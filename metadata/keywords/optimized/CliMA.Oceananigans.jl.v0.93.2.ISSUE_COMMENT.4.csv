quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,wiki,url,total_similar,target_keywords,target_matched_words
Integrability,"ld not even look at ZarrNative.jl, since it is still very young and rather a prototype.; > ; > I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool. Thanks so much for working on NetCDF.jl! I didn't mean to sound ungrateful about NetCDF.jl's performance. We were just debating which package to use. With https://github.com/JuliaGeo/NetCDF.jl/issues/87 fixed, I think we'll be happy for a long time. The `compress=9` bug explains why the IO was slow. @glwagner has suggested that for a project of our scale we'd want to help and contribute to the packages we use. We definitely want to stick with NetCDF as it's the _de facto_ standard in the climate, atmospheric, and ocean sciences. A discussion might be helpful down the line. With faster IO I think we're happy now and we're still figuring how to do IO long-term. > My feeling is that if you want to write NetCDF files through the HDF API that it will be more work, though I never tried.; > ; > Regarding NetCDF.jl & NCDatasets.jl, I feel that the statements in the OP that NetCDF.jl is not being maintained and that NCDatasets.jl grew out of bugs not being fixed is are a bit of a misrepresentation.; > ; > For installations and dependency reduction, hopefully the new HDF5 release, which will for the first time support cross compilation, will lead to HDF5.jl switching to BinaryBuilder, which will allow NetCDF.jl to do the same. Also with the Clang.jl improvements we can regenerate the bindings. I still hope that NetCDFand NCDatasets will be able to share more code in the future, and be mainly about exposing different user facing APIs. Thanks for the feedback! My thinking was the same, why use HDF5.jl when NetCDF.jl and NCDatasets.jl exist since we want NetCDF output in the end. Sorry if I misrepresented the two packages, it was just what I gleaned by skimming a few issues and PRs. Will definitely keep a look out for new HDF5 releases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847:2875,depend,dependency,2875,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847,1,['depend'],['dependency']
Integrability,"lem is generic and cannot be solved in general for arbitrary time steps. Here's a few thoughts:. - Reading about [Kahan summation](https://en.wikipedia.org/wiki/Kahan_summation_algorithm) makes it clear that we simply cannot avoid errors if we would like to add a small floating point number (the time step) to a very large number (the model time). . - I think the issue with the time-step is whether or not we can compute the RHS of the pressure Poisson equation accurately --- which is `div(u') / Δt`, where `u' = u + Δt * Gu` is the predictor velocity and `div` is the divergence. This is interesting, because I could not figure out why we would ever find large `div(u')` with small `Δt` even in this MWE. But now I realize that because of the status of the immersed Poisson solver, the velocity along the boundary is divergent, strongly so. So, `div(u')` is large along the boundary. And when we divide by `Δt` we get something huge. The magnitude of `div(u')` also somehow seems to depend on the time step (as does the magnitude of the spurious circulation). The correct solution to this case remains at rest of course. (An aside is that this problem _could_ be avoided by separately computing the hydrostatic pressure, and then using a special horizontal gradient operators that avoid computing a hydrostatic pressure gradient across an immersed boundary. However, this would only be correct for no-flux boundary conditions on buoyancy on side walls). Anyways, apparently because of this issue with the immersed pressure solver, it seems that `div(u')` is large (because `div(u)` is large) even when `Δt = O(1e-14)`... - As a result of all of this I am confused about whether this MWE is actually reliable for debugging the issue. I guess we should expect to see problems simply when `Δt = O(eps)` because this is when `div(u') / Δt` cannot be reliably computed, I think. This leads to a fairly simple criteria for the time step that's compatible with the pressure correction. But as noted in t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136:1031,depend,depend,1031,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136,1,['depend'],['depend']
Integrability,"libcublasLt.so.11 with link time reference; ```. and. ```; Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-5/clima/oceananigans/test/test_hydrostatic_free_surface_models.jl:197; Test threw exception; Expression: time_step_hydrostatic_model_works(grid; free_surface); CUBLASError: the GPU program failed to execute (code 13, CUBLAS_STATUS_EXECUTION_FAILED); Stacktrace:; [1] throw_api_error(res::CUDA.CUBLAS.cublasStatus_t); @ CUDA.CUBLAS ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/libcublas.jl:11; [2] macro expansion; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/libcublas.jl:24 [inlined]; [3] cublasDnrm2_v2(handle::Ptr{CUDA.CUBLAS.cublasContext}, n::Int64, x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, incx::Int64, result::Base.RefValue{Float64}); @ CUDA.CUBLAS ~/.julia-10861/packages/CUDA/q3GG0/lib/utils/call.jl:26; [4] nrm2; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/wrappers.jl:168 [inlined]; [5] nrm2; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/wrappers.jl:173 [inlined]; [6] norm; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/linalg.jl:108 [inlined]; [7] norm; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/linalg.jl:107 [inlined]; [8] cg_iterator!(x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Pl::Oceananigans.Solvers.SparseInversePreconditioner{CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}}; abstol::Float64, reltol::Float64, maxiter::Int64, statevars::IterativeSolvers.CGStateVariables{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, initially_zero::Bool); @ IterativeSolvers ~/.julia-10861/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [9] cg!(x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abstol::Float64, reltol::Float64, maxiter::Int64, log::Bool, statevars::IterativeSolvers.CGStateVariables{Float64, Cu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1489524526:1326,wrap,wrappers,1326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1489524526,1,['wrap'],['wrappers']
Integrability,"looks really cool - nice work!; On Apr 4, 2022, 11:13 AM -0700, Gregory L. Wagner ***@***.***>, wrote:; > Here's a video from the sediment_entrainment.jl validation case:; > https://user-images.githubusercontent.com/15271942/161605652-7e1596b0-f76e-4076-902f-6b4e7c78cfae.mp4; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1087890684:402,Message,Message,402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1087890684,1,['Message'],['Message']
Integrability,"lots/ld3vC_R3lk8.ji.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-1/clima/oceananigans/docs/make.jl:6; &nbsp; | 🚨 Error: The command exited with status 1. ```. CPU test; ```; [8] test() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:72; --; &nbsp; | [9] top-level scope at none:1; &nbsp; | Union{},Union{},Tuple{},NamedTuple{(test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; ERROR: failed process: Process(`/storage7/buildkite-agent/.julia-2556/artifacts/2fcd463fb9498f362be9d1c4ef70a63c920b0e96/bin/mpiexec -np 4 /storage7/buildkite-agent/julia-1.5.4/bin/julia -O0 --color=yes -e 'using Pkg; Pkg.test()'`, ProcessExited(1)) [1]; &nbsp; | &nbsp;; &nbsp; | Stacktrace:; &nbsp; | [1] pipeline_error at ./process.jl:525 [inlined]; &nbsp; | [2] run(::Cmd; wait::Bool) at ./process.jl:440; &nbsp; | [3] run(::Cmd) at process.jl:438; &nbsp; | [4] (::var""#1#2"")(::Cmd) at none:4; &nbsp; | [5] (::MPI.var""#8#9""{var""#1#2""})(::String) at /storage7/buildkite-agent/.julia-2556/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [6] (::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}})() at /storage7/buildkite-agent/.julia-2556/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:79; &nbsp; | [7] withenv(::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}}, ::Pair{String,String}, ::Vararg{Pair{String,String},N} where N) at env.jl:161; &nbsp; | [8] mpiexec(::MPI.var""#8#9""{var""#1#2""}; adjust_PATH::Bool, adjust_LIBPATH::Bool) at /storage7/buildkite-agent/.julia-2556/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:78; &nbsp; | [9] mpiexec(::Function) at /storage7/buildkite-agent/.julia-2556/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:61; &nbsp; | [10] mpiexec(::var""#1#2"") at /storage7/buildkite-agent/.julia-2556/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [11] top-level scope at none:4; &nbsp; | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842643141:2418,wrap,wrappers,2418,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842643141,3,['wrap'],['wrappers']
Integrability,"m and tracer fluxes at boundaries where there's an unresolved or partially-resolved turbulent boundary layer (rather than prescribing a particular value or gradient). That said, I think if we are able to specify the gradients of a field across a boundary it will likely be straightforward to extend that implementation to specifying fluxes. The paper. > [""Moving from momentum transfer to heat transfer – A comparative study of an advanced Graetz-Nusselt problem using immersed boundary methods""](https://www.sciencedirect.com/science/article/pii/S0009250918306250) by Lu et al. (2019). may also be relevant. Their conclusion is a bit confusing. They state. > In all simulations, excellent agreement are reached between CFM and DFM results, with the deviation being below 10%. which suggests that _accuracy_ may not be an important factor in deciding which method to use. But the next sentence is. > Considering the nature of capturing the discontinuity at the fluid-solid interface, DFM might offer a more accurate result, which however requires more follow-up simulations to give a solid investigation. which is difficult to interpret. I suppose all they can say is that their results are similar to one another, but they cannot say which one is more accurate (and perhaps it doesn't matter which method is more accurate in their case, if both methods return similar results). That said, I think time-step considerations are really important, and seem like a good reason to choose DFM over CFM. . Balaras (2004)'s pressure equation is. <img width=""868"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/95799302-36f2c280-0cc2-11eb-9342-a2b47a1cfdfa.png"">. where, crucially, `Ω` is the _computational_ domain (irrespective of the immersed boundary). So following Balaras (2004) would mean _not_ modifying the pressure solver? That's good news!. Does it make sense to first implement an algorithm that assumes the boundary coincides with the grid?. I am not super worried about the a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707401128:1217,interface,interface,1217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707401128,1,['interface'],['interface']
Integrability,"m::Simulation{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.Offs...; 781 0 @Base/boot.jl 360 eval; 781 0 @Base/loading.jl 1116 include_string(mapexpr::typeof(identity), mod::Module, code::String, filename::String); 781 0 @Base/loading.jl 1170 _include(mapexpr::Function, mod::Module, _path::String); 781 0 @Base/Base.jl 386 include(mod::Module, _path::String); 781 0 @Base/client.jl 285 exec_options(opts::Base.JLOptions); 781 0 @Base/client.jl 485 _start(); 796 796 @Cassette/src/context.jl ? overdub; 821 0 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl 36 _right_biased_interpolate_yᵃᶠᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci...; 821 0 @Oceananigans/src/Advection/upwind_biased_advective_fluxes.jl 85 overdub; 860 860 @KernelAbstractions/src/compiler/contract.jl 18 sub_float_contract; 860 0 @KernelAbstractions/src/compiler.jl 46 overdub; 873 0 @Oceananigans/src/Advection/weno_fifth_order.jl 148 overdub; 879 0 @Oceananigans/src/Operators/difference_operators.jl 23 δyᵃᶜᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twice...; 903 0 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl 36 _right_biased_interpolate_yᵃᶠᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci...; 903 0 @Oceananigans/src/Advection/upwind_biased_advective_fluxes.jl 31 overdub; 911 0 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl 36 _left_biased_interpolate_xᶠᵃᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, Offs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846:31932,contract,contract,31932,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846,1,['contract'],['contract']
Integrability,"mage"" src=""https://user-images.githubusercontent.com/15271942/163682350-9c0e83e4-48c2-488d-8a2a-67c1c896faf8.png"">. Since I had to dig deep into the immersed boundary implementation, I made a few more long-needed changes:. * Finally, we directly serialize `ImmersedBoundaryGrid`; * I changed `ImmersedBoundaryGrid.grid` (eminently confusing!) to `ImmersedBoundaryGrid.underlying_grid` to emphasize that there are ""two grids"" --- one underlying rectangular grid, and an overlying ""immersed grid""; * I cleaned up the output writers utilities a bit as well.; * I built out and hopefully clarified out ""node condition"" functionality. There are now a few functions:; - `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); - `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells.; - `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells.; - `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes).; - `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells. I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. * It seems ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430:1145,interface,interfaces,1145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430,1,['interface'],['interfaces']
Integrability,"mark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_Δ, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_Δ, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; > docs/src/physics/incompressible_model.md:# Incompressible model; > docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; > docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; > src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model constructor; > validation/immersed_boundaries/flow_around_cylinder.jl:# setting up incompressible model with immersed boundary; > ```; > ; > If you're okay with it I can make these alterations myself (idk what are the protocols about modifying other people's PRs...). Thanks that's helpful!; Hm... Are you sure you are looking at the latest version? Because some of those incompressible things I've changed already!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:2772,protocol,protocols,2772,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932,1,['protocol'],['protocols']
Integrability,"maximum iterations for this test are 20 with a 128 grid size, so I think we need to exclude the boundary condition possibility and look at other synchronization issues (maybe particular to the shallow water model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430067998:145,synchroniz,synchronization,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430067998,1,['synchroniz'],['synchronization']
Integrability,"model ""state""; for example, ghost cell values and nonlinear diffusivities depend on the velocity and tracer fields, in general. We currently handle this only during time-stepping --- there is no guarantee, for example, that the diffusivities or ghost cell values are consistent with the velocity field if the velocity field is set by the function `set!` (in fact, the diffusivities are *always* inconsistent with the current velocity field due to the fact that they are calculated *prior* to taking a time-step). If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). What does the jargon ""sounding"" mean?. Merger means we need to think carefully about how to reduce boilerplate to minimize (within reason) the cost of maintaining two parallel models as we develop their shared subcomponents. I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. In this paradigm, a ""Model"" is reduced to numerics + physics specification. This would be easy to implement (while I think an `Equation` abstraction would be relatively difficult due to myriad difficult design problems, including the abstraction of tuples of terms with heterogeneous function signatures, numerical aspects of the equation, implicit vs explicit treatment of terms, etc).; The `Simulation` type can then be used to ""run"" simulations over multiple time steps, eg. ```julia; simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); run!(simulation); ```. and is tasked with managing things like output writing, diagnostics calculation, adaptive time-stepping, and progress logging. Each `Model` then simply needs to define a function that performs a single time-step to interface with `Simulation`. This is discussed further in #447. Such a orthogonalization of the code means we",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671:1233,wrap,wraps,1233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671,1,['wrap'],['wraps']
Integrability,"mplement more sophisticated immersed boundary methods such as partial cells and shaved cells. In those methods, the presence of the immersed boundary is felt at a fundamental level during the calculation of grid areas and volumes. The `internal_tide.jl` validation experiment has also been refactored and now reads:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; using Plots. grid = RegularRectilinearGrid(size=(256, 256), x=(-10, 10), z=(0, 5), topology=(Periodic, Flat, Bounded)). # Gaussian bump of width ""1""; bump(x, y, z) = z < exp(-x^2). grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). # Tidal forcing; tidal_forcing(x, y, z, t) = 1e-4 * cos(t). model = HydrostaticFreeSurfaceModel(grid = grid_with_bump,; momentum_advection = CenteredSecondOrder(),; free_surface = ExplicitFreeSurface(gravitational_acceleration=4),; closure = IsotropicDiffusivity(ν=1e-4, κ=1e-4),; tracers = :b, ; buoyancy = BuoyancyTracer(),; coriolis = FPlane(f=sqrt(0.5)),; forcing = (u = tidal_forcing,)). # Linear stratification; set!(model, b = (x, y, z) -> 2 * z). progress(s) = @info ""Time = $(s.model.clock.time), max|w|: $(maximum(abs, model.velocities.w))""; ; simulation = Simulation(model, Δt = 1e-3, stop_time = 10, progress = progress, iteration_interval = 10) ; ; run!(simulation). xu, yu, zu = nodes(model.velocities.u); u = interior(model.velocities.u)[:, 1, :]. umax = maximum(abs, u); ulim = umax / 2 ; ulevels = vcat(-[umax], range(-ulim, stop=ulim, length=30), [umax]) . xu2 = reshape(xu, grid.Nx, 1); zu2 = reshape(zu, 1, grid.Nz); u[bump.(xu2, 0, zu2)] .= NaN . u_plot = heatmap(xu, zu, u'; title = ""x velocity"", color = :balance, clims = (-ulim, ulim)). display(u_plot); ```. Note that the small time-step is near the gravity wave CFL for an explicit free surface on the specified grid. Somewhat larger time-steps are possible with an `ImplicitFreeSurface` but it seems the overall integration is slower that way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305:2423,integrat,integration,2423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305,1,['integrat'],['integration']
Integrability,"mplicitFreeSurface,; FreeSurface,; PCGImplicitFreeSurfaceSolver,; implicit_free_surface_step!. function set_simple_divergent_velocity!(model); # Create a divergent velocity; grid = model.grid. u, v, w = model.velocities; η = model.free_surface.η. u .= 0; v .= 0; η .= 0. # pick a surface cell at the middle of the domain; i, j, k = Int(floor(grid.Nx / 2)) + 1, Int(floor(grid.Ny / 2)) + 1, grid.Nz. inactive_cell(i, j, k, grid) && error(""The nudged cell at ($i, $j, $k) is inactive.""). if grid isa RectilinearGrid; Δy = grid.Δyᵃᶜᵃ; end. if grid isa LatitudeLongitudeGrid; Δy = grid.Δyᶜᶠᵃ; end. if grid isa ImmersedBoundaryGrid; if grid isa ImmersedBoundaryGrid && grid.underlying_grid isa RectilinearGrid; Δy = grid.underlying_grid.Δyᵃᶜᵃ; elseif grid.underlying_grid isa LatitudeLongitudeGrid; Δy = grid.underlying_grid.Δyᶜᶠᵃ; end; end. Δz = CUDA.@allowscalar grid.Δzᵃᵃᶜ. # We prescribe the value of the zonal transport in a cell, i.e., `u * Δy * Δz`. This; # way `norm(rhs)` of the free-surface solver does not depend on the grid extensd/resolution.; transport = 1e5 # m³ s⁻¹; CUDA.@allowscalar u[i, j, k] = transport / (Δy * Δz). update_state!(model). return nothing; end. arch = CPU(). rectilinear_grid = RectilinearGrid(arch, size = (128, 1, 5),; x = (-5000kilometers, 5000kilometers),; y = (0, 100kilometers),; z = (-500, 0),; topology = (Bounded, Periodic, Bounded)). Lz = rectilinear_grid.Lz; width = rectilinear_grid.Lx / 20. bump(x, y) = - Lz * (1 - 0.2 * exp(-x^2 / 2width^2)). grid = ImmersedBoundaryGrid(rectilinear_grid, GridFittedBottom(bump)). free_surface = ImplicitFreeSurface(solver_method=:PreconditionedConjugateGradient,; abstol=1e-15, reltol=0). model = HydrostaticFreeSurfaceModel(; grid,; momentum_advection = nothing,; free_surface). set_simple_divergent_velocity!(model). @show model.velocities.u. events = ((device_event(arch), device_event(arch)), (device_event(arch), device_event(arch))). Δt = 900.0; implicit_free_surface_step!(model.free_surface, model, Δt, 1.5, events",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247333938:1279,depend,depend,1279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247333938,1,['depend'],['depend']
Integrability,"nd see an unfamiliar function so I scroll to the top to see where it was imported from. If the `import` statement is in the module file, then I have to scroll through a screenful of import statements in another file in search of the relevant line. > What is the problem that this change would solve? If one is reading code in a file, and an unfamiliar function appears, one presumably looks to the top-level to see where it is imported. If one is reading a module, why is it crucial to know where in the code the package is used?. It solves two problems: messy module files, and makes it easier to understand where import statements are used. Maybe we do things differently, but I always scroll to the top of the current file to look for import statements. I've never thought to look the module top-level file. Additionally, a list of import statements at the top of the file tell me what to expect in this file. I always skim the import statements before reading a file, although this may be Pythonic behavior haha. > This new convention could create issues in which functionality from a package imported in one file is used elsewhere, making it hard to trace exactly where an unfamiliar function first arrived in the namespace. Or, if two packages conflict with one another. In julia, resolving method conflicts when two packages export the same name can be tricky and the resolution depends on the order in which packages are imported. We can break with convention when needed, but presumably this is the rare exception rather than rule. > I think having more submodules (#495, #456) is really the right solution to this problem; in that case each module is short so the issue of tracing import statements to usage within a huge module is alleviated. Yeah maybe after we have more submodule it'll be clearer how to tackle this issue and maybe it won't be as bad. Although I think some refactoring/reorganizing/reordering of import statements may be needed to make the import statements more local.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-547225547:2502,depend,depends,2502,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-547225547,1,['depend'],['depends']
Integrability,"nd; end. @inline δx²_c2f2c(g::RegularCartesianGrid, f, i, j, k) = δx_c2f(g, f, incmod1(i, g.Nx), j, k) - δx_c2f(g, f, i, j, k). @inline function δy²_c2f2c(g::RegularCartesianGrid, f, i, j, k); if j == g.Ny; return -δy_c2f(g, f, i, j, k); else; return δy_c2f(g, f, i, j+1, k) - δy_c2f(g, f, i, j, k); end; end. @inline function δz²_c2f2c(g::RegularCartesianGrid, f, i, j, k); if k == g.Nz; return δz_c2f(g, f, i, j, k); else; return δz_c2f(g, f, i, j, k) - δz_c2f(g, f, i, j, k+1); end; end. @inline function ∇²_pnn(g::RegularCartesianGrid, f, i, j, k); 	(δx²_c2f2c(g, f, i, j, k) / g.Δx^2) + (δy²_c2f2c(g, f, i, j, k) / g.Δy^2) + (δz²_c2f2c(g, f, i, j, k) / g.Δz^2); end. function ∇²_pnn!(grid::RegularCartesianGrid, f, ∇²f); @loop for k in (1:grid.Nz; blockIdx().z); @loop for j in (1:grid.Ny; (blockIdx().y - 1) * blockDim().y + threadIdx().y); @loop for i in (1:grid.Nx; (blockIdx().x - 1) * blockDim().x + threadIdx().x); @inbounds ∇²f[i, j, k] = ∇²_pnn(grid, f, i, j, k); end; end; end. @synchronize; end. function solve_poisson_3d_pnn!(g::RegularCartesianGrid, f::CellField, ϕ::CellField); kx² = zeros(g.Nx, 1); ky² = zeros(g.Ny, 1); kz² = zeros(g.Nz, 1). for i in 1:g.Nx; kx²[i] = (2sin((i-1)*π/g.Nx) / (g.Lx/g.Nx))^2; end; for j in 1:g.Ny; ky²[j] = (2sin((j-1)*π/(2g.Ny)) / (g.Ly/g.Ny))^2; end; for k in 1:g.Nz; kz²[k] = (2sin((k-1)*π/(2g.Nz)) / (g.Lz/g.Nz))^2; end. FFTW.r2r!(f.data, FFTW.REDFT10, [2, 3]); FFTW.fft!(f.data, 1). for k in 1:g.Nz, j in 1:g.Ny, i in 1:g.Nx; @inbounds ϕ.data[i, j, k] = -f.data[i, j, k] / (kx²[i] + ky²[j] + kz²[k]); end; ϕ.data[1, 1, 1] = 0. FFTW.ifft!(ϕ.data, 1). @. ϕ.data = real(ϕ.data) / (2g.Ny*2g.Nz). FFTW.r2r!(ϕ.data, FFTW.REDFT01, [2, 3]). nothing; end. function poisson_pnn_planned_div_free_cpu(ft, Nx, Ny, Nz, planner_flag); g = RegularCartesianGrid(ft, (Nx, Ny, Nz), (100, 100, 100)). RHS = CellField(Complex{ft}, CPU(), g); RHS_orig = CellField(Complex{ft}, CPU(), g); ϕ = CellField(Complex{ft}, CPU(), g); ∇²ϕ = CellField(Complex{ft}, CPU(), g). RH",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-483896344:2000,synchroniz,synchronize,2000,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-483896344,1,['synchroniz'],['synchronize']
Integrability,"nditions(computational_grid, top = FluxBoundaryCondition(Qᵘ)). @inline Qˢ(x, y, t, S, evaporation_rate) = - evaporation_rate * S; evaporation_rate = 1e-3 / hour; evaporation_bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); S_bcs = TracerBoundaryConditions(computational_grid, top=evaporation_bc); model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=1e-4),; buoyancy = buoyancy,; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bcs)); # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise; # Temperature initial condition: a stable density gradient with random noise superposed.; Tᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z); # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z); # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, w=uᵢ, T=Tᵢ, S=35); cfl=AdvectiveCFL(0.1); start_time = time_ns() # so we can print the total elapsed wall time; # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, cfl: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; cfl(model), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)); simulation = Simulation(model, Δt=0.1, stop_time=40minutes, iteration_interval=10,; progress=progress_message,parameters=(;cfl)); # Create a NamedTuple with eddy viscosity; eddy_viscosity = (νₑ = model.diffusivities.νₑ,); simulation.output_writers[:slices] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers, eddy_viscosity),; prefix = ""ocean_wind_mixing_and_convection2"",; field_slicer = FieldSlicer(j=Int(computational_grid.Ny/2)),; schedule = TimeInterval(1minute),; force = true); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351:2601,message,message,2601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351,1,['message'],['message']
Integrability,"nelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, typeof(Oceananigans.Fields.gpu__regrid!)})(::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; ndrange::Nothing, dependencies::Nothing, workgroupsize::Nothing, progress::Function); @ CUDAKernels /g/data/v45/nc3020/.julia/packages/CUDAKernels/YWLqR/src/CUDAKernels.jl:273; [15] launch!(::GPU, ::RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Symbol, ::typeof(Oceananigans.Fields._regrid!), ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:10915,depend,dependencies,10915,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574,1,['depend'],['dependencies']
Integrability,"nigans.AbstractOperations.ConditionalOperation{…}; call_kwargs::@Kwargs{…}); @ CUDA ./none:0; [18] (::CUDA.HostKernel{…})(::Function, ::Vararg{…}; threads::Int64, blocks::Int64, kwargs::@Kwargs{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:345; [19] macro expansion; @ ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:637; [27] top-level scope; @ REPL[10]:1; [28] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; Some type information was truncated. Use `show(err)` to see complete types.; ```. That suggests that it's because the package dependencies on `main` were resolved with Julia v1.9.3. ```julia; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.3). Unexpected behavior may occur.; ```. This issue will be resolved when #3403 is merged.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:9579,depend,dependencies,9579,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372,2,['depend'],['dependencies']
Integrability,"nst); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:4770; [6] (::Enzyme.Compiler.var""#201#202"")(B::Ptr{LLVM.API.LLVMOpaqueBuilder}, OrigCI::Ptr{LLVM.API.LLVMOpaqueValue}, gutils::Ptr{Nothing}, tape::Ptr{LLVM.API.LLVMOpaqueValue}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:6657; [7] EnzymeCreatePrimalAndGradient(logic::Enzyme.Logic, todiff::LLVM.Function, retType::Enzyme.API.CDIFFE_TYPE, constant_args::Vector{…}, TA::Enzyme.TypeAnalysis, returnValue::Bool, dretUsed::Bool, mode::Enzyme.API.CDerivativeMode, width::Int64, additionalArg::Ptr{…}, forceAnonymousTape::Bool, typeInfo::Enzyme.FnTypeInfo, uncacheable_args::Vector{…}, augmented::Ptr{…}, atomicAdd::Bool); @ Enzyme.API ~/Projects/Enzymantics/Enzyme.jl/src/api.jl:141; [8] enzyme!(job::GPUCompiler.CompilerJob{…}, mod::LLVM.Module, primalf::LLVM.Function, TT::Type, mode::Enzyme.API.CDerivativeMode, width::Int64, parallel::Bool, actualRetType::Type, wrap::Bool, modifiedBetween::Tuple{…}, returnPrimal::Bool, jlrules::Vector{…}, expectedTapeType::Type, loweredArgs::Set{…}, boxedArgs::Set{…}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:7715; [9] codegen(output::Symbol, job::GPUCompiler.CompilerJob{…}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, toplevel::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9278; [10] codegen; @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:8886 [inlined]; [11] _thunk(job::GPUCompiler.CompilerJob{Enzyme.Compiler.EnzymeTarget, Enzyme.Compiler.EnzymeCompilerParams}, postopt::Bool) (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9830; [12] cached_compilation; @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9864 [inlined]; [13] (::Enzyme.Compiler.var""#474#475""{DataType, DataType, DataType, Enzyme.API.CDerivativeMode, Tuple{Bool, Bool, Bool}, Int64, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259:1994,wrap,wrap,1994,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259,1,['wrap'],['wrap']
Integrability,"o @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:1257,synchroniz,synchronize,1257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654,2,['synchroniz'],['synchronize']
Integrability,"ocs. addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers. Launches worker processes via the specified cluster manager. For example, Beowulf clusters are supported via a custom cluster manager implemented in the package ClusterManagers.jl. The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable; JULIA_WORKER_TIMEOUT in the worker process's environment. Relevant only when using TCP/IP as transport. To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute addprocs in its own task. Examples; ≡≡≡≡≡≡≡≡≡≡. # On busy clusters, call `addprocs` asynchronously; t = @async addprocs(...). # Utilize workers as and when they come online; if nprocs() > 1 # Ensure at least one new worker is available; .... # perform distributed execution; end. # Retrieve newly launched worker IDs, or any error messages; if istaskdone(t) # Check if `addprocs` has completed to ensure `fetch` doesn't block; if nworkers() == N; new_pids = fetch(t); else; fetch(t); end; end. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers. Add worker processes on remote machines via SSH. Configuration is done with keyword arguments (see below). In particular, the exename keyword; can be used to specify the path to the julia binary on the remote machine(s). machines is a vector of ""machine specifications"" which are given as strings of the form [user@]host[:port] [bind_addr[:port]]. user defaults to; current user and port to the standard SSH port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified; bind_addr and port. It is possible to launch multiple processes on a remote host by using a tuple in the machines vector or the fo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:1006,message,messages,1006,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['message'],['messages']
Integrability,oh @francispoulin I now saw your message!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2576#issuecomment-1139116592:33,message,message,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2576#issuecomment-1139116592,1,['message'],['message']
Integrability,"oh now I saw that the secondary hidden commit message talks about ""a bug...""; can you reproduce the bug here? I mean, can you tell me how to reproduce the bug because I don't know exactly what you are talking about... (there is a chance you may need to delete the dowloaded `.jld2` file to force DataDeps to download it again... perhaps that's your issue -- I'm not sure)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023542504:46,message,message,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023542504,1,['message'],['message']
Integrability,"oh sorry, I just saw your reply... ; indeed the problem was with CUDA... I fixed it!. (I removed my question though... just putting this here in case the messages seem strange for the git-archaeologists of the next century.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1638#issuecomment-839420992:154,message,messages,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1638#issuecomment-839420992,1,['message'],['messages']
Integrability,"on for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would then cover cases like `AnisotropicMinimumDissipation`, and move the free parameters associated with AMD from the turbulence closure struct into the viscosity struct. The first design is ""flatter"", and therefore exposes data like free parameters a bit more. The second design is more ""hierarchical"", which reduces boilerplate but is a little bit more complex. That's the trade-off I see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:1529,interface,interface,1529,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943,2,['interface'],['interface']
Integrability,or at least we could try following that route (it seems like there were some problems also with that implementation),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3662#issuecomment-2251239834:40,rout,route,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3662#issuecomment-2251239834,1,['rout'],['route']
Integrability,"ordering requirements are necessary for filling corner halos. ; This is done by `Periodic` boundary conditions in non-distributed simulations.; Additionally, since communication boundary conditions can be asynchronous, distributed (and multi-region) BCS need to be filled last. To remove order requirements we would need to fill the halo for flux, value, and gradient also in the corners.; I thought that might be a good idea but we hit a problem when having an `AbstractArray` boundary condition because we would need to construct the associated `OffsetArray`. . This can be prevented by wrapping the array in a `Field` and filling the halo regions but it seems like a heavy requirement to do it, and generally, a large API change that we might want to think about a little more. In #3338 I fixed the problem by separating out communicating boundary conditions which wasn't that complicated and maintained the current logic. . Maybe in the future, we might want to eliminate the order requirement though. So we can keep this issue open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3342#issuecomment-1765302174:589,wrap,wrapping,589,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3342#issuecomment-1765302174,1,['wrap'],['wrapping']
Integrability,"ore generic interface for splitting. If we have a property called `file_splitting` that _is_ a schedule, then we can write. ```julia; NetCDFOutputWriter(model, outputs; file_splitting = TimeInterval(30days), ...); ```. Then the decision about whether to start a new file will change from. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L275. to. ```julia; writer.file_splitting(model) && start_next_file(model, writer) ; ```. Next, you will have to add a new schedule in `Utils/schedules.jl` that can split based on filesize:. ```julia; mutable struct FileSizeLargerThan <: AbstractSchedule; max_filesize :: Float64; path :: String; end. (fslt::FileSizeLargerThan)(model) = filesize(fslt.path) >= fslt.max_filesize; ```. Finally, you need to add a user interface for initializing and modifying the schedules to smooth out the user experience (for example, we don't want users to have to specify the file path more than once, and the file path that is checked by the schedule has to be updated). This will have to take two parts. In `Utils/schedules.jl`, a constructor:. ```julia; FileSizeLargerThan(max_filesize) = FileSizeLargerThan(max_filesize, """"); ```. Then in output writers, an interface to be used in both the model constructor and `write_output!`:. ```julia; update_schedule!(schedule, path) = nothing; update_schedule!(schedule::FileSizeLargerThan, path) = schedule.path = path; ```. This function `update_schedule!(writer.schedule, path)` then replaces this line. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L276. and also needs to be added in the output writer constructor so that. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L176. becomes. ```julia; filepath = joinpath(dir, filename) ; update_schedule!(schedule, filepath); ```. Make sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793:1518,interface,interface,1518,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793,1,['interface'],['interface']
Integrability,"osition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_Δ, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_Δ, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; docs/src/physics/incompressible_model.md:# Incompressible model; docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model constructor; validation/immersed_boundaries/flow_around_cylinder.jl:# setting up incompressible model with immersed boundary; ```. If you're okay with it I can make these alterations myself (idk what are the protocols about modifying other people's PRs...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:2718,protocol,protocols,2718,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326,1,['protocol'],['protocols']
Integrability,"periments. > ; > > We may also need to implement a correction that ensures mass conservation, as described just before section 5 here:; > > http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.70.3860&rep=rep1&type=pdf; > ; > Unless I'm missing something this seems trivial (some good news!). I believe we'll need to insert a mass correction step into our algorithm (perhaps after fill halo regions in update state?) and how to decide when we need it. I think we'll need it both for non-zero inflow conditions (so `Open` boundaries with conditions other than `nothing` / 0`) and outflow conditions like Orlanski. > ; > > For this to work properly, we need to modify the pressure solver to work for time-dependent inflows; > ; > This seems far from trivial. But I'm assuming this was implemented when you guys implemented cubed sphere capabilities, no?. We only support hydrostatic cubed sphere simulations, so we did not implement an algorithm for accurate non-hydrostatic pressure solves with time-dependent boundary conditions when implementing the cubed sphere. The algorithm is known (I have a sketch, though some effort should be devoted to writing it up in the documentation); we only need to design a useful software abstraction. The main issue is that the right hand side of the pressure Poisson equation depends on the _time-derivative_ of the wall-normal velocity. This means that we need to store the wall-normal velocity at a prior time-step. We can probably redesign the implementation of the `Open` boundary condition for this purpose, and add code to `solve_for_pressure!` that adds these contributions when necessary: ; https://github.com/CliMA/Oceananigans.jl/blob/73be08d708131a66402eb8fc0086c47ef80a2d0e/src/Models/NonhydrostaticModels/solve_for_pressure.jl#L23-L39. > ; > CC @zhazorken. One possible route forward is to first implement the Orlanski boundary condition and setup a few validation experiments before deciding whether the pressure solver modifications are needed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/833#issuecomment-934615920:1765,depend,depends,1765,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/833#issuecomment-934615920,2,"['depend', 'rout']","['depends', 'route']"
Integrability,"r constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl= CFL, Δt = initial_timestep, max_change = max_allowable_change_in_Δt, max_Δt = maximum_Δt). # A type for calculating adaptive time steps based on capping the CFL number at `cfl`.; # On calling `update_Δt!(wizard, model)`, the `TimeStepWizard` computes a time-step such that; # ``cfl = max(u/Δx, v/Δy, w/Δz) Δt``, where ``max(u/Δx, v/Δy, w/Δz)`` is the maximum ratio; # between model velocity and along-velocity grid spacing anywhere on the model grid. The new; # `Δt` is constrained to change by a multiplicative factor no more than `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time= stop_time_info, iteration_interval = iteration_interval_info,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = Name_of_simulation,; schedule = TimeInterval(0.2minute),; force = true). run!(simulation). using JLD2. using Plots. # load(""modified_open_ocean_convection_Fplane_GPU.jld2""). file = jldopen(""ocean_convection_Fplane_Vertical_strecthed_grid.jld2""). # Coordinate arrays; xC, yC, zC = file[""grid/xC""][1:256],file[""grid/yC""][1:256],file[""grid/zC""][1:65]; Lx, Ly, Lz = file[""grid/Lx""],file[""grid/Ly""],file[""grid/Lz""]. # Extract a vector of iterations; iterations = parse.(Int, keys(file[""timeseries/t""])). @in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999:5259,message,message,5259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999,1,['message'],['message']
Integrability,r/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/lib/pkgconfig:/glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/lib/pkgconfig:/glade/u/apps/casper/23.10/spack/opt/spack/ucx/1.14.1/gcc/7.5.0/vf2h/lib/pkgconfig:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/lib/pkgconfig:/glade/u/apps/casper/23.10/opt/view/lib64/pkgconfig:/glade/u/apps/casper/23.10/opt/view/lib/pkgconfig; INFOPATH = :/glade/u/apps/casper/23.10/opt/view/share/info:/usr/local/share/info:/usr/share/info; NCAR_LDFLAGS_JULIA = /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.9.2/gcc/7.5.0/mjea/lib; NCAR_LDFLAGS_HDF5 = /glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/lib; NCAR_WRAPPER_MPI_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6/bin/mpi; __LMOD_STACK_LMOD_PACKAGE_PATH = L2dsYWRlL3dvcmsvY3NndGVhbS9zcGFjay1kZXBsb3ltZW50cy9jYXNwZXIvMjMuMTAvZW52cy9wdWJsaWMvdXRpbA==:L2dsYWRlL3dvcmsvY3NndGVhbS9zcGFjay1kZXBsb3ltZW50cy9jYXNwZXIvMjMuMTAvZW52cy9wdWJsaWMvdXRpbA==; ```; and the status check message gave me:; ```; Status `~/.julia/environments/v1.9/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; [79e6a3ab] Adapt v4.0.4; ⌅ [4fba245c] ArrayInterface v7.7.1; [a9b6321e] Atomix v0.1.0; [ab4f0b2a] BFloat16s v0.5.0; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.4.3; [1af6417a] CUDA_Runtime_Discovery v0.3.4; [d360d2e6] ChainRulesCore v1.24.0; [3da002f7] ColorTypes v0.11.5; [5ae59095] Colors v0.12.11; [1fbeeb36] CommonDataModel v0.3.6; [34da2185] Compat v4.15.0; [187b0558] ConstructionBase v1.5.5; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [9a962f9c] DataAPI v1.16.0; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.20; [e2d170a0] DataValueInterfaces v1.0.0; ⌅ [3c3547ce] DiskArrays v0.3.23; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [b305315f] Elliptic v1.0.1; [e2ba6199] ExprTools v0.1.10; [7a,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:15985,message,message,15985,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['message'],['message']
Integrability,"rection to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this change brings the experience of reading Oceananigans code into better alignment ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:1485,depend,depend,1485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405,1,['depend'],['depend']
Integrability,"red buoyancy frequency) should be calculated using the local thermal expansion coefficient and haline contraction coefficient (the analytical derivatives of the equation of state with respect to temperature and salinity at constant depth) --- This is (apparently) a more accurate approximation to the buoyancy gradient than calculating the buoyancy gradient with finite differences of buoyancy at different vertical levels. But this means that all equations of state should define functions that return these coefficients. In addition, we will supply a function to calculated the buoyancy frequency squared (I'm currently calling it `N2`). 3. For Boussinesq equations of state, we do not require the non-static components of pressure as input; instead we use the geopotential depth (corresponding to the use of hydrostatic pressure, `ρ₀ g depth`, to calculate compressive / thermobaric effects on density). At the moment we thus only require `-z` as an input --- though we may need to generalize the buoyancy implementation in the future if for some reason calculating the 'geopoential depth' requires more information (like free surface elevation). Luckily, this is a small change that just requires changing the function arguments to `buoyancy_perturbation`; etc. 4. The name `buoyancy_perturbation` is ok. It is actually potentially confusing, since ""buoyancy"" in ordinary usage is *already* associated explicitly with density anomalies --- rather than static, typically constant or z-dependent components of the density profile. So I think calling this function simply `buoyancy` might be better. On the other hand, we probably want to use `model.buoyancy` to refer to the model field that holds buoyancy-related parameters. Because of that we may want to stick with `buoyancy_perturbation`. Any ideas / alternative suggestions? An alternative is to perform a translation in the kernel functions; aka use `buoyancy_params` in the function signature of kernel(s) that call the function `buoyancy`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532995557:1786,depend,dependent,1786,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532995557,1,['depend'],['dependent']
Integrability,"riodic, Flat} on CPU with 3×3×0 halo; ├── operand: Reducing sum! over dims 1 of 256×256×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0; ```. `Integral` is actually similar for me:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(256, 256), extent=(1, 1), topology=(Periodic, Periodic, Flat));; c = CenterField(grid);; int_c = Field(Integral(c, dims=1)); @time compute!(int_c); @time compute!(int_c); ```. producing. ```julia; julia> @time compute!(int_c); 0.092271 seconds (182.96 k allocations: 12.615 MiB, 99.79% compilation time); 1×256×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1); ├── grid: 256×256×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── operand: Integral of BinaryOperation at (Center, Center, Center) over dims (1,); ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(int_c); 0.000061 seconds (60 allocations: 4.938 KiB); 1×256×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1); ├── grid: 256×256×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── operand: Integral of BinaryOperation at (Center, Center, Center) over dims (1,); ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0; ```. But I get similar numbers for `Average`. I think the compilation path may depend on the machine you're using (which could make sense)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643:3220,depend,depend,3220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643,1,['depend'],['depend']
Integrability,"rm of the equations. In practice, we infer *fluxes* from the user-prescribed boundary conditions, and ensure that the volume-integrated budget for each field is locally conserved. A separate issue is the distinction between direct numerical simulation and large eddy simulation of fluids. In direct numerical simulation, all scales of motion are resolved, down to the smallest scales of motion where fields are smooth due to the action of molecular diffusion. Thus in direct numerical simulation, we expect fields to smoothly vary at the grid scale, which further implies that the volume-averaged values of fields adjacent to boundaries will be *close* to satisfying the boundary conditions. Note that the values of fields still will not be exactly equal to the boundary conditions. For example, the cell-averaged velocity field adjacent to a no-slip wall is *not* zero --- it is just small. In large eddy simulation, a possibly infinite range of scales is *unresolved* by the numerical solution, depending on the ratio between the grid scale and the Kolmogorov scale below which molecular diffusion dominates. For example, a typical oceanic boundary layer simulation might have a grid resolution of 0.5 m, whereas the Kolmogorov scale can be as small as 0.1 mm (or less, especially close to boundaries). Thus a large fraction of the flow structure is unresolved on a coarse 0.5 m grid. More importantly, there is no *physical* reason to expect that *resolved* LES fields, which should be interpreted as some ""filtered"" version of the exact solution, are smooth at the grid scale. Due to this, a ""no-flux"" or ""zero gradient"" boundary conditions does not guarantee that the gradient of a field is zero across any boundary-adjacent region. Because we do not enforce gradients or values of fields at boundaries, and because coarse LES does not guarantee smoothness of fields, we do not expect the values and gradients of fields to tend to their exact values adjacent to boundaries. Note that in cases whe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/540#issuecomment-572075975:1128,depend,depending,1128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/540#issuecomment-572075975,1,['depend'],['depending']
Integrability,"rom a slack conversation... I’ll try to clarify what we found for @francispoulin and @tomchor, if I understand correctly what was happening. I think @tomchor was. 1. Initializing a velocity field using set!(model, …); 2. Constructing a computed field ∂z_u = ComputedField(∂z(model.velocities.u)); 3. Evaluating the computed field via compute!(∂z_u); 4. Plotting ∂z_u and noticing that it’s wrong on boundaries. The reason why ∂z_u is wrong on boundaries is because the vertical derivative of u is calcaluated with a second-order difference that spans the boundary, and thus depends on “halo points” that are outside the physical domain. In Oceananigans, we use halo points to enforce Periodic, Value and Gradient boundary conditions, and will eventually use them for parallelization. If ∂z_u were calculated during a simulation, the halo points of u would be filled. However, in this case ∂z_u was evaluated before invoking run!As a result, the halo points of u were not filled, and thus ∂z_u was wrong on boundaries.; One fix for this mentioned by @alir is to fill the halo points “manually” by calling fill_halo_regions(u, CPU()) after invoking `set!`. This will work provided that u does not have function boundary conditions. If the boundary conditions of u depend on other model fields or the simulation time, this will fail. The code that fills halo regions is here: https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Models/IncompressibleModels/update_incompressible_model_state.jl#L15-L16. The “real” fix for this (a more generic solution that doesn’t require magical incantations in user scripts), however, is to fill_halo_regions! within set!. In fact, an even better solution is to call update_state!(model) at the end of set!. This way nonlinear diffusivities and hydrostatic pressure are also correct. We have also discussed projecting the velocity field onto an incompressible field within set!. We could make all these changes in one PR perhaps…",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1252#issuecomment-739528131:1270,depend,depend,1270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1252#issuecomment-739528131,1,['depend'],['depend']
Integrability,"rop scaled by; delx, delz. This will be by far the most common model configuration. On Mon, May 27, 2019, 4:04 PM Ali Ramadhan <notifications@github.com> wrote:. > *@ali-ramadhan* commented on this pull request.; > ------------------------------; >; > In src/time_steppers.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/245#discussion_r287873945>; > :; >; > > @loop for j in (1:grid.Ny; (blockIdx().y - 1) * blockDim().y + threadIdx().y); >; > @loop for i in (1:grid.Nx; (blockIdx().x - 1) * blockDim().x + threadIdx().x); >; > - apply_z_top_bc!(top_bc, i, j, grid, ϕ, Gϕ, κ, t, iteration, u, v, w, T, S); >; > - apply_z_bottom_bc!(bottom_bc, i, j, grid, ϕ, Gϕ, κ, t, iteration, u, v, w, T, S); >; > +; >; > + κ_top = κ(i, j, 1, grid, closure, eos, g, u, v, w, T, S); >; > + κ_bottom = κ(i, j, grid.Nz, grid, closure, eos, g, u, v, w, T, S); >; > +; >; > + apply_z_top_bc!(top_bc, i, j, grid, ϕ, Gϕ, κ_top, t, iteration, u, v, w, T, S); >; > + apply_z_bottom_bc!(bottom_bc, i, j, grid, ϕ, Gϕ, κ_bottom, t, iteration, u, v, w, T, S); >; >; > It looks like if you want to impose a z boundary condition that does not; > depend on κ, you still have to calculate κ using the full closure which; > can be expensive if using an LES closure. Not sure how to get around this,; > probably some clever multiple dispatch?; >; > This is probably fine for now as constant Smagorinsky isn't integrated; > yet, and the performance hit probably isn't big enough to worry about right; > now.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/pull/245?email_source=notifications&email_token=AKXUEQURKUBCRVSBQUC2LQDPXQ5FPA5CNFSM4HP6AWMKYY3PNVWWK3TUL52HS4DFWFIHK3DMKJSXC5LFON2FEZLWNFSXPKTDN5WW2ZLOORPWSZGOBZZG3JY#pullrequestreview-242380199>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQXS3APE4PYPCYWURM3PXQ5FPANCNFSM4HP6AWMA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496297122:1195,depend,depend,1195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496297122,2,"['depend', 'integrat']","['depend', 'integrated']"
Integrability,"s (like the models implemented in OceanBioME) to ""opt-in"" to a substepping scheme. In this design, there's no need to change the existing ""slow"" kernels I don't think. However, we could consider changing the name of them. For example, all that's needed is for the _implementation_ to know when to return a slow source term vs fast source term. > this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at timestepper.G / $G^-$, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned timestepper.physics.G etc. I'm not sure that new tendencies are needed for substepping. The substepping scheme for CATKE manages to avoid allocating any additional tendencies by preserving the ""slow"" source term:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl#L167-L171. The only change that is needed within Oceananigans (in principle) --- as far as I can tell --- is to skip the tracer update for certain tracers (like we do for CATKE and TKEDissipation):. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L78-L85. Then the implementer of the BGC model has to perform the substepping inside `update_biogeochemical_state!`:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl#L49. Possibly we can go further and define an interface that does the substepping automatically though. I think that an effort like this would be good not to go so far, and first test ideas in a ""minimal"" implementation that simply uses `update_biogeochemical_state!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851:2321,interface,interface,2321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851,1,['interface'],['interface']
Integrability,"s developing and running validation experiments. > ; > > We may also need to implement a correction that ensures mass conservation, as described just before section 5 here:; > > http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.70.3860&rep=rep1&type=pdf; > ; > Unless I'm missing something this seems trivial (some good news!). I believe we'll need to insert a mass correction step into our algorithm (perhaps after fill halo regions in update state?) and how to decide when we need it. I think we'll need it both for non-zero inflow conditions (so `Open` boundaries with conditions other than `nothing` / 0`) and outflow conditions like Orlanski. > ; > > For this to work properly, we need to modify the pressure solver to work for time-dependent inflows; > ; > This seems far from trivial. But I'm assuming this was implemented when you guys implemented cubed sphere capabilities, no?. We only support hydrostatic cubed sphere simulations, so we did not implement an algorithm for accurate non-hydrostatic pressure solves with time-dependent boundary conditions when implementing the cubed sphere. The algorithm is known (I have a sketch, though some effort should be devoted to writing it up in the documentation); we only need to design a useful software abstraction. The main issue is that the right hand side of the pressure Poisson equation depends on the _time-derivative_ of the wall-normal velocity. This means that we need to store the wall-normal velocity at a prior time-step. We can probably redesign the implementation of the `Open` boundary condition for this purpose, and add code to `solve_for_pressure!` that adds these contributions when necessary: ; https://github.com/CliMA/Oceananigans.jl/blob/73be08d708131a66402eb8fc0086c47ef80a2d0e/src/Models/NonhydrostaticModels/solve_for_pressure.jl#L23-L39. > ; > CC @zhazorken. One possible route forward is to first implement the Orlanski boundary condition and setup a few validation experiments before deciding whether the pre",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/833#issuecomment-934615920:1451,depend,dependent,1451,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/833#issuecomment-934615920,1,['depend'],['dependent']
Integrability,"s exporting these common names. They are now exported by; > Oceananigans.Utils.; >; > But otherwise, the impact to user scripts is pretty minimal (the examples; > barely changed).; >; > Resolves #456; > <https://github.com/climate-machine/Oceananigans.jl/issues/456>; > Resolves #495; > <https://github.com/climate-machine/Oceananigans.jl/issues/495>; > Resolves #497; > <https://github.com/climate-machine/Oceananigans.jl/issues/497>; > Resolves #563; > <https://github.com/climate-machine/Oceananigans.jl/issues/563>; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/climate-machine/Oceananigans.jl/pull/591; > Commit Summary; >; > - New BoundaryConditions submodule feels so good.; > - Fix missing import statements; > - Coriolis submodule; > - Buoyancy submodule; > - Get rid of `set_ic!` legacy wrapper; > - Fields submodule; > - Models submodule; > - Forcing submodule; > - Utils submodule; > - Architectures submodule; > - Logger submodule; > - Export fewer things in Oceananigans top-level module; > - Update documentation API library; > - Update tests; > - Move field tuple constructions utils to Fields submodule; > - Get rid of most placeholder functions.; > - Update more tests; > - Update even more tests; > - Update examples and verification experiments; > - Reorganize Oceananigans.jl; >; > File Changes; >; > - *M* docs/src/library.md; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-0>; > (213); > - *M* examples/eady_turbulence.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-1>; > (7); > - *M* examples/ocean_convection_with_plankton.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-2>; > (5); > - *M* examples/ocean_wind_mixing_and_convection.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-3>; > (6); > - *M* src/AbstractOperations/AbstractOperations.jl; > <https://github.com/climate-mach",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/591#issuecomment-573468618:1586,wrap,wrapper,1586,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/591#issuecomment-573468618,1,['wrap'],['wrapper']
Integrability,"s). #Coefficient of Thermal expansion; const alpha= 2e-4. #Coefficient of Salinity; const beta=8e-4; #heat flux; const Bo=3.6e-4; #coriolis parameter; const f=-0.5; #gravitational acceleration; const g=300. Q = Bo; const dTdz = 0 # K m⁻¹; T_bcs = FieldBoundaryConditions(; top = FluxBoundaryCondition(Q),; bottom = GradientBoundaryCondition(dTdz)). const Qᵘ=0; u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ), bottom=ValueBoundaryCondition(0.0)); v_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ), bottom=ValueBoundaryCondition(0.0)). buoyancy = SeawaterBuoyancy(gravitational_acceleration = g,equation_of_state=LinearEquationOfState(α=alpha, β=beta)). using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = NonhydrostaticModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; tracers = (:T, :S),; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)); using Oceananigans.Diagnostics: accurate_cell_advection_timescale; wizard = TimeStepWizard(cfl=0.5,Δt=0.1, max_change=1.1, max_Δt=1minutes,cell_advection_timescale = accurate_cell_advection_timescale); start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model,; Δt = wizard,; stop_time = 12minutes,; iteration_interval = 1,; progress = progress_message; ); fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w, ""T"" => model.tracers.T). simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath=""TestSetup.nc"",; schedule=TimeInterval(6) ); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166:2490,message,message,2490,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166,1,['message'],['message']
Integrability,"s).; ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:420 [inlined]; [4] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/field.jl:399 [inlined]; [5] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Utils/sum_of_arrays.jl:23 [inlined]; [6] _interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:148 [inlined]; [7] interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:197 [inlined]; [8] advect_particle; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:83 [inlined]; [9] macro expansion; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:145 [inlined]; [10] cpu__advect_particles!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:276 [inlined]; ...; ```. I do not see why viscosity/Coriolis/buoyancy is required for shear instability. Anyway, I found another way to reproduce the error on CPU, while keeping `CFL = 10`, is to introduce a small perturbation to the initial velocity field:; ```Julia; function initial_u(x::R, y::R, z::R) where {R<:Real}; ϵ = 1e-7; return (max_velocity / Lx) * y + ϵ * max_velocity * sin(6π * x / Lx); end; ```. The output error message is the same as the previous one, in which `CFL = 51`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135:2975,message,message,2975,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135,1,['message'],['message']
Integrability,"se all they can say is that their; > results are similar to one another, but they cannot say which one is more; > accurate (and perhaps it doesn't matter which method is more accurate in; > their case, if both methods return similar results).; >; > That said, I think time-step considerations are really important, and seem; > like a good reason to choose DFM over CFM.; >; > Balaras (2004)'s pressure equation is; >; > [image: image]; > <https://user-images.githubusercontent.com/15271942/95799302-36f2c280-0cc2-11eb-9342-a2b47a1cfdfa.png>; >; > where, crucially, Ω is the *computational* domain (irrespective of the; > immersed boundary). So following Balaras (2004) would mean *not*; > modifying the pressure solver? That's good news!; >; > Does it make sense to first implement an algorithm that assumes the; > boundary coincides with the grid?; >; > I am not super worried about the algorithmic changes require to implement; > a DFM immersed boundary. I think we can isolate the immersed boundary; > implementation from the rest of the code and interface with the; > time-stepping routines with a single function call that calculates the; > discrete forcing and applies a correction to the velocity field. Using; > multiple dispatch, this change to the algorithm will have no cost to; > simulations that don't use immersed boundaries. The main challenge I think; > is figuring out abstractions that make it easy to create immersed; > boundaries and assign boundary conditions (@ali-ramadhan; > <https://github.com/ali-ramadhan> and my job to figure this out) --- and; > we'd have this challenge for any immersed boundary implementation, whether; > CFM or DFM.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707401128>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQXTZSGE6RBZ5E4B733SKOI4PANCNFSM4SNJ4CSA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707404766:2667,interface,interface,2667,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707404766,2,"['interface', 'rout']","['interface', 'routines']"
Integrability,"sible atmosphere model.; >; > Verification experiments:; >; > 1. Hydrostatic adjustment in an isothermal atmosphere [very; > qualitative, see Bannon (1995)]; > 2. Dry rising thermal bubble: thabbott/JULES.jl#31; > <https://github.com/thabbott/JULES.jl/pull/31>; > 3. Nonlinear density current (PR incoming); >; > Dry rising thermal bubble can be compared with figure 5 of Wicker and; > Skamarock (1998), figure 7 of Jahn et al. (2015), and; > https://faculty.nps.edu/fxgirald/projects/mesoscale/rtb_movie.html.; >; > Nonlinear density current can be compared with figure 1 of Straka et al.; > (1993) and; > https://faculty.nps.edu/fxgirald/projects/mesoscale/dc_movie.html.; >; > Things we can hopefully share between IncompressibleModel and; > `CompressibleModel:; >; > 1. Operators; > 2. Grids; > 3. Coriolis; > 4. Forcing functions; > 5. Boundary conditions; > 6. Turbulence closures; > 7. Diagnostics; > 8. Output writers; > 9. Advection schemes; > 10. User interface (setting initial conditions, boundary conditions,; > time stepping, etc.); >; > Atmosphere-specific abstractions that would differentiate compressible; > from incompressible models:; >; > 1. Prognostic temperature (potential temperature, entropy, enthalpy,; > etc.); > 2. Base state (dry adiabatic, isothermal, analytic sounding, form from; > initial conditions, etc.); > 3. Acoustic time stepper (nothing, fully explicit for regular grids,; > vertically implicit for stretched grids); > 4. Other atmospheric things like cloud microphysics and radiation but; > for this there are packages that can be relied on, e.g. RRTMGP.jl; > <https://github.com/climate-machine/RRTMGP.jl> and Cloudy.jl; > <https://github.com/climate-machine/Cloudy.jl>.; >; > It would be ideal if we have a single Model type and just change the; > equation between the CompressibleModel and IncompressibleModel but the; > numerical methods and abstractions employed are sufficiently different that; > I think it makes sense to have two separate model types",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-579977300:2161,interface,interface,2161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-579977300,1,['interface'],['interface']
Integrability,"so catching up with a past discussion on turbulence closure (#1277). I tried setting up a simulation with `closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=κ,κ=κ))` but am getting errors with `no method matching south_ib_flux`. Could this be specific to immersed boundary or has the turbulence closure definition of the molecular values of kinematic viscosity and diffusivity changed since #1277?. Here's a question. Doing wall-resolved LES is a bit tricky here. In the way the code is written, the diffusivity for wall fluxes with value or gradient boundary condition is derived from the model closure. For closure tuples, the logical thing to do is to add all the diffusivities together to come up with the immersed flux. However, this means that to do wall resolved LES we have to solve a tricky problem which is how to specify that the LES diffusivity has a value of 0 on the boundary. The interface implemented here doesn't support that; when we write `ValueBoundaryCondition(0)` what that means is that we add fluxes to a tendency consistent with `ValueBoundaryCondition(0)`. (The alternative, which would essentially mean ""return `0` when the field is reconstructed on boundary faces"" requires feeding boundary conditions into the reconstruction operator used by the closure. Doing that would substantially complicate the code.) This means effectively that there's no way to set the LES diffusivity to 0 on an immersed boundary. Even if there were a way to ensure this, it's also inconvenient to have to specify boundary conditions on the LES diffusivities... An alternative approach might attach a diffusivity / viscosity to the immersed boundary condition. Then the closure is ignored when calculating the immersed flux and the ""boundary diffusivity"" is used instead. This has some convenience downsides (ie diffusivity values have to be passed both to the closure _and_ the boundary condition), but would at least produce correct results in a straightforward way. I won't be ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1107321166:979,interface,interface,979,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1107321166,1,['interface'],['interface']
Integrability,"solves to calling a function, whereas calling `getindex` on a `Field` / `Array` fetches data from memory. So they are different. Naively I would expect that evaluating a complicated advection term involving `BackgroundField` would be cheaper than one that involved two concrete `Array`. But sometimes unexpected things happen (the compiler might decide to optimize the code differently...). Can you try running the code on the GPU? I think it would be enlightening to see if there's a slowdown in that case. We could potentially implement an interface whereby `Field`s can be used as `BackgroundField` rather than functions. That might give us some insight, because then the ""additional"" advection terms associated with `BackgroundField` would truly be identical to the ""original"" advection term. > because presumably the advection of the background state by the background state is zero. I would say that the background self-interaction terms are _neglected_ rather than presumed to be zero. Linear terms associated with the background fields are also neglected. The idea being that if there is a valid way to decompose a flow into background and perturbation components, then the equation that governs the background component is completely neglected (this includes both the nonlinear terms and any linear terms involving the background flow). _Side note:_ some nonlinear terms are additionally neglected in the case of nonlinear viscosity. Ideally I think we would include these because the above argument doesn't justify neglecting them, but the implementation seemed too complicated the last time I thought about it so I put it off. I think it's a solvable problem but requires a bit of thought to integrate into the current algorithm seamlessly. > Mu understanding is that it is required for GPU runs, but it also helps optimize CPU runs. This is correct --- if you're missing a `const` on a variable that's used in a kernel, that kernel will fail to compile on the GPU (it won't just be slow).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623:2362,integrat,integrate,2362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623,1,['integrat'],['integrate']
Integrability,"some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to your setup? Interpolations.jl might be an option but I'm not sure if it's GPU compatible. Worst case scenario maybe it wouldn't be too hard to code up a simple spline/interpolation scheme?. If you're looking for a 5~10x speedup you could try running multithreaded (run `julia -t n` where `n` is the number of threads to use) until a GPU version is up and running.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:1742,wrap,wrapper,1742,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660,1,['wrap'],['wrapper']
Integrability,spack/opt/spack/julia/1.9.2/gcc/7.5.0/mjea/bin:2;/glade/u/apps/casper/23.10/spack/opt/spack/netcdf/4.9.2/oneapi/2023.2.1/gfig/bin:2;/glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/bin:2;/glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6/bin/mpi:1;/glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/bin:2;/glade/u/apps/casper/23.10/spack/opt/spack/ucx/1.14.1/gcc/7.5.0/vf2h/bin:2;/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/bin:2;/glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6/bin:2;/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/lib/oclfpga/bin:1;/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/bin/intel64:1;/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/bin:1;/glade/u/apps/casper/23.10/opt/wrappers/bin:1;/glade/u/apps/casper/23.10/opt/utils/bin:1;/glade/u/home/knudsenl/.local/bin:1;/usr/lib/mit/bin:1;/opt/pbs/bin:1;/glade/u/apps/casper/23.10/opt/view/bin:1;/usr/local/bin:3;/usr/bin:3;/sbin:2;/bin:3;/glade/u/apps/casper/23.10/spack/opt/spack/llvm/14.0.6/gcc/7.5.0/arf7/bin:1; __LMOD_REF_COUNT_NCAR_LDFLAGS_CUDA64 = /glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64:1; NCAR_LDFLAGS_UCX = /glade/u/apps/casper/23.10/spack/opt/spack/ucx/1.14.1/gcc/7.5.0/vf2h/lib; __LMOD_REF_COUNT_ACL_BOARD_VENDOR_PATH = /opt/Intel/OpenCLFPGA/oneAPI/Boards:1; ACL_BOARD_VENDOR_PATH = /opt/Intel/OpenCLFPGA/oneAPI/Boards; __LMOD_REF_COUNT_NLSPATH = /glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/compiler/lib/intel64_lin/locale/%l_%t/%N:1; JAVA_HOME = /usr/lib64/jvm/java-11-openjdk-11; INSTALLPATH_ROOT = /glade/u/apps/casper/default/spack/opt/spack; __LMOD_REF_COUNT_LD_LIBRARY_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:3850,wrap,wrappers,3850,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['wrap'],['wrappers']
Integrability,"suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?; > ; > ; > ; > Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg; > ; > ; > ; > ```; > ; > ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; > ; > ```; > ; > ; > ; > > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed.; > ; > ; > ; > It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though.; > ; > ; > ; > As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.). Sorry I'm away from the computer with a GPU at the moment so can't check, but I think the reason I thought it would require changes to the tracer_tendency function is because it seems relatively straightforward to fix the issue with the velocity tendency functions (I hadn't realised you could have tracer dependent velocity forcing too so that may make it less straightforward), but then when I'd changed that a bit I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. And yeah sorry for the lack of clarity, I meant pass as required for buoyancy b/T/S",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457:1192,depend,depend,1192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457,3,['depend'],"['depend', 'dependent']"
Integrability,"sure - I was able to repro the error by using the basic example on the `KernelAbstractions` quick start page:. https://juliagpu.github.io/KernelAbstractions.jl/dev/quickstart/. ```. using KernelAbstractions. @kernel function mul2_kernel(A); I = @index(Global); A[I] = 2 * A[I]; end. dev = CPU(); A = ones(1024, 1024); ev = mul2_kernel(dev, 64)(A, ndrange=size(A)); synchronize(dev); all(A .== 2.0). ```. this is the error. ![ka_err](https://github.com/CliMA/Oceananigans.jl/assets/16384103/4fe91c2a-e7c9-4fb5-b328-353d921d6a6b). the author of the `KernelAbstractions` library has responded to this issue here and thinks it's the fault of the debugger:. https://github.com/JuliaGPU/KernelAbstractions.jl/issues/405. I'm not sure if that's helpful, but I have only experienced this issue with the `KernelAbstractions` library and not any other library. I've also opened an issue on the julia-vscode extension repo, but have not received a response yet:. https://github.com/julia-vscode/julia-vscode/issues/3349. please let me know if there's anything else I can try - thank you again for helping me with this issue",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624346600:365,synchroniz,synchronize,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624346600,1,['synchroniz'],['synchronize']
Integrability,"sure with viscosity ν and tracer diffusivities κ for each tracer field in tracers. If a single κ is provided, it is applied to all tracers. Otherwise κ; must be a NamedTuple with values for every tracer individually. Arguments; ≡≡≡≡≡≡≡≡≡. • time_discretization: either ExplicitTimeDiscretization() (default) or VerticallyImplicitTimeDiscretization(). • formulation:; • HorizontalFormulation() for diffusivity applied in the horizontal direction(s); • VerticalFormulation() for diffusivity applied in the vertical direction,; • ThreeDimensionalFormulation() (default) for diffusivity applied isotropically to all directions. • FT: the float datatype (default: Float64). Keyword arguments; ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡. • ν: Viscosity. Number, AbstractArray, Field, or Function. • κ: Diffusivity. Number, AbstractArray, Field, Function, or NamedTuple of diffusivities with entries for each tracer. • discrete_form: Boolean; default: false. When prescribing the viscosities or diffusivities as functions, depending on the value of keyword argument discrete_form, the constructor expects:. • discrete_form = false (default): functions of the grid's native coordinates and time, e.g., (x, y, z, t) for a RectilinearGrid or (λ, φ, z, t) for a LatitudeLongitudeGrid. • discrete_form = true:; • with loc = (nothing, nothing, nothing) (default): functions of (i, j, k, grid, ℓx, ℓy, ℓz) with ℓx, ℓy, and ℓz either Face() or Center().; • with loc = (ℓx, ℓy, ℓz) with ℓx, ℓy, and ℓz either Face() or Center(): functions of (i, j, k, grid). • parameters: NamedTuple with parameters used by the functions that compute viscosity and/or diffusivity; default: nothing. julia> using Oceananigans. julia> ScalarDiffusivity(ν=1000, κ=2000); ScalarDiffusivity{ExplicitTimeDiscretization}(ν=1000.0, κ=2000.0). julia> const depth_scale = 100;. julia> @inline ν(x, y, z) = 1000 * exp(z / depth_scale); ν (generic function with 1 method). julia> ScalarDiffusivity(ν=ν); ScalarDiffusivity{ExplicitTimeDiscretization}(ν=ν (generic functi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3667#issuecomment-2258700498:1551,depend,depending,1551,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3667#issuecomment-2258700498,1,['depend'],['depending']
Integrability,"t dropped it). I also slightly reworded it to have less absolute statements, but further rewording is necessary after we finish this discussion I think.; > ; > Some notes:; > ; > * The same code on CPUs isn't even close to have the same slowdown. So there's definitely something going on here for GPUs; > * I have struggled with this for quite some time until I found the culprit, so if we can't immediately find and fix the cause I'd suggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ betwe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1076,depend,depend,1076,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151,2,"['depend', 'inject']","['depend', 'injected']"
Integrability,"t regard the power method algorithm as predicated on a hypothesis (not an exact theory), which we provide empirical evidence for. This is one of the advantages of the power method that uses the full original system, I think, over more brute force approaches that forcefully remove nonlinear terms.; > ; > It is possible to replace the approx with an `=` and also include all of the nonlinear terms what one would get from the manipulations that lead to the equation for `Phi`. This is precisely what you would do if you were interested in continuing the asymptotic expansion _that linearization implies_ to investigate things like saturation, etc. So there's also a neat pedagogical power in the approx symbol in that it provides a hint for further learning and exploration of the mathematics of the system. I agree with **all** of the above. However, you missed one of my points... my disagreement was mostly of the phrasing. You suggested writing:. > Linear instabilities such as the Kelvin-Helmholtz instability, are described by equations of the form ∂_t Φ + L Φ ≈ 0 ... This statement is wrong --- that was my only objection. When accompanied with the messages you posted above it makes absolutely sense! But would you expect users to infer all these just from the ≈ symbol?. Reading your post made me think. I now suggest the following restructure (I'll present here a skeleton). - first discuss linear instabilities... the fact that Oceananigans.jl won't give you the linear operator but will evolve the full nonlinear system and the ""hack"" to get _approximately linear dynamics_ (I'll use ≈ here ;)) by utilizing `BackgroundFields`+**small amplitude**; - next discuss how we do eigenanalysis of the linear operator (without having the `L` in hand in the first place): here describe the power method and how we use the `simulation` of the ""approximately linear dynamics"" for `Δτ`described above as a way to ""apply `L`... How do you like this? (I'll work on this refactoring tomorrow probably.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282:2067,message,messages,2067,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282,1,['message'],['messages']
Integrability,"tagging the wrong Navid…. ___________________________________________; Multidisciplinary Composer | Media Alchemist | Artist-Researcher; Associate Director, Topological Media Lab; Research Associate: Matralab, Milieux, HEXAGRAM, LASG; navidnavab.com <http://navidnavab.com> | 514.432.6633; ----------------------------------------------------------------------------. On Wed, Feb 14, 2024 at 12:47 AM Navid C. Constantinou <; ***@***.***> wrote:. > Thanks @navid <https://github.com/navid> for your suggestions above. I; > will incorporate them in subsequent commits.; >; > You can just click the button next to them and they are committed!; > Screenshot.2024-02-14.at.07.46.47.png (view on web); > <https://github.com/CliMA/Oceananigans.jl/assets/7112768/34363045-e8b1-4776-8436-a551babaa02e>; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1943122887>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDTZNCXD3DWZHODH2M3JLYTRFXFAVCNFSM6AAAAAA5S3QE4CVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTSNBTGEZDEOBYG4>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1944385984:1172,Message,Message,1172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1944385984,1,['Message'],['Message']
Integrability,"tandards.; >; > Unfortunately, CF conventions don't quite provide the right vocabulary to; > describe the curvilinear geometry of staggered grid models compactly (see; > cf-convention/discuss#5; > <https://github.com/cf-convention/discuss/issues/5>). In the meantime,; > every modeling center seems to have their own preference for how to encode; > this (e.g. comodo conventions; > <https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html>; > [now offline] used by ROMS and NEMO, S-grid; > <https://github.com/sgrid/sgrid>, mosaics; > <https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf> from GFDL).; >; > With xgcm, we decided to use the Comodo conventions (rather than invent; > yet another new convention). In retrospect, this was maybe the wrong; > choice, since the pycomodo project seems to have totally disappeared. 🤦; > However, if you put the right metadata; > <https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes>; > in your attributes, xgcm should be able to figure out your grid.; >; > Whatever you do, please try your best to squeeze your data into existing; > standard file formats and metadata conventions.; > Don't invent something new. MITgcm did this with the mds data format and; > it has been endless headaches for our community. I don't know what JLD2 is,; > but it sounds like you could be going down that route...; >; > If you have any questions, please ask! I'll try to respond.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQXRYPNOI5TLPGVKV3DS6L7EJANCNFSM4XBBPGJA>; > .; >. -- ; ==========================================; John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535:1982,rout,route,1982,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535,1,['rout'],['route']
Integrability,thanks. And presumably a similar change needs to be done in the original script to include `IncompressibleModel`. That I think I can find and do. The last thing I can think of is where to define the function before there is a dispatch that occurs depending on the model.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762968343:247,depend,depending,247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762968343,1,['depend'],['depending']
Integrability,"that we need different Coriolis functions for Cartesian and Spherical coordinates. Why do we need different functions or nonhydrostatic (and shallow water I presumme) and hydrostatic?; > ; > I'm also not clear, although I'm assuming that it has to do with `w` being treated differently (since `w` appears in the equations for the horizontal rotation components). @glwagner can you clarify?. Yes, when we make the hydrostatic approximation, we assume that the aspect ratio is thin and H/L is small. The hydrostatic assumption specifically refers to the use of this scaling in the vertical momentum equation (reducing it to a diagnostic equation for hydrostatic pressure). This same scaling applied to the Coriolis force leads to the ""traditional"" approximation such that Coriolis terms involving the _vertical_ velocity are neglected from the horizontal momentum equations (likewise, the terms involving the horizontal momentum are neglected from the vertical momentum balance; neglecting these terms must be made consistently for the system to conserve kinetic energy). This thin-aspect-ratio approximation (probably best to avoid implicating ""tradition"" in model formulation...) also needs to be invoked to justify ""f-plane"" and ""beta-plane"" approximations to the Coriolis term when the numerical model is supposed to approximate oceanic motion away from the poles. (The so-called ""non-traditional"" terms --- the projection of the planetary vorticity into horizontal directions --- have been variously found to have a small effect on turbulent boundary layer motions. This is probably because the effect of Coriolis forces is most pronounced at the largest scales, and the effect of the horizontal Coriolis components on large scale vertical motions is suppressed by the presence of an impenetrable surface at the top and bottom.). In Oceananigans, we have to express this notion with a _type_ to avoid adding spurious terms to the horizontal momentum equations that depend on the vertical velocity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861:1985,depend,depend,1985,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861,1,['depend'],['depend']
Integrability,"the bug because I don't know exactly what you are talking about...; > ; > (there is a chance you may need to delete the dowloaded `.jld2` file to force DataDeps to download it again... perhaps that's your issue -- I'm not sure). The bug manifests when executing the following code snippet over the REPL:; ```; using Oceananigans; using DataDeps; cs32_4 = DataDep(""cubed_sphere_32_grid_with_4_halos"",; ""Conformal cubed sphere grid with 32×32 cells on each face and 4 halos on each side"",; ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/main/cubed_sphere_grids/cs32_with_4_halos/cubed_sphere_32_grid_with_4_halos.jld2"",; ""fbe684cb560c95ecae627b23784e449aa083a1e6e029dcda32cbfecfc0e26721""); DataDeps.register(cs32_4); grid_filepath = datadep""cubed_sphere_32_grid_with_4_halos/cubed_sphere_32_grid_with_4_halos.jld2""; cs_grid_MITgcm = ConformalCubedSphereGrid(grid_filepath;; Nz = 1,; z = (-1, 0),; panel_halo = (4, 4, 1),; radius = 6370e3); cs_grid_MITgcm = ConformalCubedSphereGrid(grid_filepath;; Nz = 1,; z = (-1, 0),; panel_halo = (4, 4, 1),; radius = 6370e3); ```; The complete error message is; ```; ERROR: KeyError: key ""panel1"" not found; Stacktrace:; [1] getindex(g::JLD2.Group{JLD2.JLDFile{JLD2.MmapIO}}, name::String); @ JLD2 ~/.julia/packages/JLD2/VWinU/src/groups.jl:101; [2] getindex(f::JLD2.JLDFile{JLD2.MmapIO}, name::String); @ JLD2 ~/.julia/packages/JLD2/VWinU/src/JLD2.jl:494; [3] conformal_cubed_sphere_panel(filepath::String, architecture::CPU, FT::Type; panel::Int64, Nz::Int64, z::Tuple{…}, topology::Tuple{…}, radius::Float64, halo::Tuple{…}, rotation::Nothing); @ Oceananigans.Grids /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Grids/orthogonal_spherical_shell_grid.jl:807; [4] construct_regionally(::Int64, ::Function, ::String, ::Vararg{Any}; kwargs::@Kwargs{Nz::MultiRegionObject{…}, z::Tuple{…}, panel::Oceananigans.Utils.Iterate{…}, topology::Tuple{…}, halo::Tuple{…}, radius::Float64}); @ Oceananigans",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023704954:1246,message,message,1246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023704954,1,['message'],['message']
Integrability,"the offender is this line ; https://github.com/CliMA/Oceananigans.jl/blob/17e6fc045a32fcbd685737878ccf9638197c7b50/src/ImmersedBoundaries/grid_fitted_bottom.jl#L75. `MultiRegionGrid` is created by wrapping around an `ImmersedBoundaryGrid` where the letter are constructed with `construct_regionally(construct_grid, args...)`; https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L83; https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L110. `fill_halo_regions!` cannot be called within a regional `@apply_regionally` call, so we probably have to shift around the construction when there is an ImmersedBoundaryGrid. (I wonder how this test is passing on main). I see two solutions here:; 1) change the constructor of `MultiRegionGrid` to make sure that fill_halo is called outside, aka partition the immersed_boundary outside the `construct_regionally`, fill_halo and then build the immersed grid with an offsetarray (simple but probably worst long term); 2) Make `ImmersedBoundaryGrid` wrap around `MultiRegionGrid`(slightly more complex, maybe for another PR, but probably useful for the cubed sphere grid?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1603029063:197,wrap,wrapping,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1603029063,2,['wrap'],"['wrap', 'wrapping']"
Integrability,"these are if we want to make the particle velocity depend on other _eulerian_ fields (like forcing for our prognostic variables). An example can be the buoyancy field for buoyant particles. If we decide that that role can be undertaken by the `dynamics` kernel, we can remove the `i, j, k` from the signature. We should probably come up with a couple of examples to include in this PR that show the implementation of different particle dynamics. ; I would include:; - buoyant particles (sinking or rising with a density-dependent vertical velocity); - particles with drag",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852745078:51,depend,depend,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852745078,2,['depend'],"['depend', 'dependent']"
Integrability,"this because we are focused on LES for the most part, or problems with very little diffusion. But ultimately we will need this, especially when we get around to implementing boundary layer closures. We have a tridiagonal solver that works on the GPU, so in some respects the hard work is already done for this problem. 3. Closures for LES and ocean modeling (Dynamic Smagorinsky, Deardorff, k-epsilon, Gent-McWilliams, convective adjustment (?) etc --- physics). We have a need to implement new turbulence closures new and old alike. Gent-McWilliams is probably easy since we already have a Leith closure implemented which calculates the tensor needed to rotate the diffusivity into an isopycnal coordinate. The others are a bit more challenging. 4. Extensive profiling and benchmarking on the GPU to identify bottlenecks / places for improvement in the algorithm (numerics). We might be able to make the code a lot faster (but we aren't sure). 5. A solver for hydrostatic problems with a free surface that uses a split-explicit time-integration method. This is notoriously tricky, but we've made a lot of progress on this for the purposes of the ClimateMachine and it might be interesting to translate what we've learned into Oceananigans. There's also some minor package stuff that I want to work on, such as refactoring the output writer (#963), improving logging / feedback while oceananigans builds a model or runs a simulation (#1013), getting arrays with named axes to work (#457), and figuring out what's going wrong with models that have `Flat` dimensions (#1024). A more fun project is to come up with cool plotting recipes in 1D, 2D, and 3D (!) We'd like to show people how to use Makie (for example) to create really cool visualizations / animations of turbulence. The examples do some animation, but more complicated stuff (such as 3D contourf plots, or volume rendering) might require dedicated scripts. @navidcy and I have also discussed projects to implement 1) a shallow water model ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281:2377,integrat,integration,2377,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281,1,['integrat'],['integration']
Integrability,"this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect it might not be but it's worth a shot (you might learn something). . > Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. I guess that's sort of what we're doing here. The main issue is reducing boilerplate / making this as easy as possible. It'd be nice to write parameterizations with more abstract syntax rather than having to write a low-level kernel function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:2804,depend,depend,2804,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513,1,['depend'],['depend']
Integrability,"this was the innovation that Alistair had when he was sorting out the; numerics of the cubed sphere out. One needs the vorticity at the corner. He; expressed it as a circulation integral snaking across three surfaces of the; cube, rather than differencing. I'm in full support. On Sun, Apr 30, 2023 at 11:25 AM Gregory L. Wagner ***@***.***>; wrote:. > Does it make sense to try to reconstruct vorticity in the same way? Ie; > have we tried reconstructing the circulation:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/98bcdde7ae679583ea88474ec0909469abccfc90/src/Operators/vorticity_operators.jl#L9; >; > and then computing vorticity by dividing by Azᶠᶜᶜ and Azᶜᶠᶜ?; >; > It makes a lot of sense to me that δx(Δy * u) + δy(Δx * v) is smoother; > than δx(Δy * u) + δy(Δx * v) / Azᶜᶜᶜ when the grid is strongly stretched.; >; > Maybe we should come up with test cases that have even more extreme; > stretching? It will be very very nice to have good properties on stretched; > grids for the cubed sphere.; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1529053452>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQRBF7RYUYWS3KH4NGDXDZ75XANCNFSM6AAAAAAXQNM76E>; > .; > You are receiving this because you are subscribed to this thread.Message; > ID: ***@***.***>; >. -- ; ==========================================; Professor John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1529054646:1350,Message,Message,1350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1529054646,1,['Message'],['Message']
Integrability,"thub.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593. There may be other problems that we haven't uncovered. An important additional case that doesn't work right now is operations that have embedded `AveragedField`. I think this is some kind of type inference issue. For `Field` on the GPU we ""throw away"" the wrapper and expose the underlying `OffsetArray` to GPU kernels. So compilation of functions of `Field` is ""no more difficult"" than compilation of functions with `OffsetArray`. This idealization is successful because indexing into the underlying `field.data` is identical indexing into the field itself, and because we don't require field locations _inside_ the kernel (we build expression trees for AbstractOperations on the CPU, prior to launching the kernel). But this idealization doesn't hold for `AveragedField` or any `ReducedField`. In particular, abstract operations index into these objects at all `i, j, k`. However, they don't vary on one or more of these directions; the indexing operation needs to be ""collapsed"" so that reduced indices are translated correctly. Thus when we adapt `AveragedField` for the GPU, we hold onto the wrapper:. https://github.com/CliMA/Oceananigans.jl/blob/98cd4f7a56aa581defc721a01d6e1ab89b534d26/src/Fields/averaged_field.jl#L94-L96. Peeking at the broadcasting code used by julia Base gives a hint. Broadcasting has to solve the same problem: we have to be able to make computations between arrays of size (Nx, Ny, 1) and (Nx, Ny, Nz), for example. In this case, the indices of the first array are ""extruded"" into the third dimension. There are [some shenanigans in `Base.Broadcast`](https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630) that look like they are solving some type instability problem (which would doom GPU compilation for us if it were occurring). So we might be able to learn / borrow code from `Base.Broadcast`. All speculation from a naive julia programmer...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550:2583,wrap,wrapper,2583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550,1,['wrap'],['wrapper']
Integrability,"time-stepping loop in our wind mixing and convection example:. https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/examples/ocean_wind_mixing_and_convection.jl#L199. This printing produces a stream of messages during the simulation:. ```julia; julia> include(""ocean_wind_mixing_and_convection.jl""); i: 0010, t: 11.000 s, Δt: 1.100 s, wmax = 7.8e-04 ms⁻¹, wall time: 594.383 ms; i: 0020, t: 23.100 s, Δt: 1.210 s, wmax = 1.5e-03 ms⁻¹, wall time: 581.628 ms; i: 0030, t: 36.410 s, Δt: 1.331 s, wmax = 2.3e-03 ms⁻¹, wall time: 567.346 ms; i: 0040, t: 51.051 s, Δt: 1.464 s, wmax = 3.2e-03 ms⁻¹, wall time: 562.455 ms; i: 0050, t: 1.119 min, Δt: 1.611 s, wmax = 4.2e-03 ms⁻¹, wall time: 576.511 ms; i: 0060, t: 1.415 min, Δt: 1.772 s, wmax = 5.2e-03 ms⁻¹, wall time: 571.096 ms; ```. In this case, the information we decide to print is:. * iteration number `i`; * the simulation time `t`; * the time-step (because we are using adaptive time-stepping); * the maximum vertical velocity; * the elapsed wall time for time stepping *only* (not including plotting) between print messages. I think this issue is about a better way to achieve the printing of simulation progress. Two ideas are:. 1. Somehow use a logging package (though I'm not 100% what this would look like --- perhaps this means adding lines to our [time-stepping loop](https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/src/time_steppers.jl#L28)?; 2. Create some types that allow the user to more easily manage the printing of progress messages, expanding on the pattern used in our example. I've thought a bit about 2: I think a generic progress messenger would be both configurable but also include some comforting defaults. A simple way to start could be something like. ```julia; struct ProgressPrinter{DT, M, D}; Δt :: DT; model :: M; diagnostics :: D; end; ```. with some kind of print function, something like. ```julia; pretty_Δt(Δt::Number) =",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:1346,message,messages,1346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,1,['message'],['messages']
Integrability,"tl;dr. 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.). 2. How do we feel about wrapping boundary conditions for immersed boundaries in `FieldBoundaryConditions` (this requires refactoring `FieldBoundaryConditions` under the hood, but does not change the API). We can do 2. without 1. In that case we'll be able to support a lot of common cases, including ordinary oceanic cases (where boundaries do not overhang, and we only specify drag on tangential components). It's really LES cases that become tricky because we can't specify drag on vertical velocity components, or on tangential components when the boundary overhangs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-867684689:528,wrap,wrapping,528,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-867684689,1,['wrap'],['wrapping']
Integrability,"ty is not part of the source code, so this doesn't actually verify new aspects of the code (at best, the plots serve to verify the implementation in the script itself).; - Implementing IB functionality and quantitative verification is probably beyond the scope of this PR right now.; - As an example, we can justifiably provide this code with caveats that it's is merely a proof-of-concept, without advertising general IB functionality, and invite users to refine and improve on our example (maybe someone will want to implement better IB functionality in Oceananigans after seeing the example). 2. The method underlying this script's IB implementation is fairly well described in Lai and Peskin (2000): . https://www.sciencedirect.com/science/article/pii/S0021999100964830. See Lai and Peskin (2000)'s equation 7, and note that the implementation in this script uses a ""true"" discrete delta function, rather than a ""regularized"" delta function. As a result, the IB forcing can be implemented point wise, rather than requiring small sums around neighboring elements. Of course, this means that the boundary is not smooth; instead we make a stair-step approximation to the cylinder boundary. . 3. As an aside --- for a general IB implementation, we may have to either evaluate integral stencils, or perform ""precomputation"". Precomputation of arbitrary terms is not supported with Oceananigans's current design, but I think we should eventually support this (we need this, for example, to include averaged terms or general integrated terms on the RHS of our equations, among other things). I think if the method is documented and well-explained (and the user is provided with caveats that this is a proof-of-concept, without formal verification of the method's order of accuracy, etc), this would be a nice example that might pique some user's interests and spur them to contribute, or think creatively about what they can do with Oceananigans and the ability to prescribe arbitrary RHS via functions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/693#issuecomment-599491196:1826,integrat,integrated,1826,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/693#issuecomment-599491196,1,['integrat'],['integrated']
Integrability,"ue to a finite time step. It's important to recognize that the dynamics of the _discrete_ linear equations are different than the continuous. When we have a smooth solution, such that our spatial discretization should approximate some exact smooth solution, we can test that refining the grid and time step leads to convergence to an exact solution. Moreover, we can estimate the time-scale of the dynamics using the time-scales of the smooth dynamics as a guide. An example is a resolved buoyancy oscillation: it has a timescale of roughly 1/N. This example is dominated by small amplitude (eg linear) noise at the grid scale. Therefore my initial time scale estimate of 1/N may not hold. Instead, we'd have to look at the discrete eigenvalues of the system at the very higheset wavenumbers (ie the Nyquist number 2pi / dx). We could then calculate the time-step that would be required to resolve these (completely unphysical) dynamics. I'm not sure what a lower bound on such spurious discrete dynamics might be. It could be far smaller than any physical time scale, ie as small as 1e-16, or smaller? Perhaps the evolution of grid scale noise also has to do with spatial resolution, so that could be another knob to vary. So if we want to investigate this further, we should conduct a systematic study of the dynamics of this grid-scale noise system affected by buoyancy, decreasing the time-step to zero. Or we can convince ourselves that non-noisy dynamics _are_ accurate --- eg by analyzing a system like the one we use for our ""internal wave"" dynamics test:. https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_internal_wave_dynamics.jl. that test verifies that a wave packet in our code propagates at the correct group speed, for example. But one could dive much deeper into that example and test a wide variety of wave numbers. It depends whether you are interested in the grid-scale noise system, or whether you are interested in verifying that smooth resolved dynamics are correct.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1444451423:2077,depend,depends,2077,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1444451423,1,['depend'],['depends']
Integrability,"using the script . https://github.com/climate-machine/Oceananigans.jl/blob/631b861bcfdbfd894c4cb6b2257a16aa8c55f8cc/sandbox/simple_forcing.jl. on the branch `integrate-turbulence-closures` that is part of PR #245 , I get the following error:. ```; julia> include(""simple_forcing.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition recurse(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /data5/glwagner/.julia/packages/Cassette/xggAf/src/overdub.jl:521 overwritten in module GPUifyLoops at /data5/glwagner/.julia/packages/Cassette/xggAf/src/overdub.jl:521.; WARNING: Method definition overdub(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /data5/glwagner/.julia/packages/Cassette/xggAf/src/overdub.jl:508 overwritten in module GPUifyLoops at /data5/glwagner/.julia/packages/Cassette/xggAf/src/overdub.jl:508. CUDA-enabled GPU(s) detected:; CuDevice(0): Quadro P6000; [ Info: Building the CUDAnative run-time library for your sm_61 device, this might take a while...; ERROR: LoadError: InvalidIRError: compiling #12(RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}, PlanetaryConstants{Float64}, LinearEquationOfState{Float64}, Oceananigans.TurbulenceClosures.ConstantAnisotropicDiffusivity{Float64}, CUDAnative.CuDeviceArray{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496489468:158,integrat,integrate-turbulence-closures,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496489468,1,['integrat'],['integrate-turbulence-closures']
Integrability,"vection/upwind_biased_advective_fluxes.jl:98; [2] _advective_momentum_flux_Ww(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::Oceananigans.Fields.ZeroField, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); @ ~/software/New_Oceananigans/Oceananigans.jl/src/Advection/momentum_advection_operators.jl:16; ```. The function `_advective_momentum_flux_Ww(i, j, k, grid, scheme, W, w)` is called in `div_Uw`. Later on we see this:. ```; [6] div_Uw(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. Rewriting the error message makes it a bit clearer:. ```julia; div_Uw(::Int64, ::Int64, ::Int64, ; ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ; ::WENO5, ; ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ; ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. We thus see that the first four arguments are `i, j, k, grid`, the fifth argument is `WENO5`, the sixth argument is a named tuple of `ZeroField`s, and the seventh argument is an `OffsetArray`. The sixth argument --- `U` --- is a tuple of `ZeroField`s when the default value of `background_fields.velocities` is the advecting velocity field:. https://github.com/CliMA/Oceananigans.jl/blob/78f63ff9329b15ce20c33faed11e96ebf0dbc67d/src/Models/IncompressibleModels/velocity_and_tracer_tendencies.jl#L140. This PR helps the compiler realize that `div_Uw` called when `U` i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828:1120,message,message,1120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828,1,['message'],['message']
Integrability,"ving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1039,protocol,protocol,1039,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590,3,"['depend', 'protocol']","['dependencies', 'dependency', 'protocol']"
Integrability,"we could count the number of times the advection term is evaluated and calculate a multiplicative slowdown based on that assumption. One issue with that assumption is that the advection terms compile to different code when using a `BackgroundField`. With a `BackgroundField` the velocity field is stored as a `FunctionField` (with almost no additional memory allocation) rather than raw data. Calling `getindex` on a `FunctionField` resolves to calling a function, whereas calling `getindex` on a `Field` / `Array` fetches data from memory. So they are different. Naively I would expect that evaluating a complicated advection term involving `BackgroundField` would be cheaper than one that involved two concrete `Array`. But sometimes unexpected things happen (the compiler might decide to optimize the code differently...). Can you try running the code on the GPU? I think it would be enlightening to see if there's a slowdown in that case. We could potentially implement an interface whereby `Field`s can be used as `BackgroundField` rather than functions. That might give us some insight, because then the ""additional"" advection terms associated with `BackgroundField` would truly be identical to the ""original"" advection term. > because presumably the advection of the background state by the background state is zero. I would say that the background self-interaction terms are _neglected_ rather than presumed to be zero. Linear terms associated with the background fields are also neglected. The idea being that if there is a valid way to decompose a flow into background and perturbation components, then the equation that governs the background component is completely neglected (this includes both the nonlinear terms and any linear terms involving the background flow). _Side note:_ some nonlinear terms are additionally neglected in the case of nonlinear viscosity. Ideally I think we would include these because the above argument doesn't justify neglecting them, but the implementation s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623:1201,interface,interface,1201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623,1,['interface'],['interface']
Integrability,"whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells.; - `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells.; - `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes).; - `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells. I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. * It seems that we should really use `Bounded` topology to be synonymous with ""impenetrable"". This might help us disentangle a few issues (eg satisfying impenetrability, correct divergences, etc.) I think we are discovering that in some cases its better to hard code certain ""assumed boundary conditions"" directly into operators, such as impenetrable conditions (considering complex domains is the key to realize the right abstractions here, since there are many simple solutions for non-complex domains and no obvious way to distinguish their tradeoffs). This means that we need to ""assume"" boundary conditions based on grid topology (information centralized on the grid), rather than requiring knowledge of the field boundary conditions (information scattered throughout the fields); * Related to the above, when we support ""open"" boundaries, I think we may actually want an ""Open"" topology that functions similar",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430:2023,interface,interface,2023,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430,1,['interface'],['interface']
Integrability,why doesn't it make a difference? Isn't the time integration incorrect?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/127#issuecomment-473361620:49,integrat,integration,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/127#issuecomment-473361620,1,['integrat'],['integration']
Integrability,"wicePrecision{Float64}, Base.Twice...; 1363 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 8 _advective_momentum_flux_Uu(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio...; 1363 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 8 overdub; 1363 0 @Oceananigans/src/Operators/difference_operators.jl 21 δxᶠᵃᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twice...; 1372 0 @Oceananigans/src/Operators/difference_operators.jl 21 overdub; 1602 0 @Oceananigans/src/Operators/difference_operators.jl 20 δxᶜᵃᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twice...; 1681 1681 @KernelAbstractions/src/compiler/contract.jl 18 mul_float_contract; 1681 0 @KernelAbstractions/src/compiler.jl 47 overdub; 1714 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 9 _advective_momentum_flux_Vu(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio...; 1714 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 9 overdub; 1714 0 @Oceananigans/src/Operators/difference_operators.jl 23 δyᵃᶜᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twice...; 1781 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 13 _advective_momentum_flux_Vv(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio...; 1781 0 @Oceananigan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846:38491,contract,contract,38491,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846,1,['contract'],['contract']
Integrability,"yeah, if they are slow, the horizontal BCs for the barotropic velocities are included in the vertically integrated tendencies.; Not sure about eta",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179221886:104,integrat,integrated,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179221886,1,['integrat'],['integrated']
Integrability,"yeah, that interpolation operator is defined as ; ```; @inline ℑxᶜᵃᵃ(i, j, k, grid::AG{FT}, u) where FT = @inbounds FT(0.5) * (u[i, j, k] + u[i+1, j, k]); ```. so it assumes that the field to be interpolated is located at `Faces`. It should not be used on Centered fields.; I do not think we need fallbacks, the operators are not part of the public API and I am not sure we want them to be as they have to be wrapped around kernels",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2969#issuecomment-1466331362:409,wrap,wrapped,409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2969#issuecomment-1466331362,1,['wrap'],['wrapped']
Integrability,"yep, makes sense and works. ; Suggestion: add some comments/explanations in https://clima.github.io/OceananigansDocumentation/stable/model_setup/grids/. Maybe another possibility is to always have the user interface present fields centered and only when going into calculations doing the decentering/staggering internally. That would keep the user away from internals and staggering conventions. Anyway thanks for the quick and useful reply !",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839722236:206,interface,interface,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839722236,1,['interface'],['interface']
Integrability,"yes please!. On Mon, Mar 28, 2022 at 8:04 PM Gregory L. Wagner ***@***.***>; wrote:. > ***@***.**** approved this pull request.; >; > Bump minor version. Would also be sweet to see some of the global; > solutions!; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/2317#pullrequestreview-923878927>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQXBJN3S56JM4PSIOITVCJCIPANCNFSM5QCCJFGA>; > .; > You are receiving this because you are subscribed to this thread.Message; > ID: ***@***.***>; >. -- ; ==========================================; Professor John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1274241485:549,Message,Message,549,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1274241485,1,['Message'],['Message']
Integrability,"you cannot use `WENO(; order =5)` in the y-direction if you have only one grid point. ; In this case the script would have to change to ; ```julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 139 already precompiled. julia> grid = RectilinearGrid(size = (16, 1, 16),; halo = (3, 1, 3),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)); 16×1×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×1×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.0625. julia> advection = FluxFormAdvection(WENO(order=5), nothing, WENO(order=5)). julia> model = NonhydrostaticModel(; grid, advection); ```; I think spitting out the error should be the correct behavior because we want to make sure that people know what scheme is begin used in the different directions, and correct the advection scheme accordingly. We can probably change the error message to be a bit more descriptive",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3732#issuecomment-2310601348:204,depend,dependency,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3732#issuecomment-2310601348,2,"['depend', 'message']","['dependency', 'message']"
Integrability,"{Int64}}}) at /home/alir/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:298; [12] macro expansion at /home/alir/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:109 [inlined]; [13] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!)})(::CUDA.CuArray{Complex{Float64},3}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothing, progress::Function) at /home/alir/.julia/packages/KernelAbstractions/xslEz/src/backends/cuda.jl:172; [14] launch!(::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Symbol, ::typeof(Oceananigans.Solvers.calculate_pressure_right_hand_side!), ::CUDA.CuArray{Complex{Float64},3}, ::Vararg{Any,N} where N; dependencies::KernelAbstractions.CudaEvent, include_right_boundaries::Bool, location::Nothing, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /home/alir/Oceananigans.jl/src/Utils/kernel_launching.jl:80; [15] solve_for_pressure!(::OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, ::Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3}}},CUDA.CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CUDA.CuArray{Complex{Float64},3},CUDA.CuArray{Co",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-700320323:10814,depend,dependencies,10814,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-700320323,1,['depend'],['dependencies']
Integrability,"| 695eb278 | 50fbc9d0; refs/heads/arbitrary-tracers-inner-loops | 2440af95 | c3c4ce7b; refs/heads/forced-flow-test | 5355044d | 4771446c; refs/heads/gh-pages | 3ecbff38 | da919955; refs/heads/glw/beaufort-gyre-example | 0e54d846 | 6fa7725a; refs/heads/glw/circulation-experiment | de5764b9 | a53c1648; refs/heads/glw/craik-leibovich-terms | 972fbd17 | 956d4739; refs/heads/glw/eady-example | c53227c8 | d8d29f47; refs/heads/glw/fix-eady-typos | 84e7d974 | f43c5dde; refs/heads/glw/mesoscale-closures | 1d0090ec | 62b6fc9c; refs/heads/glw/mesoscale-closures-biharmonic-diffusivity | 7a765f2a | fe555ef7; refs/heads/glw/mesoscale-closures-kernel-refactor | 43886b98 | 187742f0; refs/heads/glw/mesoscale-closures-leith | 54bcd904 | f1f57ae2; ... Updating references: 100% (255/255); ...Ref update completed in 3,524 ms. Commit Tree-Dirt History; ------------------------. Earliest Latest; | |; ................DmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmDDDD. D = dirty commits (file tree fixed); m = modified commits (commit message or parents changed); . = clean commits (no changes to file tree). Before After ; -------------------------------------------; First modified commit | a8b6b6cf | 69bcf932; Last dirty commit | 3ecbff38 | da919955. Deleted files; -------------. Filename Git id ; ---------------------------------------------------------------------------------------------------; deep_convection_golden_master_model_checkpoint_10.jld | eeeca1f2 (2.4 MB) ; ocean_wind_mixing_and_convection.jld2 | b5c2ca73 (51.5 MB), 5b613ce4 (51.5 MB), ... In total, 2276 object ids were changed. Full details are logged here:. /home/gridsan/aramadhan/Oceananigans.jl.git.bfg-report/2019-11-03/11-36-30. BFG run is complete! When ready, run: git reflog expire --expire=now --all && git gc --prune=now --aggressive; ```. Testing:; ```; $ git clone git@github.com:climate-machine/Oceananigans.jl.git; Cloning into 'Oceananigans.jl'...; remote: Enumerating objects: 2107, done.; remote: Counting objects: 100% (21",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/509#issuecomment-549156736:2997,message,message,2997,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/509#issuecomment-549156736,1,['message'],['message']
Integrability,"~~I would try `u` because the behavior of eta could depend on whether you use explicit or implicit time-stepping.~~. Okay, I realized that you're using `ExplicitFreeSurface`. I think the comparison you want to make is to take an `euler` step with a NaN in `G-`, and check whether the NaN appears in the field where the NaN was inserted. You're checking `G-`, rather than the field itself. Since you're checking `G-` for NaNs, it doesn't appear for a couple more time-steps because the NaNs first appear in eta, and then get transferred to `Gn`, and _then_ get transferred to `G-` when `store_tendencies!` is called using `Gn` that has a NaN.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046412381:52,depend,depend,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046412381,1,['depend'],['depend']
Integrability,"~~Is there a way around the order of `includ`ing files so that this works? If not, it probably isn't necessary to force that the `particles` slot in models is taken by a `Nothing` or `LagrangianParticles` as it is now? So we could get rid of the particles dependency in models and change the order to `include` particles after models?~~. ~~The only thing I can think of is that if a user passes something other than particles it might give a confusing error.~~. ~~I think I found a use case for removing the typing of the particles slot and overloading the update functions too but I can't remember what it was now.~~. This won't work because particles need to already be defined for the timesteppers. My other solution would be to define a function `total_velocities` that is defined somewhere early on, and then define new methods for each model?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1490850779:256,depend,dependency,256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1490850779,1,['depend'],['dependency']
Integrability,"“face to edge” delta z must refer to an operation on an x-interface or; y-interface — not a z-interface to an edge?. On Sat, Mar 9, 2019 at 8:38 AM Ali Ramadhan <notifications@github.com>; wrote:. > Dispatching on the location as a parameterized type looks neat, would; > definitely clean things up! Thanks for coding up the example.; >; > I see how this would clean things up for δz_f2c and δz_e2f but the δz; > operator also needs to know onto which location to interpolate, so how; > would this work with δz_f2c and δz_f2e?; >; > @inline function δz_f2c(f, Nz, i, j, k); >; > if k == Nz; >; > @inbounds return f[i, j, k]; >; > else; >; > @inbounds return f[i, j, k] - f[i, j, k+1]; >; > end; > end; >; >; > @inline function δz_f2e(f, Nz, i, j, k); >; > if k == 1; >; > return 0; >; > else; >; > @inbounds return f[i, j, k-1] - f[i, j, k]; >; > end; > end; >; > To me it looks like they both fit; >; > δz(f::Field{Lx, Ly, Lz}, i, j, k) where {Lx, Ly, Lz<:Interface} = ...; >; > so I'm not sure how dispatch between the two.; >; > —; > You are receiving this because you were assigned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-471177715>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AOkIBkzcm1N5EI8VXyk1UgseDS6muPk9ks5vU7lYgaJpZM4bEKew>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-471178583:58,interface,interface,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-471178583,4,"['Interface', 'interface']","['Interface', 'interface']"
Integrability,"✓ Compat; ✓ AbstractFFTs; ✓ InlineStrings; ✓ Scratch; ✓ CEnum; ✓ StaticArraysCore; ✓ TableTraits; ✓ Missings; ✓ PooledArrays; ✓ BFloat16s; ✓ Preferences. ✓ Adapt; ✓ Statistics; ✓ SentinelArrays; ✓ Compat → CompatLinearAlgebraExt; ✓ Crayons; ✓ UnsafeAtomics; ✓ CUDA_Runtime_Discovery; ✓ PrecompileTools; ✓ JLLWrappers; ✓ Tables; ✓ RandomNumbers; ✓ Atomix; ✓ TimerOutputs; ✓ AbstractFFTs → AbstractFFTsTestExt; ✓ NVTX_jll; ✓ JuliaNVTXCallbacks_jll; ✓ MacroTools; ✓ LLVMExtra_jll; ✓ CUDA_Driver_jll; ✓ Random123; ✓ DataStructures; ✓ StringManipulation; ✓ FixedPointNumbers; ✓ SortingAlgorithms; ✗ CUDA_Runtime_jll; ✓ ColorTypes; ✓ LLVM; ✓ LLVM → BFloat16sExt; ✓ StaticArrays; ✓ Adapt → AdaptStaticArraysExt; ✓ StaticArrays → StaticArraysStatisticsExt; ✓ UnsafeAtomicsLLVM; ✓ Colors; ✓ GPUArraysCore; ✓ NVTX. ✓ GPUArrays; ✓ KernelAbstractions; ✓ PrettyTables; ✓ GPUCompiler; ✓ DataFrames; ✗ CUDA; 61 dependencies successfully precompiled in 190 seconds. 5 already precompiled. The following 1 direct dependency failed to precompile:. CUDA [052768ef-5323-5732-b1bb-66c8b64840ba]. Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_UQIv2i"".; [45592] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_CUC33l"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /gl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:4478,depend,dependency,4478,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,1,['depend'],['dependency']
Modifiability," 2, 2020, 5:41 PM Ali Ramadhan <notifications@github.com> wrote:. > This PR adds experimental support for rotating/tilting the gravity vector.; >; > I'm not even sure if it works properly but I'm opening a draft PR as it; > might be ready to be experimented with? I don't think we can have a; > non-zero gravity component along a periodic direction as the fluid just; > free falls along that dimension and the model blows up.; >; > But here's a plume rising with gravity tilted at 45 degrees; >; > [image: tilted_gravity_plume]; > <https://user-images.githubusercontent.com/20099589/100940093-5ab5d600-34c5-11eb-918e-f574f284f024.gif>; >; > This is an experimental feature since it needs more rigorous testing and; > because full support for tilted gravity may require more work, e.g.; >; > 1. Should AMD use z_dot_g_b now?; > 2. Should ∂x_b return a vector or should it be split up into x_dot_∂x_b,; > etc.? The Leith closure uses ∂x_b.; > 3. We may want to clean up and refactor the implementation, taking; > some suggestions from #1151; > <https://github.com/CliMA/Oceananigans.jl/issues/1151>.; >; > cc @tomchor <https://github.com/tomchor>; >; > Resolves #1151 <https://github.com/CliMA/Oceananigans.jl/issues/1151>; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1242; > Commit Summary; >; > - Make room for tuple gravity; > - Some `{x,y,z}_dot_g_b`; > - Tilted gravity plume sandbox; >; > File Changes; >; > - *A* sandbox/tilted_gravity_plume.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-9f5abd06fd694cf6f0d35019ea409e07e100a801fbfcd9a2a8d3737801a341b0>; > (53); > - *M* src/Buoyancy/Buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-55d14f16043b022b6a286fd9881d334208e6b6251d122555d3ede4014ea59e55>; > (10); > - *A* src/Buoyancy/gravitational_acceleration.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-bb73385a8b5",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819:1089,refactor,refactor,1089,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819,1,['refactor'],['refactor']
Modifiability," A hydrostatic Boussinesq model would be super useful too of course. I think we should talk. We are working on a similar model using discontinuous Galerkin numerics over at [ClimateMachine.jl](https://github.com/CliMA/ClimateMachine.jl) and these projects would have overlapping goals. Nevertheless I would personally find it extremely useful to be able to run `Oceananigans.IncompressibleModel`s with a `HydrostaticPressureSolver` and `ExplicitFreeSurface` since I could use it to benchmark / compare with the DG functionality that I'm working on for `ClimateMachine`, and the relative advantages of high-order finite volume methods compared with DG may still be in question, at least for structured grids (meaning that an Oceananigans development effort is not a waste of time). Perhaps a zoom conversation on that topic is in order. I agree with the framework / level-of-difficulty that you've laid out for student projects!. As for deciding FourierFlows vs Oceananigans, that's up to you for sure and depends basically on whether you are okay staying with doubly-periodic systems (what FourierFlows currently supports) or whether you want to do problems with boundaries (what Oceananigans promises). FourierFlows is a nice tool for idealized problems and theoretical work (and you can run pretty large problems these days since it has GPU support); Oceananigans is evolving more towards a tool for ocean modeling that is capable of doing idealized problems, but flexible enough to use for large eddy simulation and realistic non-hydrostatic modeling, in bounded domains and hopefully irregular domains as well, eventually, using immersed boundaries. Switching between the two would be a dream... ! I'm afraid this is too futuristic for Oceananigans. It may be possible to build FV functionality into FourierFlows (which is generally more flexible than Oceananigans, but has fewer features for the specific problem of the nonhydrostatic Boussinesq equations), but that's not a small piece of work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724302226:1672,flexible,flexible,1672,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724302226,2,['flexible'],['flexible']
Modifiability," I understand point 4 completely. The ocean model also has the concept of a model ""state""; for example, ghost cell values and nonlinear diffusivities depend on the velocity and tracer fields, in general. Right. But I guess users don't have to worry about ghost cell values and nonlinear diffusivities as they'll get filled in or calculated as needed. But in JULES.jl, if you want to add a potential temperature perturbation and modify θ you need to modify both the density ρ and the ρθ field. [Example:](https://github.com/thabbott/JULES.jl/blob/beec6727eef83343dd1adac8834f1545994098e2/verification/dry_rising_thermal_bubble/dry_rising_thermal_bubble.jl#L91-L95). ```julia; θ = Θ[i, 1, k] / ρ[i, 1, k] + θ′(xC[i], 0, zC[k]); π = Π(i, 1, k, grid, gas, Θ). ρ[i, 1, k] = pₛ / (Rᵈ*θ) * π^(cᵥ/Rᵈ); Θ[i, 1, k] = ρ[i, 1, k] * θ; ```. From a user's perspective this is much more complicated than using Oceananigans' `set!` function. To further complicate things, how ρ is computed will change if you're running with entropy as a prognostic variable instead of potential temperature. > If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). This sounds like a good idea and would be of great benefit to users. > What does the jargon ""sounding"" mean?. Ah sorry I'm referring to [atmospheric soundings](https://en.wikipedia.org/wiki/Atmospheric_sounding). From talking to @thabbott apparently it's pretty common to initialize a model using observational data obtained from e.g. a weather balloon. Apparently some models get pretty fancy and construct a hydrostatic base state from the sounding to avoid transient acoustic waves when running the model. > I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. Hmmm, I wasn't super into the idea of a new `Simulation` type before but with multiple",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155:1429,variab,variable,1429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155,1,['variab'],['variable']
Modifiability," Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:1174,config,config,1174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457,1,['config'],['config']
Modifiability," c is a two-dimensional wave depending on an x wavenumber $\kappa$, a y wavenumber $\mathcal{l}$, and a time-dependent amplification factor $\xi(t)$, then; $c^n_{ij} = \xi^n \exp{(- \Im \kappa \cdot i \Delta x - \Im \mathcal{l} \cdot j \Delta y)}$. (because of overlap with the x-index $i$, I defined $\Im$ as the imaginary number $\Im = \sqrt{-1}$); Substituting this definition of $c$ and dividing through by $c^n_{ij}$ we get; $$\frac{\xi^{n+1} / \xi^n - 1}{\Delta t} = u \left(\frac{1 - \exp{(- \Im \kappa \Delta x)}}{\Delta x}\right) + v \left(\frac{1 - \exp{(- \Im \mathcal{l} \Delta y)}}{\\Delta y}\right)$$; we can make use of $\exp{\Im \theta} = \cos{\theta} + \Im \sin{\theta}$ and rewrite a bit:; $$\frac{\xi^{n+1}}{\xi^n} = 1 + \Delta t \cdot \left[ \frac{u}{\Delta x} \left( 1 - \cos{\kappa \Delta x} + \Im \sin{\kappa\Delta x}\right) + \frac{v}{\Delta y} \left( 1 - \cos{\mathcal{l} \Delta y} + \Im \sin{\mathcal{l} \Delta y} \right) \right]$$; Now, to ensure stability, the real part of $\xi^{n+1} / \xi^n$ should be bounded, so we have to ensure that; $$\left| \Re \left( \frac{\xi^{n+1}}{\xi^n} \right) \right| < 1$$; This yields; $$-2 < \Delta t \cdot \left[ \frac{u}{\Delta x} \left( 1 - \cos{\kappa \Delta x} \right) + \frac{v}{\Delta y} \left( 1 - \cos{\mathcal{l} \Delta y} \right) \right] < 0$$; The right inequality does not limit $\Delta t$, but the left does:; $$\Delta t \cdot \left[ \frac{u}{\Delta x} \left( 1 - \cos{\kappa \Delta x} \right) + \frac{v}{\Delta y} \left( 1 - \cos{\mathcal{l} \Delta y} \right) \right] < 2$$; The worst-case scenario occurs when both cosines evaluate to -1, to hit this condition it is enough to have grid-scale noise, which has the maximum expressible wavenumber of $\kappa = \pi / \Delta x$. In this case we have; $$\Delta t \cdot \left( \frac{u}{\Delta x} + \frac{v}{\Delta y} \right)< 1$$; Since the direction is arbitrary you can substitute $u$ and $v$ with their absolute values and you get; $$\Delta t < \left( \frac{|u|}{\Delta x} + ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3037#issuecomment-1489468511:1139,rewrite,rewrite,1139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3037#issuecomment-1489468511,1,['rewrite'],['rewrite']
Modifiability," functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells.; > ; > I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. Quick question: Have you checked the performance here? I ask because the model was running pretty slowly when I was testing https://github.com/CliMA/Oceananigans.jl/pull/2275...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847:1950,extend,extend,1950,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847,1,['extend'],['extend']
Modifiability," if we consider for now just a 1D problem with boundary point $\phi_b$ and interior points at $\phi_{b-1}$ etc. When we go to update the boundary point we have $\phi_b^n$ and $\phi_{b-1}^{n+1}$ and we want $\phi_b^{n+1}$. As per previous work we assume that the bulk speed is the same at both $b$ and $b-1$ but we don't have both the spatial and time derivatives of the $\phi$ interior at the same step so we first need to approximate the previous step as:. $\phi_{b-i}^n = \phi_{b-i}^{n+1}-\Delta t G^n_{b+1}$. We can then find the bulk velocity at timestep n as:. $U_b^n = -\frac{2\Delta x_{b-1}G^n_{b-1}}{\phi^n_b - \phi^{n+1}_{b-2} - \Delta t G^n _{b-2}}$. We then have all the information to step $\phi_b$ to:. $\phi_b^{n+1}=\phi_b^n-\frac{\Delta t}{\Delta x_b}U_b(\phi_b^n-\phi_{b-1}^{n+1} - \Delta t G^n_{b-1})$. This will require us to give the boundary condition both the tendencies and $\Delta t$, but this seems to be the easiest thing to change. I also think this is the only way we can get a physically sensible bulk speed where all of the components are calculated at the same timestep. I have also realised that we need to have an exterior value for every open boundary for when the flow spontaneously becomes an inflow so I think it would make sense to have every open boundary be the same and just be `OpenBoundaryCondition(external_value)`, and then put the tendencies etc in as arguments to `_fill_X_halo!`. Then when `U_b` is negative we either set the value or do nudging like in ROMS to prevent shocks (but I think this is a question for further down the line). We might also want to consider oblique waves but that shouldn't be too hard to extend to we might just have to calculate a lot of surrounding points which might motivate some other way to do it. Does this make sense to everyone? I also can't see an obvious way to get $\Delta t$ to the halo fill since it doesn't even make it into the `update_state!` so any suggestions would be appreciated. Update:. I'm not sure if",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971616810:2112,extend,extend,2112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971616810,1,['extend'],['extend']
Modifiability," push!(Rit, deepcopy(interior(Ri, 1, 1, :))); push!(bt, deepcopy(interior(b, 1, 1, :))); push!(ut, deepcopy(interior(u, 1, 1, :))); push!(et, deepcopy(interior(e, 1, 1, :))); push!(κct, deepcopy(interior(κc, 1, 1, :))); push!(κut, deepcopy(interior(κu, 1, 1, :))). return nothing; end. t = 0:10minutes:simulation.stop_time; Nt = length(t). simulation.callbacks[:dc] = Callback(collect_data, SpecifiedTimes(t)). run!(simulation). fig = Figure(resolution=(800, 600)). axR0 = Axis(fig[1, 1], xlabel=""Ri⁻¹"", ylabel=""z (m)""); axe0 = Axis(fig[2, 1], xlabel=""e"", ylabel=""z (m)"", xticks=[1e-6, 2e-5]); axκ0 = Axis(fig[3, 1], xlabel=""κ"", ylabel=""z (m)"", xticks=[0.0, 2e-3, 4e-3]). axR = Axis(fig[1, 2], xlabel=""Time (hr)"", ylabel=""z (m)"", xaxisposition=:top); axe = Axis(fig[2, 2], ylabel=""z (m)""); axκ = Axis(fig[3, 2], xlabel=""Time (hr)"", ylabel=""z (m)""). hidexdecorations!(axe). hidespines!(axR0, :r, :t); hidespines!(axe0, :r, :t); hidespines!(axκ0, :r, :t). Prt = map((κu, κc) -> κu ./ κc, κut, κct). bzt = hcat(bt...)'; Rzt = hcat(Rit...)'; ezt = hcat(et...)'; κzt = hcat(κct...)'; Pzt = hcat(Prt...)'. zc = znodes(grid, Center()); zf = znodes(grid, Face()). for n = (7, 49, 24*4+1); @show tn = t[n] / hour; label = @sprintf(""t = %d hr"", tn); lines!(axR0, 1 ./ Rit[n], zf; label); ln = lines!(axe0, et[n], zc); lines!(axκ0, κct[n], zf, color = ln.color.val, label=""κᶜ""); lines!(axκ0, κut[n], zf, linestyle=:dash, color=ln.color.val, label=""κᵘ""); end. Legend(fig[2, 0], axR0); Legend(fig[3, 0], axκ0, merge=true). vlines!(axR0, 4, color=(:gray, 0.5), linewidth=4). cr = contourf!(axR, t ./ hour, zf, 1 ./ Rzt, levels = 0:10, colormap=:viridis)#, extendhigh=true, extendlow=true); Colorbar(fig[1, 3], cr, label=""Ri⁻¹""). cr = contourf!(axe, t ./ hour, zc, ezt, levels=10, colormap=:heat); Colorbar(fig[2, 3], cr, label=""E (m² s⁻²)""). cr = contourf!(axκ, t ./ hour, zf, κzt, levels=10, colormap=:solar); Colorbar(fig[3, 3], cr, label=""κᶜ (m² s⁻¹)""). colsize!(fig.layout, 1, Relative(0.2)). display(fig); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3090#issuecomment-1528811970:2692,extend,extendhigh,2692,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3090#issuecomment-1528811970,2,['extend'],"['extendhigh', 'extendlow']"
Modifiability," well, complex, and I don't pretend to understand the nuances there, but in simple rectilinear geometries, I think it would be fairly easy to have an option to go between rigid-lid and linear free-surface in both `NonhydrostaticModel` and `HydrostaticModel`. Is this true? Would people want these options?. Yes, any solver for an implicit free surface can be generalized with some small code modifications to the rigid lid case. When using a _direct_ solve, there is negligible or actually zero difference in cost between an implicit free surface and rigid lid. When using an iterative solve, the rigid lid can be more expensive because the solution may not converge as quickly. I don't think a linear + porous free surface with a fixed grid is very useful in the non-hydrostatic model (in some respects the resulting model might be a worse approximation to any real ocean scenario). It can be done, but I don't think there is much benefit from a modeling perspective. With a breathing / moving grid that follows the surface the story might be a bit different. Having such an abstraction would enable some neat problems that are difficult to solve with any code. But for that someone would have to refactor the non hydrostatic model to use generalized vertical coordinates, and also develop a new pressure solver. This paper by Sullivan and McWilliams describe such a model for atmospheric simulations with a moving, weakly distorted lower boundary:. https://journals.ametsoc.org/view/journals/atsc/71/11/jas-d-14-0095.1.xml. In that paper the ""undistorted"" pressure solve is used a preconditioner for a fixed point iteration. We could do the same thing except with a conjugate gradient iteration (possibly slightly better than a fixed point iteration). It's possibly a nice project for someone interested in LES above or below weakly distorted boundaries. Note that this method probably won't work when the bathymetry is ""too big"", because the iterative solve may converge too slowly. cc @whitleyv .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882660514:1616,refactor,refactor,1616,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882660514,1,['refactor'],['refactor']
Modifiability," … 0.00%; Time (median): 9.717 ms ┊ GC (median): 0.00%; Time (mean ± σ): 9.797 ms ± 271.120 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █ █ █ █ █; █▁█▁▁▁▁▁▁█▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 9.61 ms Histogram: frequency by time 10.3 ms <. Memory estimate: 89.45 KiB, allocs estimate: 320. ```. on this branch:; ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true,; bathymetry = random_bathymetry()); trial1 = run_model_benchmark!(momentum_kernel_test, arch; use_benchmarktools = true, bottom_height = random_bathymetry()) = Trial(13.991 ms); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 13.991 ms … 22.167 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 14.057 ms ┊ GC (median): 0.00%; Time (mean ± σ): 15.676 ms ± 3.629 ms ┊ GC (mean ± σ): 0.00% ± 0.00%. █; █▇▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▇ ▁; 14 ms Histogram: frequency by time 22.2 ms <. Memory estimate: 487.70 KiB, allocs estimate: 766. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools = true,; bathymetry = random_bathymetry()); trial1 = run_model_benchmark!(tracer_kernel_test, arch; use_benchmarktools = true, bottom_height = random_bathymetry()) = Trial(4.807 ms); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 4.807 ms … 5.457 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 4.819 ms ┊ GC (median): 0.00%; Time (mean ± σ): 4.958 ms ± 281.609 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █▁ ▁ ▁; ██▁▁▁▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 4.81 ms Histogram: frequency by time 5.46 ms <. Memory estimate: 88.53 KiB, allocs estimate: 261. ```; A test on the global ocean configuration (found in [prototype_omip_simulation.jl](https://github.com/CliMA/ClimaOcean.jl/blob/aacd2e19b81e35a3b220bd45aa6b5bcb98dc876d/prototype_omip_simulation/prototype_omip_simulation.jl) ) is incoming",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2243530643:2789,config,configuration,2789,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2243530643,1,['config'],['configuration']
Modifiability,"""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active project, LOAD_PATH, and DEPOT_PATH) from the main process. Keyword arguments:. • restrict::Bool: if true (default) binding is restricted to 127.0.0.1. • dir, exename, exeflags, env, topology, lazy, enable_threaded_blas: same effect as for SSHManager, see documentation for; addprocs(machines::AbstractVector). │ Julia 1.9; │; │ The inheriting of the package environment and the env keyword argument were added in Julia 1.9.; ```. Ha! I was testing locally with v1.9 but the docs use v1.8.5; Seems like from v1.9 onwards the package environment is inherited so we don't need to instantiate multiple times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:6210,inherit,inherit,6210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,3,['inherit'],"['inherit', 'inherited', 'inheriting']"
Modifiability,"""slow moving"" and carefully curated --- like a textbook --- while using GitHub discussions to encapsulate ""living"", transient, and often more fine-grained knowledge about usage, experimental / rapidly changing features, and generally things that might require extended discussion and benefit from clarification questions. In part this means mostly avoiding tagging issues and pull requests in the documentation. The motivation for this approach has a few parts. First is to clarify ""what belongs in the docs"" versus what kinds of things will be documented elsewhere on the vast internet, so that people know where to look to get the answers they need. The second reason is to help control the development of docs by the community. As the code grows, the docs will have to necessarily grow to become very long. The docs are much shorter than they should be right now because the hydrostatic model in particular is still somewhat ""experimental"" (it's a multi-year effort to develop a fully functional GCM, and we are in the thick of it now). There will be so much more in the docs in the end --- a dozen or more parameterizations for ocean turbulence, sea ice, biogeochemistry, and on and on. As a result, it's going to become very important that the docs are as concise as possible (eg, the same constraint we face when writing a textbook). Thus in this process we'll have to carefully curate whatever goes into the docs as a community, and I think it will be helpful if the docs are only used for ""big"" things. A third reason is just that I think this is will reduce the effort required to maintain docs. For example, this change to the docs will become incorrect when we merge the multi-region PR (which hopefully will be soon). That means that we need to update the docs when we merge that PR. Maybe we will remember this time, but in general I think this approach doesn't scale, and also does something highly undesirable by placing barriers in the way of development. What do you think @tomchor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498:1307,parameteriz,parameterizations,1307,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498,1,['parameteriz'],['parameterizations']
Modifiability,"# Progress update. I decided to take a stab at the simplest case: triply-periodic on the CPU. Surprisingly I was able to get a distributed `IncompressibleModel` running just using multiple dispatch without having to modify any existing code, although a cleaner design might require a bit of refactoring. PR is still a work-in-progress so it's a bit messy, the purpose was to demonstrate a proof of concept. MPI.jl and PencilFFTs.jl are new dependencies but I haven't updated the Project.toml yet. So far this PR adds some new infrastructure:; 1. Distributed/multi-architectures (e.g. `MultiCPU`) that know about rank connectivity.; 2. Halo communication between ranks is done via multiple dispatch on a new `HaloCommunicationBC` type.; 3. A `DistributedFFTBasedPoissonSolver` for solving Poisson equations across ranks.; 4. A `DistributedModel` that creates local grids for each ranks, injects halo communication BCs, and passes the distributed pressure solver to a local `IncompressibleModel`. I also added some simple tests for multi architecture rank connectivity, local grid construction, injection of halo communication BCs, and halo communication (testing x, y, and z slab decompositions). Also added tests for the distributed Poisson solver ensuring the solution is divergence-free. Next step for testing would probably be to test that the code handles `Bounded` topologies correctly then add tests that reproduce the regression tests but on multiple ranks and ensure the output matches the regression output. ## Some notes. ### Domain decomposition. Domain decomposition is supported and tested in x, y, and z. But for `IncompressibleModel` z-decomposition won't work right now because vertical integrals are done inside GPU kernels (so we probably don't want to decompose in z). And PencilFFTs.jl supports decompositions in dimensions 2 and 3 (since dimension 1 FFTs are the fastest). As a result, right now Oceananigans.jl only supports slab decompositions in y although we should figure out",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066:291,refactor,refactoring,291,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066,1,['refactor'],['refactoring']
Modifiability,## try. Configuration problem:; bors.toml: not found,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-904920702:8,Config,Configuration,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-904920702,1,['Config'],['Configuration']
Modifiability,"(@simone-silvestri, until we implement the refactor and/or changes, what's the best way forward using v0.87.1?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695628026:43,refactor,refactor,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695628026,1,['refactor'],['refactor']
Modifiability,(I'll wait to see how the Plots.jl issue discussion evolves... perhaps the answer comes from there.),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1107#issuecomment-717580519:52,evolve,evolves,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1107#issuecomment-717580519,1,['evolve'],['evolves']
Modifiability,"**Can we use advection for mass evolution equation?**. Let me try and convince you that using advection for continuity makes sense. If I don't succeed then clearly I need to put more thought into it. The governing equation can be written in two forms; $$; \partial_t = -\partial_x (h u) - \partial_y (h v) = - \partial_x U - \partial_y V ; $$; If we were to solve this in terms of the velocities (u,v), then using advection is clearly a good idea as we are advecting h by the velocity. In the case of upwinding, we pick the direction based on the sign of u (or v). We are using the transports instead of velocities but it is very similar to the advection of a tracer $\nabla \cdot (u c)$ except that we use c = 1. Given that the physics is the same in both cases, I think we should be using the advection scheme for this term. . The evolution equations for h and c have a lot in common, which is helpful here. The one major difference is that h is an active tracer in the sense that it feeds back on the momentum. Even though that's the case, I don't think this should affect how we discretize the advection of h, even though it is disguesed with our use of the transport variable. If you agree with my reasoning I don't think we need to do anything different for the evolution of height equation, we might just need to have some new functions that account for this, which are essentially equivalent to c = 0. Maybe what you suggest is the way to proceed?. **High Order Finite Volume**. I agree that keeping things finite volume is a good idea, and that is how I would like to proceed. Good to know that IncompressibleModel won't generalize to higher order. I agree that the 4th-order pieces are there and just need to be assembled. The paper you cited above is very helpful but needs to be modified slightly as they present the method for a non-staggered grid, but ours is staggered. That is not problem, I just need to work through the details. Unless they have been done already?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744478924:1172,variab,variable,1172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744478924,1,['variab'],['variable']
Modifiability,"**Note to self**: Seems like the golden master tests fail on Mac (Travis CI) so it seems that JLD might not be portable (although I generated the JLD checkpoint files on Windows and the Linux tests pass). So for golden master testing I should rely on NetCDF output which is guaranteed to be portable. **EDIT**: Hmmm, it might actually just be finicky (sometimes passes, sometimes doesn't). Another reason to use NetCDF. But so far if I keep running the tests on my laptop it always passes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/140#issuecomment-474858478:111,portab,portable,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140#issuecomment-474858478,2,['portab'],['portable']
Modifiability,", 2, 3...`.; * With `maxiter=100`, the problem is stable with `OpenBoundaryCondition` on west and east. At late times, the solver converges very quickly, in 1-5 iterations. I'd like to analyze the divergence more, but it seems that it is substantially higher with `FlatExtrapolationOpenBoundaryCondition`. I would also like to understand the convergence rate, which seems slower than with a prescribed outflow. From these results we see that `maxiter` should probably be set right now as a matter of practice. I think that even a handful of CG iterations is probably preferred to simply using the FFT solver naively with no CG iteration. There's also future work to understand the interaction of the solver with open boundary conditions. Finally I would like to point out that there is probably little to gain, from a computational point of view, in using the FFT-based solver with 100+ CG iterations. If we are using 100+ iterations, we might as well use a faster preconditioner. My script adapted from @ali-ramadhan's:. ```julia; using Printf; using Statistics; using Oceananigans; using Oceananigans.Grids: with_number_type; using Oceananigans.BoundaryConditions: FlatExtrapolationOpenBoundaryCondition; using Oceananigans.Solvers: ConjugateGradientPoissonSolver, fft_poisson_solver; using Oceananigans.Utils: prettytime. N = 16; h, w = 50, 20; H, L = 100, 100; x = y = (-L/2, L/2); z = (-H, 0). grid = RectilinearGrid(size=(N, N, N); x, y, z, halo=(2, 2, 2), topology=(Bounded, Periodic, Bounded)). mount(x, y=0) = h * exp(-(x^2 + y^2) / 2w^2); bottom(x, y=0) = -H + mount(x, y); grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)). prescribed_flow = OpenBoundaryCondition(0.01); extrapolation_bc = FlatExtrapolationOpenBoundaryCondition(); u_bcs = FieldBoundaryConditions(west = prescribed_flow,; east = extrapolation_bc); #east = prescribed_flow). boundary_conditions = (; u=u_bcs); reduced_precision_grid = with_number_type(Float32, grid.underlying_grid); preconditioner = fft_poisson_s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2415367426:1369,adapt,adapted,1369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2415367426,1,['adapt'],['adapted']
Modifiability,"-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don't need that). `DiscreteBoundaryFunction` won't be very convenient for most people for immersed boundary conditions, but we can treat it the same way we treat constant `Value` or `Flux`. I wasn't planning to implement support for `Gradient` just yet, though this can be done too. Finally, one remaining task is to define or generalize the existing `conditional_flux` so that it adds fluxes only on _immersed_ boundaries. It looks like right now it's too eager and will add fluxes on non-immersed boundaries. Associated with this development I'd like to refactor our naming scheme for the boolean tools we have. Right now these are `solid_node` and `solid_interface`. I'd like to change `solid_node` to `external_node` (ie external to the active domain) and perhaps something like `external_or_boundary_node` for `solid_interface` to represent _both_ nodes that are completely external, or which lie",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:1817,extend,extended,1817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991,1,['extend'],['extended']
Modifiability,". Some notes:. A new Poisson solver has been added that solves Poisson's equation with periodic boundary conditions in the x and staggered Neumann BCs in the y and z. This involves computing a 2D DCT on the GPU, which has no native DCT, so I implemented the fast 2D cosine transform from Makhoul (1980). Unfortunately the 2D FCT does not generalize from the 1D version, and extra steps are involved. In particular, as Fourier coefficients need to be indexed in multiple ways in some statements, we need a second buffer/storage array until I can figure out whether this is necessary. A couple of 1D masks are also needed. Anyways, so this PNN Poisson solver is a little involved, but is still decently fast. We have more tests and more GPU tests in general, but this also means that the test suite takes even longer to run especially with GPUs. I've moved each test set to it's respective file so we can use the regression tests as a stand-alone . In particular, this PR heavily refactors `poisson_solvers.jl`. It's more modular, concrete, and better documented I still need to describe the algorithms in the docs, especially important as it's not easy to figure this out and the only references are sparse papers (no code or implementations as far as I can tell). `time_steppers.jl` has also been cleaned up. Several kernels were converted to broadcasts. I also removed several bits of code that aren't used anymore. I considered making separate PRs to clean things up but I had to refactor and clean up to implement stuff so I ended up doing it all in this PR. The front-end has not changed at all but this PR ended up changing/cleaning a lot of the backend so I'd like to merge it ASAP before it starts to go out of date. Currently it's twice as slow as running a doubly periodic model. Will have to profile to figure out where it's spending that extra time. For reference, a P100 is roughly 3x slower than a V100.; ```; Nvidia P100 N=128^3; Periodic: 12 ms/iteration; Channel: 28 ms/iteration; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/290#issuecomment-506884950:1670,refactor,refactor,1670,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/290#issuecomment-506884950,1,['refactor'],['refactor']
Modifiability,".julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel ~/.julia/packages/CommonDataModel/GGvMn/src/cfvariable.jl:477; [6] save_output!(ds::NCDatasets.NCDataset{…}, output::Field{…}, model::NonhydrostaticModel{…}, ow::NetCDFOutputWriter{…}, time_index::Int64, name::String); @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:482; [7] write_output!(ow::NetCDFOutputWriter{…}, model::NonhydrostaticModel{…}); @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:525; [8] initialize!(sim::Simulation{…}); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:212; [9] time_step!(sim::Simulation{…}); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:112; [10] run!(sim::Simulation{…}; pickup::Bool); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:97; [11] run!(sim::Simulation{NonhydrostaticModel{…}, Float64, Float64, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}}); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:85; [12] top-level scope; @ ~/repos/Oceananigans.jl/sandbox/mwe.jl:31; [13] include(fname::String); @ Base.MainInclude ./client.jl:489; ```. So it's not as trivial as the single change I just made. From glancing at the code we at least have to modify `initialize_nc_file!()` to take a `grid` option as well:. https://github.com/CliMA/Oceananigans.jl/blob/6730e6f6b2c8f1695e20b95ef467b5b14fdc4c5f/src/OutputWriters/netcdf_output_writer.jl#L625-L636. plus a couple of other things. Still pretty easy, but more work/time that I have right now. @iuryt feel free to jump in here and make these changes if you feel it's necessary, since creating a whole separate model can be a bit onerous and wastes precious GPU memory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084:3084,sandbox,sandbox,3084,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084,1,['sandbox'],['sandbox']
Modifiability,"/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlined]; [23] invokelatest; @ ./essenti",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7133,adapt,adapt,7133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685,1,['adapt'],['adapt']
Modifiability,/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `79.76% <100.00%> (+3.85%)` | :arrow_up: |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `87.50% <0.00%> (-12.50%)` | :arrow_down: |; | [src/Models/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `80.00% <0.00%> (-8.89%)` | :arrow_down: |; | [src/Models/Models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `100.00% <0.00%> (ø)` | |; | [src/TimeSteppers/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <0.00%> (ø)` | |; | [src/Forcing/parameterized\_forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvcGFyYW1ldGVyaXplZF9mb3JjaW5nLmps) | `100.00% <0.00%> (ø)` | |; | [src/BoundaryConditions/apply\_no\_penetration\_bcs.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9ub19wZW5ldHJhdGlvbl9iY3Muamw=) | `58.33% <0.00%> (+1.19%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `92.30% <0.00%> (+3.41%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/698#issuecomment-599273522:2348,parameteriz,parameterized,2348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/698#issuecomment-599273522,1,['parameteriz'],['parameterized']
Modifiability,"03 ms⁻¹, wall time: 576.511 ms; i: 0060, t: 1.415 min, Δt: 1.772 s, wmax = 5.2e-03 ms⁻¹, wall time: 571.096 ms; ```. In this case, the information we decide to print is:. * iteration number `i`; * the simulation time `t`; * the time-step (because we are using adaptive time-stepping); * the maximum vertical velocity; * the elapsed wall time for time stepping *only* (not including plotting) between print messages. I think this issue is about a better way to achieve the printing of simulation progress. Two ideas are:. 1. Somehow use a logging package (though I'm not 100% what this would look like --- perhaps this means adding lines to our [time-stepping loop](https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/src/time_steppers.jl#L28)?; 2. Create some types that allow the user to more easily manage the printing of progress messages, expanding on the pattern used in our example. I've thought a bit about 2: I think a generic progress messenger would be both configurable but also include some comforting defaults. A simple way to start could be something like. ```julia; struct ProgressPrinter{DT, M, D}; Δt :: DT; model :: M; diagnostics :: D; end; ```. with some kind of print function, something like. ```julia; pretty_Δt(Δt::Number) = prettytime(Δt); pretty_Δt(Δt::TimeStepWizard) = prettytime(wizard.Δt). function Base.print(progress::ProgressMessenger); @printf(""i: %04d, t: %s, Δt: %s, ; progress.model.clock.iteration, prettytime(progress.model.clock.time), pretty_Δt(progress.Δt)) ; return nothing; end; ```. One could then expand on this design by setting up the `diagnostics` field to accept a list of callable objects or functions. Or even better, a list of objects that look something like. ```julia; struct PrintableDiagnostic{D}; diagnostic :: D; format :: String; name :: String; units :: String; end. function pretty_diagnostic(pd::PrintableDiagnostic, model); return @sprintf(""%s: $(pd.format) %s"", pd.name, pd.diagnostic(model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:1953,config,configurable,1953,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,1,['config'],['configurable']
Modifiability,1. The structs do not need to be refactored if the setproperty method is used. . 2. There is only one struct for boundary conditions. What you really mean is that you will create a (new) special struct for z which is in practice identical to the struct for x and y except for the names of it’s fields.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/213#issuecomment-488176653:33,refactor,refactored,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/213#issuecomment-488176653,1,['refactor'],['refactored']
Modifiability,"1. Yes you're right. Currently Oceananigans.jl is only non-hydrostatic. We've considered adding a hydrostatic mode (shouldn't be hard to implement) but haven't really needed it yet so we've stuck with non-hydrostatic mode as we mostly do small-scale simulations (also see issue #72). Do you need to run in hydrostatic mode?. 2. Ah interesting. Like on a regular Cartesian grid but with some grid cells cut out so you effectively have a cylindrical domain but with jagged walls (that get smoother as you increase the resolution)? It's not a built-in feature but you could use the forcing functions to add topography via an immersed boundary method (basically damping the velocity to zero inside the boundary). For an example of this, see PR #693: Viscous flow around a cylinder verification experiment. We're happy to help with setting up this kind of stuff too. 3. No we don't have any mesoscale eddy parameterizations. Actually we don't really have any parameterizations in Oceananigans.jl besides turbulent diffusivity/viscosity closures as we've been mostly focused on running small-scale simulations that resolve the turbulence and trying to figure out the best parameterization from the data. Depending on what you need though, it might not be too hard to implement. It's worth discussing if you need something like GM Redi. 4. Hmmm, this isn't something that we've done as adding topography isn't really a built-in feature yet but it should be possible to impose a no-slip boundary condition at a cylindrical wall using a custom forcing function though, not an Oceananigans.jl boundary condition. I'm not 100% sure but if you want no-slip my guess is that you probably want to use a Value/Dirchlet boundary condition. I think @glwagner would know more about whether it's possible to properly implement a no-slip Value/Dirchlet BC on a curved boundary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/770#issuecomment-640688002:901,parameteriz,parameterizations,901,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/770#issuecomment-640688002,3,['parameteriz'],"['parameterization', 'parameterizations']"
Modifiability,"19"". [[NaNMath]]; git-tree-sha1 = ""bfe47e760d60b82b66b61d2d44128b62e3a369fb""; uuid = ""77ba4419-2d1f-58cd-9bb1-8ffee604a2e3""; version = ""0.3.5"". [[NetCDF_jll]]; deps = [""Artifacts"", ""HDF5_jll"", ""JLLWrappers"", ""LibCURL_jll"", ""LibSSH2_jll"", ""Libdl"", ""MbedTLS_jll"", ""Pkg"", ""Zlib_jll"", ""nghttp2_jll""]; git-tree-sha1 = ""d5835f95aea3b93965a1a7c06de9aace8cb82d99""; uuid = ""7243133f-43d8-5620-bbf4-c2c921802cf3""; version = ""400.701.400+0"". [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""FFTW"", ""Glob"", ""InteractiveUtils"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SafeTestsets"", ""SeawaterPolynomials"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""861d8cca4447304a21a94110e3ffc786cab52dce""; uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; version = ""0.56.0"". [[OffsetArrays]]; deps = [""Adapt""]; git-tree-sha1 = ""87a728aebb76220bd72855e1c85284c5fdb9774c""; uuid = ""6fe1bfb0-de20-5000-8ca7-80f57d26f881""; version = ""1.7.0"". [[OpenMPI_jll]]; deps = [""Libdl"", ""Pkg""]; git-tree-sha1 = ""41b983e26a7ab8c9bf05f7d70c274b817d541b46""; uuid = ""fe0851c0-eecd-5654-98d4-656369965a5c""; version = ""4.0.2+2"". [[OpenSSL_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""71bbbc616a1d710879f5a1021bcba65ffba6ce58""; uuid = ""458c3c95-2e84-50aa-8efc-19380b2a3a95""; version = ""1.1.1+6"". [[OpenSpecFun_jll]]; deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""9db77584158d0ab52307f8c04f8e7c08ca76b5b3""; uuid = ""efe28fd5-8261-553b-a9e1-b2916fc3738e""; version = ""0.5.3+4"". [[OrderedCollections]]; git-tree-sha1 = ""4fa2ba51070ec13fcc7517db714445b4ab986bdf""; uuid = ""bac558e1-5e72-5ebc-8fee-abe8a469f55d""; version = ""1.4.0"". [[Parsers]]; deps = [""Dates""]; git-tree-sha1 = ""c8abc88faa3f7a3950832ac5d6e690881590d6dc""; uuid = ""69de0a69-1ddd-5017-9359-2bf0b02dc9f0""; version = ""1.1.0"". [[Penci",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:11562,Adapt,Adapt,11562,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,"1f90decc"". [[SparseArrays]]; deps = [""LinearAlgebra"", ""Random""]; uuid = ""2f01184e-e22b-5df5-ae63-d93ebab69eaf"". [[SpecialFunctions]]; deps = [""ChainRulesCore"", ""OpenSpecFun_jll""]; git-tree-sha1 = ""5919936c0e92cff40e57d0ddf0ceb667d42e5902""; uuid = ""276daf66-3868-5448-9aa4-cd146d93841b""; version = ""1.3.0"". [[Static]]; deps = [""IfElse""]; git-tree-sha1 = ""ddec5466a1d2d7e58adf9a427ba69763661aacf6""; uuid = ""aedffcd0-7271-4cad-89d0-dc628f76c6d3""; version = ""0.2.4"". [[StaticArrays]]; deps = [""LinearAlgebra"", ""Random"", ""Statistics""]; git-tree-sha1 = ""e8cd1b100d37f5b4cfd2c83f45becf61c762eaf7""; uuid = ""90137ffa-7385-5640-81b9-e52037218182""; version = ""1.1.1"". [[StaticPermutations]]; git-tree-sha1 = ""193c3daa18ff3e55c1dae66acb6a762c4a3bdb0b""; uuid = ""15972242-4b8f-49a0-b8a1-9ac0e7a1a45d""; version = ""0.3.0"". [[Statistics]]; deps = [""LinearAlgebra"", ""SparseArrays""]; uuid = ""10745b16-79ce-11e8-11f9-7d13ad32a3b2"". [[StructArrays]]; deps = [""Adapt"", ""DataAPI"", ""Tables""]; git-tree-sha1 = ""44b3afd37b17422a62aea25f04c1f7e09ce6b07f""; uuid = ""09ab397b-f2b6-538f-b94a-2f83cf4a842a""; version = ""0.5.1"". [[StructTypes]]; deps = [""Dates"", ""UUIDs""]; git-tree-sha1 = ""e36adc471280e8b346ea24c5c87ba0571204be7a""; uuid = ""856f2bd8-1eba-4b0a-8007-ebc267875bd4""; version = ""1.7.2"". [[TOML]]; deps = [""Dates""]; git-tree-sha1 = ""44aaac2d2aec4a850302f9aa69127c74f0c3787e""; uuid = ""fa267f1f-6049-4f14-aa54-33bafae1ed76""; version = ""1.0.3"". [[TableTraits]]; deps = [""IteratorInterfaceExtensions""]; git-tree-sha1 = ""c06b2f539df1c6efa794486abfb6ed2022561a39""; uuid = ""3783bdb8-4a98-5b6b-af9a-565f29a5fe9c""; version = ""1.0.1"". [[Tables]]; deps = [""DataAPI"", ""DataValueInterfaces"", ""IteratorInterfaceExtensions"", ""LinearAlgebra"", ""TableTraits"", ""Test""]; git-tree-sha1 = ""c9d2d262e9a327be1f35844df25fe4561d258dc9""; uuid = ""bd369af6-aec1-5ad0-b16a-f7cc5008161c""; version = ""1.4.2"". [[TaylorSeries]]; deps = [""InteractiveUtils"", ""LinearAlgebra"", ""Markdown"", ""Requires"", ""SparseArrays""]; git-tree-sha1 = ""66f4d1993bae49eeba21a1634",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:15966,Adapt,Adapt,15966,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,"2 seconds; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 843.428 ms; │ ├── max(u): (2.48e-08, 1.37e-04, 3.09e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 6.17e-06 m; ```. When `IsopycnalSkewSymmetricDiffusivity` is included, however, we find. ```julia; julia> include(""near_global_one_degree.jl""); underlying_grid = LatitudeLongitudeGrid(arch; size = (Nx, Ny, Nz), halo = (4, 4, 4), latitude, z, longitude = (-180, 180), precompute_metrics = true) = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 259.679 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (319.597 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.116 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 1.121 seconds; │ ├── max(u): (1.94e-10, 4.57e-05, 1.03e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.03e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 998.405 ms; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (-16387479425.34, 18491107419.68) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stoppi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:2473,variab,variably,2473,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518,1,['variab'],['variably']
Modifiability,"2, time: 2 seconds, wall time: 998.405 ms; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (-16387479425.34, 18491107419.68) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 997.956 ms; │ ├── max(u): (9.82e+04, 7.85e+04, 2.49e+03) m s⁻¹; │ ├── extrema(T): (-1654340357512160890046119936.00, 2003185335144995241362194432.00) ᵒC; └ └── max|η|: 2.34e+03 m; ```. so the temperature is blowing up. The problem persists even when we don't have an immersed boundary:. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 229.227 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (290.636 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.441 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 1.446 seconds; │ ├── max(u): (7.77e-23, 4.67e-05, 1.18e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.18e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 1.348 seconds; │ ├── max(u): (1.04e-08, 9.33e-05, 2.36e-06) m s⁻¹; │ ├── extrema(T): (-456436497.24, 490120296.28) ᵒC; └ └── max|η|: 3.55e-06 m; [ Info: Simulation is stoppin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:4269,variab,variably,4269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518,1,['variab'],['variably']
Modifiability,"3x"" needed for RK3 to be superior. But that's just in theory. In practice we find that solutions become unstable at lower CFL, and caution warrants a bit of buffer. It seems like we usually use CFL=0.1-0.2 for AB2 but CFL=0.5-1 for RK3. So at the lower end for AB2, RK3 is indeed providing a decent speed up for time to solution. And I agree with you @ali-ramadhan that I have found in practice that I prefer RK3 for LES. There is more to the story --- RK3 also has superior stability properties for diffusion. Where there is some interesting room for further research is also to understand how much more stable RK3 might make a turbulence closure scheme like CATKE or k-epsilon. We do find that these can impose stricter time-step restrictions than advection, especially on grids with very fine vertical resolution near the surface. RK3 also has the crucial advantage that it is self-starting. This means we can change the time-step at will (without resolving this issue I guess) and we don't need tendencies to checkpoint. Also of course RK3 is actually 3rd order whereas QAB2 is first order. Note that the advantages of RK3 have historically not been useful for ocean simulations because at coarse (non-eddy-resolving) resolutions the momentum time-step is limited by Coriolis, not by CFL / advection. In that case a one-stage time-stepper might be preferred. > Out of curiousity, how much work is it to implement RK3 for HydrostaticFreeSurfaceModel?. It may be a research project to adapt the split-explicit free surface. It's little unclear because naively, we may be able to advance the split-explicit free surface each stage and therefore use the same algorithm we use for AB2. But there has been some work to implement an algorithm that resembles Le and Moin 1991 where the free surface is advanced to the end of the time-step, while baroclinic variables are advanced in stages. That would yield even more speed up. @simone-silvestri has thought about this a bit and might have more to add...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418061394:2482,adapt,adapt,2482,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418061394,2,"['adapt', 'variab']","['adapt', 'variables']"
Modifiability,"5 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlined]; [23] invokelatest; @ ./essentials.jl:714 [inlined]; [24] print_res",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7160,Adapt,Adapt,7160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685,2,['Adapt'],['Adapt']
Modifiability,"5] @doc(::LineNumberNode, ::Module, ::String, ::Vararg{Any,N} where N) at ./boot.jl:459; [6] include at ./boot.jl:326 [inlined]; [7] include_relative(::Module, ::String) at ./loading.jl:1038; [8] include at ./sysimg.jl:29 [inlined]; [9] include(::String) at /home/travis/build/climate-machine/Oceananigans.jl/src/Oceananigans.jl:1; [10] top-level scope at none:0; [11] include at ./boot.jl:326 [inlined]; [12] include_relative(::Module, ::String) at ./loading.jl:1038; [13] include(::Module, ::String) at ./sysimg.jl:29; [14] top-level scope at none:2; [15] eval at ./boot.jl:328 [inlined]; [16] eval(::Expr) at ./client.jl:404; [17] top-level scope at ./none:3; in expression starting at /home/travis/build/climate-machine/Oceananigans.jl/src/poisson_solvers.jl:173; in expression starting at /home/travis/build/climate-machine/Oceananigans.jl/src/poisson_solvers.jl:171; in expression starting at /home/travis/build/climate-machine/Oceananigans.jl/src/poisson_solvers.jl:171; in expression starting at /home/travis/build/climate-machine/Oceananigans.jl/src/Oceananigans.jl:149; ERROR: LoadError: Failed to precompile Oceananigans [6e00b360-fae3-11e8-3922-3d7cb9e50aad] to /home/travis/.julia/compiled/v1.1/Oceananigans/VuIZ2.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1197; [3] _require(::Base.PkgId) at ./loading.jl:960; [4] require(::Base.PkgId) at ./loading.jl:858; [5] require(::Module, ::Symbol) at ./loading.jl:853; [6] include at ./boot.jl:326 [inlined]; [7] include_relative(::Module, ::String) at ./loading.jl:1038; [8] include(::Module, ::String) at ./sysimg.jl:29; [9] exec_options(::Base.JLOptions) at ./client.jl:267; [10] _start() at ./client.jl:436; in expression starting at /home/travis/build/climate-machine/Oceananigans.jl/docs/make.jl:5; The command ""julia --project=docs/ docs/make.jl"" exited with 1.; Skipping the after_success step, as specified in the configuration.; Done. Your build exited with 1.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/153#issuecomment-477579168:5731,config,configuration,5731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/153#issuecomment-477579168,1,['config'],['configuration']
Modifiability,"6d7b675f75dd867b9f153685""; ---; > project_hash = ""bfbc7775b0a550569ac26abdec5f544ef80e881c""; 23c23; < git-tree-sha1 = ""76289dc51920fdc6e0013c872ba9551d54961c24""; ---; > git-tree-sha1 = ""02f731463748db57cc2ebfbd9fbc9ce8280d3433""; 25c25; < version = ""3.6.2""; ---; > version = ""3.7.1""; 37c37; < git-tree-sha1 = ""f83ec24f76d4c8f525099b2ac475fc098138ec31""; ---; > git-tree-sha1 = ""16267cf279190ca7c1b30d020758ced95db89cd0""; 39c39; < version = ""7.4.11""; ---; > version = ""7.5.1""; 93,94c93,94; < deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; < git-tree-sha1 = ""f062a48c26ae027f70c44f48f244862aec47bf99""; ---; > deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LLVMLoopInfo"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; > git-tree-sha1 = ""64461b0e9df3069248979113ce8ab6d11bd371cf""; 96,97c96; < version = ""5.0.0""; < weakdeps = [""SpecialFunctions""]; ---; > version = ""5.1.0""; 99a99; > ChainRulesCoreExt = ""ChainRulesCore""; 101a102,105; > [deps.CUDA.weakdeps]; > ChainRulesCore = ""d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""; > SpecialFunctions = ""276daf66-3868-5448-9aa4-cd146d93841b""; >; 104c108; < git-tree-sha1 = ""35a37bb72b35964f2895c12c687ae263b4ac170c""; ---; > git-tree-sha1 = ""1e42ef1bdb45487ff28de16182c0df4920181dc3""; 106c110; < version = ""0.6.0+3""; ---; > version = ""0.7.0+0""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:3036,Adapt,Adapt,3036,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361,2,['Adapt'],['Adapt']
Modifiability,"76d070dc7195f47a4""; uuid = ""4fba245c-0d91-5ea0-9b3e-6abc04ee57a9""; version = ""3.1.7"". [[Artifacts]]; deps = [""Pkg""]; git-tree-sha1 = ""c30985d8821e0cd73870b17b0ed0ce6dc44cb744""; uuid = ""56f22d72-fd6d-98f1-02f0-08ddc0907c33""; version = ""1.3.0"". [[BFloat16s]]; deps = [""LinearAlgebra"", ""Test""]; git-tree-sha1 = ""4af69e205efc343068dc8722b8dfec1ade89254a""; uuid = ""ab4f0b2a-ad5b-11e8-123f-65d77653426b""; version = ""0.1.0"". [[Base64]]; uuid = ""2a0f44e3-6c83-55bd-87e4-b1978d98bd5f"". [[CEnum]]; git-tree-sha1 = ""215a9aa4a1f23fbd05b92769fdd62559488d70e9""; uuid = ""fa961155-64e5-5f13-b03f-caf6b980ea82""; version = ""0.4.1"". [[CFTime]]; deps = [""Dates"", ""Printf""]; git-tree-sha1 = ""bca6cb6ee746e6485ca4535f6cc29cf3579a0f20""; uuid = ""179af706-886a-5703-950a-314cd64e0468""; version = ""0.1.1"". [[CUDA]]; deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CompilerSupportLibraries_jll"", ""DataStructures"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""LLVM"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""MacroTools"", ""NNlib"", ""Pkg"", ""Printf"", ""Random"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""TimerOutputs""]; git-tree-sha1 = ""e4b37e96b0ff53f46b13b49d7e9091b154757dc4""; uuid = ""052768ef-5323-5732-b1bb-66c8b64840ba""; version = ""2.4.3"". [[Cassette]]; git-tree-sha1 = ""742fbff99a2798f02bd37d25087efb5615b5a207""; uuid = ""7057c7e9-c182-5462-911a-8362d720325c""; version = ""0.3.5"". [[ChainRulesCore]]; deps = [""Compat"", ""LinearAlgebra"", ""SparseArrays""]; git-tree-sha1 = ""5402b5674b3068ca570771c11da9a57bfa70acd4""; uuid = ""d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""; version = ""0.9.39"". [[Compat]]; deps = [""Base64"", ""Dates"", ""DelimitedFiles"", ""Distributed"", ""InteractiveUtils"", ""LibGit2"", ""Libdl"", ""LinearAlgebra"", ""Markdown"", ""Mmap"", ""Pkg"", ""Printf"", ""REPL"", ""Random"", ""SHA"", ""Serialization"", ""SharedArrays"", ""Sockets"", ""SparseArrays"", ""Statistics"", ""Test"", ""UUIDs"", ""Unicode""]; git-tree-sha1 = ""ac4132ad78082518ec2037ae5770b6e796f7f956""; uuid = ""34da2185-b29b-5c13-b0c7-acf172513d20""; version = ""3.27.0"". [[CompilerSup",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:1532,Adapt,Adapt,1532,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,": Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.; • topology=:all_to_all: All processes are connected to each other. The default.; • topology=:master_worker: Only the driver process, i.e. pid 1 connects to the workers. The workers do not connect to each; other.; • topology=:custom: The launch method of the cluster manager specifies the connection topology via fields ident and; connect_idents in WorkerConfig. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:4973,variab,variable,4973,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['variab'],['variable']
Modifiability,": ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0. julia> u = Field((Face, Center, Center), grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0; ```; I am using ; ```; (Oceananigans) pkg> st; Project Oceananigans v0.77.4; Status `~/stable_oceananigans/Oceananigans.jl/Project.toml`; [c963dde9] AMGX v0.1.2; [79e6a3ab] Adapt v3.4.0; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.12.0; ⌃ [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; ⌅ [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; ⌃ [033835bb] JLD2 v0.4.22; ⌅ [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.7; [6fe1bfb0] OffsetArrays v1.12.7; [bac558e1] OrderedCollections v1.4.1; ⌃ [0e08944d] PencilArrays v0.17.6; [4a48f351] PencilFFTs v0.14.1; ⌃ [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.12; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics; Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ cannot be ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152:2826,Adapt,Adapt,2826,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152,1,['Adapt'],['Adapt']
Modifiability,"; Found 19 tag-pointing refs : refs/tags/v0.10.0, refs/tags/v0.10.1, refs/tags/v0.11.0, ...; Found 273 commit-pointing refs : HEAD, refs/heads/ar/lid-driven-cavity, refs/heads/ar/more-solvers, ... Protected commits; -----------------. These are your protected commits, and so their contents will NOT be altered:. * commit 91e5626e (protected by 'HEAD'). Cleaning; --------. Found 3270 commits; Cleaning commits: 100% (3270/3270); Cleaning commits completed in 35,468 ms. Updating 255 Refs; -----------------. Ref Before After ; ------------------------------------------------------------------------------; refs/heads/ar/lid-driven-cavity | 8eae1762 | 0401753a; refs/heads/ar/more-solvers | 5446ae47 | 4cf1d809; refs/heads/ar/vertically-stretched-grid | 695eb278 | 50fbc9d0; refs/heads/arbitrary-tracers-inner-loops | 2440af95 | c3c4ce7b; refs/heads/forced-flow-test | 5355044d | 4771446c; refs/heads/gh-pages | 3ecbff38 | da919955; refs/heads/glw/beaufort-gyre-example | 0e54d846 | 6fa7725a; refs/heads/glw/circulation-experiment | de5764b9 | a53c1648; refs/heads/glw/craik-leibovich-terms | 972fbd17 | 956d4739; refs/heads/glw/eady-example | c53227c8 | d8d29f47; refs/heads/glw/fix-eady-typos | 84e7d974 | f43c5dde; refs/heads/glw/mesoscale-closures | 1d0090ec | 62b6fc9c; refs/heads/glw/mesoscale-closures-biharmonic-diffusivity | 7a765f2a | fe555ef7; refs/heads/glw/mesoscale-closures-kernel-refactor | 43886b98 | 187742f0; refs/heads/glw/mesoscale-closures-leith | 54bcd904 | f1f57ae2; ... Updating references: 100% (255/255); ...Ref update completed in 3,524 ms. Commit Tree-Dirt History; ------------------------. Earliest Latest; | |; ................DmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmDDDD. D = dirty commits (file tree fixed); m = modified commits (commit message or parents changed); . = clean commits (no changes to file tree). Before After ; -------------------------------------------; First modified commit | a8b6b6cf | 69bcf932; Last dirty commit | 3ecbff38 | da919955. Deleted f",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/509#issuecomment-549156736:2622,refactor,refactor,2622,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/509#issuecomment-549156736,1,['refactor'],['refactor']
Modifiability,"; Installed Missings ──────────────────── v1.2.0; Installed StringManipulation ────────── v0.3.4; Installed UnsafeAtomics ─────────────── v0.2.1; Installed SortingAlgorithms ─────────── v1.2.1; Installed Atomix ────────────────────── v0.1.0; Installed LLVM ──────────────────────── v8.0.0; Precompiling project...; ✓ LLVMLoopInfo; ✓ DataValueInterfaces; ✓ Reexport; ✓ IteratorInterfaceExtensions; ✓ LaTeXStrings; ✓ InvertedIndices; ✓ ExprTools; ✓ DataAPI; ✓ Requires; ✓ CompilerSupportLibraries_jll; ✓ OrderedCollections; ✓ Compat; ✓ AbstractFFTs; ✓ InlineStrings; ✓ Scratch; ✓ CEnum; ✓ StaticArraysCore; ✓ TableTraits; ✓ Missings; ✓ PooledArrays; ✓ BFloat16s; ✓ Preferences. ✓ Adapt; ✓ Statistics; ✓ SentinelArrays; ✓ Compat → CompatLinearAlgebraExt; ✓ Crayons; ✓ UnsafeAtomics; ✓ CUDA_Runtime_Discovery; ✓ PrecompileTools; ✓ JLLWrappers; ✓ Tables; ✓ RandomNumbers; ✓ Atomix; ✓ TimerOutputs; ✓ AbstractFFTs → AbstractFFTsTestExt; ✓ NVTX_jll; ✓ JuliaNVTXCallbacks_jll; ✓ MacroTools; ✓ LLVMExtra_jll; ✓ CUDA_Driver_jll; ✓ Random123; ✓ DataStructures; ✓ StringManipulation; ✓ FixedPointNumbers; ✓ SortingAlgorithms; ✗ CUDA_Runtime_jll; ✓ ColorTypes; ✓ LLVM; ✓ LLVM → BFloat16sExt; ✓ StaticArrays; ✓ Adapt → AdaptStaticArraysExt; ✓ StaticArrays → StaticArraysStatisticsExt; ✓ UnsafeAtomicsLLVM; ✓ Colors; ✓ GPUArraysCore; ✓ NVTX. ✓ GPUArrays; ✓ KernelAbstractions; ✓ PrettyTables; ✓ GPUCompiler; ✓ DataFrames; ✗ CUDA; 61 dependencies successfully precompiled in 190 seconds. 5 already precompiled. The following 1 direct dependency failed to precompile:. CUDA [052768ef-5323-5732-b1bb-66c8b64840ba]. Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_UQIv2i"".; [45592] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:3638,Adapt,Adapt,3638,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,3,['Adapt'],"['Adapt', 'AdaptStaticArraysExt']"
Modifiability,"> 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.). I quite like the current convention for specifying fluxes since (imho) it's more mathematically intuitive, so my vote goes to maintaining that convention if we can (although I agree that it makes it harder to apply it generally for immersed solids...). One way to do it would be to leave most of the heavy work for the user, which would have to specify fluxes in each of the immersed solid's interfaces separately. The user's script would look like what I did here:; https://github.com/CliMA/Oceananigans.jl/blob/faed0c4ac85409cb94811b0bdba2bbb7becf330a/sandbox/drag_test.jl#L25-L41. The downside is that this won't work for non-grid-fitted boundaries and requires more user-written code. The upside is that could (I think) re-use much of the inner-workings of the current BC implementation. > We can do 2. without 1. In that case we'll be able to support a lot of common cases, including ordinary oceanic cases (where boundaries do not overhang, and we only specify drag on tangential components). It's really LES cases that become tricky because we can't specify drag on vertical velocity components, or on tangential components when the boundary overhangs. Not sure I understand this point. Do you mind clarifying @glwagner? By ""overhang"" do you mean that there's no fluid-to-the-bottom-immersed-boundary-to-the-top interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086345975:1053,sandbox,sandbox,1053,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086345975,1,['sandbox'],['sandbox']
Modifiability,"> 2\. Climate Machine also has a shallow water [model](https://github.com/CliMA/ClimateMachine.jl/blob/master/src/Ocean/ShallowWater/ShallowWaterModel.jl). I don't know the details of what this does but I should probably learn how the two models will differ. I'm not 100% sure how its implemented but I think at the end it'd be great if both ClimateMachine and Oceananigans shallow water models used the same equation set, since we can then compare the numerics. We don't have the bandwidth to develop the ClimateMachine shallow water model, but possibly at the time the Oceananigans has a nice one we'll be motivated to flesh out ClimateMachine's model. I'm not sure about immersed boundaries --- does the method generalize in a simple way? I'm not sure whether a special treatment is required for the height field, compared to an ordinary velocity variable, or tracer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726873787:850,variab,variable,850,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726873787,1,['variab'],['variable']
Modifiability,"> > > > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > > > ; > > > ; > > > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`.; > > ; > > ; > > I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time t before it is being advected to time t+Δt.; > ; > But in that case, when a time-step is complete, the radius has been computed at time `t` but the particle position is updated to time `t + Δt`. This means that if the user asks for output, the two are inconsistent with one another. Makes sense. `advect_lagrangian_particles!` first before `dynamics` it is!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874604866:47,evolve,evolve,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874604866,1,['evolve'],['evolve']
Modifiability,"> > > Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > > ; > > ; > > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there.; > ; > Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. Good point. > > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?; > ; > I think so, but I also don't think that you can guarantee this problem won't ever occur. The presence of the buoyancy does somehow impact the divergence that accumulates during a time-step / the pressure correction that has to be applied. So it's possible that the buoyancy configuration affects these results. Not sure. Yeah I see your point. I'll check `model.last_Δt` and report soon. I think it'll be good news if this is the culprit because it seems like we'd have fairly simple options to fix it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103036352:1318,config,configuration,1318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103036352,1,['config'],['configuration']
Modifiability,"> > > Hm.... `HydrostaticFreeSurfaceModel` does not support `BackgroundFields`....; > > ; > > ; > > > Hm.... `HydrostaticFreeSurfaceModel` does not support `BackgroundFields`....; > > ; > > ; > > Right, we do not support that right now. I think there are some niche uses but, for the most part, when we go hydrostatic we are often doing large scale and a bit more complicated modeling with parameterizations, etc, where getting background fields right would be more of a pain than with NonhydrostaticModel (which still does not work properly with nonlinear subgrid-scale turbulence closures).; > > I think its better to go more mainstream for this example. I think the use cases that this example serves as a starting point for are probably not going to use background fields, typically.; > ; > True true.; > ; > Any idea how to deal with the dz(b) that vanishes at the top? Or should we live with it?. Because of the no-flux boundary condition? I think that's correct, ok to have. You could have a mixed layer at the top too!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986931063:390,parameteriz,parameterizations,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986931063,1,['parameteriz'],['parameterizations']
Modifiability,"> > > I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier.; > > ; > > ; > > Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression.; > ; > I am puzzled by your statement here. A discrete, i.e. numerical calculation, is more exact than the analytical (so called exact) expression?; > ; > I guess it's more appropriate for the discretization that we are using, which is probably the point you are making. Okay, I see that and agree it's probably the better way to go. Correct. There's a ""discrete vorticity"". The analytically calculated vorticity is close to the discrete vorticity, but not exactly equal to it. For example, the perturbation vorticity in the current definition may not be initially zero, even if there were no noise. If the ""mean vorticity"" were calculated discretely, then the perturbation vorticity would be identically zero initially. A similar concept holds for geostrophic balance. There is a discrete geostrophic balance condition contains in a model that's stratified and rotating. This discrete condition is close to, but not exactly identical to the continuous geostrophic balance condition. This point has to do with approximation / discretization in general, through for some discretization (eg spectral decompositions), discrete representations may be closer to continuous analytical representations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882757399:397,flexible,flexible,397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882757399,1,['flexible'],['flexible']
Modifiability,"> > > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > > ; > > ; > > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`.; > ; > I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time t before it is being advected to time t+Δt. But in that case, when a time-step is complete, the radius has been computed at time `t` but the particle position is updated to time `t + Δt`. This means that if the user asks for output, the two are inconsistent with one another.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874440919:45,evolve,evolve,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874440919,1,['evolve'],['evolve']
Modifiability,"> > > Ok I fixed that. Probably we should use a Field rather than ones for the test and examples, because it automatically adapts to GPU, distributed, etc, so it's a bit better.; > > ; > > ; > > But I thought the whole idea is to be able to provide an `Array` for forcing.; > . `Field` is an abstract array. You should think of `Field` as a kind of `Array`. (We also want `CuArray` of course, and `SubArray`, `OffsetArray`, etc...). This code should work with anything for which `array[i, j, k]` is meaningful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1988819941:123,adapt,adapts,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1988819941,1,['adapt'],['adapts']
Modifiability,"> > > Thanks for clarifying @glwagner .; > > > I guess I need to learn how this is done in the other models.; > > ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226:655,config,configuration,655,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226,1,['config'],['configuration']
Modifiability,"> > > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > > ; > > ; > > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.; > ; > Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?. Sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088747422:375,flexible,flexible,375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088747422,1,['flexible'],['flexible']
Modifiability,"> > > in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit.; > > > The other option to not use MPI variables is to hardcode the number of processors; > > ; > > This advice seems to contradict the goal of having scripts that can be changed from non-distributed to distributed with a single line.; > > ; > > I don't think user scripts should have to write `using MPI`. The API should have all the features necessary to support ""one-click"" distributed simulations. When we see `using MPI`, it measn that the API is incomplete and we have work to do.; > ; > Just to clarify, this is already possible, just by doing; > ```julia; > arch = Distributed(); > rank = arch.local_rank; > ```; > The script, on the other hand, explicitly uses the MPI module before constructing the architecture, for which it makes sense to have `using MPI; MPI.Init()`.; > . @iuryt this works already if you don't want to hardcore/import the MPI module. I would leave the validation case like this though",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895862613:90,variab,variables,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895862613,2,['variab'],['variables']
Modifiability,"> > @matinraayai I made a bunch of suggestions!; > > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > > ```julia; > > using Oceananigans; > > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > > model = NonhydrostaticModel(; grid, advection=WENO5()); > > ϵ(x, y, z) = 2rand() - 1; > > set!(model, u=ϵ, v=ϵ); > > simulation = Simulation(model; Δt=0.01, stop_time=4); > > run!(simulation); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > should be enough?; > ; > @glwagner I'm okay with that. I can take a look at this once this PR is accepted to `amdgpu`. @glwagner and @matinraayai focusing on `validation/` , `rectilinear`, `non hydrostatic` would work. ; I can set up some CI against the cluster machines we have. I am not sure if we would want it to run for all PRs yet, so I could try https://stackoverflow.com/questions/62325286/run-github-actions-when-pull-requests-have-a-specific-label",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787:139,refactor,refactor,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787,1,['refactor'],['refactor']
Modifiability,"> > @siddharthabishnu, how do we know that now the metrics are filled correctly? you were comparing with a grid from MITgcm?; > ; > Yes. Consider the following sources for the grid metrics:; > ; > 1. the `cs32` grid with one halo layer, used by:; > ; > * Ali for the Rossby-Haurwitz test case in Oceananigans v0.82.0; and; > * yourself to check the interior coordinates and grid metrics of the Oceananigans `cc32` grid;; > 2. the `cs32` grid with 4 halo layers created by @jm-c using MITgcm;; > 3. the `cc32` grid created by Oceananigans.; > ; > In the validation scripts for solid body rotation and the Rossby-Haurwitz wave within the `ncc-glw/cubed-sphere-dynamics` branch associated with PR #3306, I compared the metrics of grid (3) against both (1) and (2), and plotted their absolute and relative differences. With the latest modifications, these differences have been minimized though not entirely eliminated. OK, so the benchmark is the `cs32` grid by MITgcm. Can we do the comparison in this PR? I'd like to see a test ideally because otherwise how do we assess that the changes we are suggesting here are correct. I can also do that, just give me a code snippet that loads the two grids?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1978039025:454,layers,layers,454,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1978039025,1,['layers'],['layers']
Modifiability,"> > AUUUGHHH that was hard but finally found the source of the type instability:; > ; > which type instability; is this related to discussion in #3750?. Yes. That issue documents slow reductions for windowed fields on immersed boundary grids. I hypothesized that it was due to a failure of type inference. Looking into it further I see that `axes(op::AbstractOperation)` cannot be type inferred when indices is not `(:, :, :)` because of the tuple generator. We found the same problem with `axes` for `Field` and fixed it but didn't fix it for AbstractOperations. Reducing windowed fields on immersed boundary grids requires this because they are wrapped in `ConditionalOperation` in order to mask the immersed regions during the reduction. This PR extends the fix we implemented for `Field` to also encompass `AbstractOperation`. It also cleans up conditional operations quite a bit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2380361438:749,extend,extends,749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2380361438,1,['extend'],['extends']
Modifiability,"> > Also I am not sure about renaming to `buffer`. What is called `buffer` here is not really a buffer but a `halo-dependent` region of the active domain. What about calling it `compute_halo_dependent_tendencies!`?; > ; > This PR _defines_ the ""buffer"" as the halo dependent region of the domain.; > ; > Before this PR there was no definition of this region at all, so this PR simply introduces one possible name. I am ok with a different name, but I think we should do it in another PR. Ok, can we leave the refactoring to another PR than to clean up this one?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2398015122:509,refactor,refactoring,509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2398015122,1,['refactor'],['refactoring']
Modifiability,"> > Also, I can run it with Nz = 4, since this example is from the MITgcm, and that case has four leves.; > ; > In my reading of the docs I see `Nz = 15`:; > ; > > As in tutorial [Barotropic Ocean Gyre](https://mitgcm.readthedocs.io/en/latest/examples/barotropic_gyre/barotropic_gyre.html#sec-eg-baro), a border row of land cells surrounds the ocean domain, so the full numerical grid size is 62 × 62 in the horizontal. The domain has 15 levels in the vertical, varying from Δz = 50 m deep in the surface layer to 190 m deep in the bottom layer, as shown by the faint red lines in [Figure 4.5](https://mitgcm.readthedocs.io/en/latest/examples/baroclinic_gyre/baroclinic_gyre.html#baroclinic-gyre-config).; > ; > From the first paragraph here: https://mitgcm.readthedocs.io/en/latest/examples/baroclinic_gyre/baroclinic_gyre.html. Is there another reference?. My mistake. Yes, 15 points in the vertical. I will work on reproducing some of their diagnostics and confirm things compare.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1085#issuecomment-1152921631:696,config,config,696,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1085#issuecomment-1152921631,1,['config'],['config']
Modifiability,"> > As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models).; > ; > I agree, but this patch-up will not work for immersed boundaries anyway. What do you mean? What patch-up?. > I still advocate for (maybe not now but later down the line) a general line of thought that ensures consistency between immersed boundaries and ""regular"" boundaries (a la MITgcm) treating them always the same way. I agree I think that would be nice. It means that operators need to know about boundary conditions though, which is a major refactor... > As an example, this issue could have been brought up for immersed boundaries, which would have required a (definitely more lengthy) rework of boundaries in abstract operations but would have solved the issue in both boundaries and immersed boundaries. We support values and gradients on non-immersed boundaries, but we do _not_ support evaluating them across immersed boundaries. We have to support what we claim / say that we support, that is the only issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786:935,refactor,refactor,935,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786,1,['refactor'],['refactor']
Modifiability,"> > But the text, the way is written at least, is generic, was not referring to **this** particular problem. :; > ; > well all problems in Oceananigans are nonlinear; and our abstractions are not flexible enough to do the linear instability without nonlinear terms :-/; > ; > But more generally I think fluids are nonlinear --- linearization is just an idealization? I think the approx helps clarify that this is a reduction of full Navier-Stokes. But agree it could limit the scope of the discussion to fluids (which might be ok?). N-S are nonlinear. When you linearize about some solution you do some approximation, indeed. But in the end you get an exact equation with an `=` for the approximate linear dynamics about that solution. Nobody writes the linear dynamics with `\approx` to denote that there was a linearization somewhere along the road... . I see your point _but_ I don't think an example in a GitHub repo is the place to introduce notation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720084987:196,flexible,flexible,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720084987,1,['flexible'],['flexible']
Modifiability,"> > Doesn't that already exist?; > > We just have to adapt the test; > ; > Yes, the test I think only tests the `NetCDFOutputWriter`. There is already a test for the `JLD2OutputWriter`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2001918160:53,adapt,adapt,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2001918160,1,['adapt'],['adapt']
Modifiability,"> > Hm.... `HydrostaticFreeSurfaceModel` does not support `BackgroundFields`....; > ; > > Hm.... `HydrostaticFreeSurfaceModel` does not support `BackgroundFields`....; > ; > Right, we do not support that right now. I think there are some niche uses but, for the most part, when we go hydrostatic we are often doing large scale and a bit more complicated modeling with parameterizations, etc, where getting background fields right would be more of a pain than with NonhydrostaticModel (which still does not work properly with nonlinear subgrid-scale turbulence closures).; > ; > I think its better to go more mainstream for this example. I think the use cases that this example serves as a starting point for are probably not going to use background fields, typically. True true. Any idea how to deal with the dz(b) that vanishes at the top? Or should we live with it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986920817:368,parameteriz,parameterizations,368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986920817,1,['parameteriz'],['parameterizations']
Modifiability,"> > Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions.; > ; > I think so. Let's definitely try!; > ; > Is it useful to have a general `Drag` boundary condition in general (in addition to `Periodic`, etc.), that would be used not only for immersed boundaries, but also for actual boundaries?. We have `FluxBoundaryCondition` already which is the same. The difference in terms of user input is that an immersed boundary condition _function_ has to be called with three indices `i, j, k` rather than two like all the other boundary conditions. I don't think we need any new types in the source code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050162738:21,adapt,adapt,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050162738,1,['adapt'],['adapt']
Modifiability,"> > I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier.; > ; > Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression. I am puzzled by your statement here. A discrete, i.e. numerical calculation, is more exact than the analytical (so called exact) expression? . I guess it's more appropriate for the discretization that we are using, which is probably the point you are making. Okay, I see that and agree it's probably the better way to go.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882755027:385,flexible,flexible,385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882755027,1,['flexible'],['flexible']
Modifiability,"> > I can't run the MPI. I need to be directed to some instructions to setup my MPI. @simone-silvestri pointed at the [MPI docs](https://juliaparallel.org/MPI.jl/stable/configuration/#Configuration). Do I need MPIPreferences? I don't know... @glwagner did you have to use that? If not, why must I... we are using the same machine...; > ; > What is your setup? Is your MPI executable path exported in the bash? Do you have a `Localpreferences.toml` file generated from MPIPreferences? Another way to use MPI.jl is through the [mpiexecjl](https://github.com/JuliaParallel/MPI.jl/blob/master/bin/mpiexecjl) command. I typically just use the mpirun executable, but this other approach might help. ```bash; $ which mpiexec; /opt/homebrew/bin/mpiexec; ```. I don't have a `LocalPreferences.toml`, I never did anything with MPIPreferences. Do I need to? I just did what the tutorial was suggesting and that wasn't part of the instructions -- that's why I didn't do anything.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2282898128:169,config,configuration,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2282898128,2,"['Config', 'config']","['Configuration', 'configuration']"
Modifiability,"> > I don't really get why returning 0 is useful though. You say ""for writing general code from the user perspective"" but I don't quite understand that.; > ; > What I mean is that it's makes it easier for a user to write something like:; > ; > ```julia; > u_sgs_flux(model) = - viscosity(model.closure, model.diffusivity_fields) * ∂z(model.velocities.u); > ```; > ; > and have it (correctly) return 0 when `closure=nothing`.; > ; > I've been writing utilities of this kind for the past couple of months for a project which has simulations both without and without closure, and I've been using if-else statements to deal with that. It's not the worst thing, but having these extra two lines in Oceananigans would help me (and possibly other users) have cleaner code in these instances.; > ; > Although admittedly I don't expect a big chunk of users to need that. The main reasons for me to propose this is that the behavior of `viscosity()` and `diffusivity()` will now be more consistent (i.e. they would work for all (?) closures we have so far), and it's only a simple two-line addition. In the future instead of using an if-statement, you can extend `viscosity` and `diffusivity` in your own code (temporarily, until a PR like this one is merged)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2951#issuecomment-1454777192:1146,extend,extend,1146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2951#issuecomment-1454777192,1,['extend'],['extend']
Modifiability,> > I have created a new validation script called `shallow_jet_topography.jl` that evolves the barotropically unstable jet (like in the shallow water example) but now over a shelflike topography. It can be found in `valiation/shallow_water`.; > ; > I don't see it; did you push?. Sorry! I have added it now. https://github.com/CliMA/Oceananigans.jl/blob/fp-ss/shallow-water-version2/validation/shallow_water_model/shallow_water_jet_topography.jl. One of my mitakes is that I didn't define the bathymetry. I need to figure out how to do that. Thanks for the very helpful feedback!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975142954:83,evolve,evolves,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975142954,1,['evolve'],['evolves']
Modifiability,"> > I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?; > ; > @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on.; > ; > I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation. Thanks @christophernhill for all this information. This will be most helpful. Unfortunately, tomorrow I am busy from 9am to 5pm so I don't think I can zoom, but maybe on Monday? I'll try and look into these resources before hand.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360570:415,config,configured,415,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360570,1,['config'],['configured']
Modifiability,"> > I made one extra change which is that I don't call `N^2 / S^2` a Richardson number anymore. Since the denominator is a strain rate, not the _vertical_ shear, I think it's odd to call it `Ri`. Also that variable (whatever you call it) only appears 3 times briefly so there's no need to give it a name.; > > It appears that our buoyancy modification doesn't really match Pressel's or Lilly's since we use an arbitrary `C_b` while they proposed to use `1/Pr_t`. @glwagner Is there any reference for that?; > ; > I don't quite understand the question --- what would you like a reference for?; > ; > It looks like for `Cb=0`, the reference is the original Smagorinsky paper, whereas for `Cb=1/Pr` one uses the model proposed by Lilly (1962). A number in between represents something different from either --- are you wondering if there are papers out there that have used `Cb` other than 0 or `1/Pr`? As to that I don't know.; > ; > We could change the default from `Cb=1` to `Cb=1/Pr` or `Cb=0`... ? The default `Pr` is `Pr=1` but I suppose one might inadvertently change `Pr` but leave `Cb=1` which would lead to a different LES model than proposed by Lilly (1962). Apparently my explanation wasn't needed! Yes, that's what I mean. I propose we either get rid of `C_b` and just use `1/Pr_t` or make it clear in the docs and docstring that we offer an extra degree of freedom, but that the model as proposed has `C_b=1/Pr_t`. I'm not sure which one is best since I do like the idea of Oceananigans allowing for easy (customization), but also that favors mistakes by un-attentive users (such as myself haha).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889307399:206,variab,variable,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889307399,1,['variab'],['variable']
Modifiability,"> > I now recall the reason for the discrepancy. It was due to an index shift, which made filling the extra layer of halos quite straightforward, so I proceeded with it. For example, field_1[2:Nc+1, Nc+1:Nc+Hc] from an odd panel corresponds to field_2[1:Hc, 1:Nc] from the panel to the north. I can modify this expression to field_1[2:Nc, Nc+1:Nc+Hc] aligning with field_2[1:Hc, 2:Nc] and make similar adjustments for other halo fillings to minimize confusion. Please let me know your thoughts.; > ; > My thoughts are two:; > ; > * how will we know that while doing that change you won't break anything since there is no test for any of these things; > * I understand that you are telling me is merely an indexing reordering, that is instead of doing; > ```julia; > for j in 1:10; a[j] = 10; > ```; > ; > ; > ; > ; > ; > ; > ; > ; > ; > ; > ; > you do; > ```julia; > for j in 2:11; a[j-1] = j-1; > ```; > ; > ; > ; > ; > ; > ; > ; > ; > ; > ; > ; > right? But these two will result to the same array. So I'm confused. I understand that there is no test for these things, but the chances of breaking the code is nil because the same logic applies to the remaining halo points. Regarding the index shifting, your example is not quite analogous to our case. Just consider my example above, where field_1[2:Nc+1, Nc+1:Nc+Hc] of panel 1 corresponds to field_2[1:Hc, 1:Nc] of panel 3. That is for sure, right? If, instead, I specified field_1[2:Nc, Nc+1:Nc+Hc] of panel 1 corresponds to field_2[1:Hc, 2:Nc] of panel 3, that would have removed the additional row/column of halo fills and made it look cleaner. I thought if the additional row/column were filled incorrectly, it would have been reflected in the remaining rows/columns as well, since the halos were filled in the same way. But, yes, I agree with your other comment that cleaning up the code would enhance its clarity and enable future recollection of our work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2025907530:1854,enhance,enhance,1854,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2025907530,1,['enhance'],['enhance']
Modifiability,"> > I see your point _but_ I don't think an example in a GitHub repo is the place to introduce notation.; > ; > I dispute that I'm introducing new notation! Both `=` and approx have unambiguous meaning. Let me elaborate on ""why approx"":; > ; > Oceananigans solves the full N-S with nonlinear terms. The script's power method algorithm will fail if the eigenmode to grow too much --- this is a real pitfall of the power method. The purpose of the approx symbol is to concisely illustrate why this can happen. This is crucial to explain for users who want to experiment with the script, change parameters, and adapt it for new problems.; > ; > We can explain this all in words, but I thought the approx is _visual_ which is helpful. Even just scanning the document you see, this equation involves an _approximation_. The approx is, in fact, a more precise and correct representation of the problem. We can in fact regard the power method algorithm as predicated on a hypothesis (not an exact theory), which we provide empirical evidence for. This is one of the advantages of the power method that uses the full original system, I think, over more brute force approaches that forcefully remove nonlinear terms.; > ; > It is possible to replace the approx with an `=` and also include all of the nonlinear terms what one would get from the manipulations that lead to the equation for `Phi`. This is precisely what you would do if you were interested in continuing the asymptotic expansion _that linearization implies_ to investigate things like saturation, etc. So there's also a neat pedagogical power in the approx symbol in that it provides a hint for further learning and exploration of the mathematics of the system. I agree with **all** of the above. However, you missed one of my points... my disagreement was mostly of the phrasing. You suggested writing:. > Linear instabilities such as the Kelvin-Helmholtz instability, are described by equations of the form ∂_t Φ + L Φ ≈ 0 ... This statement i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282:608,adapt,adapt,608,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282,1,['adapt'],['adapt']
Modifiability,"> > I suggest we remove the parameter for `gravitational_acceleration`.; > > @francispoulin any objection to that?; > ; > Please don't remove the parameter. It appears in the model equations and we need it to evolve the momentum equations. I only meant removing the explicit type declaration of the parameter. Sorry, should have been clearer. :); But we decided not to. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2955#issuecomment-1453564182:209,evolve,evolve,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2955#issuecomment-1453564182,1,['evolve'],['evolve']
Modifiability,"> > I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users.; > > I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful.; > ; > I wouldn't setting the `diffusive_cfl` is surprising. After all the diffusive cfl is as much of a necessary condition for convergence as the advective cfl, it just is a limiting-factor less often for oceanic simulations. But I'm okay with keeping the current behavior as well. I certainly don't disagree that it's convenient; the question is more whether the benefit justifies the cost. Users also want a code that's easy to maintain and extend because then they get more features! For constant diffusivities, the CFL constraint can be pre-calculated. For some common closures the calculation is simple, but this is not _generically_ the case for all turbulence closures. It's really only for variable diffusivities that we _need_ a feature for on-the-fly calculation. We could also use something like `diffusive_cfl=nothing` which completely avoids the calculation. Then we can justify supporting a diffusive CFL calculation for selected turbulence closures. That might be a good route (discussion for another issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247:717,extend,extend,717,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247,2,"['extend', 'variab']","['extend', 'variable']"
Modifiability,"> > I think it would be better to add an interface for precomputing the boundary conditions and then add a line to `update_state!` that does this. It's more explicit.; > ; > To do this wouldn't I need to make the boundary condition mutable and adapt it for GPU?. If the precomputation is storing values in an `Array` or `CuArray` (which is already mutable) then no. If you need to precompute a number for every boundary, then yes you need something mutable. But it looks like this would not involve the `BoundaryCondition` itself but rather a component of the boundary condition (eg the `condition` or the `classification`). None of this is hard though. I think we need to write down the use cases we want to support (explicitly, as detailed as possible), then we can design the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979244558:244,adapt,adapt,244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979244558,1,['adapt'],['adapt']
Modifiability,"> > I think something like you're proposing would have added to my confusion.; > ; > Isn't the confusion a problem with the output writers API? I think it sounds like a great idea to support `AbstractOperation` output. It's kind of logical. Doing this even allows us to do some clever stuff behind the scenes, like using one underlying array to store the results of multiple computations performed serial (thus saving memory). The confusion is that I wasn't aware that that a `Field` has `data`, and therefore takes up memory, which allows it to store values. While an `AbstractOperation` is just instructions on how to compute things. This extended to the output writers, but I wouldn't say output writers were the source of confusion. If we make it so that users don't have to know what a `Field` is and we can use abstract operations everywhere, then my comment is moot.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036795591:641,extend,extended,641,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036795591,1,['extend'],['extended']
Modifiability,"> > I think the majority of simulations do not use a Checkpointer so the warning would be irrelevant in most cases.; > ; > I don't get this. How are people not using a Checkpointer? Is no one else limited by HPC wall times or running long simulations? It seems like one of the most fundamental capabilities of any time-stepped numerical model.; > ; > But yes, this warning should only be issued if a Checkpointer is used (and maybe also when a simulation picks up from an existing Checkpoint). I think for sophisticated research Checkpointing is common, but for simpler classroom and LES applications the checkpointer is used less. After all, probably the most simulations are actually run in our examples on CI -- and there are no examples with a checkpointer! (It would be nice to change that). I can't speak for others, but for boundary layer parameterization work the LES typically run in less than 24 hours of wall time. We also only utilize very simple diagnostics, like the horizontally-averaged solution at the final time step. So in those rare cases that we need a checkpointer (I have used a handful of times) barebones checkpointing is sufficient. Of course we are currently working on building a OMIP simulation and that will require much longer runs, so we will definitely need more sophisticated checkpointing very soon. @simone-silvestri and @tomchor might have more to add. Or @sandreza, what do you use for the neverworld work?. I'm not saying we don't want to develop this, I'm just providing some context about why this hasn't been resolved / developed yet. In an ideal world the simulations would run fast enough that we wouldn't need checkpointing, after all 😄",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305131230:846,parameteriz,parameterization,846,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305131230,1,['parameteriz'],['parameterization']
Modifiability,"> > I will add a docstring with some explanation, and replace some of the if-statements with multiple dispatch.; > ; > What will you dispatch on though? A docstring is for sure needed. Thanks!. I see your point. For dispatch, the argument types need to be different, which is not the case here. I used so many if statements to minimize the number of functions. I think I will just rewrite them in more readable way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1653960932:381,rewrite,rewrite,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1653960932,1,['rewrite'],['rewrite']
Modifiability,"> > I'm strongly opposed to having multiple small packages.; >; > Why is that, given the benefits?. Mainly I think we can get all the same benefits by maintaining a single unified and tidy repository with sub-modules. I don't see Oceananigans as a complex project yet, we're barely at 2,500 lines of code (minus turbulence closure operators which aren't integrated yet). I can see reasons for having a separate repository for examples and tutorials if there are enough of them, but I don't see e.g. the output writers as being logically separate from the main code. As a stand alone package, OceananigansOutput.jl doesn't do anything useful. Something like TurbulenceClosures.jl could though. Keeping things in tidy submodules within a single repository increases code visibility, which I think is important. When I see a package or framework spread across multiply small packages I find it hard to get an idea about what it can do. Another nice thing is we currently have ""unified versioning"" so when releases occur we know everything works together. We don't have to worry about running with Oceananigans v0.x with OceananigansPlotting v0.y and OceananigansOutput#master to fix some issue. From a development perspective, issues and pull requests are now spread across multiple repositories and we can end up with pull requests that depend on other pull requests in other repositories, e.g. when adding in halo regions the main code got refactored but so did the output writers and plotting code would change as well. We can also end up with multiple test suites that need to pass, plus possibly multiple CI pipelines to manage. So right now it's easy to make atomic changes that touch upon multiple pieces of code (and we'll probably be in this stage where we need to refactor frequently for a while). I also don't have to git clone a bunch of repositories just to work on a simple example. But this is getting off-topic.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502137749:1439,refactor,refactored,1439,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502137749,2,['refactor'],"['refactor', 'refactored']"
Modifiability,"> > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > ; > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`. I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time $t$ before it is being advected to time $t + \Delta t$.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873881652:43,evolve,evolve,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873881652,1,['evolve'],['evolve']
Modifiability,"> > It's something to do with GPU, maybe GPU reductions?; > > ```; > > [2023/05/24 21:41:15.102] INFO Testing grid utils on variably spaced grid....; > > --; > >   | Grid initialization: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_grids.jl:199; > >   | Expression: minimum_xspacing(grid) ≈ FT(π / 3); > >   | Evaluated: 0.0 ≈ 1.0471975511965976; > > ```; > ; > I see this error. But I can't reproduce it. On tartarus it's not happening and I don't have access to Svedrup. So I don't know what to do... :(. I guess its a CUDA version issue or something",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1567729329:124,variab,variably,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1567729329,1,['variab'],['variably']
Modifiability,> > Likely this function is the problem:; > > https://github.com/CliMA/Oceananigans.jl/blob/775d1544610d5af6f602254ec5dff3dec7f18480/src/BoundaryConditions/update_boundary_conditions.jl#L15-L16; > ; > Yeah I saw that this was where some of the errors were coming from but I don't really understand what is going on with Enzyme that this causes problems?. It could be that this function is recursive coupled with the fact that `boundary_conditions` is not type-inferrable. So we may want to rewrite both of those functions. Luckily typically the changes we make to improve type inferrence (making it easier for the compiler to understand) also make it easier for humans to understand. As a starting point I don't think we can use the `Tuple` generator...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263694349:490,rewrite,rewrite,490,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263694349,1,['rewrite'],['rewrite']
Modifiability,"> > Most of the changes are separating the bgc transitions from the rest of the tendencies which isn't that hard but is just quite a lot of lines.; > ; > Can you elaborate for the benefit of future generations?. For sure, the problems were:. - to split the bgc tendencies from the rest I needed a way to turn them off in the normal tendency computation, I did this by passing a keyword all the way through to `biogeochemical_transitions` - when I did it this way the intention was to touch as little of the existing code as possible, but it might not be the cleanest/most maintainable; - I then needed to be able to compute the bgc tendencies only so I added a function to the bgc file to launch a kernel that just computes `biogeochemical_transitions`; - Then I made the new time stepper which is just a container for two different timesteppers called `physics` and `biogeochemistry` (which are normal timesteppers so each have a set of tendencies etc.); - this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at `timestepper.G` / `$G^-$`, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned `timestepper.physics.G` etc.; - Then I had to add `time_step_biogeochemistry!` functions which do the same as `time_step!` but only comput the bgc tendencies. So to summarise: 1) separating the bgc tendency calculations from the rest, 2) make somewhere for the bgc tendencies to live and return the physics tendencies when expected, 3) step the bgc on its own",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455392735:572,maintainab,maintainable,572,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455392735,1,['maintainab'],['maintainable']
Modifiability,"> > Ok I fixed that. Probably we should use a Field rather than ones for the test and examples, because it automatically adapts to GPU, distributed, etc, so it's a bit better.; > ; > But I thought the whole idea is to be able to provide an `Array` for forcing. `Field` is an abstract array. You should think of `Field` as a kind of `Array`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1988818257:121,adapt,adapts,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1988818257,1,['adapt'],['adapts']
Modifiability,"> > Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`.; > > The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization.; > ; > We need to be able to compute the vorticity in those points as well as those points are involved in the ζk^×u term. So I think the dynamics test is blowing up because of that, but I'm not 100% sure. But I think the problem here is just that the kernel launched by `compute!` does not extend to all the points where zeta is defined. On the other hand, when zeta is used during time-stepping, we compute it for the u- and v- tendency kernels. In those kernels, all relevant grid points are touched.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759751128:528,extend,extend,528,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759751128,1,['extend'],['extend']
Modifiability,"> > The more the merrier! Contributors are generally welcome on our end too. Links @christophernhill in his comment were broken. So just in case:; > > ; > > * [JOSS issue (accepted)](https://github.com/openjournals/joss-reviews/issues/4207), [paper (proofs)](https://github.com/openjournals/joss-papers/blob/joss.04207/joss.04207/10.21105.joss.04207.pdf); > > * [Github repo (JuliaOcean)](https://github.com/JuliaOcean/PlanktonIndividuals.jl); > > ; > > _PlanktonIndividuals.jl: A GPU supported individual-based phytoplankton life cycle model_; > ; > @gaelforget it looks like you might have some Oceananigans examples which is super cool!! Can you point to them for us? Have you considered expanding to ""online"" capabilities? What are the pros and cons of that?. The two models we currently have some support for (offline) are `MITgcm` and `oceananigans.jl`. . I have examples for both models in <https://gaelforget.github.io/ClimateModels.jl/dev/examples/> which you can run the JuliaClimate sandbox <https://juliaclimate.github.io/Notebooks/> and generate the kind of model output that `PlanktonIndividuals.jl` or `IndividualDisplacement.jl` can then ingest as input for offline computation. The `PlanktonIndividuals.jl` documentation has corresponding examples on the ecology + bgc side. An online mode with models like `MITgcm` and `oceananigans.jl` would be useful in my view, in the case of both `PlanktonIndividuals.jl` or `IndividualDisplacement.jl`. With this being said, I tend to most like the idea of small'ish modeling components developed outside of monolitic modeling efforts that emphasize code re-usability and integration with multiple models. . For completeness, here is the reference to the JOSS paper on [IndividualDisplacement.jl](https://joss.theoj.org/papers/10.21105/joss.02813) -- https://joss.theoj.org/papers/10.21105/joss.02813.pdf -- and the [GitHub repo](https://github.com/JuliaClimate/IndividualDisplacements.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509:994,sandbox,sandbox,994,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509,1,['sandbox'],['sandbox']
Modifiability,"> > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > ; > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`. Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088696540:363,flexible,flexible,363,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088696540,1,['flexible'],['flexible']
Modifiability,"> > This warning means that you didn't configure MPI correctly to work with julia. There is some documentation on how to do it [here](https://juliaparallel.org/MPI.jl/stable/configuration/). We should add a link in the docs to this webpage; > ; > So I went to that doc pages but I wasn't sure -- do I need to install MPIPreferences? There is no other way? We should definitely add a link to that docs page then. No the best thing to do is to call `mpiexecjl`, which is installed when you install `MPI.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2278730680:39,config,configure,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2278730680,2,['config'],"['configuration', 'configure']"
Modifiability,"> > We should also add a test similar to the one that was added in #3512.; > ; > Doesn't that already exist?; > ; > We just have to adapt the test. Yes, the test I think only tests the `NetCDFOutputWriter`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2001910688:132,adapt,adapt,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2001910688,1,['adapt'],['adapt']
Modifiability,"> > Were you suggesting to combine these in a single `k`-long tuple, e.g.,; > > ```julia; > > gravitational_acceleration .* (1, (ρ[k] - ρ[k-1]) / ρ[k-1], (ρ[k-1] - ρ[k-2]) / ρ[k-2], ..., (ρ[2] - ρ[1]) / ρ[1] ); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which will become a number for single layers?; > ; > Yes, that's exactly what I was suggesting, since gravitational_acceleration could be understood as the value of g that each layer feels, so not sure why we need different parameters for both. Ok! This type field will be pf different type for single and multilayer models then.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1472887372:328,layers,layers,328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1472887372,1,['layers'],['layers']
Modifiability,"> > What's the error with `TimeInterval`?; > ; > I think the issue was the interval being stored as a Float64, but I'm not sure why that would ever endup in a kernel. (copy-pasting from #2618). One possibility is that there is a type promotion occurring within `align_time_step`:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L24-L33. and. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L133-L134. This would cause widespread issues in switching to single precision, so @simone-silvestri may want to take note. The quick fix is to convert after calculating the aligned time-step:. ```julia; Δt = aligned_time_step(sim, sim.Δt); Δt = convert(eltype(sim.model), Δt); ```. I think we need a more defined interface for this in the long run though. We really need both `eltype` (the floating point type used by state variables, grid metrics, etc) and a `timetype` (the type of `model.clock.time`). . (Also I'm not sure `eltype(model)` is defined yet, but it should be...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734542698:940,variab,variables,940,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734542698,1,['variab'],['variables']
Modifiability,"> > Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?; > ; > I was planning was to implement the tridiagonal solve similarly to what we do for single GPU as such:; > ; > ```julia; > transpose_z_to_y!(storage) # copy data from storage.zfield to storage.yfield; > solver.plan.forward.y!(parent(storage.yfield), buffer.y) ; > transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; > solver.plan.forward.x!(parent(storage.xfield), buffer.x); > transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; > transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; > ; > # Perform the implicit vertical solve here on storage.zfield...; > ; > transpose_z_to_y!(storage); > solver.plan.backward.y!(parent(storage.yfield), buffer.y); > transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; > solver.plan.backward.y!(parent(storage.xfield), buffer.x); > transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; > transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; > ```; > ; > This is not super great because it requires eight transposes, but I think it's the same thing that was happening in #2538. Can you just say, you are planning to implement the algorithm in #2538? The way you describe it, I can't figure out if you are coming up with something new or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197393925:233,adapt,adapted,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197393925,1,['adapt'],['adapted']
Modifiability,"> > but I guess you are telling me that it defaults to the position of the first variable?; > ; > Correct.; > ; > > Actually, I needed to use model.solution.uh instead of uh and it seems to be working better (but I'm not done). Does that make sense or am I missing something; > ; > My apologies for being unclear! I would write; > ; > ```julia; > uh, vh, h = model.solution; > u = ComputedField(uh / h); > ```. Great to know, thanks!. Actually, the fact that I have uh, vh and h already defined causes some problems. Rather than introducing more variables I will probably just use the long name. I will try and not forget this in the future though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760282723:81,variab,variable,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760282723,2,['variab'],"['variable', 'variables']"
Modifiability,"> > in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit.; > > The other option to not use MPI variables is to hardcode the number of processors; > ; > This advice seems to contradict the goal of having scripts that can be changed from non-distributed to distributed with a single line.; > ; > I don't think user scripts should have to write `using MPI`. The API should have all the features necessary to support ""one-click"" distributed simulations. When we see `using MPI`, it measn that the API is incomplete and we have work to do. Just to clarify, this is already possible, just by doing; ```julia; arch = Distributed(); rank = arch.local_rank; ```; The script, on the other hand, explicitly uses the MPI module before constructing the architecture, for which it makes sense to have `using MPI; MPI.Init()`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894742065:88,variab,variables,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894742065,2,['variab'],['variables']
Modifiability,"> > potentially with a default value of overwrite_existing = false.; > ; > Do you run with `overwrite_existing=false`? (Outside the context of restoring from a checkpoint.). I agree, that is not a common use case scenario. I have only used `overwrite_existing=false` without a checkpoint for short tests within the same Julia instance to extend the model output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391892045:338,extend,extend,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391892045,1,['extend'],['extend']
Modifiability,"> > the time integral when we use variable time stepping that is a feature we use quite often; > ; > What do you mean by this?. Actually, I should probably say that I use the wizard quite often to change the time step. In my opinion, AB2 is a good compromise between accuracy, stability, and performance. RK3 is better only when you can achieve a CFL 3 times larger. We should fix the variable AB2 time stepper or discourage the use of frequent updates of the time step when using AB2. The first option is probably better in my opinion. I ll look into fixing AB2 and what it entails",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313376167:34,variab,variable,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313376167,2,['variab'],['variable']
Modifiability,"> @Mikejmnez , could you maybe say a bit more of what you are hoping to do? If you initialize your flow to have a constant shear, for example, then there is a velocity associated with that shear and it will evolve because of the momentum equations.; > ; > If you wanted a simple toy problem, we might be able to do something with `ShallowWaterModel`. It might be simple enough for your purposes, depending on what you wanted to learn, but that would be orthogonal to this issue. @francispoulin I am interested deriving/testing closures in the 2D Adv-Diff equation in the (general) case of periodic shear flows. A constant shear flow won't do it. More like a velocity field that can be decomposed into a shear flow u(y) (e.g. a cosine in y or sum of cosines) plus a cellular flow (square waves). I am still a newbie over here, so I am open to trying different models.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768512388:207,evolve,evolve,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768512388,1,['evolve'],['evolve']
Modifiability,"> @ali-ramadhan would it be good to send messages to everyone who has a fork maybe and maybe keep an issue open, so people who have cloned can see?. That's a good idea, I think the only other person who had an issue was @arcavaliere who had an open PR at the time, but otherwise we could tag all the forkers. > Of course it would also be good not to rewrite the history - that pretty much breaks how git works. In theory reviewing PRs should catch this?. Agreed. Yeah it took us a while to find the leak in #509 (JLD2 file wasn't added by us but by examples generating files when built) and the damage was contained to the `gh-pages` branch but the reason it affected the `master` branch was that I also deleted an old regression test file. Now that we're more aware of this issue I think we can stop it from happening again.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/598#issuecomment-577237824:350,rewrite,rewrite,350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/598#issuecomment-577237824,1,['rewrite'],['rewrite']
Modifiability,"> @glwagner ,; > ; > So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:; > ; > ```julia; > lamb = 1 # decay scale for slip velocity in meters; > @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); > sinking = SlipVelocity(WENO5(), w=w); > ```; > ; > The way the code is, does it accept functions for velocity inputs? Is that something I could do to help you?. You can do this a few ways:. ```julia; # Vertical velocity function; const lamb = # something; const H = # something; @inline w_func(x, y, z) = tanh(max(-z / lamb, 0.0)) * tanh(max((z + H) / lamb, 0.0)). # Field (allocates memory and precalculates w_func); w = ZFaceField(grid); set!(w, w_func); sinking = AdvectiveForcing(w = w). # Function field (avoids allocating memory but calls `w_func` every iteration); w = FunctionField{Center, Center, Face}(w_func, grid); sinking = AdvectiveForcing(w = w); ```. We could also add the feature to `AdvectiveForcing` that, if an input is a function, we assume it's a function of `x, y, z, t` and deal with it appropriately (by wrapping in a `FunctionField` and adding reference to the model `clock`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436:126,adapt,adapted,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436,1,['adapt'],['adapted']
Modifiability,"> @glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future).; > ; > 1. Rigid lid (solve for the surface pressure); > 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping); > ; > Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. I would vote for implementing a rigid lid / vertically-`Flat` mode for the hydrostatic model instead, in order to keep the shallow water model as simple as possible (generalizing to multiple layers as an alternative direction would be nice I think). Have you benchmarked this? It is true that vertically `Flat` avoids a few vertical operations in the vertical advection term but since the kernel sizes are the same I'd be surprised if the performance differences are huge in terms of cost per time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736:694,layers,layers,694,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736,1,['layers'],['layers']
Modifiability,"> @glwagner and @simone-silvestri; > ; > Continuing the discussion. [#2788 (reply in thread)](https://github.com/CliMA/Oceananigans.jl/discussions/2788#discussioncomment-8101280); > ; > It looks like MPI needs to be initialized before accessing its communication variables.; > ; > Thus, despite calling `Distributed` initializes MPI, we need to access `Nranks = MPI.Comm_size(comm)` before to define `Partition`.; > ; > https://github.com/CliMA/Oceananigans.jl/blob/294602781e7a678ef3a662e1a31d2145d10d0800/validation/distributed_simulations/distributed_nonhydrostatic_turbulence.jl#L20-L22; > ; > Should we initialize MPI when importing DistributedComputations?. Either 1) explicitly invoke `MPI.Init()` or 2) move those lines to after the grid constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894650511:263,variab,variables,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894650511,1,['variab'],['variables']
Modifiability,> @jagoosw I believe that `adapt` is missing its first argument. Note the PRs were merged without tests passing... that's why we have this issue. Sorry! I hadn't realised they could be merged without the tests passing so when I saw the PR approved just hit merge. Sorry for all the problems!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868338988:27,adapt,adapt,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868338988,1,['adapt'],['adapt']
Modifiability,"> @matinraayai I made a bunch of suggestions!; > ; > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > ; > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > ; > ```julia; > using Oceananigans; > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > model = NonhydrostaticModel(; grid, advection=WENO5()); > ϵ(x, y, z) = 2rand() - 1; > set!(model, u=ϵ, v=ϵ); > simulation = Simulation(model; Δt=0.01, stop_time=4); > run!(simulation); > ```; > ; > should be enough?. @glwagner I'm okay with that. I can take a look at this once this PR is accepted to ```amdgpu```.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702:139,refactor,refactor,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702,1,['refactor'],['refactor']
Modifiability,"> @matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. For the moment those two elements are part of this PR.; > ; > This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft, the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult. Nice, thanks for that explanation. Why are we following 2decomp? PencilArrays has some benchmarking that shows it can compete with the fastest codes out there. I don't see anything similar for 2decomp, so I can't figure out what the motivation for following that strategy would be. I'm not sure if they are different, either. Something we do not previously support (but which is implemented in https://github.com/CliMA/Oceananigans.jl/pull/2538) was an algorithm that could support any topology with vertically-stretched grids. What is the relationship between this PR and https://github.com/CliMA/Oceananigans.jl/pull/2538, and does this PR support vertically stretched grids?. One of the main limitations of PencilArrays from our perspective is that it could not distribute an array along the first dimension. Since we almost always would like to use vertically stretched grids (and for various reasons, we may want to also compute the hydrostatic pressure with a vertical integral), ocean LES are typically distributed in x and y. Therefore, in order to support 2D domain decompositions, we were faced with somehow ch",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859:427,config,configuration,427,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859,1,['config'],['configuration']
Modifiability,"> @navidcy Hmmm, digging into Documenter.jl's Buildkite config it looks like push previews are only provided if the build belongs to a PR?; > ; > https://github.com/JuliaDocs/Documenter.jl/blob/4be8243d31a6ffdbc64d779e3f8c2fb7c61de075/src/deployconfig.jl#L719-L725; > ; > Maybe there was no push preview here since @tomchor pushed this branch at which Buildkite ran, before the PR existed, so Buildkite did not publish a preview. Maybe if a second commit was made on this PR, it would be detected by Buildkite as a PR and therefore a preview would be published?. Perhaps if we update Documenter.jl in the docs to the latest version we can alleviate that. At the moment DocumenterCitations v0.2.0 is precluding Documenter from v0.26 and later; see https://github.com/ali-ramadhan/DocumenterCitations.jl/pull/34#issuecomment-782308024.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782308873:56,config,config,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782308873,1,['config'],['config']
Modifiability,"> @siddharthabishnu, how do we know that now the metrics are filled correctly? you were comparing with a grid from MITgcm?. Yes. Consider the following sources for the grid metrics:. 1. the `cs32` grid with one halo layer, used by:; - Ali for the Rossby-Haurwitz test case in Oceananigans v0.82.0; and; - yourself to check the interior coordinates and grid metrics of the Oceananigans `cc32` grid;; 2. the `cs32` grid with 4 halo layers created by @jm-c using MITgcm;; 3. the `cc32` grid created by Oceananigans. In the validation scripts for solid body rotation and the Rossby-Haurwitz wave within the `ncc-glw/cubed-sphere-dynamics` branch associated with PR #3306, I compared the metrics of grid (3) against both (1) and (2), and plotted their absolute and relative differences. With the latest modifications, these differences have been minimized though not entirely eliminated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1977945018:430,layers,layers,430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1977945018,1,['layers'],['layers']
Modifiability,"> @siddharthabishnu, what capability does this PR add?. @glwagner, this PR uses the new halo-filling functions to update halos for prognostic variables and refines the vorticity computation function on the cubed sphere. Additional features introduced in this PR are detailed in the description.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3570#issuecomment-2087903213:142,variab,variables,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3570#issuecomment-2087903213,1,['variab'],['variables']
Modifiability,> @simone-silvestri this looks great. Have you thought about some sort of thickness weighting for vertical vorticity as a next step!! That could be a great step toward som flexible vertical coordinate options ( https://www.gfdl.noaa.gov/fv3/fv3-key-components/ ). @christophernhill don't we need to implement thickness weighting as part of a general overhaul to generic vertical coordinates? Or can we implement thickness weighting even in a fixed Z coordinate system?. @glwagner and @simone-silvestri I think you could explore thickness weighting in the non-linear shallow water. @francispoulin does that make sense? Might be a way to more quickly pilot some API and numerics aspects?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081924693:172,flexible,flexible,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081924693,1,['flexible'],['flexible']
Modifiability,> @tomchor Not sure if this is the issue but have you tried adapting `ScaleInvariantSmagorinsky` for the GPU?; > ; > Looks like `ScalarBiharmonicDiffusivity` needed it here:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl#L109-L113; > ; > Not sure why `update_frequency` is coming up as an `Integer` (which is an abstract supertype) instead of `Int` (which is a concrete type and an alias for `Int64`) but maybe adapting will fix this?. I tried that and got a different error. But now looking at `ScalarBiharmonicDiffusivity` I think I probably did something wrong. I'll try again soon!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2313450686:60,adapt,adapting,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2313450686,2,['adapt'],['adapting']
Modifiability,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:193,Adapt,Adapt,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212,3,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,"> @tomchor; > ; > In terms of ""smoothness indicators"" yes, not in terms of polynomial reconstruction. The WENO we had before is `WENO5()`. This will be formally wrong on a stretched grid because the reconstruction at the face is not done accounting for variable spacing.; > ; > `WENO5(grid = grid, stretched_smoothness=false) ` accounts for variable spacing in the reconstruction polynomial (i.e., the ![](https://render.githubusercontent.com/render/math?math=c_{rj}) coefficients are calculated based on grid spacing). This makes the scheme formally correct as, independently on how you weight the polynomials, the different stencils will have mathematically correct reconstructions at the face. This should _always_ be done in case of a stretched grid (and it does not decrease execution speed).; > ; > Now, the `stretched_smoothness=true` calculates the ![](https://render.githubusercontent.com/render/math?math=\beta_{r}) accounting for a stretched mesh. This means that the three reconstruction polynomials (![](https://render.githubusercontent.com/render/math?math=p_{0}, p_{1}, p_{2})) are weighted accounting for their actual smoothness and not a ""uniform smoothness"" that `WENO5(grid = grid, stretched_smoothness=false) ` calculates. In my tests this did not give a noticeable benefit in terms of accuracy (apparently ![](https://render.githubusercontent.com/render/math?math=\beta_{r}) for a stretched mesh are very similar to ![](https://render.githubusercontent.com/render/math?math=\beta_{r}) for a uniform mesh). In addition, it gives a non-negligible decrease in execution speed (especially on the GPU). For this reason, I think it is nice to have as an option, but to be used with parsimony :) and only when necessary. OK. This is great. Do you mind if I add something along those lines in a docstring somewhere? It's a pity to be left just in a comment in this PR, lost in the aether of closed PRs...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975853695:253,variab,variable,253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975853695,2,['variab'],['variable']
Modifiability,"> @vchuravy @maleadt Would it be possible to adapt a very simple `mutable struct` like `Clock{T}` to work in GPU kernels with Adapt.jl? It's never modified in a GPU kernel. Sure, you could e.g. have an adapt rule return a named tuple so that you can still do `.time` etc, as long as you don't have any signatures relying on `::Clock`. Getting mutables to work is much tougher, but not impossible either, especially if the object doesn't contain pointers (as Clock here).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/697#issuecomment-599136181:45,adapt,adapt,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/697#issuecomment-599136181,3,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,"> Actually I think you want `u` at the same location as `uh`, so you should write; > ; > ```julia; > u = ComputedField(uh / h); > ```. Agreed. What I did was `u = ComputedField( @at (Face,Cell,Cell) uh/h )` but I guess you are telling me that it defaults to the position of the first variable?. Actually, I needed to use `model.solution.uh` instead of `uh` and it seems to be working better (but I'm not done). Does that make sense or am I missing something?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760279876:284,variab,variable,284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760279876,1,['variab'],['variable']
Modifiability,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. That help was from Adapt 3.6.2, which is in the Oceananigans Manifest. I'll check v4 now. But I don't think it matters. The first argument `to` is necessary --- that indicates the device you are adapting to. There are two pieces of information required to adapt an object: the device we're adapting to, and the object being adapted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146:2,Adapt,Adapt,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146,7,"['Adapt', 'adapt']","['Adapt', 'adapt', 'adapted', 'adapting']"
Modifiability,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:2,Adapt,Adapt,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171,21,"['Adapt', 'adapt', 'extend']","['Adapt', 'adapt', 'adaptions', 'adaptor', 'adapts', 'extend']"
Modifiability,"> Additionally can you help me understand why you are using `GradientBoundaryCondition` at all? [- @glwagner]. Flux boundary conditions are both conceptually and practically easier to implement when the boundary fluxes are zero or constant. They can be trickier when they depend on interior flow variables. In our case, for example, the boundary condition on the perturbation variable $b'$ (the buoyancy tracer in Oceananigans) is that the *total* diffusive flux should vanish, which means the *perturbation* diffusive flux needs to be minus the *background* diffusive flux. . ![image](https://github.com/CliMA/Oceananigans.jl/assets/12971166/d5eae1d6-4aa8-438e-870b-0ff17352dcea). Imposing a flux boundary condition requires knowing the diffusivity $\kappa$ right at the boundary. It is obvious how to implement this if the diffusivity is a constant, because the background diffusive flux is also a known constant, but less obvious how to do it when using a subgrid turbulence closure that yields a diffusivity that varies in space and time. @tomchor pointed out to use that we can sidestep this complexity if we just divide both sides of the boundary condition by $\kappa$, because then the boundary condition simply becomes that the buoyancy gradient across the boundary should just be equal to minus the background buoyancy gradient—a known constant in our problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211446146:296,variab,variables,296,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211446146,2,['variab'],"['variable', 'variables']"
Modifiability,"> Agreed. It may not even be clear what a good solution is. Apparently DARWIN has a similar problem I think where many plankton species may be uptaking nutrients so the question of what to do when a nutrient are depleted is hard to solve, especially as having nutrients go below zero can be bad for the model. Even more than details associated with particular challenging ODEs is the more fundamental software challenge of designing a flexible and useful system for user-specification of ODEs (special fields defined on sets of particles, each associated with an independent ODE that is coupled to the model solution) to be solved on particle trajectories. If we were integrated with DifferentialEquations.jl, this might not be all that hard, however.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-548641256:435,flexible,flexible,435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-548641256,1,['flexible'],['flexible']
Modifiability,> Ah I think you added `sandbox/vertically_stretched_plankton.jl` back in when we meant to keep it nuked but we can worry about it after this PR is merged. I was also puzzled why that happened. I just pulled master and then `git merge master`...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783653083:24,sandbox,sandbox,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783653083,1,['sandbox'],['sandbox']
Modifiability,"> Ah sorry I really do think it would be confusing to users that one has to use HydrostaticSphericalCoriolis on grids that have spherical coordinate systems; and that the ""constant Coriolis"" type only applies to Cartesian coordinate systems :-( don't others agree?. I do agree it's a bit confusing, but IMO it's also obscure to name it `ConstantCartesianCoriolis`. As a user I'm thinking what's a cartesian Coriolis? And I definitely wouldn't make the leap in reasoning that `ConstantCartesianCoriolis` is meant to be used with _rectilinear grids_ (none of those two words appears in the name). Which is I suggested a few posts back to use the (very verbose) `ConstantRectlinearGridCoriolis` or something to that effect. > Sorry this is becoming laborious... if the name is changed to include Cartesian then we can merge this and discuss further in an issue. I'm okay with this. It seems like the background rotation implementation could use a big refactoring, which is kind of outside the scope of this PR anyway.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888380511:948,refactor,refactoring,948,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888380511,1,['refactor'],['refactoring']
Modifiability,"> Ah, I see...; > ; > ```; > @inline Γᶠᶠᶜ(i, j, k, grid, u, v) = δxᶠᵃᵃ(i, j, k, grid, Δy_qᶜᶠᶜ, v) - δyᵃᶠᵃ(i, j, k, grid, u, Δx_qᶠᶜᶜ, u); > ```; > ; > that can also work... maybe more robust since differences are already extended for `Flat` grids. I agree. So I pushed fd3a456.; Is there a test for that? Do we need to test that this expression is actually correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054872171:220,extend,extended,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054872171,1,['extend'],['extended']
Modifiability,"> Ah, the only issue is there will be conflicts with #1575. It shouldn't be hard to refactor these changes to work with the code on that PR though I don't think. @glwagner we can merge this in at some point. I didn't want to lose it meantime. Looks like #1575 needs other bits doing too, since #1522 did its stuff!!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1593#issuecomment-820454246:84,refactor,refactor,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1593#issuecomment-820454246,1,['refactor'],['refactor']
Modifiability,"> Also just to clarify, the problem is not `SeawaterBuoyancy` but rather any buoyancy model at all. When I tested with `BuoyancyTracer` the issue doesn't come up. I suppose you mean any buoyancy model that doesn't have buoyancy as an explicit prognostic variable right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3795#issuecomment-2377886697:254,variab,variable,254,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3795#issuecomment-2377886697,1,['variab'],['variable']
Modifiability,"> Also one thing that is important to get right in multi-layer shallow water models is layer-wise conservation of mass and other properties (see _e.g._, https://aronnax.readthedocs.io/en/latest/verification.html and http://www.nordet.net/beom.html).; > ; > > Topography that can interact more than one layer is complicated because then we need wetting and drying, but it won't need immersed boundaries. At least i don't think so. Wetting and drying usually requires a positive preserving advection scheme. We have first-order upwinding (which I don't think anyone has every used), that is positive preserving and could do this. But it's not a great scheme. A limiter would be better. There are a lot of methods out thatk, but not the first thing to worry about. This if much longer term, I would say.; > ; > In addition to positive-preserving advection schemes, it seems one other way to deal with this is adding to the pressure gradients an extra term that prevents the thicknesses of outcropped/incropped layers from reaching zero following [Salmon (2002)](https://www.ingentaconnect.com/content/jmr/jmr/2002/00000060/00000004/art00004?token=005b148389c57630504c2a726e2d58464340592f713b672c57582a67232d45234a46246c6a4d2c3167732355e72). There is a deep discussion on the physics and practical implementation of this in different validation simulations in http://www.nordet.net/etc/doc_beom.pdf. Just wanted to put this out there, I don't have a good feel for which approach would be most desirable. Thanks for the reference @apaloczy ! I know of Rick's work but didn't know whether people were using it very much. The reference seems like it will shed some light on the matter. This might very well be worth playing with to see what approach we prefer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116110257:1007,layers,layers,1007,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116110257,1,['layers'],['layers']
Modifiability,"> Also this works:; > ; > ```julia; > julia> import Base: minimum; > ; > julia> using OffsetArrays; > ; > julia> minimum(a::SubArray{<:Any, <:Any, <:OffsetArrays.OffsetVector}) = minimum(parent(parent(a))); > minimum (generic function with 21 methods); > ; > julia> minimum(zspacings(grid, Center())); > 1.0; > ; > julia> grid; > 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; > └── Bounded z ∈ [0.0, 16.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0; > ```; > ; > so it might have something to do with the `KernelFunctionOperation` that's used here?:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Grids/grid_utils.jl#L407-L413. We use the `KernelFunctionOperation` because this generalizes to any grid, including immersed boundary grids that may modify the spacings of the underlying grid (for example with `PartialCellBottom`). It's possible to implement shortcuts like calculating a minimum directly over a `view`, but I'd hesitate to put this in the source code. Maybe we can make some improvements to `KernelFunctionOperation` that allow it to be reduced more easily. That would benefit everyone.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1499438276:573,variab,variably,573,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1499438276,1,['variab'],['variably']
Modifiability,"> Also, I can run it with Nz = 4, since this example is from the MITgcm, and that case has four leves. In my reading of the docs I see `Nz = 15`:. > As in tutorial [Barotropic Ocean Gyre](https://mitgcm.readthedocs.io/en/latest/examples/barotropic_gyre/barotropic_gyre.html#sec-eg-baro), a border row of land cells surrounds the ocean domain, so the full numerical grid size is 62 × 62 in the horizontal. The domain has 15 levels in the vertical, varying from Δz = 50 m deep in the surface layer to 190 m deep in the bottom layer, as shown by the faint red lines in [Figure 4.5](https://mitgcm.readthedocs.io/en/latest/examples/baroclinic_gyre/baroclinic_gyre.html#baroclinic-gyre-config). From the first paragraph here: https://mitgcm.readthedocs.io/en/latest/examples/baroclinic_gyre/baroclinic_gyre.html. Is there another reference?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1085#issuecomment-1152751746:681,config,config,681,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1085#issuecomment-1152751746,1,['config'],['config']
Modifiability,"> Also, you don't need the `field_dependencies` argument with `discrete_form=true` (but I think that has no effect, so just a side comment, maybe we should throw an error for that). Ah yeah, I forgot to change that when I adapted it to discrete form. Thanks for catching that and for the other tips!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401359397:222,adapt,adapted,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401359397,1,['adapt'],['adapted']
Modifiability,"> And just to clarify, when I say ""extend"" I'm referring to ""method extension"" --- in other words, defining new methods for a function that _dispatch_ on the number or arguments and argument types. That makes sense and it should be easy enough to define `ShallowWaterModel` versions of these. I will work on the advection case and let you know what I come up with.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761165109:35,extend,extend,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761165109,1,['extend'],['extend']
Modifiability,"> Another possibility is that we figure out how to translate `x^2` to `x*x` (eg hook into `Base.literal_pow`). Exponentiation by literals is covered by that, just not when using constants as in #1770 . ```julia; julia> f(x) = x^2; f (generic function with 1 method). julia> code_warntype(f, Tuple{Float64}); Variables; #self#::Core.Const(f); x::Float64. Body::Float64; 1 ─ %1 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2}); │ %2 = (%1)()::Core.Const(Val{2}()); │ %3 = Base.literal_pow(Main.:^, x, %2)::Float64; └── return %3; ```; ```julia; julia> const factor = 2; 2. julia> g(x) = x^factor; f (generic function with 1 method). julia> code_warntype(g, Tuple{Float64}); Variables; #self#::Core.Const(g); x::Float64. Body::Float64; 1 ─ %1 = (x ^ Main.factor)::Float64; └── return %1; ```. HOWEVER, on the CPU both result in good code:. ```julia; julia> code_llvm(f, Tuple{Float64}); ; @ REPL[12]:1 within `f'; define double @julia_f_1923(double %0) {; top:; ; ┌ @ intfuncs.jl:312 within `literal_pow'; ; │┌ @ float.jl:332 within `*'; %1 = fmul double %0, %0; ; └└; ret double %1; }. julia> code_llvm(g, Tuple{Float64}); ; @ REPL[6]:1 within `g'; define double @julia_g_342(double %0) {; top:; ; ┌ @ math.jl:918 within `^'; ; │┌ @ float.jl:332 within `*'; %1 = fmul double %0, %0; ; └└; ret double %1; }; ```. Whereas with CUDA, the non-literal version leads to expensive code:. ```; julia> CUDA.code_llvm(f, Tuple{Float64}); ; @ REPL[12]:1 within `f'; define double @julia_f_1908(double %0) {; top:; ; ┌ @ intfuncs.jl:312 within `literal_pow'; ; │┌ @ float.jl:332 within `*'; %1 = fmul double %0, %0; ; └└; ret double %1; }. julia> CUDA.code_llvm(g, Tuple{Float64}); ; @ REPL[6]:1 within `g'; define double @julia_g_1282(double %0) {; top:; ; ┌ @ /home/tim/.julia/packages/CUDA/Ozu5O/src/device/intrinsics/math.jl:223 within `^' @ /home/tim/.julia/packages/CUDA/Ozu5O/src/device/intrinsics/math.jl:218; %1 = call i32 @llvm.nvvm.d2i.hi(double %0) #4; %2 = call i32 @llvm.nvvm.d2i.hi(double 2.000000e",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1832#issuecomment-875793587:308,Variab,Variables,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1832#issuecomment-875793587,2,['Variab'],['Variables']
Modifiability,"> Apparently running on GPUs has a few caveats even after you guys did most of the hard work in Oceananigans. @tomchor the reason your code did not compile is because this function. ```julia; function bottom_mask_func(x, y, z); sponge_one = -grid.Lz/2; sponge_zero = sponge_one + grid.Lz/10; return heaviside(-(z-sponge_zero)) * (z - sponge_zero)^2 / (sponge_one - sponge_zero)^2; end; ```. references `grid.Lz` as a global variable. Global variables can only be used inside functions on the GPU if they are declared `const` as @ali-ramadhan has done. One strategy to avoid having to use `const` is to build callable objects like `GaussianMask` that store their parameters. This is why a parameterized `GaussianMask` callable object is provided for users to use as `mask`. It might be nice to add a `SigmoidMask` masking function as well that uses `tanh` and has a `width`, `center`, and `direction`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-734412987:424,variab,variable,424,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-734412987,3,"['parameteriz', 'variab']","['parameterized', 'variable', 'variables']"
Modifiability,"> Are you envisioning that we need something additional to simply dispatching on the boundary condition types (which is already implemented?). Good point, we should just dispatch on the boundary conditions. Might get messy if we're passing the boundary conditions through multiple layers of operators so maybe there's a way to include them in the grid? The grid is already passed in. > I vote for using the halo regions to satisfy boundary conditions rather than writing if-statements into the operators. Don't think I'll use an `if` statement, maybe we can use a 1D array like `Ay[0] = Ay[Ny+1] = 0` and `Ay[j] = Δx*Δz`. Reason being is that apparently there are issues or reasons why it's better to enforce the wall by setting the area to zero at the wall, rather than using the halo regions to enforce things. I still need to discuss this with @jm-c and @christophernhill.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-500781322:281,layers,layers,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-500781322,1,['layers'],['layers']
Modifiability,"> As I said, please post your slurp script and other environment options. It is impossible to debug otherwise.; > ; > I have an annotated slurp script here https://github.com/CliMA/ClimateMachine.jl/wiki/Satori-Cluster which is what I used a while back for GPU scaling tests. A mossconfigured MPI can easily manifest itself as scaling this poor. @hennyg888 has been very busy this week so hasn't had a chance to response. The slurm script that he used was passed down from @christophernhill , and I will let him share that with you, but it might not happen until Monday. But I suppose I should learn to start running stuff on Satori as that is something that everyone else can use and people understand the configuration. I'll try to do that on Monday.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274:707,config,configuration,707,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274,1,['config'],['configuration']
Modifiability,"> As a side note: I started working on a PR that adds tests to make sure we can write output from all grids, which would also help with #1429. But yeah, I don't think it'll be a quick PR since the grids all use different property names... Good to hear! Thanks!. > Sounds like the variable names used in NetCDF might be an issue? I've had no problems with unicode variable names in NetCDF but I don't use IPython... I don't think there is a _problem_, because NetCDF accepts unicode names, etc, and Python (and most other modern programming languages I thnik) also do. The issue that I pointed out is that, because most other programming languages don't let you write code with all unicode characters, most source-code editors/prompts don't let you type all unicode characters easily. So you can write the following in Python and it'll work (I think, I haven't tested); ; ```Python; ds.plot(x=""xᶜᵃᵃ""); ```. But every time you wanna do it (or write other characters like `xᶜᵃᵃ`) you have to copy paste those characters from somewhere else, which is kind of a hassle.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799825309:280,variab,variable,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799825309,2,['variab'],['variable']
Modifiability,"> As for the origninal problem I suggested, with terrain-following coordinates, since the grid is fixed all it needs is analogous versions of the operators in xz space. So the machinary is all there but some translation needs to be done. Starting with a 2D vertical slice would be very similar to shallow water but there is an incompressibility condition that needs to be imposed, but we have tools to solve that. I don't think we need to go to 3D curvlinear coordinates since it's only curvlinear in 2 dimensions. I can find references for this if that would help. References would help! We are currently curvilinear only in xy... so 2D curvilinearity in xz is the same thing as 3D curvilinearity. But maybe I am misunderstanding what you're saying. > Create a dispatch between ConservationForm and VectorInvariantForm (similar to HydrostaticModel I presume). Alternatively, you can adapt the existing ""flux form"" momentum advection operators to work on curvilinear grids. This is something we plan to do eventually (so we can use WENO advection schemes on a lat-lon grid, for example), but haven't gotten to it yet. There is already a `VectorInvariant` type. You just need to move around some of the code and ensure that the vector invariant advection scheme generalizes / can be generalized to a shallow water system. > Define a new grid, maybe called BoundaryFollowingGrid. I think you could build something more generic like `HorizontallyWarpedGrid` with a warping function that maps from the rectangle / square to whatever geometry you're trying to use?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814261781:884,adapt,adapt,884,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814261781,1,['adapt'],['adapt']
Modifiability,> As part of the examples refactor I'm wondering whether we should we also change some of the examples to use a Makie variant for plotting?. I agree Makie is way better. Can we do animations too though? I'll explore. Sadly tartarus is not open CL enabled.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1064673750:26,refactor,refactor,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1064673750,1,['refactor'],['refactor']
Modifiability,"> As we also discussed on slack, using threads (or tasks) won't work since to capture the output the global stdout variable is changed. You need `pmap` or launch new processes with `run`. So what we did here was; https://github.com/CliMA/Oceananigans.jl/blob/5d9836398cb49cf2eea38ec6da505b03d9a94a66/docs/make.jl#L46-L53; which is equivalent to `pmap`, right?. But now I see. I thought the `run('...')` was only if I wanted to carry out global variables from one example to the other.; So you are saying that . ```Julia; asyncmap(1:length(example_scripts)) do n ; example = example_scripts[n] ; example_filepath = joinpath(EXAMPLES_DIR, example) ; withenv(""JULIA_DEBUG"" => ""Literate"") do ; run(`julia --project=docs -e'Literate.markdown(example_filepath, OUTPUT_DIR; flavor = Literate.DocumenterFlavor(), execute = true)'`; end ; end; ```; right? I'll try that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576460246:115,variab,variable,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576460246,2,['variab'],"['variable', 'variables']"
Modifiability,"> As you know, the two methods are virtually identical. I am happy to go the way of generalizing `GridFittedBottom` and add in a tolerance and a way of specifying the height. Shouldn't be much work, it's just a matter of deciding exactly what we want this to look like. The only change to existing code you need is a new property in `GridFittedBottom`. Then the current methods are the fallback (default), and we extend behavior by defining new functions for specific cases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044750063:413,extend,extend,413,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044750063,1,['extend'],['extend']
Modifiability,"> Assuming this is the last API changing PR for now, would be good to get this merged and a new version tagged so we can refactor and stabilize simulation scripts. Definitely need a new version for this change!. I think we should reverse the k-index soon though. But that can be yet another version.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533093384:121,refactor,refactor,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533093384,1,['refactor'],['refactor']
Modifiability,"> Awesome!; > ; > How big is `wet_cells_map`? Should we extend `ImmersedBoundaryGrid` so that users can opt in/opt out of this feature?. It is not that large, I figured that with `UInt16` we can cover almost all practical cases. `wet_cell_map` will be a vector of _active_ locations defined by a tuple of indices. Depending on what % of the domain is active, the size of the map will be. `prod(size(grid)) * %active * 3 * sizeof(Type)`. where `Type` is the `UInt` with the minimum size required to represent `maximum(size(grid)))`; In the example of the ocean, where 57% of the domain is active, the map is 42.75% the size of a standard Float64 `Field`:. a UInt16 occupies 2 bytes, so compared to a field, the map is . `(0.57 * 3 * 2) / 8 ≈ 0.4275` . I guess adding the opt in/opt out can be nice and is very easy because of . https://github.com/CliMA/Oceananigans.jl/blob/b7835edbac0a7318d49462addb1c1046014e39c4/src/ImmersedBoundaries/wet_cells_map.jl#L10-L21. which is used now to calculate the map only when we construct the model.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317283775:56,extend,extend,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317283775,1,['extend'],['extend']
Modifiability,"> Before proceeding further, I guess we should discuss a bit on whether we want a single parameter for gravitational acceleration (`effective_gravitational_acceleration`, which can encapsulate both gravitational acceleration `g` and reduced gravity `g'` terms) or two parameters (one for `g` and `g'` each), with Navid's code above an example of the latter. I am inclined towards the former as I feel it's cleaner (scientifically and for coding purposes), but happy to go either ways. I didn't really think through my code above so don't pay too much attention to it. :); It was just a placeholder to demonstrate about parametric types. But I don't understand exactly what you suggest. `gravitational_acceleration` is a number, and it the same regardless of the number of layers you have. It's the acceleration that the top-layer surface feels (given that we use the approximation that `ρ_air ≪ ρ_fluid`. The reduced gravities `g'_{k+1/2} = g * (ρ_layer_k+1 - ρ_layer_k) / ρ_layer_k+1` are the gravitational accelerations each of the fluid interfaces feel. So `g'` is a Tuple of `k-1` numbers, where `k` is the number of layers, right? And this parameter is irrelevant for the SingleLayerModel. Were you suggesting to combine these in a single `k`-long tuple, e.g.,. ```julia; gravitational_acceleration .* (1, (ρ[k] - ρ[k-1]) / ρ[k-1], (ρ[k-1] - ρ[k-2]) / ρ[k-2], ..., (ρ[2] - ρ[1]) / ρ[1] ); ```; which will become a number for single layers?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1471840937:772,layers,layers,772,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1471840937,3,['layers'],['layers']
Modifiability,"> Blast. How about `x′`, `y′`?; >; > Can also change the vorticity notation in field_metric_products to something else. I'm okay with `x′`, `y′` but I'll leave it for now since it's localized to the grid constructor so it hopefully shouldn't cause any confusion (and there's a comment). Could be cool if we had like a notation list/glossary so every variable had one meaning like some books have, but we'd probably run out of letters very quickly...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-799811016:350,variab,variable,350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-799811016,1,['variab'],['variable']
Modifiability,"> Buoyancy might not be worth the hassle...; > ; > I just know that density drops out of the Boussinesq equations; if we then convert to buoyancy coordinates and discretize in buoyancy space, we might obtain something identical or similar to the layered shallow water equations.; > ; > We've written Oceananigans to deal with buoyancy rather than density with great intention: a ""reference density"" does not always appear in every setup / numerical experiment (for example: using buoyancy itself as a tracer), and when it does appear it's only meaningful in a few specific places (equation of state, thermodynamic calculations at the surface). This not only clarifies the physics (eg what role _does_ the reference density play?) but also helps reproducibility (we shouldn't have to report / set a reference density for experiments where its _dynamically_ irrelevant). Yes, it's different from how we normally think about the problem, but there's always room for progress...; > ; > I'm not sure if the layered shallow water benefits from this philosophy too. I don't know if using buoyancy instead of density affects the layered shallow water model much. One way to think of the model is that the density/buoyancy is piecewise constant, which is why one is just a scalar multiple of each other. We use hydrostatic balance to determine the pressure in terms of density/buoyancy and we can then use either variable. . If we are going to use buoyancy in the n-layer problem, then we might want to start with the one-layer version. I prefer to think of it as a reduced gravity shallow water model, since that is more general. In that context we define the reduced gravity as `g' = Δρ g/ ρ₀`, where `Δρ` is the change in density and `ρ₀` is a reference density. It seems that the reduced gravity is proportional to the change in buoyancy between two layers. Not sure if that helps at all, but its an observation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116106583:1404,variab,variable,1404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116106583,2,"['layers', 'variab']","['layers', 'variable']"
Modifiability,"> But question: floats need adaptation?. The answer is no. For any object that doesn't have an explicitly defined `adapt` method, then `adapt(to, x) = x`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2179041846:28,adapt,adaptation,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2179041846,3,['adapt'],"['adapt', 'adaptation']"
Modifiability,"> But the text, the way is written at least, is generic, was not referring to **this** particular problem. :. well all problems in Oceananigans are nonlinear**; and our abstractions are not flexible enough to do the linear instability without nonlinear terms :-/. But more generally I think fluids are nonlinear --- linearization is just an idealization? I think the approx helps clarify that this is a reduction of full Navier-Stokes. But agree it could limit the scope of the discussion to fluids (which might be ok?). ** unless `advection = nothing` (if we have implemented that), but if you do that then you also lose the background field terms at the current moment.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720084341:190,flexible,flexible,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720084341,1,['flexible'],['flexible']
Modifiability,"> Can any of you take a look to see if I'm doing anything that's wrong or ill-advised in any way? (I solved it in a pretty pythonic way...). I think your solution is fine. In more complicated scenarios it's sometimes better to use dispatch rather than if statements because the code is then more extensible (by defining new functions, which can go anywhere, rather than adding conditions to a chain of if statements in some central location). Here it's not so crucial and we can refactor later if we need to. We certainly _can_ use if statements in julia (and dispatch in python!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784539053:479,refactor,refactor,479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784539053,1,['refactor'],['refactor']
Modifiability,"> Can you try this branch and see if it goes better? `ss/fix-memory-issue`. It seems to solve the memory issue! But I do get an error when writing to disk:. ```; ERROR: LoadError: NetCDF error: size mismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:212,variab,variable,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165,3,"['Variab', 'variab']","['Variable', 'variable']"
Modifiability,"> Can't we add advective terms via the biogeochemical forcing term?; > ; > edit: I see you mentioned that, so I might be missing something... I'll take a look at your examples.; > ; > PS we should add those scripts to `validation/biogeochemistry/`. > I think we can impose a little more structure that eases biogeochemical model development.; > ; > One route is to build out a layer on top of `AbstractBiogeochemistry` for models with a common form, something like; > ; > ```julia; > struct TracerBasedBiogeochemistry; > biogeochemical_tracers; > drift_advection_schemes; > drift_velocities; > transitions; > auxiliary_fields; > end; > ```; > ; > and perhaps more properties. This is similar to how `SeawaterBuoyancy` works, in that it provides a concrete structure with a slot `equation_of_state` whereby ""external"" packages like `SeawaterPolynomials` can insert custom behavior.; > ; > Another possibility is to build out a new abstract type below `AbstractBiogeochemistry` with a function-based interface (somehow).; > ; > I was also thinking it would be nice to supply a ""continuous form"" interface, so that model developers can implement functions that look something like; > ; > ```julia; > biogeochemical_transition(x, y, z, t, N, P, Z, D, parameters); > ```; > ; > rather than having to use the ""discrete form"".; > ; > This sort of structure could also be provided by an external package. The advantage of including it here is that we get tighter coupling with Oceananigans development. This seems like a good idea, I will have a think and try and come up with something",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311545594:1455,coupling,coupling,1455,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311545594,1,['coupling'],['coupling']
Modifiability,"> Comparing the `model.clock.time` seems to be a good solution since RK3 `tick!` increases the stage and `model.clock.time`.; > ; > I'm just curious why `FieldStatus` is required as it's just a container/wrapper around a `Float64`. Couldn't you dispatch on `::Number` and `::Nothing` instead of `::FieldStatus` and `::Nothing`?. I couldn't do that because that would require making `AveragedField` a `mutable struct` (for example), which cannot be used directly on the GPU. The adapt method for `FieldStatus` (which is mutable) returns a `NamedTuple` (similar to `Clock`). I think that's right...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/968#issuecomment-698425183:478,adapt,adapt,478,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968#issuecomment-698425183,1,['adapt'],['adapt']
Modifiability,"> Curious what's the status of this effort to add Metal support to Oceananigans. It's crazy how easy it is to add this support, but the major limitation is that Metal only supports Float32. There hasn't been much effort to validate anything for Float32, though this is a worthwhile goal... Also if we do refactor this PR, I think we should probably put the Metal functionality in an extension, much as #3468 does.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-2093736191:304,refactor,refactor,304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-2093736191,1,['refactor'],['refactor']
Modifiability,"> Did you want me to give this a try? It does not seem like a lots needs to change and I will certainly learn a lot in the process. That's fine with me (and I am very happy to help, or pair program over zoom). I think resolving this issue (moving files around) should happen in a separate PR from implementing `ShallowWaterModel`. Imports and exports will also change, for example `IncompressibleModels` will become a submodule of `Models`, and we'll have to pull the name `IncompressibleModel` into `Models`:. ```julia; # in Models.jl. include(""IncompressibleModels/IncompressibleModels.jl""). using IncompressibleModels.IncompressibleModel; ```. Hopefully we can reuse as much code as possible. If your prognostic variables are `hu,`, `hv`, `h`, you may benefit from some fancy julia abstraction that will let you reuse momentum advection and tracer advection operators like `div_Uu` and `div_Uc`. I'm happy to help with that. Your fields will all have to be three-dimensional (with a single grid point in the vertical direction). Also until #1024 is fixed we will unfortunately also need halo regions in the vertical direction. Hopefully this won't matter too much and eventually we will be able to use `Flat` vertical directions. As for the file structure, I think some functions can be generalized to work for any model rather than split, like `store_tendencies!` (it perhaps makes sense that `store_tendencies!` is independent of the model type). I think it's nice that the physics-specific functions will now be in `Models/IncompressibleModels`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-725500396:715,variab,variables,715,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-725500396,1,['variab'],['variables']
Modifiability,"> Distributed IO is not supported yet and will require a lot of work and refactor so for the time being we have to do with the rank in the output writers. Distributed IO is not necessary to solve this problem. We can introduce a convention for filenames whereby the rank number is automatically inserted into the filename for distributed simulations. Similarly the convention can be reversed for `FieldTimeSeries` to make the process seamless for users. There are probably plenty of other possible solutions. The first step is recognizing that a problem or deficiency exists, and having the desire to fix it. Then we can do the fun part, which is to design solutions to an important problem. Note that distributed IO is unlikely to ever be supported for JLD2. So to provide a seamless experience with JLD2, we really do require a filename convention to solve the problem. (For NetCDF, we could envision providing a choice between file splitting or distributed IO.). Filename conventions also seem preferred to me for many cases in a world of GPUs where each rank likely needs to hold a substantial portion of the computation for performance. Splitting files by rank will limit the filesize, which makes it easier to transfer data when the simulations are very large --- which will probably often be the case when doing distributed simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895891029:73,refactor,refactor,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895891029,1,['refactor'],['refactor']
Modifiability,> Do these changes mean that we need to rewrite the PR that makes things more concrete? It looks like there will be a lot of merge conflicts.; > ; > _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/pull/290#issuecomment-506888727_. Looks like there will be a few conflicts but mostly small changes to the boundary conditions will need to be made. They're still mutable structs in this PR so a lot of the examples should still work. I think the two big issues with this PR are still the same:; 1. The way we set boundary conditions changes a little bit in this PR so we should probably also update any existing examples and scripts.; 2. This PR breaks checkpointing. This is fine as long as we have a fix ready to merge. Been meaning to convert to a native Julia checkpointer that only saves the bare essentials to disk (either in binary or JLD2) so this is a good opportunity.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/282#issuecomment-506890827:40,rewrite,rewrite,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/282#issuecomment-506890827,1,['rewrite'],['rewrite']
Modifiability,"> Do you want to contribute an advection scheme to Oceananigans? A lot of people might benefit from having the kind of advection scheme that you are using! It may not be very much work, since we have an interface for adding new advection schemes. Sure! I'll submit a PR soon. > Do you evolve the tracer fully outside of the `Oceananigans` infrastructure? . Yes, it's fully outside of `Oceananigans`. I just use the velocities from `Oceananigans`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/949#issuecomment-694262045:285,evolve,evolve,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/949#issuecomment-694262045,1,['evolve'],['evolve']
Modifiability,"> Does anybody know what is the rationale for `similar(::Field)` to drop the boundary conditions?. I think it depends on how you view ""boundary conditions"". If we adopt a ""weak formulation philosophy"" then boundary conditions are part of the definition of an equation set and don't belong to fields at all. This is how `ImmersedBoundaryGrid` works; inhomogeneous boundary conditions can only be enforced by adding boundary fluxes to a tendency. There's no such thing as a ""boundary condition"" outside the context of time stepping. Unfortunately, `Oceananigans` is not consistent in how this philosophy is applied and when we are on ""non-immersed"" grids we have more of a ""strong formulation"" philosophy. I believe the rationale for not transferring boundary conditions is the expectation that we will eventually adopt a ""weak formulation philosophy"" consistently throughout the code. In that case, non-default boundary conditions are meaningless on anything but prognostic fields that are evolved during time-stepping.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2882#issuecomment-1411317487:989,evolve,evolved,989,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2882#issuecomment-1411317487,1,['evolve'],['evolved']
Modifiability,> Does it make sense to nuke sandbox stuff in this? It seems a bit orthogonal to the rest of the PR? Is it meant to be in there?. @christophernhill @ali-ramadhan I meant to nuke the sandbox stuff in the next PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/312#issuecomment-514747344:29,sandbox,sandbox,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/312#issuecomment-514747344,2,['sandbox'],['sandbox']
Modifiability,"> Does the magnitude of the velocity error scale with the time-step, or resolution?. I think the expected behavior is that the velocity error in the object scales with the non-hydrostatic pressure gradient times the timestep of the Runge-Kutta substep. Presumably the non-hydrostatic pressure gradient in the object scales as the non-hydrostatic pressure over the length scale of the object. If the strength of the non-hydrostatic pressure field on the object of the boundary is a function of the outer-flow and object configuration, then I don't think grid refinement will help much. We should do a more rigorous validation of this at some point, but at least the dependence on the timestep gives a way to control the velocity error. I also suspect the pattern of the normal velocities in the plot shown may be spurious, as we know the velocity gets very small in all 'solid' nodes fully inside the object. The apparent error on the boundary as a function of angle may have to do with the how the current first-pass implementation sets the solid boundary location on the c-grid. . @christophernhill thanks very much for the offer! It will be good to take you up on that down the line, but let @whitleyv and I do a bit of digging first.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738460012:519,config,configuration,519,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738460012,1,['config'],['configuration']
Modifiability,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878:1136,extend,extend,1136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878,1,['extend'],['extend']
Modifiability,"> Glad you brought this up! Definitely a use case for an expert/power user but I can think of a few use cases (e.g. nested simulations) that would be good to support. It's also crucial for the semantics of `set_default_number_type!` versus simply ""set_number_type!"", ie we want to preserve independent settability for all parameters. We've been intentionally disciplined / conservative about ""no global settings"", so this would represent an adventure away from that philosophy. It seems well-motivated in this case. The only other parameter that can possibly appear more than once in Oceananigans (as far as I know) is gravitational acceleration (free surface and buoyancy). Good points about environment variables and portability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2397234167:705,variab,variables,705,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2397234167,2,"['portab', 'variab']","['portability', 'variables']"
Modifiability,> Great job guys. @jagoosw have you been able to run this (https://github.com/CliMA/Oceananigans.jl/blob/19dac0b8f6b621057e250ecf0510b3c4c91915e9/validation/lagrangian_particles/particles_in_convection.jl#L30) on GPU?; > ; > . I haven't run that case on GPU but would have thought it will run if you change the grid architecture and adapt the initial particle positions (which is described in the simulation tips part of the docs). I can have a look later to see if I can run it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1590920430:333,adapt,adapt,333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1590920430,1,['adapt'],['adapt']
Modifiability,"> Greg, Doesn't Ali have a version of immersed boundary layers going?. @johncmarshall54, Ali experimented with a simple immersed boundary implemented via Oceananigans's user-defined forcing functions. The code is these 9 lines:. https://github.com/CliMA/Oceananigans.jl/blob/a921fc3edbf795bf4a2193cca84cad41ebdd5625/verification/flow_around_cylinder/flow_around_cylinder.jl#L18-L27. This implementation damps the velocity field to zero on a very fast time-scale (specified by the parameter `K`) within the immersed boundary. This is certainly a nice, simple immersed boundary implementation for Dirichlet / Value boundary conditions and could be a good starting point. However, I also think there's some good reasons to pursue an alternate immersed boundary implementation to what @ali-ramadhan has done:. 1. @ali-ramadhan's implementation doesn't obviously extend to other boundary conditions, like prescribed gradients or fluxes (the latter being crucial for the geophysical problems we're interested in). So, even if we use a continuous forcing method similar to @ali-ramadhan's implementation, we need to figure out how to enforce boundary conditions other than Dirichlet boundary conditions.; 2. @ali-ramadhan's implementation conforms exactly to the grid; however we would like to be able to model smoothly-varying boundaries.; 3. As noted by @whitleyv, @ali-ramadhan's ""continuous forcing method"" implementation introduces a time-step restriction due to the need to explicitly resolve the damping time-scale in the forcing function. It seems that a discrete forcing method overcomes this restriction and could prove crucial for geophysical problems that involve otherwise long time-steps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707412244:56,layers,layers,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707412244,2,"['extend', 'layers']","['extend', 'layers']"
Modifiability,"> Gregg, Ali, can we get variable delz in at the same time? John. I'm happy to start working on that in October. I think we should reverse the k-index first, because I think at least part of the variable delz algorithm will depend on the direction of `k`. @ali-ramadhan on `buoyancy` versus `buoyancy_perturbation` --- since this is an internal issue (not part of the API), I'm fine to stick with `buoyancy_perturbation` for now and continue to discuss what the best nomenclature is after this PR is merged.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533099629:25,variab,variable,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533099629,2,['variab'],['variable']
Modifiability,"> Gregg, Ali, can we get variable delz in at the same time? John. Variable grid spacing is a huge addition and is already the subject of two open pull requests (PR #283 and PR #306) requiring extensive refactoring and testing, which we collectively decided to put on the back burner for now. If it's a high priority now, we can look reviving it sooner rather than later. A lot of the preliminary work has been done. Reversing the k-index is a smaller change and wouldn't require additional testing (we just need to get existing tests to pass).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533097623:25,variab,variable,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533097623,3,"['Variab', 'refactor', 'variab']","['Variable', 'refactoring', 'variable']"
Modifiability,"> Guys, is this a good idea? John. It's an optional set of utilities we can use to choose a time step. Default will still be constant dt. I hear it's easy to get burned by adaptive time-stepping, especially if taking time steps close to what's allowed by CFL. But I think it'll be especially useful for the seasonal cycle simulations where instead of running with dt = 3 seconds, we can set a maximum of dt = 3 seconds and let the adaptive time stepping ensure we don't blow up just because we were suddenly restricted to dt = 2.9 seconds by CFL. Or we can always take time steps that are e.g. 0.2*max_dt to ensure we're significantly below CFL.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505551251:172,adapt,adaptive,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505551251,2,['adapt'],['adaptive']
Modifiability,"> Here's a question: wouldn't it be better if this were a `KernelComputedField`? (Or maybe even a `KernelFunctionOperation`?). I think reusing more features that have been developed for user applications internally is a great idea in general. More code reuse, more understandable internals. I have thought about this a bit for diffusivities and pressure fields, which are both auxiliary fields to a model and some flavor of ""ComputedField"". I think we would need to expand on the user interface to `KernelComputedField` for this purpose. There are a few reasons. First, the user interface to ComputedField does not supply a way to combine kernel computations for more than one field. Second, we need to develop a user interface for propagating arguments from `compute!` into the kernel. The reason is that we have to pass in both `closure` and `buoyancy` into this kernel. `KernelComputedField` supports parameters right now. However, I think its important that these arguments are explicitly passed from the model (rather than being bound to the diffusivities at model construction time) --- because models are mutable, which means that users can change the closure or buoyancy model on the fly (provided the new object has the same type as the old one). Expanding the computed field infrastructure to support simultaneous computation and propagated arguments would be really cool I think and a great addition to the code. Once that's done we could consider refactoring internal code, which would also be awesome.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882653413:1459,refactor,refactoring,1459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882653413,1,['refactor'],['refactoring']
Modifiability,"> Hm.... `HydrostaticFreeSurfaceModel` does not support `BackgroundFields`.... Right, we do not support that right now. I think there are some niche uses but, for the most part, when we go hydrostatic we are often doing large scale and a bit more complicated modeling with parameterizations, etc, where getting background fields right would be more of a pain than with NonhydrostaticModel (which still does not work properly with nonlinear subgrid-scale turbulence closures). I think its better to go more mainstream for this example. I think the use cases that this example serves as a starting point for are probably not going to use background fields, typically.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986920020:273,parameteriz,parameterizations,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986920020,1,['parameteriz'],['parameterizations']
Modifiability,> Hmmm I thought this line would be enough; > ; > https://github.com/CliMA/Oceananigans.jl/blob/723ff2d69bb486a856c9748f84e56aef5e524c9e/docs/make.jl#L150; > ; > but you're right we used to use the `TRAVIS_REPO_SLUG` environment variable for this I think.; > ; > Looks like the GitHub Actions equivalent is `GITHUB_REPOSITORY` like you linked to.; > ; > But there doesn't seem to be one for Buildkite... https://github.com/JuliaDocs/Documenter.jl/blob/fa459cf315425d4fc5bdfbd6769f3b0e78f4a795/src/deployconfig.jl#L644-L666. Perhaps you are right that nowadays (with more recent Documenter versions) ; https://github.com/CliMA/Oceananigans.jl/blob/723ff2d69bb486a856c9748f84e56aef5e524c9e/docs/make.jl#L150; suffices. Bit while ago it wasn't enough! :) . I'll test it though and we'll find out.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782353270:229,variab,variable,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782353270,1,['variab'],['variable']
Modifiability,"> Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions. I think so. Let's definitely try!. Is it useful to have a general `Drag` boundary condition in general (in addition to `Periodic`, etc.), that would be used not only for immersed boundaries, but also for actual boundaries?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050120921:19,adapt,adapt,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050120921,1,['adapt'],['adapt']
Modifiability,> How do you like this? (I'll work on this refactoring tomorrow probably.). I think it sounds great and trust your judgement here.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720172854:43,refactor,refactoring,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720172854,1,['refactor'],['refactoring']
Modifiability,"> However, I found that the velocity shear at the first grid points is much larger than that predicted by the Monin-Obukhov similarity theory. I don't have much experience with solid wall boundary layers. A quick search returns this review:. https://journals.aps.org/prfluids/pdf/10.1103/PhysRevFluids.2.104601?casa_token=VBO0hrNqp-cAAAAA%3A3XEKZfLTdhiVluwRl8sCQCkOK44GoGUX-546uFtqQjSWAUIDQpKyyQsA4lQd65Oz6Kw5ClWias_CVQ0. suggesting that correct flux predictions in wall-modeled LES is unsolved. For example:. <img width=""616"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/a6ffe67e-2009-441a-a440-80afe0dc4a70"">. shows a mismatch between DNS and wall-modeled LES for a few standard codes. Based on the literature, a failure to reproduce the log-law is expected?. It might help if you provide more background on what exactly you're trying to achieve, and why you believe the current approach will achieve that objective. For example, are we attempting to reproduce a known result?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1650818364:197,layers,layers,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1650818364,1,['layers'],['layers']
Modifiability,"> I agree that the PoissonSolver struct is a better place to store the pressure boundary conditions, but what do you think of just storing them in model.boundary_conditions?. I don't like this idea, because I would like the tuple of boundary conditions to have the same length as the number of solution variables to permit easy and simple looping / code reduction / arbitrary tracer stuff in the future. . While not crucial, I think it makes sense (though of course we don't currently have a `solution` tuple, though that would be easy to add). Edit: we could achieve both aims by adding a level of hierarchy to `boundary_conditions`, so that it has fields `solution, tendencies, pressure`, (each of them a tuple), or something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-527167861:303,variab,variables,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-527167861,1,['variab'],['variables']
Modifiability,"> I also find `with_halos` a bit messy, but in this case it might be neccessary to output grid metrics to disk if JLD2 or NetCDF are configured to output the halos. On the contrary with this approach you should be able to use the existing `construct_output`:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/OutputWriters/output_construction.jl#L44-L46. which is designed for `Field` / `AbstractOperation` already. So I think again with this approach the kwarg `with_halo` is irrelevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450926823:133,config,configured,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450926823,1,['config'],['configured']
Modifiability,"> I also suggest changing the module name to Buoyancies or BuoyancyModels and reserving Buoyancy for the user-facing object. The current names that @ali-ramadhan and I used were always meant to be a placeholder as we couldn't agree on good ones to use. I quite like this suggestion (and I suspect @ali-ramadhan does too) so I implemented it.; Just as a reference, here are the commands that I used (plus the same for the struct `Buoyancy`):. ```bash; find . -type f -name ""*.jl"" -exec sed -i ""s/\<Buoyancy\>/BuoyancyModels/g"" {} \;; find . -type f -name ""*.md"" -exec sed -i ""s/\<Buoyancy\>/BuoyancyModels/g"" {} \;; ```. I also added an example in the sandbox that runs a fully quiescent fluid with a tilted stratification for an hour and then makes sure that the vertical and horizontal derivatives stay the way we expect them. (This test is done both for `BuoyancyTracer` and for `SeawaterBuoyancy`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-795853154:651,sandbox,sandbox,651,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-795853154,1,['sandbox'],['sandbox']
Modifiability,"> I am not sure that I am following everything there. Is it for flux-form of vector-invariant ? otherwise, I don't recognize the energy-conserving discretization (thought it would have been nice to have). I didn't realize the the Coriolis implementation is different for the ""flux-form"" momentum equations than for vector-invariant momentum equations --- thanks for pointing that out @jm-c. I don't quite understand why this is the case. However, it is not that difficult to extend our Coriolis implementation to dispatch on the `advection` ""scheme"" / form if we need to. After looking into the details (see below), it would appear that the implementation we are using is correct if. 1. The horizontal grid is regular; 2. The horizontal grid is curvilinear and we are using `momentum_advection=VectorInvariant()`. Because these are the only two possible cases, I believe the current Coriolis implementation is sufficient. However when/if we support curvilinear horizontal grids with flux form advection terms, we will (if we follow the MITgcm implementation) need to dispatch the evaluation of the Coriolis term on `momentum_advection` scheme. Another question is whether it even makes sense / is physically consistent to support `FPlane` and `BetaPlane` on grids that are sectors of the sphere. Perhaps there's no point at all in implementing a curvilinear-friendly version of `FPlane` and `BetaPlane`. If this is true, we can revert back to the prior implementation of both for Rectilinear grids, and focus on a energy/enstrophy - conserving Coriolis scheme for curvilinear grids on the surface of the sphere. # Some notes on Coriolis implementations for vector-invariant and flux form momentum schemes . Focusing on the x-component, the [MITgcm documentation](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8) writes that with a vector-invariant advection scheme, the Coriolis term that preserve potential enstrophy is. <img width=""228"" alt=""image"" src=""https://user-images.gith",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782741799:475,extend,extend,475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782741799,1,['extend'],['extend']
Modifiability,"> I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators. For example, if the boundary is fixed and not dependent on the interior variables, it might be possible just to fix the BC once before the sub stepping and just iterate without needing to use any update",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319:561,variab,variables,561,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319,1,['variab'],['variables']
Modifiability,"> I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier. Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882750311:376,flexible,flexible,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882750311,1,['flexible'],['flexible']
Modifiability,"> I apologize if this is just a problem with communication style, but I don't think this statement can possibly be correct. The above example seems to demonstrate, for example, that the cylinder wake can be represented well by _either_ making the domain large enough (with sponge layers), _or_ by using a better numerical method with a smaller domain.; > . Yeah sorry, that was very imprecise of me. I more mean that that case was a good demonstration of a situation where we need a very large domain to not effect the interior solution in the area we are interested in, or have a matching scheme. > I really hope that the outcome of this work are a set of solid recommendations for nesting (better yet, a recipe that does not have to be changed --- a recommended matching scheme, or a combination of matching scheme and sponge layer) which is supported by unequivocal and rationally presented evidence. That sounds good in the long term. Do you want that all for this PR or can we merge this part after I've implemented a simple matching scheme as a demonstration and then work on the rest elsewhere?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2037435373:280,layers,layers,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2037435373,1,['layers'],['layers']
Modifiability,> I can adapt `GridFittedImmersedBoundary` for `IncompressibleModel` in a separate PR if that makes sense?. I think a separate PR is best. It's really a research PR since we don't have a recipe so the validation process will probably be more involved. It's not clear what algorithm we should choose for `IncompressibleModel`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-839931448:8,adapt,adapt,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-839931448,1,['adapt'],['adapt']
Modifiability,"> I can't run the MPI. I need to be directed to some instructions to setup my MPI. @simone-silvestri pointed at the [MPI docs](https://juliaparallel.org/MPI.jl/stable/configuration/#Configuration). Do I need MPIPreferences? I don't know... @glwagner did you have to use that? If not, why must I... we are using the same machine... What is your setup? Is your MPI executable path exported in the bash? Do you have a `Localpreferences.toml` file generated from MPIPreferences? ; Another way to use MPI.jl is through the [mpiexecjl](https://github.com/JuliaParallel/MPI.jl/blob/master/bin/mpiexecjl) command. I typically just use the mpirun executable, but this other approach might help",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2282771458:167,config,configuration,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2282771458,2,"['Config', 'config']","['Configuration', 'configuration']"
Modifiability,"> I can't see the modifications to `geostrophic_adjustement.jl` that were made on this PR --- have these changes been pushed?; > ; > I don't think `Flat` will work in the vertical for `HydrostaticFreeSurfaceModel`. We have to inspect the way vertical velocities are calculated but I believe it will fail. Perhaps we need a more general algorithm, or we can write code to deal with that special case. I don't think its important (aside from testing) since if one wants to run a shallow water model they might be better off using `ShallowWaterModel`... Sorry, since that example didn't work I decided to restore that example to master. If you wanted to see the minor changes that I have done you can go here https://github.com/CliMA/Oceananigans.jl/pull/1513/commits/f372a5e5aa2c5d9cb3cdc9d0bc3104df5f1de184. I added in some `Flat` tests to `test_hydrostatic_free_surface_models.jl` and I'm happy to say all of those pass. Actualy, since last night all checks have passes so this PR seems to be in the clear. I should mention that I did adapt the `cell_advection_timescale` to deal with a vertically stretched grid and my solution might not be the cleanest but it does work. I do wonder whether something similar needs to be done to `cell_diffusion_timescale`. . One issue is that this version of `lid_driven_cavity.jl` is different from `master` but restoring that should be easy, if that's what we decided to do. Another thought: `HydrostaticFreeSurfaceModel` is labelled as experimental. If for some reason `Flat` does no work completely with that model, I suppose it's not as bad as it seems to work with the other two models, as far as I can tell. @glwagner if you are able to review this PR and tell me what other concerns you have or other tests we need to do, I can certainly try and do those.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000:1035,adapt,adapt,1035,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000,1,['adapt'],['adapt']
Modifiability,"> I considered this when I started developing the Verstappen closure. Almost none of the code is shared, which is why there are two files, unlike the Smagorinsky closures which have a lot of shared code. In principle it might be possible to refactor both implementations to share (a bit) more code but that would be a lot of work, and would also probably make both implementations more complex... Didn't realize they were that different. In that case, maybe makes more sense to keep two separate files. More complex implementation of AMD sounds like a bad idea.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526200983:241,refactor,refactor,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526200983,1,['refactor'],['refactor']
Modifiability,"> I could use some explanations on your closure usage. @glwagner is the mastermind behind the implementation of the LES closures. It's still not documented but he's written up some documentation about them in a different package: https://dedales.readthedocs.io/en/latest/summaryclosures.html. > If it was up to me I would prefer an extended documentation of GPUifyLoops ;) I only understand how it works by reading what you do with it. Yeah GPUifyLoops could do with an extra example or two... I have an old and still open PR showing an example of a 3D stencil computation but you probably already know how to do this: https://github.com/vchuravy/GPUifyLoops.jl/pull/18. Ah interesting, yeah I found papers online that described a 50-80% speedup but sounds like a lot of manual work which Julia may be able to do for us :) We've barely thought about CPU performance let alone SIMD but maybe something like GPUifyLoops.jl can figure out the multicore SIMD code. > I will try to use part of your code to rewrite the toy 2D CFD solver I have translated from Matlab (https://discourse.julialang.org/t/asynchronous-makie/27127/9?u=laurentplagne). That's awesome! Do let us know if you have any questions. That's a pretty cool use of Makie with `fillrange=true`!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518441255:332,extend,extended,332,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518441255,2,"['extend', 'rewrite']","['extended', 'rewrite']"
Modifiability,"> I couldn't do that because that would require making `AveragedField` a `mutable struct` (for example), which cannot be used directly on the GPU. The adapt method for `FieldStatus` (which is mutable) returns a `NamedTuple` (similar to `Clock`).; > ; > I think that's right... Ah ok that makes sense. Output writers are `mutable struct` have a similar field `previous` but they never get passed to GPU kernels so the issue never came up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/968#issuecomment-698431242:151,adapt,adapt,151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968#issuecomment-698431242,1,['adapt'],['adapt']
Modifiability,"> I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. I'm still wondering about this solution, which may both be _more general_ (since users can effect arbitrary changes to tracer tendencies, not just source/sink terms) and is less heavy in the source code. Right now, this PR makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > although I imagine that could use a lot more memory if there were a large grid and small amount of particles. It seems the memory requirement of the forcing function approach is proportional to the number of _tracers_, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248417125:1226,flexible,flexible,1226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248417125,1,['flexible'],['flexible']
Modifiability,"> I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?. I think many of the tests can probably be designed / written in a more maintainable way. There's a lot of boilerplate and copy-pasted code in the tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922536029:305,maintainab,maintainable,305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922536029,1,['maintainab'],['maintainable']
Modifiability,"> I feel that labeling it ""weird"" is a harsh judgement. But I would say that using the word ""oceanic"" to describe software is ""quirky"". If folks prefer ""ocean-flavored"" (also quirky, just more characters), let's switch to that. Being ""flexible"" is probably one of our core philosophies as well so I agree with adding that. Sorry, didn't mean to sound harsh. I just really didn't know what other word to use. Also, @glwagner I don't think we have access to change that description. It probably needs to be someone from Clima.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945841241:235,flexible,flexible,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945841241,1,['flexible'],['flexible']
Modifiability,"> I have also realised that we need to have an exterior value for every open boundary for when the flow spontaneously becomes an inflow so I think it would make sense to have every open boundary be the same and just be `OpenBoundaryCondition(external_value)`, and then put the tendencies etc in as arguments to `_fill_X_halo!`. Then when `U_b` is negative we either set the value or do nudging like in ROMS to prevent shocks (but I think this is a question for further down the line). We might also want to consider oblique waves but that shouldn't be too hard to extend to we might just have to calculate a lot of surrounding points which might motivate some other way to do it.; > ; > Does this make sense to everyone? I also can't see an obvious way to get Δt to the halo fill since it doesn't even make it into the `update_state!` so any suggestions would be appreciated. To clarify, the statement ""when U_b is negative"" means more generally ""when U_b implies inflow into the domain"". It makes sense to me that inflow is prescribed, whereas outflow is a little tricker, requiring us to smoothly advect information out of the domain. Having the boundary condition depend on the previous time-step does seem to break assumptions we have made about how information flows. For example, we call `update_state!` during model construction. How does the first time-step / initialization work with this kind of outflow model? It might help to consider that. Practically speaking it would not be hard to pass the time-step to update state. But it might be nice to understand the implications before committing, because a different design / redesign could make sense. For example I supposed we would need to have a default ""time step"" that is 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972515289:564,extend,extend,564,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972515289,1,['extend'],['extend']
Modifiability,> I have created a new validation script called `shallow_jet_topography.jl` that evolves the barotropically unstable jet (like in the shallow water example) but now over a shelflike topography. It can be found in `valiation/shallow_water`. I don't see it; did you push?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975080077:81,evolve,evolves,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975080077,1,['evolve'],['evolves']
Modifiability,"> I have only used overwrite_existing=false without a checkpoint for short tests within the same Julia instance to extend the model output. Thank you for pointing out this use case. I think this is another situation that could be solved by waiting until `run!` for initialization. We can analyze an existing file and determine whether or not any data within the file will be overwritten based on the simulation parameters (current time, stop time). Another idea by the way would be to move the concept of ""overwriting"" to `run!`, as well. Then the single keyword can apply to all output, or not, which presumably more aligned with what a user would want (rather than toggling `overwrite_existing` for each writer individually).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2392171348:115,extend,extend,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2392171348,1,['extend'],['extend']
Modifiability,"> I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > ; > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?. @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on. I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885336918:409,config,configured,409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885336918,1,['config'],['configured']
Modifiability,"> I hear it's easy to get burned by adaptive time-stepping, especially if taking time steps close to what's allowed by CFL. Adaptive time-stepping is useful for avoiding ""getting burned"", since you can ensure that your time-step is always stable by choosing a conservative CFL number. > Or we can always take time steps that are e.g. 0.2*max_dt to ensure we're significantly below CFL. I don't understand this comment. The `TimeStepWizard` has a parameter `cfl`, which sets `dt` to achieve a certain CFL number. If you set `cfl=0.1`, the time-step is chosen so that CFL = 0.1. The parameter `max_dt` is a user-defined parameter that limits `dt` to some maximum number.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505552350:36,adapt,adaptive,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505552350,2,"['Adapt', 'adapt']","['Adaptive', 'adaptive']"
Modifiability,"> I hope this description of the workflow is clearer. It's clear!. > I thought the optimal implementation is to append to the previous existing file when using checkpoints. Of course I agree with this. I think our basic principle should be that there is no difference in workflow, either for running or analysis, between scripts for checkpointing or not. Also, I think that `overwrite_existing` should not delete your files if you are picking up from a checkpoint (regardless of what it is set to). Do you agree?. > If I don't change the name each time I pickup, with the overwrite_existing=false it crashes, and with overwrite_existing=true it rewrites all the files. If we have a system that does not overwrite files when picking up from a checkpoint, do you think that it will be necessary to have `overwrite_existing=false` by default? In this case, the only time we risk overwriting files is when we _re-run_ a simulation from the beginning. Assume for the following discussion that the ""overwriting issue"" is solved for checkpointing:. In my experience, I typically set up a script with `overwrite_existing=true` from the very beginning. This is because when we first write a script, we are prototyping. I have never then gone back and changed `overwrite_existing=false` because of some concern about overwriting data. It's inconvenient, in fact, to set `overwrite_existing=false`. My thought is that it makes more sense to ask people to intentionally request `overwrite_existing=false` in the _rare_ case that this is desired. The key insight is that we spend the vast majority of time prototyping. I would even argue from an economic standpoint that the productivity saved from this setting outweights any rare instances of lost data, if they actually would ever occur due to changing the default. Also, even for this purpose I don't really want a ""non-overwriting guarantee"" as a feature. I would prefer something like ""unique_filenames = true"" or something, which I could then ""turn on"" if I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2392162201:645,rewrite,rewrites,645,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2392162201,1,['rewrite'],['rewrites']
Modifiability,"> I made one extra change which is that I don't call `N^2 / S^2` a Richardson number anymore. Since the denominator is a strain rate, not the _vertical_ shear, I think it's odd to call it `Ri`. Also that variable (whatever you call it) only appears 3 times briefly so there's no need to give it a name.; > ; > It appears that our buoyancy modification doesn't really match Pressel's or Lilly's since we use an arbitrary `C_b` while they proposed to use `1/Pr_t`. @glwagner Is there any reference for that?. I don't quite understand the question --- what would you like a reference for?. It looks like for `Cb=0`, the reference is the original Smagorinsky paper, whereas for `Cb=1/Pr` one uses the model proposed by Lilly (1962). A number in between represents something different from either --- are you wondering if there are papers out there that have used `Cb` other than 0 or `1/Pr`? As to that I don't know. We could change the default from `Cb=1` to `Cb=1/Pr` or `Cb=0`... ? The default `Pr` is `Pr=1` but I suppose one might inadvertently change `Pr` but leave `Cb=1` which would lead to a different LES model than proposed by Lilly (1962).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889295372:204,variab,variable,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889295372,1,['variab'],['variable']
Modifiability,"> I mostly do it to keep a consistent size and chunks across files for post-processing. Ok! Curious how this will evolve, we eventually hope to support FieldTimeSeries for NetCDF which will give us some options to design various productivity features...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393589831:114,evolve,evolve,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393589831,1,['evolve'],['evolve']
Modifiability,"> I see your point _but_ I don't think an example in a GitHub repo is the place to introduce notation. I dispute that I'm introducing new notation! Both `=` and approx have unambiguous meaning. Let me elaborate on ""why approx"":. Oceananigans solves the full N-S with nonlinear terms. The script's power method algorithm will fail if the eigenmode to grow too much --- this is a real pitfall of the power method. The purpose of the approx symbol is to concisely illustrate why this can happen. This is crucial to explain for users who want to experiment with the script, change parameters, and adapt it for new problems. We can explain this all in words, but I thought the approx is _visual_ which is helpful. Even just scanning the document you see, this equation involves an _approximation_. The approx is, in fact, a more precise and correct representation of the problem. We can in fact regard the power method algorithm as predicated on a hypothesis (not an exact theory), which we provide empirical evidence for. This is one of the advantages of the power method that uses the full original system, I think, over more brute force approaches that forcefully remove nonlinear terms. It is possible to replace the approx with an `=` and also include all of the nonlinear terms what one would get from the manipulations that lead to the equation for `Phi`. This is precisely what you would do if you were interested in continuing the asymptotic expansion _that linearization implies_ to investigate things like saturation, etc. So there's also a neat pedagogical power in the approx symbol in that it provides a hint for further learning and exploration of the mathematics of the system.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720089701:593,adapt,adapt,593,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720089701,1,['adapt'],['adapt']
Modifiability,"> I share here a double drake experiment that makes full use of this PR; > ; > #### Grid setup; > * latitude longitude grid from 75 S to 75 N; > * 1/3 of a degree in the horizontal (1080 points in longitude, 450 in latitude); > * 150 exponentially stretched vertical levels for a 3km deep ocean; > * double drake bathymetry (https://doi.org/10.1175/2009JCLI3197.1); > ; > #### Top BC:; > * temperature: restoring to reference profile (cosine shape); > * salinity: prescribed latitudinally dependent surface flux; > * zonal velocity: prescribed latitudinally dependent wind stress; > ; > #### Bottom BC:; > * velocities: linear bottom drag with a drag coefficient of 0.003 ms⁻¹; > ; > #### Initial conditions; > * zero velocities; > * exponentially stratified temperature with SST equal to the reference temperature; > * constant salinity; > ; > #### Model setup; > * linear equation of state; > * Richardson-based diffusivity for BL mixing; > * vertical background viscosity and diffusivity of 5e-4 and 3e-5, respectively; > * vector invariant momentum advection with WENO for vorticity and divergence flux as well as vertical transport (no horizontal viscosity); > * WENO for tracer advection (no horizontal diffusivity); > * Split explicit free surface using an averaging shape function and a CFL of 0.7 (23 substeps per time step); > ; > #### Simulation setup; > * time step of 10 minutes; > * ran on 2 MPI processes with CUDA-aware MPI; > * performs about 10 simulated years per day; > ; > On the left, there is the free surface evolution, on the right the surface vertical vorticity (evolved for 9 years). This would be a good setup to add to `ClimaOcean.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431581342:1589,evolve,evolved,1589,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431581342,1,['evolve'],['evolved']
Modifiability,"> I should have addressed all the changes except the `Field{loc...}(grid)` to `Field(loc, grid)`. I will do another PR that will refactor all the instances of `Field(loc, grid)` to `Field{loc...}(grid)`. sounds good",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1437202030:129,refactor,refactor,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1437202030,1,['refactor'],['refactor']
Modifiability,> I suggest we remove the parameter for `gravitational_acceleration`.; > ; > @francispoulin any objection to that?. Please don't remove the parameter. It appears in the model equations and we need it to evolve the momentum equations.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2955#issuecomment-1453388047:203,evolve,evolve,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2955#issuecomment-1453388047,1,['evolve'],['evolve']
Modifiability,"> I think for sophisticated research Checkpointing is common, but for simpler classroom and LES applications the checkpointer is used less. After all, probably the most simulations are actually run in our examples on CI -- and there are no examples with a checkpointer! (It would be nice to change that). Agreed!. > I can't speak for others, but for boundary layer parameterization work the LES typically run in less than 24 hours of wall time. We also only utilize very simple diagnostics, like the horizontally-averaged solution at the final time step. So in those rare cases that we need a checkpointer (I have used a handful of times) barebones checkpointing is sufficient.; > ; > Of course we are currently working on building a OMIP simulation and that will require much longer runs, so we will definitely need more sophisticated checkpointing very soon.; > ; > @simone-silvestri and @tomchor might have more to add. Or @sandreza, what do you use for the neverworld work?. For context, 100% of my simulations have used checkpoints. As far as I know, 100% of the simulations from others in my group also use checkpoints. The only exceptions for my case are very early scripts still in the development phase, and still with very coarse grids. As soon as I try to get more serious with it, I need checkpoints. So this a PR I'm very much looking forward to seeing merged ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305164720:365,parameteriz,parameterization,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305164720,1,['parameteriz'],['parameterization']
Modifiability,> I think it would be better to add an interface for precomputing the boundary conditions and then add a line to `update_state!` that does this. It's more explicit. To do this wouldn't I need to make the boundary condition mutable and adapt it for GPU? That's why I didn't originally go down the route of making the velocity explicitly part of the boundary condition.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1978824869:235,adapt,adapt,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1978824869,1,['adapt'],['adapt']
Modifiability,"> I think it's ok that ""rigid lid"" is implicit. In fact all the sides are rigid and there's no special direction at all.; > ; > In fact, it might make sense to omit ""free surface"" from the hydrostatic model description. We could soon have a rigid lid option there, and then it wouldn't really make sense to continue calling it a ""HydrostaticFreeSurfaceModel"".; > ; > There's a few things I think should go in before 1.0:; > ; > * Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`. Building an abstraction for vectors changes the API because we'll specify boundary conditions on the whole velocity field, not just each component separately. I don't think we should do 1.0 without this.; > * Resolve [Should we store `architecture` in `grid`? #1825](https://github.com/CliMA/Oceananigans.jl/issues/1825) (specifying `architecture` when building `grid`). Another major API change, not to mention a substantial internal refactor.; > * Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere). Another API change because we don't need `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Also simplifies the code a lot.; > ; > It could also make sense to build some experience with immersed boundaries in case there are change motivated by that feature. in my opinion, for v1.0 we should finalize spherical implementations and bathymetry also...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882109635:1013,refactor,refactor,1013,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882109635,1,['refactor'],['refactor']
Modifiability,"> I think see your point (I'm not sure I grasp the totality of it). Is your point that we are able to _re-use_ more existing code if we allow `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction` as `condition`? I didn't understand this previously so thank you for clarifying. Sorry I wasn't clearer before. > To re-use that code with a new `condition`, we can use a nesting technique:; > ; > ```julia; > function getbc(open_bc::OpenBoundaryCondition, ...); > state_value = getbc(open_bc.condition.external_state, ...); > # other stuff related to matching; > end; > ```; > ; > This means that we don't have to rewrite anything, we just add new functionality for open boundary conditions on top. I can see how this could work. As it currently is `getbc` expects a full `BoundaryCondition` so we would need to-do some rewriting of that to unpack like `getbc(bc::BoundaryCondition, ...) = getbc(bc.condition, ...)` and then modify all of the existing `getbc` methods. > On the flip side, the advantage of making a new `OpenCondition` is that `getbc` retains its meaning as ""the function that returns the boundary condition value"". When we have an external state + matching scheme, the boundary condition values are not exactly the external state and are modified by the matching scheme. I see your point. For e.g. gradient boundary conditions it feels like the ""boundary condition value"" being the gradient at the boundary has about as much meaning as the boundary condition value for an open boundary condition being the external state and then we do some matching to get the internal solution to approximate it. But its quite unclear since an open boundary isn't mathematically defined like the other conditions so I think whatever we settle on is really equally as valid. . `getbc` is also not part of the API right? So if in the new code we say `external_value = getbc(...)` it should be clear enough to a future developer how it's being used and we shouldn't need to worry that a user would be",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1991781582:616,rewrite,rewrite,616,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1991781582,1,['rewrite'],['rewrite']
Modifiability,"> I think the expected behavior is that the velocity error in the object scales with the non-hydrostatic pressure gradient times the timestep of the Runge-Kutta substep. Presumably the non-hydrostatic pressure gradient in the object scales as the non-hydrostatic pressure over the length scale of the object. If the strength of the non-hydrostatic pressure field on the object of the boundary is a function of the outer-flow and object configuration, then I don't think grid refinement will help much. Thanks @wenegrat. Sounds like there might be two decent tests to confirm that the algorithm is implemented correctly: 1) run the same problem for 3-5 different time-steps, and confirm that the error reduces with 1/dt and 2) refine the grid and confirm that the error remains constant. > My guess is that the asymmetry is due to an index sweep in the; solver smearing this error ahead of itself. Hmm... the solver uses FFTs. Perhaps @ali-ramadhan can answer, but this might be a question about the internal implementation of the FFT -- not sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738760595:436,config,configuration,436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738760595,1,['config'],['configuration']
Modifiability,"> I think we can achieve this by splitting a kernel like calculate_interior_source_terms! into two kernels, one that computes source terms ""near"" the boundary (1-2? grid points from any boundary as needed), then halo communication can happen while a second more compute-intensive kernel computes the source terms in the rest of the interior. Don't you want the opposite? You want a kernel that computes source terms in the ""deep interior"", which can be performed without knowledge of halos and thus can be performed simultaneous to performing communication. After communication + deep interior calculations are complete, you then perform calculations on near-boundary elements. Are communications restricted to `fill_halo_regions!` and the pressure solve? If so, we can start to prepare for such optimizations by refactoring the time-stepping slightly. This is is the part of our current algorithm that involves interior tendency computation (there are additional halo filling calls associated with the fractional step):. ```julia; function calculate_explicit_substep!(tendencies, velocities, tracers, pressures, diffusivities, model); time_step_precomputations!(diffusivities, pressures, velocities, tracers, model); calculate_tendencies!(tendencies, velocities, tracers, pressures, diffusivities, model); return nothing; end; ```. The function `calculate_tendencies!` calculates interior and boundary contributions to tendencies and does not involve communication. The function `time_step_precomputations!` is. ```julia; function time_step_precomputations!(diffusivities, pressures, velocities, tracers, model). fill_halo_regions!(merge(velocities, tracers), model.boundary_conditions.solution, model.architecture,; model.grid, boundary_condition_function_arguments(model)...). calculate_diffusivities!(diffusivities, model.architecture, model.grid, model.closure, model.buoyancy,; velocities, tracers). fill_halo_regions!(diffusivities, model.boundary_conditions.diffusivities, model.architecture, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/615#issuecomment-583379290:813,refactor,refactoring,813,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/615#issuecomment-583379290,1,['refactor'],['refactoring']
Modifiability,"> I think we should fix this problem first by generalizing the code so that explicit references to grid properties don't appear anywhere (instead we should use functions like all_x_nodes, etc). Changing the name of the grid property can come last (as a purely aesthetic improvement). Interesting consideration. I was gonna take a crack at fixing this in order to expedite my validation of the tilted buoyancy, but I think, given all the talks going on about the grids etc, I'm gonna let that one for you guys to solve. > Ah, I think you using IPython, rather than python, correct? I believe Jupyter notebooks support backslash / latex notation for expressing unicode, but IPython may not. Jupyter uses IPython for it's kernel (by default at least I think), so that ability comes from IPython. In any case, that doesn't work for all unicode characters. Just the ones that python can recognize as valid variable names (which I believe is [every unicode character that represents characters in written languages](https://python-3-for-scientists.readthedocs.io/en/latest/python3_features.html)). So all greek letters can be typed LaTeX style, but subscripts and supercripts can't, along with many other ones that are valid names in Julia. So if nothing is done to ""translate"" these variable names when writing NetCDF files, it's unfortunately going to be hard to deal with Oceananigans output outside of Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799804731:901,variab,variable,901,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799804731,2,['variab'],['variable']
Modifiability,"> I think wrapping `Base.Broadcast.materialize!` in; > ; > https://github.com/CliMA/Oceananigans.jl/blob/6730e6f6b2c8f1695e20b95ef467b5b14fdc4c5f/src/Fields/broadcasting_abstract_fields.jl#L24; > ; > around `@apply_regionally` for multi region fields might do the job. Or we can extend `materialize!(dest::MultiRegionField, ...)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3577#issuecomment-2093438485:279,extend,extend,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3577#issuecomment-2093438485,1,['extend'],['extend']
Modifiability,"> I thought we used the word state since inside the time stepping kernels, state includes the tendencies as well?. Looks like `state` doesn't currently include tendencies. I think this actually makes sense since the tendencies are actually an auxiliary variable. In other words, at the time that a tendency is being calculated, the _current_ value of the tendency is not available (it's being calculated!) Due to that there's probably no advantage to having access to the tendencies in a forcing function or boundary condition function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/985#issuecomment-699500682:253,variab,variable,253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/985#issuecomment-699500682,1,['variab'],['variable']
Modifiability,"> I want to merge this then use it to develop the user API for immersed boundary fluxes.; > ; > Also, did anyone use this?. I haven't used this, but I can test it if you want. > Partly I am wondering whether we may actually need shaved cells for accurate LES computations in complex domains with non-straight immersed boundaries) ... otherwise our boundaries will always have ""effective roughness"", and form drag may dominate. It is actually possible that form drag dominance is ok as a model for rough boundaries. But it'd be nice to have the possibility of ""smooth"" boundaries where fluxes can be controlled via parameterizations.; > ; > It's also interesting that PALM, which uses an almost identical numerical method that we use, is primarily used for atmospheric LES in urban environments. So their boundaries _are mostly flat_ (the sides of buildings, etc...). Shaved cells are definitely preferred in terms of accuracy (and convergence with resolution), but might not be necessary in a number of cases. My intuition from seeing results from papers (and from previous LES+IBM at my previous group) is that partial step cells would be almost as accurate as shaved cells (at least for oceanic cases with mild bathymetry slopes) but significantly simpler to implement. Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?). Also, when running ocean LES the aspect ratios are generally isotropic (Δz/Δx~1) but the bathymetry slopes are very small, which means that for some cases even full-step grid-fitted IBM might be enough. Only some tests will tell for sure though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266:614,parameteriz,parameterizations,614,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266,1,['parameteriz'],['parameterizations']
Modifiability,"> I wasn't specific about time because I wasn't sure. I often find myself spending way longer on PRs than I initially anticipate so I'm generally not very good at assessing these things lol. ok ok! Here's a rule of thumb: a bugfix or refactor is the least committment, because you can get away with no new tests or docs. A new _feature_ takes more time because of documentation. One should expect to spend most of their time on docs and tests. If you're spending a lot of time implementing a feature, then either the feature is very complicated / hard, or your workflow can use some improvement. Among new features, different types of features require different amount of effort. This case is one of the easier cases --- it's extending functionality without changing existing functionality, also its fairly niche (at this point) so simple documentation will suffice. The work required to test the feature also has already been partially completed (the script you posted). Other features, like adding new _physics_ will take much longer, because often you'll have to run a full validation case + analysis to assess whether things work as expected. So even if the source code change is small to implement new physics, the validation will take a while and dominate the development effort. If a new feature also requires changing existing functionality / refactoring, that's going to take the most amount of time, because you will probably also have to change existing tests. And many tests are poorly written, so updating test code is a potential rabbit hole.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2093480258:234,refactor,refactor,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2093480258,3,"['extend', 'refactor']","['extending', 'refactor', 'refactoring']"
Modifiability,"> I would also add a check that the fields are ""full"" fields, aka no `Windowed` fields (with particular indices different from the one we use to launch the kernel) and no `Reduced` fields with lower than 3 dimensions. We want to separate out those fields and treat them differently. We have an implementation like that for `fill_halo_regions!` here; > ; > https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Fields/field_tuples.jl#L54-L78; > ; > What I would probably do actually, instead of a new struct is to extend `compute!` for tuple fields as we do for `fill_halo_regions!` and use your newly implemented kernels for tuples of full fields.; > ; > On the other hand, if defining a new type is useful for OutputWriters I am ok with it. The new commit follows the suggestion of overloading the `compute!` method to apply it on a tuple of `ComputedField`. I also added a check to make sure that all these fields are `FullField`. However, I wonder whether we should throw an error when any of these fields is not a ""full field"" or we should follow the implementation of `fill_halo_regions!` to fill these regions using different methods?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694253036:550,extend,extend,550,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694253036,1,['extend'],['extend']
Modifiability,"> I'd love to hear feedback about this design.; ; Maybe I'm personally quite picky about specifying outputs and output file names, so I might always end up with verbose boilerplate for output writing (and I'm personally fine with that). But I'd support reducing boilerplate and maybe just a bit of flexibility would work even for picky people! I remember having this conversation in #1171 actually!. One-line flexible output writing would be especially great for examples, new user friendliness, and quick iteration. Some thoughts:; 1. I think the name `output!` is a bit vague in what it does. Does it just output the current state of the simulation? Would `add_output_writers!` be clearer and align more closely with existing Oceananigans nomenclature? For the same reason, I'd suggest keeping `add_callback!` over renaming to `callback!`.; 2. I frequently output both JLD2 and NetCDF versions of the exact same data. So ideally subsequent calls to `add_output_writers!` with `JLD2Format()` and `NetCDFFormat()` would add both.; 3. Would definitely support extending this to NetCDF as well!. > First, we need to default `with_halos=true` for JLD2OutputWriter. The time has come because `FieldTimeSeries` is mature. We do, in fact, want halos. Sounds good! Will be nice for derivatives to work by default. Although `FieldTimeSeries` could do with a bit more maturing, e.g. issues #3144 and #3750. > The other conundrum is `overwrite_existing` which is discussed on #3543. In short I am wondering whether the best course of action is simply to make default `overwrite_existing=true` and solve so much boilerplate. Is the ""so much boilerplate"" just the extra one line `overwrite_existing = true` for each output writer? Maybe I'm too conservative here but I think the default should be `overwrite_existing = false` just because the cost of overwriting and losing data can be very high. But I really like the suggestions in #3543 of having the option to save output in unique directories be easily speci",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875:409,flexible,flexible,409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875,1,['flexible'],['flexible']
Modifiability,"> I'm a little worried about the increase in size of the already-quite-large time_step! function, but otherwise as far as I can tell things look ok. I agree and at some point in this PR I switched to using broadcasts for the permutations which gets rid of all the `idct_permute!` kernels and keeps one `calculate_pressure_source_term` kernel, but I couldn't get it to perform well on the GPU so I scrapped it. Worth revisiting... > One question: is it the name of the field that needs to be known for halo regions, or the type (FaceFieldZ, FaceFieldX, etc). If its the type, then this suggests two improvements:. Yeah it's kind of hacked together for now. When you want to fill halo regions you feed in a tuple like `(:u, bcs, u_data)` which fills the halos of `u_data` assuming it's a u-velocity field with boundary conditions `bcs`. It kind of crap because for pressure halos I fill them like I would fill in the w-velocity field. This makes the code confusing I think. Might be good to attach boundary conditions to each field, so that all fields get assigned boundary conditions, not just `u, v, w, T, S`. Would be great if we can can adapt fields to work well on GPUs. I think last time we tried we couldn't get them to perform for some reason. One of our oldest issues: https://github.com/climate-machine/Oceananigans.jl/issues/13",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/290#issuecomment-506899367:1139,adapt,adapt,1139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/290#issuecomment-506899367,1,['adapt'],['adapt']
Modifiability,"> I'm assuming this is a relatively simple issue to resolve?. Unfortunately not due to our current algorithm that we inherited from MITgcm, but which we hope to change pretty soon. Right now Oceananigans splits up the pressure into the hydrostatic pressure anomaly and the non-hydrostatic pressure (see https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/pressure_decomposition/). MITgcm did this to facilitate easy switching between a hydrostatic mode and a non-hydrostatic mode: to turn a non-hydrostatic model into a hydrostatic one, just don't compute the non-hydrostatic pressure and recompute w from the continuity equation. But we feel we can use multiple dispatch to implement a hydrostatic model in Julia. This algorithm also requires extra memory (2 pressure fields instead of just 1). So we're hoping to change the algorithm to only use 1 pressure field and get rid of this pressure decomposition. The algorithm also makes it difficult to implement tilted gravity because the hydrostatic pressure anomaly is computed as. ```; pHY′ = ∫ buoyancy_perturbation dz from z=0 down to z=-Lz; ```. where `buoyancy_perturbation = g * (αT - βS)` if you're using a linear equation of state. So now if gravity is tilted it's not just a vertical integral. I'm actually not sure how to modify the vertical integral if gravity is tilted... Seemed easier to move away from this vertical integral by not decomposing pressure then we should be able to easily add in support for tilted gravity via a `bg⃗` term in the momentum equation where `g⃗ = g⃗(x, y, z)` can be whatever the user wants. Not sure if we have an issue discussing this change to the pressure decomposition, but if it doesn't exist then I can open one to track progress on it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1151#issuecomment-732369605:117,inherit,inherited,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1151#issuecomment-732369605,1,['inherit'],['inherited']
Modifiability,"> I'm confused as to what T would be here. It feels like it should be simulation.Δt, but that wouldn't work for variable Δt. The time interval that user specifies, `TimeInterval(T)`. > We probably would need to discuss how that would interact with min_Δt from the TimeStepWizard, no?. I hadn't thought of that. But `min_Δt` is not a global constraint, it's only the `min_Δt` that the TimeStepWizard specifies. The simulation `Δt` can still be smaller.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104627707:112,variab,variable,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104627707,1,['variab'],['variable']
Modifiability,"> I'm not sure I exactly understand whats changed here because of all the renaming. The important changes are here right?; > ; > https://github.com/CliMA/Oceananigans.jl/blob/7cc97812d42982b2c8bd5635b40f807e800b2472/src/Utils/kernel_launching.jl#L120-L158; > ; > And this makes it so that instead of being able to optionally fill the right boundary point, you can set it to `true` and it will instead compute 2:N for face fields (and presumably still 1:N for center fields)?. Heh, I'd argue that without the renaming it would also be hard (harder) to understand! Especially for me... The outcome of this PR is a key change to the computation of nonhydrostatic tendencies, here:. https://github.com/CliMA/Oceananigans.jl/blob/7cc97812d42982b2c8bd5635b40f807e800b2472/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl#L104-L115. In addition to that, we do not update the periphery regardless:. https://github.com/CliMA/Oceananigans.jl/blob/7cc97812d42982b2c8bd5635b40f807e800b2472/src/TimeSteppers/runge_kutta_3.jl#L172. The keyword `exclude_periphery` propagates into `work_layout` as noticed. When we use the `:xyz` specification, ask for `exclude_periphery`, and the location is `Face` and the topology is `Bounded`, then the kernel is configured to loop from 2:N. Otherwise, it loops from 1:N as usual. Hope that helps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2393866646:1256,config,configured,1256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2393866646,1,['config'],['configured']
Modifiability,"> I'm not sure I follow then. Are you saying that you're not sure all the versions in this range are bug-free? That being the case it's best to pin it to a version we know is safe?; > […](#); > On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***> wrote: ***@***.**** commented on this pull request. ------------------------------ In Project.toml <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)> : > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc"" [compat] Adapt = ""^3"" -CUDA = ""3"" +CUDA = ""3.0.0 - 3.3.6"" Note that Manifest.toml pins a specific version. Right, that's why I figured making it specific was the safest option. — You are receiving this because you were mentioned. Reply to this email directly, view it on GitHub <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ> . Triage notifications on the go with GitHub Mobile for iOS <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> or Android <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>. Oh, I just can't remember how far back we're able to go. But if you've gone to the effort to test a whole range of versions then certainly we might as well use a range, since it has the benefits you mentioned! My thought was just that it'd be quick and simple to pin to the version in the Manifest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502:524,Adapt,Adapt,524,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502,1,['Adapt'],['Adapt']
Modifiability,"> I'm not sure if Oceananigans explicitly models bathymetry by adding a pressure gradient, and whether we would be double counting the effects of bathymetry using the equations I shared above. `ShallowWaterModel` is totally independent from the other models --- so this is up to how `ShallowWaterModel` is written. But in a shallow water system it seems (based on the discussion on this thread) that bathymetry is treated via pressure gradients (and also vanishing layers or other techniques to handle outcropping). So we won't use `ImmersedBoundaryGrid`, which is how complex domains are handled elsewhere in Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117376977:465,layers,layers,465,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117376977,1,['layers'],['layers']
Modifiability,"> I'm still wondering about this solution, which may both be _more general_ (since users can effect arbitrary changes to tracer tendencies, not just source/sink terms) and is less heavy in the source code. Right now, this PR makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can. I've reconsidered this now and think we may not even need any source code change to properly implement this behaviour and integrate some particle induced tracer forcing. If we have a model with some tracers `(:A, :B)` which we want to force with some particles, we can define an auxiliary field `G\_p=TracerFields((:A, :B), grid)`. We can then have a particle dynamics function that modifies `model.auxiliary_fields.G\_p`, for example sets the points surrounding the particles to `-A[i, j, k]` for `A`, and `+A[i, j, k]` for `B` like in my example above. You can then define a discrete forcing function for each of the tracers like `a_forcing(i, j, k, grid, clock, model_fields) = model_fields.G\_p.A[i, j, k]` etc. (this would only work with my other PR #2733 added so that the `auxiliary_fields` are available). > It seems the memory requirement of the forcing function approach is proportional to the number of tracers, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. My reservation with this was that if there's e.g. 1 particle effecting loads of tracers you have to store lots mor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312:514,flexible,flexible,514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312,1,['flexible'],['flexible']
Modifiability,"> I'm thinking about updating `benchmarks.md` with the new benchmark result tables and graphs. Should I do it now or wait until the docs get refactored?; > It's only a single file in the appendix section, but I'm not too sure how me opening a PR on it now to update it will affect the grander refactoring plan. As @glwagner said, this refactoring is a long term plan. I think running new benchmarks now will definitely be a positive change and (imo) a great contribution to the docs ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880742532:141,refactor,refactored,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880742532,3,['refactor'],"['refactored', 'refactoring']"
Modifiability,"> I've also offered to help configure testing on our systems, if someone wants to provide what is needed to integrate with slurm. https://github.com/CliMA/slurm-buildkite is what is being used IIUC. . Oceananigans doesn't use this afaik, but instead just uses runners on a private compute node.; Looks like me, @glwagner or @charleskawczynski have the right priviliges to create an agent token.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328798736:28,config,configure,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328798736,1,['config'],['configure']
Modifiability,"> If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp. From my tests I think this optimization can shave off 10% of time on the CPU and 25% on the GPU. This isn't bad, but I anticipate launching `Forcing` only where necessary would shave of much more in the situations I mentioned. Although when I originally posted the issue I thought it could be directly implemented in `Forcing`, but you make a good point that it can't, so it might not be worth the effort (at least not right now). I'll close this for now but feel free to re-open it if you think it's worth discussing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092:178,layers,layers,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092,1,['layers'],['layers']
Modifiability,"> If we take a look at those other kernels, maybe we can get to the bottom of it?. Actually now that I'm checking my scripts, I have always differentiated arguments passed as a `computed_dependency`. I hadn't paid attention to this before but I've never differentiated a variable that I created _inside_ the kernel, as is the case with `wp`. Apparently this is yet another limitation of GPU computing that I wasn't aware of. For my application this already solves the issue, as I can just define a vertical derivative kernel and pass the abstract operation `w*p`. But for the sake of the general user: is there any way around this limitation?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786715346:271,variab,variable,271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786715346,1,['variab'],['variable']
Modifiability,"> Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the Distributed module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). I think (but am not 100% sure) that PencilArrays is tied to MPI. So I guess for 1 we are either ""borrowing"" (but not using directly) the transpose algorithm from PencilArrays, or we are extending the code so that it works ""without MPI"" -- and also with GPUs, which is work in progress: https://github.com/jipolanco/PencilFFTs.jl/pull/37. Another reason to focus on 2 is that we can use PencilFFTs for _distributed_ (but _not_ `MultiRegion`) nonhydrostatic model. So even if PencilFFTs had support for CuArray now (and if `Distributed` were performant for multi GPU --- both of which may not be too close), using cufftxt could still _potentially_ be motivated by performance reasons. In other words, if we develop a capability with cufftxt, then in the future we can also support multi GPU via PencilFFT and `Distributed`, and we have two options (one perhaps performant on single node, multi GPU, and another to use when you need GPUs spread across multiple nodes).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852:857,extend,extending,857,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852,1,['extend'],['extending']
Modifiability,"> In line 39, where I define the background buoyancy of the jet, I can't use coriolis.f because CUDA seems to need a global variable and this doesn't cut it. This isn't a GPU issue I don't think because initialization is done on the CPU. I don't see a `coriolis` object defined in your script. You may need to write `model.coriolis.f`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815045759:124,variab,variable,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815045759,1,['variab'],['variable']
Modifiability,"> In python the convention is to put import statements at the top of a file? So the python convention is not to have local import statements. Since every file is a module, this means that in python import statements are at the top of modules by convention.; > ; > In julia modules can be split among many files. Thus if imports are at the top of a file, they are scattered within the module. I meant ""more local"" so putting `import` and `using` statements at the top of each file. I think putting them at the module level makes module files messy/cluttered and actually makes it harder to see where and how imported functions are used and overloaded. > One reason to put things at the top level is so that its easy to see at a glance what a package imports. It's also nice to see what methods are being extended via implication; for example if one sees `import Base: +` we can expect that `+` is redefined. If I want to check what a package imports, I will check the `Project.toml`. I think it's very rare for me to check ""what a module imports"". The much more common case in my experience is I'm looking at a file and see an unfamiliar function so I scroll to the top to see where it was imported from. If the `import` statement is in the module file, then I have to scroll through a screenful of import statements in another file in search of the relevant line. > What is the problem that this change would solve? If one is reading code in a file, and an unfamiliar function appears, one presumably looks to the top-level to see where it is imported. If one is reading a module, why is it crucial to know where in the code the package is used?. It solves two problems: messy module files, and makes it easier to understand where import statements are used. Maybe we do things differently, but I always scroll to the top of the current file to look for import statements. I've never thought to look the module top-level file. Additionally, a list of import statements at the top of the file tell me w",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-547225547:803,extend,extended,803,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-547225547,1,['extend'],['extended']
Modifiability,"> In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it. Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873552345:41,evolve,evolve,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873552345,1,['evolve'],['evolve']
Modifiability,"> In the paper you mentioned, equation 33 is the at the core where the nonlinear Coriolis term is rewritten using WENO schemes to rewrite `\omega U_\perp` using WENO. Is this what is the part that is done differently where the velocity is used?. That's right. The ""nonlinear Coriolis term"" in the vector invariant advection scheme requires reconstructing the vorticity at the locations of the x- and y-momentum. This PR implements WENO reconstruction of this term with two possibilities for the smoothness calculation: `VorticityStencil()` ([Roullet and Gaillard](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2021MS002663)) and `VelocityStencil()` (uses velocity rather than vorticity to calculate smoothness coefficients, implemented in this PR). The API is probably WIP; hopefully we will smooth this out. Anyways, this scheme can be used by writing. ```julia; using Oceananigans.Advection: VelocityStencil, VorticityStencil. # and then. momentum_advection = WENO5(vector_invariant=VelocityStencil()); ```. for example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081940086:130,rewrite,rewrite,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081940086,1,['rewrite'],['rewrite']
Modifiability,"> Indeed, the boundary conditions for `U` and `V` should be the integral of boundaries for `u` and `v`. I am unsure about the boundaries for `η`; I think `η` is typically prescribed outside the domain in regional simulations, but we probably need to find a reference for that. For reference, I think ROMS currently uses the algorithm described [here](https://www.sciencedirect.com/science/article/abs/pii/S146350031000082X?via%3Dihub). I haven't read it carefully, but it seems to project both `U` and `η` to a common point outside of the domain, calculate a variable that depends on both quantities (Eq. (2)), and specify the BCs for both based on that. (Likewise for `V`.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353455930:559,variab,variable,559,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353455930,1,['variab'],['variable']
Modifiability,"> Is it worth to rotate x- and y-stretched grids so that the stretching is in the `z` direction and then use the tridiagonal solver behind the scenes? I have no idea how slow something like that would be on a GPU. I think it might be more fruitful to generalize `BatchedTridiagonalSolver`. It's a little annoying (our fault for using `i, j, k` rather than `CartesianIndex`...) --- but we can probably figure out how to rotate indices in https://github.com/CliMA/Oceananigans.jl/blob/a314f1f64e80181ecff84d6bab1e5182644d95cc/src/Solvers/batched_tridiagonal_solver.jl#L91. Not a small refactor, so I'd argue not priority 1 right now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023499655:583,refactor,refactor,583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023499655,1,['refactor'],['refactor']
Modifiability,"> Is the PR on KA very crucial?; > ; > Would it be a lot of refactoring to have this merged atm with a tagged KA version? This way we don't need to wait for KA?. I would wait for KA to merge (we do not want to depend on a branch). . On the other hand, I would prefer not to wait for KA to have this PR ready to merge so we can merge the two PRs in rapid succession and not take time to refactor/review this one later (it would be better to merge this by July 15th and I think it has some major changes we want to discuss before). In the end the KA PR just handles how offsets are used in indexing kernels. I don't think that API will change even when changing the internals, and even if it does, it is just a matter of changing one function (`launch!` in `src/Utils/kernel_launching!`) to reflect the API changes",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1611315191:60,refactor,refactoring,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1611315191,2,['refactor'],"['refactor', 'refactoring']"
Modifiability,"> Is the PR on KA very crucial?; > ; > Would it be a lot of refactoring to have this merged atm with a tagged KA version? This way we don't need to wait for KA?. Sorry, I misunderstood. Yeah, it would be indeed a bit of refactoring.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1611394008:60,refactor,refactoring,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1611394008,2,['refactor'],['refactoring']
Modifiability,"> Is the vertical velocity generated over the piecewise constant topogrpahy something that is of a concern? When I increased the resolution I believe I saw the vertical velocity generated increased as well. I agree with @glwagner that it's concerning at least for your current configuration. My guess is that with bottom drag and a more turbulent simulation that might not be a huge problem. But as it stands it's definitely affecting the dynamics. (Btw, I say that because I've run a fair amount of turbulent simulations with immersed boundaries at this point and I've never seen this being an issue in my simulations. But they are always turbulent.). > I think so! Is this with GridFittedBottom or PartialCellBottom? I feel like this motivated cut / shaved cells. @glwagner reading the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take1.jl) it seems that it's a `GridFittedBottom`. @francispoulin Like Greg mentioned, shaved cells would be ideal here, but since we don't have that yet, I'd suggest trying out the `PartialCellBottom`. I expect some improvement there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028920617:277,config,configuration,277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028920617,1,['config'],['configuration']
Modifiability,"> Is there a way to test x_f_cross_U et al?. Yes: construct a model with the given feature and then perform a time-step. I guess ideally we would form a giant matrix representing all possible model configurations and time-step them all once. This would be expensive. Maybe we should just loop over each physics specification individually and cross our fingers that there's no bad interactions (I can already tell this would be naive, for example, when a turbulence closure depends on buoyancy).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/616#issuecomment-583371090:198,config,configurations,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/616#issuecomment-583371090,1,['config'],['configurations']
Modifiability,> Is there any other model that may be impacted from this?. As mentioned in a DM I don't think `HydrostaticFreeSurfaceModel` supports vertically-flat configurations; even with one grid point in the vertical we may need vertically `Bounded`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2093#issuecomment-985522014:150,config,configurations,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2093#issuecomment-985522014,1,['config'],['configurations']
Modifiability,"> Is this still an issue?. Apparently not anymore. I just tested @navidcy 's MWE are everything seems to work fine (on a Quadro GPU and CUDA 3.12 on `main`):. ```julia; julia> grid; 150×150×12 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=5.00e+01, max(h)=5.00e+01); ├── underlying_grid: 150×150×12 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-200.0, 200.0) regularly spaced with Δx=2.66667; ├── Periodic y ∈ [-200.0, 200.0) regularly spaced with Δy=2.66667; └── Bounded z ∈ [0.0, 100.0] variably spaced with min(Δz)=8.33333, max(Δz)=8.33333. julia> maximum(abs, u); 0.0. julia> maximum(abs, w); 0.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1319159807:625,variab,variably,625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1319159807,1,['variab'],['variably']
Modifiability,"> It is also of course possible to simply write a function that calculates the eddy viscosity, and call this function repeatedly to avoid temporaries altogether. Don't know if it's always possible but if we can avoid temporary variables by aggressively inlining all calculations, that would be cool. Every temporary field saved means being able to run a larger model on GPUs. We will always need a couple of temporary arrays so if we can't inline we can just try to share and reuse the temporary arrays as much as possible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-468751396:227,variab,variables,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-468751396,1,['variab'],['variables']
Modifiability,"> It may become common if users do realistic GCM stuff, because there will be many turbulence closures, but only *one* of them would require explicit boundary-diffusivity modeling to control field gradients and diffusivities along boundaries (for example, prescribing some interesting lateral diffusivity parameterization on top of a vertical mixing parameterization). Ah interesting I didn't think of such cases. I believe we can set up arbitrarily complicated boundary conditions so anything is possible. It's just hard and probably unfeasible/undesirable to extend the user interface to handle all these cases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589850223:305,parameteriz,parameterization,305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589850223,3,"['extend', 'parameteriz']","['extend', 'parameterization']"
Modifiability,"> It might make sense to follow @simone-silvestri's suggestion and include all fields in `field_dependencies`. That would open up more options for forcing in general, esp using `auxiliary_fields`. Just to make sure I understand correctly: you're talking about expanding the use of the already-existing keyword argument `field_dependencies` to include not only prognostic fields (which apparently is the current status), but all fields. If that's correct, I don't see why not. It'd make the code more flexible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225895785:500,flexible,flexible,500,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225895785,1,['flexible'],['flexible']
Modifiability,"> It would require a lot more refactoring though... but now's the time I guess. I think explicit is better. Why do we need to refactor? Why don't we just specify a default topology in the grid constructor? Then, the only refactoring we need to do is for models in the channel domain.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/614#issuecomment-581891251:30,refactor,refactoring,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/614#issuecomment-581891251,3,['refactor'],"['refactor', 'refactoring']"
Modifiability,"> It's a significant refactor to remove hydrostatic pressure --- I don't think we want to do the hacky thing that we did to set up that PR that just keeps the same structures but sets pressure to `nothing`, we want to do it properly and update the docs. Agreed. https://github.com/CliMA/Oceananigans.jl/pull/3080 is for now just a start to see if anything significant breaks. So far everything looks OK there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518198862:21,refactor,refactor,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518198862,1,['refactor'],['refactor']
Modifiability,"> It's something to do with GPU, maybe GPU reductions?; > ; > ```; > [2023/05/24 21:41:15.102] INFO Testing grid utils on variably spaced grid....; > --; >   | Grid initialization: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_grids.jl:199; >   | Expression: minimum_xspacing(grid) ≈ FT(π / 3); >   | Evaluated: 0.0 ≈ 1.0471975511965976; > ```. I see this error. But I can't reproduce it. On tartarus it's not happening and I don't have access to Svedrup. So I don't know what to do... :(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566845080:122,variab,variably,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566845080,1,['variab'],['variably']
Modifiability,"> Its ok for there to be a divergence in the slip velocity. In the case of the ocean surface or seafloor that's exactly what you want since the particles will then accumulate at those surfaces depending on whether they are light or dense. Tracer is conserved in an integrated sense since the flux through the boundary vanishes. In some cases the user might want a flux across the boundary, e.g. for dense particles sinking through an open boundary at the bottom of the domain, so we probably want the profile of the slip velocity in the user's control. Also, note that for very buoyant tracers there will be numerical issues if the tracer all accumulates at the surface. Finer grid spacing can help a bit, but I think this is a drawback to using buoyant tracers and particles work better in those cases (Jenny discusses this in her draft paper on microplastics which is under review). That makes physical sense!. I believe supporting divergent slip velocities means we cannot use the ""flux form"" of the advection term, ie we cannot rewrite. ```; u_slip ⋅ ∇c = ∇ ⋅ (u_slip c); ```. correct? This means that we cannot use native Oceananigans operators for this advection term, since the operators we've implemented all assume that the advecting velocity field is non-divergent. This is not much of an issue since we can easily write a second-order discretization of `u_slip ⋅ ∇c`. In addition, we can support a flag in which users might optionally declare the velocity field as non-divergent, in which case we can use higher-order discretizations of `∇ ⋅ (u_slip c)`. Perhaps `SlipVelocity` is a better name than `AdvectiveForcing` since it parallels the literature?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082424860:1032,rewrite,rewrite,1032,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082424860,1,['rewrite'],['rewrite']
Modifiability,"> Just to clarify a point here. The background field here does not participate in the hydrostatic pressure, it only adds an advective term to the tracer equation which reads ∇⋅(uB). So in practice, you are solving; > ; > ∂tu+(u⋅∇)u=−∇p+g^b+Di(u) ∂tb+∇⋅(ub)+∇⋅(uB)=Di(b)+Di(B) where Di is the implicit diffusion coming from 5th order upwind. Yup, and just to clarify the physics behind this set-up, it is necessary when simulating things like doubly-periodic tilted boundary layers in a stratified environment (such as our [tilted bottom example](https://clima.github.io/OceananigansDocumentation/stable/generated/tilted_bottom_boundary_layer/)). @simone-silvestri not to sidetrack from the issue but isn't $\mathcal D_i(B)$ ignored in the evolution equation? I got that impression from reading the docs [here](https://clima.github.io/OceananigansDocumentation/stable/model_setup/background_fields/) and [here](https://clima.github.io/OceananigansDocumentation/stable/physics/nonhydrostatic_model/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1490474866:474,layers,layers,474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1490474866,1,['layers'],['layers']
Modifiability,"> Looks like a good interface to me.; > ; > But is it on purpose that there is only support for background fields in the `NonhydrostaticModel` and not for the `HydrostaticFreeSurfaceModel`?; > ; > @liuchihl will test it in our configurations. Well yes, it's substantial effort to support background fields. So we implemented it in the nonhydrostatic model first. Nobody has requested having background fields for the hydrostatic model. It's not impossible but might require some thinking if it's going to work with the more complicated turbulence closures (like CATKE or k-epsilon) that sometimes get used for hydrostatic applications. Since the nonhydrostatic model is fast (at least on one GPU) the hydrostatic model is mostly important for simulations on the sphere (although this statement needs to be evaluated more carefully for complex domains when we have a proper nonhydrostatic solver).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2206898460:227,config,configurations,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2206898460,1,['config'],['configurations']
Modifiability,"> Looks like me, @glwagner or @charleskawczynski have the right privileges to create an agent token. I'm happy to help, but @glwagner is probably more familiar with the Oceananigans configuration.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328997644:182,config,configuration,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328997644,1,['config'],['configuration']
Modifiability,"> Luckily, I found a reliable way to get NaNs immediately is to set both reltol and abstol to zero and maxiter to more than a thousand. The purpose is to test the numerical stability of the iteration method. I think this makes sense. When the residual is reduced to near machine precision then I think this is when the present instability is exposed, which occurs when the search direction is essentially a constant. I wonder if its possible that the instability was observed in the original simulations when, for some random reason of the flow configuration, the CG solution converged especially fast (thereby exposing the instability).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2420734546:545,config,configuration,545,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2420734546,1,['config'],['configuration']
Modifiability,"> May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it. As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field. If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component. Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924962650:794,parameteriz,parameterization,794,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924962650,1,['parameteriz'],['parameterization']
Modifiability,> Maybe compute_w_from_continuity! is missing a datatuple or something is missing from an adapted struct?. But it's only with the `RegularLatitudeLongitudeGrid` -- a model with `RegularRectilinearGrid` passes. 🤔,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1449#issuecomment-796257534:90,adapt,adapted,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1449#issuecomment-796257534,1,['adapt'],['adapted']
Modifiability,> Maybe it did need some of the overwrite existing because it writes different configurations to the same file; > ; > Update: passes locally if I add them back. hmm ok that's ok. Could also just manually delete the existing files which might save future pain / confusion,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1570923051:79,config,configurations,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1570923051,1,['config'],['configurations']
Modifiability,"> More out of interest, is there a benefit to passing variables explicitly?. Is this question about CUDA.jl behavior? I'm afraid I don't know, but this comment might help:. https://github.com/CliMA/Oceananigans.jl/pull/746#issuecomment-653428852. It could be worth asking on #gpu slack, or on https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1238525107:54,variab,variables,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1238525107,1,['variab'],['variables']
Modifiability,"> Multiple forcing is tested but all the forcing tests just check that they don't error, so I expect in this situation the advective forcing would have no effect but wouldn't error.; > ; > Perhaps all of the forcing tests should really have something checking that they are changed, the forcing a could all just be set to return 1 and then we check that all of the tracers that are forced are not zero at the end?. Mm yeah I can extend the existing test to pass only if the tracer distribution changes after that time-step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234:429,extend,extend,429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234,1,['extend'],['extend']
Modifiability,"> My end goal here is to recreate the set-up in [this paper](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/frontogenesis-and-frontal-arrest-of-a-dense-filament-in-the-oceanic-surface-boundary-layer/2FFBE4503C590CE7BDB1B8BAA236C387) and see if I can see some submesoscale activity. This is just a proof (or disproof I guess) of concept, so I'm aiming for a coarser resolution and other simplifications. Any tips are greatly appreciated. If you're mostly interested in the oceanic boundary layer and don't need topography or a free surface, then Oceananigans probably has most of what you need. (See #443 if you're interested in surface physics.). 8192×3072×256 ~ 10¹⁰ grid points is out of our reach for the moment although our plan is to be able to run these super large simulations one day!. We're still limited to 1 GPU (with 16 or 32GB RAM) which lets us go up to ~5×10⁷ grid point. We could probably extend that to ~10⁸ grid points if we implement #98 but even then it would take 50-100 GPUs to reach 10¹⁰ grid points. We've mostly been running oceanic mixed layer simulations with a focus on vertical mixing so no need for a ton of horizontal resolution, but we do have horizontal mixing problems in mind at which point we'll need to start running on multiple GPUs with MPI. This is something we're starting to get serious about as we do need it ourselves. Not sure how coarse you can go but if you can go down to ~10⁸ grid points then maybe Oceananigans can be useful. If the factor of ~2 reduction in memory usage from #98 would be useful for you, let us know and we can look into implementing it. In general, I think we're happy to work together on features that you might need. I still need to work on some documentation to showcase all the model creation options, etc. so let us know if you're not sure how to impose a certain boundary condition or forcing, etc. Out of curiosity, what LES model are you currently using?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539743886:933,extend,extend,933,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539743886,1,['extend'],['extend']
Modifiability,"> My fear is that making things less standardized (i.e. adding more possibilities), it'll be harder to spot these mistakes. It will mean that `set!` becomes more specific; ie two-dimensional set functions can only be applied to two-dimensional variables. I think there are more _possibilities_ for bugs if three-dimensional functions can be applied to two-dimensional variables. For example, you might accidentally assign the wrong initial condition to a variable. When half the variables are 2D and half are 3D, you have the possibility that a typo throws an error. We can add some `try catch` statements to throw helpful errors within `set!` when we encounter a `MethodError`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777716631:244,variab,variables,244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777716631,4,['variab'],"['variable', 'variables']"
Modifiability,"> Not _exactly_ sure why it was [1][3], but if `u_init` was an active variable at one point then we we would want to get its derivative which is there. Hm ok got it, it depends on the status of what's returned",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438850544:70,variab,variable,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438850544,1,['variab'],['variable']
Modifiability,"> Not sure how much code overlaps between the two, but if both are deemed important enough to maintain, then the shared functionality can go into amd_core.jl or something. I considered this when I started developing the Verstappen closure. Almost none of the code is shared, which is why there are two files, unlike the Smagorinsky closures which have a lot of shared code. In principle it might be possible to refactor both implementations to share (a bit) more code but that would be a lot of work, and would also probably make both implementations more complex...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526200161:411,refactor,refactor,411,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526200161,1,['refactor'],['refactor']
Modifiability,"> OK! I'll review this!; > ; > so in Oceananigans terms is the `e-ϵ` parameterization, right?. I think we should call it ""TKE dissipation vertical diffusivity"", or k-epsilon in a nod to the literature. I don't think we shoudl call it ""e-epsilon"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3605#issuecomment-2164357889:69,parameteriz,parameterization,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3605#issuecomment-2164357889,1,['parameteriz'],['parameterization']
Modifiability,"> OK, perhaps I'm a bit oblivious to physics of tilted gravity etc. Are is the tilted gravity crucially important for this to occur?. Apparently yes. This doesn't happen when the buoyancy acceleration is aligned with the model's z-coordinate. > Also, is there an energy integral associated with these dynamics when there is a fixed imposed buoyancy? Even in the continuous case, before we go to discrete world, is there guarantee that E should decrease?. That's a good point and as far as I can tell this system should have a a finite, non-increasing total energy since the background buoyancy is stable. So the background buoyancy shouldn't be introducing any extra energy reservoirs (unlike, for example, an Eady set-up, which constantly injects energy into the system by imposing a horizontal buoyancy gradient). My understanding of this comes mainly from [Umlauf et al (2015)](https://journals.ametsoc.org/configurable/content/journals$002fphoc$002f45$002f12$002fjpo-d-15-0041.1.xml?t:ac=journals%24002fphoc%24002f45%24002f12%24002fjpo-d-15-0041.1.xml). Their equation (24) applied to the set-up above (i.e. without any boundary stresses and without applying a Reynolds decomposition) reads. ```math; \frac{d}{dt}\int_V \left[ \frac{u_i u_i}{2} + \frac{b^2}{2N^2} \right] dV = ; - \int_V \left[ ; \kappa \frac{\partial_j b \partial_j b}{N^2} ; + \nu {\partial_j u_i \partial_j u_i}; \right] dV \le 0; ```. Also it's worth noting that even in a `(Bounded, Flat, Bounded)` domain I still get an energy buildup, although in this case the KE stops growing after a while:. https://user-images.githubusercontent.com/13205162/228590310-51b59910-2550-48c9-93a7-f22d70c2474e.mp4. I say that because this may be a more familiar set-up and because sometimes a tilted, periodic domain might introduce some unexpected effects.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1488852882:910,config,configurable,910,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1488852882,1,['config'],['configurable']
Modifiability,"> Ok I fixed that. Probably we should use a Field rather than ones for the test and examples, because it automatically adapts to GPU, distributed, etc, so it's a bit better. But I thought the whole idea is to be able to provide an `Array` for forcing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1987930274:119,adapt,adapts,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1987930274,1,['adapt'],['adapts']
Modifiability,"> Ok I think I figured it out. The `Float64` values are coming in from functions like `depthᶜᶜᶠ` and `height_above_bottomᶜᶜᶠ`. The main issue is actually the grid coordinates not being fully `Float32`.; > ; > In particular, when coordinates like `grid.zᵃᵃᶜ` are ranges the reference and step size are `Float64`:; > ; > ```julia; > julia> r = range(0.0f0, 1.0f0, 16); > 0.0f0:0.06666667f0:1.0f0; > ; > julia> typeof(r); > StepRangeLen{Float32, Float64, Float64, Int64}; > ```. Can you clarify? You're showing the type of `r`, but not the type of the coordinate that would be produced by indexing into the range, which is what we care about. The docstring specifically says . ```julia; help?> StepRangeLen; search: StepRangeLen StepRange. StepRangeLen( ref::R, step::S, len, [offset=1]) where { R,S}; StepRangeLen{T,R,S}( ref::R, step::S, len, [offset=1]) where {T,R,S}; StepRangeLen{T,R,S,L}(ref::R, step::S, len, [offset=1]) where {T,R,S,L}. A range r where r[i] produces values of type T (in the first form, T is deduced automatically), parameterized by a reference; value, a step, and the length.; ```. Therefore `StepRangeLen{Float32, Float64, Float64}` should produce values of `Float32`. Is this not happening?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445639713:1038,parameteriz,parameterized,1038,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445639713,1,['parameteriz'],['parameterized']
Modifiability,"> Ok, here's a multi-pronged strategy to address this:; > ; > 1. Rather than computing the next time step directly based on the schedules, compute the nearest _action time_ (either output or callback or the simulation is stopping). Then compute the time-step like we have been and as suggested by @tomchor for RK3, by taking the differences between the next action time and the current time.; > ; > 2. Change `TimeInterval` so that, rather than accumulating `previous_actuation_time`, we instead compute something like the `initialization_time` and `actuation_index`. Then we can compute the next actuation time with `t0 + T * (i + 1)` --- will this reduce round off error when computing the actuation time?. I'm confused as to what `T` would be here. It feels like it should be `simulation.Δt`, but that wouldn't work for variable `Δt`. > 3. Fix RK3 so it also uses differences to accumulate the substep times as suggested by @tomchor. We can also manually ensure that after the subtseps are complete the the clock time is in fact the current time plus the time-step.; > ; > 4. Should we also add a feature to the nonhydrostaticmodel, something like the minimum time step? If the time-step is below that minimum, then rather than doing a time-step + pressure correction, we simply advance the model clock. I think this could work. We probably would need to discuss how that would interact with `min_Δt` from the `TimeStepWizard`, no? Since they're putting two different lower boundaries (I think the one in `NonhydrostaticModel` would be more ""powerful"", correct?); ; > I wonder if, after all these changes, whether we still need a ""discretized time"" like I was suggesting or not. If we discretize time do we even need the stuff above?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104566106:823,variab,variable,823,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104566106,1,['variab'],['variable']
Modifiability,"> Okay finally tests passed!; > ; > @navidcy I tried restarting the tests over and over (honestly more than 10 times over the past few days) and they always failed. I could only make them pass this morning when I restarted them one at a time. That is, starting one, and only restarting the next failed test when the previous one had fully run.; > ; > So maybe the variability we see in tests has to do with different processes trying to access the same resources... ?. Yes it is a race condition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223710307:364,variab,variability,364,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223710307,1,['variab'],['variability']
Modifiability,"> On checkpointing, looks like the current Checkpointer will work as it just serializes the entire model.boundary_conditions struct which isn't a problem if it contains no functions. Although this does suggest that we need at least two extra checkpointer tests: 1. one where checkpointed boundary conditions are used, and 2. one where a boundary condition contains a function that we have manually restore. This can be the focus of another PR. Yes, because the keyword argument can be either a `SolutionBoundaryConditions` or a `ModelBoundaryConditions`, checkpointing works properly. We do need to extend the checkpointer to allow the user to pass in forcing functions and boundary conditions to `restore_from_checkpoint` in the case that these objects contain functions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/405#issuecomment-531492709:599,extend,extend,599,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405#issuecomment-531492709,1,['extend'],['extend']
Modifiability,"> One aspect of this change is that the models will no longer be concretely typed (because `OrderedDict{Symbol, Callback}` is not a concrete type). I'm not sure this matters, but it's worth noting this.; > ; > Thinking about the API issues, I wonder if there's another advantage in putting the state callbacks in `Simulation`, that we have a system in which a ""model"" is not modified after its created (eg we are not adding callbacks to it) --- that's something that we do with Simulations. With this PR, we mix the concepts of models and simulations. Which may be ok... Perhaps we could change it so you give the model a Tuple or NamedTuple of callbacks when you specify it so the API is more consistent and the model not modified after? I think it could be argued that state callbacks are part of the model rather than the simulation, like forcing functions are, since they could be an intrinsic part of how the model evolves, e.g. if it modified the tendencies. I suppose this argument could be made for some callbacks as well though so I don't know whats best!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1272521047:920,evolve,evolves,920,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1272521047,1,['evolve'],['evolves']
Modifiability,"> Or maybe we can do this just with `AbstractOperations`, the problem is that we have to define a ""helper"" model. I think extending the capabilities of the `DiscreteDiffusionFunction` is the right approach here. But I also think we should only make the necessary changes in abstract_scalar_diffusivity.jl and abstract_biharmonic_scalar_diffusivity.jl and leave the tendency kernels and existing closures (like AMD) unchanged. The only thing that needs to be done is `merge(U, C)` there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2580#issuecomment-1139148066:122,extend,extending,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2580#issuecomment-1139148066,1,['extend'],['extending']
Modifiability,"> Personally, I don't think it's confusing. I also don't feel strongly either way though. Ah yes, totally agree that it isn't confusing. I wasn't arguing that it was confusing though. . In terms of _reading_ these code statements I much prefer seeing `pressure_solver = poisson_solver`. Its even pedagogical because it teaches you that we solve the Poisson equation for pressure. I love that and that is exactly why we chose this design. Please bear with me to understand the reason I am proposing this change. In practical usage / when coding new experiments it is easy to mix up ""pressure"" with ""poisson"". I've been working testing lots of different solvers these past few days, and keep accidentally typing `pressure_solver = ConjugateGradientPressureSolver(grid)` which is wrong. If it becomes more common to configure the pressure / poisson solver in the future (because we have better support for different solvers for irregular geometries) then I would like to also help others that may run into this issue. It's nice to have syntax that ""rolls of the tongue"", ie, is what you would type if you were typing without concentrating very hard. It's not big deal either. I just tend to think that if one makes the same syntax mistake multiple times, it's important to make sure you step back and consider whether the problem is you, or the syntax.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377874234:813,config,configure,813,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377874234,1,['config'],['configure']
Modifiability,"> Point taken, but I think there are still Oceananigans-relevant applications where Value / Gradient boundary conditions on non-immersed boundaries are useful enough to be a ""core"" feature (e.g. imposing observed SST patterns rather than observed air-sea heat fluxes), but there is always the workaround of strongly restoring boundary-adjacent sponge regions. I think this is what many ocean modelers do to implement such boundary conditions anyway. True! I'm not aware that has ever been done, but since it's not difficult to support (notwithstanding @simone-silvestri's concerns about parallel performance) it's interesting to allow it --- agree. For future readers I want to point out that SST restoring (and similar models) are typically be implemented as a `FluxBoundaryCondition` using a piston velocity model, rather than using `ValueBoundaryCondition` (which implies a flux mediated by some diffusivity / viscosity, possibly derived from a parameterization). (`FluxBoundaryCondition` is mathematically identical to restoring in the surface grid point, though it would be a slightly different model to distribute the restoring over some depth). It could be an interesting project to explore using some parameterization-derived diffusivity together with `ValueBoundaryCondition` to predict surface fluxes, though, I'm not sure what the implications would be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452:948,parameteriz,parameterization,948,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452,2,['parameteriz'],"['parameterization', 'parameterization-derived']"
Modifiability,"> Probably something to implement when we have a time stepper that’s more appropriate for adaptive time stepping like RK3?. Yeah that makes sense. We could implement a initializer for AB2 that is formally second-order, e.g. RK2, trapezoidal, or Ralston's method (I think these are all RK2 schemes anyways). But maybe not worth it as AB2 isn't great with adaptive time-stepping. > One thought: we can create a ‘Simulation’ type with a ‘run!’ function, and fields model, timestep (either constant or a Wizard) and perhaps also a progress statement function for managing a simulation. Think I saw a more detailed proposal in another issue so I'll comment there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/431#issuecomment-541414064:90,adapt,adaptive,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/431#issuecomment-541414064,2,['adapt'],['adaptive']
Modifiability,"> Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at n and the time step at n-1 to be correct. It seems like a good idea to use this. . Although, I think we basically always recommend using RK3 for `NonhydrostaticModel`. . Would another path forward be to also implement RK3 for `HydrostaticFreeSurfaceModel`, and basically deprecate any recommendation to use AB2 at all? It's just so much more convenient to use RK3 and also seems to have better numerical properties, not least in light of this issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313369477:34,variab,variable,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313369477,2,['variab'],['variable']
Modifiability,"> Right yeah RegularRectilinearGrid called it grid.zC but VerticallyStretchedRectilinearGrid calls it grid.zᵃᵃᶠ to be more consistent with the curvilinear grids being added, but the output writers might not know this yet. Can we refactor the tests to use `all_z_nodes`? This could avoid issues with property names.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791630388:229,refactor,refactor,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791630388,1,['refactor'],['refactor']
Modifiability,"> Right, and we are essentially looking for a keyword that the user can use to specify they want to use layers. This keyword can be anything we want, right?; > ; > I was advocating for something that seemed intuitive to me but any layered shallow water model is a plus for me. I'm talking about the relationship between the vertical grid topology and the algorithm used by `ShallowWaterModel` to solve a problem on that grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1156641717:104,layers,layers,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1156641717,1,['layers'],['layers']
Modifiability,"> Should also restructure the new `ShallowWaterModel` version in a similar way. Quite! In the context of `ShallowWaterModel`, this will only effect 1D models where adaptive time-stepping may not be that useful (because the vertical dimensions is `Flat` _a priori_). But we can add it there too if we think that's important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1309#issuecomment-763706226:164,adapt,adaptive,164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1309#issuecomment-763706226,1,['adapt'],['adaptive']
Modifiability,"> So if no parameterizations are being used, are the boundary conditions actually being imposed then?. I believe yes: if the viscosity/diffusivity is 0, then flux or no-slip boundary conditions cannot be imposed (mathematically, the order of the PDE is reduced in that case). We then can only impose no-penetration or periodic conditions. > I still feel like bc.calc() feels obscure. My primitive logic: for a flux boundary condition, `bc.calc()` ""calculates"" the flux at the given grid point and time-step. For a ""value"" boundary condition, `bc.calc()` ""calculates"" the value of the boundary condition at the given grid point and time-step. But I agree it is a weird name. What is a better name?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472248169:11,parameteriz,parameterizations,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472248169,1,['parameteriz'],['parameterizations']
Modifiability,"> So the first task is to extend the tridiagonal solver to support integrals in `x` and `y`.; > ; > This could be straightforwardly supported by adding some kind of tag to indicate the ""tridiagonal direction"" (ie `:x`, `:y`, or `:z`), and copy-pasting the functionality for each case. It's a bit of code duplication but pretty straightforward...; > ; > Alternatively we could introduce some kind of abstraction that permutes array dimensions. Then we just have one algorithm which assumes the tridiagonal index is `k`, and support `i` or `j` under the hood via an array wrapper that performs an index permutation.; > ; > I'm leaning towards copy/paste because it's a little easier to understand and it's not that much code in this case... I also prefer the copy/paste method (that's what I used in https://github.com/CliMA/Oceananigans.jl/pull/3111). If I understand correctly these two functions are the only ones that need to be generalized, no?: . https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L74-L83. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L88. if so, that's not too bad. Is duplicating one of the tests in [test_batched_tridiagonal_solver.jl](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_batched_tridiagonal_solver.jl) but rotating everything to two different directions enough to test this new functionality?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1560271584:26,extend,extend,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1560271584,1,['extend'],['extend']
Modifiability,"> So what do you guys think if this tilting is implement at the AbstractBuoyancy level? If I understand correctly all buoyancy types inherit that, right? That way we'd have a keyword for the tilt (maybe tilt, gravitational_direction or gravity_projection) that would default to (0, 0, 1) and a similar option could be given to FPlane, avoiding confusion. Ah, the issue is that abstract types cannot have properties --- they can only be used to organize type parameters and dispatch.; The logic and motivation of your suggestion is sound though (avoiding code duplication through good design); we just have to come up with a different solution. A similar solution could perhaps design a more hierarchical interface to `IncompressibleModel.buoyancy`. For example, we might write. ```julia; struct Buoyancy{G, B}; gravitational_direction :: G; model :: B; end; ```. The existing subtypes of `AbstractBuoyancy` are used for `Buoyancy.model`. The user API could be. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()); ```. or. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9),; model=SeawaterBuoyancy(gravitational_acceleration=9.81, equation_of_state=LinearEquationOfState(α=2e-4, β=8e-5))); ```. This is more verbose but could avoid some of the issues that @tomchor sees. As for `Plane` and `BetaPlane`, I agree that those models are really predicated on a thin aspect ratio assumption that has to do with gravitational accelerations, and therefore ""know"" about the direction of gravity. We could either add a property `gravitational_direction` or, perhaps, add some wrapper / helper functions for constructing coriolis forces in tilted domains (eg `coriolis = TiltedCoriolisForces(FPlane(f=1e-4), vertical_direction=(0.1, 0.0, 0.9))` which returns `GeneralCoriolis` with 3D Coriolis forces --- or something). I think we will start to run into these sorts of issues more generically, where we need to specify ""global"" parameters that impact mu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047:133,inherit,inherit,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047,1,['inherit'],['inherit']
Modifiability,"> So whatever's happening probably has to do with the HydrostaticModel, which I'm really not familiar with unfortunately.; > ; > What do you prefer that I do?. the hydrostatic model does not have `w` as state variable... try removing `w` and see if all is good.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1893650409:209,variab,variable,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1893650409,1,['variab'],['variable']
Modifiability,"> Some of the points that could be in the Goals/Mission section:; > ; > * Easy to install, understand and use; > * Versatile: model is made in blocks that could be combined and easily configured across scales; > * Modern: this might be no independent from the others. Yeah! ""Easy to install"" are ""versatile"" are definitely very important motivators of Julia. Here's some additional points from the ""Vision"" slide presented at Ocean Sciences 2022 Oceananigans town hall:. ![image](https://user-images.githubusercontent.com/15271942/156891514-6ae309ea-597c-4a6a-9ea4-aed1da6f231f.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059790533:184,config,configured,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059790533,1,['config'],['configured']
Modifiability,"> Some of the validations are failing...?; > ; > What previously gave; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); > ERROR: ArgumentError: Must supply extent or x keyword when x-direction is Periodic; > Stacktrace:; > [1] validate_dimension_specification(T::Type, ξ::Nothing, dir::Symbol, N::Int64, FT::Type); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:70; > [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:98; > [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:293; > [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:268; > [5] top-level scope; > @ REPL[3]:1; > ```; > ; > now it goes through:; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); > 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [1.0, 1.0) variably spaced with min(Δx)=0.0, max(Δx)=0.0; > ├── Periodic y ∈ [1.0, 1.0) variably spaced with min(Δy)=0.0, max(Δy)=0.0; > └── Bounded z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699; > ```; > ; > Note that it creates an x and y coord `[1.0, 1.0)`!. I think I fixed it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762146968:1569,variab,variably,1569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762146968,2,['variab'],['variably']
Modifiability,"> Some sandbox stuff might've been added by accident. Ah, thanks for catching that. I was investigating the stretched grid + timestep wizard thing. Should be good now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-863622034:7,sandbox,sandbox,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-863622034,1,['sandbox'],['sandbox']
Modifiability,"> Some stuff later in the docstring is also weird. For example it says; > ; > > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:; > ; > I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?. Good catch! I will work on the docstring and error after the weekend.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443:105,adapt,adapt,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443,3,['adapt'],"['adapt', 'adaptation']"
Modifiability,"> Some test pass and it makes no sense. Is it just random test failure past of the test natural variability?. It's natural variability in hardware instructions for GPU, which is pretty scary. sverdrup has a Quadro P6000 which is a bit older and intended more for gaming. I think weird stuff goes on deep inside. If we had billions of dollars we'd get a little cluster dedicated to CI up and running and make beautiful examples and have lightning fast tests (and an engineer to maintain them). Not there yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489:96,variab,variability,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489,2,['variab'],['variability']
Modifiability,"> Something I don't quite understand: say that I want to output horizontal averages, and I pre-allocate memory to store the result of these computations on the GPU. How would I then write a function to use with JLD2OutputWriter?. Look at lines 140-173 of this script to see how I used the vertical profile diagnostics with a JLD2 output writer.; https://github.com/ali-ramadhan/seasonal-cycle-mixed-layers/blob/a2d2cca8cfd198d35367f34f6b0a86df89aad1a5/deepening_mixed_layer.jl. Basically the JLD2 output writer grabs whatever profile is currently stored in the diagnostic. I use the same interval for the diagnostics and profile writer which works because diagnostics are run before output writers are run.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520510511:399,layers,layers,399,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520510511,1,['layers'],['layers']
Modifiability,"> Sorry, let me rephrase, users shouId pass clock and fields only when boundary conditions require it, so we need some type of warning to make sure the error is well documented.; > ; > I think it is nice to have `fill_halo_regions!(field)`, it will be a bit cumbersome to always have to pass a clock and fields also when non using complex BCs. It's not even possible to construct a field with `ContinuousForcing` outside a model constructor. The model constructor has to do things like compute the index of `fields(model)` that a field name belongs to. So its more than cumbersome, its not possible. Also we need to prioritize. We are trying to do simulations, not have uber fancy flexible field abstractions (this is just an auxiliary feature that's very nice).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179186646:681,flexible,flexible,681,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179186646,1,['flexible'],['flexible']
Modifiability,"> Sounds like the plan is to switch to SolutionBoundaryConditions but that might involve more refactoring so maybe best left for another PR?. This is already done, because the model constructor calls the function `ModelBoundaryConditions` here:. https://github.com/climate-machine/Oceananigans.jl/blob/e41711f6b5db492d3aa5344d2e3bc9c2fe65dd70/src/models.jl#L64. which then dispatches based on whether the argument `boundary_conditions` is a `SolutionBoundaryConditions` or a `ModelBoundaryConditions`:. https://github.com/climate-machine/Oceananigans.jl/blob/e41711f6b5db492d3aa5344d2e3bc9c2fe65dd70/src/boundary_conditions.jl#L254. Thus in either case the model is constructed with a `ModelBoundaryConditions`. Edit: note that this is required for correct checkpointing, because the checkpointer passes a `ModelBoundaryConditions` to the model constructor, while we expect users to pass a `SolutionBoundaryConditions`. . The downside to this pattern is that the type of `model.boundary_conditions` will often be different than the keyword argument `boundary_conditions`. Hopefully this is not confusing or surprising... :-/ An alternative is perhaps to specifically delineate between them; ie change the keyword argument in the `Model` constructor to `solution_boundary_conditions`. However, something to consider is that the `tendency` and `pressure` fields of `ModelBoundaryConditions` should be uniquely determined by `SolutionBoundaryConditions`. Another factor to consider is that the pattern that keyword arguments correspond to fields is not a guaranteed julia pattern, it is simply an organizational principle that we feel is helpful. Thus I think we can break it occasionally if it improves the readability and simplicity of code. We should note the difference in the documentation to the `Model` constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/405#issuecomment-531491747:94,refactor,refactoring,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405#issuecomment-531491747,1,['refactor'],['refactoring']
Modifiability,"> Sponge layers can be added with the existing API. A 1 line implementation (by defining the forcing function to implement a sponge layer, using the currently provided arguments) is currently possible. Yes that's how I did it in PR #291. It can be done in a user script but I figured why not have a `add_sponge_layer!(model; damping_timescale)` convenience function in case users want one. > What is meant by “arbitrary”?. By arbitrary I mean you can keep adding or piling on forcing functions. The purpose of this PR is just to prototype this and see if it can be made performant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/294#issuecomment-504417716:9,layers,layers,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/294#issuecomment-504417716,1,['layers'],['layers']
Modifiability,"> Stokes vorticity?. Ah, when using a GM parameterization?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1454#issuecomment-796822490:41,parameteriz,parameterization,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1454#issuecomment-796822490,1,['parameteriz'],['parameterization']
Modifiability,"> Storing constant values in diffusivities is possible, but could be interpreted as boilerplate. The coefficients need to be stored in closure, because that's where users specify them. So copying the constants or functions into diffusivities (this would have to be done individually for all closures) requires additional code. We don't have that many closures that would need this though, right? I think only `IsotropicConstant`, `AnisotropicConstant` and the biharmonic one that I see in the docs. (I think you have a TKE-based one that isn't listed in the docs also?). > I think of all the changes to diffusivities, the one that makes the most sense is to eliminate that field and change the API so that grid is a required argument for closures that have fields associated with them. This is a substantial internal refactor, but perhaps someone wants to take it up?. I like this option, but keeping the user from creating a closure without a grid seems a bit counter-productive... It's still not clear to me which one I'd vote for. For the time being, should we do something for the problem title refers to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883732045:817,refactor,refactor,817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883732045,1,['refactor'],['refactor']
Modifiability,"> Sure, I think a problem might also be that it varies so much on a case by case basis. The most important case, which is supported by many other codes, is _nesting_. In this situation the entire 3D state outside the prognostic domain is provided. To support this we need to be able to extract the boundary state and potentially also sponge layers from the prescribed 3D state. I think cases where the boundary state is directly prescribed (perhaps for idealized simulations) will be a lot more rare. Yes there are some use cases (like the developing boundary layer case that @simone-silvestri referenced). But I think this will be a lot less common than nesting, which is already widely used for regional modeling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2005310948:341,layers,layers,341,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2005310948,1,['layers'],['layers']
Modifiability,"> Thank you for your help! I have installed the updated version of Julia and when running it appears to be Segfaulting when trying to add CUDA. I will open an issue with them if I cannot figure out how to solve it. Thank you again. @logan can you link the CUDA issue here please?. Also, if you haven't tried, erase everything on your `$JULIA_DEPOT_PATH` (really to be safe you should make a backup of everything there first) and then run the same script you've been running with `using Pkg; Pkg.instantiate()` on the first line. This should ""re-install"" all the packages from scratch. For context [`$JULIA_DEPOT_PATH`](https://docs.julialang.org/en/v1/manual/environment-variables/#JULIA_DEPOT_PATH) by default is `~/.julia`, I think, and that's where julia stores the package files it downloads. The hypothesis here is that at some point some package download/compilation went wrong and you have some broken code there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245639622:671,variab,variables,671,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245639622,1,['variab'],['variables']
Modifiability,"> Thank you for your replies!; > ; > The FFT-based preconditioner was the first one that I tried. It produced suspicious zonal jets in my simulations. This figure shows the difference between the two solvers. It seems to me that these zonal jets are numerical artifacts. Can you clarify --- is the simulation on the right with the FFT-based _direct_ solver, or is it with a preconditioned conjugate gradient solver that use an FFT as a preconditioner?. My suggestion is to use a preconditioned conjugate gradient solver, with the FFT-based solver as a _preconditioner_ (not as the direct solver). As for blow up I think the problem happens for very small time-steps? Perhaps try it without adaptive time-stepping for now and also cap the `max_iterations` as a small number.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2067298583:690,adapt,adaptive,690,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2067298583,1,['adapt'],['adaptive']
Modifiability,"> Thanks @tomchor for doing this.; > ; > I remember last year, Henry needed to use `@gpu_sync` when he was running stuff on multiple cores. Maybe why it is not necessary for a single core?. I think in this case it's not necessary because it's a multi-CPU testing script, so no GPUs involved. And that allows us to get rid of the `Benchmarks` dependence and make the script more portable.; ; > I presume you are going to try and run this on more than one core? If you try it and get an error I'd be curious to know what it is. I did! And I'm running into issues. Please check https://github.com/CliMA/Oceananigans.jl/issues/2433! Any help there is appreciated",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148:378,portab,portable,378,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148,1,['portab'],['portable']
Modifiability,"> Thanks a lot for your hint, I wanted to make sure what you mean by _number_ of actuations as a criteria. Do you mean; > ; > ```julia; > first_actuation_time::Number; > ```; > ; > and do you think this will potentially prevent the floating point issue?. Not quite. `TimeInterval` keeps a count of _how many times it has been actuated_. This is stored in the variable `TimeInterval.actuations`. It's use is illustrated in the computation of the `next_actuation_time`:. https://github.com/CliMA/Oceananigans.jl/blob/dc5dc28c6cf433dcb8a6668cef99e98309e6ead9/src/Utils/schedules.jl#L58-L63. To understand this consider an example. `TimeInterval` has been actuated 2 times, with an interval of 1.1. This means that the next actuation time --- the _third_ actuation_ -- will occur at the time. ```; t = 3 * 1.1 = 3.3; ```. Thus rather than storing the ""previous actuation time"" (a floating point number), we instead store the _number_ of actuations (an integer, and exact), and compute the next actuation time with the formula above. Does this make sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2286669182:359,variab,variable,359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2286669182,1,['variab'],['variable']
Modifiability,"> That's a really cool idea. I can see how we could do that with KernelComputedFields, but I can't really see how to do it for ComputedFields. I think we understand how to write a `compute!` function that fuses the kernels for multiple `ComputedField`s or `KernelComputedField`s. But the harder part is designing an API that implements fusion for an output writer. We might need to add a property called something like `fused_compute` to both `OutputWriter`s. For example, `JLD2OutputWriter` fetches output in a loop:. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/OutputWriters/jld2_output_writer.jl#L195-L196. where `fetch_and_convert_output` calls `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/OutputWriters/fetch_output.jl#L13-L16. which in turn calls `compute_at!`. But we want to trigger _one_ call to `compute_at!` for all the outputs at the same time ... I think ... so that requires some refactoring and API design.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800597659:1004,refactor,refactoring,1004,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800597659,1,['refactor'],['refactoring']
Modifiability,"> The construction `Field(Average(op; dims))` allocates memory only for the result, and not for intermediate variables. So volume averages should not allocate much memory if constructed this way.; > ; > Also note that you usually want to give abstract operations to output writers directly rather than `Field(abstract_op)`, because this will reduce memory allocation when you request sliced output. I find that using `Field(abstract_op, data=scratc.data)` saves a ton of space when compared to just passing `abstract_op` to the writer. Is that not expected? Also, at least for my simulation using `NetCDFWriter`, passing `Field(abstract_op)` or `abstract_op` makes no difference on memory allocation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302594509:109,variab,variables,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302594509,1,['variab'],['variables']
Modifiability,"> The failures seem unrelated, e.g. `Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64})`. wut. > I'm not sure what already is expected to fail. Nothing is expected to fail. Where does `Fix1` come from?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867004447:111,Adapt,Adapt,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867004447,2,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,"> The line should be `minimum(view(parent(grid.Δzᵃᵃᶜ), 1:grid.Nz))`. This is not quite right. We want a view of the interior indices; the indices `1:grid.Nz` of the parent array covers the halo region at the bottom, and does not cover all the points near the top / surface. It should be sufficient to compute the minimum of `parent(grid.Δzᵃᵃᶜ)` because the spacing in the halo region is extended from the interior points (and thus contains no new extrema).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866253813:387,extend,extended,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866253813,1,['extend'],['extended']
Modifiability,> The memory savings is a major advantage of this closure over `AnisotropicMinimumDissipation` for problems with very large numbers of tracers (eg biogeochemistry problems with 10+ tracers).; > ; > Note also that there is overhead to launching a kernel which cannot be ignored --- we can't estimate computational cost just by adding the number of operations. Typically (though not always) our goal is to reduce the number of kernel launches as much as possible. Good points. I also wasn't aware that the kernel launch time was an important issue. I'll close this PR and open another one extending `κᶠᶜᶜ()`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419839733:587,extend,extending,587,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419839733,1,['extend'],['extending']
Modifiability,"> The reason we used U10 in the ""theory wave"" is that the empirical relations we used to estimate the peak wave number are based on wind speed. We need a bulk formula to convert these relations to momentum flux. The relation between U10 and surface Stokes drift does vary with U10 (see, e.g., Fig. 6 of [Rascle & Ardhuin 2013](http://dx.doi.org/10.1016/j.ocemod.2012.12.001)). But Langmuir number also seems to vary with U10 even for fully developed waves (Below is an example showing the relation between the turbulent Langmuir number and U10 assuming Pierson-Moskowitz spectrum). So I'm not sure which way is better... @qingli411 curious your thoughts on Lenain and Pizzo (2020), who provide a model in terms of friction velocity. I think their opinion is that bulk formula tend to introduce further errors into an already approximate parameterization. I suppose this model wasn't available for prior work in 2017 so perhaps the situation is different now? One unique aspect of Lenain and Pizzo (2020) is that they can co-observe the air-sea flux directly (from R/P FLIP) along with high quality measurements of wave properties.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058503937:837,parameteriz,parameterization,837,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058503937,1,['parameteriz'],['parameterization']
Modifiability,"> There are a lot of new instances of `@allowscalar`, but rather than adding new instances we should be refactoring the tests so they don't appear. I added these because it was the only way to make tests pass locally. However, I can't fully reproduce tests results locally anyway, like I mentioned in my previous comment, so these may well be unnecessary (since these lines might be passing on buildkite).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2865#issuecomment-1411337468:104,refactor,refactoring,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2865#issuecomment-1411337468,1,['refactor'],['refactoring']
Modifiability,"> There could be consistency requirements between the treatment of pressure / height gradients in the momentum equation, and transport gradients in the continuity equation. @francispoulin do you know of any requirements here or is this not a concern?. Hmm, I don't believe so. If whatever finite volume scheme we use for the evolution of height, we will ensure mass is conserved. This presumably variable height will drive the motion, and that parts seems very distinct to me. However, if you wanted to ensure global conservation of energy, or something, maybe one needs to be careful about this? I don't believe this is a concern though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744544855:396,variab,variable,396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744544855,1,['variab'],['variable']
Modifiability,"> There's a lot of references to an 'embedded' model. Should we remove these @ali-ramadhan and simply call it a model ? It doesn't seem appropriate for documentation --- the model can be run without embedding it in anything. Yes, calling it a model and not an embedded model sounds like a good call. For context, the LaTeX notes I copied from envisioned this model being a super-parameterization or embedded model but this has changed since the notes were typeset.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470528243:379,parameteriz,parameterization,379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470528243,1,['parameteriz'],['parameterization']
Modifiability,"> There's no need for a new kernel because the diffusivities are `νₑ / Pr` so they can be calculated on the fly.; > ; > We need to extend `κᶠᶜᶜ` and `κᶜᶠᶜ` and `κᶜᶜᶠ`; > ; > ```julia; > @inline κᶠᶜᶜ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑxᶠᵃᵃ(i, j, k, grid, K.νₑ) / closure.Pr[id]; > @inline κᶜᶠᶜ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑyᵃᶠᵃ(i, j, k, grid, K.νₑ) / closure.Pr[id]; > @inline κᶜᶜᶠ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑzᵃᵃᶠ(i, j, k, grid, K.νₑ) / closure.Pr[id]; > ```. I may be missing something, but when I make those changes I still get the errors in #2869. The changes in this PR are the only ones I've tried that seem to solve the issue. I've implemented and pushed your solution to the [tc/smag-binary-op2 branch](https://github.com/CliMA/Oceananigans.jl/blob/tc/smag-binary-op2/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl) in case you wanna check if I understood your suggestion. Basically these are the changes:. https://github.com/CliMA/Oceananigans.jl/blob/56a76ae24d7199a3efe822d06969acc7b6ce6b16/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L127-L129. I'm getting a `device kernel image is invalid (code 200, ERROR_INVALID_IMAGE)` error with only those changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419454342:131,extend,extend,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419454342,1,['extend'],['extend']
Modifiability,"> Thinking of revamping this, I think `T` is a good notation; we do not need to specify `U` and `C` since probably (in the future) we will need to refactor these a little to pass through boundary conditions. Hopefully we don't have to pass boundary conditions 🥺 . Not all complexity is justified by the performance gains...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2329666236:147,refactor,refactor,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2329666236,1,['refactor'],['refactor']
Modifiability,"> This PR allows hiding MPI passing of barotropic auxiliary variables behind the implicit vertical solver and prognostic variables behind the tendency calculations. The latter is done by splitting the tendency kernels into an interior kernel that calculates tendencies between, e.g., i = Hx and i = Nx - Hx, and a boundary kernel, executed once communication is complete, that calculates tendencies adjacent to boundaries. @simone-silvestri I think this description is incomplete. Isn't there also a change to how the auxiliary computations are done?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1712193512:60,variab,variables,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1712193512,2,['variab'],['variables']
Modifiability,"> This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains. No stretched mesh is supported at the moment (that will come in a later PR); > ; > The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes; > ; > * the starting configuration is always a _z-free_ configuration.; > * the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; > * the y-direction is integer divisible by the number of ranks that divide the x-direction; > * the z-direction is integer divisible by the number of ranks that divide the y-direction; > ; > An additional assumption is that:; > ; > * if TY is Bounded, also TZ needs to be Bounded; > * if TX is Bounded, also TY needs to be Bounded; > ; > All these assumptions can be relaxed in following PRs. Are these statements still accurate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850:416,config,configuration,416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850,2,['config'],['configuration']
Modifiability,"> This PR tweaks the API to simplify non-uniform partitioning which should already be supported by the algorithm.; > ; > This PR also extends the tests to include non-uniform distributed partitioning; > ; > The proposal of this PR (up to discussion and tweaking) is to allow calling; > ; > ```julia; > arch = Distributed(CPU(); partition = Partition(Rx = [0.3, 0.1, 0.6]); > ```; > ; > which allows to distributed the domain over 3 workers which hold 30%, 10% and 60% of the computation, respectively. How would one manually specify the grid points on each rank with this API? This is a little non-standard since most of our APIs use words rather than symbols (ie it's not clear what `Rx` means just from reading the code).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762126912:134,extend,extends,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762126912,1,['extend'],['extends']
Modifiability,"> This is WENO order 5 on a stretched grid on the GPU in the nonhydrostatic model right? Seems like the problem might be in the advection of `w`. look like an out of bound error. Maybe using explicit checkbounds it will point out the error. What version of the branch was working?. Yes it is. The manifest entry for the working version is. ```; [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""CUDAKernels"", ""Crayons"", ""CubedSphere"", ""Dates"", ""DocStringExtensions"", ""FFTW"", ""Glob"", ""IncompleteLU"", ""InteractiveUtils"", ""IterativeSolvers"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilArrays"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SeawaterPolynomials"", ""SparseArrays"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""59cc53a3c6b579181932d55f94eae45ce51c6e14""; repo-rev = ""59cc53a3c6b579181932d55f94eae45ce51c6e14""; repo-url = ""https://github.com/CliMA/Oceananigans.jl.git""; uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; version = ""0.77.0""; ```. I couldn't quite figure out what version that refers to, but maybe you understand manifest entries better than I do...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179773940:372,Adapt,Adapt,372,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179773940,1,['Adapt'],['Adapt']
Modifiability,"> This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?. This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088676711:355,flexible,flexible,355,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088676711,1,['flexible'],['flexible']
Modifiability,"> This is of course a lot of overlap between this model and ShallowWaterModel. @francispoulin physically yes but numerically no. `ShallowWaterModel` uses a conservative formulation that solves for the thickness-weighted velocities `hu` and `hv`. Here we use the ""primitive"" variables `u`, and `v`. In addition to that, the free surface displacement equation is linearized. In the future, we could envision generalizing `HydrostaticFreeSurfaceModel` to have a nonlinear free surface and also to have a ""layered"" implementation that might use the thickness weighted velocities like `ShallowWaterModel`. At that point there might be overlap and we can consider merging the two and combining our work...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778464227:274,variab,variables,274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778464227,1,['variab'],['variables']
Modifiability,"> This looks like a symptom of a larger problem and, indeed, does not seem to be tested. I think to solve it we should fix the time-indexing of reduced FTS.; > ; > We seem to be missing the 4D indexing of reduced FTS:; > ; > ```julia; > @propagate_inbounds getindex(f::XYFTS, i::Int, j::Int, k::Int, n::Int) = getindex(f.data, i, j, 1, memory_index(f, n)); > @propagate_inbounds getindex(f::XZFTS, i::Int, j::Int, k::Int, n::Int) = getindex(f.data, i, 1, k, memory_index(f, n)); > @propagate_inbounds getindex(f::YZFTS, i::Int, j::Int, k::Int, n::Int) = getindex(f.data, 1, j, k, memory_index(f, n)); > ```; > ; > to be added [here](https://github.com/CliMA/Oceananigans.jl/blob/abb66e32d333562dd9aaeb7dd2ed8fac5e781368/src/OutputReaders/field_time_series_indexing.jl#L108); > ; > and the 2D-Time indexing of reduced FTS; > ; > ```julia; > @propagate_inbounds getindex(f::XYFTS, i::Int, j::Int, time_index::Time) = getindex(f, i, j, 1, time_index); > @propagate_inbounds getindex(f::XZFTS, i::Int, k::Int, time_index::Time) = getindex(f, i, 1, k, time_index); > @propagate_inbounds getindex(f::YZFTS, j::Int, k::Int, time_index::Time) = getindex(f, 1, j, k, time_index); > ```; > ; > maybe to be added [here](https://github.com/CliMA/Oceananigans.jl/blob/abb66e32d333562dd9aaeb7dd2ed8fac5e781368/src/OutputReaders/field_time_series_indexing.jl#L116); > ; > and all the respective methods for 1D and 0D FTS. In theory, the boundary conditions should work as intended. Indeed, we should add a test for it. and the GPU adapted versions right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3663#issuecomment-2251206241:1516,adapt,adapted,1516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3663#issuecomment-2251206241,1,['adapt'],['adapted']
Modifiability,"> This output writer works (but TimeInterval won't work):. One possibility is that there is a type promotion occurring within `align_time_step`:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L24-L33. and. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L133-L134. This would cause widespread issues in switching to single precision, so @simone-silvestri may want to take note. The quick fix is to convert after calculating the aligned time-step:. ```julia; Δt = aligned_time_step(sim, sim.Δt); Δt = convert(eltype(sim.model), Δt); ```. I think we need a more defined interface for this in the long run though. We really need both `eltype` (the floating point type used by state variables, grid metrics, etc) and a `timetype` (the type of `model.clock.time`). . (Also I'm not sure `eltype(model)` is defined yet, but it should be...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732649563:805,variab,variables,805,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732649563,1,['variab'],['variables']
Modifiability,> This provides another reason to include all the `Nz+1` face data for face-centered fields. Will this feature be easy to implement in the future?. So that comment is actually outdated now. The Neumann boundary conditions can be built into the `Nz x Nz` tridiagonal system. > Pretty simple PR I think because it basically just adds a test (please confirm... ?). Yes. It was originally going to add a vertically stretched pressure solver but then I realized it would be much better code design to do the refactoring I did PR #589 first then add the solver in. So this PR just adds a test that shows you can implement a vertically stretched pressure solver using the `BatchedTridiagonalSolver`. > I think the test may be incorrectly named and can also be greatly simplified. I'm not sure if the test is 1) not achieving its intended purpose or 2) is over-complicated. Either way I think it should be cleaned up a bit before merging. Yes it is unfortunately over-complicated because there is no abstraction for a vertically stretched grid or a stretched pressure so they are implemented in the test itself. This test will be massively cleaned up in PR #543.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/306#issuecomment-572266779:503,refactor,refactoring,503,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/306#issuecomment-572266779,1,['refactor'],['refactoring']
Modifiability,> This warning means that you didn't configure MPI correctly to work with julia. There is some documentation on how to do it [here](https://juliaparallel.org/MPI.jl/stable/configuration/). We should add a link in the docs to this webpage. So I went to that doc pages but I wasn't sure -- do I need to install MPIPreferences? There is no other way?; We should definitely add a link to that docs page then.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2278718087:37,config,configure,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2278718087,2,['config'],"['configuration', 'configure']"
Modifiability,"> Thus because I do not think we should regard Value / Gradient boundary conditions as a ""core"" feature (this package is oriented towards ocean modeling from large eddy simulation up to global scales --- direct numerical simulation is not our core application) the trade-off points towards not supporting this. Point taken, but I think there are still Oceananigans-relevant applications where Value / Gradient boundary conditions on **non-immersed** boundaries are useful enough to be a ""core"" feature (e.g. imposing observed SST patterns rather than observed air-sea heat fluxes), but there is always the workaround of strongly restoring boundary-adjacent sponge regions. I think this is what many ocean modelers do to implement such boundary conditions anyway. I can't really conceive of any reasons why one would want Value / Gradient BCs on the immersed boundary though, and agree it is not alone worth a major refactor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690256956:915,refactor,refactor,915,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690256956,1,['refactor'],['refactor']
Modifiability,"> To properly handle the checkpoint pickup, we manually adjusted the actuation to match the correct value based on the pre-pickup simulation. Here's an [example](https://github.com/liuchihl/Oceananigans.jl/blob/correct-averagedtimeinterval/test_netcdf_timeaverage.jl#L105-L116) to illustrate what I mean.; While this resolves the issue of checkpoint for now, it's more of a workaround. Agree we need to refactor the Checkpointer. Thank you for documenting a way to proceed for the time being.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2433143553:403,refactor,refactor,403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2433143553,1,['refactor'],['refactor']
Modifiability,"> Using a discretized version of the thermal wind balance is a sound suggestion, but it does not explain why the error only appears when evolving the total fields. Why not? When evolving the total fields, the condition of geostrophic balance is computed during the prognostic evolution of the total variables. When evolving just the perturbation, the algorithm for mean-perturbaiton decomposition _assumes_ that the mean fields are balanced. There is no need to worry about the tiny difference between discrete and continuous balance in the case that you only evolve perturbations. But if you want to evolve the geostrophically balanced state, you must ensure that it is perfectly balanced to within machine precision, or you will have an adjustment. That's the basis for my suggestion. I'm not sure the computation I recommended achieves numerical balance (something might be missing) --- that should be checked.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712196487:299,variab,variables,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712196487,3,"['evolve', 'variab']","['evolve', 'variables']"
Modifiability,"> Was just looking through this, and not sure if there is still room for comments from noobs (happy to be ignored). Would `tensor_diffusivity` be a good name - skewsymmetric seems a bit like saying that a T-junction is a left_right_turn. :). I see what you're saying @dhruvbalwada ... ! :-D Maybe `IsopycnalTensorDiffusivity` ? The thing is, when users build this closure they have the option only to set _coefficients_ (which may be constants or nonlinear functions of model variables) of two tensors --- an ""isopycnal rotation tensor"" that is symmetric and rotates a vector into the isopycnal plane, and another skew-symmetric or antisymmetric tensor. So the tensor is not general; it has a specific form... On the other hand I think we are leaning towards more substantial changes to this parameterization than would be covered by this name. So we could have one `IsopycnalTensorDiffusivity` corresponding only to the symmetric component, and another `GentMcWilliamsDiffusivity`(or something?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-972010093:476,variab,variables,476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-972010093,2,"['parameteriz', 'variab']","['parameterization', 'variables']"
Modifiability,> We could further simplify the time stepping code if we adapt the Field abstraction to be GPU compatible (#298). Just a note: I attempted this while working on abstract operations and was unable to solve the problem. But we are using new versions of julia + cuda tools all the time so it is / will be worth revisiting,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589270716:57,adapt,adapt,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589270716,1,['adapt'],['adapt']
Modifiability,"> We could procede in a couple of ways from here:. Let me provide a few other options:. * Compute the 2D boolean masks for reduced operations in `x`, `y`, and `z` when forming `ImmersedBoundaryGrid`. Then, use those masks for conditional differencing of reduced fields, rather than calling `immersed_inactive_node`. * For `GridFittedBottom` and `PartialCellBottom`, as a stop gap, define these methods:. ```julia; @inline conditional_δx_f(ℓy, ℓz, i, j, k, ibg::GFBIBG, δx, r::ZIRF, args...) = ifelse(immersed_inactive_node(i, j, ibg.Nz, ibg, c, ℓy, ℓz) |; immersed_inactive_node(i-1, j, ibg.Nz, ibg, c, ℓy, ℓz),; zero(ibg),; δx(i, j, k, ibg.underlying_grid, r, args...)). ```. That use a condition based on whether `k == Nz` is immersed. This will fix fields that are reduced in `z` without increasing memory storage or doing a computation in the immersed boundary grid constructor. And that's the most common case anyways. * When building a `ReducedField`, compute the mask that has to be applied to abstract operations. Then, extend the `_derivative` constructor for the combination of a `ReducedField` argument + `ImmersedBoundaryGrid` using conditional operation. This has the advantage of avoiding the mask computation in `ImmersedBoundaryGrid` (since its only needed to do operations on reduced fields). The disadvantage is that different reduced fields have to redo the computation. Also, this only fixes abstract operations and does not fix the internal operators. We also have to update the conditional operators to throw away the immersed boundary grid for reduced fields, or throw away the immersed boundary grid inside the abstract operation. * A variant on the above approach is to compute the mask when forming `Derivative`. But then a new mask is computed for every operation. There's probably a lot of other options. Keep the brainstorming coming.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2099195353:1028,extend,extend,1028,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2099195353,1,['extend'],['extend']
Modifiability,> We should also add a test similar to the one that was added in #3512. Doesn't that already exist? . We just have to adapt the test,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2000835614:118,adapt,adapt,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2000835614,1,['adapt'],['adapt']
Modifiability,"> We should always use default boundary conditions for `grid` and the location, eg `Face` or `Cell` along each dimension. I'm okay with doing this but should we be worried that not all `{Cell,Cell,Cell}` fields are tracer fields and not all `{Face,Cell,Cell}` fields are u-velocity fields?. > Just a note: I attempted this while working on abstract operations and was unable to solve the problem. But we are using new versions of julia + cuda tools all the time so it is / will be worth revisiting. Hmmm, do you remember what you got stuck on? I'd be in favor of reopening the issue and trying to adapt `Field` to work in GPU kernels. > For tuples of closures, everything related to the closure is tupled, including the DiffusivityFields. If there are different diffusivity fields for different closures, then it is possible to set them with different diffusivities?. Ah sorry I meant that passing a named tuple like; ```julia; boundary_conditions = (b=buoyancy_bcs, κₑ=(b=κₑ_bcs,)); ```; to the model constructor will apply diffusivity boundary conditions as expected. But if you have two closures and you want to impose different diffusivity boundary conditions on each one then you can't do so by passing a named tuple to the model constructor. You can of course use `DiffusivityFields` to accomplish this. We could upgrade the logic for interpreting boundary condition named tuples so that you can do something like; ```julia; κ1_bcs = (T=some_diffusivity_bcs, S=some_diffusivity_bcs); κ2_bcs = (T=some_other_diffusivity_bcs, S=some_other_diffusivity_bcs); boundary_conditions = (T=T_bcs, κₑ=(κ1_bcs, κ2_bcs)); ```; but it felt like a pretty edge case (very very few users would probably use it) so I didn't do it. But we can do it, it's within scope for this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589456579:597,adapt,adapt,597,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589456579,1,['adapt'],['adapt']
Modifiability,"> We should modify the netCDF variable names to `λF`, `λC` or something... I didn't do this in #2979 because I didn't know if NetCDF allows unicode (and because I felt it was outside of the scope of that PR). Sorry for the delay in chiming in here. Yes, NetCDF works fine with unicode, but I suspect that due to the [SGRID conventions](https://sgrid.github.io/sgrid/) we will have to name our coordinate a default, non-unicode name, which will be different from the names we use in Oceananigans. ~The downside of this is that I think it'll be a bit harder to output spacings and other metrics separately in meters and degrees, which I think would be useful for curvilinear coordinates.~",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516631188:30,variab,variable,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516631188,1,['variab'],['variable']
Modifiability,> We should note the difference in the documentation to the Model constructor. +1. > We do need to extend the checkpointer to allow the user to pass in forcing functions and boundary conditions to `restore_from_checkpoint` in the case that these objects contain functions?. Don't think so as you can already pass in whatever `kwargs` you want to `restore_from_checkpoint`. But would be good to have a unit test for this functionality.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/405#issuecomment-531493346:99,extend,extend,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405#issuecomment-531493346,1,['extend'],['extend']
Modifiability,"> We should use the same method on the CPU and GPU that permutes the dimensions of the array. . The problem is that we can do something more efficient on the CPU with FFTW's cosine transforms (I haven't benchmarked the permutating DCT algorithm on the CPU, although it's probably safe to assume that FFTW is faster). We may be able to switch to a a wholly more efficient pressure solver that solves tridiagonal systems in the vertical with PR #306 so then we can get rid of the permutation algorithm for doubly periodic configurations and have fewer Poisson solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/475#issuecomment-545510373:520,config,configurations,520,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/475#issuecomment-545510373,1,['config'],['configurations']
Modifiability,"> Were you suggesting to combine these in a single `k`-long tuple, e.g.,; > ; > ```julia; > gravitational_acceleration .* (1, (ρ[k] - ρ[k-1]) / ρ[k-1], (ρ[k-1] - ρ[k-2]) / ρ[k-2], ..., (ρ[2] - ρ[1]) / ρ[1] ); > ```; > ; > which will become a number for single layers?. Yes, that's exactly what I was suggesting, since gravitational_acceleration could be understood as the value of g that each layer feels, so not sure why we need different parameters for both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1472879794:260,layers,layers,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1472879794,1,['layers'],['layers']
Modifiability,"> What I meant about trusting users for auxiliary fields is that you can do e.g. this: `model = NonhydrostaticModel(; grid, auxiliary_fields=(; A = randn(1, 2))` and it doesn't error. Why do we want to support arrays in `auxiliary_fields`?. The main usage for `auxiliary_fields` is that they can be invoked in continuous-form forcing functions. In that usage they have to be `AbstractField`, otherwise we can't figure out how to interpolate them into a forcing function. `auxiliary_fields` isn't meant to be a place to store just any information needed for a model (what would the purpose of that be?) We can adapt `auxiliary_fields` but it would be good to understand why. Separately, perhaps we should check that all `auxiliary_fields` are `AbstractField`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269340649:609,adapt,adapt,609,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269340649,1,['adapt'],['adapt']
Modifiability,"> What about on a non-immersed rectilinear spaced grid? The reduction is a little different in that case. That seems OK:. ```Julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:583,variab,variable,583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457,5,"['Config', 'config', 'variab']","['Config', 'Configuration', 'config', 'variable']"
Modifiability,"> What about the topologically aware operators PR? Should that come first? That seems to me to be the most significant improvement.; > ; > Note there are some changes on #3867 to respect. Right, I guess we can first #3268, then #3841 and then we can refactor the split explicit code",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3873#issuecomment-2441610553:250,refactor,refactor,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3873#issuecomment-2441610553,1,['refactor'],['refactor']
Modifiability,"> What does `find_neighboring_panels` do that is not already included in the `grid.connectivity`? `find_neighboring_panels` seems like a bit of a ""hack"" to me that only works for 1-region-per-panel configs? `grid.connectivity` is general. Why don't we use the grid's connectivity to read out the rank of the neighboring panels.; > ; > (I really should have made this comment in #3488, but it's never too late..). It's been taken care of in commit [5cffc13](https://github.com/CliMA/Oceananigans.jl/pull/3547/commits/5cffc139eb93c1afbd68c520a95e21ba56d73990).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3547#issuecomment-2046332671:198,config,configs,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3547#issuecomment-2046332671,1,['config'],['configs']
Modifiability,> What make sense logically is that `validate_closure` is called first. Because if it's not a valid closure why bother doing anything else...; > ; > But I'm not sure if it's difficult to refactor. I don't think its hard.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2347634362:187,refactor,refactor,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2347634362,1,['refactor'],['refactor']
Modifiability,"> When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!. Thanks for asking the question! Also is it ok if I convert to discussion? If it remains an issue we might lose track of it when the issue is closed. But this might be useful to people if its more visible. > Why you need to define f², wouldn't work simply using ∂zᶠᶜᶠ and squaring the operation?. Because we need to interpolate `∂zᶠᶜᶠ` using `ℑxzᶜᵃᶜ`. Note that Oceananigans operators (derivatives, interpolation, differences) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:84,parameteriz,parameterization,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513,1,['parameteriz'],['parameterization']
Modifiability,"> Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?. I was planning was to implement the tridiagonal solve similarly to what we do for single GPU as such:; ```julia; transpose_z_to_y!(storage) # copy data from storage.zfield to storage.yfield; solver.plan.forward.y!(parent(storage.yfield), buffer.y) ; transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; solver.plan.forward.x!(parent(storage.xfield), buffer.x); transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; ; # Perform the implicit vertical solve here on storage.zfield... transpose_z_to_y!(storage); solver.plan.backward.y!(parent(storage.yfield), buffer.y); transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; solver.plan.backward.y!(parent(storage.xfield), buffer.x); transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; ```. This is not super great because it requires eight transposes, but I think it's the same thing that was happening in #2538",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197384003:231,adapt,adapted,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197384003,1,['adapt'],['adapted']
Modifiability,"> Where in the model should we store the forcing array in this case?. The user would define an array in a script, declare it `const` to the compiler, and then write a function that indexes into it as a global:. ```julia; # define a; forcing(..., i, j, k) = a[i, j, k]; ```. We can also include a constructor for `Forcing` that allows the user to pass some function that defines a constant array, and set up the same functionality internally. > The main motivation being that we don't have to write extra functions that dispatch on the forcing, thus simplifying the time stepping code. As you point out we don't want to write 5! = 120 new functions. The update_source_terms! function is already 52 lines long so I'd rather avoid having to dispatch on this function. I think the problem is that our functions are trying to do too much at once. We need smaller functions that perform more atomic operations so we can dispatch on atomic operations. I don't think we need to re-invent multiple dispatch with macros. We just need to refactor the code so we can use multiple dispatch effectively.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470556414:1027,refactor,refactor,1027,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470556414,1,['refactor'],['refactor']
Modifiability,"> Why do we need to refactor? Why don't we just specify a default topology in the grid constructor? Then, the only refactoring we need to do is for models in the channel domain. I'll add a default `topology=(Periodic, Periodic, Bounded)` then. The bigger refactor would be if we decided to go with named tuples like `size=(x=16, z=32)` instead of just tuples `size=(16, 1, 32)`. > I'm fine with `Flat`. `Flat` it is then. > But the topology does not restrict how many grid points one uses. I don't see the point of doing that. We only need this for eliding derivative operations, not restricting user behavior. True but I don't see the point of running with more than one grid point in a dimension that's supposed to be `Singleton` or `Flat`. But I guess users can do many weird things, and this wouldn't be the weirdest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/614#issuecomment-581895888:20,refactor,refactor,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/614#issuecomment-581895888,3,['refactor'],"['refactor', 'refactoring']"
Modifiability,"> Work with FieldTimeSeries as if it were a 4D array (with operations ignoring the halos). To clarify, are you referring to getting broadcasting and reduction to work?. If so I would clarify this comment: we need to extend our existing broadcasting and reduction machinery for 3D fields to 4D field time series. The problem is not merely to avoid operations on halos, but also to correctly interpolate between locations on a staggered grid and correctly apply derivatives on arbitrary grids. The built-in broadcasting machinery launches kernels via `launch!` so such functionality avoids operations on halos like all other `launch!` kernels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1641#issuecomment-835433735:216,extend,extend,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1641#issuecomment-835433735,1,['extend'],['extend']
Modifiability,"> Yes, most containers are ""adapted"" on the GPU. We adapt `field` to `field.data`:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/7debded91d24520d72857c120303bcd22b805104/src/Fields/field.jl#L394; > ; > And note that `field.data` will be further adapted. For example, `CuArray` becomes `CuDeviceArray`. GOTHCA!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370321014:28,adapt,adapted,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370321014,3,['adapt'],"['adapt', 'adapted']"
Modifiability,"> You can use `FluxBoundaryCondition` with `closure=nothing` (it's `Value` and `Gradient` that won't work). You can obtain global dissipation by differencing globally integrated TKE (and perhaps a pointwise dissipation by evaluating the TKE budget), but I agree that it's probably more difficult. @simone-silvestri may have some tips as he has been developing an implicit LES scheme for mesoscale turbulence.; > ; > Does `AnisotropicMinimumDissipation` work? Or other closures?. Nice catch! It does work for AMD. I hadn't tried that before because I assumed it wasn't gonna work. Unfortunately I can't really use AMD because it produces a lot of noise in the stratified regions of my domain, but hopefully adapting Smag isn't too hard?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403796249:706,adapt,adapting,706,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403796249,1,['adapt'],['adapting']
Modifiability,"> You can't have multiple threads incrementing the same variable, you get a race condition. Ok, that's just me showing my ignorance. . Perhaps we can change the name of `gpu_accumulate_xy` to something like `horizontal_integral!` that works on both the CPU and GPU? And with a docstring that explains inputs and outputs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520524067:56,variab,variable,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520524067,1,['variab'],['variable']
Modifiability,"> [Every kernel](https://github.com/climate-machine/Oceananigans.jl/blob/b746a0bce63642a8beb9e6771b4b43cd17368ba6/src/time_steppers.jl#L72) uses `NT=2` --- or am I missing something?. Yes sorry, let me try explaining again. Right now most of our kernels are written so that each thread is responsible for 1 grid point. Some kernels that involve calculating vertical integrals are written so that each thread is responsible for `Nz` grid points (or 1 column). As long as our thread-block layouts reflect this, i.e. using a layout with `Tx*Ty*Tz*Bx*By*Bz == Nx*Ny*Nz` when calling kernels where 1 thread is responsible for 1 grid point, and using a layout with `Tx*Ty*Tz*Bx*By*Bz == Nx*Ny` when calling kernels where 1 thread is responsible for 1 column, we won't have to rewrite any kernels. We just have to be careful to use the correct thread-block layout when launching kernels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-496523520:770,rewrite,rewrite,770,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-496523520,1,['rewrite'],['rewrite']
Modifiability,"> ```julia; > u_subsampled = XFaceField(subset_grid); > ; > function subsample_u(model); > u = model.velocities.u; > interpolate!(u_subsampled, u); > return u_subsampled; > end; > ; > outputs = (; u=subsample_u); > ```. I see, so there is no way to make this seamlessly work with a NamedTuple I already have with all variables I want to output?; I would need to create a function for each of the variables?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2032422385:317,variab,variables,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2032422385,2,['variab'],['variables']
Modifiability,"> `clobber=false` is probably safer. That's what I was thinking too but apparently with NCDatasets.jl the other modes are append (`""a""`) and read-only (`""r""`) so if you're creating files for the first time (the most common use case) then clobber must be used. Otherwise you get NetCDF errors when it tries to open a non-existent file. > Named tuples are trivial to support; but maybe users don't care. Personally, I much prefer them in the JLD2OutputWriter. I actually wasn't able to get named tuples to work with JLD2 but I opened an issue about that: #562. I don't see the big advantage of a `NamedTuple` over a `Dict` in this case so I'm going to keep it simple and stick to named tuples here for now. The original point of this PR was that the documentation was wrong. `NetCDFOutputWriter` needs to be refactored a little anyways, and I'd like to add some features to it as well so I'll add support for named tuples then.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/556#issuecomment-564362931:806,refactor,refactored,806,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/556#issuecomment-564362931,1,['refactor'],['refactored']
Modifiability,"> although not sure when I'd use iter if I have t. `iter` is useful for defining stochastic forcings that change every iteration (with a substep method like RK3, you must hold the value of a random variable constant over the substeps, but change on whole steps). It's not crucial right now. The best solution would be if the user could potentially *change* the arguments of the kernel function if they desired...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/390#issuecomment-527166939:198,variab,variable,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/390#issuecomment-527166939,1,['variab'],['variable']
Modifiability,"> and I talked about using `FieldVector` as a parent type for `Forcing` (and `Velocities`, `Tracers`, etc) as a nice way to get tuple-like features. What do you think about that?. Should be fine, but I leave the abstractions to @peterahrens ;) . > closure-specific temporary variables. What do you mean by that? Are these temporaries globals that ought to be updated and carried between different forcing functions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-467872715:275,variab,variables,275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-467872715,1,['variab'],['variables']
Modifiability,"> and the GPU adapted versions right?. right, should be accounted for if we define the 1D and 0D FTS as we do the 2D ones; ```julia; const XYFTS = FlavorOfFTS{<:Any, <:Any, Nothing, <:Any, <:Any}; const XZFTS = FlavorOfFTS{<:Any, Nothing, <:Any, <:Any, <:Any}; const YZFTS = FlavorOfFTS{Nothing, <:Any, <:Any, <:Any, <:Any}; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3663#issuecomment-2251230309:14,adapt,adapted,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3663#issuecomment-2251230309,1,['adapt'],['adapted']
Modifiability,"> and the run script only resubmits if that file is not found. I'm not sure this would work, but could we also use environment variables for this? There could be an environment variable called `SIMULATION_COMPLETE` or something like that. I don't think I completely understand how the resubmission works, so an explanation of that might be helpful. I guess there is a slurm script with a few lines at the end?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/779#issuecomment-651290164:127,variab,variables,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/779#issuecomment-651290164,2,['variab'],"['variable', 'variables']"
Modifiability,"> but I guess you are telling me that it defaults to the position of the first variable?. Correct. > Actually, I needed to use model.solution.uh instead of uh and it seems to be working better (but I'm not done). Does that make sense or am I missing something. My apologies for being unclear! I would write. ```julia; uh, vh, h = model.solution; u = ComputedField(uh / h); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760280879:79,variab,variable,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760280879,1,['variab'],['variable']
Modifiability,"> but it felt like a pretty edge case (very very few users would probably use it) so I didn't do it. It may become common if users do realistic GCM stuff, because there will be many turbulence closures, but only *one* of them would require explicit boundary-diffusivity modeling to control field gradients and diffusivities along boundaries (for example, prescribing some interesting lateral diffusivity parameterization on top of a vertical mixing parameterization). EDIT: we don't need to confront these complexities now of course, but it's worth keeping in mind. One brute force solution is just to define convenience constructors for models themselves (`OceanCirculationModel`) that sets up an `IncompressibleModel` in ""MITgcm"" mode (for example) 😏. Then we can do whatever needs to be done there, provided it's at least *possible*.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589766969:404,parameteriz,parameterization,404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589766969,2,['parameteriz'],['parameterization']
Modifiability,"> forcing at the surface to generate mixing (through convection or mechanical stress), while the forcing in the interior restores the stratification. Hi there. Talked briefly about this with @zhenwu0728 earlier and was suggesting something along those lines for the physics too. I could imagine additional applications for configs like these and am willing to help with e.g. exploring the parameter space a bit if needed. Maybe the simplest, yet rather tunable, approach I could think of would be something like:. - at the top: warming (e.g. via relaxation to SST0) + wind stress to mechanically generate turbulence; - below a certain depth z1: cooling (e.g. via relaxation to T1<SST0) to restore to positive stratification. I feel that this simple approach should lead to a statistically steady stratification within an appropriate ranges of [SST0 T1 z1] and piston velocities. . With this basic config in place, which maybe is not far from your `examples/ocean_wind_mixing_and_convection.jl`, my guess is that adding a diel or seasonal mixed layer deepening is straightforward -- e.g. via a time variation in SST0. Does that make sense? Am I missing something obvious?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629517072:323,config,configs,323,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629517072,2,['config'],"['config', 'configs']"
Modifiability,"> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)). Nope, it's not erroring on main. ```Julia; julia> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)); 1×1×3 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [1.0, 16.0] variably spaced with min(Δz)=3.0, max(Δz)=7.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757850869:330,variab,variably,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757850869,1,['variab'],['variably']
Modifiability,"> in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit.; > ; > The other option to not use MPI variables is to hardcode the number of processors. This advice seems to contradict the goal of having scripts that can be changed from non-distributed to distributed with a single line. I don't think user scripts should have to write `using MPI`. The API should have all the features necessary to support ""one-click"" distributed simulations. When we see `using MPI`, it measn that the API is incomplete and we have work to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894651642:86,variab,variables,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894651642,2,['variab'],['variables']
Modifiability,"> including the cosine term would only make sense if we're running on a sphere. I'm not sure what you mean by `cosine` term --- I am referring to including the full rotation vector, which projects onto the horizontal as well as the vertical in a tangent plane approximation. Keeping only the vertical component of the projection is known as the 'traditional' approximation. For weakly stratified non-hydrostatic scenarios there is evidence that the full Coriolis force should be used. See:. * https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/nearinertial-waves-in-the-ocean-beyond-the-traditional-approximation/8E5E79284F842F15A79E1570D1B5A2A7. * https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1002/2015GL066472. For the sphere, a different abstraction for `Rotation` should probably be used, because there is no longer the concept of the projection of the rotation vector into a coordinate system that is locally tangent to the Earth's surface at a particular latitude (which is what gives rise to the parameters `f`). I think if this code is successful, DNS will be a common use case. There are no julia DNS CFD codes, and the are very few GPU DNS codes in general. > This makes sense to me, but then I'm wondering if ρ₀ is important to know to calculate diagnostics etc. where should we store it? EOS makes the most sense to me as a storage place even though it doesn't influence the dynamics. This is the question. If the EOS actually calculates buoyancy rather than density, I feel that it is an error to associate ρ₀ with the EOS. Including ρ₀ in the EOS contributes to the misconception that density is a variable in the code, which it is not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491903130:1642,variab,variable,1642,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491903130,1,['variab'],['variable']
Modifiability,"> on `buoyancy` versus `buoyancy_perturbation` --- since this is an internal issue (not part of the API), I'm fine to stick with `buoyancy_perturbation` for now and continue to discuss what the best nomenclature is after this PR is merged. Completely agree. @suyashbire1 and I are hoping this gets merged ASAP because all our scripts are depending on old versions right now (which have other issues) and we need to update them but can't until the buoyancy and rotation API is stable (well we can, but we want to refactor all our scripts at once).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533102511:512,refactor,refactor,512,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533102511,1,['refactor'],['refactor']
Modifiability,"> right, `particle` is a list of particles though. `p` is the index that we have to pass in. we can call it forcing but it is specifically an advective forcing (or velocity forcing) because it is added to the velocity. That's a detail and can be implemented regardless of the type of interface. The difference is. 1. Users _extend_ an Oceananigans function to implement a forcing, OR; 2. Users pass a function into `ParticleAdvectiveForcing` to implement a forcing. Option 1 is fine, no doubt. It's just that the rest of our user interfaces implements option 2. I think we should have a uniform interface across the code. Our original motivation for choosing option 2 is because we believed it would be easier to use for people who don't know Julia very well. People should be able to use Oceananigans without knowing what ""multiple dispatch"" is. We can revisit this. If we think that extending forcing function is a better pattern, we should change it throughout the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819345238:885,extend,extending,885,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819345238,1,['extend'],['extending']
Modifiability,"> right, sorry I confused `i, j, k` with particle position, I meant we have to pass the particle position `x, y, z`. Ah ok, that makes more sense!. The particle position is available via. ```julia; x = particles[p].x; ```. etc right?. We should implement a helper function,. ```julia; position(p) = (p.x, p.y, p.z); ```. Note that particles are also annoying on `Flat` grids. One needs to beware the particle position in the `Flat` direction, but they shouldn't have to. The same issue will affect `interpolate` once we merge #3395 . EDIT: even better would simply be to extend `interpolate` to work with the particle as an argument, eg something like. ```julia; up = interpolate(particles[p], u, u_loc, grid); ``` . I think ultimately it would be nice to push this under the hood with some nice user interface for `ParticleVelocity` or whatever",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876:571,extend,extend,571,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876,1,['extend'],['extend']
Modifiability,> the time integral when we use variable time stepping that is a feature we use quite often. What do you mean by this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313367035:32,variab,variable,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313367035,1,['variab'],['variable']
Modifiability,"> then it can be used in a GPU kernel right out of the box?. Yes :) but you are missing the fact that `Array{Float64, 1}` is not `isbitstype`. I think to make it work out of the box you need. ```; Adapt.adapt_structure(to, x::OffsetArray) = OffsetArray(adapt(to, parent(x)), x.offsets); Base.Broadcast.BroadcastStyle(::Type{<:OffsetArray{<:Any, <:Any, AA}}) where AA = Base.Broadcast.BroadcastStyle(AA); ```; https://github.com/JuliaLabs/ShallowWaterBench/blob/aa8b4add55172f0c1920d6f8cebc8eccc424f2b5/src/GPUMeshing/src/GPUMeshing.jl#L79-L80. I should probably finish https://github.com/JuliaArrays/OffsetArrays.jl/pull/57",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/104#issuecomment-469738576:197,Adapt,Adapt,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/104#issuecomment-469738576,2,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,"> then we'd have to rewrite loads of stuff to make it so the user can specify whatever they want for the external state. I think see your point (I'm not sure I grasp the totality of it). Is your point that we are able to _re-use_ more existing code if we allow `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction` as `condition`? I didn't understand this previously so thank you for clarifying. To re-use that code with a new `condition`, we can use a nesting technique:. ```julia; function getbc(open_bc::OpenBoundaryCondition, ...); state_value = getbc(open_bc.condition.external_state, ...); # other stuff related to matching; end; ```. This means that we don't have to rewrite anything, we just add new functionality for open boundary conditions on top. You could make the point that we have less _new_ code to write though, if we implement a design that allows conditions to be the same. And for users, this could be clearer, so I see the advantage of that. On the flip side, the advantage of making a new `OpenCondition` is that `getbc` retains its meaning as ""the function that returns the boundary condition value"". When we have an external state + matching scheme, the boundary condition values are not exactly the external state and are modified by the matching scheme. So I see pros and cons to both, but the good news is that we can actually talk coherently about the pros and cons. And if there are other pros and cons please mention them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988781194:20,rewrite,rewrite,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988781194,2,['rewrite'],['rewrite']
Modifiability,"> these are if we want to make the particle velocity depend on other _eulerian_ fields (like forcing for our prognostic variables). An example can be the buoyancy field for buoyant particles. If we decide that that role can be undertaken by the `dynamics` kernel, we can remove the `i, j, k` from the signature.; > ; > We should probably come up with a couple of examples to include in this PR that show the implementation of different particle dynamics. I would include:; > ; > * buoyant particles (sinking or rising with a density-dependent vertical velocity); > * particles with drag. The discussion is fine but we first need to resolve something more fundamental: the particles do not have indices `i, j, k`. The only way to use Eulerian fields to determine particle forcing is to `interpolate` the Eulerian fields to the location of the particle. Obviously, that's how advecting particles works in the first place, by interpolating the velocity field to the location of the particle.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852941287:120,variab,variables,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852941287,1,['variab'],['variables']
Modifiability,> we need to extend our existing broadcasting and reduction machinery for 3D fields to 4D field time series. @glwagner Reductions on `Field`s don't all work on `master` but work now (without the `interior_copy` version) but trigger scalar operations on the GPU. Might be worth doing a bit of pair programming later around this? I'll see if I can add some CPU tests which should pass.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1641#issuecomment-839405428:13,extend,extend,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1641#issuecomment-839405428,1,['extend'],['extend']
Modifiability,> when I run; > ; > ```shell; > (base) navid:OceananigansDistributedExamples/ (glw/docs2) $ mpiexec -n 2 julia --project distributed_example.jl; > ┌ Warning: You appear to have run julia under a different `mpiexec` than the one used by MPI.jl.; > │ See the documentation for details.; > └ @ MPI ~/.julia/packages/MPI/is7GN/src/environment.jl:26; > ```. This warning means that you didn't configure MPI correctly to work with julia. There is some documentation on how to do it [here](https://juliaparallel.org/MPI.jl/stable/configuration/). We should add a link in the docs to this webpage,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2278388760:388,config,configure,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2278388760,2,['config'],"['configuration', 'configure']"
Modifiability,"> would there be 30+ nested parameterized types for ModelBoundaryConditions. Is/should that be a concern?. @ali-ramadhan do you mean with regards to performance? I'm not sure. With multiple dispatch being core to julia it seems this scenario is not uncommon (30+ may not be very large). > Just one initial question: I might be misunderstanding the purpose of bc.calc but why not bc.impose(args...) instead of bc.calc(args...) as we usually say that we impose boundary conditions?. The function `calc` does not actually impose a boundary condition --- the imposition of boundary condition depends on, for example, the viscosity and diffusivity, and is a property of the equation (or turbulent closure) being implemented. Again for example, the K-Profile-Parameterization includes a modification of how a flux boundary condition is implemented. In other words, the ""specification of flux"" is separate from the ""imposition of a boundary condition"". The former is determined by the user. The latter is determined by the model/governing equation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472225606:28,parameteriz,parameterized,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472225606,2,"['Parameteriz', 'parameteriz']","['Parameterization', 'parameterized']"
Modifiability,"> yep broadcasting works. My thought was that `plan` can be hacked to store unified memory. I still have to look at the data structure to see how to do it.; > ; > cufftxt basically works in the same way (local FFT direction distributed among the workers then transpose and nonlocal FFT). I am not sure they use unified memory but they for sure use transposes https://on-demand.gputechconf.com/gtc/2014/presentations/S4788-rapid-multi-gpu-programming-cuda-libraries.pdf. Mmm ok. Is this proposal a way to avoid cuffxt basically? I think what you outlined is somehow roughly how PencilFTTs work:. 1. FFT along local direction (dim=1); 2. Simultaneously communicate and permute data to (2, 1, 3) (or is it (2, 3, 1)?); 3. FFT along local direction (dim=2); 4. Simultaneously communicate and permute data to (3, 2, 1); 5. FFT along dim=3. At the end, the data has permutation (3, 2, 1). The backwards transform then reverses this process. `solver.storage` is actually a tuple of 3 preallocated arrays to support this algorithm. For the tridiagonal solver I think we want to use the same algorithm, except that we skip step 1 (ie the first step is to communicate and permute data with no transform). Once the two other transforms are complete we have data in the configuration (x, y, z) where z is local, and we can do a tridiagonal solve in eigenfunction space. Then we transform back and obtain data back in the (z, y, x) permutation, with z local, and copy into the pressure. We have to extend the tridiagonal solver to accomodate this kind of permutation for distributed CPU, so if we have an algorithm like the one above we can then also use it for MultiRegionGrid solves on the GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119916674:1258,config,configuration,1258,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119916674,2,"['config', 'extend']","['configuration', 'extend']"
Modifiability,"> you are referring to including the horizontal components of the rotation vector within the tangent plane approximation?. Ah I should have been clearer. For the Cartesian domains we might want `FullCoriolis` but including the cosine term would only make sense if we're running on a sphere. > Do you think that we should not have the concept of a molecular transport coefficient at all?. I think it makes sense to have this, especially so that the default is a DNS. Not sure if this is the most common use case, in which case maybe we can spit out a warning to new users so they know what they're running. > The point is that density is not a variable in a Boussinesq code and the value of the reference density has no effect on the dynamics. This makes sense to me, but then I'm wondering if ρ₀ is important to know to calculate diagnostics etc. where should we store it? EOS makes the most sense to me as a storage place even though it doesn't influence the dynamics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491866754:643,variab,variable,643,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491866754,1,['variab'],['variable']
Modifiability,">@ChrisRackauckas can the constant-dt Runge-Kutta methods be adapted to accept a changing time-step? This is important because we often have external criteria available (the CFL criterion, for example) that can be used to adapt time-step size. Yes, you can adjust `dt` in a `DiscreteCallback`. . http://docs.juliadiffeq.org/latest/features/callback_functions.html. >Our implicit solves are usually coupled, such that they require the use of fast methods for the solution of elliptic PDEs to time-step efficiently (either the FFT-based algorithm described above, or a fast batched tridiagonal solver for the GPU that we are currently working on). Can the user provide their own fast solver for implicit time stepping with the split ODE solver?. Yes. http://docs.juliadiffeq.org/latest/features/linear_nonlinear.html",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/391#issuecomment-549187518:61,adapt,adapted,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/391#issuecomment-549187518,2,['adapt'],"['adapt', 'adapted']"
Modifiability,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:731,rewrite,rewrite,731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440,1,['rewrite'],['rewrite']
Modifiability,"@BrodiePearson I refactored `StokesDrifts.jl` very slightly --- I agree with the new terms you added!. I put together this script that reproduces the ""deep Eulerian return flow"" from McIntyre (1981):. ```julia; using Oceananigans; using Oceananigans.Units; using GLMakie. ϵ = 0.1; λ = 60 # meters; g = 9.81. const k = 2π / λ. c = sqrt(g / k); const δ = 1kilometer; const cᵍ = c / 2; const Uˢ = ϵ^2 * c. @inline A(ξ) = exp(- ξ^2 / 2δ^2); @inline A′(ξ) = - ξ / δ^2 * A(ξ); @inline A′′(ξ) = (ξ^2 / δ^2 - 1) * A(ξ) / δ^2. # Write the Stokes drift as; #; # uˢ(x, z, t) = A(x, t) * ûˢ(z); #; # which implies. @inline ûˢ(z) = Uˢ * exp(2k * z); @inline uˢ(x, z, t) = A(x - cᵍ * t) * ûˢ(z); @inline ∂z_uˢ(x, z, t) = 2k * A(x - cᵍ * t) * ûˢ(z); @inline ∂t_uˢ(x, z, t) = - cᵍ * A′(x - cᵍ * t) * ûˢ(z). # Note that if uˢ represents the solenoidal component of the Stokes drift,; # then; #; # ```math; # ∂z_wˢ = - ∂x_uˢ = - A′ * ûˢ .; # ```; #; # We therefore find that; #; # ```math; # wˢ = - A′ / 2k * ûˢ; # ```; #; # and. @inline ∂x_wˢ(x, z, t) = - 1 / 2k * A′′(x - cᵍ * t) * ûˢ(z); @inline ∂t_wˢ(x, z, t) = + cᵍ / 2k * A′′(x - cᵍ * t) * ûˢ(z). stokes_drift = StokesDrift(; ∂z_uˢ, ∂t_uˢ, ∂t_wˢ, ∂x_wˢ). grid = RectilinearGrid(size = (256, 64),; x = (-5kilometers, 15kilometers),; z = (-512, 0),; topology = (Periodic, Flat, Bounded)). model = NonhydrostaticModel(; grid, stokes_drift,; tracers = :b,; buoyancy = BuoyancyTracer(),; timestepper = :RungeKutta3). # Set Lagrangian-mean flow equal to uˢ,; uᵢ(x, z) = uˢ(x, z, 0). # And put in a stable stratification,; N² = 0; bᵢ(x, z) = N² * z; set!(model, u=uᵢ, b=bᵢ). Δx = xspacings(grid, Center()); Δt = 0.2 * Δx / cᵍ; simulation = Simulation(model; Δt, stop_iteration = 600). progress(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(10)). filename = ""surface_wave_induced_flow.jld2""; outputs = model.velocities; simulation.output_writers[:jld2] = JLD2Ou",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085:17,refactor,refactored,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085,1,['refactor'],['refactored']
Modifiability,"@ChrisRackauckas can the constant-dt Runge-Kutta methods be adapted to accept a changing time-step? This is important because we often have external criteria available (the CFL criterion, for example) that can be used to adapt time-step size. As for the fractional step method, we can also write a function that performs the fractional step algorithm using two substeps and an implicit pressure solve. Multiple fractional steps can then be embedded in a multi-step algorithm like Runge-Kutta; this may provide a route to integration with DifferentialEquations.jl. Note that the implicit pressure solves that forms the second part of the fractional step method requires a specialized fast solver for the 3D elliptic problem. We use this method:. https://www.sciencedirect.com/science/article/pii/0021999188901027. Integration with DifferentialEquations.jl will require integration of this FFT-based Poisson/Helmholtz solver into the algorithm. Our implicit solves are usually coupled, such that they require the use of fast methods for the solution of elliptic PDEs to time-step efficiently (either the FFT-based algorithm described above, or a fast batched tridiagonal solver for the GPU that we are currently working on). Can the user provide their own fast solver for implicit time stepping with the split ODE solver?. Our time-stepping method is roughly described here:. https://climate-machine.github.io/Oceananigans.jl/stable/manual/time_stepping/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/391#issuecomment-549149954:60,adapt,adapted,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/391#issuecomment-549149954,2,['adapt'],"['adapt', 'adapted']"
Modifiability,"@Mikejmnez , could you maybe say a bit more of what you are hoping to do? If you initialize your flow to have a constant shear, for example, then there is a velocity associated with that shear and it will evolve because of the mometnum equations. . If you wanted a simple toy problem, we might be able to do something with `ShallowWaterModel`. It might be simple enough for your purposes, depending on what you wanted to learn, but that would be orthogonal to this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768492710:205,evolve,evolve,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768492710,1,['evolve'],['evolve']
Modifiability,"@Tinydog8 let me know if you're ok to convert this to discussion. Here's a sketch of how to accumulate `u_wm`:. ```julia; u_wall_model = XFaceField(grid, indices=(:, :, 1)) # It's purely a niceity to specify `indices` properly here --- the only thing we really need is a 2D array. # Also define other velocity components as needed; # Define drag boundary condition in terms of u_wall_model, other velocity components, etc using the `discrete_form=true`. # This function is meant to be used in a callback; function compute_wall_model_velocity!(sim); u, v, w = sim.model.velocities. filtering_time_scale = 1.0 # seconds --- for example; ϵ = sim.Δt / filtering_time_scale. u_wm = interior(u_wall_model, :, :, 1) # extract a view to broadcast over; u_LES = interior(u, :, :, 1) # a view into the LES velocity within the first grid cell; @. u_wm = (1 - ϵ) * u_wm + ϵ * u_LES. # Compute other components as needed; return nothing; end. simulation.callbacks[:wall_model] = Callback(compute_wall_model_velocity!); ```. An even more slick approach would build new auxiliary fields for the wall model velocities. In that case (if I'm not mistaken), then the wall model velocities are accessible from the argument to the boundary condition function (and don't have to be referenced as global variables).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1654114493:1281,variab,variables,1281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1654114493,1,['variab'],['variables']
Modifiability,"@Yesse42, you might wanna have a look at:; https://clima.github.io/OceananigansDocumentation/stable/model_setup/time_stepping/; on how to set up adaptive time-step. (Note that with RK3 time-stepping could be ""OK"" to cap CFL at ~0.6 or 0.7.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-732862607:145,adapt,adaptive,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-732862607,1,['adapt'],['adaptive']
Modifiability,"@ali-ramadhan , the changes in #357 are minor: just some refactoring to permit more flexible interaction with the `JLD2OutputWriter` constructor. I'll push them in.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/382#issuecomment-526124121:57,refactor,refactoring,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/382#issuecomment-526124121,2,"['flexible', 'refactor']","['flexible', 'refactoring']"
Modifiability,"@ali-ramadhan I did some things with unitful.jl back in Sept 2019. It is really useful for checking formulae when it works, because you can check dimensions of results, intermediate computations etc.... At the time I tried it many other packages (plotting, static arrays, possibly MPI?) fell over when using Unitful variables - which kind of made it less useful. If those things have improved then @alanedelman is entitled to make fun, and it could be a useful thing to explore. . Certainly UnitfulRecipes.jl looks hopeful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1116#issuecomment-719781652:316,variab,variables,316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1116#issuecomment-719781652,1,['variab'],['variables']
Modifiability,"@ali-ramadhan OK, I switched to the ""multiple files"" version now. Few comments:; 1) diffusion.jl laplacian.jl and viscosity.jl are not right: should not involve Ax^2 and division by V^2 ; we talked about this already few times so no need to re-do it again.; 2) In coriolis.jl, the comments are misleading since one of the 2 expressions should have a minus sign ; to match: ""Operators that calculate the Corolis terms"". cf my old suggestion that has been dropped along the way.; 3) in ""divergence.jl"", line 25 should be with ""Ax(i+1, j ,k, grid)"" instead of ""Ax(i, j, k, grid)""; ans same issue line 31 and line 41.; 4) I did not find where ϊx_V⁻¹ is defined. It appears in ""momentum_advection.jl"" (line 31) and should be; computed as 1/(V-averaged) but the notation might suggest (1/V)_averaged.; 5) will need to check again when we consider ""practical"" variable resolution (e.g., varable in z); that everything looks good.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-504556418:854,variab,variable,854,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-504556418,1,['variab'],['variable']
Modifiability,@ali-ramadhan Should we close this PR since @simone-silvestri completely refactored WENO5?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1238#issuecomment-982612992:73,refactor,refactored,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1238#issuecomment-982612992,1,['refactor'],['refactored']
Modifiability,"@ali-ramadhan a few more comments:. - I don't understand why the temperature profiles you've plotted have spikes in them, especially since they are horizontal averages. What's going on? The sub grid scale diffusivities also seem to have far too much variance. - Can you plot multiple equilibrated horizontally averaged solutions for differing model constant `C`? I think we may need to determine the correct value of this constant for our numerical method in order for our results to match. It looks like the SGS diffusivity values are too small, so this might help... - We can't be sure what resolution an `Oceananigans.jl` model needs to be to match Diablo results, since Diablo uses a spectral discretization in the horizontal. That's something to keep in mind. Note also that V&T take the spectral discretization into account when defining their 'filter widths' in their AMD implementation. - If our results matched Diablo *without* resolving the viscous boundary layer near the walls, I think this would not constitute a verification of Oceananigans (instead, it would indicate a problem with Oceananigans, or the presence of some kind of 'cancellation of errors'). We must resolve the viscous boundary layers near the walls in this experiment for the results to be valid. For reference, the AMD viscosity is calculated here:. https://github.com/climate-machine/Oceananigans.jl/blob/352c018b6cb8801500bae61ac858ddc146bf3f48/src/turbulence_closures/anisotropic_minimum_dissipation.jl#L50. the diffusivities are similar.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-522567655:1208,layers,layers,1208,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-522567655,1,['layers'],['layers']
Modifiability,"@ali-ramadhan agree that good performance would be great. I think that having a flexible and maximally useful feature might be a higher priority though. @johncmarshall54 's requirements provide a good design target, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-733191938:80,flexible,flexible,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-733191938,1,['flexible'],['flexible']
Modifiability,@ali-ramadhan and @glwagner this looks promising. Does it make sense to nuke sandbox stuff in this? It seems a bit orthogonal to the rest of the PR? Is it meant to be in there?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/312#issuecomment-514608840:77,sandbox,sandbox,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/312#issuecomment-514608840,1,['sandbox'],['sandbox']
Modifiability,"@ali-ramadhan does makes a fair point. But there will be some learning curve either way... The user should either know some git, or they should be familiar with Julia's syntax, or Julia's project management (`julia --project=...`). To that extend, perhaps the doc instructions could suggest few avenues that the user can start running the examples. Cloning the repo could be one of them. But also copy-paste from the docs after ensuring the the proper `Project.toml` is instantiated could also be a viable option!. By the way Literate.jl provides ways to output the examples in different forms other than markdown for the docs.; https://fredrikekre.github.io/Literate.jl/v2/outputformats/; With some pre/postprocessing we can have Literate.jl strip out things like `nothing #hide` and then point the users to cleaner `.jl` scripts or Jupyter notebooks.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1149#issuecomment-724231746:240,extend,extend,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1149#issuecomment-724231746,1,['extend'],['extend']
Modifiability,"@ali-ramadhan here is my proposed re-factor of the poisson solver:. https://github.com/glwagner/Oceananigans.jl/blob/poisson-solver-refactor/src/poisson_solver.jl. Now may be the right time to move it to a new package, because we can run the tests independent from oceananigans before refactoring oceananigans itself.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/106#issuecomment-469743283:132,refactor,refactor,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/106#issuecomment-469743283,2,['refactor'],"['refactor', 'refactoring']"
Modifiability,@ali-ramadhan it isn't ready yet --- still need to refactor the RHS calculation to incorporate the (now-pre-computed) turbulent diffusivities.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/312#issuecomment-511409356:51,refactor,refactor,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/312#issuecomment-511409356,1,['refactor'],['refactor']
Modifiability,@ali-ramadhan let's focus first on #3801 and then we can revisit this PR. There are some additional challenges to resolving #3791 unfortunately that will also require some test refactoring.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2383828408:177,refactor,refactoring,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2383828408,1,['refactor'],['refactoring']
Modifiability,"@ali-ramadhan should we merge? We might want to redo this experiment with new time-stepper and advection schemes, at which point we can rewrite the plotting script if we desire.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/572#issuecomment-694266496:136,rewrite,rewrite,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/572#issuecomment-694266496,1,['rewrite'],['rewrite']
Modifiability,"@ali-ramadhan there is no explicit reason why the LES closure itself would fail adjacent to a non-flat boundary. However, typically momentum fluxes associated with a no slip condition have to be parameterized (which you could view as an extension of the LES closure) in wall-bounded LES.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/530#issuecomment-553520575:195,parameteriz,parameterized,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/530#issuecomment-553520575,1,['parameteriz'],['parameterized']
Modifiability,"@ali-ramadhan would it be good to send messages to everyone who has a fork maybe and maybe keep an issue open, so people who have cloned can see? Of course it would also be good not to rewrite the history - that pretty much breaks how git works. In theory reviewing PRs should catch this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/598#issuecomment-577221566:185,rewrite,rewrite,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/598#issuecomment-577221566,1,['rewrite'],['rewrite']
Modifiability,"@ali-ramadhan, gitlab run needs to be restarted. Not sure why the `mesoscale-closures` shows up; we only need `mesoscale-closures-kernel-refactor`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/515#issuecomment-548089421:137,refactor,refactor,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/515#issuecomment-548089421,1,['refactor'],['refactor']
Modifiability,"@ali-ramadhan, indeed I tried to use Gitlab CI with FourierFlows but I never managed to have it running. Then we did a major refactor of FourierFlows and the GPU functionality moved to CuFourierFlows.jl. We need to get back to it...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/53#issuecomment-464864588:125,refactor,refactor,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/53#issuecomment-464864588,1,['refactor'],['refactor']
Modifiability,"@ali-ramadhan, the docs log says:; ```; ┌ Info:;   | │ Buildkite config:;   | │ Commit branch: ""tomchor-patch-1"";   | │ Pull request: ""false"";   | │ Commit tag: """";   | │ Detected build type: devbranch;   | │ - ✘ ENV[""BUILDKITE_BRANCH""] matches devbranch=""master"";   | │ - ✔ ENV[""DOCUMENTER_KEY""] exists;   | └ Deploying to folder ""dev"": ✘; ```; Seems like buildkite will only reply from master? I don't see where that setting in buildkite is though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782282187:65,config,config,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782282187,1,['config'],['config']
Modifiability,"@beta-effect to follow up on my previous comment, here is what I suggest:. ```julia; # Variables used as globals in functions must be declared const to work on GPU; const plume_flux = 1e-8 # set to desired temperature flux; const plume_radius = 50; @inline radius(i, j, grid) = @inbounds sqrt((grid.xC[i] - grid.Lx/2)^2 + (grid.yC[j] - grid.Ly/2)^2); @inline bottom_flux(i, j, grid, args...) = ifelse(radius(i, j, grid) < plume_radius, plume_flux, 0.0). # Create boundary condition for temperature; Tbcs = HorizontallyPeriodicBCs(bottom = BoundaryCondition(Flux, bottom_flux))); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/314#issuecomment-517800004:87,Variab,Variables,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/314#issuecomment-517800004,1,['Variab'],['Variables']
Modifiability,"@elise-palethorpe, I don't see the AMGX package in `Project.toml` nor in `Manifest.toml`. Btw, when I tried to add it locally on my Mac I got this:. ```Julia; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (Oceananigans) pkg> st; Project Oceananigans v0.77.1; Status `~/Research/OC.jl/Project.toml`; [c963dde9] AMGX v0.1.2; [79e6a3ab] Adapt v3.3.3; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.11.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:564,Adapt,Adapt,564,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987,1,['Adapt'],['Adapt']
Modifiability,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:543,variab,variables,543,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441,1,['variab'],['variables']
Modifiability,"@francispoulin and I ran some of the strong and weak scaling scripts recently up to 128 CPU cores. An extra bit of code was added into the files that handled the plotting. Also added was a small but vital configuration adjustment for the @benchmark macro which allowed for more than 64 cores to be benchmarked without what is perceived as deadlocking from occurring. I will PR my all my changes made to the benchmarking scripts shortly. Here are the results:. weak scaling shallow water model, with grid size being 8192 x 512R where R is the number of cores:; ```; ┌───────────────┬──────────┬─────────┬─────────┬─────────┬─────────┬──────────┬────────┬─────────┐; │ size │ ranks │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼──────────┼─────────┼─────────┼─────────┼─────────┼──────────┼────────┼─────────┤; │ (8192, 512) │ (1, 1) │ 1.464 s │ 1.464 s │ 1.465 s │ 1.466 s │ 1.60 MiB │ 2804 │ 4 │; │ (8192, 1024) │ (1, 2) │ 1.475 s │ 1.475 s │ 1.477 s │ 1.486 s │ 1.49 MiB │ 3146 │ 8 │; │ (8192, 2048) │ (1, 4) │ 1.472 s │ 1.475 s │ 1.477 s │ 1.509 s │ 1.49 MiB │ 3146 │ 16 │; │ (8192, 4096) │ (1, 8) │ 1.500 s │ 1.503 s │ 1.508 s │ 1.537 s │ 1.49 MiB │ 3146 │ 32 │; │ (8192, 8192) │ (1, 16) │ 1.545 s │ 1.578 s │ 1.593 s │ 1.682 s │ 1.49 MiB │ 3146 │ 64 │; │ (8192, 16384) │ (1, 32) │ 1.744 s │ 1.803 s │ 1.805 s │ 1.894 s │ 1.49 MiB │ 3146 │ 96 │; │ (8192, 32768) │ (1, 64) │ 1.723 s │ 1.792 s │ 1.795 s │ 1.868 s │ 1.49 MiB │ 3155 │ 192 │; │ (8192, 65536) │ (1, 128) │ 1.679 s │ 1.809 s │ 1.811 s │ 1.907 s │ 1.49 MiB │ 3155 │ 384 │; └───────────────┴──────────┴─────────┴─────────┴─────────┴─────────┴──────────┴────────┴─────────┘. Shallow water model weak scaling speedup; ┌───────────────┬──────────┬──────────┬────────────┬──────────┬─────────┐; │ size │ ranks │ slowdown │ efficiency │ memory │ allocs │; ├───────────────┼──────────┼──────────┼────────────┼──────────┼─────────┤; │ (8192, 512) │ (1, 1) │ 1.0 │ 1.0 │ 1.0 │ 1.0 │; │ (8192, 1024) │ (1, 2) │ 1.00706",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-864572422:205,config,configuration,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-864572422,1,['config'],['configuration']
Modifiability,"@francispoulin explained the situation well for `Gradient` and `Value` boundary conditions. I'd like to restate what he said in the context of the finite volume method and clarify the situation for `Flux` boundary conditions because I said something wrong above... Oceananigans uses a weak formulation of PDEs via the finite volume method. We evolve the average value of fields, integrated over a cell volume. In this integral formulation there are two contributions to the tendency of a field: fluxes across cell interfaces (advective and diffusive usually, but also possibly others via user-defined forcing), and interior ""sources"" (such as pressure gradients, Coriolis forces, gravitational forces). When users invoke `Gradient` or `Value` boundary conditions, then the same model is used for fluxes across interior cell interfaces as for ""exterior"" interfaces (domain boundaries). Thus if users set `closure=nothing` and zero out diffusive fluxes, boundary fluxes are _always_ zero regardless of what `Gradient` or `Value` are specified. More specifically, we enforce `Gradient` or `Value` boundary conditions by filling halo regions and then calculating exterior fluxes using the same kernel that's evaluated in the interior. As @francispoulin points out this is not some quirk of our algorithm or numerics; this follows from the properties of the underlying PDE. Something different happens when `Flux` boundary conditions are specified and this is where I was wrong above. With `Flux` boundary conditions, users are really specifying two _different_ models for fluxes: one across ""interior"" cell interfaces, and another for fluxes across domain boundaries. Setting `closure=nothing` in this case only nullifies _interior_ diffusive fluxes. But since boundary fluxes are explicitly specified in this case, they still do have an impact on interior tendency values. . A further subtlety is that `Value` and `Gradient` boundary conditions do actually have an impact if there is non-zero `NormalFlow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-832093191:343,evolve,evolve,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-832093191,1,['evolve'],['evolve']
Modifiability,"@francispoulin thanks for starting this discussion!. Broadly speaking I think we would like to implement an arbitrary Lagrangian-Eulerian vertical coordinate in the long run. As far as I understand, implementing an ALE scheme would require more changes than just a new `AbstractGrid`. We need to modify the time-stepping to include a regridding / interpolation stage, and I believe we also need to change the equations being solved (the tendency kernels). . My preliminary thought on software design is that this might be a new model property, something like `HydrostaticFreeSurfaceModel.vertical_coordinate`. Then one needs to interpret the z-coordinate in the chosen `HydrostaticFreeSurfaceModel.grid` in light of the choice of `HydrostaticFreeSurfaceModel.vertical_coordinate`. Other design ideas are certainly welcome!. Something less clear is what happens if we design a terrain following coordinate. Perhaps you are write @francispoulin that terrain following coordinates can be implemented purely by introducing a new type of grid (because the grid is not moving... ?) I think terrain-following, curvilinear grid would require three-dimensionally curvilinear operators, correct? So we would have to update the implementation of the `HydrostaticFreeSurfaceModel` operators as well. As for a horizontal grid for `ShallowWaterModel`, since we have horizontally-curvilinear operators I think you might be able to do `boundary_following` in the horizontal once you refactor `ShallowWaterModel` to use horizontally-curvilinear operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814206629:1467,refactor,refactor,1467,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814206629,1,['refactor'],['refactor']
Modifiability,"@francispoulin, sure, I'd like to discuss the implementation of advection in the `ShallowWaterModel`. We can also zoom if you want, send me an email and we can see when we both have time. @christophernhill I'll take a look at that! It will be nice when implementing the cubed sphere. @pvthinker thanks for the comment! In this case vorticity is still the quantity being upwinded. I agree that upwinding the velocity would lead to errors since you have to ensure consistency in `div(U)` which you break by using an upwinding stencil for U (at least on a C-grid). ; Here I just relied on U to assess the ""smoothness"" of the vorticity stencils for upwinding. (if we look it in an ENO fashion, the choice of wether to upwind strongly or use a (less dissipative) centered stencil for vorticity relies on the velocity field rather than the vorticity field). . This might also be consistent with how you choose the stencils in the advection of tracers, where the choice is based on the evolved quantity (I have no mathematical proof in this case). I agree though, that maybe some more quantitative study is required to ensure that this method plays nicely. Just to share, these are the spectra (KE and enstrophy) at the final time step of the _immersed_ simulation shown above compared with a 2nd oder vector invariant (ensthrophy conserving) scheme with additional biharmonic viscosity (at a resolution of 1024^2) ; ![vel_x_spec-bih](https://user-images.githubusercontent.com/33547697/160655542-18b59170-a928-44ac-85f4-60b22b8e8dce.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1082056720:979,evolve,evolved,979,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1082056720,1,['evolve'],['evolved']
Modifiability,"@glwagner ,. So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:. ```julia; lamb = 1 # decay scale for slip velocity in meters; @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); sinking = SlipVelocity(WENO5(), w=w); ```. The way the code is, does it accept functions for velocity inputs?; Is that something I could do to help you?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083104129:118,adapt,adapted,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083104129,1,['adapt'],['adapted']
Modifiability,"@glwagner ; I am really impressed with your effort to explain to me all details of the implementation. Thanks you!; In the past few days I am learning a lot reading the code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks fo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:300,parameteriz,parameterization,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688,2,['parameteriz'],['parameterization']
Modifiability,"@glwagner ; I should have reviewed your code instead, right?. This is now complaining about `af` variable; `nested task error: UndefVarError: af not defined`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082105665:97,variab,variable,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082105665,1,['variab'],['variable']
Modifiability,"@glwagner @simone-silvestri I took the liberty to modifying the [release notes for v0.84.0](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.84.0) to illustrate what my idea here was. @glwagner had already included something but I extended it a bit. Basically a user reading the release notes know quickly what changed: `compression` kwarg is gone and is replaced by `deflatelevel` (which also link directly to https://github.com/CliMA/Oceananigans.jl/pull/3153 for more info) and there's a quick summary of changes to `VectorInvariant` also with a link to https://github.com/CliMA/Oceananigans.jl/pull/3091. @simone-silvestri reading the description of https://github.com/CliMA/Oceananigans.jl/pull/3091 I couldn't understand what was breaking about that change. Seems like it just added more features/kwargs, with isn't necessarily breaking. Feel free to modify my description to clairfy. I also included a ""highlights"" section, which quickly points to a user what new features are available. At this point it only references to https://github.com/CliMA/Oceananigans.jl/pull/3145, but I think https://github.com/CliMA/Oceananigans.jl/pull/3145 probably should be there too; I just don't understand it well enough to be sure and summarize everything with a simple sentence. Feel free to add. This ""highlights"" section may be a bit repetitive, since similar information is contained in the list of PRs at the bottom. But my rationale is that most of those PRs don't really affect an average user (for example the doc examples parallelization is super important, but not relevant to users), so most people probably won't read their description. In any case, feel free to modify or undo what I wrote there. I did it mostly for illustration purposes :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754:239,extend,extended,239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754,1,['extend'],['extended']
Modifiability,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426:369,layers,layers,369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426,1,['layers'],['layers']
Modifiability,@glwagner Do you think you'll have some time to review this PR this week?. It affects a lot of code you've written and is a bit of a bottleneck as it refactors a lot of the existing code.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/529#issuecomment-558325070:150,refactor,refactors,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/529#issuecomment-558325070,1,['refactor'],['refactors']
Modifiability,"@glwagner I created a new issue using your comment as it wasn't very relevant to the original issue. I agree that it's not guaranteed to be in bounds by itself. I guess we guarantee it by looping over the correct indices but this isn't the cleanest way. I think you're right that this belongs at the loop level where we can enclose the loop inside an `@inbounds` block and `@propagate_inbounds` to inlined functions. I think @peterahrens suggested using `@propagate_inbounds` a while back (#58), and @vchuravy (https://github.com/climate-machine/Oceananigans.jl/issues/13#issuecomment-479851704) just suggested this as well. Would definitely be good to refactor the code to do this. Also see: https://docs.julialang.org/en/v1/devdocs/boundscheck/index.html#Propagating-inbounds-1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/164#issuecomment-479854601:653,refactor,refactor,653,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/164#issuecomment-479854601,1,['refactor'],['refactor']
Modifiability,@glwagner I won't ask for git history rewrite now but let's not get into the habit of calling me Dr Constantinou.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-777882397:38,rewrite,rewrite,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-777882397,1,['rewrite'],['rewrite']
Modifiability,"@glwagner Sorry for a late response. The current implementation I have going projects the velocity into tangential and normal directions (with respect to the immersed surface) before interpolating over the boundary. Since the boundary can be pretty variable in made more sense for us to take this approach. So the user would specify what they want the two tangential and 1 normal direction to be instead of (u,v,w) specifically. Obviously with tracers there is no projection because it's not a vector like that. I know this is a little different than the fitted version, because it's a little harder to specify a normal direction in that case, and also different from what you do for the usual boundary condition. My interpolation can handle Neumann and Dirichlet ie. `Value` and `Gradient` and the original idea was to infer `Flux` from `Gradient`, but right now everything is hard coded in. The normal and tangential though, would not hold with the current boundary condition set up with `North` or `East` or `Top` etc, but I don't think it would be hard to have whatever implementation is decided and just have 'Tang' and 'Normal' or whatever as well?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850539557:249,variab,variable,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850539557,1,['variab'],['variable']
Modifiability,"@glwagner These changes look great!. I fixed some typos in the refactored file, which were terms that would not have affected your new validation case. I moved my original example to validation and provided some minor tweaks to your first validation case. I did not look much at the ``surface_wave_quasi_geostrophic_flow.jl`` case you created",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1836775430:63,refactor,refactored,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1836775430,1,['refactor'],['refactored']
Modifiability,"@glwagner Yeah, what I am interested is in evolving, say the 2D advection diffusion equation, with a prescribed (time-independent) shear flow. No need to evolve the velocity field, it is just defined by the user (e.g. a cellular flow, a jet, etc).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768486665:154,evolve,evolve,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768486665,1,['evolve'],['evolve']
Modifiability,"@glwagner and @simone-silvestri . Continuing the discussion.; https://github.com/CliMA/Oceananigans.jl/discussions/2788#discussioncomment-8101280. It looks like MPI needs to be initialized before accessing its communication variables. Thus, despite calling `Distributed` initializes MPI, we need to access `Nranks = MPI.Comm_size(comm)` before to define `Partition`. https://github.com/CliMA/Oceananigans.jl/blob/294602781e7a678ef3a662e1a31d2145d10d0800/validation/distributed_simulations/distributed_nonhydrostatic_turbulence.jl#L20-L22. Should we initialize MPI when importing DistributedComputations?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890460124:224,variab,variables,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890460124,1,['variab'],['variables']
Modifiability,"@glwagner can you review this? The failures seem unrelated, e.g. `Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64})` and I'm not sure what already is expected to fail",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1863593838:140,Adapt,Adapt,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1863593838,2,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,@glwagner have a look at the rewrite.; https://clima.github.io/OceananigansDocumentation/previews/PR1125/generated/kelvin_helmholtz_instability/,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-722122990:29,rewrite,rewrite,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-722122990,1,['rewrite'],['rewrite']
Modifiability,"@glwagner or @ali-ramadhan probably can change that. I actually like the description as is. :); I'd probably just add the ""flexible"" to the current description: ""A flexible oceanic...""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-955788563:123,flexible,flexible,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-955788563,2,['flexible'],['flexible']
Modifiability,"@glwagner the idea is that the flow of the script for a user would be something like this:. (1) define a grid; (2) choose an architecture; .; .; code does not change from here on; .; . for this reason I was thinking you cannot have a `DistributedNonhydrostaticModel` vs a `NonhydrostaticModel` as much as you don't have a `CPUNonhydrostaticModel` vs a `GPUNonhydrostaticModel`. About the future direction: I was thinking that `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:560,extend,extends,560,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,3,['extend'],"['extend', 'extending', 'extends']"
Modifiability,@glwagner the important changes are basically the `Advection` module and `conditional_fluxes.jl` in the `ImmersedBoundaries` module. The rest is only adapting here and there (and some small bugfixes in immersed boundaries and shallow water module),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177988301:150,adapt,adapting,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177988301,1,['adapt'],['adapting']
Modifiability,"@glwagner yes, that was more along the lines of what I was saying. From the docs it seemed to me using a Gaussian mask in the relaxation should be equivalent to a sponge layer, which is why I expected the gaussian function to be set-up with a sharp cut-off. But I think we're on the same page about what a sponge layer should be. . So I think it may be a matter of maybe making the docs clearer? Maybe also, like you said, constructing an example that uses sponge layers (I think there's an issue about there somewhere, right?). The Langmuir example might a good one. In the original paper by Jim they use a radiation boundary condition at the bottom which doesn't have an analog in the Langmuir example at the moment.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733365742:464,layers,layers,464,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733365742,1,['layers'],['layers']
Modifiability,"@glwagner, @simone-silvestri: Question: How is Δx^faa, defined for the F at the edge of the domain?. Is it the distance between `C[1] - F[1]`? (don't think so...); Or distance between `C[1] - C[0]`?. For a curvilinear grid with variable distances (as the `OrthogonalSphericalShellGrid` we need to compute where the halo faces and centers would be if we actually extended the grid, right? We can't just replicate the `C[2] - C[1]` distances `Hx` times...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384614027:228,variab,variable,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384614027,2,"['extend', 'variab']","['extended', 'variable']"
Modifiability,"@glwagner, I think there was a misunderstanding about the test failing. For the background-flux-divergence PR, we were just confused as to why it wasn't passing the existing test suite. The separate issue of adding a new test is for the [unrelated PR](https://github.com/CliMA/Oceananigans.jl/pull/3721) related to refactoring `AveragedTimeInterval` to fix the existing bug. @liuchihl has some local branches where he'd merged both of those and was testing them in combination, so we got our signals crossed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3862#issuecomment-2433728389:315,refactor,refactoring,315,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3862#issuecomment-2433728389,1,['refactor'],['refactoring']
Modifiability,"@glwagner, I think you're right that the error is coming from this line:; https://github.com/CliMA/Oceananigans.jl/blob/10a9479ec462f4f5f053e7447ff667fdfe20542d/src/Distributed/distributed_fft_based_poisson_solver.jl#L65; I checked the sizes of these variables, and here xc is sized on the global grid while lambda x is sized on the local grid. I'm not sure which grid this operation is intended to be performed on. The code here is impressively compact but not particularly easy to decipher (at least for me).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067340658:251,variab,variables,251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067340658,1,['variab'],['variables']
Modifiability,"@iuryt speaks truth... it's hard to say something _isn't_ ""feasible"". However, I do think that polishing off an n-layer extension of the existing ShallowWaterModel would require some time. I think you want to write not only the continuous equations, but also the finite volume discretization (and there's some issues around discretization of the advection operator now see #1866). There are some design questions regarding the user interface and the use of existing grids. One possibility is to use the existing grids (which all have a z-coordinate) to specify the _number_ of layers (via the vertical size), but to ignore the vertical grid. Then users would also have to input the buoyancy of each layer (I think I'd prefer buoyancy to density, if that's possible...) But another design might be possible that ""re-uses"" whatever users provide for the vertical grid. I just took a look at the code and was surprised to notice that all of the kernels and fields are already three-dimensional. That means that once the user interface is figured out and appropriate model modifications are made, the ""only"" thing left might be to generalize the kernels... I'm not sure how you do immersed boundaries, or how you blend ""explicit"" bathymetry (added through the pressure gradient) and immersed boundaries. Does anyone know?. @apaloczy may also be interested in this discussion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115530176:577,layers,layers,577,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115530176,1,['layers'],['layers']
Modifiability,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:513,refactor,refactoring,513,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444,4,"['config', 'refactor']","['configurations', 'refactor', 'refactoring']"
Modifiability,@jm-c there are two `ivd_diagonal` functions --- which one do you mean? Here are the two:. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl#L52-L59. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl#L75-L82. We should adapt this dynamics test:. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/test/test_dynamics.jl#L447. to use a vertically-stretched grid. Hopefully that would isolate this issue.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-973700892:419,adapt,adapt,419,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-973700892,1,['adapt'],['adapt']
Modifiability,"@jmbeckers thanks for the delucidation! Indeed, a conservative discretization might be more ""natural"" (have better discrete properties) in terms of momentum conservation. Especially because vector invariant formulations do not conserve momentum but angular momentum. @francispoulin, indeed, I think that, for a one layer model explicit dissipation might not be necessary because the noise associated with a horizontal velocity divergence is encoded in the mass equation which is discretized with a WENO formulation also (another way of repeating what @glwagner said). This is the difference with the hydrostatic model where we do not explicitly evolve a prognostic equation for the vertical velocity and we have to explicitly damp the noise contained in the vertical velocity `w` through a divergence damping closure. So you can think at that ""divergence damping"" closure as a ""WENO"" for an hypothetical `w` equation (which we have in the shallow water equations explicitly trough `h`). I agree also that we should introduce a diffusion term anyways. It is always good to be able to quickly quantify the dissipation you have in your model and with implicit dissipation that is very difficult (implicit LES is frowned upon by many purist of turbulence). for the documentation problem I think it's just because I changed the example. I ll fix the test",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1120046380:645,evolve,evolve,645,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1120046380,1,['evolve'],['evolve']
Modifiability,"@johncmarshall54 that would be nice I agree! But not super easy. I've concentrated on tools in `OceanTurb` that allow us to quickly develop new models (abstractions for time-stepping, PDEs, macros for declaring the prognostic variables in a PDE, etc). . These tools *could* be implemented in `Oceananigans` (I'd love to, in fact) but it's not copy and paste. Not only would they require substantial changes to Oceananigans (more abstraction, decoupling of the time stepper from equation specification, etc), there there will likely be some challenges adapting `OceanTurb` ideas to the GPU. . We will need to start using `Oceananigans.jl` eventually to develop parameterizations for the mesoscale problem. For that, we will probably want to use `Oceananigans` as both our 'data' (high-res model) and as 'model' (low-res model with parameterization). For this effort we *will* need some of the abstractions developed for `OceanTurb` to easily change the underlying PDE implemented in `Oceananigans.jl` and develop/implement new and radical paramterization ideas.. So this process may begin soon, but it will be gradual. . That said, hopefully it *can* begin in a few months after I have wrapped up the column modeling work and (with everyone's blessing) turned my attention to the mesoscale problem. It's been nice to keep them separate so far --- I've made a lot of drastic and breaking changes to `OceanTurb` in my quest to prototype and refine abstraction techniques. I think the current PR #210 is an example of what we should do with increasing frequency in the next few months --- take ideas that have been developed in `OceanTurb` (in 1D) and reimplement them in 3D in `Oceananigans`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/174#issuecomment-486742843:226,variab,variables,226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/174#issuecomment-486742843,4,"['adapt', 'parameteriz', 'variab']","['adapting', 'parameterization', 'parameterizations', 'variables']"
Modifiability,"@masonrogers14 Thanks for looking into this and writing up some notes! That's pretty cool that there's an explicit formula for inverting a symmetric tridiagonal matrix. While it is explicit, it seems that you have to solve an implicit equation for λ but that only has to be done once. Yeah I guess this wouldn't generalize to a vertically stretched grid with variable Δz as each row is different now, but the same derivation in the notes can be used to reach the tridiagonal system required. Indeed, the batched tridiagonal solver in `Oceananigans.Solvers` used a slightly modified TDMA algorithm. ---. @masonrogers14 On another note, @rafferrari, @glwagner, and I were talking about your simulation yesterday. Implicit time-stepping for diffusion may not be the most useful feature as it sounds like you want ""realistic"" values for the viscosity ν and diffusivity κ (@rafferrari was thinking 10⁻⁴ m²/s), whereas implicit diffusion helps when your diffusion is very high. High diffusion may be eroding away your isopycnals when you're hoping for them to slope (although I think you just had high ν). But I think you reported that the model tends to blow up when ν and κ are too small. I think this could be related to the second-order advection scheme which is known to introduce numerical oscillations/artifacts which require a high enough diffusivity to smooth out and keep the model stable. To get around this issue you should probably increase the resolution of your model (add more grid points) so you can keep using a small ν and κ (and hopefully a much larger time step than 20 seconds). I think you're using the `TimeStepWizard` so you can just set the maximum time step to be something like 0.1Δz²/2κ. For small κ like 10⁻⁴ m²/s and Δz ~ 10 m the maximum time step to keep diffusion stable should still be multiple hours and the `TimeStepWizard` will probably just limit the time step according to the CFL condition to keep advection stable. Hopefully the increased time step should help a lo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/587#issuecomment-573038475:359,variab,variable,359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/587#issuecomment-573038475,1,['variab'],['variable']
Modifiability,"@matinraayai I made a bunch of suggestions!. I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`. Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like. ```julia; using Oceananigans; grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO5()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ); simulation = Simulation(model; Δt=0.01, stop_time=4); run!(simulation); ```. should be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085:131,refactor,refactor,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085,1,['refactor'],['refactor']
Modifiability,"@matinraayai I think it will also help us get those tests passing quicker, because keeping `GPU` will allow us to avoid refactoring a lot of existing code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2493#issuecomment-1112369281:120,refactor,refactoring,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2493#issuecomment-1112369281,1,['refactor'],['refactoring']
Modifiability,"@matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. ; For the moment those two elements are part of this PR. This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft,; the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521:420,config,configuration,420,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521,1,['config'],['configuration']
Modifiability,"@mncrowe it sounds like this happened when you weren't using adaptive time-stepping --- which is nice because it will help us construct an MWE more easily. Do you think you can help with that? We just need a very simple simulation that reproduces the issue, hopefully something 0D with no dynamics that runs fast.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3614#issuecomment-2150474033:61,adapt,adaptive,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3614#issuecomment-2150474033,1,['adapt'],['adaptive']
Modifiability,"@navidcy . I just sent you an invite to the overleaf document. I thought maybe we want to have both the tracer and momentum equations before we create a PR, but I'm flexible. Thanks also for the reference. I remember seeing this paper before and liking it so I will look at it again. It seems that our advection schemes use the cell-averaged velocity to approximate the velocity at the edge. This is a perfectly valid choice and corresponds to a certain order of accuracy. I don't know what that is but I imagine using more cell averaged velocities would give a higher order accuracy. I'm not suggesting we do this, but I'm just trying to get a better understanding of the order of accuracy.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874314460:165,flexible,flexible,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874314460,1,['flexible'],['flexible']
Modifiability,"@navidcy Good call! ; You can find here below the output of benchmarks/benchmark_advection_schemes.jl ran on main and this PR and adapted to test the new methods.; For validation, you can run validation/advection/validate_weno_schemes.jl to validate the methods on a 1D and 2D advection problem for different grids; (uniform and stretched). execution of benchmark_advection_schemes.jl on main; ```; ┌───────────────┬────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ Architectures │ Schemes │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼────────────────────────┼───────────┼───────────┼───────────┼───────────┼──────────┼────────┼─────────┤; │ CPU │ CenteredFourthOrder │ 1.779 s │ 1.789 s │ 1.794 s │ 1.814 s │ 1.05 MiB │ 1685 │ 3 │; │ CPU │ CenteredSecondOrder │ 1.018 s │ 1.066 s │ 1.061 s │ 1.090 s │ 1.05 MiB │ 1685 │ 5 │; │ CPU │ UpwindBiasedFifthOrder │ 2.467 s │ 2.505 s │ 2.505 s │ 2.544 s │ 1.05 MiB │ 1685 │ 2 │; │ CPU │ UpwindBiasedThirdOrder │ 1.808 s │ 1.877 s │ 1.862 s │ 1.903 s │ 1.05 MiB │ 1685 │ 3 │; │ CPU │ WENO5 │ 6.775 s │ 6.775 s │ 6.775 s │ 6.775 s │ 1.05 MiB │ 1685 │ 1 │; │ GPU │ CenteredFourthOrder │ 20.879 ms │ 20.970 ms │ 21.078 ms │ 21.874 ms │ 2.17 MiB │ 20610 │ 10 │; │ GPU │ CenteredSecondOrder │ 11.402 ms │ 15.533 ms │ 15.138 ms │ 15.680 ms │ 2.05 MiB │ 13147 │ 10 │; │ GPU │ UpwindBiasedFifthOrder │ 23.356 ms │ 23.498 ms │ 24.055 ms │ 29.246 ms │ 2.21 MiB │ 23281 │ 10 │; │ GPU │ UpwindBiasedThirdOrder │ 18.863 ms │ 19.027 ms │ 19.298 ms │ 21.745 ms │ 2.12 MiB │ 17945 │ 10 │; │ GPU │ WENO5 │ 23.234 ms │ 28.467 ms │ 27.982 ms │ 28.684 ms │ 2.30 MiB │ 29259 │ 10 │; └───────────────┴────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────────┴─────────┘; ```; This PR same file, (WENO5 on uniform grids); ```; ┌───────────────┬────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ Architec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:130,adapt,adapted,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738,1,['adapt'],['adapted']
Modifiability,"@navidcy Hmmm, digging into Documenter.jl's Buildkite config it looks like push previews are only provided if the build belongs to a PR?. https://github.com/JuliaDocs/Documenter.jl/blob/4be8243d31a6ffdbc64d779e3f8c2fb7c61de075/src/deployconfig.jl#L719-L725 . Maybe there was no push preview here since @tomchor pushed this branch at which Buildkite ran, before the PR existed, so Buildkite did not publish a preview. Maybe if a second commit was made on this PR, it would be detected by Buildkite as a PR and therefore a preview would be published?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782289428:54,config,config,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782289428,1,['config'],['config']
Modifiability,"@navidcy PyPlot is used for the log2 scale for the x-axis of certain graphs. The normal backend of Plots,jl only has natural log scale axis option. Log-base-2 scale works best for these plots since most of them have an independent variable that scales based on powers of 2. The inclusion of Oceananigans in `benchmark/Project.toml` is likely due to a Julia package config suggested by @ali-ramadhan. What was done was that in Julia's package manager, `dev ..` was inputted to enable what I assume is the dev version of the Oceananigans package folder. Before this was done, there were numerous output errors with the benchmark scripts, and doing so fixes them all.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1746#issuecomment-864599629:231,variab,variable,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746#issuecomment-864599629,2,"['config', 'variab']","['config', 'variable']"
Modifiability,"@navidcy is a tease! The ""other repo"" is https://github.com/CliMA/ClimaOcean.jl. That's where we plan to build out the features needed for high-quality realistic simulations, eg interpolating bathymetry from one grid to another, ""recipes for realism"" such as parameterization and boundary condition choices. There's already a tool there for downloading some repeat-year forcing JRA55 data; we still need to build a tool for the entire dataset, and also tools for restricting to some region, etc. The vision in the end though is to get as close as possible to ""one click regional modeling"" as we can. @navidcy is right that the tools are not so useful now unless you want to get into the weeds. But if you want to help, it's greatly appreciated. Feedback on issues or wishlist features could also be fun to discuss.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809327733:259,parameteriz,parameterization,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809327733,1,['parameteriz'],['parameterization']
Modifiability,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:233,config,configuration,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778,2,['config'],"['config', 'configuration']"
Modifiability,"@peterahrens thanks for that tip!. @vchuravy, by closure-specific temporary variables (or fields), I am referring to domain-size quantities that can be re-used in computing the contribution of an LES closure to the 'source terms' for momentum and tracers. In other words, [this line, which computes the source term for `u`](https://github.com/ali-ramadhan/Oceananigans.jl/blob/a544300cabe6f8d872b7f9658284cad34c8619ad/src/time_steppers.jl#L223) could become something like. ```julia; kernel_temporaries!(subgrid_closure, ..., i, j, k); Gu[i, j, k] = ... + subgrid_closure.u(subgrid_closure_temporaries, ..., i, j, k); ```. ... I think. In physical terms, the intermediate variable is an 'eddy viscosity' that acts on all momentum terms. But I guess when I say the computation 'will benefit' from variables to store intermediate results, what I really mean is that I'm expecting the calculation of this temporary variable to be fairly involved (potentially >20 derivatives of velocity and tracer fields in x, y, z, plus scalar operations to combine the fields, and a 'clipping' function to make sure the viscosity is not negative --- see [the formula for the eddy viscosity predictor](https://dedales.readthedocs.io/en/latest/closures/anisotropic_minimum_dissipation.html#the-eddy-viscosity-predictor)). It is also of course possible to simply write a function that calculates the eddy viscosity, and call this function repeatedly to avoid temporaries altogether.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-468747674:76,variab,variables,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-468747674,4,['variab'],"['variable', 'variables']"
Modifiability,"@sandreza thanks! We utilize this functionality for many of our objects, eg:. https://github.com/climate-machine/Oceananigans.jl/blob/9ef95e7bef2db1dc9ac04af78664418b0caaf99b/src/AbstractOperations/binary_operations.jl#L144. For some reason, during an undocumented attempt to apply this logic to fields back in October, we were unsuccessful to get code to work on the GPU. Back then, the field consisted of an OffsetArray wrapped around a CuArray, and a grid. Both of those objects can be adapted to GPU kernels, so it should have worked, I think. So I'm not 100% sure why our attempt to use `adapt_structure` failed for fields, while working for other objects. Any insight appreciated...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-622472025:489,adapt,adapted,489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-622472025,1,['adapt'],['adapted']
Modifiability,"@simonbyrne do you have any advice for how to avoid these annoying round-off errors? Basically I'm wondering if theres a robust way to get. ```; ├── Periodic x ∈ [0.0, 6.28319) regularly spaced with Δx=0.0490874; ```. here we are given the length of the domain (2pi), but then we have to construct a range of nodes which extends _left_ of 0, so that it includes our halo region. The problem is when we do that, the first face (which is then something like `range[4]` if we have 3 halo points) has round-off error (or at least that's how I'm interpreting it... maybe there's no way around it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1113423017:321,extend,extends,321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1113423017,1,['extend'],['extends']
Modifiability,"@simone-silvestri , thanks to your help I am now able to print out the norms of the perturbation buoyancy in the case when we evolve the total fields. The error that arises in this case, but not when we evolve the perturbation fields, decreases quadratically with increasing resolution. I could pick a resolution where this is small but in the first hour the norm or buoyancy grows by three orders of magnitude, which looks like an instability. It is not noisy and very well resolved, it can't be a baroclinic instability and does not look anything like an inertial instability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708614762:126,evolve,evolve,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708614762,2,['evolve'],['evolve']
Modifiability,"@simone-silvestri I refactored the CFL calculation so that we only have one function all the time, rather than one ""ordinary"" and one ""accurate"". The tests still fail though. I'm not totally sure why, but I am somewhat confused how this is supposed to work on a staggered grid. I don't think we can apply wikipedia's definition; we need the definition that's correct for a C grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1058063997:20,refactor,refactored,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1058063997,1,['refactor'],['refactored']
Modifiability,"@simone-silvestri I refactored the tuple halo filling (partly to shorten the code but also to filter more stuff from the tuples, and to avoid filling halos for the same fields twice --- sometimes a field can appear twice in a named tuple...) But it looks like my changes broke some stuff, so I might need some help fixing that up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2426#issuecomment-1094117367:20,refactor,refactored,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2426#issuecomment-1094117367,1,['refactor'],['refactored']
Modifiability,"@simone-silvestri You seem to be right. On the cluster I get:. ```julia; julia> using Oceananigans.Architectures: DEVICE_STREAMS, DEVICE_FREE_STREAMS; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided. julia> length(DEVICE_STREAMS); 1. julia> DEVICE_FREE_STREAMS; (CUDA.CuStream[],). julia> CUDA.dev^C. julia> using CUDA. julia> CUDA.devices(); CUDA.DeviceIterator() for 2 devices:; 0. Tesla V100-SXM2-32GB; 1. Tesla V100-SXM2-32GB. julia> CUDA.ndevices(); 2; ```. If you need to reproduce this and aren't able to, we can set up a PP session via zoom and I can share my screen.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310992343:191,variab,variable,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310992343,4,"['Config', 'config', 'variab']","['Config', 'config', 'variable']"
Modifiability,"@simone-silvestri asked for a little more alignment, so we have. ```julia; julia> grid = RectilinearGrid(size = (32, 32, Nz), x = (0, 64),; y = (0, 64), z = hyperbolically_spaced_faces); 32×32×24 RectilinearGrid{Float64} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 64.0) regularly spaced with Δx = 2.0; ├── Periodic y ∈ [0.0, 64.0) regularly spaced with Δy = 2.0; └── Bounded z ∈ [-32.0, -0.0] variably spaced with min(Δz) = 0.682695, max(Δz) = 1.83091; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017983292:397,variab,variably,397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017983292,1,['variab'],['variably']
Modifiability,@simone-silvestri can probably contribute a simple script (maybe something that adapts a baroclinic adjustment case) for `Distributed`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2085674244:80,adapt,adapts,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2085674244,1,['adapt'],['adapts']
Modifiability,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426:600,refactor,refactoring,600,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426,3,"['adapt', 'polymorphi', 'refactor']","['adapt', 'polymorphism', 'refactoring']"
Modifiability,"@simone-silvestri here's some description of the GVC problem. There's additional discussion on #1549. Today, we discussed whether the prognostic variable in a model formulated with a generalized vertical coordinate is thickness weighted velocity `hu`, or velocity `u` (which has also come up on #2522). Based on some discussion and consultation with papers it seems that we want both, because we evolve `hu` when we use ""flux form"" or ""conservative form"" momentum advection, but we evolve `u` when we use ""vector invariant"" advection. This choice has consequences beyond momentum advection though (I think). Also, whichever momentum variable we prognose, we always prognose the thickness weighted tracer concentration `hc`. Thoughts on this are very welcome @jm-c @jmbeckers !. In the ""z-tilde"" paper by [Leclair and Madec 2011](https://www.sciencedirect.com/science/article/pii/S1463500311000126?casa_token=DHE0RUlG-WMAAAAA:lJV98AknVQXrbcNmIUI9sxHLYoqmw4I7lw0EKSMyhiX9lKR6sxreDJ5Kt86jhc2fbqFH88aAYew), we find. <img width=""544"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/167006545-ffff4819-a5a5-4fbc-88a6-aefbed6322cb.png"">. I think `e3` above is our `h`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-1118951226:145,variab,variable,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-1118951226,4,"['evolve', 'variab']","['evolve', 'variable']"
Modifiability,@simone-silvestri this looks great. Have you thought about some sort of thickness weighting for vertical vorticity as a next step!! That could be a great step toward som flexible vertical coordinate options ( https://www.gfdl.noaa.gov/fv3/fv3-key-components/ ).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081920582:170,flexible,flexible,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081920582,1,['flexible'],['flexible']
Modifiability,"@simone-silvestri, from symmetry arguments, the metrics on the halo on one face should be the same as the metrics on some other face. E.g., `Δxᶠᶠᵃ[0]` on one face should be either `Δxᶠᶠᵃ[grid.Nx+1]` or `Δyᶠᶠᵃ[grid.Ny+1]` on the other face (or something like that, depending on whether a rotation applies). Right?. So we could hardcode these in from a single face instead of constructing 6 faces and filling halos to fill the halo metrics. It will assume, thought, that a specific face configuration is implied.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384677447:485,config,configuration,485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384677447,1,['config'],['configuration']
Modifiability,"@simone-silvestri, in relation to why `cpu_face_constructors` require `with_halos=true`: note that before the grid_utils refactor `cpu_face_constructors` were using `cpu_face_constructors` were using `all_x/y/z_nodes` which is exactly equivalent to `x/y/znodes(; with_halos=true)`. ;). https://github.com/CliMA/Oceananigans.jl/blob/e7cb507b2645f04c6cdf52ee6f18c2c5b79f7bde/src/Grids/grid_utils.jl#L244-L246",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2979#issuecomment-1491077886:121,refactor,refactor,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2979#issuecomment-1491077886,1,['refactor'],['refactor']
Modifiability,"@simone-silvestri, sorry but I don't know of any exact solutions but I will think about this a bit more. One thougth that I have discussed with @glwagner a while ago is having a vector invariant form of the `ShallowWaterModel`. This is probably easy to put together from the current `HydrostaticModel`. But if we were to allow for a rigid-lid `ShallowWaterModel`, then we could test the exact solution in the context of this model where momentum evolves. I realize this is a multi-step process, but I for one have wanted to have a rigid lid shallow water model, and this would help to make it happen, as well as create a nice sandbox to test our advection schemes with a classical problem. Please feel free to ignor this idea but if you wanted to discuss it further please let me know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062097227:446,evolve,evolves,446,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062097227,2,"['evolve', 'sandbox']","['evolves', 'sandbox']"
Modifiability,"@tomchor . In terms of ""smoothness indicators"" yes, not in terms of polynomial reconstruction. The WENO we had before is `WENO5()`. This will be formally wrong on a stretched grid because the reconstruction at the face is not done accounting for variable spacing. . `WENO5(grid = grid, stretched_smoothness=false) ` accounts for variable spacing in the reconstruction polynomial (i.e., the <img src=""https://render.githubusercontent.com/render/math?math=c_{rj}""> coefficients are calculated based on grid spacing). This makes the scheme formally correct as, independently on how you weight the polynomials, the different stencils will have mathematically correct reconstructions at the face. This should _always_ be done in case of a stretched grid (and it does not decrease execution speed). Now, the `stretched_smoothness=true` calculates the <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r}""> accounting for a stretched mesh. This means that the three reconstruction polynomials (<img src=""https://render.githubusercontent.com/render/math?math=p_{0}, p_{1}, p_{2}"">) are weighted accounting for their actual smoothness and not a ""uniform smoothness"" that `WENO5(grid = grid, stretched_smoothness=false) ` calculates. In my tests this did not give a noticeable benefit in terms of accuracy (apparently <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r}""> for a stretched mesh are very similar to <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r}""> for a uniform mesh). In addition, it gives a non-negligible decrease in execution speed (especially on the GPU). For this reason, I think it is nice to have as an option, but to be used with parsimony :) and only when necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975684663:246,variab,variable,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975684663,2,['variab'],['variable']
Modifiability,@tomchor I extended both JLD2 and NetCDF tests to include a StepRange index specification. All that's potentially left is to spruce up the docstring if we have the motivation here.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1526#issuecomment-810679001:11,extend,extended,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1526#issuecomment-810679001,1,['extend'],['extended']
Modifiability,@tomchor Not sure if this is the issue but have you tried adapting `ScaleInvariantSmagorinsky` for the GPU?. Looks like `ScalarBiharmonicDiffusivity` needed it here: https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl#L109-L113. Not sure why `update_frequency` is coming up as an `Integer` (which is an abstract supertype) instead of `Int` (which is a concrete type and an alias for `Int64`) but maybe adapting will fix this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2313325100:58,adapt,adapting,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2313325100,2,['adapt'],['adapting']
Modifiability,"@tomchor and @francispoulin (and more) should this include ""flexible"" (to convey the LES <-> general circulation, lab/theory simulations <-> exoplanets, etc.... )?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945745910:60,flexible,flexible,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945745910,1,['flexible'],['flexible']
Modifiability,"@tomchor do you mind if I generalize this issue to talk about refactoring the examples in general?. Here are my thoughts:. 1. I agree we should combine Langmuir turbulence and Ocean wind mixing and convection. I think we should implement one LES example with all bells and whistles: surface waves, wind forcing and buoyancy forcing, temperature/salinity, and potentially also a nonlinear equation of state. 2. I think we should keep convecting plankton and continue to develop that as a pedagogical example for both time-dependent boundary conditions and to illustrate Oceananigans' potential for chemistry / biology modeling via nonlinear forcing functions. 3. I think we should convert the Eady turbulence example to something that uses the hydrostatic model with bathymetry (perhaps some baroclinic instability example with bathymetry). 4. We should get rid of the geostrophic adjustment example. 5. We need an example on `LatitudeLongitudeGrid`. I also think we should generate rough timings for all the examples so we understand which ones are costing us the most.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062523507:62,refactor,refactoring,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062523507,1,['refactor'],['refactoring']
Modifiability,"@tomchor unfortunately we don't have an issue for this problem. @sandreza is it possible to open an issue to document the problem that we are seeing? In the case that this PR does not resolve the issue, we'd like to have an issue open... I don't have much hard evidence to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then co",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:478,config,configuration,478,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865,1,['config'],['configuration']
Modifiability,"@tomchor, I haven't implemented `MultiRegion` for `NonhydrostaticModel` yet. It would be quite easy to extent it if it weren't for the pressure solver which is done in two different ways and both of them are global (`FFT` and `TridiagonalFFT`). A quick and dirty solution would be to do as I have done with the `ImplicitFreeSurface` and reserve the calculation on 1 GPU only. The problem is that the pressure solve is 3D and not 2D so we would probably like to use the `cuFFT` multi-gpu functionality (in particular the cuFFTxt library, which I hope is implemented in `CUDA.jl` although I haven't checked yet) I ll open a PR to start implementing it. Regarding the `OutputWriters`, they are implemented in jld2 trivially with `reconstruct_global_field`. ; You can specify a `JLDOutputWriter` as you do for a single region grid, provided you don't want to slice the direction across the regions ; for example you cannot do; ```; indices = (1:10, :, :) ; ```; for an `XPartition` or ; ```; indices = (:, 1:10, :); ```; for a `YPartition`; (`MultiRegion` does not play well with `indices` at the moment). . It runs, but there is a weird bug for which the fields are not updated as the model timesteps (i.e., all the outputs are the initial condition). I think it is easily solvable but I have to take a deeper look. So basically, it is not working at the moment... On the other hand, to anticipate the `CubedSphere` refactor, we probably want to have `OutputWriters` which output all regions separately (as `reconstruct_global_field` does not mean much in a cubed sphere context). The `OutputReaders`, on the other hand, are completely undefined",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116860842:1413,refactor,refactor,1413,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116860842,1,['refactor'],['refactor']
Modifiability,"@tomchor, indeed you are correct on 1. above, but let me remark that sponge layers could be a bit tricky. I explain:. What you want sponge layers to do is to allow flow propagation into the sponge region but where drag would dissipate any fluid motion there. The ""tricky"" part is to make the sponge layer transition smooth enough so that the fluid does not experience it as a ""wall"". If the transition region is very short then the fluid ""sees"" the sponge as a wall and waves are reflected back into the fluid. But how ""short"" is short-enough depends on the scales of the fluid motion... In my experience always there is some fiddling to be done for every problem or even for same problem at different parameter regimes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733210428:76,layers,layers,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733210428,2,['layers'],['layers']
Modifiability,"@tomchor:. - I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?. - In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?. - Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616:183,Adapt,Adapt,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616,1,['Adapt'],['Adapt']
Modifiability,"@vchuravy solved it (naturally)! The issue is that functions . 1. cannot reference non-`const` global variables (as was occurring in `simple_forcing.jl`; 2. cannot have a `Union` return type, as is the case in many operators because of various instances of branches that `0` and `0.5` (when the other branch returns `Float32` or `Float64`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496742602:102,variab,variables,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496742602,1,['variab'],['variables']
Modifiability,"A ""dynamic function invocation"" means that the compiler thinks a function is being called whose scope can change ""dynamically"" (I think). This is the error one gets when a function depends on a global variable that is not `const` (for example). In this case, the error tells us that the types of the objects involved in calling `getindex` defined on `BinaryOperation`:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/AbstractOperations/binary_operations.jl#L34. are not correctly inferred. The way getindex comes into play is in the kernel function `_compute!` that evaluates the `AbstractOperation`:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Fields/computed_field.jl#L84-L87. calling `getindex(operand, i, j, k)` (or equivalently `operand[i, j, k]`) triggers recursive `getindex` calls that traverse the `AbstractOperation` tree. It seems that when the tree is too large, this traversal cannot be entirely compiled. Perhaps there are tricks we might use to help the compiler parse this kind of operation, like putting some type annotations / hints into `getindex(b::BinaryOperation, ...)`. Not sure. Another possibility is to figure out how to simplify the object `BinaryOperation`, `MultiaryOperation`, so that the compiler is less stressed trying to compile them... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738838140:201,variab,variable,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738838140,1,['variab'],['variable']
Modifiability,"A ""schedule"" is a function or callable object with a method. ```julia; schedule(model); ```. that returns true or false based on a criterion. `true` means ""do something"". The cleanest way to get this feature is to refactor the output writers to have a more generic interface for splitting. If we have a property called `file_splitting` that _is_ a schedule, then we can write. ```julia; NetCDFOutputWriter(model, outputs; file_splitting = TimeInterval(30days), ...); ```. Then the decision about whether to start a new file will change from. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L275. to. ```julia; writer.file_splitting(model) && start_next_file(model, writer) ; ```. Next, you will have to add a new schedule in `Utils/schedules.jl` that can split based on filesize:. ```julia; mutable struct FileSizeLargerThan <: AbstractSchedule; max_filesize :: Float64; path :: String; end. (fslt::FileSizeLargerThan)(model) = filesize(fslt.path) >= fslt.max_filesize; ```. Finally, you need to add a user interface for initializing and modifying the schedules to smooth out the user experience (for example, we don't want users to have to specify the file path more than once, and the file path that is checked by the schedule has to be updated). This will have to take two parts. In `Utils/schedules.jl`, a constructor:. ```julia; FileSizeLargerThan(max_filesize) = FileSizeLargerThan(max_filesize, """"); ```. Then in output writers, an interface to be used in both the model constructor and `write_output!`:. ```julia; update_schedule!(schedule, path) = nothing; update_schedule!(schedule::FileSizeLargerThan, path) = schedule.path = path; ```. This function `update_schedule!(writer.schedule, path)` then replaces this line. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L276. and also needs to be added in the output writer constructor ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793:214,refactor,refactor,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793,1,['refactor'],['refactor']
Modifiability,"A `state` variable would be cool, especially if it shortens function signatures!. And yeah if `state` is not a model property but just a common function signature (presumably for internal/backend use) then there won't be much confusion. I guess function signatures will become; ```julia; F(i, j, k, grid, time, state, parameters); ```; which is quite nice. This change will break a lot of scripts that define custom forcing functions and boundary conditions so should probably mention this in release notes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595559226:10,variab,variable,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595559226,1,['variab'],['variable']
Modifiability,"A consideration when picking up from a checkpoint and using `NetCDFOutputWriter` is that `mode=""a""` (append) needs to be used instead of `mode=""c""` (create or clobber) when creating the `NetCDFOutputWriter`. This functionality works and is tested, but currently needs to be set manually by the user. Not sure of the best way of making this easy for users without accidentally overwriting their data. I can think of three solutions:; 1. Not specifying a `mode` causes `mode=""c""` if the file does not exist and `mode=""a""` if the file does exist. I like this solution the most as it works well with and without a checkpointer (and users don't have to do anything to get reasonable default behavior).; 2. Add a `force` kwarg to `NetCDFOutputWriter` that is `false` by default. The `NetCDFOutputWriter` will error if you try to overwrite an existing file, allowing the user to go back and set `mode=""a""` without any data loss. A `pickup` kwarg could perform a similar function if it's `false` by default.; 3. Setting the `PICKUP` environment variable causes `mode=""a""` to be the default if the file already exists. But I think we should avoid using global environment variables to modify internal behavior.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1068#issuecomment-711035671:1037,variab,variable,1037,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068#issuecomment-711035671,2,['variab'],"['variable', 'variables']"
Modifiability,A default argument works great too! You can also capture data as a global variable:. ```julia; julia> a = 3; 3. julia> f(x) = x * a; f (generic function with 4 methods). julia> f(2); 6; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1002609481:74,variab,variable,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1002609481,1,['variab'],['variable']
Modifiability,"A few additional thoughts:. This problem could be solved if we ever figure out how to adapt fields to work on the GPU (#746). We can then define `lastindex` for fields ~~properly~~ in a special way. A second solution is to define a thin wrapper `FieldData` around `OffsetArray` with a special `lastindex` method that covers the same purpose, but does not contain pointers to `grid` or `boundary_conditions` (therefore being more likely to work on the GPU, unlike `Field`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/838#issuecomment-691062002:86,adapt,adapt,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/838#issuecomment-691062002,1,['adapt'],['adapt']
Modifiability,"A few more comments:. * Perhaps we can name `SomethingBiogeochemistry` ""BasicBiogeochemistry"". I think this is appropriate communication about the purpose of this object; large, sophisticated packages should implement their own models from the ground up.; * I think `light_attenuation_model` is too specific for `BasicBiogeochemistry`. For example, it only pertains to biology; however some models are chemistry-only. @jagoosw do you mind if I address these, and also adapt `test_biogeochemistry.jl` into a form that's close to merge-ready?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1334717022:468,adapt,adapt,468,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1334717022,1,['adapt'],['adapt']
Modifiability,"A few thoughts while I'm debugging these test failures:. * I think at least some of the failures are occurring because we are still using `time_step!(model, dt)` for tests. Now we have to call `update_state!(model)` before a hand-written loop when `model.clock.iteration != 0`. * checking `model.clock.iteration == 0` does not catch some cases. In the regression tests, we manually restore the model state to a configuration (essentially manual checkpointing). However, the halos are not correct (after this PR is merged they will be correct in saved data. However we still could have incorrect halos if models are ""hack checkpointed"" with NetCDFOutputWriter or JLD2OutputWriter that don't include halos). For these cases, we need to call `update_state!` before running a simulation. It seems we probably want to call `update_state` as part of the initialization of `run!` whether or not `iteration == 0` to avoid this gotcha... * Calling `update_state!(model)` every time that `run!` is called can lead to excess computation. But I think the excess is very small even in cases where `run!` is ""misused"" to advance the simulation only 10-20 time-steps (because `update_state!` is already a minor part of the total cost of time-stepping --- I think).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1083#issuecomment-712988897:411,config,configuration,411,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1083#issuecomment-712988897,1,['config'],['configuration']
Modifiability,"A general question. In the tests a variable `results` is created, which is a mutable struct Dict. I see that map is a way to pick out elements of this object. When I ask for information on resutls I get something like this. ```julia> results; Dict{Any,Any} with 1 entry:; CenteredSecondOrder => fill((cx = (simulation = [-8.07688e-137, -2.28227e-125, -1.9026e-114, -4.67931e-104, -3.39525e-94, -7.26804e-…; ```. How do I get values from this object? . From looking in the scripts I gather that we need to use `map` but not sure what fields to get or how to get them. I found out that I can get a bit more inside using `results[CenteredSecondOrder]` but still not sure how to access the arrays.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745408363:35,variab,variable,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745408363,1,['variab'],['variable']
Modifiability,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142:1161,parameteriz,parameterization,1161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142,2,['parameteriz'],['parameterization']
Modifiability,"A new idea for extending the pressure solver to `MultiRegion` is to divide the FFT computations into ""local"" and ""non-local"" directions. . The FFT in local directions can be easily performed wrapping the transform in `@apply_regionally`; For non local directions, if `storage` and `plan` are `unified_array`s, the non local FFT can be performed by permuting the partitioning of the `MultiRegionGrid` without having to transpose memory (that will happen under the hood thanks to unified memory). . This strategy would not be easily extensible to generally subdivided regions and will play well only with one direction partitioning, but given the current limitations of the FFT solver (only regular grid), I think it is a good strategy to get something to work",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969:15,extend,extending,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969,1,['extend'],['extending']
Modifiability,"A performance warning is a pretty cool idea. Yes, let's do the changes tomorrow. Agreed that many parametric types becomes cumbersome. I think architecture is appropriate for the current model type (perhaps we will eventually call it `LESModel`... ?) We can define new types for new flavors of model (`HydrostaticModel`, `VariableBathymetryModel`...), rather than introducing type parameters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468538413:322,Variab,VariableBathymetryModel,322,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468538413,1,['Variab'],['VariableBathymetryModel']
Modifiability,"A question for @glwagner . At the moment the tendencies in the evolution equation for height is computed here using essentailly a second-order finite difference method. This is fine for a start, but as discussed elsehwere, it would be better to use finite volume and therefore using the advection schemes that already exist. https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl#L71. In line 69 above you will see that I tried doing this by definig a new operator, div_UV, for partial_x U + partial_y V. This was clunky because I needed to pass variables U and V, and I had an error. The details can be found here,. https://github.com/CliMA/Oceananigans.jl/blob/9402a90af072a495ef130d540661be9327a51552/src/Models/ShallowWaterModels/shallow_water_advection_operators.jl#L24. Can you suggest a better way of doing this?. When I try running the tests most of the pass except at line 82 I get the following error . ```; [2021/01/11 15:36:04.735] INFO Testing time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]...; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); KernelException: exception thrown during kernel execution on device Quadro P400; Stacktrace:; [1] check_exceptions() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/compiler/exceptions.jl:94; [2] prepare_cuda_call() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/state.jl:85; [3] initialize_api() at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:92; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/libcuda.jl:975 [inlined]; [5] macro expansion at /home/fpoulin/.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952:630,variab,variables,630,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952,1,['variab'],['variables']
Modifiability,A related issue but really outside our scope is that someone that has CUDA but doesn't have things configured correctly can have difficulty running Oceananigans --- even if they only ever planned on running CPU models. This issue was avoided when `has_cuda()` was based on whether `using CuArrays` failed or not.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/840#issuecomment-670516629:99,config,configured,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/840#issuecomment-670516629,1,['config'],['configured']
Modifiability,"A thought: . A different design would extend `SeawaterBuoyancy` with two types that specify whether temperature and salinity are present:. ```julia; struct SeawaterBuoyancy{FT, EOS, T, S} <: AbstractBuoyancy{EOS}; gravitational_acceleration :: FT; equation_of_state :: EOS; end; ```. and. ```julia; function SeawaterBuoyancy(FT=Float64;; gravitational_acceleration = g_Earth,; equation_of_state = LinearEquationOfState(FT); with_temperature = true, with_salinity = true; ); return SeawaterBuoyancy{FT, typeof(equation_of_state), with_temperature, with_salinity}(gravitational_acceleration, equation_of_state); end; ```. We can then dispatch on those types when calculating buoyancy. Slightly less code this way, but perhaps the complexity isn't worth it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/581#issuecomment-567750982:38,extend,extend,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/581#issuecomment-567750982,1,['extend'],['extend']
Modifiability,"A warning might make sense. `show` can be more specific (spacing `Array` doesn't mean that the spacing is variable, it means the spacing is given by an `Array`). It's good at least now that `show` helps you realize that `Array` spacings are special.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2192#issuecomment-1022770084:106,variab,variable,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2192#issuecomment-1022770084,1,['variab'],['variable']
Modifiability,"Actually I'll reopen this since I'm still getting an error, albeit a different one:. ```; julia> grid; 44×8×52 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [4.35026e-15, 894.427) regularly spaced with Δx=20.3279; ├── Periodic y ∈ [-8.74514e-15, 178.885) regularly spaced with Δy=22.3607; └── Bounded z ∈ [-178.885, 178.885] variably spaced with min(Δz)=4.76685, max(Δz)=21.2525. julia> minimum_zspacing(grid); ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/error.jl:89; [2] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/utils/call.jl:26; [4] #39; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CuStream, CuFunction, CuDim3, CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CuDeviceArray{Float64, 4, 1}, ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Of",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490569457:374,variab,variably,374,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490569457,1,['variab'],['variably']
Modifiability,"Actually `Array` and `CuArray` aren't `isbits`. But from what I understand, I think CUDAnative uses Adapt.jl to convert a `CuArray` to something like a `CuDeviceArray` which is `isbits` when passing arguments to CUDA kernels, which is what we would have to do to convert our `Field` structs to be `isbits`. But yeah, definitely agree about avoiding abstract and unspecified types. Comes with learning Julia I guess.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/19#issuecomment-477678970:100,Adapt,Adapt,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/19#issuecomment-477678970,1,['Adapt'],['Adapt']
Modifiability,"Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh. We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867881028:0,Adapt,Adapt,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867881028,2,['Adapt'],['Adapt']
Modifiability,"Adapt.jl isn't relevant here, that's for CPU->GPU conversions. This is a tuple operation not getting inferred properly, leading to a dynamic call to a runtime function. Those aren't supported. With 1.5, there's been a bunch of latency optimizations that have affected inference quality, e.g., when not forcing specialization on functions with `::F where F`. Your best bet here would be to step through using Cthulhu and figure out which code isn't inferring properly. If it's tough code to get though, you could always add the call to `Cthulhu.descend_code_warntype` at the place where the InvalidIRError is thrown.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-673479769:0,Adapt,Adapt,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-673479769,1,['Adapt'],['Adapt']
Modifiability,"Adapting Smagorinsky seems an easy avenue. . In terms of Implicit LES, you could try using just WENO without any closure, but if you are in a true LES regime it would probably be too dissipative. A Smagorinsky viscosity combined with an energy-conserving advection scheme has been found to be less dissipative although noisier (here is an example applied to Burgers equation https://reader.elsevier.com/reader/sd/pii/S0377042717303035?token=83A413B5659B8B16B96E1D0CBDAD5865D8552AE5B2FF2FDFE78FFDEF064F2820B38D1BBFF646D3F7B75D58FE010DF7DB&originRegion=us-east-1&originCreation=20230125193548). You can always try with higher order (maybe 7th?) but the higher the order the lower the stability (i.e. at a certain order your implicit dissipation will be so low that you will start to generate grid-scale noise). . The KE dissipation is there with `closure=nothing` and a WENO scheme, it is just not strictly physical: it's (roughly) akin to a 4th to a 6th-order hyperviscosity. You can compare this to using `UpwindBiased(order = 5)` which would give you everywhere a dissipation that converges to a 6th-order hyperviscosity. In general:. $$\partial_x {uu}^{Upwind_N} \sim \partial_x {uu}^{Centered_{N+1}} + \partial_x {K_{numerical}} \partial_x^{N} u$$. where $K_{numerical} \sim \Delta x u$ and $N$ is the order. The nice thing about using WENO instead of a simple Upwind discretization is that the order of the hyperviscosity adapts to the smoothness of the field. Therefore, where the field is noisier (like in regions of higher gradients) the dissipation is more aggressive. . This procedure not only ensures a smooth field but can be thought of as mimicking the subgrid-scale dissipation (which also increases with the gradient of resolved scale variables. As such people have referred to using particularly diffusive advective schemes (such as WENO) as _Implicit_ LES. I like the idea of implicit LES because it allows you to ""fill in"" for the subgrid-scale dissipation without committing to any s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433:0,Adapt,Adapting,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433,1,['Adapt'],['Adapting']
Modifiability,"Adaptive time-stepping is useful for a wide class of problems. The general strategy is to use the CFL number to compute a stable time-step. This is especially useful in problems with lots of time variability --- for example, LES of a seasonal cycle. In addition, the CFL computation can be used to stabilize the spin-up of a model, during which a transition to turbulence occurs. Some complexity is introduced by the fact that we use Adams-Bashforth time stepping (as opposed to a RK-method, which is more common and more stable), since it means we need to re-initialize the ""previous source terms"" with a forward Euler step when the time step is changed. I have been using adaptive time-stepping in my work, which along with a strategy for handling model spinup / transition to turbulence, has proven to be an important practical feature that makes running experimental simulations under different conditions much easier, since all I need to do is set my boundary conditions, and let the model run. I am then able to start dozens of LES per day (if I want to) without having to choose my time step size through a mistake-prone and time-consuming trial-and-error process --- and I am guaranteed not to waste resources with a too-short time-step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505551358:0,Adapt,Adaptive,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505551358,3,"['Adapt', 'adapt', 'variab']","['Adaptive', 'adaptive', 'variability']"
Modifiability,"Adding automatic NaN checking as a stop criteria is actually slightly different behavior because if a NaN just stops a simulation then the rest of the script still executes (instead of killing the script outright). However, the behavior could be changed by catching the right exception if we want different behavior upon seeing a NaN. Sounds like the consensus is to refactor automatic NaN checking as a stop criteria (as part of resolving #1138)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1198#issuecomment-733265642:367,refactor,refactor,367,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1198#issuecomment-733265642,1,['refactor'],['refactor']
Modifiability,Additionally can you help me understand why you are using `GradientBoundaryCondition` at all? I had thought that it's usually preferred to use `FluxBoundaryCondition` since this is often the preferred parameterization for large scale motions and basically we only use `ValueBoundaryCondition` for DNS (and `GradientBoundaryCondition` almost never). Curious to understand the class of problems that benefit from `GradientBoundaryCondition`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2207703968:201,parameteriz,parameterization,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2207703968,1,['parameteriz'],['parameterization']
Modifiability,After #2522 me and @dhruvbhagtani will start working on the multi-layer. The plan is to extend the `ShallowWaterModel` to allow non-flat `z` dimensions with `Nz` the number of fluid layers. It would be good if we add a regression test for the single-layer `ShallowWaterModel` to ensure we don't break things in the process.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137948975:88,extend,extend,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137948975,2,"['extend', 'layers']","['extend', 'layers']"
Modifiability,"After talking a bit with @ali-ramadhan, I think we might have settled on the following solution:. * Introduce a new type called `PhysicalParameters` that holds `g` and `ρ0`; * Introduce a new abstract type called `Rotation` (or some such) that encodes information about the background rotation rate of the model --- `TangentPlane` with `f` and `β`, and possibly non-traditional Coriolis parameters, another type for the sphere, etc.; * Group viscous and diffusive transport coefficients into the upcoming `TurbulenceClosure` type, allowing for isotropic constant transport coefficients, anisotropic constant coefficients, or nonlinear closure schemes. These changes will also require us to compute buoyancy rather than a density perturbation, and may motivate us to simplify the code by defining variables in `pressures` as having units of the 'kinematic pressure', which is the ordinary pressure divided by `ρ0`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-494898546:796,variab,variables,796,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-494898546,1,['variab'],['variables']
Modifiability,"Agreed. Useful and related comment. > I was thinking of doing some prototyping and benchmarking in a sandbox by building off the example in my PR [vchuravy/GPUifyLoops.jl#18](https://github.com/vchuravy/GPUifyLoops.jl/pull/18).; > ; > The PR contains an example that can be extended to rely on a `Grid` struct, multiple `FaceField`s and ` CellField`. So I'll prototype grids and fields that are `isbitstype` (you already helped by doing this for a grid in [#59 (comment)](https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-467660181)) and test to see if they work on the GPU with GPUifyLoops.jl. If they do work and performance isn't degraded then I'll rewrite the operators to use grid and field structs.; > ; > You probably know how to do this better than me, but might be good if I rewrite the operators as they's still undocumented and do some _slightly convoluted_ stuff to avoid having to store intermediate calculations.; > ; > Right now I'm focusing on system tests and benchmarks but once @christophernhill @jm-c and I get closer to implementing the variable _Δz_ grid #47 I will work on this.; >; >_Originally posted by @ali-ramadhan in https://github.com/climate-machine/Oceananigans.jl/issues/115#issuecomment-470782067_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-470297910:101,sandbox,sandbox,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-470297910,5,"['extend', 'rewrite', 'sandbox', 'variab']","['extended', 'rewrite', 'sandbox', 'variable']"
Modifiability,Agreed. We could address this when we refactor halo regions to dispatch on boundary conditions. Would then be good to add some code that asserts that the velocity boundary conditions are compatible with the boundary conditions we support (and with each other).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/311#issuecomment-510898553:38,refactor,refactor,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/311#issuecomment-510898553,1,['refactor'],['refactor']
Modifiability,Ah I think you added `sandbox/vertically_stretched_plankton.jl` back in when we meant to keep it nuked but we can worry about it after this PR is merged.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783652214:22,sandbox,sandbox,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783652214,1,['sandbox'],['sandbox']
Modifiability,"Ah interesting, that could be it especially since we're using free-tier CI testing. Looking to see what the final version of https://github.com/climate-machine/CLIMA/issues/106 and https://github.com/climate-machine/CLIMA/issues/107 look like, then would be good to at least use a CPU-only configuration on Appveyor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/89#issuecomment-473687080:290,config,configuration,290,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/89#issuecomment-473687080,1,['config'],['configuration']
Modifiability,Ah it was just a try. `\bm` comes from the `bm` LaTeX package which I guess was available with KaTeX. For MathJax we might have to define the `\bm` command at the top of the pages that use it?. [Equation numbering still doesn't work](https://clima.github.io/OceananigansDocumentation/previews/PR1530/numerical_implementation/time_stepping/) but apparently it's because MathJax3 doesn't enable it by default: http://docs.mathjax.org/en/latest/input/tex/eqnumbers.html. Looks like we can configure it by passing a dict to the `MathJax3` constructor though: https://juliadocs.github.io/Documenter.jl/stable/lib/internals/writers/#Documenter.Writers.HTMLWriter.MathJax3,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-811481173:486,config,configure,486,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-811481173,1,['config'],['configure']
Modifiability,"Ah neat result @navidcy, thanks for posting your solution! Indeed I doubt I set it up correctly. I went back and tried to play around with the setup a bit but no luck. Perhaps I misunderstood how to reduce down to Burgers equation but might try again a bit later with fresh eyes... Out of curiosity what numerical method did you use? That's a super clean shock!. > Also, @ali-ramadhan in your solution above I see noise forming for negative parts of the solution first. This might hint some biased in the scheme towards certain-sign velocities?. Yeah that weirded me out as well. Wasn't sure what to make of it but I decided to ignore it since I wasn't solving the right equation (or the setup was just wrong). I didn't notice any discrepency between periodic advection of a square waveform with positive and negative velocities, but I only checked using my unreliable eyeball norm. It's using the same advection schemes as Oceananigans.jl (which we've tested for convergence using positive and negative velocities). But because the prognostic variable is ρu there's an extra division by ρ since it computes fluxes of ρuu as (ρu)*(ρu)/ρ. So maybe I should be doing something like `WENO(ρ)*WENO(ρ)/WENO(ρ)` instead of just `WENO(ρ)*WENO(ρ)/ρ`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079#issuecomment-716459705:1044,variab,variable,1044,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079#issuecomment-716459705,1,['variab'],['variable']
Modifiability,"Ah ok I see why your original script didn't work now. When executing. ```julia; model = IncompressibleModel(grid=grid,; closure = closure,; boundary_conditions = (v=v_bcs); ); ```. this assigned `v_bcs` to the new variable `v` and passes it to the `IncompressibleModel` function. `v_bc` itself is a `NamedTuple` containing `x, y, z` properties so the `IncompressibleModel` constructor does not complain. Since the named tuple that is passed does not not have a `v` property, the velocities get the default boundary conditions (free slip and no normal flow). Then when you call `set!(model, v=-0.5)` it fills v to be -0.5 everywhere but then `update_state!(model)` is called to ensure that the velocity field is incompressible (divergence-free) by performing a pressure projection step. Since the default boundary condition enforces no-normal flow, the velocity cannot be -0.5 everywhere so the pressure field updates it to be zero to enforce incompressibility. This is a pretty subtle bug (related to #1204)... Since the proper named tuple can't be checked for in the constructor function signature, I wonder if it's worth adding a manual check to make sure a `NamedTuple{(:x,:y,:z)}` was not passed to the model constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756979930:214,variab,variable,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756979930,1,['variab'],['variable']
Modifiability,"Ah ok! Was the behavior different in prior versions of Oceananigans? This is what I would like to understand. We did not fill halo regions *after* time stepping in prior versions of Oceananigans, either, as far as I know. Do you want to contribute an advection scheme to Oceananigans? A lot of people might benefit from having the kind of advection scheme that you are using! It may not be very much work, since we have an interface for adding new advection schemes. Do you evolve the tracer fully outside of the `Oceananigans` infrastructure? Or is the tracer ""included"" in the list of tracers for your `IncompressibleModel`, but you somehow negate tracer advection and add it outside of `time_step!`, somehow? It would be interesting to see this method, and figure out how to make it easier for users to solve problems like the one you're encountering in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/949#issuecomment-694211534:474,evolve,evolve,474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/949#issuecomment-694211534,1,['evolve'],['evolve']
Modifiability,"Ah right, when broadcasting you wouldn't want the operations to act on the _ghost cells_ or _halo regions_ (well that's probably fine as long as they're overwritten before being used). So just use an `@views` maybe. Either way, don't think we use any broadcasts over `CuArrays`s but should probably play around in a GPU sandbox a bit before implementing anything.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/104#issuecomment-469741132:320,sandbox,sandbox,320,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/104#issuecomment-469741132,1,['sandbox'],['sandbox']
Modifiability,"Ah sorry about that! Happy to chat over Slack but don't wanna butcher @glwagner's suggestion. I guess having the `X, Y, Z` is important for `NetCDFOutputWriter` since it uses that information to know which dimensions to assign to each variable. They could be specified manually via the `dimensions` kwarg (there should be an example of this in the docstring) but ideally the dimensions should be detected automatically for an Oceananigans field. Maybe you just need to use `reduced_location` to determine the `X, Y, Z` for the `SpatialWindowAverage`? https://github.com/CliMA/Oceananigans.jl/blob/0ff8cd8e7d4565c8493ec7b81e531599277ab645/src/Fields/reduced_field.jl#L137. Maybe something like this could work?. ```julia; function SpatialWindowAverage(field; dims, field_slicer=FieldSlicer()); X, Y, Z = reduced_location(location(field), dims=dims); return SpatialWindowAverage{X, Y, Z}(field.data, field.grid, field, field_slicer, dims); end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783553934:235,variab,variable,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783553934,1,['variab'],['variable']
Modifiability,Ah sorry for the slow reply. Docs build on `tartarus.mit.edu` through Buildkite which has GPUs but we disable the GPU through the Buildkite config. I think if we just remove this line we can build examples on the GPU!. https://github.com/CliMA/Oceananigans.jl/blob/81d9c0e061cae4aa5a0ec770ff8348be7517aa53/.buildkite/pipeline.yml#L324. Doesn't have to happen in this PR of course.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802307902:140,config,config,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802307902,1,['config'],['config']
Modifiability,"Ah the examples at the end seem they would be quite a bit nicer than what we already have, and if everything goes through the `BoundaryCondition` function that would be pretty clean. Seems like we would end up with a signature like. ```julia; BoundaryCondition(Tbc, condition::Function; parameters=nothing, field_in_forcing=false, long_function_signature=false); ```; where non-nothing `parameters` adds a `parameters` argument at the end of boundary condition functions (of all types), `long_function_signature` switches between `(x, y, t, p)` and `(i, j, grid, clock, state, p)`, and `field_in_forcing` switches between `(x, y, t, p)` and `(x, y, t, ϕ, p)` (only works together with `long_function_signature=false`). If this means not having to juggle `SimpleForcing`, `ParameterizedBoundaryFunction`, etc. then it would be a huge upgrade.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/769#issuecomment-683162842:772,Parameteriz,ParameterizedBoundaryFunction,772,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/769#issuecomment-683162842,1,['Parameteriz'],['ParameterizedBoundaryFunction']
Modifiability,"Ah woops, sorry! Embarrassing mistake on my part. I cleaned up the `examples/` directory recently and accidently moved `examples/utils.jl` to `sandbox/utils.jl`. Thanks for posting this!. Should be fixed now (#255).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/254#issuecomment-497285519:143,sandbox,sandbox,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/254#issuecomment-497285519,1,['sandbox'],['sandbox']
Modifiability,"Ah yes I see the `\newcommand\v[1]{\boldsymbol{ #1}}` now. Using `\upsilon` for velocity feels weird to me as it's not used for velocity but I haven't played around with MathJax so not sure what the best variables are. MathJax might not support a lot of extra math fonts anyways. `\nu` looks like a nu so yeah maybe changing v is the way to go?. I don't think there's a reason why `\mathbf{u}` became `\mathbf{v}` besides oversight. I combined the docs from multiple scattered notes and we ended up with slightly inconsistent documentation, so that was my fault. Thanks for pointing this out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470513283:204,variab,variables,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470513283,1,['variab'],['variables']
Modifiability,"Ah yes as noted here:. > This speed issue disappears either when ζ = ∂x(v) - ∂y(u) is replaced with ζ = Field(∂x(v) - ∂y(u)), or when ζ is the only variable in fields_slice. That's pretty bizarre. That makes me think it's some kind of weird interaction between `NCDatasets` and `Oceananigans`. I can say, with `ζ = Field(∂x(v) - ∂y(u))` the output type is different. It would seem more complex in fact, because it has one more layer of indirection (ie it's the window that refers to a 3D computed field, rather than a windowed computed field). So I don't know why that would compile faster. Honestly I don't think any of us has much experience optimizing compile time. Perhaps first reading this blog post:. https://julialang.org/blog/2020/08/invalidations/. and then the source code for `NetCDFOutputWriter` will lead to revelations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805104189:148,variab,variable,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805104189,1,['variab'],['variable']
Modifiability,Ah yes! Seems like we were probably not doing it exactly right before... We could also add the environment variable `JULIA_DEBUG=Documenter` if people think it's helpful to get an idea of which example is currently being built (for when you build docs + examples locally).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1542#issuecomment-819466377:107,variab,variable,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1542#issuecomment-819466377,1,['variab'],['variable']
Modifiability,"Ah, I see the problem... all the `viscous_flux` are formulated in terms of velocities `U.u, U.v, U.w` which the shallow water model does not necessarily have. This will be slightly more involved to fix than just changing the signature of the function. . It depends how you want to formulate the viscous operator, as a diffusion of `u` or a diffusion of `uh`. If the former is _always_ the desired formulation, both in the vector invariant and the conservative equations, then it might be useful to add the velocities as a field of the shallow water model and pass them to the tendency kernel. . So indeed, we should open a PR to adapt the shallow water model to work with closures",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152698100:629,adapt,adapt,629,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152698100,1,['adapt'],['adapt']
Modifiability,"Ah, I see... ```; @inline Γᶠᶠᶜ(i, j, k, grid, u, v) = δxᶠᵃᵃ(i, j, k, grid, Δy_qᶜᶠᶜ, v) - δyᵃᶠᵃ(i, j, k, grid, u, Δx_qᶠᶜᶜ, u); ```; that can also work... maybe more robust since differences are already extended for `Flat` grids. I agree",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054866428:201,extend,extended,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054866428,1,['extend'],['extended']
Modifiability,"Ah, I think I see. If we turned off advection, pressure solve, buoyancy, Coriolis and all other forces, then the velocity would be fixed. In this case the `BackgroundField` would be identical to `PrescribedVelocties`, in that the tracers would evolve with the velocity but the velocity would not be changed. Very good to know!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768486532:244,evolve,evolve,244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768486532,1,['evolve'],['evolve']
Modifiability,"Ah, I think suffice to say that in the context of the Craik-Leibovich equations, whenever the word ""Stokes drift"" is used, it's ""pseudomomentum"" that is really meant. . In particular the original context of ""Stokes drift"" is the specific situation in which surface waves forced from rest are associated with a mean Lagrangian current that causes particles and fluid to ""drift"". In the Craik-Leibovich equations, the Lagrangian-mean momentum is a prognostic variable and is not determined or _explicitly_ modified by the ""Stokes drift"" (it is only _implicitly_ modified through changes to the fluid physics). Thus rather than causing fluid to ""drift"", specifying the ""Stokes drift"" in the Craik-Leibovich equations (and in Oceananigans) instead acts to modify the underlying fluid dynamics by changing the relationship between momentum and vorticity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-779826789:457,variab,variable,457,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-779826789,1,['variab'],['variable']
Modifiability,"Ah, right! We have to extend the outer functions (`left_biased_interpolate`, `right_biased_interpolate`, and `symmetric_interpolate`) instead of the `inner` ones",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1276402805:22,extend,extend,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1276402805,1,['extend'],['extend']
Modifiability,"Ah, the only issue is there will be conflicts with #1575. It shouldn't be hard to refactor these changes to work with the code on that PR though I don't think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1593#issuecomment-820023429:82,refactor,refactor,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1593#issuecomment-820023429,1,['refactor'],['refactor']
Modifiability,"Ah, we just need `Adapt` for `ContinuousForcing`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010#issuecomment-701447763:18,Adapt,Adapt,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010#issuecomment-701447763,1,['Adapt'],['Adapt']
Modifiability,"Ahh, very nice ideas. A convenience constructor for a collection of writers is a much better idea than the ""global variable""-y solution I proposed regarding `Simulation`; we just have to invent a file naming convention. We actually don't need separate `Averaged*` constructors if we extend the philosophy of time-averaging and add a kwarg like `spatially_averaged_dims` (maybe there's a better name, but we have to avoid confusion with time-averaging) that transforms fields into `AveragedField`s, eg. ```julia; simulations.output_writers[:horizontal_averages] =; NetCDFOutputWriter(model, output_fields, spatially_averaged_dims=(1, 2), ...). simulations.output_writers[:volume_averages] =; NetCDFOutputWriter(model, output_fields, spatially_averaged_dims=(1, 2, 3), ...); ```. the default `nothing` doesn't transform anything.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1171#issuecomment-726748981:115,variab,variable,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1171#issuecomment-726748981,2,"['extend', 'variab']","['extend', 'variable']"
Modifiability,"Ali and Greg, thanks for your comments. I found the exchange very; enlightening. John. On Tue, Jun 25, 2019, 7:49 PM Gregory L. Wagner <notifications@github.com>; wrote:. > Adaptive time-stepping is useful for a wide class of problems. The general; > strategy is to use the CFL number to compute a stable time-step. This is; > especially useful in problems with lots of time variability --- for; > example, LES of a seasonal cycle. In addition, the CFL computation can be; > used to stabilize the spin-up of a model, during which a transition to; > turbulence occurs.; >; > Some complexity is introduced by the fact that we use Adams-Bashforth time; > stepping (as opposed to a RK-method, which is more common and more stable),; > since it means we need to re-initialize the ""previous source terms"" with a; > forward Euler step when the time step is changed.; >; > I have been using adaptive time-stepping in my work, which along with a; > strategy for handling model spinup / transition to turbulence, has proven; > to be an important practical feature that makes running experimental; > simulations under different conditions much easier, since all I need to do; > is set my boundary conditions, and let the model run. I am then able to; > start dozens of LES per day (if I want to) without having to choose my time; > step size through a mistake-prone and time-consuming trial-and-error; > process --- and I am guaranteed not to waste resources with a too-short; > time-step.; >; > —; > You are receiving this because you commented.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/pull/297?email_source=notifications&email_token=AKXUEQVQYODJTMVZ46AOA3TP4JLCFA5CNFSM4H3I7NT2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODYRBT7Q#issuecomment-505551358>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQS54XWGGG7MKQWZZELP4JLCFANCNFSM4H3I7NTQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505609983:173,Adapt,Adaptive,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505609983,3,"['Adapt', 'adapt', 'variab']","['Adaptive', 'adaptive', 'variability']"
Modifiability,"Ali,; changes to; - Poisson (div v etc) and; - diagnosing w from continuity instead of stepping forward the vertical mtm; equation; are major algorithmic changes.; Important to do an extended integration to make sure nothing is broken.; Free convection?; Did the divide or multiply by del_t get sorted out?; John. On Thu, May 23, 2019 at 8:50 PM Ali Ramadhan <notifications@github.com>; wrote:. > Now that the velocity field is truly incompressible in time.; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/climate-machine/Oceananigans.jl/pull/233; > Commit Summary; >; > - Update thermal bubble golden master output.; >; > File Changes; >; > - *M* test/thermal_bubble_golden_master_10.nc; > <https://github.com/climate-machine/Oceananigans.jl/pull/233/files#diff-0>; > (0); >; > Patch Links:; >; > - https://github.com/climate-machine/Oceananigans.jl/pull/233.patch; > - https://github.com/climate-machine/Oceananigans.jl/pull/233.diff; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/pull/233?email_source=notifications&email_token=AKXUEQXNYO4M3IXQPZJTXITPW43ULA5CNFSM4HPLKXNKYY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4GVS43WA>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQTT25U7Q4S3UQHKFGTPW43ULANCNFSM4HPLKXNA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/233#issuecomment-495690445:183,extend,extended,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/233#issuecomment-495690445,1,['extend'],['extended']
Modifiability,Alright I think this PR is ready to be merged. Extra change since yesterday: I think we can have a cleaner design by getting rid of `DistributedIncompressibleModel` and just reusing `IncompressibleModel` but with `architecture = MultiCPU`. So now instead of dispatching on `::CPU` and `::GPU` we would dispatch on `::AbstractCPUArchitecture` and `::AbstractGPUArchitecture` and things should work out whether the model is distributed or not. > I see that one changed grid to my_grid. Not sure if that was a bug or not but if so glad you caught it. Yes I think it was picking default boundary conditions based on the `full_grid` but it should be using the local `my_grid` (not that it matters right now since the local grid inherits the topology of the full grid but we might change that soon). EDIT: Also bumping v0.53.0.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-791430098:723,inherit,inherits,723,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-791430098,1,['inherit'],['inherits']
Modifiability,"Alright so as suggested I added a test for CFL calculation with a vertically stretched grid. Also refactored where the minΔx functinos go like @glwagner suggested, so if the tests pass I believe this should be good to go. @ali-ramadhan should I just call JuliaRegistrator to register this after it's merged?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799660063:98,refactor,refactored,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799660063,1,['refactor'],['refactored']
Modifiability,"Also a design choice to be made:. When we notice the user has given the wrong inputs do we; 1. Tell the user what went wrong and how to fix it so at the scripts are correct/robust, or; 2. Fix as much as possible behind the scenes so the input can be quite flexible and things just work™. Both seem to have advantages/disadvantages. Just curious what others think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/421#issuecomment-532789591:256,flexible,flexible,256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/421#issuecomment-532789591,1,['flexible'],['flexible']
Modifiability,Also apologies if this is PR feature scope but I found it easier to refactor if I de-cluttered the `ImmersedBoundaries.jl` module file. This ended up creating three new files:. * `immersed_boundary_grid.jl`; * `immersed_boundary_interface.jl`; * `immersed_boundary_nodes.jl`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459922652:68,refactor,refactor,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459922652,1,['refactor'],['refactor']
Modifiability,"Also one thing that is important to get right in multi-layer shallow water models is layer-wise conservation of mass and other properties (see _e.g._, https://aronnax.readthedocs.io/en/latest/verification.html and http://www.nordet.net/beom.html). > Topography that can interact more than one layer is complicated because then we need wetting and drying, but it won't need immersed boundaries. At least i don't think so. Wetting and drying usually requires a positive preserving advection scheme. We have first-order upwinding (which I don't think anyone has every used), that is positive preserving and could do this. But it's not a great scheme. A limiter would be better. There are a lot of methods out thatk, but not the first thing to worry about. This if much longer term, I would say. In addition to positive-preserving advection schemes, it seems one other way to deal with this is adding to the pressure gradients an extra term that prevents the thicknesses of outcropped/incropped layers from reaching zero following [Salmon (2002)](https://www.ingentaconnect.com/content/jmr/jmr/2002/00000060/00000004/art00004?token=005b148389c57630504c2a726e2d58464340592f713b672c57582a67232d45234a46246c6a4d2c3167732355e72). There is a deep discussion on the physics and practical implementation of this in different validation simulations in http://www.nordet.net/etc/doc_beom.pdf. Just wanted to put this out there, I don't have a good feel for which approach would be most desirable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115738194:991,layers,layers,991,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115738194,1,['layers'],['layers']
Modifiability,"Also this works:. ```julia; julia> import Base: minimum. julia> using OffsetArrays. julia> minimum(a::SubArray{<:Any, <:Any, <:OffsetArrays.OffsetVector}) = minimum(parent(parent(a))); minimum (generic function with 21 methods). julia> minimum(zspacings(grid, Center())); 1.0. julia> grid; 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [0.0, 16.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0; ```. so it might have something to do with the `KernelFunctionOperation` that's used here?: https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Grids/grid_utils.jl#L407-L413",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490607038:527,variab,variably,527,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490607038,1,['variab'],['variably']
Modifiability,"Also to be clear, declaring something as `const`, and then inserting that variable's value into another data structure does not guarantee that the value in the second data structure is fixed. `const` attaches to a name and does not ""propagate"" into other data structures like `ContinuousBoundaryFunction.parameters`. So things like the following are valid:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> const b = 2; 2. julia> t = Test(b); Test{Int64}(2). julia> t.a = 3; 3. julia> t; Test{Int64}(3); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691:74,variab,variable,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691,1,['variab'],['variable']
Modifiability,"Also what we'd call `filename` would be different than what is called file name in the docs for [`JLD2`](https://docs.juliahub.com/JLD2/O1EyT/0.4.22/internals/#JLD2.jldopen) and [`NCDatasets`](https://alexander-barth.github.io/NCDatasets.jl/stable/variables/#NCDatasets.NCDataset-Tuple{NCDatasets.CFVariable}), which might be a source of confusion in new users.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098254438:248,variab,variables,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098254438,1,['variab'],['variables']
Modifiability,"Also, `float_type` is part of the grid and all field defined on the grid could inherit that, right?; (perhaps this is already the case?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-875268386:79,inherit,inherit,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-875268386,1,['inherit'],['inherit']
Modifiability,"Also, do we want to add documentation about this to the output writers? It could surprise some users that their time-step is forcibly changed by output. For people using adaptive time-stepping this is a non-issue (their time-step is constantly changing anyways), but for people with constant time-steps, the effect of alignment is more noticeable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1213#issuecomment-736141239:170,adapt,adaptive,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1213#issuecomment-736141239,1,['adapt'],['adaptive']
Modifiability,"Although I prefer being explicit I'm a big fan of the macro you suggested as it collapses 20+ lines into a single elegant statement (and buries the ugly unpacking) whereas the `unpack_model` function still requires a comma separate list of 20+ variables. I think I'll go with the simple macro. If the unpacking variables have descriptive names, e.g. `grid`, `source_terms`, `velocities`, etc. then I think it'll still be understandable without being explicit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/155#issuecomment-477595870:244,variab,variables,244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/155#issuecomment-477595870,2,['variab'],['variables']
Modifiability,"An easier course of action would be to forget about performance at first and just fill halos every substep.; This will be quite inefficient but will allow us to test open boundary conditions for the hydrostatic model and validate them first. There is an implementation of a split explicit free surface solver that does not require special operators (specifically for a multi region grid) in #3596 ; https://github.com/CliMA/Oceananigans.jl/blob/a6e9a465aa9528b5b3afd49737310e710e4681b0/src/MultiRegion/multi_region_split_explicit_free_surface.jl#L130-L170. We could adapt this implementation for normal grids by implementing a keyword argument in the `SpliExplicitFreeSurface` constructor. Something like the `extended_halos` that is mentioned here; https://github.com/CliMA/Oceananigans.jl/blob/a6e9a465aa9528b5b3afd49737310e710e4681b0/src/MultiRegion/multi_region_split_explicit_free_surface.jl#L19-L28. For serial grids, `extended_halos` is not the correct argument, though, because we do not extend halos (we do that only on distributed and multi region grids), so maybe something like `use_boundary_aware_operators.` . Once the numerics have been settled we can adapt the open boundary condition implementation to the special operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2399186268:566,adapt,adapt,566,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2399186268,3,"['adapt', 'extend']","['adapt', 'extend']"
Modifiability,"And just to clarify, when I say ""extend"" I'm referring to ""method extension"" --- in other words, defining new methods for a function that *dispatch* on the number or arguments and argument types.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761152934:33,extend,extend,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761152934,1,['extend'],['extend']
Modifiability,"Another application is for regularization in parameterizations, for example:; ```julia; Ri = ℑxyᶜᶜᵃ(i, j, k, grid, ℑxyᶠᶠᵃ, diffusivities.Ri) # Not boundary-aware . Ri = ℑxyᶜᶜᶜ(i, j, k, grid, ℑxyᶠᶠᶜ, diffusivities.Ri) # Boundary-aware ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3158#issuecomment-1610955565:45,parameteriz,parameterizations,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3158#issuecomment-1610955565,1,['parameteriz'],['parameterizations']
Modifiability,"Another benefit of removing the hydrostatic pressure is that we can improve the documentation and user interface too. For example, the hydrostatic pressure in the hydrostatic model is stored in something like. ```; model.pressure.pHY; ```. since for the nonhydrostatic model its. ```; model.pressures.pNHS; model.pressures.pHY; ```. With just one pressure field we should simply write `model.pressure` for both cases. It's a significant refactor to remove hydrostatic pressure --- I don't think we want to do the hacky thing that we did to set up that PR that just keeps the same structures but sets pressure to `nothing`, we want to do it properly and update the docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518172281:437,refactor,refactor,437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518172281,1,['refactor'],['refactor']
Modifiability,"Another design we can consider is something like:; ```julia; grid = RegularCartesianGrid(size=(x=128, z=64), x=(-1, 1), z=(-1, 0), topology=(x=Periodic, z=Bounded)); ```; where since `y` has not been specified, it is assumed to be `Flat`. This makes the grid constructors more verbose but has the added benefit of being clearer and not having to specify flat dimensions, i.e. it's an xz-model so y should not even be mentioned. It would require a lot more refactoring though... but now's the time I guess.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/614#issuecomment-581830270:456,refactor,refactoring,456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/614#issuecomment-581830270,1,['refactor'],['refactoring']
Modifiability,Another outstanding issue is the formulation of tracer evolution. At the moment we are evolving tracers but maybe we want to evolve thickness weighted tracers,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165844286:125,evolve,evolve,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165844286,1,['evolve'],['evolve']
Modifiability,Another possibility is that we refactor the code to generalize integer types. Which is not actually a horrible idea. There's some notion that we may also benefit from index types that are `Int32`. Adding an integer type for `Nx` would allow us to also automatically convert integers to `Int32` (eg we write something like `i = inttype(grid)`).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731452482:31,refactor,refactor,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731452482,1,['refactor'],['refactor']
Modifiability,"As a side note: I started working on a PR that adds tests to make sure we can write output from all grids, which would also help with #1429. But yeah, I don't think it'll be a quick PR since the grids all use different property names... Sounds like the variable names used in NetCDF might be an issue? I've had no problems with unicode variable names in NetCDF but I don't use IPython...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799818546:253,variab,variable,253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799818546,2,['variab'],['variable']
Modifiability,"As a user, I prefer an internal ""settings"" dictionary over an environment variable. Actually, I think it would be better to define a function `Oceananigans.set_default_number_type(FT)` for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. Another option is to pass `FT=Float32` to the model and then let the constructor convert related components to `Float32` \(or `Float64` if `FT=Float64` is passed\). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644:74,variab,variable,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644,1,['variab'],['variable']
Modifiability,"As discussed with @jm-c, I think another feature we will need is the ability to design closure-specific temporary variables. For example, the implementation of Constant Smagorinsky or Anisotropic Minimum Dissipation will benefit from the ability to compute the eddy viscosity (at 4 locations in a cell --- 3 `FaceField`s and 1 `CellField`) and re-use it in calculating the contribution of the subgrid closure to the momentum 'source terms'.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-467660286:114,variab,variables,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-467660286,1,['variab'],['variables']
Modifiability,"As for the `with_halo`, I am testing things out in REPL. Below you see that I have `with_halo` defined already but when I try the line you suggested it says that the function must be explicitly exported to be extended. Sorry that my function defining chops are not skilled enough to figure this out. ```; julia> methods(with_halo); # 2 methods for generic function ""with_halo"":; [1] with_halo(new_halo, old_grid::RegularRectilinearGrid) in Oceananigans.Grids at /home/fpoulin/software/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:218; [2] with_halo(new_halo, old_grid::VerticallyStretchedRectilinearGrid) in Oceananigans.Grids at /home/fpoulin/software/Oceananigans.jl/src/Grids/vertically_stretched_rectilinear_grid.jl:242. julia> with_halo(halo, ibg::ImmersedBoundaryGrid) = ImmersedBoundaryGrid(with_halo(halo, ibg.grid), ibg.immersed_boundary); ERROR: error in method definition: function Grids.with_halo must be explicitly imported to be extended; Stacktrace:; [1] top-level scope; @ none:0; [2] top-level scope; @ REPL[40]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844329017:209,extend,extended,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844329017,2,['extend'],['extended']
Modifiability,"As of PR #3783 the current config is to retry automatically once, but only if the exit status is 1. ```; retry:; automatic:; - exit_status: 1 ; limit: 1; ```. So I think this issue has been resolved. Thanks @glwagner!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3773#issuecomment-2397334483:27,config,config,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3773#issuecomment-2397334483,1,['config'],['config']
Modifiability,As part of the examples refactor I'm wondering whether we should we also change some of the examples to use a Makie variant for plotting?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1064460506:24,refactor,refactor,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1064460506,1,['refactor'],['refactor']
Modifiability,"As part of this PR it would probably make sense to refactor the interface between `Simulation` and output writers a bit. For example, `Callback` has a place to insert custom `initialize!` but output writers do not:. https://github.com/CliMA/Oceananigans.jl/blob/82503b811a305bd7a6c4f1d3650f2b25b535c8fa/src/Simulations/run.jl#L200-L214. The natural way to throw a warning would be during initialization, which should depend on both the output writer and the simulation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3312#issuecomment-1749299406:51,refactor,refactor,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3312#issuecomment-1749299406,1,['refactor'],['refactor']
Modifiability,"As soon as I put `fig[0, :] = Label(fig, title, textsize=24)` then the plot size gets all small and weird... Any ideas?. ```Julia; using GLMakie. filename = ""internal_wave"". fig = Figure(resolution = (800, 400)). ax = Axis(fig[1, 1];; xlabel = ""x"",; ylabel = ""z"",; limits = ((-π, π), (-π, π)),; aspect = AxisAspect(1)). iter = Observable(0). using JLD2. file = jldopen(filename * "".jld2""); grid = file[""serialized/grid""]. title = @lift(string(""ωt = "",; string(round(file[""timeseries/t/"" * string($iter)] * ω, digits=3)))). w = @lift(Array(file[""timeseries/w/"" * string($iter)][:, 1, :])). x, y, z = nodes((Center, Center, Center), grid). w_lim = 1e-8; w_levels = range(-w_lim, stop=w_lim, length=10). contourf!(ax, x, z, w; ; levels = w_levels,; colormap = :balance,; colorrange = (-w_lim, w_lim),; extendlow = :auto,; extendhigh = :auto). fig[0, :] = Label(fig, title, textsize=24). iterations = parse.(Int, keys(file[""timeseries/t""])). record(fig, filename * "".mp4"", iterations, framerate=8) do i; @info ""Plotting iteration $i of $(iterations[end])...""; iter[] = i; end; ```. https://user-images.githubusercontent.com/7112768/168449952-2ce68db5-1e21-4f04-8dc8-a29d2fba6c57.mp4. While with **everything same except** the line `fig[0, :] = Label(fig, title, textsize=24)` I get. https://user-images.githubusercontent.com/7112768/168450064-ab456174-06da-45e4-8674-55f0a3356091.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126821142:799,extend,extendlow,799,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126821142,2,['extend'],"['extendhigh', 'extendlow']"
Modifiability,"As we also discussed on slack, using threads (or tasks) won't work since to capture the output the global stdout variable is changed. You need `pmap` or launch new processes with `run`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576427498:113,variab,variable,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576427498,1,['variab'],['variable']
Modifiability,"Assuming this is the last API changing PR for now, would be good to get this merged and a new version tagged so we can refactor and stabilize simulation scripts. Let me know if you'd like me to work on anything.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533082343:119,refactor,refactor,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533082343,1,['refactor'],['refactor']
Modifiability,"At the moment I'm playing with rectilinear and lon-lat grids, so those are the ones that I'm thinking about. However, I appreciate that we want these methods to work on all the grids that we support. . On these two grids, we could use the difference operators without any concern, for both the vertical component of vorticity and the horizontal component of divergence. No problem there. If you use Green's theorem to rewerite the integral of a vorticity as a circulation integral, then we should be able to rewrite the horizontal divergence using Gauss' divergence theorem as a line integral. Maybe that would generealize better to more exotic grids?. I will look at the paper you cited. Thanks for pointing this out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2575#issuecomment-1136345956:508,rewrite,rewrite,508,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2575#issuecomment-1136345956,1,['rewrite'],['rewrite']
Modifiability,"At the moment, this PR allows slab decomposition in x and y, and pencil decomposition in x, y.; This PR implements these transposes:; ```julia; z -> y; y -> x; x -> y ; y -> z; ```; where the above letter stands for the ""free"" direction (the direction that is completely local). We always start from the `z` configuration because we do not want to support z-decompositions (because of possible vertical integrals and implicit vertical diffusion). ; The FFT based algorithm is ; ```julia; z_transform! ; z -> y; y_transform!; y -> x; x_transform!; division by λ; x_transform!; x -> y ; y_transform!; y -> z; z_transform!; ```; The whole procedure needs 4 transposes for pencil decomposition and 2 for slab decomposition.; I am still working on implementing the Fourier tridiagonal solver, which is very easily done naively by increasing the number of transposes:; ```julia; z -> y; y_transform!; y -> x; x_transform!; x -> y ; y -> z; tridiagonal_solve!; z -> y; y_transform!; y -> x; x_transform!; x -> y; y -> z; ```; This requires 8 transposes though, which would kill any possibility of scaling even if we completely fill the GPU memory.; I would like to ensure that we always do a maximum of 4 transposes (2 forward and 2 backward).; This means playing with memory in the background, I still have to do a little bit of thinking to ensure it, maybe I have to define other transposes like; ```julia; x -> z; z -> x; ```; which would remove two of them but it is slightly more complicated. This is because, in the previous transposes we switch partitioning between the in and out free direction while the third dimension remains untouched. On the other hand, z-configuration and x-configuration also have a differently partitioned y-direction which makes the transpose process between `x` and `z` non-trivial",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1731333132:308,config,configuration,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1731333132,3,['config'],['configuration']
Modifiability,Awesome!. How big is `wet_cells_map`? Should we extend `ImmersedBoundaryGrid` so that users can opt in/opt out of this feature?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317226117:48,extend,extend,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317226117,1,['extend'],['extend']
Modifiability,"BTW, the progress function does not have to run on the GPU, which means that flexible callable objects can be used which have embedded parameters. This is the way I envision progress function development moving forward. We may want eventually to have complex progress functions for fancy logging / in-terminal plotting, eg. A `simulation.parameters` field is probably not the right approach --- we want callable objects, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/639#issuecomment-590147928:77,flexible,flexible,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/639#issuecomment-590147928,1,['flexible'],['flexible']
Modifiability,"Bah, I realized this won't work because we have to call `compute!` on all leaves of an expression tree. For that it's important that `compute!(::AbstractOperation)` doesn't do anything. We can support this if we change that interface, eg if we add something `compute_leaf!`. Then we can adapt `compute!` for public use and update the private methods like `compute_leaf!` as needed. Might not be worth it, probably there's other stuff we also need to work on if we want totally beautiful REPLness.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432:287,adapt,adapt,287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432,1,['adapt'],['adapt']
Modifiability,"Based on some previous benchmarks I think so; https://github.com/climate-machine/Oceananigans.jl/blob/3cd4ae32cb4d716bc6470a6e7ba484ed98d60de7/benchmark/gpu.jl#L164-L198; Basically I wrote an _x_-difference operator that used `@. @views` which allowed it to act on Arrays and CuArrays, and when acting on a CuArray it was only ~10x faster compared to single-core CPU performance. While the entire time-stepping loop we have using GPUifyLoops.jl is ~90x faster. **However** I don't think I did the benchmarking there properly (have to use `@benchmark CuArrays.@sync` I believe) and maybe I didn't use `@. @views` properly. I think using broadcasts would make the code much more readable, but I can think of a few drawbacks (mainly related to performance):. 1. I don't know how to fuse kernels when doing broadcasts. E.g. we might be able to do something like; ```julia; @. Gu = calc_RHS_u(u, v, w, ...); @. Gv = calc_RHS_v(u, v, w, ...); ...; ```; which would look cleaner but then `update_source_terms!` would end essentially end up in several kernels. From talking with you I believe this shouldn't matter as kernel launches are cheap and the broadcast operator should essentially do exactly what `update_source_terms!` does, but I'm not 100% sure of this and we may lose out on performance. 2. We may want to fine tune our kernel launches, e.g. by using the thread-block layout we want which is probably possible, I'm just not very familiar with the CuArrays.jl package. 3. Some kernels, e.g. ones that do permutations like `calculate_source_term_divergence_gpu!` and `idct_permute!` can't be broadcasted over I think, but these are the exception rather than the rule. To really find out whether we take a performance hit we might have to refactor the time-stepping to use broadcasting then benchmark the two approaches on CPU, GPU, and multi-GPU architectures (not sure if CuArrays.jl will do multi-GPU arrays yet). This will become much easier once #67 is resolved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/108#issuecomment-469765393:1741,refactor,refactor,1741,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/108#issuecomment-469765393,1,['refactor'],['refactor']
Modifiability,"Before this issue is resolved, one solution is to use callable objects:. ```julia; struct ParameterizedCallback{P}; parameters :: P; end. (cb::ParameterizedCallback)(simulation) = # function that depends on both `sim` and `cb.parameters`. cb = ParameterizedCallback(parameters) # builds the callable object, capturing `parameters`. simulation.callbacks[:callback] = Callback(cb, IterationInterval(10)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1001249933:90,Parameteriz,ParameterizedCallback,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1001249933,3,['Parameteriz'],['ParameterizedCallback']
Modifiability,"Both `IncompressibleModel` and `ShallowWaterModel` use the more general `model_forcing` now, but I had to refactor `regularize_forcing` a bit as it needs the `model_field_names` when constructing `Relaxation` forcings and `ContinuousForcing`s with field dependencies. Tests passed on Tartarus but might be good if @glwagner had a quick look to make sure it's okay.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756838133:106,refactor,refactor,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756838133,1,['refactor'],['refactor']
Modifiability,"BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}}},SpatialWindowAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos/Oceananigans.jl/sandbox/windowed_spatially_averaged.jl:111; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos/Oceananigans.jl/sandbox/windowed_spatially_averaged.jl:111; ```; </details>. I've tried expanding the struct to include a grid parameter (based off of how `AveragedField` is programmed` and then defining `compute!` but I haven't been able to make it work. Any tips?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170:16548,sandbox,sandbox,16548,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170,2,['sandbox'],['sandbox']
Modifiability,"Btw, the problem is not related with bathymetry directly. It's related with the Heptadiagonal Matrix-based free surface solver. When there is an immersed boundary the default free-surface solver is the Heptadiagonal Matrix-based solver so that's why we get the error above. But an immersed boundary grid is not really required. ```julia; test_Oceananigans/ $ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.5 (2023-01-08); _/ |\__'_|_|_|\__'_| |; |__/ |. (@v1.8) pkg> activate .; Activating new project at `~/Research/test_OC`. (test_Oceananigans) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General.toml`; Resolving package versions...; Updating `~/Research/test_OC/Project.toml`; [9e8cae18] + Oceananigans v0.84.1; Updating `~/Research/test_OC/Manifest.toml`; [621f4979] + AbstractFFTs v1.4.0; [79e6a3ab] + Adapt v3.6.2; [4fba245c] + ArrayInterface v7.4.11; [a9b6321e] + Atomix v0.1.0; [ab4f0b2a] + BFloat16s v0.4.2; [fa961155] + CEnum v0.4.2; [179af706] + CFTime v0.1.2; [052768ef] + CUDA v4.4.0; [1af6417a] + CUDA_Runtime_Discovery v0.2.2; [d360d2e6] + ChainRulesCore v1.16.0; [9e997f8a] + ChangesOfVariables v0.1.8; [1fbeeb36] + CommonDataModel v0.2.4; [34da2185] + Compat v4.7.0; [a8cc5b0e] + Crayons v4.1.1; [7445602f] + CubedSphere v0.2.3; [9a962f9c] + DataAPI v1.15.0; [864edb3b] + DataStructures v0.18.14; [e2d170a0] + DataValueInterfaces v1.0.0; [ffbed154] + DocStringExtensions v0.9.3; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.9; [7a1cc6ca] + FFTW v1.7.1; [5789e2e9] + FileIO v1.16.1; [0c68f7d7] + GPUArrays v8.8.1; [46192b85] + GPUArraysCore v0.1.5; [61eb1bfa] + GPUCompiler v0.21.4; [c27321d9] + Glob v1.3.1; [615f187c] + IfElse v0.1.1; [40713840] + IncompleteLU v0.2.1; [3587e190] + InverseFunctions v0.1.11; [92d709cd] + IrrationalConstants v0.2.2; [42fd0dbc] + IterativeSolvers v0.9.2;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:991,Adapt,Adapt,991,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243,1,['Adapt'],['Adapt']
Modifiability,"But currently the array type *is* a parameter in the [`CellField` definition](https://github.com/ali-ramadhan/Oceananigans.jl/blob/6ec7cc23393bd5fdce846e1b3eb601fcd1901af4/src/fields.jl#L12). I am referring to the [constructor for `CellField`](https://github.com/ali-ramadhan/Oceananigans.jl/blob/6ec7cc23393bd5fdce846e1b3eb601fcd1901af4/src/fields.jl#L71) (for example), which use branches rather than multiple dispatch to construct fields with different array types. It's not a huge deal, but I think using multiple dispatch is cleaner and easier to extend than using branches and `metadata`. You may not even need `metadata` to be an attribute of the fields, or the model. The fact that a GPU architecture is being used can be inferred from the type of the coordinate arrays and FFT plans and whatnot.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/45#issuecomment-462788747:552,extend,extend,552,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/45#issuecomment-462788747,1,['extend'],['extend']
Modifiability,But question: floats need adaptation?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2166702826:26,adapt,adaptation,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2166702826,1,['adapt'],['adaptation']
Modifiability,"CUDA v2.4.0 is out but we're blocked by OffsetArrays.jl now, which might remove the Adapt.jl dependency (https://github.com/JuliaArrays/OffsetArrays.jl/issues/174) so might not be worth waiting for all dependencies to support Adapt v3.0.0. If tests pass with CUDA v2.4.0 I say we merge this PR and close #1287.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372:84,Adapt,Adapt,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372,2,['Adapt'],['Adapt']
Modifiability,Calculation via $$\log_2(\vert \frac{progn}{tend} \vert)$$. with $progn$ being the prognostic variable (zonal velocity above) and $tend$ being the tendency taken as two consecutive time steps from the output. It's not exactly that obv because the AB2 time stepper works a bit differently but it's probably good enough! So this quantity is essentially the orders of magnitude (as power of 2) that the prognostic variables are larger than the tendencies. This is equivalent to the mantissa bits of precision lost in the addition of the two.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672146256:94,variab,variable,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672146256,2,['variab'],"['variable', 'variables']"
Modifiability,"Can we just compare 1) the topology and 2) all of the nodes? I think that would be sufficient to determine equality. I'm worried if we don't explicitly check the topology that we might run into some edge cases where the nodes / spacings are the same but the topologies are different (these would possibly be pathological with 0 halo in a periodic / flat direction, but still good to explicitly check I think...). When comparing numeric equality for nodes, we should add `@allowscalar` as needed there. I think we should add a test that equality works as expected, as well. We should also add a test for checkpointing on stretched grids. I think its ok if we don't support a numeric equality for other grids --- we can build them up one at a time. They are specific to each grid. The main downside here is that we need to refactor our grid implementation to have a single `RectilinearGrid` (there's no reason to have different rectilinear grid types, since we can dispatch on the case that certain directions have constant spacing easily). So this code will go away when we make that change. But I think it's a useful incremental improvement for now while we still have two rectilinear grids, so I'm fine to have it go in once it's cleaned up. Because of this:. ```julia; julia> using CUDA. julia> a = rand(2); 2-element Vector{Float64}:; 0.8207604162394306; 0.3815099688071648. julia> b = CuArray(a); 2-element CuArray{Float64, 1}:; 0.8207604162394306; 0.3815099688071648. julia> CUDA.@allowscalar a == b; true; ```. I think that this will work if the checkpointed grid is deserialized onto the CPU, even though `model.grid` is on the GPU. I think this is what we want, so that's fortunate the above works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945919406:821,refactor,refactor,821,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945919406,1,['refactor'],['refactor']
Modifiability,"Can we start by refactoring this PR to implement this functionality in an example script? It could perhaps go in [`validation/biogeochemistry`](https://github.com/CliMA/Oceananigans.jl/tree/main/validation/biogeochemistry). Once we have that cleaned up, we might be able to see what parts of it belong in the source code versus left to users?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252870856:16,refactor,refactoring,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252870856,1,['refactor'],['refactoring']
Modifiability,Can you explain? Why does a function like `read_output` depend on whether the time step is constant? Why does any part of the code need to assume a constant time-step?. I think adaptive time-stepping is useful in many scenarios and the time-step should not be assumed constant in general.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/37#issuecomment-462546680:177,adapt,adaptive,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/37#issuecomment-462546680,1,['adapt'],['adaptive']
Modifiability,Can you write these possibilities for variable `ν` (eg `ν` must always appear inside the divergence)? These don't all have the same dimensions --- what's happening?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089417262:38,variab,variable,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089417262,1,['variab'],['variable']
Modifiability,"Can't reproduce the problem. On tartarus with Julia v1.8:. ```Julia; julia> grid = RectilinearGrid(GPU(), size=(16, 16, 16), x=(0,1), y=(0,1), z=0:16); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [0.0, 16.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> minimum_zspacing(grid); 1.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1498623545:389,variab,variably,389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1498623545,1,['variab'],['variably']
Modifiability,"CenteredSecondOrder` advection and `ScalarDiffusivity` with constant coefficients; * Large eddy simulation with `SmagorinskyLilly` or `AnisotropicMinimumDissipation` turbulence closures; * Idealized problems (eg two-dimensional turbulence) in 1-3 dimensions that use Laplacian, biharmonic, or implicit numerical dissipation.; 2. `HydrostaticFreeSurfaceModel`, which solves the hydrostatic Boussinesq equations with linear free surface dynamics and a `z` coordinate. The hydrostatic model is useful for larger scale simulations, eg regional ocean modeling, and can be used with `RectilinearGrid` stretched in any or all directions as well as a `LatitudeLongitudeGrid`. We have a prototype closure for vertical mixing called `CATKEVerticalDiffusivity` (paper coming soon...) as well as a `RiBasedVerticalDiffusivity` and `ConvectiveAdjustment` that support implicit time discretization for vertical diffusion. We have a new high-order advection scheme specialized for geophysical turbulence / mesoscale turbulence problems that uses a vector invariant formulation. We can treat the free surface dynamics implicitly in time with various methods (FFT-based on rectilinear grids with flat bottoms, or preconditioned conjugate gradient based with various preconditioners in other situations). We also have a `SplitExplicitFreeSurface`. All models support complex domains / bathymetry via `ImmersedBoundaryGrid`, a variety of Coriolis forces (`FPlane`, `BetaPlane`, as well as some more exotic options), a wide variety of boundary conditions for any prognostic variable on any model boundary. Note however that the pressure solver for `NonhydrostaticModel` is only approximate on `ImmersedBoundaryGrid` (we are working on an exact pressure solver for immersed boundaries). We don't support simulations on the full sphere, or sea ice, yet, but we are working on both of those. Let me know if you have any specific questions about capabilities, I'm curious to hear what problems you're interested in tackling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3126#issuecomment-1572601030:2708,variab,variable,2708,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3126#issuecomment-1572601030,1,['variab'],['variable']
Modifiability,"Certainly vertically implicit would be useful. John. On Sun, Dec 22, 2019, 12:37 PM Ali Ramadhan <notifications@github.com>; wrote:. > Is this something we want to implement in the future? Would 3D implicit; > diffusion be useful or just vertically implicit?; >; > I ask because if so it might influence some choices I make when; > refactoring the Poisson solvers.; >; > Vertically implicit diffusion can be implemented with just the; > BatchedTridiagonalSolver. For 3D implicit diffusion I believe we can do a; > Poisson solve similar to what we do for the pressure but I haven't worked; > out the math in 3D.; >; > It's probably not needed for the boundary layer turbulence LES but maybe; > vertically implicit would be useful for mesoscale simulations?; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/587?email_source=notifications&email_token=AKXUEQR5Y3QKOYPBB5XJQ23QZ6QWVA5CNFSM4J6MYQLKYY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4ICGK7SQ>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQQZMJBXVFTSSUI6JFDQZ6QWVANCNFSM4J6MYQLA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/587#issuecomment-568286497:332,refactor,refactoring,332,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/587#issuecomment-568286497,1,['refactor'],['refactoring']
Modifiability,Changed the title slightly as it is being adapted: https://github.com/CliMA/Oceananigans.jl/blob/bf767af3c40c049ebc9499b7553065a9ef350178/src/ImmersedBoundaries/partial_cell_bottom.jl#L72-L84,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269861562:42,adapt,adapted,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269861562,1,['adapt'],['adapted']
Modifiability,Closing as I think we agreed that in this case it's better to load initial conditions from disk than add a portable random number generate as a utility.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/176#issuecomment-506994970:107,portab,portable,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/176#issuecomment-506994970,1,['portab'],['portable']
Modifiability,Closing this because this refactoring needs to be done with a bit more care.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/921#issuecomment-691032752:26,refactor,refactoring,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/921#issuecomment-691032752,1,['refactor'],['refactoring']
Modifiability,Closing this issue as @maleadt has figured out how to compute dynamic launch configurations for kernels. @glwagner has also proposed a thread-block layout abstraction in PR #249 that we can switch to if needed.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/64#issuecomment-500234807:77,config,configurations,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/64#issuecomment-500234807,1,['config'],['configurations']
Modifiability,"Consider:. * The Adams-Bashforth time stepper is not well-suited for adaptive time-stepping, because it requires a initialization step. Thus it behooves scientists to update their time-step only infrequently. * However, during model spinup / transition to turbulence, a sharp change in flow regime may occur. This sharp change necessitates updating the time-step frequently to avoid blow up (an alternative strategy is to take uniform small time-steps during this time, which is safer but will take longer). * In addition to the need to update a time-step frequently near transition to turbulence, it is *also* wise to take conservatively small time-steps . Because of these considerations I am not sure it makes sense to add `spinup_cfl`, which only addresses the last, minor point. The main feature that is needed is a change in the frequency at which the time-step is updated (we currently do this manually by writing two loops). However, a change in update frequency is only really needed because Adams-Bashforth is ill-suited for adaptive time stepping (otherwise it'd be fine to update frequently even in the main loop). So it's a hack-on-a-hack. What do you think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520824946:69,adapt,adaptive,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520824946,2,['adapt'],['adaptive']
Modifiability,"Copy pasting a comment by @glwagner from #601 so it doesn't get lost in a closed PR:. > It's an interesting philosophical question whether fields should carry around their boundary conditions or not. @kburns might have something to say. I think there are some good arguments in favor of this view.; > ; > There are some oddities: for example, the boundary conditions on pressure are not zero gradient; however we use these ""effective"" boundary conditions for convenience and (at least eventually) will include inhomogeneous parts of the pressure boundary condition on the RHS of the pressure Poisson equation. So at least for pressure the ""boundary conditions"" we would specify are not actually the true boundary conditions.; > ; > Once we have topological information embedded in our `AbstractGrid`, adding default boundary conditions for fields may not be too difficult. But it may not just be a refactor. It seems it might change the user API, too.; > ; > _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/pull/601#issuecomment-579560026_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580295810:898,refactor,refactor,898,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580295810,1,['refactor'],['refactor']
Modifiability,"Correct. Buildkite doesn't support any templating last I looked.The `codecov` variable is currently unused though, so you can leave that out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063345075:78,variab,variable,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063345075,1,['variab'],['variable']
Modifiability,Could be a failure of `Adapt.jl`'s method for tuples and named tuples:. https://github.com/JuliaGPU/Adapt.jl/blob/a62a2568f1199d0e7b154eb6001afa629d31038e/src/base.jl#L3,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-668065550:23,Adapt,Adapt,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-668065550,2,['Adapt'],['Adapt']
Modifiability,"Curious if @glwagner has any thoughts on `backend_kw` vs. `reader_kw`, but I'm thinking of renaming to `reader_kw` then potentially revising the naming in a future refactor of `OutputReaders` (probably as part of supporting NetCDF).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2441901434:164,refactor,refactor,164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2441901434,1,['refactor'],['refactor']
Modifiability,"Currently in my workflow, I define an environment variable that contains an string like `$init_$end.nc`, where `init` is the initial time and `end` is the `stop_time` of the simulation. In the first instantiation of the model for 60 days, this string will be appended to my output filename e.g.`vel_field_`, resulting on something like `vel_field_0_60.nc`. For the next pickup the filename will be changed to `vel_field_60_120.nc`. This works well when the files are not split, i.e. `file_splitting = NoFileSplitting()`. However when splitting the file, e.g. `file_splitting = TimeInterval(30days)`, the first instantiation will result in the following files:; ```; vel_fields_0_60_part1.nc vel_fields_0_60_part2.nc vel_fields_0_60_part3.nc; ```; then the next pickup will result in files: ; ```; vel_fields_60_120_part1.nc vel_fields_60_120_part3.nc vel_fields_60_120_part5.nc; vel_fields_60_120_part2.nc vel_fields_60_120_part4.nc; ```; of this files, the first 2 parts (`vel_fields_60_120_part1.nc` and `vel_fields_60_120_part2.nc`) are empty, and the `vel_fields_60_120_part3.nc` contains data from the day 61 until 91. This makes the loading of the data for post-processing a bit tricky, since some of they are empty and the disk storage will make more difficult chunking data. . If I don't change the name each time I pickup, with the `overwrite_existing=false` it crashes, and with `overwrite_existing=true` it rewrites all the files. . Another workflow will be to create a new folder for each pickup keeping the same filename, but splitting the files will result in the same issue of file duplication. . I hope this description of the workflow is clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391946301:50,variab,variable,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391946301,2,"['rewrite', 'variab']","['rewrites', 'variable']"
Modifiability,"Dedalus currently has a binary configuration option to cache the evaluation of every intermediate operation within a single timestep / sub-stage. The recursive evaluation of an operator tree accepts and propagates a cache-key argument, which could be related to e.g. the simulation iteration and sub-stage. If caching is enabled, each operator checks it's own size-1 cache for the cache-key, and returns the result if present. Otherwise it evaluates itself, and stores the result under the cache-key. . This eliminates the repeated evaluation of individual operators, but at the cost of storing the result of every intermediate operation. We're currently working on an upgrade that first traverses the tree, counts the number of references to a given operator, and deallocates the cached result after the cache has been accessed the corresponding number of times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694332991:31,config,configuration,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694332991,1,['config'],['configuration']
Modifiability,"Definitely worth thinking about improving our algorithm. With the halo region implementation we have `fill_halo_regions!(::Grid, fields...)` which is somewhat a step towards your 2, but maybe we don't want to mix boundary conditions and distributed parallelization too much. What Palm does, especially step C, sounds a lot like what the MITgcm does I believe. For now though I don't have much time and need to change projects for a little while so I'm going to create a `channel-model` branch and rewrite the operators and Poisson solver to quickly implement a channel model prototype to play around with a bit. Then I'll revisit the `channel-model` branch when I have more time to build the appropriate abstractions, e.g.; ```julia; abstract type GridBoundaryType end; struct Periodic <: GridBoundaryType end; struct Bounded <: GridBoundaryType end; Grid{A<:AbstractArray, R<:AbstractRange, BX<:GridBoundaryType, BY<:GridBoundaryType, BZ<:GridBoundaryType}; ```; and properly merge it into master with tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-483905865:497,rewrite,rewrite,497,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-483905865,1,['rewrite'],['rewrite']
Modifiability,Did some refactoring and CPU and GPU hydrostatic regression tests pass locally so I think this PR is ready for review!. @simone-silvestri Requesting a review from you on your own PR again lol but I won't approve unless you do.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2400089856:9,refactor,refactoring,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2400089856,1,['refactor'],['refactoring']
Modifiability,"Dispatching on the location as a parameterized type looks neat, would definitely clean things up! Thanks for coding up the example. I see how this would clean things up for `δz_f2c` and `δz_e2f` but the δz operator also needs to know onto which location to interpolate, so how would this work with `δz_f2c` and `δz_f2e`?; ```julia; @inline function δz_f2c(f, Nz, i, j, k); if k == Nz; @inbounds return f[i, j, k]; else; @inbounds return f[i, j, k] - f[i, j, k+1]; end; end. @inline function δz_f2e(f, Nz, i, j, k); if k == 1; return 0; else; @inbounds return f[i, j, k-1] - f[i, j, k]; end; end; ```. To me it looks like they both fit; ```julia; δz(f::Field{Lx, Ly, Lz}, i, j, k) where {Lx, Ly, Lz<:Interface} = ...; ```; so I'm not sure how dispatch between the two.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-471177715:33,parameteriz,parameterized,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-471177715,1,['parameteriz'],['parameterized']
Modifiability,Distributed IO is not supported yet and will require a lot of work and refactor so for the time being we have to do with the rank in the output writers,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895864384:71,refactor,refactor,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895864384,1,['refactor'],['refactor']
Modifiability,"Do not merge yet. There's a GPU bug with `calc_diffusivities!`. Since we now use `config=launch_config(grid, 3)`, the z loop needs to be; ```julia; @loop for k in (1:grid.Nz; (blockIdx().z - 1) * blockDim().z + threadIdx().z); ```; instead of; ```julia; @loop for k in (1:grid.Nz; blockIdx().z); ```; since `launch_config` will return block sizes where `Bz != Nz`. Will commit a fix once I test it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/315#issuecomment-516134494:82,config,config,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315#issuecomment-516134494,1,['config'],['config']
Modifiability,Do these changes mean that we need to rewrite the PR that makes things more concrete? It looks like there will be a lot of merge conflicts.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/290#issuecomment-506888727:38,rewrite,rewrite,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/290#issuecomment-506888727,1,['rewrite'],['rewrite']
Modifiability,"Do we currently have a function to retrieve spacings that considers whether a cell is ""wet"" or not? Meaning it considers whether a cell is part of the interior of the domain or is a halo/immersed solid cell when calculating `Δz`? Or maybe there's a way to use abstract operation metrics to do this that I'm not aware?. For example in the script below, I can retrieve `Δz` directly from `grid`, but the edges do not reflect the fact that the `z` direction is bounded. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size = (4, 4, 4), x=(0,1), y=(0,1), z=0:0.25:1); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.25, max(Δz)=0.25. julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; 5-element Vector{Float64}:; 0.25; 0.25; 0.25; 0.25; 0.25; ```. To be in line with [`xgcm`'s standards for metrics](https://github.com/xgcm/xgcm/issues/306#issuecomment-776124591) the output in the above case (considering only the ""wet"" or interior or fluid-filled cells when calculating `Δz`) should be; ```julia ; julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; 5-element Vector{Float64}:; 0.125; 0.25; 0.25; 0.25; 0.125; ```; since the first and last spacings on a bounded grid are ""half inside the domain and half outside"". I looked for ways to do this in that are already in the code but couldn't find anything. I wanted to ask before I started coding something from scratch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1182527618:812,variab,variably,812,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1182527618,1,['variab'],['variably']
Modifiability,"Do we think maybe just extending the existing pattern of input validation functions (`validate_coriolis`, `validate_advection`, etc) is a good route?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057:23,extend,extending,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057,1,['extend'],['extending']
Modifiability,"Do you want to add this here: https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans ? . Let's phase these ""extended instructions"" out of the Documenter-based docs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2472#issuecomment-1109068285:150,extend,extended,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2472#issuecomment-1109068285,1,['extend'],['extended']
Modifiability,"Does anyone know how I can add Codecov coverage in our [buildkite pipeline](https://github.com/CliMA/Oceananigans.jl/blob/ncc/adds-codecov/.buildkite/pipeline.yml)?. From what I read at [`JuliaGPU/buildkite/README`](https://github.com/JuliaGPU/buildkite/blob/main/README.md) here, I get that I have to add:. ```Julia; plugins:; - JuliaCI/julia#v1:; version: ""1""; - JuliaCI/julia-test#v1: ~; - JuliaCI/julia-coverage#v1:; codecov: true; ```. in *every* step in our buildkite pipeline. Is this correct?. cc @maleadt, @vchuravy",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063309592:318,plugin,plugins,318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063309592,1,['plugin'],['plugins']
Modifiability,"Does it check for NaNs everywhere (i.e., in all grid points of `model.velocities` and `model.tracers`)?; If a NaN is developed somewhere then surely after 1-2 time-steps there will be NaNs everywhere, no?; So it suffices to check only one field... a field that is always there regardless the 1D/2D/3D configuration?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1198#issuecomment-732882332:301,config,configuration,301,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1198#issuecomment-732882332,1,['config'],['configuration']
Modifiability,"Done!. ```Julia; julia> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)); 1×1×3 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [1.0, 16.0] variably spaced with min(Δz)=3.0, max(Δz)=7.0. julia> grid = RectilinearGrid(size=3, z= x->-x^2, topology=(Flat, Flat, Bounded)); ERROR: ArgumentError: z should have increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::var""#41#42"", dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:126; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::var""#41#42""); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Function); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Function, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[22]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3319#issuecomment-1751328718:227,variab,variably,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319#issuecomment-1751328718,1,['variab'],['variably']
Modifiability,"During the coefficients down to 1e-9 (!!) allows 3 stable time steps _when continents / bathymetry are removed_:. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 226.942 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (288.084 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.446 seconds).; ┌ Info: Iteration: 1, time: 20 minutes, wall time: 1.452 seconds; │ ├── max(u): (1.32e-16, 5.40e-02, 6.44e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 5.93e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 945.169 ms; │ ├── max(u): (1.39e-02, 1.06e-01, 1.05e-03) m s⁻¹; │ ├── extrema(T): (0.05, 30.00) ᵒC; └ └── max|η|: 1.33e+00 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 1 hour, wall time: 945.031 ms; │ ├── max(u): (3.55e-02, 1.52e-01, 1.37e-03) m s⁻¹; │ ├── extrema(T): (0.15, 30.00) ᵒC; └ └── max|η|: 2.08e+00 m; ```. But when they're put back, it still blows up (even with coefficients 1e-9):. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = ImmersedBoundaryGrid on:; architecture: CPU(); grid: 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bound",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807:486,variab,variably,486,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807,1,['variab'],['variably']
Modifiability,"Everything useful that I have is probably in the draft PR #2275 and the associated branch! They aren't forcing functions, but we hard coded in some drag functions for the flux in the IB case that could be used, and the sandbox has the boundary condition versions of those same functions as a test. It wouldn't take much to turn them into divergences!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1099515153:219,sandbox,sandbox,219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1099515153,1,['sandbox'],['sandbox']
Modifiability,"Exactly what I am struggling with right now: figuring out how to quickly get x, y, z coordinates when loading an output file created previously (with JLD2 output writer}). So as far as I understand in that case the 'model' and 'grid' variables do not exist. ; `xc = file([""grid/xC""]) `; etc. works, but contains the halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-1022295367:234,variab,variables,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-1022295367,1,['variab'],['variables']
Modifiability,Fair enough. I'll keep it with the idealized seasonal cycle script (which will end up in the sandbox).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/291#issuecomment-505399246:93,sandbox,sandbox,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/291#issuecomment-505399246,1,['sandbox'],['sandbox']
Modifiability,"Feel free to refactor [`generated_vertically_stretched_grid`](https://github.com/CliMA/Oceananigans.jl/blob/6ff1f69e2bc5d66a0889fb3c62fb2a3b633ab535/src/Grids/vertically_stretched_rectilinear_grid.jl#L189) as part of #1532 and put it in a new file, so we can use it for grid stretching in non-z directions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1605#issuecomment-825730370:13,refactor,refactor,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1605#issuecomment-825730370,1,['refactor'],['refactor']
Modifiability,"Few comments here:; 1) I sent an email to Ali (@ali-ramadhan) and Chris (@christophernhill) on Apr 02 2019,; and Ali opened issue #161 the same day and included a copy of my email content in it.; So, ""originally"" w was stepped forward, not the other way.; 2) do we currently have a good Float32 test ?; 3) machine truncation error in solver when we switch to variable vertical resolution ?; 4) I disagree with the last point, recomputing w from continuity is fine with free surface; and with flow through the bottom (cf, MITgcm). In fact, it might be even more useful; with a non-linear free-surface since, in this case, some linearization is needed when; solving for pressure. On Wed, Aug 07, 2019 at 05:16:43AM -0700, Gregory L. Wagner wrote:; > We originally did the recompilation of w from continuity partly because we thought this may prevent an accumulation of error that could otherwise occur, and partly because @sandreza convinced us this was more correct. But I would argue that because we haven't done model verification we aren't sure whether this is correct or not. ; > ; > Another issue, or annoyance, with recomputing w from continuity is that it is only valid in the case of rigid lids on top and bottom.; > ; > -- ; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly or view it on GitHub:; > https://github.com/climate-machine/Oceananigans.jl/pull/336#issuecomment-519070915",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/336#issuecomment-519120749:359,variab,variable,359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/336#issuecomment-519120749,1,['variab'],['variable']
Modifiability,"Few comments here:; 1) I sent an email to Ali (@ali-ramadhan) and Chris (@christophernhill) on Apr 02 2019,; and Ali opened issue #161 the same day and included a copy of my email content in it.; So, ""originally"" w was stepped forward, not the other way.; 2) do we currently have a good Float32 test ?; 3) machine truncation error in solver when we switch to variable vertical resolution ?; 4) I disagree with the last point, recomputing w from continuity is fine with free surface; and with flow through the bottom (cf, MITgcm). In fact, it might be even more useful; with a non-linear free-surface since, in this case, some linearization is needed when; solving for pressure. On Wed, Aug 07, 2019 at 05:16:43AM -0700, Gregory L. Wagner wrote:; > We originally did the recompilation of w from continuity partly because we thought this may prevent an accumulation of error that could otherwise occur, and partly because @sandreza convinced us this was more correct. But I would argue that because we haven't done model verification we aren't sure whether this is correct or not. ; > ; > Another issue, or annoyance, with recomputing w from continuity is that it is only valid in the case of rigid lids on top and bottom.; > ; > -- ; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly or view it on GitHub:; > https://github.com/climate-machine/Oceananigans.jl/pull/336#issuecomment-519070915. _Originally posted by @jm-c in https://github.com/climate-machine/Oceananigans.jl/pull/336#issuecomment-519120749_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/338#issuecomment-519124463:359,variab,variable,359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/338#issuecomment-519124463,1,['variab'],['variable']
Modifiability,"Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:62; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Field{Center,Face,Center,OffsetArrays.OffsetArray{Float64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:2635,sandbox,sandbox,2635,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449,1,['sandbox'],['sandbox']
Modifiability,"Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Int64,typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64,Int64}}}}; filepath::String, schedule::AveragedTimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:88; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[1]:1; ```. I'm not really sure how to fix this one...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056:14990,sandbox,sandbox,14990,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056,1,['sandbox'],['sandbox']
Modifiability,"For a future PR (probably #2642):. * Use the _order_ (not buffer size) as a type parameter, so WENO(order=5) yields a type `WENO{5}`, for example; * Improve docstrings for advection schemes (but this is contingent on the larger advection refactor in #2642)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1194587440:238,refactor,refactor,238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1194587440,1,['refactor'],['refactor']
Modifiability,"For future reference, instead of the second step above, we need to add an environment variable `DOCUMENTEY_KEY=path_to_long_private_key` to the file `/etc/buildkite-agent/hooks/environment` (which may not exist yet).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901384701:86,variab,variable,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901384701,1,['variab'],['variable']
Modifiability,"For regular spacing:. ```julia; julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(2, 2, 2)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; x: [0.0, 2.0] regularly spaced with Δxᶜᵃᵃ = 2.0; y: [0.0, 2.0] regularly spaced with Δyᵃᶜᵃ = 2.0; z: [-2.0, 0.0] regularly spaced with Δzᵃᵃᶜ = 2.0; ```. for variable spacing:. ```julia; julia> σ = 1.1; # stretching factor. julia> Nz = 24; # vertical resolution. julia> Lz = 32; # depth (m). julia> hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(σ * (k - 1) / Nz) / tanh(σ));. julia> grid = RectilinearGrid(size = (32, 32, Nz), x = (0, 64),; y = (0, 64), z = hyperbolically_spaced_faces); 32×32×24 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; x: [0.0, 64.0] regularly spaced with Δxᶜᵃᵃ = 2.0; y: [0.0, 64.0] regularly spaced with Δyᵃᶜᵃ = 2.0; z: [-32.0, -0.0] variably spaced with min(Δzᵃᵃᶜ) = 0.682695, max(Δzᵃᵃᶜ) = 1.830909; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017835511:338,variab,variable,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017835511,2,['variab'],"['variable', 'variably']"
Modifiability,For sure. The trick about the global environment is just Julia knowledge. But it is relevant to efficient workflows for testing so we can indeed put it there. Personally I don't test just one file unless I am debugging major refactors but perhaps others do it differently...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3507#issuecomment-2000034395:225,refactor,refactors,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3507#issuecomment-2000034395,1,['refactor'],['refactors']
Modifiability,"For the moment this works only with the `SplitExplicitFreeSurface` but I think it can be extended to work also with an implicit free surface following the above mentioned algorithm where $\text{barotropic-step}$ and $\text{barotropic-correction}$ are substituted with a solve of the linear system (starting from interpolated velocities) and a pressure correction step with interpolated eta, i.e.:. ***substep 1:***; - $u^{*, n+1/2} = u^{n} + \Delta t G(u^{n})$; - $\eta^{n+1/2} = \text{barotropic-solve}\left(\eta^n, \int_z u^{*, n+1/2} \right)$; - $u^{n+1/2} = \text{pressure-correction}\left(u^{*, n+1/2}, \eta^{n+1/2} \right)$. ***substep 2***; - $u^{*, n+1/3} = \frac{3}{4}u^{n} + \frac{1}{4}\left(u^{n+1/2} + \Delta t G(u^{n+1/2}) \right)$; - $\eta^* = \text{barotropic-solve}\left(\eta^{n+1/2}, \int_z u^{*, n+1/3} \right)$; - $\eta^{n+1/3} = \frac{3}{4}\eta^{n} + \frac{1}{4}\eta^*$; - $u^{n+1/3} = \text{pressure-correction}\left(u^{*, n+1/3}, \eta^{n+1/3} \right)$. ***substep 3***; - $u^{*, n+1} = \frac{1}{3}u^{n} + \frac{2}{3}\left(u^{n+1/3} + \Delta t G(u^{n+1/3})\right)$; - $\int_z u ^{n+1} = \frac{1}{6}\int_z u^{n} + \frac{1}{6}\int_z u^{n+1/2} + \frac{2}{3}\int_z u^{*, n+1}$; - $\eta^{n+1} = \text{barotropic-solve}\left(\eta^{n}, \int_z u ^{n+1} \right)$; - $u^{n+1} = \text{pressure-correction}\left(u^{*, n+1}, \eta^{n+1}\right)$",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441255636:89,extend,extended,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441255636,1,['extend'],['extended']
Modifiability,Found a trick to configure Travis CI to build pull requests but only pushes to master (thus reducing redundancy as default Travis CI behavior is to build both pushes and merge commits on PRs). See: https://stackoverflow.com/a/31882307,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/872#issuecomment-682117407:17,config,configure,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/872#issuecomment-682117407,1,['config'],['configure']
Modifiability,"From the stacktrace, it looks like it's complaining about `ω̄ ` and looking at the script: . https://github.com/CliMA/Oceananigans.jl/blob/master/examples/Bickley_jet_shallow_water.jl#L92. it looks like it's using a global variable `U` in the definition of `ω̄ ` which won't work in a GPU kernel. Probably the easiest solution is to just define `const U = 1.0` since `const` global variables can be referenced in GPU kernels. Not sure if there's a clean way of putting in `U` as a parameter (like with forcing functions) since you're using `ω̄ ` in an abstract operation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800175997:223,variab,variable,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800175997,2,['variab'],"['variable', 'variables']"
Modifiability,"From the standpoint of `NonhydrostaticModel`, the only requirement (I think?) is a pressure solver that's valid on more grids. The `FourierTridiagonalPoissonSolver` combines FFTs with a tridiagonal solve in one direction to solve the Poisson equation. Thus, this method can be used if the grid is stretched in just one (1) direction. Right now, we only support grids that are stretched in `z`, the third direction / index. Presumably it's at most a matter of copy and paste and index permutation to support grids that are stretched in `x` (and regular in `y, z`) or stretched in `y` (and regular in `x, z`). Under the hood, the `FourierTridiagonalPoissonSolver` relies on the `BatchedTridiagonalSolver` to perform the tridiagonal solve:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/fourier_tridiagonal_poisson_solver.jl#L81-L82. The `BatchedTridiagonalSolver` launches a kernel over `xy` and performs a tridiagonal solve in `z`:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L79-L80. So the first task is to extend the tridiagonal solver to support integrals in `x` and `y`. . This could be straightforwardly supported by adding some kind of tag to indicate the ""tridiagonal direction"" (ie `:x`, `:y`, or `:z`), and copy-pasting the functionality for each case. It's a bit of code duplication but pretty straightforward... Alternatively we could introduce some kind of abstraction that permutes array dimensions. Then we just have one algorithm which assumes the tridiagonal index is `k`, and support `i` or `j` under the hood via an array wrapper that performs an index permutation. I'm leaning towards copy/paste because it's a little easier to understand and it's not that much code in this case...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1557689620:1147,extend,extend,1147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1557689620,1,['extend'],['extend']
Modifiability,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:281,variab,variables,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575,2,['variab'],"['variable', 'variables']"
Modifiability,"Future work:. 1) Make sure that the symmetric flux of buoyancy is very small, even on a stretched grid, etc; 2) Adapt the taper factor calculation to be boundary-friendly; 3) Also make sure the slope calculation is boundary-friendly. I don't really know how to do (3) so we need @jm-c help for that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2481#issuecomment-1111599631:112,Adapt,Adapt,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2481#issuecomment-1111599631,1,['Adapt'],['Adapt']
Modifiability,"Getting at least area and volume in there would be helpful, but kind of stopping short of 'doing this right'. . Each time I look at the SGRID specs I think ""Its right there"" when I see the specifications of 'edges=length', 'faces=area', and 'volume'; <img width=""804"" alt=""image"" src=""https://user-images.githubusercontent.com/14314623/227060884-d28ff5d1-9e0a-4874-b9eb-093afd4607f9.png"">; But AFAIK there is no way to actually assign a coordinate/data variable to each of these positions? If we could somehow add that into the spec I think that would be much better than abusing `cell_thickness`. . In my mind, all that is needed to correctly parse a metric into xgcm is a flag (e.g. this is a metric) and information on the 'kind' of metric and its 'orientation', both of which I believe can be encoded in SGRID already? So really all that is needed is some metadata that implements the flag. I hope this makes sense to folks. . Maybe we get some of the sgrid folks into this discussion? Just to see if I misinterpret what is already possible and whether we could add something to SGRID that indicates that a variable/coordinate represents some physical metric (length, area, volume). cc @hrajagers @rsignell-usgs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1480392005:453,variab,variable,453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1480392005,2,['variab'],['variable']
Modifiability,"Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, Forcing{typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(FS)}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to Cassette.overdub); Stacktrace:; [1] S★ at /archive1/glwagner/Projects/Oceananigans.jl/sandbox/simple_forcing.jl:21; [2] FS at /archive1/glwagner/Projects/Oceananigans.jl/sandbox/simple_forcing.jl:22; [3] calculate_interior_source_terms! at /archive1/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:178; [4] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136; Reason: unsupported dynamic function invocation (call to Cassette.overdub); Stacktrace:; [1] FS at /archive1/glwagner/Projects/Oceananigans.jl/sandbox/simple_forcing.jl:22; [2] calculate_interior_source_terms! at /archive1/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:178; [3] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136; Reason: unsupported dynamic function invocation (call to Cassette.overdub); Stacktrace:; [1] calculate_interior_source_terms! at /archive1/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:178; [2] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136; Stacktrace:; [1] check_ir(::CUDAnative.CompilerJob, ::LLVM.Module) at /data5/glwagner/.julia/packages/CUDAnative/9rZcJ/src/compiler/validation.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496489468:3014,sandbox,sandbox,3014,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496489468,1,['sandbox'],['sandbox']
Modifiability,"Go for it! If you want to discuss an idea before writing code, let's discuss here. Here's my thoughts:. 1. We can add a color to an important `show` method like one / all of the models, or `Simulation`; 2. We can add a nice utility for logging progress that uses `Term.jl`, that users can configure and then add to `simulation.callbacks` (we could also consider making it default)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2281#issuecomment-1077663914:289,config,configure,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2281#issuecomment-1077663914,1,['config'],['configure']
Modifiability,"Good idea! Does this mean tagging v0.94.0 (and one stop closer to v0.100) as it's a change to the public interface?. > Remove `OceananigansLogger`: rarely used. I use it in almost every script I write haha, but that's because I wrote it to my liking. There's a strong argument to be made that a logger configuration does not belong in Oceananigans.jl. I feel it's similar to Oceananigans' decision to not provide a default progress callback seeing as each user will probably want a different one. > Remove `StateChecker`: not used as far as I know. Yeah I think I used that to debug cubed sphere stuff. Could easily be defined in a validation script though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439726627:302,config,configuration,302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439726627,1,['config'],['configuration']
Modifiability,"Good idea. Maybe even suggest the user try `ShallowWaterModel`, as that is a better way to try this configuration? ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023127291:100,config,configuration,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023127291,1,['config'],['configuration']
Modifiability,"Good suggestion. Actually, this should help fix one problem I've been having with JLD2 output: Julia ranges like `grid.xC` are serialized to the JLD2 file, and cannot be read outside of Julia. You might want to serialize the grid when checkpointing to easily restore from a checkpoint file. But when saving the grid to a JLD2 output file, which may be read by a language other than Julia, the grid properties should be saved in a language-agnostic manner. Same for boundary conditions. So I changed the way structs are saved to disk for both the JLD2 output writer and the checkpointer. It's all done recursively via multiple dispatch so it should be flexible enough to work for all current `Model` properties and it should accomodate future changes to `Model` with minor changes. When saving stuff to disk like a JLD2 file, `saveproperty!` is used, which converts Julia objects to language-agnostic objects. When checkpointing, `serializeproperty!` is used, which serializes objects, with fields and boundary conditions require special treatment. We checkpoint structs that are important for timestepping. Diagnostics and output writers are not checkpointed, as they are not essential and can be added in any time after model constructions. But if one or more boundary conditions contain a function, `model.boundary_conditions` are not serialized and must be manually restored. There is one mess bits associated with restoring from a checkpoint:; * Fields cannot be passed to the `Model` constructor. When restoring fields we want to avoid loading a field from disk and allocating `Model` memory for it at the same time, as we won't be able to restore models whose memory footprint exceed ~half the CPU/GPU memory. Thus restoring fields is treated as a special case (see `restore_fields!`). It is done after model creation where fields are read from disk and used to fill up existing model fields. Unfortunately, `model.timestepper` doesn't fit the pattern and is treated as an extra special case. @g",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-524941619:651,flexible,flexible,651,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-524941619,1,['flexible'],['flexible']
Modifiability,"Good to clean up the API first before extending it. Otherwise we'd have multiple definitions of `Tx ,Ty, Tz, Bx, By, Bz` floating around, one set for each dimension. And we've definitely had bugs related to incorrect use of thread block layouts...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/363#issuecomment-523630443:38,extend,extending,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/363#issuecomment-523630443,1,['extend'],['extending']
Modifiability,"Greg, Ali, and what if we began to consider more complex geometries etc -; hard to resist going in that direction..... we'd have to change the solvers; - more MITgcm-like, congrad etc - but what would the implications be for; boundary conditions? More food for thought. John. On Sat, Mar 28, 2020 at 10:22 AM Gregory L. Wagner <notifications@github.com>; wrote:. > Mostly I am worried about scalability and sustainability in this design,; > or future designs.; >; > Currently our models are fairly simple, but its challenging to place; > bounds on potential future complexity. For example, models in the future; > may require additional fields associated with closures or; > parameterizations, such as (two-dimensional) boundary layer depth fields,; > plume quantities, mixing lengths and perhaps other auxiliary fields; > associated with various prognostic / diagnostic LES models. We probably; > can't plan to support setting boundary conditions on every possible field; > via the model constructor.; >; > With our current design we have essentially special-cased turbulent; > diffusivities because our focus is LES, turbulent diffusivities are; > relatively common, and it convenient for us. However doing this incurs some; > maintenance burden --- which will increase if we plan to hard-code; > validation and error checking.; >; > Food for thought.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/721#issuecomment-605453798>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQT642WME2EIX3DDSITRJYBYXANCNFSM4LVSZPAA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060:675,parameteriz,parameterizations,675,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060,1,['parameteriz'],['parameterizations']
Modifiability,"Greg, Doesn't Ali have a version of immersed boundary layers going?. On Mon, Oct 12, 2020, 7:50 PM Gregory L. Wagner <notifications@github.com>; wrote:. > One extra consideration is that we also allow users to specify diffusive; > fluxes across boundaries. This is especially important for geophysical; > problems at LES scales and larger, where its appropriate to employ a ""wall; > model"" to predict momentum and tracer fluxes at boundaries where there's an; > unresolved or partially-resolved turbulent boundary layer (rather than; > prescribing a particular value or gradient). That said, I think if we are; > able to specify the gradients of a field across a boundary it will likely; > be straightforward to extend that implementation to specifying fluxes.; >; > The paper; >; > ""Moving from momentum transfer to heat transfer – A comparative study of; > an advanced Graetz-Nusselt problem using immersed boundary methods""; > <https://www.sciencedirect.com/science/article/pii/S0009250918306250> by; > Lu et al. (2019); >; > may also be relevant. Their conclusion is a bit confusing. They state; >; > In all simulations, excellent agreement are reached between CFM and DFM; > results, with the deviation being below 10%.; >; > which suggests that *accuracy* may not be an important factor in deciding; > which method to use. But the next sentence is; >; > Considering the nature of capturing the discontinuity at the fluid-solid; > interface, DFM might offer a more accurate result, which however requires; > more follow-up simulations to give a solid investigation.; >; > which is difficult to interpret. I suppose all they can say is that their; > results are similar to one another, but they cannot say which one is more; > accurate (and perhaps it doesn't matter which method is more accurate in; > their case, if both methods return similar results).; >; > That said, I think time-step considerations are really important, and seem; > like a good reason to choose DFM over CFM.; >; > Balaras ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707404766:54,layers,layers,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707404766,2,"['extend', 'layers']","['extend', 'layers']"
Modifiability,"Greg, I think that rho_o belongs in the EOS. And we will have to run many; problems with anisotropic diffusion etc. So we should support from the; outset. John. On Thu, May 9, 2019, 5:55 PM Gregory L. Wagner <notifications@github.com>; wrote:. > As discussed with @jm-c <https://github.com/jm-c>, the organization of; > physical constants and parameters is somewhat confusing.; >; > Currently, constants are stored in three places:; >; > 1. PlanetaryConstants, which stores a rotation rate, gravitational; > acceleration, and a Coriolis parameter used in an f-plane approximation; > 2. ModelConfiguration, which stores anisotropic (potentially; > turbulent) viscosities and diffusivities; > 3. EquationOfState, of which there is only one kind:; > LinearEquationOfState, which stores both parameters associated with; > the equation of state in addition to a reference density; >; > I see a few problems:; >; > - f is not a property of a planet.; > - 'Model configuration' is an obscure name for turbulent or molecular; > transport coefficients.; > - A reference density is not a parameter in an equation of state.; >; > I propose that we consolidate these three types into two, removing the; > reference density from EquationOfState and define a new type containing; > f, g, ρ0, ν, and κ.; >; > I'm not sure what to call the new type. One possibility is FluidParameters; > or PhysicalParameters or PhysicalConstants.; >; > I also propose that we cease support for anisotropic transport; > coefficients as parameters, defined generally, at least for the moment. We; > can support constant anisotropic transport coefficients as a type of LES; > closure in the future.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/217>, or mute; > the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQW3GJUNC2CYLVWD44TPUSMUVANCNFSM4HL6JVQA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491107162:956,config,configuration,956,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491107162,1,['config'],['configuration']
Modifiability,"Gregg, Ali, can we get variable delz in at the same time? John. On Thu, Sep 19, 2019, 11:45 PM Gregory L. Wagner <notifications@github.com>; wrote:. > Assuming this is the last API changing PR for now, would be good to get; > this merged and a new version tagged so we can refactor and stabilize; > simulation scripts.; >; > Definitely need a new version for this change!; >; > I think we should reverse the k-index soon though. But that can be yet; > another version.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/pull/412?email_source=notifications&email_token=AKXUEQW5SNP7HHDFXVWLQYLQKNQ55A5CNFSM4IXKRUWKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD7DFYCA#issuecomment-533093384>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQQL7SU7LDR4FEVLBMDQKNQ55ANCNFSM4IXKRUWA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533095036:23,variab,variable,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533095036,2,"['refactor', 'variab']","['refactor', 'variable']"
Modifiability,"Guys, is this a good idea? John. On Tue, Jun 25, 2019, 4:31 PM Ali Ramadhan <notifications@github.com> wrote:. > Copy pasting from @glwagner <https://github.com/glwagner>'s fork.; >; > Adaptive time stepping with a TimeStepWizard that computes time steps for; > you.; >; > I'll add some more docstrings and a couple of tests.; >; > cc @sandreza <https://github.com/sandreza>; >; > Resolves #189; > <https://github.com/climate-machine/Oceananigans.jl/issues/189>; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/climate-machine/Oceananigans.jl/pull/297; > Commit Summary; >; > - Utils for adaptive time stepping.; > - Some docstrings.; >; > File Changes; >; > - *A* src/time_step_utils.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/297/files#diff-0>; > (104); >; > Patch Links:; >; > - https://github.com/climate-machine/Oceananigans.jl/pull/297.patch; > - https://github.com/climate-machine/Oceananigans.jl/pull/297.diff; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/pull/297?email_source=notifications&email_token=AKXUEQXE74LLYFD3QRG7BP3P4IT5HA5CNFSM4H3I7NT2YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4G3SCVLA>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQQTKNBSXD3NJO6ROKDP4IT5HANCNFSM4H3I7NTQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505511666:185,Adapt,Adaptive,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505511666,2,"['Adapt', 'adapt']","['Adaptive', 'adaptive']"
Modifiability,"Heh. I would never imply you can't take my code and adapt it to do nice things. You can of course do that. For example if you have `outputs` already assembled, you can do. ```julia; function create_subsampled_output(field); loc = location(field); subsampled_field = Field(loc, subsampled_grid); function output(model); interpolate!(subsampled_field, field); return subsampled_field; end; return output; end. subsampled_outputs = NamedTuple(name => create_subsampled_output(outputs[name]) for name in keys(outputs)); ```. And there's an infinity of other ways you can write your code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2033084916:52,adapt,adapt,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2033084916,1,['adapt'],['adapt']
Modifiability,Here are some plots that were made by @sandreza in an eddying channel configuration:. `CenteredSecondOrder`:. ![image](https://user-images.githubusercontent.com/15271942/94508191-68a65c80-01df-11eb-8cda-2be243d7aad7.png). `WENO5`:. ![image](https://user-images.githubusercontent.com/15271942/94508209-72c85b00-01df-11eb-9473-5632b36d7961.png),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/925#issuecomment-700398499:70,config,configuration,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/925#issuecomment-700398499,1,['config'],['configuration']
Modifiability,"Here is where the different terms in the _u_-momentum equation are calculated and added to the _u_ source term. It's not super pretty but shouldn't be too hard to refactor it to be more readable. https://github.com/ali-ramadhan/Oceananigans.jl/blob/e1be1f0e3f067cdb4236eb5e7b962e0c772ce4d1/src/time_steppers.jl#L55-L77. In order: it's momentum advection _-u∇u_, Coriolis _fv_, hydrostatic pressure anomaly _∂xpHY′_ encoding the buoyancy, and viscous dissipation _𝜈∇²u_. There's also viscous drag added to the top and bottom to impose no-slip (sounds weird but it's the finite volume way of imposing an equal and opposite flux at the boundary to get zero velocity I think). There's a bug in that `bc.bottom_bc == :no_slip` ends up imposing no slip at the top as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/36#issuecomment-462554312:163,refactor,refactor,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/36#issuecomment-462554312,1,['refactor'],['refactor']
Modifiability,"Here's a few notes on a model with fetch dependence. ## Time-dependence of the spectral peak. Under persistent winds, the sea state continuously evolves. This is captured by the concept of _fetch_, which is more or less the distance over which the wind blows. The fetch dependence of the sea state is strikingly captured by this figure from [JONSWAP](https://pure.mpg.de/rest/items/item_3262854/component/file_3282032/content):. <img width=""671"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/156589227-c6f5f778-3cfd-4d4b-b199-34d4ad3756b1.png"">. which shows the _fetch dependence_ of the surface wave spectrum: as the fetch gets longer (as the winds blow for a longer period of time), the peak wavenumber decreases (the waves get longer) and the spectrum spreads out. [Lenain and Melville 2017](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2019/06/2017_Lenain_Melville-Journal_of_Physical_Oceanography_vol_47-2.pdf) derive fetch relationships between peak frequency and non-dimensional fetch in their equations 11 and 12. Putting ourselves in a reference frame moving at the phase speed of the peak wavenumber, and rewriting these relationships in terms of peak wavenumber yields. ![image](https://user-images.githubusercontent.com/15271942/156588626-19b01ba3-5557-4f17-af1d-4d93b8c4fb9f.png). The above is a model for a time-dependent peak wavenumber for a given constant friction velocity. This is an alternative to a constant peak wavenumber scaling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701:145,evolve,evolves,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701,1,['evolve'],['evolves']
Modifiability,"Here's a possible implementation... # New constructor for `BoundaryCondition` for function boundary conditions. ```julia; function BoundaryCondition(Tbc, condition::Function; parameters=nothing, long_function_signature=false); if !long_function_signature # convert condition to a BoundaryFunction; condition = BoundaryFunction{:x, Cell, Cell}(condition, parameters); elseif parameters != nothing; condition = ParameterizedBoundaryConditionFunction(condition, parameters); end; return BoundaryCondition(Tbc, condition); end. BoundaryCondition(Tbc, condition::{BoundaryFunction, ParameterizedBoundaryConditionFunction}) =; BoundaryCondition(Tbc, condition); ```. The last definition may not be needed; however in the case that `condition` is already a `BoundaryFunction` or a `ParameterizedBoundaryConditionFunction` we would not want to do any conversion. # Modification to `FieldBoundaryConditions` constructor. Note that the conversion to `BoundaryFunction` is not correct in general. To handle this we can modify the `FieldBoundaryConditions` constructor. One solution is. ```julia. relocate_function_boundary_condition(bc, args...) = bc # fallback. relocate_function_boundary_condition(bc::BoundaryCondition{C, <:BoundaryFunction}, boundary, loc1, loc2) where C =; BoundaryCondition(C, BoundaryFunction{boundary, loc1, loc2}(bc.func, bc.parameters)). function FieldBoundaryConditions(grid, loc;; east = DefaultBoundaryCondition(topology(grid)[1], loc[1]),; west = DefaultBoundaryCondition(topology(grid)[1], loc[1]),; south = DefaultBoundaryCondition(topology(grid)[2], loc[2]),; north = DefaultBoundaryCondition(topology(grid)[2], loc[2]),; bottom = DefaultBoundaryCondition(topology(grid)[3], loc[3]),; top = DefaultBoundaryCondition(topology(grid)[3], loc[3])). east = relocate_function_boundary_condition(east, :x, loc[2], loc[3]); west = relocate_function_boundary_condition(west, :x, loc[2], loc[3]); south = relocate_function_boundary_condition(south, :y, loc[1], loc[3]); north = relocate_f",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/769#issuecomment-682803265:409,Parameteriz,ParameterizedBoundaryConditionFunction,409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/769#issuecomment-682803265,3,['Parameteriz'],['ParameterizedBoundaryConditionFunction']
Modifiability,"Here's a starting list:. * `ViscousDissipation`, which @tomchor attempts to compute above, also being computed [here](https://github.com/CliMA/LESbrary.jl/blob/master/src/TurbulenceStatistics/viscous_dissipation.jl) (and note that there's [an open issue about the expression](https://github.com/CliMA/LESbrary.jl/issues/38)). * [`TurbulentKineticEnergy`](https://github.com/CliMA/LESbrary.jl/blob/master/src/TurbulenceStatistics/turbulent_kinetic_energy.jl), which requires embedding `AveragedField`s in an operation. * [`ShearProduction`](https://github.com/CliMA/LESbrary.jl/blob/master/src/TurbulenceStatistics/shear_production.jl), similar to above. @ali-ramadhan not sure if this is what you mean but when trying to adapt `Field` to the GPU we did encounter an error that was something like ""ptx arguments consume too much parameter space"". I believe this is an issue compiling very large objects (`Field` is large because it has boundary conditions). I don't think that this is the error we get for too-complex AbstractOperations though. I think for abstract operations its a type-inference issue. We should dump the whole error into this issue so that we know. I also think the error might change as the julia compiler evolves, or when we upgrade CUDA.jl.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738757085:721,adapt,adapt,721,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738757085,2,"['adapt', 'evolve']","['adapt', 'evolves']"
Modifiability,Here's how the `u` field from the code-snippet above looks like when evolved on a SingleRegion and MultiRegion grids:. ![u](https://github.com/CliMA/Oceananigans.jl/assets/7112768/cf256be5-7e94-45d6-9bc3-e5c7a6adc1fb),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3514#issuecomment-1999457836:69,evolve,evolved,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3514#issuecomment-1999457836,1,['evolve'],['evolved']
Modifiability,"Here's my latest work on setting up an OMIP simulation:. https://github.com/CliMA/ClimaOcean.jl/blob/glw-ss/ice-ocean-model/experiments/prototype_omip_simulation/omip_simulation.jl. which also includes an example of using `ImmersedBoundaryGrid` to implement bathymetry. Bathymetry is a little sad there; I ""diagnose"" it from the ECCO state rather than prescribing directly. We need initialization tools for reasonable ""in painting"" for cases where initial condition information and bathymetry are slightly different (ie filling in NaNs near boundaries, etc). All of this should evolve quite a bit in the next few months. PS I'm going to convert this to a Discussion so that we can continue the party without needing to make any source code changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809330687:578,evolve,evolve,578,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809330687,1,['evolve'],['evolve']
Modifiability,"Here's the julia docs on constants for reference:. https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Constants. This statement in the julia docs could maybe be clarified:. > It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. because its ambiguous what ""code involving global variables"" is. For Oceananigans, this almost always means ""functions that capture global variables in their scope"". So `f(x) = a * x` is going to be slow unless `a` is `const`; otherwise `f(x)` cannot be inlined properly because the type of `a` is uncertain.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539:91,variab,variables-and-scoping,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539,4,['variab'],"['variables', 'variables-and-scoping']"
Modifiability,"Here's the specific error we got when we tried to get `Field`, including all its glorious boundary conditions, to compile on the GPU:. ```; Entry function 'ptxcall_calculate_Gu__66' uses too much parameter space (0x16c8 bytes, 0x1100 max); ```. dredged up from #746 . Some workarounds were suggested there, but I think our solution is actually better / simpler (adapt fields by unwrapping the underlying data and throwing away boundary conditions, rather than wrestling to get all the field info onto the poor GPU).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738767849:362,adapt,adapt,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738767849,1,['adapt'],['adapt']
Modifiability,"Here's what I got:. ![image](https://user-images.githubusercontent.com/15271942/156228448-7e02ebdb-4fa6-4e74-a495-0cd955927cb4.png). This seems sort of reasonable at moderate wind speeds. At low wind speeds it presumably doesn't make sense to have a peak period of 2.5s ... ? At the higher wind speeds peak periods of 25.5 s are maybe not impossible. It'd be nice to have a way of validating this. But maybe that's not easy short of actually running WW3. Notes... * The code to produce this is below; * Since Oceananigans doesn't yet have bulk formulae, we have to ""invert"" a toy bulk formula to obtain an ""expected air speed"" for a given kinematic momentum flux `τ`. I'm not sure whether it makes more sense to parameterize Stokes drift in terms of U10 or momentum flux (momentum fluxes saturate when waves stop growing at high wind speeds?); * If we want to re-parameterize this ""equilibrium Stokes drift"" in terms of momentum flux, we'll presumably have to run a sweep with WW3. ```julia; using SpecialFunctions; using GLMakie; using Printf. # Parameters; g = 9.81 # Gravitational acceleration for diagnostic wave property calculations; ρʷ = 1035 # Water density for toy bulk formula; ρᵃ = 1.225 # Air density for toy bulk formula; Cᵈ = 1e-3 # Drag coefficient for toy bulk formula; Ckᵖ = 0.167 # Peak wavenumber scaling parameter; Cuˢ = 0.016 # Scaling between wind stress and surface stokes drift; A_McWilliamsRestrepo = 5.1e-4 # parameter with units ""inverse acceleration""; # that relates wind stress to Stokes transport. # Peak wave number and surface Stokes drift calculation; U₁₀(τ) = sqrt(τ * ρʷ / (Cᵈ * ρᵃ)); surface_Stokes_drift(τ) = Cuˢ * U₁₀(τ); Stokes_transport(τ) = A_McWilliamsRestrepo * U₁₀(τ)^3. @inline function peak_wavenumber(τ); uˢ₀ = surface_Stokes_drift(τ); Vˢ = Stokes_transport(τ); return Ckᵖ * uˢ₀ / Vˢ; end. # Stokes drift profile calculation; T₁(k, z) = exp(2k * z); T₂(k, z) = sqrt(2π * k * abs(z)) * erfc(sqrt(2k * abs(z))). function Stokes_drift(τ, z); kᵖ = peak_waven",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055741685:712,parameteriz,parameterize,712,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055741685,2,['parameteriz'],['parameterize']
Modifiability,"Hey @ali-ramadhan, thanks for the quick reply!. Note that this was working a couple of days ago when the `NetCDFOutputWriter` keyword was still `interval` rather than `time_interval`. Below is the truncated stack trace. `data/turb_box_test.nc` was a new file. I can send over the script if that's helpful. . Many thanks!; ; [1] nc_inq_varid(::Int32, ::String) at /Users/guptam/.julia/packages/NCDatasets/NNX1o/src/netcdf_c.jl:1335; [2] variable(::NCDatasets.NCDataset{Nothing}, ::String) at /Users/guptam/.julia/packages/NCDatasets/NNX1o/src/variable.jl:79; [3] getindex(::NCDatasets.NCDataset{Nothing}, ::String) at /Users/guptam/.julia/packages/NCDatasets/NNX1o/src/cfvariable.jl:270; [4] write_output(:: ....; [5] (::Oceananigans.Simulations.var""#6#10""{Simulation{IncompressibleModel{Oceananigans.TimeSteppers...; [6] iterate at ./generator.jl:47 [inlined]; [7] collect(::Base.Generator{; [8] run!(::Simulation{IncompressibleModel...; [9] macro expansion at /Users/guptam/Desktop/test_ocean/turbulence/turb_box.jl:98 [inlined]; [10] top-level scope at /Users/guptam/.julia/packages/Plots/6RLiv/src/animation.jl:183; [11] include(::String) at ./client.jl:457; [12] top-level scope at REPL[12]:1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/862#issuecomment-676560854:436,variab,variable,436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/862#issuecomment-676560854,2,['variab'],['variable']
Modifiability,"Hey @arcavaliere sorry I think I messed up your PR :(. I was trying to get rid of a big file that invaded our git history by mistake (#509) but apparently because it rewrites git history, open pull requests become invalid so now you have a PR with 1000+ commits and 100+ merge conflicts haha. Might be better to open a new pull request. You also need to delete the old repository and `git clone` a fresh copy. Don't think you can cherry-pick either... I can help with opening a new pull request. Again, sorry about ruining your pull request.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-549157655:166,rewrite,rewrites,166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-549157655,1,['rewrite'],['rewrites']
Modifiability,"Hey @arcavaliere thanks for working on this! Just added ""[WIP]"" to the title as that's our convention for PRs that are still a work in progress. About your error, you did define `min_enabled_level` but I think you need to [import methods from `Logging` to extend them](https://discourse.julialang.org/t/overloading-operators/6773). I think something like this would work:; ```julia; import Logging: min_enabled_level; min_enabled_level(logger::ModelLogger) = logger.min_level; ```; or; ```julia; import Logging; Logging.min_enabled_level(logger::ModelLogger) = logger.min_level; ```; and the same goes for `shouldlog` and `handle_message`. ---. Might also be good to `include(""logging.jl"")` in `src/Oceananigans.jl` so it gets exported and available to users after `using Oceananigans`. PS: Looks like your second account made the commits haha. We can fix this later.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-542247142:256,extend,extend,256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-542247142,1,['extend'],['extend']
Modifiability,"Hey @tomchor thank you for testing out the example and reporting this! Indeed we did a lot of refactoring for v0.11 and you've become the first victim haha. I updated the example with the right keyword argument and removed the stale link (PR #450). . I'd like to revive the full rising thermal bubble example soon but for now @glwagner has put together some pretty cool examples with plots: https://github.com/climate-machine/Oceananigans.jl/tree/master/examples. Let us know if you had a simulation in mind you're trying to run, we're more than happy to help!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539722982:94,refactor,refactoring,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539722982,1,['refactor'],['refactoring']
Modifiability,"Hey, original author of both https://github.com/JuliaGeo/NetCDF.jl and https://github.com/meggart/ZarrNative.jl here. Regarding the state of NetCDF.jl , yes I would say I mostly stopped developing the package due to time constraints and currently shift my focus towards Zarr since this is what we are using in our current project. . My last attempt at improving the NetCDF solved many of the issues with the package https://github.com/JuliaGeo/NetCDF.jl/pull/61 but was not merged because of conflicts with other bugfix PRs. However, might be source of inspiration if someone wants to do a rewrite. . Regarding write performance, I would be very interested to see examples where NetCDF.jl performs worse than e.g. python-netcdf4, since most of the time should be spent in the same NetCDF C library. I have been using the package extensively and did not experience it to be slower than comparable packages. . I you are worried about the robustness of NetCDF.jl, you should not even look at ZarrNative.jl, since it is still very young and rather a prototype. . I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475680874:590,rewrite,rewrite,590,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475680874,1,['rewrite'],['rewrite']
Modifiability,"Hi @c42f thank you for chiming in! Will definitely ping you as we work on logging. I think we probably should have tackled logging much earlier. We still use `@printf` and vanilla `@info` for logging, which has been quite counter-productive haha. Definitely hoping we can reach a useful logger that can; * help developers by providing info and debug messages. Also nice in test logs.; * help users understand what the model is doing and provide a better and more responsive user experience by logging what the model is doing. This is where `@setup` and `@diagnostic` logging messages might be really nice. Although `@setup` and `@diagnostic` might be bad names as they don't imply logging? Not sure of the best solution but maybe your kwarg suggestion would help here, e.g. `@info source=""diagnostic"" msg`?. @arcavaliere seems to be developing a pretty general-purpose `ModelLogger` which hopefully we can adapt for all these uses! @arcavaliere I'm more than happy to help if you need anything. MicroLogging.jl looks pretty neat! I like that it puts the log level, file name, and line number on the right as putting them on the left causes messages not to align and makes logs harder to read. TensorBoardLogger looks pretty cool! Would be awesome to have something like that one day, but I guess you'd have to use something like ncusrses...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-542677876:906,adapt,adapt,906,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-542677876,1,['adapt'],['adapt']
Modifiability,"Hi @iurt! Very nice that you are thinking to implement a new parametrization! . To start I would try to implement the additional prognostic equations, decoupled from the main solution. ; You can use the existing infrastructure for tracer evolution and modify the k or epsilon (or omega or whatever quantity you choose to evolve) ""specific"" dissipation terms in the TurbulenceClosures module. Once that is done and validated we can couple them to the momentum equations through the definition of a new ""eddy viscosity"" which uses values from the newly defined tracers",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051271554:321,evolve,evolve,321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051271554,1,['evolve'],['evolve']
Modifiability,"Hi @pnavaro thanks for opening this issue. Yeah this is an issue on some clusters so it might be worth adding a note in the documentation. In my case I think the login node had a GPU so I was able to build on the login node then just precompile and run on the compute node without internet access. But this was also before CUDA.jl which very nicely downloads CUDA artifacts for you so it just relied on the local CUDA toolkit. Do you have access to the CUDA toolkit on the login node via something like `module load cuda`? Might allow you to build on the login node without a GPU but might be weird to have CUDA but no GPU. Your compute node must have a CUDA installation. Looks like the CUDA.jl documentation has a section on how to make use of a local CUDA installation: https://juliagpu.gitlab.io/CUDA.jl/installation/overview/#CUDA-toolkit. If you can find where the CUDA toolkit is installed on your compute node, then maybe all you have to do is set one of the `CUDA_HOME`, `CUDA_ROOT` or `CUDA_PATH` environment variables?. Looks like creating a container with CUDA.jl is an option but it still requires a CUDA toolkit at runtime: https://juliagpu.gitlab.io/CUDA.jl/installation/overview/#Containers. Let us know if this helps or if you're able to get up and running on your compute node. Would be good to figure this out and add to the documentation. The #gpu channel on Julia's Slack or the GPU section of the Julia Discourse might also be good places to ask if we can't figure it out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1035#issuecomment-707637840:1019,variab,variables,1019,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1035#issuecomment-707637840,1,['variab'],['variables']
Modifiability,"Hi All - this should definitely be useful for the sort of ensemble of; LES parameter/background state; sweep runs that Greg mentions. On Tue, Jun 25, 2019 at 4:29 PM John Marshall <notifications@github.com> wrote:; >; > Ali and Greg, thanks for your comments. I found the exchange very; > enlightening. John; >; > On Tue, Jun 25, 2019, 7:49 PM Gregory L. Wagner <notifications@github.com>; > wrote:; >; > > Adaptive time-stepping is useful for a wide class of problems. The general; > > strategy is to use the CFL number to compute a stable time-step. This is; > > especially useful in problems with lots of time variability --- for; > > example, LES of a seasonal cycle. In addition, the CFL computation can be; > > used to stabilize the spin-up of a model, during which a transition to; > > turbulence occurs.; > >; > > Some complexity is introduced by the fact that we use Adams-Bashforth time; > > stepping (as opposed to a RK-method, which is more common and more stable),; > > since it means we need to re-initialize the ""previous source terms"" with a; > > forward Euler step when the time step is changed.; > >; > > I have been using adaptive time-stepping in my work, which along with a; > > strategy for handling model spinup / transition to turbulence, has proven; > > to be an important practical feature that makes running experimental; > > simulations under different conditions much easier, since all I need to do; > > is set my boundary conditions, and let the model run. I am then able to; > > start dozens of LES per day (if I want to) without having to choose my time; > > step size through a mistake-prone and time-consuming trial-and-error; > > process --- and I am guaranteed not to waste resources with a too-short; > > time-step.; > >; > > —; > > You are receiving this because you commented.; > > Reply to this email directly, view it on GitHub; > > <https://github.com/climate-machine/Oceananigans.jl/pull/297?email_source=notifications&email_token=AKXUEQVQYODJTMVZ46AOA3TP4JL",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505614637:407,Adapt,Adaptive,407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505614637,2,"['Adapt', 'variab']","['Adaptive', 'variability']"
Modifiability,"Hit a slight roadblock as the `Field` structs are not `isbitstype`:; ```julia; struct CellField{A<:AbstractArray,G<:Grid} <: Field; data::A; grid::G; end; ```; since `Array`s and `CuArray`s are not `isbits`. However, @vchuravy points out that a `CuArray` is not `isbits` only because it contains a `finalize` function (essentially a destructor) which makes it not `isbits` on the host. Apparently CUDAnative converts the `CuArray` to some sort of `CuDeviceArray` using [Adapt.jl](https://github.com/JuliaGPU/Adapt.jl) which is `isbits` and can be used as a device argument. So we'll have to figure out how to _adapt_ our `Field` structs to be `isbits` on the GPU device using Adapt.jl. It shouldn't be too hard as the struct is simple. I should also check out the `cudaconvert(args...)` function in CUDAnative.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-475660249:470,Adapt,Adapt,470,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-475660249,3,['Adapt'],['Adapt']
Modifiability,"Hmm yes, perhaps the output writers need to be re-initialized when picking up as well? That would require extending what we do when we pick up here:. https://github.com/CliMA/Oceananigans.jl/blob/3bb62a647a55a7dadf5f37331321bf0020a78c4d/src/Simulations/run.jl#L87-L90",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3485#issuecomment-1997565752:106,extend,extending,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3485#issuecomment-1997565752,1,['extend'],['extending']
Modifiability,"Hmm, I think perhaps the mean buoyancy actually has to include an additional component that evolves (in addition to the static background component) which is independent of $x$ (upslope coordinate) but maybe varies in $z$ (slope-normal coordinate), right?. It sounds like what that example needs is to include a derivation of the equations we want to solve + boundary conditions, and then to impose intended boundary conditions (whatever those need to be) consistent with the boundary conditions that we'd like to impose on the total (non-decomposed) problem?. Edit: I noticed that you suggested modifying the boundary conditions in the tilted bottom boundary layer problem. My only suggestion is to also include a write up of the equations and a reference to the docs equations, that will make it clear the precise connection between the ""original"" equations and the perturbation equations that have to be solved by Oceananigans to achieve the desired goal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083765467:92,evolve,evolves,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083765467,1,['evolve'],['evolves']
Modifiability,"Hmm, I think then `cell_advection_timescale` and `cell_diffusion_timescale` need to be extended for `ShallowWaterModel`, after which the `TimeStepWizard` will probably work. Perhaps change the name of this issue to ""Adapt cell_advection_timescale for ShallowWaterModel""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761148599:87,extend,extended,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761148599,2,"['Adapt', 'extend']","['Adapt', 'extended']"
Modifiability,"Hmm, we need to take care because apparently only openmpi allows us to check this:. ```; help?> MPI.has_cuda; MPI.has_cuda(). Check if the MPI implementation is known to have CUDA support. Currently only Open MPI provides a mechanism to check, so it will return false with other implementations (unless overridden). For ""IBMSpectrumMPI"" it will; return true. This can be overridden by setting the JULIA_MPI_HAS_CUDA environment variable to true or false. │ Note; │; │ For OpenMPI or OpenMPI-based implementations you first need to call Init(). See also MPI.has_rocm for ROCm support.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3883#issuecomment-2445566465:428,variab,variable,428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3883#issuecomment-2445566465,1,['variab'],['variable']
Modifiability,"Hmm... I don’t think this is a typo. The functions *_gradient for “west”, “south”, and “bottom” are *identical*. Therefore we should use the alias “left” for all three to avoid copy-pasting identical functions. The same applies to the three “right” boundaries: “east”, “north”, and “top”. If we want to use matching names in other functions then we should use ‘const’ aliases. I think copy-pasting function definitions is bad practice that decreases maintainability and can make bugs harder to catch and fix.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/690#issuecomment-596539100:450,maintainab,maintainability,450,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/690#issuecomment-596539100,1,['maintainab'],['maintainability']
Modifiability,"Hmm... maybe something like. ```julia; s = 10 # stretching factor; h(k) = (1 - exp(s * (1 - k) / N)) / (1 - exp(-s)) # normalized, stretched height (goes from 0 at z=-Lz to 1 at z=0).; z_faces(k) = Lz * (h(k) - 1) # offsets normalized height and scales by Lz; ```. I get. ![image](https://user-images.githubusercontent.com/15271942/123190408-b7c2aa80-d45c-11eb-9eed-3c9aa1ed7c67.png). The stretched height function could be further parameterized by an exponent but it may not be necessary if changing `s` is sufficient for generating different grids.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867271377:432,parameteriz,parameterized,432,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867271377,1,['parameteriz'],['parameterized']
Modifiability,"Hmm... we don't support `Flat` z right now with `ExplicitFreeSurface` because we require two grid points in the vertical velocity (one grid point at the ""bottom"", one at the ""top"" coincident with the location of the free surface). I'm not sure about `ImplicitFreeSurface`. Can you check?. We might be able to refactor the algorithm to generally support hydrostatic free surface simulations with `Flat` z. Maybe we just need to generalize the free surface tendency for `ExplicitFreeSurface`?. On a regular `RectilinearGrid`, `NonhydrostaticModel` with `Flat` z is hydrostatic and has equivalent physics (because the free surface physics are linearized in `HydrostaticFreeSurfaceModel`). Before generalizing anything we could add an error message to the `HydrostaticFreeSurfaceModel` constructor to point this out (and maybe link to this issue). `ShallowWaterModel` has a nonlinear free surface and thus finite ""Mach number"" (ratio between gravity wave speed and flow speed). So I agree with @francispoulin ; that `ShallowWaterModel` is more general and might be a nice choice for some applications. I think it still lacks a diffusive flux implementation though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023327537:309,refactor,refactor,309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023327537,1,['refactor'],['refactor']
Modifiability,"Hmm... with a vanilla closure, the change is completely encapsulated in the addition of two layers of abstraction (we are just calling a simple diffusion operator). So, let's figure out how to make the abstractions fast. I think the slow down for vanilla closures should be `nil`. The 'abstraction slowdown' causes much larger problems with the complicated closures, so we need to solve that problem anyways. Edit: I see your post, so what I said above holds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496476529:92,layers,layers,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496476529,1,['layers'],['layers']
Modifiability,"Hmmm - I am skeptical about that from a computer point of view? In an implicit algorithm and/or radiative transfer alg the next step often depends on the result of the previous steps. . As every CCE graduate student learns, computers take many tens of cycles to evaluate an operation like a an add or multiply. The operation is sequential and carried out in a multi-stage pipeline in the heart of a CPU (or GPU). So unless the compiler has something else for the processor to do, the processor will have to wait for one step to make it through the pipeline before the next step? . I think the normal way to do this is to have some inner horiz blocking that is flexible (and can be 1,1) and then iterate over levels with some intermediate stores? The horiz block can be some fraction of inner cache or GPU local proc shared mem. The math doesn't quite look at this way because it assumes that a+b and/or a*b etc.. happen ""instantaneously"". It does not take into account that the awnser from a*b might take; 5-10 clock cycles to pass through the CPU floating point unit. . I think that is fairly generally true? Functional style code in Julia should make it possible; to express this in a fairly clean way, but with flexibility to change blocking for different ; target arch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541363073:660,flexible,flexible,660,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541363073,1,['flexible'],['flexible']
Modifiability,Hmmm I thought this line would be enough. https://github.com/CliMA/Oceananigans.jl/blob/723ff2d69bb486a856c9748f84e56aef5e524c9e/docs/make.jl#L150. but you're right we used to use the `TRAVIS_REPO_SLUG` environment variable for this I think. Looks like the GitHub Actions equivalent is `GITHUB_REPOSITORY` like you linked to. But there doesn't seem to be one for Buildkite... https://github.com/JuliaDocs/Documenter.jl/blob/fa459cf315425d4fc5bdfbd6769f3b0e78f4a795/src/deployconfig.jl#L644-L666,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782346460:215,variab,variable,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782346460,1,['variab'],['variable']
Modifiability,"Hmmm, I'm not 100% sure how the callable object would work with `ParameterizedForcing` but as long as it's easy/intuitive to use in scripts then that'll be great. Do you have some pseudocode about what the setup would look like for users?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595941345:65,Parameteriz,ParameterizedForcing,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595941345,1,['Parameteriz'],['ParameterizedForcing']
Modifiability,"Hmmm, do we know why we can't adapt the full `Field` to work inside GPU kernels? I think you said you've tried it but ran into some issues a while back?. The definition is; ```julia; struct Field{X, Y, Z, A, G, B} <: AbstractField{X, Y, Z, A, G}; data :: A; grid :: G; boundary_conditions :: B; ```; where the `grid` has been adapted, `data` is usually an offset array which has also been adapted, and I thought individual boundary conditions have been adapted as well so feels like it should be easy to adapt the full `Field`. Note: `boundary_conditions` is a named tuple of `FieldBoundaryConditions` so maybe we just need to adapt `FieldBoundaryConditions`, `CoordinateBoundaryConditions`? Hmmm but they're really named tuples so maybe they're already adapted. If we can't adapt `Field` then yeah the adapt rules you've suggested sound pretty good and would simplify the time stepping a lot. The kernels already deal with data tuples so not much would even have to change I think. If we can adapt `Field` though, then we should get all the benefits of simpler time stepping code without the confusion of a non-vanilla adapt rule. X-Ref: https://github.com/climate-machine/Oceananigans.jl/issues/298",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-605973535:30,adapt,adapt,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-605973535,11,['adapt'],"['adapt', 'adapted']"
Modifiability,"Hmmm, on some level I feel like differentiating, interpolating, and integrating forcing functions seems like something the user should be doing, but I could see it being useful for collecting statistics for post-processing or analysis. If it's just a matter of switching arguments, then it sounds like a small price to pay for a potentially cool feature. I guess at some point we'll probably want to pick a convention and refactor the operators, time-stepping kernels, and user-defined functions to all match.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/390#issuecomment-527172040:422,refactor,refactor,422,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/390#issuecomment-527172040,1,['refactor'],['refactor']
Modifiability,"Hmmm, seems like taking an approach like Documenter.jl where everything is a module makes sense for us. In which case, each turbulence closure will become its own submodule. It could be part of a larger code refactoring to turn everything into a submodule.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/521#issuecomment-548770506:208,refactor,refactoring,208,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/521#issuecomment-548770506,1,['refactor'],['refactoring']
Modifiability,"Hmmm, should we be using [`CUDA.has_cuda_gpu`](https://cuda.juliagpu.org/dev/api/essentials/#CUDA.has_cuda_gpu) instead of [`CUDA.has_cuda`](https://cuda.juliagpu.org/dev/api/essentials/#CUDA.has_cuda)?. Since Tartarus actually has GPUs (we just hide them via an environment variable in CI, e.g. https://github.com/CliMA/Oceananigans.jl/blob/main/.buildkite/pipeline.yml#L77) I can see `CUDA.has_cuda_gpu` returning false (which we want) while `CUDA.has_cuda` would return true (not what we want). This might fix the unit tests (`test_field.jl`) but there are other failures that might not be related to this. Confusingly I see no recent changes in CUDA.jl that would lead to a difference in behavior for `has_cuda` (see changes for `src/initialization.jl`) but there were a lot of changes between v3.3.6 and v3.5.0 that I wouldn't understand: https://github.com/JuliaGPU/CUDA.jl/compare/v3.3.6...v3.5.0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942845682:275,variab,variable,275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942845682,1,['variab'],['variable']
Modifiability,"Hmmm, yeah I'll close it for now as we haven't discussed it in forever. The way the `Field` abstraction seems to have evolved is that we expose `Field`s to users, but behind the scenes we have to get a little messy and use either the `OffsetArray` or the underlying `Array/CuArray` as needed. Which is fine, as long as the user interface is clean.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/163#issuecomment-525545676:118,evolve,evolved,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/163#issuecomment-525545676,1,['evolve'],['evolved']
Modifiability,"How about this @dhruvbhagtani?. ```Julia; julia> struct SingleLayer end. julia> struct MultiLayer end. julia> struct ShallowWaterModel{N, T}; number_of_layers :: Int; parameter :: T; ; function ShallowWaterModel(number_of_layers, parameter); if number_of_layers == 1; return new{SingleLayer, typeof(parameter)}(number_of_layers, parameter); else number_of_layers > 1; return new{MultiLayer, typeof(parameter)}(number_of_layers, parameter); end; end; end. julia> const SingleLayerShallowWaterModel{T} = ShallowWaterModel{SingleLayer, T}; SingleLayerShallowWaterModel (alias for ShallowWaterModel{SingleLayer}). julia> model1 = ShallowWaterModel(1, 2.0); SingleLayerShallowWaterModel{Float64}(1, 2.0). julia> model2 = ShallowWaterModel(2, 2.3); ShallowWaterModel{MultiLayer, Float64}(2, 2.3). julia> typeof(model1) <: ShallowWaterModel; true. julia> typeof(model1) <: SingleLayerShallowWaterModel; true. julia> typeof(model2) <: ShallowWaterModel; true. julia> typeof(model2) <: SingleLayerShallowWaterModel; false. julia> do_something(::SingleLayerShallowWaterModel) = ""I'll do something for single layer""; do_something (generic function with 1 method). julia> do_something(x) = ""I'll do something for multiple layers""; do_something (generic function with 2 methods). julia> do_something(model1); ""I'll do something for single layer"". julia> do_something(model2); ""I'll do something for multiple layers""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1482001178:1210,layers,layers,1210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1482001178,2,['layers'],['layers']
Modifiability,How does this PR change `adapt`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2288911080:25,adapt,adapt,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2288911080,1,['adapt'],['adapt']
Modifiability,"Hyperviscosity _is_ an LES closure. It's not just a great one because it requires tuning (ie you have to select the hyperviscosity, and the hyperviscosity doesn't change). You can use a scaling argument to find the hyperviscosity:. $$ \nu_4 = \Delta^4 / \tau $$. where $\Delta$ is a length scale (typically the grid spacing) and $\tau$ is the time-scale over which you'd like to damp grid scale motions. The longer the better. Perhaps you can estimate a time-scale in terms of the buoyancy frequency (eg to damp grid scale buoyancy oscillations) --- like $\tau = C / N$ where $N$ is the buoyancy frequency and $C$ is a constant (perhaps not O(1)). $C = 10$ could be a good starting point. If you need more dissipation then decrease $C$, if you need less increase $C$. Its not ""less correct"" than an LES closure. (Both are closures, not exact.) As for all LES or macroscale computational science in general the goal is to find solutions with statistics of interest that are indepednent of resolution. Note that upwinding can be thought of as adding hyperdissipation which scales with the velocity (similar to traditional LES closures in fact). WENO is adaptive-order hyperdissipation, from biharmonic on up. Personally I suspect that WENO produces more physical solutions than ""traditional"" LES closures.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1518010193:1151,adapt,adaptive-order,1151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1518010193,1,['adapt'],['adaptive-order']
Modifiability,"I added some more but they definitely don't cover _all_ cases. Either I forgot or I am missing the point of `x/y/z/λ/φspacing` methods (the ones that give you a particular spacing). Like where would those be useful?. Btw, a periodic grid with faces at [0, 1, 11, 101] implying centers at [0.5, 6, 56] has the following spacings. It took me a while to confirm that the first spacing for Faces is actually correct. ```julia; julia> grid = RectilinearGrid(size=3, topology=(Periodic, Flat, Flat), x=[0, 1, 11, 101]); F = vcat(F₋, interiorF, F₊) = [-101.0, -100.0, -90.0, 0.0, 1.0, 11.0, 101.0, 102.0, 112.0, 202.0]; C = [(F[i + 1] + F[i]) / 2 for i = 1:TC] = [-100.5, -95.0, -45.0, 0.5, 6.0, 56.0, 101.5, 107.0, 157.0]; 3×1×1 RectilinearGrid{Float64, Periodic, Flat, Flat} on CPU with 3×0×0 halo; ├── Periodic x ∈ [0.0, 101.0) variably spaced with min(Δx)=1.0, max(Δx)=90.0; ├── Flat y; └── Flat z. julia> xspacings(grid, Center()); 3-element view(OffsetArray(::Vector{Float64}, -2:5), 1:3) with eltype Float64:; 1.0; 10.0; 90.0. julia> xspacings(grid, Face()); 3-element view(OffsetArray(::Vector{Float64}, -3:6), 1:3) with eltype Float64:; 45.5; 5.5; 50.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3054#issuecomment-1605785678:824,variab,variably,824,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3054#issuecomment-1605785678,1,['variab'],['variably']
Modifiability,"I admit I haven't read @tomchor script above in detail before making my comment... From my experience, sponge layers are usually applied as linear drag with a variable linear coefficient. E.g.,. ∂u/∂t = ... + μ(z) u; ∂v/∂t = ... + μ(z) v. where μ(z) is a function that is 0 everywhere and becomes 1 in the sponge with some transitional region of certain width. As, @glwagner points out, `tanh((z-z_sponge) / width_sponge)` is a good starting point.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733271068:110,layers,layers,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733271068,2,"['layers', 'variab']","['layers', 'variable']"
Modifiability,I agree that GPUifyLoops.jl is core to functionality but I don't think it's within its scope to extend to distributed architectures. I still think it's bad design to have the GPUifyLoops structures showing up e.g. in the Poisson solvers where it has nothing to do with GPUifying loops. Yeah I was thinking of using a dictionary to map between the two definitions but the translation functions you proposed is even better.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/133#issuecomment-473711085:96,extend,extend,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/133#issuecomment-473711085,1,['extend'],['extend']
Modifiability,I agree that having a flexible particle tracking framework is more important. I've already started refactoring with @suyashbire1. Just wanted to benchmark the barebones implementation first to ensure that the extra features don't slow it down by 100x. Sometimes it's easy to introduce huge slowdowns on the GPU.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-733209783:22,flexible,flexible,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-733209783,2,"['flexible', 'refactor']","['flexible', 'refactoring']"
Modifiability,"I agree that it always returns a `Float32`. However, `@cuprintln` was clearly showing depths that were `Float64` inside the GPU kernels. Outside any kernel, I was not able to call `znode` and get back a `Float64`. . So I think your right that it might just be a GPU issue and maybe we just need to adapt `StepRangeLen` for the GPU to use `Float32`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445709565:298,adapt,adapt,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445709565,1,['adapt'],['adapt']
Modifiability,"I agree the current state of affairs puts a lot of responsibility on the user to ensure they pass `Float32` to every constructor that requires it, which is not very _friendly_ especially to new users who aren't familiar with the code. I also agree that having a way to specify the default number type in Julia is better than using an environment variable. Besides the limitation of strings, I feel like it would stray from Oceananigans.jl's script-based interface. If you share a script with someone now, you also need to inform them to run with specific environment variables. With enough environment variables you'll want a `.env` file. Agree with @Yixiao-Zhang that with `Oceananigans.set_default_number_type(FT)` we can do some checks and throw appropriate warnings compared with `Oceananigans.settings[:default_number_type] = Float32` (assuming it's a vanilla dictionary). > Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). Glad you brought this up! Definitely a use case for an expert/power user but I can think of a few use cases (e.g. nested simulations) that would be good to support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2396992817:346,variab,variable,346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2396992817,3,['variab'],"['variable', 'variables']"
Modifiability,"I agree tutorials is the way to go.; Let's talk about how to get these done.; John. On Fri, May 24, 2019 at 8:01 AM Gregory L. Wagner <notifications@github.com>; wrote:. > I think we should have ""tutorials"" in addition to examples! Examples are; > for ""quickstarting"" -- download the code and run *something*. Tutorials; > are extended examples with documentation, plots, etc. What do you think; > about that?; >; > Ultimately when the code is more stable I could see the utility of having; > more than just 2-3 examples, though.; >; > —; > You are receiving this because you commented.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/221?email_source=notifications&email_token=AKXUEQRIXKFCEQMBMBP2IELPW7KJ5A5CNFSM4HM5OBLKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODWFCXIA#issuecomment-495594400>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQV45XSBFQ4JHHFN2P3PW7KJ5ANCNFSM4HM5OBLA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/221#issuecomment-495691216:327,extend,extended,327,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/221#issuecomment-495691216,1,['extend'],['extended']
Modifiability,"I agree we can make the functions a little more verbose in that sense. ; We can change `calc_ κᶜᶜᶜ` to `calc_nonlinear_ κᶜᶜᶜ` and `calc_νᶜᶜᶜ` to `calc_nonlinear_νᶜᶜᶜ`. ; (`κᶜᶜᶜ` does not exist because diffusivity is needed at faces). For the variables we can make them verbose or agree to have a _concise_ naming convention (parallel to the verbose one) that is always consistent (i.e., `U` is `velocities`, `C` is `tracers`, `b` is `bouyancy` and so on)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1257255335:242,variab,variables,242,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1257255335,1,['variab'],['variables']
Modifiability,I agree we should pick a convention and stick to it. I'll think more about this the next time I'm refactoring `time_steppers.jl`. But your proposed ordering looks good to me!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/448#issuecomment-541416078:98,refactor,refactoring,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/448#issuecomment-541416078,1,['refactor'],['refactoring']
Modifiability,I agree we should use it as a default and define it as a `const`. But I like to keep superscripts for notation (mostly because the entire alphabet isn't available as superscripts or subscripts) so in this case I might instead use the variable name `Ω_Earth`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/510#issuecomment-547212395:234,variab,variable,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/510#issuecomment-547212395,1,['variab'],['variable']
Modifiability,"I agree with @ali-ramadhan, keeping a `overwrite_existing` seems quite important to me too, potentially with a default value of `overwrite_existing = false`. . Another issue to add into this discussion is the fact of how to handle output (e.g. `file.nc`) with checkpoints and `file_splitting`. Currently, when a simulation is pickup from a checkpoint having the flag `overwrite_existing = true` rewrites to empty all the pre-existing files (i.e. file_part1.nc, file_partN.nc). With `overwrite_existing = false`, the simulation crashes because it doesn't find the file `file.nc`. I think it will be useful to handle automatic concatenation to splitted files, to allow a more flexible output particularly in the context of HPC computing with manageable file sizes, chunks, and wall times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391714179:395,rewrite,rewrites,395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391714179,2,"['flexible', 'rewrite']","['flexible', 'rewrites']"
Modifiability,"I agree with this. I think our experience has shown that requiring submodule imports is a huge source of boilerplate. At the same time, I think we should stop exporting names from submodules (for better internal code documentation). This will requires some refactoring.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1132#issuecomment-720680776:257,refactor,refactoring,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1132#issuecomment-720680776,1,['refactor'],['refactoring']
Modifiability,"I agree, let's just disable this test for now so we can merge outstanding PRs and rewrite the test",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430155087:82,rewrite,rewrite,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430155087,1,['rewrite'],['rewrite']
Modifiability,"I also find `with_halos` a bit messy, but in this case it might be neccessary to output grid metrics to disk if JLD2 or NetCDF are configured to output the halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450863860:131,config,configured,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450863860,1,['config'],['configured']
Modifiability,"I am happy to follow this discussion and even though I am very new to the table but will share a perspective. Outside of the context of Oceananigans, I would think of the collection of PDEs as the physical model, and the method by which we discretize them in both space and time, as the numerical model. In this context, when we say model we mean the spatial discretization of the physical model, which is most of but not quite all of the numerical model. The fact that we don't have Advection in the Models folder is consistent and a good idea. It makes sense to me to put the time stepping in simulations since that is the part where we turn the crank and find the solutions to the prognostic variables. . I suspect the user might benefit from a little bit of discusson on this in the docs so that they can better understand the framework you've set up, which works great. This is of course something to be done when you have spare time, if such a thing really exists. ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1175#issuecomment-728907421:695,variab,variables,695,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1175#issuecomment-728907421,1,['variab'],['variables']
Modifiability,"I am just not extremely sure about the name `backend_kwargs`: at first glance, I thought it would be the keyword arguments of the `backend`, but it is just related to the reader of the underlying data (which for the moment, is only JLD2) and is not necessarily related to the backend (for the moment). ; I guess `jld2_kw` like in the `JLD2OutputWriter` does not work if we want to extend this to NETCDF. would something like `reader_kwargs` or `IO_kwargs` work you think?; Otherwise, if `backend_kwargs` is ok for the majority I can accept this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2441804321:381,extend,extend,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2441804321,1,['extend'],['extend']
Modifiability,"I am strongly in favor of more localized parameters as it makes the code more modular and we can stop juggling around `model.parameters`. If users do want a global-like parameters object, they can define one big named tuple and pass it to all the `ParameterizedForcingFunction`s and `ParameterizedBoundaryFunction`s.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595952615:248,Parameteriz,ParameterizedForcingFunction,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595952615,2,['Parameteriz'],"['ParameterizedBoundaryFunction', 'ParameterizedForcingFunction']"
Modifiability,"I am thinking about it actually, for the moment I am dealing with bug fixing and improving stability and accuracy (which should be basically finished), when I have everything tested and verified I ll proceed with the refactor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1155362210:217,refactor,refactor,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1155362210,1,['refactor'],['refactor']
Modifiability,"I am very curious to hear what people think but do think it would make sense to have a tab called Models where we state briefly the model equations. This way the user knows exactly what their getting themselves into. We have that for `IncompressibleModel` in the `Physics` section, and feel the other two models should get a bit of converge. Even though the numerical methods will evolve, the governing equations will not change. Or if they do we'll be adding more into them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1460#issuecomment-798799226:381,evolve,evolve,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1460#issuecomment-798799226,1,['evolve'],['evolve']
Modifiability,"I can answer my own question:. Needs to put `const` before all parameters, as described in the [Documentation](https://clima.github.io/OceananigansDocumentation/stable/simulation_tips/#Global-variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters). ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units; using Adapt. const Ny = 4000 # number of points in y; const Nz = 50 # number of points in z; const H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. const width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers=:b, buoyancy=BuoyancyTracer()). const h = 50meters # mld; const Hv = 150meters # virtual h (stratification) ; const S = 2.8 # m/s; const c=2750kilometers # center of the storm; const l=pi/(250kilometers) # horizontal wavenumber of the storm. @inline B(x, y, z) = ifelse(z>-h, (S^2)/(Hv+h), (S^2)/(Hv-z)); @inline U(x, y, z) = ifelse(abs(l*(y-c))<pi && z>-h, sin(l*(y-c)), 0). set!(model;b=B,u=U). simulation = Simulation(model, Δt = 1minutes, stop_time = 20days). simulation.output_writers[:velocities] =; JLD2OutputWriter(model, model.velocities, prefix = ""../data/velocities"",; schedule=TimeInterval(3hour), force = true). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068625008:192,variab,variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068625008,3,"['Adapt', 'layers', 'variab']","['Adapt', 'layers', 'variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters']"
Modifiability,"I can confirm what Ali said. I used Oceananigans (3D) to compare to Dedalus (2D) output in ""identical"" configurations. It's the first publication that uses Oceananigans!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/973#issuecomment-699228920:103,config,configurations,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/973#issuecomment-699228920,1,['config'],['configurations']
Modifiability,"I can help with a few things:. 1. Moving the existing implementation of `set!` to `Models/IncompressibleModels`.; 2. Writing a new version of `set!` that works with `ShallowWaterModel`.; 3. Implementing a few simple tests that ensure `ShallowWaterModel` can be instantiated. @francispoulin let me know if you'd like to me to work on those three things. For 2. I need some clarification: `IncompressibleModel` has a tuple of fields called `model.velocities`, which always has fields `velocities.u, velocities.v, velocities.w`. For `ShallowWaterModel` I believe the three essential prognostic variables are `uh`, `vh`, and `h`. Then there can be additional tracers in `sw_model.tracers`. How do you want to organize the essential prognostic variables? I think you can come up with any name you want, or you can split them into multiple places...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1188#issuecomment-729925232:591,variab,variables,591,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1188#issuecomment-729925232,2,['variab'],['variables']
Modifiability,"I can use CUDA on sverdrup:. ```julia; julia> using CUDA. julia> CUDA.has_cuda(); true. julia> CuArray(rand(3)); 3-element CuArray{Float64, 1}:; 0.5230283963088462; 0.0396121811777137; 0.04373785020067866; ```. this is with CUDA v3.3.1:. ```julia; (v1.6) pkg> st; Status `/net/ocean/home/data44/data5/glwagner/.julia/environments/v1.6/Project.toml`; [052768ef] CUDA v3.3.1; ```. so this suggests that indeed the problem is with the buildkite setup. > Why is JULIA_CUDA_USE_BINARYBUILDER=""true"" needed?. This was needed briefly when an nvidia driver went out of date. It is no longer out of date, however, so this environment variable is not needed anymore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1794#issuecomment-872215666:625,variab,variable,625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1794#issuecomment-872215666,1,['variab'],['variable']
Modifiability,"I can't run the MPI. I need to be directed to some instructions to setup my MPI. @simone-silvestri pointed at the [MPI docs](https://juliaparallel.org/MPI.jl/stable/configuration/#Configuration). Do I need MPIPreferences? I don't know... @glwagner did you have to use that? If not, why must I... we are using the same machine...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2282501425:165,config,configuration,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2282501425,2,"['Config', 'config']","['Configuration', 'configuration']"
Modifiability,"I changed the name because I believe that ""golden master"" is misleading: as far as I know, a ""golden master"" test is one in which the output of the model matches some *externally* verified result (eg, an MITgcm solution, or a numerical solution reported in the literature). In other words, a ""golden master"" in our case is another numerical model that we (arbitrarily) deem to be a master. These tests are not ""golden master"" tests in that sense. Instead, they test whether the output of the model has ""regressed"", or changed relative to a prior output of the model generated in an identical configuration. Basically, we should not commit ""updates"" to golden master output, because the golden master is... the golden master. However, we do have to update the regression test data when we find bugs in `Oceananigans`. Make sense?. It would be nice to have golden master tests, too. Our best hope for this are tests that use a turbulence closure, since there are many published results for ""low-resolution"" solutions using common turbulence closures like Constant Smagorinsky. Unfortunately, we do not support the boundary conditions that the majority of published results use at low-resolution (either triply-periodic, or vertically-bounded with a 'wall model'). . We are also limited right now in verifying the accuracy of the model to high-resolution published results because the GPU solver appears to generate different results than the CPU solver.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/239#issuecomment-496230553:592,config,configuration,592,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239#issuecomment-496230553,1,['config'],['configuration']
Modifiability,I changed the title if you want to focus on variable time-step but I think you should open another discussion or issue for the other stuff about the size of chi,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313366216:44,variab,variable,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313366216,1,['variab'],['variable']
Modifiability,"I continued refactoring and fixing tests now that `*spacings` use `KernelFunctionOperation`s to return `Field`s. All grid tests should pass now. And `*spacings` works on immersed grids fulfilling the original intent of this PR. Do we want an `include_halos` option or should the spacings be computed in the halos by default? I'm actually not sure how to make `KernelFunctionOperation` compute things in the halos. Will look into it. I'm also bumping v0.94.0 since this is a breaking change to the public interface. If people are happy with these changes, I can work on adding some more tests and docstrings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221:12,refactor,refactoring,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221,1,['refactor'],['refactoring']
Modifiability,I could keep cleaning things up but I think I've done enough to close #59 (and 6 other issues!). The only big feature missing is turning our `Field` struct into something we can adapt/convert to a CUDA device argument using `cudaconvert` or Adapt.jl. We can do more cleanup when we figure out how to do this. Note that tests will fail on dev/nightly builds (Julia 1.2) because something changed which broke Cassette (which GPUifyLoops depends on). Will release v0.5.0 once this is merged.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/147#issuecomment-479305069:178,adapt,adapt,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/147#issuecomment-479305069,2,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,"I decoupled the high-order reconstructions from the low-order interpolations. ; The reconstruction for advective fluxes are in `Advection/reconstruction_coefficients.jl`. You can probably extend all the instances of `symmetric_interpolate`, `left_biased_interpolate` and `right_biased_interpolate` in `flat_advective_fluxes`. Or maybe put a fallback for Flat grids in `topologically_conditional_interpolation.jl`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1263713946:188,extend,extend,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1263713946,1,['extend'],['extend']
Modifiability,"I didn't have a use-case in mind when suggesting this. It'll be rare for oceanography that two horizontal directions need to have different eddy diffusivities (though I'm sure that would be reasonable in some cases (balanced jet?)), but I think it's worth to implement that capability if we're trying to make Oceananigans a flexible, general-purpose-ish CFD package. Plus, given that parallelization capabilities are limited to only some directions, I can envision cases where users will rotate their domain in a way where the ""horizontal"" directions are actually `y`, `z`, and then `HorizontalDirections` won't work as intended. In any case, I personally will probably never use this feature, and it was only a suggestions for possible future uses. So feel free to ignore it if you think it's not worth it :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2262#issuecomment-1047165720:324,flexible,flexible,324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2262#issuecomment-1047165720,1,['flexible'],['flexible']
Modifiability,"I didn't have the same problem! I think that means the issue could arise from some downstream package in your Manifest.toml in your global 1.5 environment (which is not present in mine, for some reason). What is the output of. ```julia; julia> pkg""st --manifest""; ```. ?. Mine is. ```julia; julia> pkg""st --manifest""; Status `~/.julia/environments/v1.5/Manifest.toml`; [621f4979] AbstractFFTs v1.0.1; [79e6a3ab] Adapt v2.4.0; [4fba245c] ArrayInterface v2.14.17; [56f22d72] Artifacts v1.3.0; [ab4f0b2a] BFloat16s v0.1.0; [6e4b80f9] BenchmarkTools v0.7.0; [6e34b625] Bzip2_jll v1.0.6+5; [fa961155] CEnum v0.4.1; [179af706] CFTime v0.1.1; [052768ef] CUDA v2.3.0; [83423d85] Cairo_jll v1.16.0+6; [7057c7e9] Cassette v0.3.4; [d360d2e6] ChainRulesCore v0.9.29; [944b1d66] CodecZlib v0.7.0; [35d6a980] ColorSchemes v3.10.2; [3da002f7] ColorTypes v0.10.9; [5ae59095] Colors v0.12.6; [34da2185] Compat v3.25.0; [e66e0078] CompilerSupportLibraries_jll v0.3.4+0; [d38c429a] Contour v0.5.7; [a8cc5b0e] Crayons v4.0.4; [7445602f] CubedSphere v0.1.0; [9a962f9c] DataAPI v1.6.0; [864edb3b] DataStructures v0.18.9; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.0.2; [ffbed154] DocStringExtensions v0.8.3; [5ae413db] EarCut_jll v2.1.5+1; [b305315f] Elliptic v1.0.1; [2e619515] Expat_jll v2.2.7+6; [e2ba6199] ExprTools v0.1.3; [c87230d0] FFMPEG v0.4.0; [b22a6f82] FFMPEG_jll v4.3.1+4; [7a1cc6ca] FFTW v1.3.2; [f5851436] FFTW_jll v3.3.9+7; [53c48c17] FixedPointNumbers v0.8.4; [a3f928ae] Fontconfig_jll v2.13.1+14; [59287772] Formatting v0.4.2; [d7e528f0] FreeType2_jll v2.10.1+5; [559328eb] FriBidi_jll v1.0.5+6; [0656b61e] GLFW_jll v3.3.2+1; [0c68f7d7] GPUArrays v6.2.0; [61eb1bfa] GPUCompiler v0.8.3; [28b8d3ca] GR v0.53.0; [d2c73de3] GR_jll v0.53.0+0; [5c1252a2] GeometryBasics v0.3.9; [78b55507] Gettext_jll v0.20.1+7; [7746bdde] Glib_jll v2.59.0+4; [c27321d9] Glob v1.3.0; [42e2da0e] Grisu v1.0.0; [0234f1f7] HDF5_jll v1.12.0+1; [cd3eb016] HTTP v0.8.19; [83e8ac13] IniFile v0.5.0; [1d5cc7b8] Intel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824043189:412,Adapt,Adapt,412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824043189,1,['Adapt'],['Adapt']
Modifiability,"I don't suspect this is the best place to post this but I'll start here and happy to move the conversation over to wherever it should be happening. I have created a new branch called ""ShallowWaterS1waveeqn"". S1 is for step 1. It doesn't do much right now but I'm trying to set up the skeleton so that we can actually do something intereting, like evolve the equation. At the moment I have the following:. - Created a ShallowWaterModels folder. - Created a ShallowWaterModels.jl module. It doesn't do much except include shallowwater_model.jl. - shallowwater_model.jl defines a mutable struct and a function. I couldn't get a lot of things to work but it does regularlize the boundary condtions, set up the velocities and a new variable called layer_depth. The name is not great and can go with depth or height, as people prefer. It will be in in the governing equations. - Created an example, in the same folder, called onedim_shallowwater.jl. Currently, this includes the module mentioned above, defines a grid (yes, a single point!), defines the initial conditions and sets the velocity. Questions: . 1. This is pretty bare bones so far but does this follow the philosophy of Oceananigans?; 2. I have tried to inititalze the layer_depth by adding an argument into the set! command but it failed. Below is the command that I thought would work and below is the error because layer_depth is not model.velocities or model.tracers. Can someone help me to see what silliness I am doing?. ``` ; set!(model, u = u, v = v, layer_deth = layer_depth); fails with ""ERROR: LoadError: ArgumentError: name layer_depth not found in model.velocities or model.tracers.""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-728964105:347,evolve,evolve,347,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-728964105,2,"['evolve', 'variab']","['evolve', 'variable']"
Modifiability,I don't think it should because the issue here is whether we conserve tracers when we have explicit diffusion and should probably use no flux boundary conditions. The tests on PR #1486 test whether fluxes across boundaries are correctly prescribed (and uses `closure=nothing`). The tests are pretty similar though and resolving this issue is a priority now. We also need to extend the tests mentioned in this issue to other models and grids.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/942#issuecomment-801146245:374,extend,extend,374,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/942#issuecomment-801146245,1,['extend'],['extend']
Modifiability,"I don't think so, we can refactor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2623#issuecomment-1480040680:25,refactor,refactor,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2623#issuecomment-1480040680,1,['refactor'],['refactor']
Modifiability,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:1030,adapt,adapted,1030,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874,1,['adapt'],['adapted']
Modifiability,"I don't think this is resolved. However, I think we should discourage using arrays for boundary conditions. We should encourage users to use functions because they are more portable, faster, and easier to interpret the meaning of when reading a script. Should we close this issue as a result?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/419#issuecomment-663172613:173,portab,portable,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/419#issuecomment-663172613,1,['portab'],['portable']
Modifiability,I don't think we use PencilArray for CuArray either in the source code or tests. My question is: does bumping PencilArrays and PencilFFTs mean that we can extend the distributed FFT algorithm (currently only implemented on CPU) to GPUs?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3121#issuecomment-1613498127:155,extend,extend,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3121#issuecomment-1613498127,1,['extend'],['extend']
Modifiability,"I don't think you can pass a field_dependency as symbols `(:v, :w)` because symbols cannot be passed into GPU kernels.; I'll check the proper syntax for `field_dependencies`. Correction: you should be able to because `field_dependencies` should not pass to the GPU when adapted, but now it is being passed internally somewhere...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2563#issuecomment-1130308748:270,adapt,adapted,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563#issuecomment-1130308748,1,['adapt'],['adapted']
Modifiability,"I draft a repo on this matter [here](https://github.com/iuryt/Bioceananigans.jl).; I tried to summarize my ideas in the README:. > Most of the interelationships between biogeochemical tracers could be implemented using the **forcing functions** (see [Convecting Plankton](https://clima.github.io/OceananigansDocumentation/stable/generated/convecting_plankton/) example from Oceananigans documentation), but commonly the light or light-limiting growth of the phytoplankton are **averaged over the mixed layer** in order to parameterized the effects of the mixing in the upper boundary layer. In other words, the mixing timescale is usually longer than photosynthesis, but shorter than cell-division time, which makes phytoplankton **see the average light or grow at the average light-limiting growth rate** while on the mixed layer. Other example of processes that are not easily implemented on Oceananigans include the **shading of phytoplankton** to deeper layers and the **sinking velocity**. The latter is currently being implemented on Oceananigans by this [Pull Request](https://github.com/CliMA/Oceananigans.jl/pull/2389) with a new forcing called `AdvectiveForcing`.; > ; > For now, this repository basically gives a set of modules that can be used to estimate the mixed-layer depth, estimate the phytoplankton shading and calculate the light-limiting growth, which is defined by the user as a function, and then the light (or the light-limiting growth) can be averaged over the mixed layer. So basically the repository can simply give all auxiliary functions that are needed for the biogeochemical models, but not the interelationship functions, which can be defined as forcing functions and added to a list of examples on the documentation. I don't mind giving up this repository and merging or adding it to the organization if this is somehow a good starting point.; I am also interested in seeing what the others think about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116856781:522,parameteriz,parameterized,522,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116856781,2,"['layers', 'parameteriz']","['layers', 'parameterized']"
Modifiability,"I feel that labeling it ""weird"" is a harsh judgement. But I would say that using the word ""oceanic"" to describe software is ""quirky"". If folks prefer ""ocean-flavored"" (also quirky, just more characters), let's switch to that. Being ""flexible"" is probably one of our core philosophies as well so I agree with adding that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945819977:233,flexible,flexible,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945819977,1,['flexible'],['flexible']
Modifiability,"I finished the first draft (of the topics I know about at least). I haven't written the very last subsection though, which is about viewing/using arrays in GPU runs because honestly I don't know enough to write about it. I know there's a function called `view()` that helps with slicing, and you can also use `adapt` to view CUDA Arrays in REPL for investigating, but I feel like I don't know enough of this aspect of the code to write this. There are two options here:. - Someone helps me out and writes that last section; - Or I can merge the PR without it for now (there are many other important things there for the user) and we worry about that last part in a future PR. Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-814533032:310,adapt,adapt,310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-814533032,1,['adapt'],['adapt']
Modifiability,I guess from a refactoring point of view it might also make sense to wait until we're closer to Oceananigans v1.0 before splitting off into multiple smaller packages. If we have to refactor code that involves deep changes (still likely) right now it might be easier to refactor 1 package rather than refactor across multiple packages + tag releases etc.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815049079:15,refactor,refactoring,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815049079,4,['refactor'],"['refactor', 'refactoring']"
Modifiability,"I guess this is not the issue (since `Qᵇ = 0`), but just be aware that this line:. https://github.com/BrodiePearson/Oceananigans.jl/blob/838cc38552ba8c4acff583aef840157cf7f145da/examples/nonlinear_EOS_crash.jl#L104. is not correct if `Qᵇ` is buoyancy flux (as the numbers of the commented out line suggest it is)--- it is only correct is `Qᵇ = 0` is *heat* flux. Which may be what you want anyways for this problem... Note also that TEOS10 requires a reference density. Thus this line:. https://github.com/BrodiePearson/Oceananigans.jl/blob/838cc38552ba8c4acff583aef840157cf7f145da/examples/nonlinear_EOS_crash.jl#L93. introduces a second reference density that isn't equivalent to the one used by TEOS10 (the [default for TEOS10 in `SeawaterPolynomials.jl` is 1020 kg / m^3](https://github.com/CliMA/SeawaterPolynomials.jl/blob/9e3342ec405bff01dee23e6309dd9de6fe342aa8/src/TEOS10.jl#L56)). The two can be synced by instantiating the TEOS10 equation of state object first:. ```julia; eos = TEOS10EquationOfState(FT); ```. and then using `eos.refererence_density`. You can also adjust the reference density for the equation of state by writing. ```julia; eos = TEOS10EquationOfState(FT, reference_density=1027); ```; As for negative salinity... the only thing I can think of is that its a numerical error due to a violation of a CFL condition (or something similar). Does reducing the CFL used in adaptive time stepping to 0.1 or 0.05 help? You might also reduce the initial time-step. With a strong momentum flux, you'll get strong surface velocities initially, and it may be best to start time-stepping with a very small time-step. Yo could try to replace this line: . https://github.com/BrodiePearson/Oceananigans.jl/blob/838cc38552ba8c4acff583aef840157cf7f145da/examples/nonlinear_EOS_crash.jl#L223. with. ```julia; wizard = TimeStepWizard(cfl=0.1, Δt=0.1, max_change=1.1, max_Δt=10.0); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/802#issuecomment-659694281:1396,adapt,adaptive,1396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/802#issuecomment-659694281,1,['adapt'],['adaptive']
Modifiability,I guess we could call it `grid_metric` instead of `area` and the iterator can be called `met` or `m` or `grid_term` instead... Probably also the comment above should be changed to something in the line of `operators of the form M * q where M is a grid metric and q is some variable`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2285#issuecomment-1055034558:273,variab,variable,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2285#issuecomment-1055034558,1,['variab'],['variable']
Modifiability,"I have a practical example that might demand a better interface for `calculate_diffusivities!` (or at least defining it for `ScalarDiffusivities`). I am now using quite complex formulations to calculate the viscosity for `ScalarBiharmonicDiffusivity`. Because of the staggering of the variables, the viscosity can only be calculated at `Center`s; I am using now `DiscreteDiffusionFunction`, which interpolates my formulation to the desired location in space.; This is very inefficient because I am recomputing the expensive viscosity multiple times in the same place.; It would be nice to have an option to have a precomputed diffusivity also in case of a `ScalarDiffusivity`, but provide the function to calculate the diffusivity as it is now done for `DiscreteDiffusionFunction`.; This would allow the code to be way more personalizable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260817342:285,variab,variables,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260817342,1,['variab'],['variables']
Modifiability,"I have a start to this soon to be PR (I hope) but nothing working yet. . One issue that comes up is that `automatic_halo_sizing.jl` should not extend the halo if the topology is flat This is easy enough to set this up in principle, however, when I try telling it what `Flat` means using the following `using Oceananigans.Grids: Flat`, it fails. . How should I load `Flat` at this stage?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-803738292:143,extend,extend,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-803738292,1,['extend'],['extend']
Modifiability,"I have created a new validation script called `shallow_jet_topography.jl` that evolves the barotropically unstable jet (like in the shallow water example) but now over a shelflike topography. It can be found in `valiation/shallow_water`. . Some preliminary results are shown below. First, this is the case with a flat bottom and it does produce the same results as what we have in the example. ![Geostrophic_State](https://github.com/CliMA/Oceananigans.jl/assets/8239041/3f8cc034-6764-4d3e-a7c1-510d7b55073d). Second, this is an example of prograde topography with the shallow water on the right of the propogating jet. ![Geostrophic_State](https://github.com/CliMA/Oceananigans.jl/assets/8239041/d262c028-1ea3-41b8-8573-8ab4419ed891). Third, this is an example of retrograde topopgraphy with the shallow water on the right of the propogating jet. ![Geostrophic_State](https://github.com/CliMA/Oceananigans.jl/assets/8239041/064ebf34-b8bf-4cca-9000-a9edb1bdfd94). The growth rates differ but I want to update my linear stability code to compute the growth rates so that we can validate that the results are quantitatively close. But for this case here the prograde case is slightly more unstable with the rettrograde case, which is qualitatively correct.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973911400:79,evolve,evolves,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973911400,1,['evolve'],['evolves']
Modifiability,"I have introduced the option to iterate as well an option to use the formulation that assumes infinite iterations (`iterations = nothing`). If you want to give it a try for a simple configuration that would be nice!. example:; ```julia; grid = RectilinearGrid(size = (10, 10, 10), extent = (1, 1, 1)). advection = MPData(grid; iterations = 1) # equivalent to UpwindBiased(; order = 1); advection = MPData(grid; iterations = 3) # 3 corrective iterations; advection = MPData(grid; iterations = nothing) # ∞ iterations (a little more expensive); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1942023450:182,config,configuration,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1942023450,1,['config'],['configuration']
Modifiability,"I honesntly don't have a personal preference here. I'm just myself off of [Julia naming conventions](https://docs.julialang.org/en/v1/manual/variables/#Stylistic-Conventions) for variables and [general identified styles](https://en.wikipedia.org/wiki/Naming_convention_(programming)#Examples_of_multiple-word_identifier_formats). `ZFaces`, `z_faces` or `z_Faces` work for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814143240:141,variab,variables,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814143240,2,['variab'],['variables']
Modifiability,I just changed the Adapt.jl compat entry to make use of the new version with the `StepRangeLen` fix. The MWE from #3870 does not error with Adapt.jl v4.1.1 locally.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2447316135:19,Adapt,Adapt,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2447316135,2,['Adapt'],['Adapt']
Modifiability,"I just did some refactoring so that the Poisson solver parameters (including any FFTW or CuFFT plans) are not serialized to disk. They are rebuilt when restoring from a checkpoint. We can figure out the minimum amount of data that needs to be saved for a restart later as that'll need more code to support, and the savings aren't massive I imagine. The fact that JLD supports some fast compression is the biggest space saver right now. I decided to go with [JLD.jl](https://github.com/JuliaIO/JLD.jl) as [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) looks to be unmaintained since Julia 1.0= came out, which is a shame as it fits our needs better. But either way, checkpointing is done every 10k time steps so not too worried about speed right now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/30#issuecomment-466787189:16,refactor,refactoring,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/30#issuecomment-466787189,1,['refactor'],['refactoring']
Modifiability,"I just looked over the source code, and while I think this will be easy for the serial case, the code for distributed models is... fun... I have wanted to refactor the distributed stuff to make it understandable for a while anyways though. So I think we can come out on top.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388820708:155,refactor,refactor,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388820708,1,['refactor'],['refactor']
Modifiability,"I left a few comments in the code. To guide the design of this feature, consider a few important use cases:. 1. Buoyant particles (eg particles that feel an ""additional"" advecting velocity, in addition to `model.velocities` and `model.background_fields.velocities`); 2. Chemical reactions taking place on particles; 3. ""Elastic"" particles that bounce of walls with a specified coefficient of restitution; 4. Particles that are nudged with random stochastic noise in addition to advection (this is a crucial feature that is necessary to approximate the effect of molecular / subfilter turbulent diffusion). I am not suggesting that we support all of these immediately or in the near future, but it'd be good to have a type-based infrastructure for particle dynamics that can be extended to include more features.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-713689396:777,extend,extended,777,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-713689396,1,['extend'],['extended']
Modifiability,"I looked at both of those and they aren't very fast. That's why I coded up; my own in WaterLily. I have used CG preconditioners before with variable coefficient Poisson; equations and I agree they are a nice matrix free approach. Gabriel D Weymouth; _______________________________________________; ""Computers are useless. They can only give you answers."" Pablo Picasso. On Thu, Jun 17, 2021 at 2:54 AM Francis J. Poulin ***@***.***>; wrote:. > I have never used multigrid solvers in julia but did a quick look around; > and found there are at least a couple of libraries one can use. If someone; > decides they want to play with multigrid, I would suggest looking at these; > and other libraries as that would be very fast to get started.; >; > https://github.com/JuliaLinearAlgebra/AlgebraicMultigrid.jl; > https://github.com/JuliaInv/Multigrid.jl; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-862853210>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AADSKJ7IMJP5XPQFKUSYHGDTTFIUFANCNFSM457USDVQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-863021831:140,variab,variable,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-863021831,1,['variab'],['variable']
Modifiability,"I made one extra change which is that I don't call `N^2 / S^2` a Richardson number anymore. Since the denominator is a strain rate, not the _vertical_ shear, I think it's odd to call it `Ri`. Also that variable (whatever you call it) only appears 3 times briefly so there's no need to give it a name. It appears that our buoyancy modification doesn't really match Pressel's or Lilly's since we use an arbitrary `C_b` while they proposed to use `1/Pr_t`. @glwagner Is there any reference for that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889288420:202,variab,variable,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889288420,1,['variab'],['variable']
Modifiability,I need to digest this suggestion! But in the meantime: does this work for changing `dt`? For idealized / strongly-time-dependent problems we often find it useful to continuously adapt the time-step according to a CFL criteria.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461:178,adapt,adapt,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461,1,['adapt'],['adapt']
Modifiability,I opened a new issue for parameterized Callbacks --- check out #2127,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001249751:25,parameteriz,parameterized,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001249751,1,['parameteriz'],['parameterized']
Modifiability,"I propose that we develop a type that corresponds to a boundary conditions. I think the following user code will be nice:. ```Julia; ...; surface_flux(x, y, z, t) = F_b * exp(-x^2 / 2L^2) * cos(σ*t); bottom_flux = N^2. top_bc = DirichletBoundaryCondition(:T, :z; :right, surface_flux); bottom_bc = DirichletBoundaryCondition(:T, :z, :left, bottom_flux). model = Model(... bcs=[top_bc, bottom_bc]); ```. (The names of the types are certainly up for debate: we might also have `ConstantDirichletBoundaryCondition` and `VariableDirichletBoundaryCondition`, and either expose it to the user or hide this layer from from the user and use multiple dispatch to parse between user-inputs.). We can propose default boundary conditions that are deployed whenever a boundary condition is not specified.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/86#issuecomment-468249677:517,Variab,VariableDirichletBoundaryCondition,517,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/86#issuecomment-468249677,1,['Variab'],['VariableDirichletBoundaryCondition']
Modifiability,"I propose we develop output tools that permit the specification of completely arbitrary output with flexible naming. Then, we can write additional convenience functions that allow users to opt for default/standard output with standardized names.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/91#issuecomment-468288139:100,flexible,flexible,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/91#issuecomment-468288139,1,['flexible'],['flexible']
Modifiability,"I put a ton of effort into making it so that we could include one file and run the tests. So if its broken or wasn't a complete solution hopefully we can fix it, or make it work more generally. It's more annoying to have to include the filename as a global variable. I don't like that workflow as much. When we can include a file, we can rapidly iterate because we don't have to wait for things to recompile.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3507#issuecomment-1997573228:257,variab,variable,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3507#issuecomment-1997573228,1,['variab'],['variable']
Modifiability,"I put some work into the description, removing ""oceanic"" in favor of ""ocean-flavored"" and adding ""flexible"". Please reopen if there's still an issue!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-960167339:98,flexible,flexible,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-960167339,1,['flexible'],['flexible']
Modifiability,"I refactored the interface significantly. Now instead of using a model property `immersed_boundary`, I've introduced a new grid ""wrapper"" called `ImmersedBoundaryGrid`. This new grid wrapper replicates the behavior of the underlying or ""primary"" grid, except where functions are overridden. This allows functions like `diffusive_flux_x` to be extended without touching model time-stepping code. The main motivation for this change is to make it easy to implement more sophisticated immersed boundary methods such as partial cells and shaved cells. In those methods, the presence of the immersed boundary is felt at a fundamental level during the calculation of grid areas and volumes. The `internal_tide.jl` validation experiment has also been refactored and now reads:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; using Plots. grid = RegularRectilinearGrid(size=(256, 256), x=(-10, 10), z=(0, 5), topology=(Periodic, Flat, Bounded)). # Gaussian bump of width ""1""; bump(x, y, z) = z < exp(-x^2). grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). # Tidal forcing; tidal_forcing(x, y, z, t) = 1e-4 * cos(t). model = HydrostaticFreeSurfaceModel(grid = grid_with_bump,; momentum_advection = CenteredSecondOrder(),; free_surface = ExplicitFreeSurface(gravitational_acceleration=4),; closure = IsotropicDiffusivity(ν=1e-4, κ=1e-4),; tracers = :b, ; buoyancy = BuoyancyTracer(),; coriolis = FPlane(f=sqrt(0.5)),; forcing = (u = tidal_forcing,)). # Linear stratification; set!(model, b = (x, y, z) -> 2 * z). progress(s) = @info ""Time = $(s.model.clock.time), max|w|: $(maximum(abs, model.velocities.w))""; ; simulation = Simulation(model, Δt = 1e-3, stop_time = 10, progress = progress, iteration_interval = 10) ; ; run!(simulation). xu, yu, zu = nodes(model.velocities.u); u = interior(model.velocities.u)[:, 1, :]. umax = maximum(abs, u); ulim = umax / 2 ; ulevels = vcat(-[umax], range(-ulim, stop=ulim, length=30), [u",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305:2,refactor,refactored,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305,3,"['extend', 'refactor']","['extended', 'refactored']"
Modifiability,"I remember there is a problematic issue with initialisation and bathymetry. You need to be extra careful to put initial condition that is consistent with the bathymetry. We should actually fix that because it was so counterintuitive. That’s what I was trying to understand back in the day and fix but I lost steam. I couldn’t set up very simple things, let alone global configuration.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973413973:370,config,configuration,370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973413973,1,['config'],['configuration']
Modifiability,"I say we emit a warning for now and I'll add a comment to `offset_windowed_data` that it could be extended to support windowing and offsetting for data that doesn't cover the whole grid. Here's some thoughts for the future:. - We want to compute index intersections using ""grid indices"" rather than ""parent indices"". So more lines in `offset_windowed_data` are needed; - the ""parent indices"" corresponding to particular grid indices depend on the span of the data. `parent_index_range` is only valid for ""full"" indices. Probably we should extend `parent_index_range` to take in some information about the parent data rather than assuming it spans the grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127157325:98,extend,extended,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127157325,2,['extend'],"['extend', 'extended']"
Modifiability,I see. I was describing what it should look like to the user but it sounds like the structs used will need to be refactored to accommodate this change (until PR #107 is finished and merged).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/213#issuecomment-488127779:113,refactor,refactored,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/213#issuecomment-488127779,1,['refactor'],['refactored']
Modifiability,"I share here a double drake experiment that makes full use of this PR ; #### Grid setup; - latitude longitude grid from 75 S to 75 N; - 1/3 of a degree in the horizontal (1080 points in longitude, 450 in latitude); - 150 exponentially stretched vertical levels for a 3km deep ocean; - double drake bathymetry (https://doi.org/10.1175/2009JCLI3197.1); #### Top BC: ; - temperature: restoring to reference profile (cosine shape); - salinity: prescribed latitudinally dependent surface flux; - zonal velocity: prescribed latitudinally dependent wind stress; #### Bottom BC:; - velocities: linear bottom drag with a drag coefficient of 0.003 ms⁻¹; #### Initial conditions; - zero velocities; - exponentially stratified temperature with SST equal to the reference temperature; - constant salinity; #### Model setup; - linear equation of state; - Richardson-based diffusivity for BL mixing ; - vertical background viscosity and diffusivity of 5e-4 and 3e-5, respectively; - vector invariant momentum advection with WENO for vorticity and divergence flux as well as vertical transport (no horizontal viscosity); - WENO for tracer advection (no horizontal diffusivity); - Split explicit free surface using an averaging shape function and a CFL of 0.7 (23 substeps per time step); #### Simulation setup; - time step of 10 minutes; - ran on 2 MPI processes with CUDA-aware MPI; - performs about 10 simulated years per day. On the left, there is the free surface evolution, on the right the surface vertical vorticity (evolved for 9 years). https://user-images.githubusercontent.com/33547697/219039209-e99ad100-2730-4805-bf57-c3b438f64537.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431366185:1508,evolve,evolved,1508,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431366185,1,['evolve'],['evolved']
Modifiability,"I should have addressed all the changes except the `Field{loc...}(grid)` to `Field(loc, grid)`. I will do another PR that will refactor all the instances of `Field(loc, grid)` to `Field{loc...}(grid)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1437178605:127,refactor,refactor,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1437178605,1,['refactor'],['refactor']
Modifiability,"I started tackling this issue in ClimaAtmos last week. I wrote a module, `OutputPathGenerator`, in a separate utilities package ([documentation](https://clima.github.io/ClimaUtilities.jl/dev/outputpathgenerator/)). This module defines an object, `OutputPathGenerator` that can be extended with different `OutputPathGeneratorStyle`s. ; The `OutputPathGenerator` is used in a `generate_output_path` function that takes the base output dir and the style.; The simplest of such styles is ""overwrite"". . The style that is currently being used in Atmos is `ActiveLinkStyle`. Citing from the docs:; > This style provides a more convenient and non-destructive approach. It manages a sequence of subfolders within the base directory specified by `output_path`. It also creates a symbolic link named `output_active` that points to the current active subfolder. This allows you to easily access the latest simulation results with a predictable path. > Example:; > Let's assume your output_path is set to data.; > If data doesn't exist, the module creates it and returns data/output_active. This link points to the newly created subfolder data/output_0000.; > If data exists and contains an output_active link pointing to data/output_0005, the module creates a new subfolder data/output_0006 and updates output_active to point to it.; > If data exists with or without an output_active link, the module checks for existing subfolders named data/output_XXXX (with XXXX a number). If none are found, it creates data/output_0000 and a link data/output_active pointing to it. Atmos uses `OutputPathGenerator` internally. My vision is that end users would be providing the base path and possibly choosing a `Style` if they don't want the default behavior (which is the ActiveLinkStyle). `Styles` are Julia objects and new ones can be defined in scripts by implementing a method for the function `generate_output_path`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662:280,extend,extended,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662,1,['extend'],['extended']
Modifiability,I started updating the checkpointer but didn't want to refactor too much as there's already an open PR that refactors it (#628) and it's subject to change a bit. I'll wait until it's merged before I fully update the checkpointer here.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-586966505:55,refactor,refactor,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-586966505,2,['refactor'],"['refactor', 'refactors']"
Modifiability,"I support a `Rotation` abstract type with subtypes like `FPlane`, `BetaPlane`, and `FullCoriolis` (you are referring to including the horizontal components of the rotation vector within the tangent plane approximation?). Do you think that we should not have the concept of a molecular transport coefficient at all? I feel we should have something like `MolecularTransportCoefficients` for things like molecular viscosity and different molecular diffusivities for each tracer (so that we support the most basic and easiest simulation case: DNS). `TurbulenceClosure` can handle all the cases in which the transport coefficients are non-molecular, as in the case of a constant anisotropic viscosity. My comment about the reference density was actually my attempt to channel @jm-c and I think I mangled it. The point is that density is not a variable in a Boussinesq code and the value of the reference density has no effect on the dynamics. Buoyancy is the Boussinesq variable. It gets confusing when you add nonlinear equations of state, because you will still need to store a reference density somewhere in order to calculate boundary fluxes of temperature and velocity associated with, for example, heat fluxes and momentum fluxes. For that reason it makes sense to divorce the reference density from the equation of state and consider it separately. As long as you have a Boussinesq code you will not need to calculate density. You'll get to this point in a hurry if you try to implement nonlinear equations of state for your Europa simulation. Maybe @jm-c can weigh in so we can get these thoughts from the source.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491666948:838,variab,variable,838,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491666948,2,['variab'],['variable']
Modifiability,I think I'm happy with the finite volume operators in this PR. Happy to make changes based on feedback so we have versatile and flexible operators. In the next PR I will fully integrate them with the code and make sure they are correct and performant. It will also show if I missed any operators.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-546648773:128,flexible,flexible,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-546648773,1,['flexible'],['flexible']
Modifiability,"I think all the closures we have contain diffusivity data (constants or functions or fields) that are not in `diffusivities`. The list is here:. https://github.com/CliMA/Oceananigans.jl/tree/master/src/TurbulenceClosures/turbulence_closure_implementations. Only a subset of the code is documented, so better to look to the source when considering refactoring I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883733159:347,refactor,refactoring,347,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883733159,1,['refactor'],['refactoring']
Modifiability,"I think broadcasting for same-field operators, e.g. `CellField .+ CellField` would be really useful and make the code more readable. The simplification here is fewer loops to look at which is a big plus I think. But cross-field broadcasting is a bit trickier so might be better to leave it unimplemented especially as it's not a very common operation, I only use it when adding `f .* v` to `Gu` or `f .* u` to `Gv`. Without it you would have to explicitly write `u .+ avgx(avgy(v))` so if you forget it then it might make finding the bug a bit harder. With it, you can just write `u .+ v` with the averaging happening behind the scenes, so you might apply it by mistake without realizing it. Another potentially difficult bug to find. I feel like everyone has a different opinion on this but in my mind, I'm thinking this would make the code easier to read and write (short-term), and ultimately easier to extend by users (long-term). I just sometimes use issues leave random TODO notes and ramble.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/12#issuecomment-445494799:906,extend,extend,906,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/12#issuecomment-445494799,1,['extend'],['extend']
Modifiability,I think extending `κᶠᶜᶜ` is simpler --- less code and less memory usage.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419777537:8,extend,extending,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419777537,1,['extend'],['extending']
Modifiability,"I think for idealized stuff the hydrostatic model is fairly well tested, but if one wants to do complex domains, problems requiring mixing parameterizations, etc, then our capability is still a little green I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107528576:139,parameteriz,parameterizations,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107528576,1,['parameteriz'],['parameterizations']
Modifiability,I think here `return` and `return nothing` would have the same effect (probably also just avoiding the whole `return` statement but that will print the variable to screen if used in the REPL). . ```; julia> function test!(a); a[1] +=1; return; end; test! (generic function with 1 method). julia> function test_two!(a); a[1] +=1; return nothing; end; test_two! (generic function with 1 method). julia> a = [1]; 1-element Vector{Int64}:; 1. julia> test!(a). julia> a; 1-element Vector{Int64}:; 2. julia> test_two!(a). julia> a; 1-element Vector{Int64}:; 3. julia> function test_three!(a); a[1] +=1; end; test_three! (generic function with 1 method). julia> test_three!(a); 4. julia> a; 1-element Vector{Int64}:; 4; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005242652:152,variab,variable,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005242652,1,['variab'],['variable']
Modifiability,I think it must be blocked by some dependency since CompatHelper updates the Manifest. I guess merging #1295 caused some conflicts so I might try bumping to Adapt v3.0.0 in a different PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881:157,Adapt,Adapt,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881,1,['Adapt'],['Adapt']
Modifiability,"I think it only depends on the combination of Boundary conditions you give to the GPU. Anyways, it's a weird error, I don't seem to be able to reproduce it; ```; ssilvest@tartarus:~/stable_oceananigans/Oceananigans.jl$ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.0 (2022-08-17); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans, Statistics, Printf, Oceananigans.Units; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided. julia> grid = RectilinearGrid(GPU(), size=(1024, 1024), extent=(2π, 2π),; topology=(Bounded, Bounded, Flat)); 1024×1024×1 RectilinearGrid{Float64, Bounded, Bounded, Flat} on GPU with 3×3×0 halo; ├── Bounded x ∈ [4.64839e-19, 6.28319] regularly spaced with Δx=0.00613592; ├── Bounded y ∈ [4.64839e-19, 6.28319] regularly spaced with Δy=0.00613592; └── Flat z. julia> # forcing; u_forcing(x, y, z, t) = 0.01*cos(5*y); u_forcing (generic function with 1 method). julia> v_forcing(x, y, z, t) = -0.01*cos(5*x); v_forcing (generic function with 1 method). julia> # no-slip boundary conditions; u_bcs = FieldBoundaryConditions(south = ValueBoundaryCondition(0.0),; north = ValueBoundaryCondition(0.0));. julia> v_bcs = FieldBoundaryConditions(east = ValueBoundaryCondition(0.0),; west = ValueBoundaryCondition(0.0));. julia> model = NonhydrostaticModel(timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; boundary_conditions = (u=u_bcs, v=v_bcs),; forcing = (u=u_forcing, v=v_forcing),; buoyancy = nothing,; tracers = nothing,; closure = ScalarDiffusivity(ν=1e-5)); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 102",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873:623,variab,variable,623,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873,4,"['Config', 'config', 'variab']","['Config', 'config', 'variable']"
Modifiability,"I think it's a clue that . ```julia; vz_op = @at((Face, Center, Center), ∂x(b) / f); ```. is valid. My guess now is that if. ```julia; vz_op = @at (Face, Center, Center) - ∂x(b) / f; ```. is interpreted as. ```julia; loc = (Face, Center, Center); op = ∂x(b) / f; invalid_subtraction = -(loc, op) # not only does this not work, it's also just one `Expr`; vz_op = @at invalid_subtraction; ```. We can try to bandaid this by extending `@at` but I guess it's really just invalid syntax. `@at((Face, Center, Center), ∂x(b) / f)` is the right way to express this --- nice find @iuryt !",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1099101478:422,extend,extending,422,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1099101478,1,['extend'],['extending']
Modifiability,"I think it's ok that ""rigid lid"" is implicit. In fact all the sides are rigid and there's no special direction at all. In fact, it might make sense to omit ""free surface"" from the hydrostatic model description. We could soon have a rigid lid option there, and then it wouldn't really make sense to continue calling it a ""HydrostaticFreeSurfaceModel"". There's a few things I think should go in before 1.0:. * Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`. Building an abstraction for vectors changes the API because we'll specify boundary conditions on the whole velocity field, not just each component separately. I don't think we should do 1.0 without this.; * Resolve #1825 (specifying `architecture` when building `grid`). Another major API change, not to mention a substantial internal refactor.; * Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere). Another API change because we don't need `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Also simplifies the code a lot. It could also make sense to build some experience with immersed boundaries in case there are change motivated by that feature.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882075634:891,refactor,refactor,891,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882075634,1,['refactor'],['refactor']
Modifiability,"I think so, the issue #3342 applies also to multi-region, so I think in a next PR we can extend this halo splitting to multi region boundary conditions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1764795630:89,extend,extend,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1764795630,1,['extend'],['extend']
Modifiability,I think some stuff in `broadcast_abstract_field.jl` may need to be extended:. https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/src/Fields/broadcasting_abstract_fields.jl. specifically. https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/src/Fields/broadcasting_abstract_fields.jl#L18. which helps us identify when we're broadcasting between arrays and fields so that we hit . https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/src/Fields/broadcasting_abstract_fields.jl#L42. https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/src/Fields/broadcasting_abstract_fields.jl#L46. Also. https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/src/Fields/broadcasting_abstract_fields.jl#L24-L28. where we take a shortcut for things like `u .= a` where `u isa Field` and a is some kind of array.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2540#issuecomment-1121030783:67,extend,extended,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2540#issuecomment-1121030783,1,['extend'],['extended']
Modifiability,"I think something that we haven't fully grasped in the past (and I am largely to blame) is how to properly display information to users in the REPL and log files (eg by extending existing methods so the interface for displaying `Oceanangians` types is the same as other julia types). There are a few functions available:. * `show`; * `print` (seems similar to `show`, except used where fancy formatting such as colors, etc may not be appropriate or available); * `summary`. We also want even more minimal representations than those produced by `summary`, like `string(typeof(obj).name.wrapper)`. There may also be a julia function for this, but I didn't find one after a cursory search. We have (unfortunately) introduced what appears to be a needless alternative to `summary` in the source code; we call this `short_show`. So we already have sizeable technical debt... I think it's helpful to follow convention as much as possible, especially if this package is used by other packages (eg it will be embedded in a climate model at some point in the future, which will be a separate package...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360:169,extend,extending,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360,1,['extend'],['extending']
Modifiability,"I think that's a decent idea and also might help de-complexify some of the code associated with buoyancy models. We would have to refactor our equations of state a bit but that's not hard. The main question is what to do about `gravitational_acceleration`. Right now, `gravitational_acceleration` is a parameter of `SeawaterBuoyancy`:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/BuoyancyModels/seawater_buoyancy.jl#L10-L15. because if you're using `BuoyancyTracer()`, there's no gravitational acceleration parameter (since its absorbed into the definition of buoyancy). However, we could move `gravitational_acceleration` into `Buoyancy`, and then set it to `nothing` when we are using `BuoyancyTracer`. The downside of this approach is that people can then change this parameter when using `BuoyancyTracer`, even though such changes would have no dynamical effect on the model (we've tried to limit such possibility for confusion otherwise...). It could be reasonable to move `constant_temperature` and `constant_salinity` into `equation_of_state`. `SeawaterBuoyancy` is then a type union of buoyancies with either `LinearEquationOfState` or something else from `SeawaterPolynomials.jl`. PS the default values for coefficients here:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/BuoyancyModels/linear_equation_of_state.jl#L25. should probably be 0?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-951090677:130,refactor,refactor,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-951090677,1,['refactor'],['refactor']
Modifiability,"I think the flux boundary condition implementation is correct: ; we ensure zero first and second order derivative across the boundary by mirroring the field, then we just add the flux later as a forcing. . The problem is in the `Open` boundary conditions. These just substitute the value at the interface without modifying halo nodes. This will not ensure a zero second order derivative on the face.; we have to extend the boundary condition to the halos to ensure 0 laplacian on the boundary. Two way that this can be done is either mirroring or linearly extrapolating. This will have an impact later if we support ""true"" open boundary conditions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1040632132:412,extend,extend,412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1040632132,1,['extend'],['extend']
Modifiability,"I think the main reason to use total height is that it generalizes to a ""stacked"" shallow water model (where there are N layers rather than just 1). But perhaps the choice depends on whether shallow water model is valuable mostly as a stand-alone model for physics problems or whether it's intent is more as a testbed for develping numerical methods, etc (with perhaps the eventual possibility of generalizing to N layers).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1115156776:121,layers,layers,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1115156776,2,['layers'],['layers']
Modifiability,"I think the next step is a fully-fledged implementation that supports `Flux` boundary conditions (and possibly others). We are almost there with the latest `TurbulenceClosures` refactor. If `correct_immersed_tendencies!` is copy/pasted for tracers then all tracers will be set to zero inside a boundary; this might not be exactly what users want. I think we also sometimes want free-slip rather than no-slip boundary conditions on momentum. The algorithm I am thinking of would have the following components:. 1. Implement a ""mask"" that replaces `correct_immersed_tendencies!` that forcibly overwrites immersed regions to specified values in `update_state!` (this is effectively what `correct_immersed_tendencies!` does now); 2. Extend `calculate_boundary_tendency_terms!` to adjust tendencies in cells adjacent to immersed boundaries. This involves a) subtracting out the ""spurious"" component associated with a diffusive flux across an immersed boundary and b) adding in the ""true"" boundary flux that's either specified by the user, or implied by a `Value` / `Gradient` boundary condition.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1548#issuecomment-813819493:177,refactor,refactor,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1548#issuecomment-813819493,2,"['Extend', 'refactor']","['Extend', 'refactor']"
Modifiability,"I think there are already a couple of challenges for this pull request:; 1. Implementing user-defined forcing functions without losing performance.; 2. Getting the user-defined forcing functions to work on the GPU without losing performance either. As #59 will result in a ton of refactoring, I think it might be more appropriate to address it in a different branch after #73 is resolved, so that everything (`Forcing` is already `isbitstype` but no other code depends on it) can be converted into `isbitstype`. If doing so results in large performance drops (which I think might have happened here) then it might take a while to figure out #59.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/85#issuecomment-467654884:280,refactor,refactoring,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/85#issuecomment-467654884,1,['refactor'],['refactoring']
Modifiability,"I think there's still a use for `KernelComputedField`! It's more expensive to construct a calculation by nesting `ComputedField`s inside it. The difference is in the number of kernel launches: when expressing a calculation with a single kernel, the computation is computed with a single loop over all grid points. When expressing a calculation using intermediate `ComputedField`, then first we launch kernels to calculate the intermediate `ComputedField`s, and launch a final kernel to compute the quantity of interest. It can also be more memory intensive since the intermediate `ComputedField`s need to be stored. For some applications, the ""optimization"" of avoiding intermediate kernel launches / calculations may be unimportant (for example, if plenty of memory is available and computations are made very rarely). I think nesting `ComputedField`s is a nice solution that avoids having to hand-write kernels for those cases. But sometimes I do think that users want to optimize diagnostics calculations. There are also some other nice applications of `KernelComputedField`; for example I think it would be nice to make the LES eddy diffusivities into `KernelComputedField` (which are computed every tendency evaluation so performance is crucial), and perhaps some other auxiliary variables. I think it would be fun to try the compiler hack-around that I suggested in my comment above (defining multiple `identity` functions and using an internal counter to scroll through them during compilation). It's just a matter of finding the time to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600:1285,variab,variables,1285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600,1,['variab'],['variables']
Modifiability,"I think this PR is finally ready. Thanks to @simone-silvestri for the help!. Here a simple simulation (roughly adapted from the [ocean wind mixing example](https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/)) using stretched grids in the x, y, and z directions respectively:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/fba0fa71-92b0-4f7b-978e-7bb24f7060fb. https://github.com/CliMA/Oceananigans.jl/assets/13205162/dea0309f-3b2f-499a-81b2-f5de819dc992. https://github.com/CliMA/Oceananigans.jl/assets/13205162/17e2c3e1-71be-4d9a-9bbe-378bbb657150",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3111#issuecomment-1597796977:111,adapt,adapted,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3111#issuecomment-1597796977,1,['adapt'],['adapted']
Modifiability,"I think this is a a big step forward and happy to share my two cents worth. I agree that we should keep `gravitational_acceleration` the same as before. We will need to have a bunch of `g'`. Since we have a free surface, we assume that we have air above, then `g'` of the top layer is really just `g`. That's why I would suggest having n reduced gravities for n layers. We will need n interfaces and we could also store the n heights. Sometimes it's convenient to have one or the other. For efficiency we only need one, but for convenience we might want to have both. What are people's preferences?. The more layers we have, the thinner each layer tends to be. This means that it's more likely that layer depths can vanish. If this ever happens, then a numerical instability can happen. I remember discussing with @simone-silvestri using the positive preserving property of WENO to deal with this but I also remember that a preliminary test showed that it wasn't actually ensure to be positive. Sadly, I didn't follow up. Any idea if that was fixed?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1481952717:362,layers,layers,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1481952717,2,['layers'],['layers']
Modifiability,"I think we can impose a little more structure that eases biogeochemical model development. One route is to build out a layer on top of `AbstractBiogeochemistry` for models with a common form, something like. ```julia; struct TracerBasedBiogeochemistry; biogeochemical_tracers; drift_advection_schemes; drift_velocities; transitions; auxiliary_fields; end; ```. and perhaps more properties. This is similar to how `SeawaterBuoyancy` works, in that it provides a concrete structure with a slot `equation_of_state` whereby ""external"" packages like `SeawaterPolynomials` can insert custom behavior. Another possibility is to build out a new abstract type below `AbstractBiogeochemistry` with a function-based interface (somehow). I was also thinking it would be nice to supply a ""continuous form"" interface, so that model developers can implement functions that look something like. ```julia; biogeochemical_transition(x, y, z, t, N, P, Z, D, parameters); ```. rather than having to use the ""discrete form"". This sort of structure could also be provided by an external package. The advantage of including it here is that we get tighter coupling with Oceananigans development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310908285:1132,coupling,coupling,1132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310908285,1,['coupling'],['coupling']
Modifiability,I think we decided we would merge this in its current form and add tests for different topologies and Helmholtz equations in a future PR. In future PR(s) we should also refactor the interface to be more consistent with the other solvers and to use CuArrays in the solver itself. I think we don't intend to use the `PreconditionedConjugateGradientSolver` with `IncompressibleModel` so I removed it from the constructor. I presume a PCG solver will be created in the hydrostatic model constructor. Although a good regression test would be to run an `IncompressibleModel` with a PCG pressure solver and make sure it matches the regression data.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781637359:169,refactor,refactor,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781637359,1,['refactor'],['refactor']
Modifiability,"I think we should delete the regression test and put a warning in the model constructor ""The ShallowWaterModel has not been validated"". It's a shame we've put so much time into the regression test as it is. I think the model likely has a few bugs to be ironed out. I'm also not convinced that we have all the numerical methods (ie vanishing layers, positive preserving advection) that would be needed to advertise the model as ""production-ready""). One could argue that the regression test is misleading in that it gives the false impression that the model is in a state that shouldn't change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3049#issuecomment-1496736100:341,layers,layers,341,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3049#issuecomment-1496736100,1,['layers'],['layers']
Modifiability,"I think we should do 1. and 2., keeping them separate. On Wed, Mar 17, 2021, 8:53 PM Ali Ramadhan ***@***.***> wrote:. > Some time ago @sandreza <https://github.com/sandreza> and @xiaozhour; > <https://github.com/xiaozhour> suggested it would be useful to add the; > GM-Redi parameterization to Oceananigans.jl since we may want to train; > mesoscale eddy parameterizations.; >; > I'm opening this issue to discuss on what exactly needs to be implemented.; > My main reference is; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html; >; > It seems that there are three different new closures that could; > potentially be added:; >; > 1. Redi (symmetric) tensor diffusivity.; > 2. Gent-McWilliams (anti-symmetric) tensor diffusivity.; > 3. GM-Redi combining the two.; >; > Note: @glwagner <https://github.com/glwagner> has already implemented; > parts of the Redi tensor and GM for TwoDimensionalLeith so GM-Redi might; > not need too much extra work:; > https://github.com/CliMA/Oceananigans.jl/blob/master/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl; > Questions/proposal; >; > 1. Do we make the small-angle approximation? I would say yes.; >; > In Oceananigans.jl right now each component of the tensor diffusivity is; > calculated on-the-fly so the unapproximated tensor could end up being 2-4x; > more expensive to compute. We cannot compute the full tensor in one go; > (reusing the isopycnal slopes) and we may not want to since it takes up a; > lot of memory (9 extra field?). But maybe there's a good reason to not make; > the small-angle approximation? We could eventually support both; > (unapproximated and small-angle approximation).; >; > See; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#redi-scheme-isopycnal-diffusion; > for a comparison of the two.; >; > 1. Is GM-Redi the main parameterization of interest? Would people use; > the fully symmetric or the fully anti-symmetric diffusivity tensor by; > themsel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587:275,parameteriz,parameterization,275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587,2,['parameteriz'],"['parameterization', 'parameterizations']"
Modifiability,"I think we should have ""tutorials"" in addition to examples! Examples are for ""quickstarting"" -- download the code and run *something*. Tutorials are extended examples with documentation, plots, etc. What do you think about that?. Ultimately when the code is more stable I could see the utility of having more than just 2-3 examples, though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/221#issuecomment-495594400:149,extend,extended,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/221#issuecomment-495594400,1,['extend'],['extended']
Modifiability,"I think we should make it a rule that we don't write about experimental and transient features in the docs. I propose that instead we use Discussions and Issues for that. I prefer we make the docs ""slow moving"" and carefully curated --- like a textbook --- while using GitHub discussions to encapsulate ""living"", transient, and often more fine-grained knowledge about usage, experimental / rapidly changing features, and generally things that might require extended discussion and benefit from clarification questions. In part this means mostly avoiding tagging issues and pull requests in the documentation. The motivation for this approach has a few parts. First is to clarify ""what belongs in the docs"" versus what kinds of things will be documented elsewhere on the vast internet, so that people know where to look to get the answers they need. The second reason is to help control the development of docs by the community. As the code grows, the docs will have to necessarily grow to become very long. The docs are much shorter than they should be right now because the hydrostatic model in particular is still somewhat ""experimental"" (it's a multi-year effort to develop a fully functional GCM, and we are in the thick of it now). There will be so much more in the docs in the end --- a dozen or more parameterizations for ocean turbulence, sea ice, biogeochemistry, and on and on. As a result, it's going to become very important that the docs are as concise as possible (eg, the same constraint we face when writing a textbook). Thus in this process we'll have to carefully curate whatever goes into the docs as a community, and I think it will be helpful if the docs are only used for ""big"" things. A third reason is just that I think this is will reduce the effort required to maintain docs. For example, this change to the docs will become incorrect when we merge the multi-region PR (which hopefully will be soon). That means that we need to update the docs when we merge that PR. Maybe we",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498:457,extend,extended,457,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498,1,['extend'],['extended']
Modifiability,"I think we should put this into the sandbox rather than the main code, as its not very general and thus only useful for a (relatively) narrow class of problems.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/291#issuecomment-505398771:36,sandbox,sandbox,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/291#issuecomment-505398771,1,['sandbox'],['sandbox']
Modifiability,"I think we want `h` to be the layer thickness, so that these ideas generalize to ""n"" layers. Then the ""surface height"" is `H(x, y, t) = h(x, y, t) + b(x, y, t)`, where `b` is the height of the bathymetry. `eta` is defined relative to some reference height, eg `eta(x, y, t) = H(x, y, t) - H0`. I think with this definition, `b` comes into the pressure gradient but not momentum.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128972918:85,layers,layers,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128972918,1,['layers'],['layers']
Modifiability,I think we want to do this over a few PRs. The first task is to extend BatchedTridiagonalSolver,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3111#issuecomment-1557433725:64,extend,extend,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3111#issuecomment-1557433725,1,['extend'],['extend']
Modifiability,"I think we're ready to merge this once we hammer out the details. Still TODO will be:. - refactoring the model setup pages to be more tutorial-like; - finishing the tutorials on reductions, simulations, and field time series / post-processing. @navidcy @simone-silvestri @rafferrari",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2274344831:89,refactor,refactoring,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2274344831,1,['refactor'],['refactoring']
Modifiability,"I think what we want in terms of API is the ability to specify boundary conditions on the surface of an immersed boundary. One design would be to introduce a type called `ImmersedBoundary` that collects information about the location of the boundary and the boundary conditions for each field prescribed on it. This could be relatively simple to implement in the code, though it doesn't exactly conform to our current code design in which boundary conditions are embedded in `Field` objects. Another possibility that may better conform to our current boundary conditions / field design would be to embed `boundaries` in `grid` objects. With this design, `ImmersedBoundary` collects only information about its geometry and parameters related to its numerical implementation (eg regularization functions, interpolation methods, etc). We can then infer from `grid` the information needed to define boundary conditions for fields in both (`x` ,`y`, `z`), as well as on any `ImmersedBoundary`s. Grid constructors would then be something like. ```julia; grid = RegularCartesianGrid(; immersed_boundaries = ImmersedBoundary(geometry = # a function of (x, y, z, t); transfer_function = # parameters ; ); topology = # etc; ); ```; ; As for verification, I think we should use a quantitative test that verifies that boundary conditions are satisfied on the immersed boundary. Reproducing the Reynolds number correction to the drag coefficient on a sphere might be a good one, though it could be challenging because we'd have to use sponge layers to replicate an open boundary. We could also reproduce driven-cavity results in a triply periodic domain using rectangular immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/693#issuecomment-597087759:1529,layers,layers,1529,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/693#issuecomment-597087759,1,['layers'],['layers']
Modifiability,"I think what you have discovered is that simulations with `BackgroundField` can behave differently on the GPU than on the CPU for some reason. What do you mean when you say the `BackgroundField` is not consistent with the boundary condition? The boundary condition is applied only to the prognostic variable (the deviation) only. Indeed, one of the most important applications of `BackgroundField` is to run simulations in which the deviations are _periodic_ even though the `BackgroundField` is not. The Eady turbulence problem is an example of one such problem. In that case the background velocity and buoyancy fields are not periodic in the y-direction; but because they only vary _linearly_, deviations from that background state _can_ be idealized as periodic. There may indeed be some issue regarding `BackgroundField` and `Bounded` directions, but I believe this is a bug and not expected. Certainly there is a bug if different results occur on the CPU versus the GPU. Hopefully we can get to the bottom of it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815420587:299,variab,variable,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815420587,1,['variab'],['variable']
Modifiability,"I think with PR #643 we finally have a flexible enough NetCDF output writer based on NCDatasets.jl and can finally close this issue: it's fast and allows for arbitrary output (fields, scalars, profiles, slices, etc.) so we can output all our diagnostics to NetCDF. Thanks @suyashbire1 for working on this!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-595393359:39,flexible,flexible,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-595393359,1,['flexible'],['flexible']
Modifiability,"I think you instantiate a model to do many things; one of them is time-stepping, but another may be analysis. Another is testing. Even now we can't actually solve poisson's equation without a `Model` easily, which seems like an unnecessary restriction of our non-modularity. I don't think we should make this problem worse. I think it makes sense `model` is a field of `Simulation`. Its simple to envision `Simulation` parameters that are identical, with a different underlying `model` (eg, changing the number of passive tracers)`. The way I envision a logical course for the development of complex software in general is that we start with the fundamental building blocks and make them as easy to use in their low-level form as possible. When we've decided we can proceed no farther, we add another layer of abstraction that fuses these underlying building blocks into a higher-order coherent object. And so on. I think its a better design strategy to add *layers* of abstraction, rather than *embedding* abstraction within already complex objects. The latter strategy would lead to unmanageable complexity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542267410:959,layers,layers,959,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542267410,1,['layers'],['layers']
Modifiability,"I think η★ U★, and V★ (the intermediate variables at time step m+½ I think) are currently computed on-the-fly (mostly needed for AB3), which makes sense why imposing the topology and boundary conditions had to be baked into the operators. https://github.com/CliMA/Oceananigans.jl/blob/13bf409616af8c155b72d8869b7b8f97ae0e844b/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl#L105-L120",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2397688960:40,variab,variables,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2397688960,1,['variab'],['variables']
Modifiability,"I thought I would also try freezing the velocity field, if possible. If this still weirdness at the boundary still happens when the velocity doesn't evolve, then it has nothing to do with the pressure solve. Could someone point me to an example that does this?; ________________________________; From: Francis Poulin ***@***.***>; Sent: Wednesday, April 7, 2021 7:43:11 PM; To: CliMA/Oceananigans.jl ***@***.***>; CliMA/Oceananigans.jl ***@***.***>; Cc: Mention ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] strange results on gpus (#1554). Very good point. The background buoyancy does not satisfy the boundary conditions that are imposed. I will check it out later. If this is the case, then it is still mysterious why GPUs have a harder time with this than CPUs, but we will see and learn. Thanks for the suggestion. Francis; ________________________________; From: Gregory L. Wagner ***@***.***>; Sent: Wednesday, April 7, 2021 5:44:23 PM; To: CliMA/Oceananigans.jl ***@***.***>; Cc: Francis Poulin ***@***.***>; Mention ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] strange results on gpus (#1554). The second time-step is when QuasiAdamsBashforth2 uses tendency information saved from the previous time-step. On the first time-step it's equivalent to a forward Euler scheme. I know the differences are small, 8th decimal place or so, but on such a coarse grid should we be expecting the same answers?. Hardware differences can produce results that differ by something like sqrt(eps(Float64)) I think. This is the tolerance we use for regression tests (but even those sometimes fail to pass on the GPU for some reason). Since the background buoyancy field has a linear gradient and your domain is bounded, can you try running the same simulation but explicitly resolving the background buoyancy field? (This could suggest that the issue has to do with BackgroundField...). -; You are receiving this because you were mentioned.; Reply to this email directly, view it on GitHub<https://gi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815368840:149,evolve,evolve,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815368840,1,['evolve'],['evolve']
Modifiability,"I thought of defining `cell_viscous_timescale` and `cell_tracer_diffusion_timescale` so that `cell_diffusion_timescale` just returns; ```julia; min(cell_viscous_timescale, cell_tracer_diffusion_timescale); ```; but then `cell_tracer_diffusion_timescale` would have to return `Inf` instead of `nothing` and it seemed a bit messy with lots of one-liner functions and duplicated dispatch signatures so I just refactored `cell_diffusion_timescale` to just dispatch on whether `closure.κ` is an empty named tuple or not. I added tests to make sure `cell_diffusion_timescale` will work for all closures when `buoyancy=nothing, tracers=nothing`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/691#issuecomment-597571689:406,refactor,refactored,406,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/691#issuecomment-597571689,1,['refactor'],['refactored']
Modifiability,"I understand there's no difference, but I think it's bad practice to rely on another package for such a fundamental data type that will be a parameter of the core `Model` struct. We're talking about a _few_ lines of ""clutter"", which it isn't as it's fundamental to what the model does. What if GPUifyLoops.jl gets deprecated in favor of another package? Or what if the types change later? What if it's abandoned in a year? We're not in control. Even a small change in how GPUifyLoops.jl defines the types will force us do a ton of refactoring.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/133#issuecomment-473693173:531,refactor,refactoring,531,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/133#issuecomment-473693173,1,['refactor'],['refactoring']
Modifiability,"I want to merge this then use it to develop the user API for immersed boundary fluxes. Also, did anyone use this?. Partly I am wondering whether we may actually need shaved cells for accurate LES computations in complex domains with non-straight immersed boundaries) ... otherwise our boundaries will always have ""effective roughness"", and form drag may dominate. It is actually possible that form drag dominance is ok as a model for rough boundaries. But it'd be nice to have the possibility of ""smooth"" boundaries where fluxes can be controlled via parameterizations. It's also interesting that PALM, which uses an almost identical numerical method that we use, is primarily used for atmospheric LES in urban environments. So their boundaries _are mostly flat_ (the sides of buildings, etc...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100228717:551,parameteriz,parameterizations,551,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100228717,1,['parameteriz'],['parameterizations']
Modifiability,I wanted to add tests but the current test functionality is difficult to adjust to work for 2D arrays. . https://github.com/CliMA/Oceananigans.jl/blob/39e9b6f3e5c5f43845f21f8e10fdd629ced448fc/test/test_multi_region_cubed_sphere.jl#L9-L62. I'd like to rewrite those to use the connectivity property of the `ConformalCubedSphereGrid` rather than a series of if statements. Also address ##3242. But I wasn't planning to do this on this PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3256#issuecomment-1712759761:251,rewrite,rewrite,251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3256#issuecomment-1712759761,1,['rewrite'],['rewrite']
Modifiability,"I was thinking even simpler:. ```julia; F(i, j, k, grid, clock, state); ```. Any 'parameters' that are needed for forcing functions can be introduced by defining a callable object that carries around its parameters. We can introduce something simple like `ParameterizedForcing` for users, too, perhaps. (Now that I think of it, we should probably separate `SimpleForcing` (forcing functions of `x,y,z,t` with no parameters) from `SimpleParameterizedForcing` (simple forcing functions with parameters) too...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595931041:256,Parameteriz,ParameterizedForcing,256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595931041,1,['Parameteriz'],['ParameterizedForcing']
Modifiability,"I was thinking of doing some prototyping and benchmarking in a sandbox by building off the example in my PR https://github.com/vchuravy/GPUifyLoops.jl/pull/18. The PR contains an example that can be extended to rely on a `Grid` struct, multiple `FaceField`s and ` CellField`. So I'll prototype grids and fields that are `isbitstype` (you already helped by doing this for a grid in https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-467660181) and test to see if they work on the GPU with GPUifyLoops.jl. If they do work and performance isn't degraded then I'll rewrite the operators to use grid and field structs. You probably know how to do this better than me, but might be good if I rewrite the operators as they's still undocumented and do some _slightly convoluted_ stuff to avoid having to store intermediate calculations. Right now I'm focusing on system tests and benchmarks but once @christophernhill @jm-c and I get closer to implementing the variable _Δz_ grid #47 I will work on this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/115#issuecomment-470782067:63,sandbox,sandbox,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/115#issuecomment-470782067,5,"['extend', 'rewrite', 'sandbox', 'variab']","['extended', 'rewrite', 'sandbox', 'variable']"
Modifiability,I will move `MultiDimensionalScheme` and the advection refactor to two different PR,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1175058807:55,refactor,refactor,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1175058807,1,['refactor'],['refactor']
Modifiability,"I wonder if something like `Tracer`, `Velocity` rather than `Cell`, `Face` or `Center`, `Face` would be even better. . The reason is that the formulation really staggers 4 finite volume grids --- one for tracers, pressure, and mass, and 3 others for the 3 momentum variables. So cell-averages of all the quantities are located at ""cell centers"" of their respective grids. Sadly that'd be a deeper change, since I think we would need to use something like `xU`, `yV` and `zW` rather than `xF`, etc. Changing `Cell` to `Center` is just a lot of copy/paste. It's not intrinsically difficult. This issue should probably be resolved before a 1.0 (#1234)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/414#issuecomment-756154714:265,variab,variables,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/414#issuecomment-756154714,1,['variab'],['variables']
Modifiability,"I would also add a check that the fields are ""full"" fields, aka no `Windowed` fields (with particular indices different from the one we use to launch the kernel) and no `Reduced` fields with lower than 3 dimensions. We want to separate out those fields and treat them differently. ; We have an implementation like that for `fill_halo_regions!` here; https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Fields/field_tuples.jl#L54-L78. What I would probably do actually, instead of a new struct is to extend `compute!` for tuple fields as we do for `fill_halo_regions!` and use your newly implemented kernels for tuples of full fields. On the other hand, if defining a new type is useful for OutputWriters I am ok with it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694057688:538,extend,extend,538,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694057688,1,['extend'],['extend']
Modifiability,I would like to suggest the following checklist moving forward. - [ ] Decide whether we like the structure of the script `new_rates_of_convergence.jl`. How can we might improve it?; - [ ] Find where the bottleneck is in Oceanangans to make things globally single precision.; - [ ] Adapt this approach to the other validation cases that currently exist.; - [ ] Make `UpwindFirstOrderBiased()` advection scheme.; - [ ] Make `CenteredSixthOrder()` advection scheme.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313:281,Adapt,Adapt,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313,1,['Adapt'],['Adapt']
Modifiability,"I would not incorporate those modifications but rather try to understand why that happens. The only difference there is the use of `getregion` instead of indexing with `[region]`. But `getregion` is intended to be basically just an indexing for the variables you have there, so it means that there is a problem with `getregion`, maybe a missing `@inline` somewhere?. In the end, with apply_regionally what happens under the hood is just this:. ```julia; for (r, dev) in enumerate(devs); switch_device!(dev); regional_func!((getregion(arg, r) for arg in args)...; (getregion(kwarg, r) for kwarg in kwargs)...); end; ```; In this case `regional_func!` is the launch! function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3547#issuecomment-2100622115:249,variab,variables,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3547#issuecomment-2100622115,1,['variab'],['variables']
Modifiability,I'd like to eliminate `Δx` from the code because this grid metric is only valid on regular horizontal grids. This is why I did not extend `Δx` for `ImmersedBoundaryGrid` when I extended all of the other grid metrics here:. https://github.com/CliMA/Oceananigans.jl/blob/master/src/ImmersedBoundaries/immersed_grid_metrics.jl. I was hoping that not including rogue metrics like `Δx` would facilitate in excising them from the code base. Where in `ShallowWaterModel` to you use `Δx`? I think in the stack trace for the error you received you should be able to locate where the problematic `Δx` is called.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-845306836:131,extend,extend,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-845306836,2,['extend'],"['extend', 'extended']"
Modifiability,"I'd like to resurrect this issue. We've implemented 5, but we don't have callbacks. I think we should just add a callback layer to `Simulation` to replace `simulation.progress` and address whether diagnostics should become callbacks later. The key change is that `iteration_interval` would no longer be an argument to `Simulation`. Instead we would refactor all the examples and validation tests to implement logging and adaptive time stepping via callbacks. Because of that this ends up being a big API change. A barebones callback feature might be. ```julia; struct Callback{F, S}; func :: F; schedule :: S; end; ```. Usage would be something like. ```julia; progress(sim) = println(""Iteration $(sim.model.clock.iteration)""); progress_printer = Callback(progress, schedule = IterationInterval(100)). wizard = TimeStepWizard(cfl=0.1, initial_dt = 2minutes, schedule = IterationInterval(10)). simulation = Simulation(model, stop_time=2hours, callbacks = [progress_printer, wizard]); ```. In other words, the `TimeStepWizard` becomes a callback with a schedule, and we can print progress and adapt the time step on different schedules. What do people think about this API?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1138#issuecomment-881904721:349,refactor,refactor,349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138#issuecomment-881904721,3,"['adapt', 'refactor']","['adapt', 'adaptive', 'refactor']"
Modifiability,"I'll work on this until we're happy with the interace but will leave restoring massive models (that fill up memory) properly for another PR. . > I’m happy with output_writers.jl; I think all the code in that file is appropriately related. I still find it a little messy and hard to navigate. Maybe a good solution for now would be to reorganize the file into sections, and shared functions can be moved to the top. > I am particularly concerned about the maintainability of the checkpointer, since it will need to be updated every time a new feature is added. Let’s make sure the design is easy to maintain before merging. Eventually the `Model` struct will become stable but until then we'll have to modify the checkpointer to account for that. But yeah, having something flexible and easy to modify is important. > add a field (perhaps `checkpointed_fields`) to the `Checkpointer` that allows the user to control which subfields of `model` are checkpointed. Might make more sense. In general, the checkpointer should be flexible but you'd probably only need to change what's checkpointed for esoteric cases. E.g. if you remove something important, you'll",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-518240132:455,maintainab,maintainability,455,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-518240132,3,"['flexible', 'maintainab']","['flexible', 'maintainability']"
Modifiability,"I'm a little conflicted about this. In python the convention is to put import statements at the top of a file? So the python convention is *not* to have local import statements. Since every file is a module, this means that in python import statements are at the top of modules by convention. In julia modules can be split among many files. Thus if imports are at the top of a *file*, they are scattered within the module. One reason to put things at the top level is so that its easy to see at a glance what a package imports. It's also nice to see what methods are being extended via implication; for example if one sees `import Base: +` we can expect that `+` is redefined. However, I understand that it is not easy to connect an import statement at the top of a massive module (like ours) with where it is used among the many files that comprise the code of a module. I think having more submodules (#495, #456) is really the right solution to this problem; in that case each module is short so the issue of tracing import statements to usage within a huge module is alleviated. What is the problem that this change would solve? If one is reading code in a file, and an unfamiliar function appears, one presumably looks to the top-level to see where it is imported. If one is reading a module, why is it crucial to know *where* in the code the package is used?. This new convention could create issues in which functionality from a package imported in one file is used elsewhere, making it hard to trace exactly where an unfamiliar function first arrived in the namespace. Or, if two packages conflict with one another. In julia, resolving method conflicts when two packages export the same name can be tricky and the resolution depends on the order in which packages are imported.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-545594755:573,extend,extended,573,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-545594755,1,['extend'],['extended']
Modifiability,I'm closing this. I'll open an issue to discuss an advection scheme refactor.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1104656459:68,refactor,refactor,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1104656459,1,['refactor'],['refactor']
Modifiability,"I'm finally starting to work on this issue now. I should be able to refactor all the code without changing any of the numerics. Resolving this issue will also resolve #60. I have moved the slightly separate issue of just using cell centers and cell interfaces (and explicitly stating which interface) to #146 as that will change the operators and numerics, and may be trickier to get right. I've added some goals to the original post.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-475269437:68,refactor,refactor,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-475269437,1,['refactor'],['refactor']
Modifiability,"I'm made a few changes based on your suggestions:; 1. There is only one diagnostic, the `HorizontalAverage` that can accept 1 or 2 fields. If given two fields `a, b` it calculates the horizontal average of `a*b`.; 2. `HorizontalAverage` can be used as a callable object. This PR does not refactor the diagnostics abstraction/framework, nor does it attempt to interpolate the two fields onto a common location. These are larger issues that are outside the scope of this PR. @glwagner Let me know if this looks okay to merge.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-524306817:288,refactor,refactor,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-524306817,1,['refactor'],['refactor']
Modifiability,"I'm not 100% sure but I think doing reductions over non-contiguous data might be subject to variable timings that depend on how the data is organized in memory. In an ideal world, we would benchmark these things regularly...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-960354233:92,variab,variable,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-960354233,1,['variab'],['variable']
Modifiability,"I'm not familiar with the Oceananigans code writing practice, but it looks like the parameter `number_of_layers` is redundant as it is already present in `grid.Nz`. Is the parameter added in a case where the user inputs the number of layers explicitly?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469180135:234,layers,layers,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469180135,1,['layers'],['layers']
Modifiability,"I'm not sure I follow then. Are you saying that you're not sure all the; versions in this range are bug-free? That being the case it's best to pin; it to a version we know is safe?. On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***>; wrote:. > ***@***.**** commented on this pull request.; > ------------------------------; >; > In Project.toml; > <https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022>; > :; >; > > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc""; >; > [compat]; > Adapt = ""^3""; > -CUDA = ""3""; > +CUDA = ""3.0.0 - 3.3.6""; >; > Note that Manifest.toml pins a specific version.; >; > Right, that's why I figured making it specific was the safest option.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ>; > .; > Triage notifications on the go with GitHub Mobile for iOS; > <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>; > or Android; > <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.; >; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-934858603:527,Adapt,Adapt,527,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-934858603,1,['Adapt'],['Adapt']
Modifiability,"I'm not sure. I'm not very familiar with the testing part of Oceananigans, so I'm not sure what would be a good test for this. Just testing that `min_Δz` works seems too specific, on the other hand, creating a whole simulation with a stretched grid and running it with an LES and adaptive time-stepping just to test that seems wasteful. I'm happy to just merge this for now and create a test for this in the future. Thoughts?. CC @glwagner @ali-ramadhan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866087165:280,adapt,adaptive,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866087165,1,['adapt'],['adaptive']
Modifiability,"I'm pretty sure this is trivial to support because `FunctionField` has the same interface as `AbstractOperation`, so we can simply extend these methods:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/AbstractOperations/computed_field.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122:131,extend,extend,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122,1,['extend'],['extend']
Modifiability,"I'm thinking about updating `benchmarks.md` with the new benchmark result tables and graphs. Should I do it now or wait until the docs get refactored?; It's only a single file in the appendix section, but I'm not too sure how me opening a PR on it now to update it will affect the grander refactoring plan.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880741401:139,refactor,refactored,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880741401,2,['refactor'],"['refactored', 'refactoring']"
Modifiability,"I'm using v0.68.6, previously I was on v0.67.1 and saw the same error (not surprising). I was hoping to use a stretched x-grid with a stretched z-grid while I play around with some 2D internal wave simulations. I'm still new to Julia and Oceananigans so I've been trying to simulate the classic vertically oscillating sphere or cylinder as my source. I was playing around with refining the mesh near the oscillation to see if the wave beams were a little cleaner. I can make due with stretched z-grids for now!. --; Regarding the `MethodError`, and while I am new to Julia, but maybe in this case a `NotImplementedError` would work better? I find Julia's stacktraces a bit long winded because of multi-dispatch and I obviously didn't figure out that variable grid spacing is only implemented for the vertical coordinate for the pressure solver. But getting a `NotImplementedError` when I tried would have been painfully obvious even to me. :-)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023289047:750,variab,variable,750,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023289047,1,['variab'],['variable']
Modifiability,"I've also offered to help configure testing on our systems, if someone wants to provide what is needed to integrate with slurm.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328783023:26,config,configure,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328783023,1,['config'],['configure']
Modifiability,I've documented an attempt to adapt `Field` to the GPU at #746 .,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-652527928:30,adapt,adapt,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-652527928,1,['adapt'],['adapt']
Modifiability,"I've had a go at implementing a proper NPZD model (rather than one I just made up on the fly) and have some thoughts on how we should modify the API:; - I think we need an `required_biogeochemical_auxiliary_fields` like `required_biogeochemical_tracers` because for most models we're going to want the user to at least specify a PAR field (I suppose we may want this to also check the shape of the field because some models may have a pre defined depth dependence of PAR so we might want the user to specify a 2D PAR field rather than doing it properly by integrating a 3D field); - Given what you said the other day about callbacks only being used for features that should be built into Oceananigans we might want to have a think about how a BGC model can specify the attenuation of PAR. You've mentioned that we could define some kind of integrated field?; - It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. `sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P)`, and model makers will need to do the setup stuff I've done to make the advective velocity fields. You can see my implementation [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/src/Models/AdvectedPopulations/NPZD.jl) and a script using it [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/examples/NPZD.jl) since I thought it was probably too complicated for the test (and will change that back to a 1 variable model later). Not finished making it work but yet but will be done soon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310609242:1798,variab,variable,1798,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310609242,1,['variab'],['variable']
Modifiability,"I've refactored a bit more so that we can use `FieldBoundaryConditions` to construct velocity, tracer, diffusivity, pressure, and tendency boundary conditions. This is done by specifying the `field_type` required kwarg when calling `FieldBoundaryConditions`. ```julia; u_bcs = FieldBoundaryConditions(grid, field_type=:velocity); T_bcs = FieldBoundaryConditions(grid, field_type=:tracer, top=FluxBoundaryCondition(0.1)); ```. An alternative design (really a wrapper):; ```julia; VelocityFieldBoundaryConditions(grid; kwargs...) =; FieldBoundaryConditions(grid, field_type=:velocity, kwargs...); TracerFieldBoundaryConditions(grid; kwargs...) =; FieldBoundaryConditions(grid, field_type=:tracer, kwargs...); ```. This will allow us to properly set default velocity and tracer boundary conditions with a single `FieldBoundaryConditions` constructor. It will also allow us to clean up the code a bit and remove some other functions like `PressureBoundaryConditions` and `DiffusivitiesBoundaryConditions` from `solution_and_model_boundary_conditions.jl`. @glwagner Let me know what you think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/620#issuecomment-586327005:5,refactor,refactored,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/620#issuecomment-586327005,1,['refactor'],['refactored']
Modifiability,"I've refactored this PR to combine all the different average diagnostics into one `Average` diagnostic. Different averages are specified with the `dims` keyword argument, e.g. like `Statistics.mean`. `HorizontalAverage` is now `Average(..., dims=(1, 2))` and `ZonalAverage` is now `Average(..., dims=1)` or `Average(..., dims=(1,))` so we have all possible averages available to us now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/798#issuecomment-670651085:5,refactor,refactored,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/798#issuecomment-670651085,1,['refactor'],['refactored']
Modifiability,If `times` is a `Vector` then it needs to be converted to `arch_array` _and_ adapted when passed to GPU. We're doing a big overhaul on #3450 and this is one of the thing we fixed:. https://github.com/CliMA/Oceananigans.jl/blob/13dcd4ff9767c5a1e030bf4ce5765cc661b1175b/src/OutputReaders/field_time_series.jl#L235-L243,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3472#issuecomment-1942031002:77,adapt,adapted,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472#issuecomment-1942031002,1,['adapt'],['adapted']
Modifiability,If it was related to the rewrite of the terms then shouldn't been affecting CPU regression test as well?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1427118830:25,rewrite,rewrite,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1427118830,1,['rewrite'],['rewrite']
Modifiability,"If we have a `Particle` design that looks something like. ```julia; struct Particle{P, T, R, E, D}; position :: P; properties :: T; restitution :: R; external_velocities :: E; diffusivity :: D; end; ```. With the following meaning:. * `position`: a 3-element object with the particle position (not sure what's best for GPU --- some kind of mutable struct or `Array` / `CuArray`)?; * `properties` (could use a better name): user-defined properties + model fields for simulating reactions and such. Probably need additional types / interface for these; * `restitution`: floating point number between 0 and 1 that determines particle behavior at solid walls; * `external_velocities`: a 3-tuple of settling/buoyant/other velocities to be applied to the particle in addition to the resolved + background velocity field. We can also design an abstraction / special type that computes the buoyancy of a particle with a certain temperature / salinity / buoyancy (for example); * `diffusivity` diffusion coefficient that is used to compute stochastic noise added to the particle position (requires some care to ensure the stochastic diff eq is integrated correctly. Would be nice to support both constants and functions of space-time, etc. We can start with just a few of these fields in our `Particle` type, and extend its power in future PRs if we need?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-713698417:1304,extend,extend,1304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-713698417,1,['extend'],['extend']
Modifiability,"If we want to allow for variable `nu`, which is a good idea, then the first two have the problem of not guaranteeing that viscosity reduces the kinetic energy,. The third form is the one to focus on, and is what would appear in the non-conservative of vector invariant forms. For the conservative form we need to mutliply the 3rd equation by `h`, and then `nu` has the correct dimensions: length^2/time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089638174:24,variab,variable,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089638174,1,['variab'],['variable']
Modifiability,If we're not sure what the cause of the problem is and Cthulu.jl doesn't help (or in my case too much of a noob) we could try commenting out the pressure solve (or parts of it) to try and isolate the problematic line(s) or kernel(s). I did try playing around with refactoring `permute_index` to resolve this issue but didn't really get anywhere.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-698407604:264,refactor,refactoring,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-698407604,1,['refactor'],['refactoring']
Modifiability,"If you are looking to pass structs with CuArray members into kernels, I think that you might be looking for something like https://github.com/sandreza/Learning/blob/master/nla/gmres.jl#L50; (thanks to @vchuravy for showing me how to use adapt!); It should work recursively so that composite structs will function as desired as long as each individual struct is adapted",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-621378116:237,adapt,adapt,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-621378116,2,['adapt'],"['adapt', 'adapted']"
Modifiability,"If you didn't define new advection schemes but use the implemented ones they automatically lower the order near the boundaries. The implementation is in `topologically_conditional_interpolation.jl`. If you did not define new `symmetric_left_biased_interpolation_xᶠᵃᵃ` functions you should be ok. ; Otherwise you have to add your methods in the above mentioned file. If you are using an immersed boundary, the limiting is performed in the `conditional_fluxes.jl` file in the ImmersedBoundaries module. You can always use high order and fill more halos but then you are making an assumption on the field which you are trying to evolve",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182333702:626,evolve,evolve,626,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182333702,1,['evolve'],['evolve']
Modifiability,"If you want to adopt this PR, that would be great. I would leave the boundary conditions outside the operator for the moment, then we can look at the influence of those in performance in another PR. To test the performance we should push PR #3596 that implements split explicit with fill halos at every substep. Using that implementation for split-explicit will make boundary conditions for barotropic variables quite trivial to implement, but probably extremely slow. However, we can use it as a benchmark",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353152298:402,variab,variables,402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353152298,1,['variab'],['variables']
Modifiability,"In case people don't know, @hennyg888 ran all the benchmark scrips and I beileve he has posted the results here. Thank you Henry!. I think the scripts have evolved in that some of the outputs are formatted different than what currently appears. I'm not sure if people want to change everything to the current benchmark scripts that we have?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-877468836:156,evolve,evolved,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-877468836,1,['evolve'],['evolved']
Modifiability,"In shallow water models we don't usually talk about buoyancy but you could I suppose. Since density is what appears in the momentum equation, that's what's typically used. I believe Greg was saying buoyancy since that's the variable we typically use in the other models, but I could be wrong. Yes, you can have outcroppings at the surface. This can even happen in a one layer case. Imagine starting out with a one layer reduced gravity shallow water model that is in the shape of an inverted U. When perturbed, the interface will move and then you have to deal with height going to 0 and also becoming positive. . There are positive preserving schemes for WENO that we can code up and test with our current model to better understand how it works before moving to multiple layers. Again, very happy to talk about this too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159:224,variab,variable,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159,2,"['layers', 'variab']","['layers', 'variable']"
Modifiability,In the examples I have developed I have tried to always declare variables that are referenced globally in forcing functions or boundary conditions as `const`. Definitely open PRs to fix this if you find places where that isn't the case. I haven't stayed on top of every example that's been added.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881662284:64,variab,variables,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881662284,1,['variab'],['variables']
Modifiability,"Indeed the pressure solver at the moment allows only a variable z-direction. This is because for a regular grid we can use a full FFT solve while with a singular stretched direction we can solve a tridiagonal system. . For more than one stretched direction we should use an iterative solver to solve the Poisson equation (the solvers are there but the infrastructure not quite yet). We should implement the iterative solver as a default for two or more stretched directions. And set up the FFT-tridiagonal solver as default when we have one stretched direction (either x, y or z). In the meantime, as a hotfix, If you only need one stretched direction I would suggest you to rotate your problem to stretch it in z-direction",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022674786:55,variab,variable,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022674786,1,['variab'],['variable']
Modifiability,"Instructions to adapt the code to `MultiRegion` from a Slack conversation with @simone-silvestri:. If you want to adapt your script to multiregion you have to:; - define a multiregion grid with: `grid = MultiRegionGrid(grid, partition = XPartition(n_gpus_you_want_to_use), devices = n_gpus_you_want_to_use)` . The multiregion grid supersedes the immersed boundary grid, i.e. if you are using an immersed boundary grid then `grid = MultiRegionGrid(ibg; kwargs...)` , not the other way around.; - if you are using any array for forcing or boundary condition, you have to adapt it to the multiregion paradigm as follows: `using Oceananigans.MultiRegion: multi_region_object_from_array; my_adapted_array = multi_region_object_from_array(my_array, grid)`. MultiRegion works only on single node multi GPU, so all the GPUs should be accessible from a single process in the node. You can check the number of GPUs available by logging in a node and typing nvidia-smi , if you want to split your grid on specific devices (let’s say GPU 0 and 3), you can pass `devices = (0, 3)` to the `MultiRegionGrid` constructor. There is another thing that you have to take care of: the pressure solve is performed on one GPU only so both the storage and source term (a field of complex values of the size of the full grid) reside on 1 GPU only (usually the one corresponding to the last region). This means that if your grid is 100M points, 2.98 GB will have to be reserved for the solver’s auxiliary fields; ```julia; julia> sizeof(complex(zeros(Int(100e6)))) / 1024 / 1024 / 1024 * 2; 2.9802322387695312; ```; So make sure you have that space available. (When I have time I ll try to find a solution to run truly parallel pressure solvers, for both nonhydrostatic and hydrostatic models). In terms of outputs, we make use of `reconstruct_global_field` , a function used to reconstruct a global field from a `MultiRegionField` on the CPU. It is used by the output writers to spit out the full field. It is a slow procedure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875:16,adapt,adapt,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875,3,['adapt'],['adapt']
Modifiability,"Interesting! Good find. This not the only thing to worry about regarding the entrainment diffusivity. It's effect also seems to depend on vertical resolution, and it only seems useful at low resolutions. In general, I recommend switching to CATKEVerticalDiffusivity, where we have put a lot of effort into solving those problems. I'm going to suggest a different solution that setting some maximum capping diffusivity. I think setting a maximum diffusivity could work, but that there are better solutions that more directly address the underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718:923,extend,extend,923,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718,1,['extend'],['extend']
Modifiability,Is it true that the [different cosine transforms](http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html) differ in their definition of the collocation points?. Where is the pressure stored in `z`? At cell centers? So your grid extends from `z=-dz/2` to `z=-H+dz/2`? Just from glancing at the FFTW documentation those would seem the right grid points for DCT-II. You can have more than one test! I think it makes sense to have an easy test with sinusoids to catch obvious bugs. Then if you are ambitious you can also implement a Gaussian test.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/7#issuecomment-439693037:239,extend,extends,239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/7#issuecomment-439693037,1,['extend'],['extends']
Modifiability,Is the PR on KA very crucial?. Would it be a lot of refactoring to have this merged atm with a tagged KA version? This way we don't need to wait for KA?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1610993664:52,refactor,refactoring,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1610993664,1,['refactor'],['refactoring']
Modifiability,"Is this PR looking for an adopter? Happy to try to complete it since it seems like the first step towards open BCs for hydrostatic models. > > Thinking of revamping this, I think `T` is a good notation; we do not need to specify `U` and `C` since probably (in the future) we will need to refactor these a little to pass through boundary conditions.; > ; > Hopefully we don't have to pass boundary conditions 🥺; > ; > Not all complexity is justified by the performance gains... Ah I'm actually not sure where the performance gains would come from, but I thought that the operators need to be aware of the boundary condition in order to correctly implement open BCs (at least based on @simone-silvestri's comments in https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2312725203).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2350225617:288,refactor,refactor,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2350225617,1,['refactor'],['refactor']
Modifiability,"It also bears mention that the curious behavior in the lat-lon results above (what looks like spurious boundary fluxes after around 20 days) apparently occurs whether we include the GM parameterization or not. So something else is wrong, perhaps with Bounded boundary conditions on lat-lon (but not sure).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1127186179:185,parameteriz,parameterization,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1127186179,1,['parameteriz'],['parameterization']
Modifiability,"It appears to be related to the size of the grid:. ```julia; julia> grid = RectilinearGrid(GPU(), size=(8, 8, 8), x=(0,1), y=(0,1), z=0:8); 8×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.125; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [0.0, 8.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> minimum_zspacing(grid); 1.0. julia> grid = RectilinearGrid(GPU(), size=(16, 16, 16), x=(0,1), y=(0,1), z=0:16); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [0.0, 16.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> minimum_zspacing(grid); ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/error.jl:89; [2] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CUDA.CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CUDA.CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/utils/call.jl:26; [4] #39; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::Cartesian",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490603313:371,variab,variably,371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490603313,2,['variab'],['variably']
Modifiability,"It looks like there is a problem with GM. Taking 1 second time-steps without GM, `idealized_one_degree_simulation.jl` produces . ```julia; julia> include(""near_global_one_degree.jl""); underlying_grid = LatitudeLongitudeGrid(arch; size = (Nx, Ny, Nz), halo = (4, 4, 4), latitude, z, longitude = (-180, 180), precompute_metrics = true) = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 5.177 seconds; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (388.072 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (28.553 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 28.596 seconds; │ ├── max(u): (1.94e-10, 4.57e-05, 1.03e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.03e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 1.632 seconds; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 843.428 ms; │ ├── max(u): (2.48e-08, 1.37e-04, 3.09e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 6.17e-06 m; ```. When `IsopycnalSkewSymmetricDiffusivity` is included, however, we find. ```julia; julia> include(""near_globa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:637,variab,variably,637,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518,1,['variab'],['variably']
Modifiability,"It looks like this PR fixes some issues with complex AbstractOperations, but it does not allow us to use AveragedField on the GPU. I think a possible avenue to explore could maybe be to Adapt an AveragedField by wrapping the underlying, `Adapt`ed data in `Base.Broadcast.Broadcasted`, rather than attempting to adapt `AveragedField` (with its custom `getindex`, which it the crucial part) directly for the GPU. We know that broadcasting with singleton dimensions already works on the GPU and its possible we might borrow some of that machinery. The key function we might want to get a hold of is `_broadcast_getindex`:. https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821774827:186,Adapt,Adapt,186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821774827,3,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,"It makes sense that using `const` for variables referenced ""globally"" in functions increases CPU performance, see: https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436:38,variab,variables,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436,2,['variab'],['variables']
Modifiability,"It would be nice to convert it into a discussion, but I think we want to correct the AB2 for variable time stepping quite soon, because it might be a large source of error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313282962:93,variab,variable,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313282962,1,['variab'],['variable']
Modifiability,"It's an interesting philosophical question whether fields should carry around their boundary conditions or not. @kburns might have something to say. I think there are some good arguments in favor of this view. There are some oddities: for example, the boundary conditions on pressure are not zero gradient; however we use these ""effective"" boundary conditions for convenience and (at least eventually) will include inhomogeneous parts of the pressure boundary condition on the RHS of the pressure Poisson equation. So at least for pressure the ""boundary conditions"" we would specify are not actually the true boundary conditions. Once we have topological information embedded in our `AbstractGrid`, adding default boundary conditions for fields may not be too difficult. But it may not just be a refactor. It seems it might change the user API, too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/601#issuecomment-579560026:796,refactor,refactor,796,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/601#issuecomment-579560026,1,['refactor'],['refactor']
Modifiability,"It's easy to extend the existing simple test to a two-output case, so I did that on #1807. If #1807 passes, then there is some other aspect of the setup that's producing a failure. It's also possible that there is more than one problem / cause of woe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947:13,extend,extend,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947,1,['extend'],['extend']
Modifiability,"It's easy. The main challenge is designing the API / semantics. Do we want to extend `ConstantIsotropicDiffusivity` to new `κ` types (dispatching on the type of `κ` to achieve this goal), or do we want to create a new type, eg `SpatiallyVaryingIsotropicDiffusivity`?. If we nudge the meaning of ""constant"" to mean ""constant in time"", I think that it could make the most sense to extend the functionality of `ConstantIsotropicDiffusivity`. Also, I am realizing that we want to do this with functions rather than arrays. That's ok, because we can also compute flux divergences for diffusivity functions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/51#issuecomment-531180161:78,extend,extend,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/51#issuecomment-531180161,2,['extend'],['extend']
Modifiability,"It's hard because even [wikipedia](https://en.wikipedia.org/wiki/Stokes_drift) is misleading on this subject and says. > For a pure wave motion in fluid dynamics, the Stokes drift velocity is the average velocity when following a specific fluid parcel as it travels with the fluid flow. Yet if a mean velocity exists, the motion is not a ""pure wave"" motion; it has a mean component and a wave component, each of which have dynamics that are independent in the limit of small amplitude waves. In other words, if particles and thus fluid undergo some net drift, then some external mean force must have imparted mean momentum to the fluid. So the first sentence of the Wikipedia article misleads. It's easy to get this wrong because in many systems the mean dynamics are ""trivial"" and do not evolve. But this is not always the case... The reason this subject is so tricky is because the physics of surface gravity waves _require_ a transfer of mean momentum from some external agent if they are excited (this is part of what it means for a wave field to have pseudomomentum). Thus the forced growth of waves is _also_ associated with a transfer of mean momentum (from the atmosphere to the ocean). But the mean momentum so transferred is not by any reasonable definition a ""wave property""; it undergoes an independent evolution and is easily divorced from wave fields that propagate rapidly away. In particular, if the system is rotating, the mean momentum excites a stationary inertial oscillation that has no net transport over long periods of time (while the wave field happily propagates ad infinitum)... Not that Wikipedia was always right before this on every topic --- but the view on Wikipedia is the same one that's taught in classrooms. I think users know _mathematically_ what is indicated by the keyword `stokes_drift`, especially if we well-document the fact that we solve for the Lagrangian-mean velocity. That's probably the most important thing. Buhler (2014) provides a good perspective ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611:789,evolve,evolve,789,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611,1,['evolve'],['evolve']
Modifiability,"It's just a suggestion... Perhaps it's not needed. But having it as a parameter of the type could be useful, even if the parameter is the same value as `grid.Nz` because if it's part of type you can write methods that do different things based on the number of layers your model has. E.g.,. ```Julia; function compute_this_and_that(model::ShallowWaterModel{1}); a = 1 # simple calculation for single-layer models; return a; end. function compute_this_and_that(model::ShallowWaterModel); number_of_layers = model.number_of_layers; a = sum(rand(number_of_layers)) # more complicated stuff only needed for multi-layer models; return a; end; ```. This way we don't use `if number_of_layers > 1; do this; else; do that` which reduces performance because the compiler has to compile all cases and check every time the value of layers and do this or the other....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469188127:261,layers,layers,261,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469188127,2,['layers'],['layers']
Modifiability,"It's mirroring Base julia, eg. ```julia; julia> a = rand(2, 3, 4); 2×3×4 Array{Float64, 3}:; [:, :, 1] =; 0.264469 0.977549 0.937297; 0.491955 0.710279 0.315507. [:, :, 2] =; 0.243796 0.783644 0.820073; 0.682626 0.351825 0.503396. [:, :, 3] =; 0.726912 0.287171 0.671998; 0.234873 0.993365 0.913062. [:, :, 4] =; 0.507489 0.568977 0.327032; 0.59475 0.547478 0.459589. julia> size(a, 3); 4; ```. We've extended `size` for fields, and `1, 2, 3` do currently correspond to the first, second, and third dimensions in that syntax. So I don't agree that it ""means nothing"", but perhaps we want something else for our API... I do agree that having named dimensions is a cool idea. I wonder if it'd be better to do this properly in the sense of #1700 or https://rafaqz.github.io/DimensionalData.jl/stable/course/#Dimensions-and-DimArrays rather than just providing functions like `size(c::AbstractField, :x)`...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-971713695:401,extend,extended,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-971713695,1,['extend'],['extended']
Modifiability,"It's needed when your computation is located on `Face`s. By default, `work_layout` returns a layout that extends from ""1 to `N`"". This default is used for time-stepping kernels. But for diagnostics you usually want that last grid point at `N+1`. It might make sense to change the default value, since users / people writing new kernels probably want `include_right_boundaries=true`, and its only a minority of rarely-changed kernels (for time-stepping) that want `include_right_boundaries=false`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1290#issuecomment-756170764:105,extend,extends,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1290#issuecomment-756170764,1,['extend'],['extends']
Modifiability,It's so nice that we have these tests. Seeing them pass makes me so confident that you did this matrix constructor refactor correctly @elise-palethorpe.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1180287052:115,refactor,refactor,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1180287052,1,['refactor'],['refactor']
Modifiability,"It's something to do with GPU, maybe GPU reductions?. ```; [2023/05/24 21:41:15.102] INFO Testing grid utils on variably spaced grid....; --;   | Grid initialization: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_grids.jl:199;   | Expression: minimum_xspacing(grid) ≈ FT(π / 3);   | Evaluated: 0.0 ≈ 1.0471975511965976; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1564733331:112,variab,variably,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1564733331,1,['variab'],['variably']
Modifiability,"It's true that global variables have to be defined as `const`, but it's also true that global variables are never ""required"" (they just may be more convenient than defining a callable struct)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2960#issuecomment-1458703878:22,variab,variables,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2960#issuecomment-1458703878,2,['variab'],['variables']
Modifiability,"It's very exciting! I was just remarking about ""we have to comment X out"". Extending a method that doesn't work on the cubed sphere is practically the same amount of work (in this case), and illustrates the proper workflow when developing a new feature (often methods will have to be extended, since they may make assumptions that are no longer valid). So I wanted to point that out in case people run into this in the future and use it as a template for their own development. Also if you are working with others, being clear about the development that's needed can help coordinate efforts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1719386432:75,Extend,Extending,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1719386432,2,"['Extend', 'extend']","['Extending', 'extended']"
Modifiability,"I’m happy with output_writers.jl; I think all the code in that file is appropriately related. The checkpointer could provide its own constructor to avoid excess memory allocation. . For GPU problems I don’t think there is an issue: checkpointed arrays can b loaded into CPU memory rather than GPU memory, and then the data can be copied into the fields allocated by the model constructor. So at first glance the excess memory allocation does not seem like a major issue on modern CPUs. . I am particularly concerned about the maintainability of the checkpointer, since it will need to be updated every time a new feature is added. Let’s make sure the design is easy to maintain before merging.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-517777579:526,maintainab,maintainability,526,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-517777579,1,['maintainab'],['maintainability']
Modifiability,"Just a quick thought: mathematically it sometimes makes sense to use boundary conditions to reduce the size of the function space a variable can live in, i.e. considering a certain field to be in the space of functions that have zero value (or zero normal derivative) at a boundary. Physically, though, I'm not sure this is so useful, since many systems have non-trivial boundary conditions, including nonlinear conditions and conditions involving multiple fields. Then the notion of a certain BC even ""belonging"" to a certain field is a little less clear... you may just have a set of fields that need to collectively satisfy a set of conditions on the boundary. E.g. thermal radiation conditions (heat flux depends nonlinearly on temperature); E.g. nontrivial stress BCs (maybe where viscosity is temperature-dependent, like ice)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580349260:132,variab,variable,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580349260,1,['variab'],['variable']
Modifiability,Just a small plea to make this implementation compatible with / moves us towards the refactor envisioned in #2454,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1128350043:85,refactor,refactor,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1128350043,1,['refactor'],['refactor']
Modifiability,"Just an update (mostly for my own benefit later), apparently the outputs are constructed appropriately now, but the outputs still can't be written to NetCDF because the writer creates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:188,variab,variables,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655,4,"['Variab', 'variab']","['Variable', 'variable', 'variables']"
Modifiability,"Just another thought. If it's implemented in this way with; * `CoordinateBoundaryConditions` on the `left` and `right` parts of the domain.; * `FieldBoundaryConditions` along the `x`, `y`, and `z` dimensions.; * `BoundaryConditions` on the `u`, `v`, `w`, `T`, and `S` fields. with the final boundary condition being a function, would there be 30+ nested parameterized types for `ModelBoundaryConditions`. Is/should that be a concern?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472013599:354,parameteriz,parameterized,354,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472013599,1,['parameteriz'],['parameterized']
Modifiability,"Just as an update --- we actually currently cannot do this verification experiment because of a problem with LES models (a theoretical problem, not an implementation problem) with specified buoyancy flux boundary conditions and zero stress boundary conditions. In short, we observe grid-scale oscillations in the near-surface buoyancy gradient when buoyancy fluxes are specified. The primary issue is associated with a too-small near-surface LES diffusivity. . I want to emphasize that this is not a numerical issue with boundary condition specification, or a bug in the LES implementation --- this is a fundamental, theoretical problem with LES formulation. Others have observed this issue before with a variety of LES formulations, so this issue is not particular to AMD, either. I'm working on a fix because this is an important, canonical problem. The easiest way to fix the problem is to allow the LES model constant (which we should view as a free parameter) to vary in space and in particular to increase near the wall. This is simple, yet completely empirical solution. . The level of empiricism / near-wall enhancement of the model constant needed for a smooth solution is mitigated somewhat if we can specify the gradient of buoyancy / temperature on the boundary. This second component of the fix can be done by introducing a wall model on top of the interior LES formulation that applies *on* boundaries. The wall model introduces a second free parameter in addition to the interior LES free parameter. Adjusting the wall model's free parameter allows us to ""effectively"" increase the near-wall value of the AMD diffusivity. An even better, more complete fix would also modify the interior LES model near the wall. But this is an open-ended science problem with no clear solution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/547#issuecomment-580299239:1116,enhance,enhancement,1116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/547#issuecomment-580299239,1,['enhance'],['enhancement']
Modifiability,"Just for completeness, what do we think about `pseudomomentum`?. The issue with Stokes ""drift"" is that it implies a ""drifting"" which is not quite the right way to think about how surface waves affect the motion of fluid beneath them. In reality, average momentum (and thus any ""drifting"" that might occur) is imparted by external forces (such as the atmosphere); the averaged effect of surface waves is rather more subtle and is associated with changes to the relationship between mean momentum and vorticity (eg, vorticity feels the effect of pseudomomentum, despite that momentum does not). These concepts are confused routinely in the literature, so our community doesn't have a solid conceptual foundation on which standardized terminology is easily built. But suffice to say that in practice most people say ""Stokes drift"" but mean ""pseudomomentum"". In the context of Oceanagnians of course the prognostic variable _is_ the mean momentum (the Lagrangian-mean velocity field), thus this keyword really does control psuedomomentum with no impact on ""drifting""...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777144818:911,variab,variable,911,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777144818,1,['variab'],['variable']
Modifiability,"Just for reference, I created the MWE example below of a column model with a sheared `u` that evolves in time, where I write both the full `u` and an interpolated `u` to half the original resolution. What I'm doing here is creating a coarse grid, coarse model, and coarse field that takes the interpolated `u`. I use a `Callback` to keep interpolating `u` into `coarse_u` and then it's only a matter of setting up a coarse `NetCDFWriter` with `coarse_model`. ```julia; using Oceananigans. grid = RectilinearGrid(size = (1, 1, 8), extent = (1,1,1));; model = NonhydrostaticModel(; grid, closure = ScalarDiffusivity(ν=1e-2)). set!(model, u=(x, y, z,) -> z). simulation = Simulation(model,; Δt=0.5*maximum(zspacings(grid, Center())) / maximum(abs, model.velocities.u),; stop_time=20); # Create regular output; simulation.output_writers[:fullfields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename = ""fullfields.nc"",; schedule = TimeInterval(5),; overwrite_existing = true,). # Create interpolated u on coarse grid; coarse_grid = RectilinearGrid(size = (grid.Nx, grid.Ny, grid.Nz÷2), extent = (grid.Lx, grid.Ly, grid.Lz)); coarse_model = NonhydrostaticModel(; grid=coarse_grid, closure = ScalarDiffusivity(ν=1e-2)); coarse_u = Field{Face, Center, Center}(coarse_grid). using Oceananigans.Fields: interpolate!; update_coarse_u(simulation) = interpolate!(coarse_u, simulation.model.velocities.u); simulation.callbacks[:update_interp] = Callback(update_coarse_u). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(coarse_model, (; coarse_u,),; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; overwrite_existing=true,). run!(simulation); ```. This seems to be working. In the figure below the lines and triangles come from the full res output, while the cirlces come from the coarse (interpolated) output:. ![image](https://github.com/CliMA/Oceananigans.jl/assets/13205162/1a72237a-67ac-4804-9230-9d766e71b353). You can definitely take nicer/fancier a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2090846777:94,evolve,evolves,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2090846777,1,['evolve'],['evolves']
Modifiability,"Just to add a reference, [Kevlahan et al. 2015](http://doi.org/10.5194/gmd-8-3891-2015) doesn't discuss multiple layers, but seems to do a good job incorporating bathymetry and immersed-boundary continents that have proper wave reflection and don't increase wave speeds inside the continents. I'm trying this model out in Dedalus and maybe it's possible to extend this approach to multiple layers, but I'm not a shallow water expert.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116178998:113,layers,layers,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116178998,3,"['extend', 'layers']","['extend', 'layers']"
Modifiability,"Just to be clear, the point of doing this is because you want to use dispatch to write flexible array operations that are agnostic to whether the array is a 'raw' array (like an `Array` or `CuArray`), or some kind of wrapper like an `OffsetArray`. By writing `parent(a)`, you ensure correct behavior on `a` in both cases; you don't need to write new high-level functions for wrappers versus arrays because dispatch is performed at the lower level, where it belongs. With `data` we can use the same logic --- this concept is deployed extensively in PR #463.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/454#issuecomment-542269350:87,flexible,flexible,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/454#issuecomment-542269350,1,['flexible'],['flexible']
Modifiability,"Just to document what's been done:. So I ran the Ri = 0.01, Pr = 0.7 case that Cat ran at three different horizontal resolutions and unfortunately the results are quite different from hers:; 1. U and T don't fully go to zero at the top and bottom. This could be because we only have 64 vertical levels, not enough to resolve the boundary layers, but otherwise the profiles look qualitatively correct.; 2. Our νSGS/ν and κSGS/κ are too low by a factor of ~2. They decrease as you increase the resolution which makes sense. κ profile shape looks similar to Cat's. ν profile shape should be flatter.; 3. Re is roughly a factor of 2 too large. Nu is too large by ~60%. (edited) ; I might try changing the Poincare ""constant"" to see if it makes a difference here. Currently C = 1/12, so I'll try 1/24 and 1/6. Might also try 128 vertical levels, but that's no longer a fair comparison. ![Stratified_couette_flow_UT](https://user-images.githubusercontent.com/20099589/64424696-bc478480-d077-11e9-8b1e-f4d93e912214.png). ![Stratified_couette_flow_VK](https://user-images.githubusercontent.com/20099589/64424702-bf427500-d077-11e9-890f-56096e6719a0.png). ![Stratified_couette_flow_ReNu](https://user-images.githubusercontent.com/20099589/64424706-c2d5fc00-d077-11e9-9711-d03c30d5a97e.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-528817838:338,layers,layers,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-528817838,1,['layers'],['layers']
Modifiability,"Just to frame the discussion: this is probably most important in the context of new users or scientists trying to read examples, docs, and scripts that implement numerical experiments for scientific purposes. In that context I agree with @ali-ramadhan that `BoussinesqModel` is misleading for models with `tracers = nothing` and `buoyancy = nothing`. I think we've also discussed making this default, since its simple... As for the distinction between hydrostatic and non-hydrostatic models I agree that with currently supported configurations, `NonhydrostaticRigidLid` is better than `HydrostaticFreeSurfaceModel`. I'm only hesitant about this change because I wonder if we may want to combine these two models in the future. The motivation to develop `HydrostaticFreeSurfaceModel` separately is largely practical and caves to short term timeline pressures (it's easier to break things when nobody's using it, and we throw a warning right in the constructor so people know its experimental). In the long run it might make sense to have just a single interface to all incompressible models and support all combinations of hydrostatic, non-hydrostatic, free surface / rigid lid, etc through a single interface, similar to what MITgcm offers. The interfaces / model specific code is expensive to maintain, which motivates having just one interface. If this is our goal, it'd be premature to change the name of `IncompressibleModel`. If people feel they'd like to commit to maintaining two interfaces / model constructors / time-stepping code then I think changing the name to be clearer but less general is an option to consider. I personally would rather maintain as few `AbstractModel` as possible because I feel they are fairly expensive in terms of person-time to maintain. And we probably have a lot of improvements that need to be made (features like `model.auxiliary_fields`, `VectorField` for velocity field rather than baking in the coordinate system which fails on the cubed sphere), proper su",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827842772:529,config,configurations,529,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827842772,1,['config'],['configurations']
Modifiability,"KE) * L_mix` with a mixing length `L_mix`, but also to energetically constrain the backscatter in the momentum equation. See this schematic, modified from Figure 1, Jansen et al. (2019):; ![MEKE_schematic](https://user-images.githubusercontent.com/23617395/167711268-23732094-80aa-476e-8f13-fd6cd8659e8c.png); So how about `PrognosticMEKEDiffusivity` and `PrognosticMEKEBackscatter`? Probably good to keep these 2 separated to be able to switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length scale. So if you use MEKE with the Eady length scale `L_e` (see Appendix Ab in Kong and Jansen, 2021), you recover the GEOMETRIC source",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:1730,variab,variable,1730,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692,1,['variab'],['variable']
Modifiability,"LES closure is a very high priority. On Wed, Apr 24, 2019, 5:39 PM Ali Ramadhan <notifications@github.com> wrote:. > Not supposed to be concrete but just to lay out some goals for big new; > features and prioritize them based on our needs. Also in case I forgot; > about them.; >; > Most of these can be done independently so the version ordering is mostly; > for priority.; >; > - v0.6: Halo regions (#167; > <https://github.com/climate-machine/Oceananigans.jl/pull/167>); > - v0.7: More conservative time-stepping for Float32; > - v0.8: channel and boxed/cubed models, i.e. multiple wall-bounded; > dimensions (#180; > <https://github.com/climate-machine/Oceananigans.jl/pull/180>); > - v0.9: Arbitrary LES closures (Smagorinsky and AMD implemented); > - v0.10: Variable Δz grid; > - v0.11: GPU performance optimization (GPU hackathon); > - v0.12: Multi-GPU (and multi-CPU?) distributed parallelism (GPU; > hackathon); > - v0.13: ..?; > - v1.0: ....?; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/207>, or mute; > the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQUFOFFJEHO2C7FNEB3PSDHR3ANCNFSM4HIIDSNA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/207#issuecomment-486464430:764,Variab,Variable,764,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/207#issuecomment-486464430,1,['Variab'],['Variable']
Modifiability,"Let me try to reframe the problem and tell me if you agree. I think its a real issue that the output files are created when the output writers are instantiated. Because of this, we find ourselves having to write `overwrite_existing=false` when we pickup from a checkpoint, but `overwrite_existing=true` otherwise. This is a hack for sure. It's a failure of the checkpointer design --- the whole point of the design is to make checkpointing easy. We should be able to change just one line. I even think we should be able to pick up from a checkpoint with an environment variable so we don't have to change the run script at all. That would be more robust. What you're describing sounds like an additional problem of this deficiency. The fix seems straightforward. We just need to introduce the concept of output ""initialization"". Then we can delay creating the output file to `run!`. At that point we know if we are picking up from a checkpoint or not, obviously if we are picking from a checkpoint we don't want to delete any existing files. It seems like if we introduce initialization we can also handle file splitting. What do you think? If you want to help we can get started on it. I was putting it off myself because I don't have immediate needs for checkpointing but that will probably change pretty soon. Separately I don't like I also don't like `overwrite_existing` more broadly because I feel its boilerplate, which we are discussing a bit over on #3793 .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391318167:569,variab,variable,569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391318167,1,['variab'],['variable']
Modifiability,Let's close this --- the code will change a lot soon and we can easily rewrite these changes.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/216#issuecomment-494886548:71,rewrite,rewrite,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/216#issuecomment-494886548,1,['rewrite'],['rewrite']
Modifiability,Looks like a good interface to me. But is it on purpose that there is only support for background fields in the `NonhydrostaticModel` and not for the `HydrostaticFreeSurfaceModel`?. @liuchihl will test it in our configurations.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2204239079:212,config,configurations,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2204239079,1,['config'],['configurations']
Modifiability,Looks like this PR only updates Adapt to v2.4.0 and not v3.0.0 so maybe it's being blocked by a dependency (which probably has a similar CompatHelper PR open right now). I think we should wait to check that all tests pass with Adapt v3.0.0 before merging.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548:32,Adapt,Adapt,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548,2,['Adapt'],['Adapt']
Modifiability,"Looks like this happened after PR #1740 was merged as https://buildkite.com/clima/oceananigans/builds/2893 looks fine (GPU tests running on the commit before #1740 was merged) but the next commit/build on master is not fine https://buildkite.com/clima/oceananigans/builds/2895 (no GPU tests on the #1740 merge commit). Maybe this had something to do with CUDA.jl v3.3.0 or with the addition of the `JULIA_CUDA_USE_BINARYBUILDER=""true""` environment variable?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1794#issuecomment-871698977:448,variab,variable,448,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1794#issuecomment-871698977,1,['variab'],['variable']
Modifiability,"Lots of interesting discussion here. Nomenclature can be a pain as people use a lot of different words for the same things and sometimes use the same word for different things. I wonder whether finding a good review article and citing that would be a good way to establish our foundation? I imagine there is a lot to choose from out there but don't have a specific one in mind. Below are a few thoughts. 1) I would argue that molecular viscosity is real (resolved) physics, in these continuum models, is derived from physical principles and you should not change the coefficients based on the grid you are using. These are measured in experiments and are what the community to believe as true when doing lab experiments. 2) For large-scale flows, as many of us consider, molecular viscosity is insignificant and should probably be ignored as it has no real meaning on the large scales. That is why summing molecular and eddy viscosities does not seem like such a good idea to me. However, adding a very small number to a large number will nto make much of a difference for all intensive purposes. I would think that the user has the onous of responsibility of picking the viscosity that is appropriate for their problem. . 3) For large-scale flows where you need some parameterization, I think that using `eddy` or `sgs` are accepted by large groups in the community. Effective seems a little less desirable for me as it does not say where it comes from.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775339859:1268,parameteriz,parameterization,1268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775339859,1,['parameteriz'],['parameterization']
Modifiability,"Maybe I misunderstood your suggestion but the problem with a kernel like; ```julia; integral[k] += field[i, j, k] * A_cell[i, j]; ```; is that it's not thread-safe on a GPU. You can't have multiple threads incrementing the same variable, you get a race condition. You can do that using atomic CUDA operations (e.g. an `atomic_add`) but I don't think they're part of CUDAnative.jl yet. That's why I went with a parallel reduction prefix sum algorithm which I essentially took and modified from https://github.com/JuliaGPU/CUDAnative.jl/blob/master/examples/scan.jl. Another way to calculate that horizontal integral on the GPU is to use 1 thread per vertical level, but I coded that up and it's slow as you'll need ~5000 vertical layers to saturate an Nvidia V100 GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520512225:228,variab,variable,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520512225,2,"['layers', 'variab']","['layers', 'variable']"
Modifiability,Maybe better to extend the `Checkpointer` constructor specifically for `ShallowWaterModel`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2866#issuecomment-1384668956:16,extend,extend,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2866#issuecomment-1384668956,1,['extend'],['extend']
Modifiability,Maybe it did need some of the overwrite existing because it writes different configurations to the same file. Update: passes locally if I add them back,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1570636076:77,config,configurations,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1570636076,1,['config'],['configurations']
Modifiability,Maybe. We might revisit but I'll close this PR for now since we have dynamic launch configs now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-500225375:84,config,configs,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-500225375,1,['config'],['configs']
Modifiability,"Might be cool to be able to dispatch on the order so the order could be specified as part of the model, e.g. ```julia; model = ShallowWaterModel(grid=grid, order=4); ```. and it would make it easier to use the operators in other models. We could define new types like. ```julia; struct SecondOrderCenteredDifference end # one option; struct CenteredDifference{N} end # another option; ```. then dispatch on `::SecondOrderCenteredDifference` or `::CenteredDifference{Val{4}}` or we could dispatch on numbers via `Val`. ```julia; julia> δ(i, A, ::Val{2}) = A[i] - A[i-1]; δ (generic function with 1 method). julia> δ(i, A, ::Val{4}) = (-2A[i+1] + 16A[i] - 16A[i-1] +2A[i-2]) / 12; δ (generic function with 2 methods). julia> δ(10, collect(1:20) .^ 2, Val(2)); 19. julia> δ(10, collect(1:20) .^ 2, Val(4)); 15.833333333333334; ```. but might have to be careful to [avoid performance regressions with `Val`](https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-value-type). That said it might take a non-trivial amount of refactoring to support and test dispatching on the operator order, at least for the incompressible model. Maybe it makes sense for `ShallowWaterModel` to add support for 4th-order operators first (with or without dispatch, probably easier without first) and from there we can investigate how to generalize?. If we go all out and start supporting lots of different operators I wonder if it's worth looking into [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl) or [FiniteDifferences.jl](https://github.com/JuliaDiff/FiniteDifferences.jl). Not sure what role these packages would play. From skimming the FiniteDifferences.jl README it seems that there are no higher-order non-allocating implementations between the two packages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155:1039,refactor,refactoring,1039,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155,1,['refactor'],['refactoring']
Modifiability,"Might be good to add a test (or more than just one) for windowed fields. Even a simple one like. ```julia; windowed_field = CenterField(grid, indices=(:, :, 1:1)); @test view(windowed_field, :, :, 1:1) isa AbstractArray; ```. or something. @siddharthabishnu can you add that? Pretty basic test so probably belongs in `test_field.jl`:. https://github.com/CliMA/Oceananigans.jl/blob/sb/extend-parent-indices/test/test_field.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2088811397:384,extend,extend-parent-indices,384,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2088811397,1,['extend'],['extend-parent-indices']
Modifiability,"Might be good to clarify some of this discussion: a ""sponge layer"" refers to any region in a simulation domain that dissipates energy. A wide variety of forcing functions are ""valid"" sponge layers, including the example in the documentation. The Gaussian mask appears to be behaving correctly, and as one expects given the documentation, source code, and known/measurable/plottable properties of Gaussians. Using a Gaussian to define the masked region is valid strategy used successfully in research. Of course, this does not mean that other masking functions may be more appropriate, or that a ""smooth step"" function might be more useful to users, since the width of the sponge, and width of the sponge layer *transition* region may be modulated independently. This is not the case for the Gaussian, which has only one width parameter. A sharp heaviside is not a good choice for a sponge layer when the sponge is intended to absorb radiating internal waves. The reason is that waves can reflect off a sponge layer if the transition between undamped and damping regions is too abrupt (as pointed out by @navidcy). was under the impression this might even be an issue for problems without waves... ?. The requirement that sponge layers involve smooth transitions does mean that sponge layers can take up a substantial portion of the computational domain. This is often cited as a downside of sponge layers (eg Klemp and Durran 1993).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-734408323:190,layers,layers,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-734408323,4,['layers'],['layers']
Modifiability,Might make sense to figure out how to `@assert` that the benchmark is configured correctly?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885658285:70,config,configured,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885658285,1,['config'],['configured']
Modifiability,"Mostly I am worried about scalability and sustainability in this design, or future designs. . Currently our models are fairly simple, but its challenging to place bounds on potential future complexity. For example, models in the future may require additional fields associated with closures or parameterizations, such as boundary layer depth fields, in-plume tracer concentrations and vertical momentum, precomputed mixing length fields, and perhaps other auxiliary fields associated with various prognostic / diagnostic LES models. We probably can't plan to support setting boundary conditions on every possible field via the model constructor. With our current design we have essentially special-cased turbulent diffusivities because our focus is LES, turbulent diffusivities are relatively common, and it convenient for us. However doing this incurs some maintenance burden --- which will increase if we plan to hard-code validation and error checking. Food for thought.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605453798:294,parameteriz,parameterizations,294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605453798,1,['parameteriz'],['parameterizations']
Modifiability,Moved it out of examples since I agree it might not be good to just fill it up with convection examples. It's in the sandbox now as a script for generating movie data. Not necessarily a good example in its current form. > Why don’t we use a function instead since that is cleaner and more Julian. In this case `Q` is constant in time so it's more efficient to generate it once and apply it as an `AbstractArray` boundary condition rather than a function with if statements that gets called at Nx*Ny times every time step.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/334#issuecomment-518900928:117,sandbox,sandbox,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/334#issuecomment-518900928,1,['sandbox'],['sandbox']
Modifiability,"My 2 cents: I think it’s fine to plan to refer back to this closed issue if, at some point in the future, we’d like to create many more verification tests. . Personally I think we should keep the number of verification tests from ballooning — they will become a burden to maintain as we evolve the API. This code is young! There’s a lot of progress to make.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-478103393:287,evolve,evolve,287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-478103393,1,['evolve'],['evolve']
Modifiability,"My only additional note is that we are using lowercase `u`, `v`, and `w` to refer to velocity fields at the moment; both the code and the description of this PR refer to uppercase variables. This is off-topic, but notable: I wouldn't mind achieving some consistency in the naming: either changing `T` and `S` to lowercase `θ` and `s`, or changing `u`, `v`, and `w` to `U`, `V`, and `W`. It's unfortunate to combine upper and lowercase because otherwise we could ascribe some meaning to the case of a variable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/215#issuecomment-490705929:180,variab,variables,180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/215#issuecomment-490705929,2,['variab'],"['variable', 'variables']"
Modifiability,"Navid here is the output-; ```; julia> using Pkg. julia> Pkg.activate("".""); Activating environment at `~/new_directory/Project.toml`. julia> print(read(""Manifest.toml"", String)); # This file is machine-generated - editing it directly is not advised. [[AbstractFFTs]]; deps = [""LinearAlgebra""]; git-tree-sha1 = ""485ee0867925449198280d4af84bdb46a2a404d0""; uuid = ""621f4979-c628-5d54-868e-fcf4e3e8185c""; version = ""1.0.1"". [[Adapt]]; deps = [""LinearAlgebra""]; git-tree-sha1 = ""f1b523983a58802c4695851926203b36e28f09db""; uuid = ""79e6a3ab-5dfb-504d-930d-738a2a938a0e""; version = ""3.3.0"". [[ArrayInterface]]; deps = [""IfElse"", ""LinearAlgebra"", ""Requires"", ""SparseArrays"", ""Static""]; git-tree-sha1 = ""2fbfa5f372352f92191b63976d070dc7195f47a4""; uuid = ""4fba245c-0d91-5ea0-9b3e-6abc04ee57a9""; version = ""3.1.7"". [[Artifacts]]; deps = [""Pkg""]; git-tree-sha1 = ""c30985d8821e0cd73870b17b0ed0ce6dc44cb744""; uuid = ""56f22d72-fd6d-98f1-02f0-08ddc0907c33""; version = ""1.3.0"". [[BFloat16s]]; deps = [""LinearAlgebra"", ""Test""]; git-tree-sha1 = ""4af69e205efc343068dc8722b8dfec1ade89254a""; uuid = ""ab4f0b2a-ad5b-11e8-123f-65d77653426b""; version = ""0.1.0"". [[Base64]]; uuid = ""2a0f44e3-6c83-55bd-87e4-b1978d98bd5f"". [[CEnum]]; git-tree-sha1 = ""215a9aa4a1f23fbd05b92769fdd62559488d70e9""; uuid = ""fa961155-64e5-5f13-b03f-caf6b980ea82""; version = ""0.4.1"". [[CFTime]]; deps = [""Dates"", ""Printf""]; git-tree-sha1 = ""bca6cb6ee746e6485ca4535f6cc29cf3579a0f20""; uuid = ""179af706-886a-5703-950a-314cd64e0468""; version = ""0.1.1"". [[CUDA]]; deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CompilerSupportLibraries_jll"", ""DataStructures"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""LLVM"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""MacroTools"", ""NNlib"", ""Pkg"", ""Printf"", ""Random"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""TimerOutputs""]; git-tree-sha1 = ""e4b37e96b0ff53f46b13b49d7e9091b154757dc4""; uuid = ""052768ef-5323-5732-b1bb-66c8b64840ba""; version = ""2.4.3"". [[Cassette]]; git-tree-sha1 = ""742fbff99a2798f02bd37d250",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:422,Adapt,Adapt,422,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,"New parameters for `RiBasedVerticalDiffusivity` in this PR as well @simone-silvestri . https://user-images.githubusercontent.com/15271942/227622141-c682b9d5-8848-4f3d-9734-aa258463b2f3.mp4. Note the TKE variable has no dynamics, just a passive tracer for ri-based.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3016#issuecomment-1483311126:203,variab,variable,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3016#issuecomment-1483311126,1,['variab'],['variable']
Modifiability,Nice adaptations. I agree with modifying the NaNchecker as a stop criteria (which outputs also the NaN location). No need to have simulations timestepping with NaNs,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2048#issuecomment-968916615:5,adapt,adaptations,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2048#issuecomment-968916615,1,['adapt'],['adaptations']
Modifiability,"Nice!. I was actually going to advocate for adding such a utility because I've found myself running a few tests where the time steps are likely to be diffusion limited:; 1. possibly stratified Couette flow sometimes,; 2. the Pearson vortex test from PR #336,; 3. more recently the [forced flow test](https://github.com/climate-machine/Oceananigans.jl/blob/5355044deae3120134b55cc20f6e38f637eea6a5/test/verification/forced_flow.jl) from (Brown, Cortez, & Minion, 2000) that I'm using to test whether our operator-splitting method is second-order accurate in both velocity and pressure. For geophysical flows, the time step will almost always be limited by advection, but there seem to be many other flows where the time step will be limited by diffusion. So if we want a package that is usable for not just geophysical flows, it would be nice to have adaptive time stepping that works with both advective and diffusive CFL.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/360#issuecomment-526919951:850,adapt,adaptive,850,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/360#issuecomment-526919951,1,['adapt'],['adaptive']
Modifiability,"Nice, yeah I agree it's now more ""modeling advice"". I think it might be very useful to have a ""Tips and tricks"" section with general advice on diagnosing why your model blows up, how to determine which resolution is ""enough"", how to tell if you're resolving the dynamic of interest, when/how to use sponge layers, seeding initial conditions with noise, etc. Just an accumulation of practical advice we've found useful put in one place. I guess some things are more appropriate to discuss than others, but I know for example that the MITgcm mailing list gets lots of questions about model blowup. A useful paragraph or two in the documentation can help answer a lot of these questions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/354#issuecomment-526919245:306,layers,layers,306,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/354#issuecomment-526919245,1,['layers'],['layers']
Modifiability,"No need to apologize! To extend a method, you can `import` it:. ```julia; import Oceananigans.Grids: with_halo. with_halo(halo, ibg::ImmersedBoundaryGrid) = ImmersedBoundaryGrid(with_halo(halo, ibg.grid), ibg.immersed_boundary); ```. Alternative syntax is. ```julia; using Oceanigans.Grids. Grids.with_halo(halo, ibg::ImmersedBoundaryGrid) = ImmersedBoundaryGrid(with_halo(halo, ibg.grid), ibg.immersed_boundary); ```. These are identical and the difference is just a matter of style. Syntax for namespace management is documented here: https://docs.julialang.org/en/v1/manual/modules/#using-and-import-with-specific-identifiers,-and-adding-methods",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844531769:25,extend,extend,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844531769,1,['extend'],['extend']
Modifiability,"No worries about the late response! Here's a couple of comments, might have more later. > The current implementation I have going projects the velocity into tangential and normal directions (with respect to the immersed surface) before interpolating over the boundary. Since the boundary can be pretty variable in made more sense for us to take this approach. So the user would specify what they want the two tangential and 1 normal direction to be instead of (u,v,w) specifically. Right, this is what I mean by having an ""abstraction for vectors"" --- awesome! If the momentum equation is treated in vector form then the three components are coupled. User specification is then on the vector momentum equation; users will specify `VelocityBoundaryConditions` (rather than boundary conditions for each component, and `VectorForcing`, rather than forcing on each component. It may also make sense to coalesce the kernels that compute tendencies for each velocity component (but I'm less sure about that). Either way this is a major change to the API at the very least, but probably necessary and something we also need for complex domains for GCM simulations, like the cubed sphere. > the original idea was to infer Flux from Gradient. This makes sense for a continuous immersed boundary where it's not possible to _discretely_ specify fluxes. If we can't discretely specify fluxes, we have to rely on a diffusivity extracted from the specified turbulence closure. This is simple for closures that have isotropic diffusivities, but gets more complicated for closures with anisotropic / tensor diffusivities. Even worse is supporting flux boundary conditions for the case that a closure doesn't use a diffusivity at all... Note also that flux boundary conditions are used almost exclusively except for direct numerical simulation, so this is indeed an important consideration. > I know this is a little different than the fitted version, because it's a little harder to specify a normal direction in that",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850559517:302,variab,variable,302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850559517,1,['variab'],['variable']
Modifiability,"No worries, thanks for checking through it!. The `δˣ` operator has been deprecated in some sense in favor of `δˣz2f` and `δˣf2z` for now which know about cell centers and cell faces (might only be on the fixing-nonhydrostatic-algorithm branch). Once the nonhydrostatic algorithm works and I can refactor it nicely we should just be using in-place `δˣz2f!` and `δˣf2z!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/9#issuecomment-440086558:295,refactor,refactor,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/9#issuecomment-440086558,1,['refactor'],['refactor']
Modifiability,None other than it requires typing the code and adding a test or two. Are you suggesting extending the capabilities of `FieldSlicer`? I think that's a nice idea if so!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-809903134:89,extend,extending,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-809903134,1,['extend'],['extending']
Modifiability,"Not _exactly_ sure why it was [1][3], but if `u_init` was an active variable at one point then we we would want to get its derivative which is there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438773709:68,variab,variable,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438773709,1,['variab'],['variable']
Modifiability,"Not really, it will call the fallback. But it's no cost to just have an adapt there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2178696246:72,adapt,adapt,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2178696246,1,['adapt'],['adapt']
Modifiability,"Not working yet --- we have to be able to calculate the isopycnal slope inside the vertically-implicit diffusion solver, so need some refactoring.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2487#issuecomment-1112130751:134,refactor,refactoring,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2487#issuecomment-1112130751,1,['refactor'],['refactoring']
Modifiability,"Note that `.=` between different arrays is `copyto!` and `convert(CuArray, A)` tends to be better written as `adapt(CuArray, A)`. The former will lose structure if you have `A==Transpose{CuArray}`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/174#issuecomment-482187814:110,adapt,adapt,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/174#issuecomment-482187814,1,['adapt'],['adapt']
Modifiability,"Note, the `Checkpointer` currently does not save field location --- it only serializes the field data:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/OutputWriters/checkpointer.jl#L170. For a clean implementation of this feature, you'll need to extend the `Checkpointer` to also serialize the field location (and indices). Then you can use something like. ```julia; parent_data = file[""$name/data""]; loc = file[""$name/location""]; indices = file[""$name/indices""]; data = offset_data(parent_data, grid, loc, indices); model_field = model_fields[name]. if with_halos; copyto!(parent(model_field), parent_data); else; set!(model_field, data); end; ```. which extends these lines. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/OutputWriters/checkpointer.jl#L215-L217",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659135376:290,extend,extend,290,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659135376,2,['extend'],"['extend', 'extends']"
Modifiability,"Note: I discovered a bug in the specification of the 'model configuration' (the viscosity and diffusivity coefficients were swapped). This bug does not affect the other regression tests or dynamics tests (which assume equal viscosities and diffusivities), but it does affect this regression test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/239#issuecomment-496210533:60,config,configuration,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239#issuecomment-496210533,1,['config'],['configuration']
Modifiability,"OK! I'll review this!. so in Oceananigans terms is the `e-ϵ` parameterization, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3605#issuecomment-2159268527:61,parameteriz,parameterization,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3605#issuecomment-2159268527,1,['parameteriz'],['parameterization']
Modifiability,"OK, I added some tests for variably spaced grids as well. @glwagner, what do you think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3054#issuecomment-1615844030:27,variab,variably,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3054#issuecomment-1615844030,1,['variab'],['variably']
Modifiability,"OK, let me put my 2 cents. If we have the validations in the docs just because of the animations then we should just put the animations on YouTube or somewhere and point people there. Having the non-working versions of, e.g., `lid_cavity.jl` script in the repo and in the docs has lead many new users in the rabbit hole of figure it out. Then users feel that scripts are not working, sometimes they post an issue or ask in Slack. But who know how many other users are simply discouraged. Personally, if I download a code that includes non-working pieces of code I am very discouraged. Thus, bottom-line: I see @glwagner's point that the functionality or pipeline for maintaining healthy validations scripts (even a subset of them) then *only those* should be included in the Docs. `Sandbox`: I'm so against a `sandbox` directory! It's like keeping your trash bin in your house for ever in case there is something useful there. I used to to it all the time: I'd keep commented out code in my scripts... But I think it's a bad practice. We need to let go. The repository and the tagged versions should not include half-bake scripts and what not. I'm happy with a sandbox repository `Oceananigans.jl-sandbox` where we keep things. Or a `sandbox` branch even. Regarding this PR and what's should be kept in the Docs: I vote we keep the convergence tests in the docs and nuke the validations. I agree with the git history size issue and probably the method of including the `.png` files that @ali-ramadhan suggests would work -- I've never done it though. (btw, @ali-ramadhan, I've noticed an increase in the repo's size recently... :()",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872556231:782,Sandbox,Sandbox,782,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872556231,5,"['Sandbox', 'sandbox']","['Sandbox', 'sandbox']"
Modifiability,"Oh ya. This is solved for sure by `BuoyancyField`. Strictly speaking density is not constant. The Boussinesq equations are an asymptotic expansion around a constant density, in which only the first effect of variable density is retained (the gravitational acceleration such variations impart) and other effects are ignored. Due to this reduction of the equations of motion, however, the density cannot always be reconstructed. More over it is linearly related to buoyancy via. ```; density = reference_density * (1 - b / g); ```. where `b = BuoyancyField(model)` and `g = buoyancy.gravitational_acceleration` when `buoyancy::SeawaterBuoyancy`. Linear equations of state do not have `reference_density` (it is arbitrary); however `buoyancy` terms with nonlinear equations of state should use `buoyancy.equation_of_state.reference_density`. I am fine to require users to use this formula, rather than providing an implementation of `DensityField` on top of `BuoyancyField`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/516#issuecomment-702304811:208,variab,variable,208,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/516#issuecomment-702304811,1,['variab'],['variable']
Modifiability,"Oh yeah right... Well, I don't know any ""good reference"". I've seen some people use an ad-hoc ""boundary layer depth"" of few tenth's of meters. In isopycnal coordinates (e.g. mom6) one uses the depth of the bottom layer, or an average of the fluid layers within e.g. 10 meters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1974#issuecomment-917622445:247,layers,layers,247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1974#issuecomment-917622445,1,['layers'],['layers']
Modifiability,"Oh yeah that should work. I'll wait and see what your implementation looks like then. I agree that something like `set_surface_temperature!(model, 300)` looks much more user-friendly and portable!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/5#issuecomment-439149399:187,portab,portable,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/5#issuecomment-439149399,1,['portab'],['portable']
Modifiability,"Ok @navidcy I've updated the parameters. For the sake of documentation: these parameters were obtained by calibrating CATKE against 5 LES from LESbrary's ""4 day suite"" at 8m resolution. The defaults are now the ""best"" parameters at the end of that calibration. The last iteration of the calibration produced these plots:. <img width=""687"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/155354710-33778efc-b52a-4fdb-a54d-e9ba97c4bda1.png"">. The blue line is the forward solution produced by a column model with CATKE using the best parameters. The TKE is a bit off, and the velocity profiles aren't ""perfect"" (still very good); but the buoyancy profiles are near perfect. I have some ideas for improving CATKE further, but it's going to take a bit of time. I think moving forward the right approach is to always use CATKE's default configuration for experiments. Then, whenever we update CATKE we'll take a new version. That way we can figure out what CATKE flavor we used by referencing the Oceananigans version. Also for documentation, here's a screenshot of the parameter values from the end of the calibration:. <img width=""1549"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/155355188-089d306f-32ae-46ed-a5e1-f70d3b16f4df.png"">. The defaults were copied from that screenshot. @navidcy I think @rafferrari is referring to any time-step constraints that CATKE might impose. You should be prepared to take short time-steps between 10s and 1 minute during the initial stages of the simulation (while the TKE profile is rapidly adjusting to the initial condition + forcing). Hopefully we can take longer time-steps later on.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2273#issuecomment-1048925824:852,config,configuration,852,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2273#issuecomment-1048925824,1,['config'],['configuration']
Modifiability,Ok great then I think this is close. I'll just add a `Project.toml` to the new validation directory (hopefully eventually we will transition all validation directories to this more maintainable state).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1837207940:181,maintainab,maintainable,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1837207940,1,['maintainab'],['maintainable']
Modifiability,"Ok here's a little more insight into the problem. The issue is actually with `view`, which doesn't work when called on windowed field. `view` can only _create_ a windowed field from a full field, right now. In other words, `view` cannot act on a `view`. Haha. I'm extending `view` to work correctly when the argument itself is already windowed. This is probably the issue with outputting the free surface too. I can't remember exactly what went wrong there though. The output issue could also hint that things are more convoluted than they should be. Still though, we should be able to create views into fields that are already views. It should be fine.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2090900577:264,extend,extending,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2090900577,1,['extend'],['extending']
Modifiability,"Ok if its just for a quick test rather than extended work, that makes sense",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3555#issuecomment-2069564427:44,extend,extended,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3555#issuecomment-2069564427,1,['extend'],['extended']
Modifiability,"Ok, I'll open a PR that refactors the interface for file splitting.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000127066:24,refactor,refactors,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000127066,1,['refactor'],['refactors']
Modifiability,"Ok, this change doesn't work because we actually pass the `closure` and `buoyancy` to `apply_flux_bcs!`, right now:. https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/Models/HydrostaticFreeSurfaceModels/compute_hydrostatic_free_surface_tendencies.jl#L42-L43. This is for models like CATKE that have boundary conditions which depend on the closure... which extend `getbc`... https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/tke_top_boundary_condition.jl#L19-L20. So I think to make this change we also need to generalize the implementation of `DiscreteBoundaryFunction`. We would need to have a type that indicates whether or not we should somehow truncate the `args` that are passed to `fill_halo_regions!` (in that generalization, the pattern on `main` would be the special case that all the args after the first 2 are discarded). ## Nota bene. A different solution one might invent would _copy_ `model.closure` and `model.buoyancy` into CATKE's `TKETopBoundaryConditionParameters`. The reason this doesn't work is that we support _changing_ the parameters of `model.closure` after creating the model. (This is a nifty feature that makes calibration a lot more efficient.) This means that we always need to get the closure parameters from `model.closure` to be consistent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3630#issuecomment-2189717780:397,extend,extend,397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3630#issuecomment-2189717780,1,['extend'],['extend']
Modifiability,"Okay finally tests passed!. @navidcy I tried restarting the tests over and over (honestly more than 10 times over the past few days) and they always failed. I could only make them pass this morning when I restarted them one at a time. That is, starting one, and only restarting the next failed test when the previous one had fully run. So maybe the variability we see in tests has to do with different processes trying to access the same resources... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223676543:349,variab,variability,349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223676543,1,['variab'],['variability']
Modifiability,"Okay so this MWE reproduces the error:. ```julia; using NCDatasets. a = reshape([1.], 1, 1, 1); b = dropdims(a, dims=(1, 2, 3)). ds = NCDataset(""/tmp/test.nc"",""c""); time = defDim(ds,""time"",Inf); v = defVar(ds,""temp"",Float32,(""time"",)); ds[""temp""][1] = b. close(ds); ```. However, if I create a variable without an unbouded dimension (i.e. without time) and do the same thing, it works properly:. ```julia; using NCDatasets. a = reshape([1.], 1, 1, 1); b = dropdims(a, dims=(1, 2, 3)). ds = NCDataset(""/tmp/test.nc"",""c""); v = defVar(ds,""temp"",Float32,()); ds[""temp""][] = b. close(ds); ```. So I think this is an edge case that NCDatasets doesn't yet handle well. I'm gonna create an issue there and see what they say.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2857#issuecomment-1362066454:294,variab,variable,294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857#issuecomment-1362066454,1,['variab'],['variable']
Modifiability,"Okkkk round 2. Let's see if this makes more sense. ```julia; # Two-parameter stretching:; h★ = 0.5 # controls spacing near surface (higher means finer spaced); Δh = 0.25 # normalized height where stretching becomes significant (here, 1/4 of domain height). h₀(k) = h★ + (1 - h★) * (k - 1) / (Nz + 1) # linear normalized height; h(k) = h₀(k) * tanh((k - 1) / (Δh * Nz)) / tanh(1 / Δh) # bottom-stretched normalized height. z_faces(k) = Lz * (h(k) - 1); ```. Hopefully that produces something more sensible. EDIT: ~~I guess this parameterization only works for small values of `Δh` (otherwise the grid is invalid). I'll keep thinking --- I think we can just replace the bottom-stretching function (the tanh) with something better behaved.~~ Fixed that in the above. Another issue is that spacing is linear near the bottom for large `Δh` so only the middle is stretched. So we could try a three-parameter function instead (maybe not worth it for this PR...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867783861:527,parameteriz,parameterization,527,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867783861,1,['parameteriz'],['parameterization']
Modifiability,"On a refactoring note, currently `ZDirection` is defined here https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L6. Which is after `Coriolis/coriolis.jl` is compiled. I think it makes more sense to move this definition to `Grids`. Everyone okay with that? That way any other module can use it (and I can use in Coriolis). I also think would be useful to use something like `validate_vertical_unit_vector()` to validate the rotation axis: https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L37. So I was thinking of moving this to `Utils` (or maybe even `Grids`?) and renaming it to `validate_unit_vector()`. Since this would be refactoring code, I'll wait for some feedback before doing these modifications.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464:5,refactor,refactoring,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464,2,['refactor'],['refactoring']
Modifiability,"On another note, the deep convection regression test is disabled right now as it's waiting for a truly portable random number generator #219 but maybe a better approach is to just save the initial condition to disk like you did here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/239#issuecomment-496246270:103,portab,portable,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239#issuecomment-496246270,1,['portab'],['portable']
Modifiability,"On the user interface side, @simone-silvestri discussed a refactor that would implement something like:. ```julia; # To fix the number of substeps at 200; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(200)). # To fix the number of substeps according to CFL criteria, given the time-step passed to simulation; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(simulation_Δt=2minutes, cfl=0.7)). # Fixed time-step (variable number of substeps); free_surface = SplitExplicitFreeSurface(time_step=FixedSize(cfl=0.7)); ```. Do you have any feedback on that? Partly, this was motivated by my own confusion with the API. (Note, we also discussed some internal changes like getting rid of `settings`.) One detail is that we shouldn't have to pass `grid` because the free surface already must be ""materialized"" on the model grid in order to allocate memory for fields. My opinion is that we _either_ should pass `grid` and cut out the materialization, or we should not pass `grid` and materialize under the hood. But not both because that's the worst of both words (less convenient for users, complicated under the hood). We're waiting for #3125 to do this since there are some changes introduced there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342:58,refactor,refactor,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342,2,"['refactor', 'variab']","['refactor', 'variable']"
Modifiability,"One extra consideration is that we also allow users to specify diffusive fluxes across boundaries. This is especially important for geophysical problems at LES scales and larger, where its appropriate to employ a ""wall model"" to predict momentum and tracer fluxes at boundaries where there's an unresolved or partially-resolved turbulent boundary layer (rather than prescribing a particular value or gradient). That said, I think if we are able to specify the gradients of a field across a boundary it will likely be straightforward to extend that implementation to specifying fluxes. The paper. > [""Moving from momentum transfer to heat transfer – A comparative study of an advanced Graetz-Nusselt problem using immersed boundary methods""](https://www.sciencedirect.com/science/article/pii/S0009250918306250) by Lu et al. (2019). may also be relevant. Their conclusion is a bit confusing. They state. > In all simulations, excellent agreement are reached between CFM and DFM results, with the deviation being below 10%. which suggests that _accuracy_ may not be an important factor in deciding which method to use. But the next sentence is. > Considering the nature of capturing the discontinuity at the fluid-solid interface, DFM might offer a more accurate result, which however requires more follow-up simulations to give a solid investigation. which is difficult to interpret. I suppose all they can say is that their results are similar to one another, but they cannot say which one is more accurate (and perhaps it doesn't matter which method is more accurate in their case, if both methods return similar results). That said, I think time-step considerations are really important, and seem like a good reason to choose DFM over CFM. . Balaras (2004)'s pressure equation is. <img width=""868"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/95799302-36f2c280-0cc2-11eb-9342-a2b47a1cfdfa.png"">. where, crucially, `Ω` is the _computational_ domain (irrespective of the immersed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707401128:536,extend,extend,536,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707401128,1,['extend'],['extend']
Modifiability,"One idea to avoid a huge amount of refactoring could be to define something like. ```julia; default_float_type = Ref(Float64); ```. Then to change to float32 we'd write. ```julia; Oceananigans.default_float_type[] = Float32; ```. Next, everywhere we've written `FT=Float64` we change to `FT=default_float_type[]`. Basically that adds a global variable that users can modulate at the top of a script. We'd also have to introduce type parameters here and there wherever `Float64` was hardcoded (eg `TimeInterval`). Note this is also a reason not to do clock updates with some kind of higher precision it would seem (which we have discussed a bit to solve some rounding errors)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732204898:35,refactor,refactoring,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732204898,2,"['refactor', 'variab']","['refactoring', 'variable']"
Modifiability,"One thing that might be easier to ask for help with his, I wanted to print out the norm of the perturbation buoyancy in both cases. When we evolve the perturbation this is easy, but when we evolve the total field, I couldn't figure out how to do it. Do you have a recommendation? . This would be helpful to determine how the norm changes with resolution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708512691:140,evolve,evolve,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708512691,2,['evolve'],['evolve']
Modifiability,Or maybe to adapt the default based on the incoming grid?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3806#issuecomment-2399820164:12,adapt,adapt,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806#issuecomment-2399820164,1,['adapt'],['adapt']
Modifiability,"Out of curiousity, how much work is it to implement RK3 for `HydrostaticFreeSurfaceModel`?. Seems like fixing AB2 for variable time steps isn't too difficult if it's just changing how $G^{n+1}$ is computed though. > Why don't we answer this once and for all, there are not two answers to this question. I thought this was answered quite clearly, albeit for a very idealized case, here: https://github.com/CliMA/Oceananigans.jl/pull/945#issuecomment-692706814 Is AB2 still technically only first-order accurate?. I know it's quite difficult to extrapolate from the convergence test to global simulations, but my experience has been that RK3 beats out AB2 for non-hydrostatic simulations. That said, it's probably still good to have AB2 especially if it can support variable time steps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418029947:118,variab,variable,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418029947,2,['variab'],['variable']
Modifiability,"PR is ready to be reviewed/merged now I think. Pretty sure the main issue turned out to be a problem with saving the `1×1×Nz` result arrays from calling `(::Average)(model)` to NetCDF variables with dimensions `(""xC"", ""time"")`, so I should have been dropping singleton dimensions before writing to NetCDF. Once I fixed this by calling `dropdims` before writing `Average` results to NetCDF, the problem disappeared (see below). I wasn't able to reproduce the issue in isolation with NCDatasets.jl at the REPL and not sure why it only became an issue in this PR... Instead of calling `dropdims` before writing data to NetCDF, an alternative could be to provide a `reshape` option to the `Average` diagnostic which could be seen as introducing bloat into the `Average` diagnostic but it may have other uses in the future. ---. ```; <xarray.DataArray 'T' (time: 4, zC: 256)>; array([[19.001953, 19.005859, 19.009766, ..., 19.990234, 19.994141, 19.998047],; [19.001953, 19.005859, 19.009766, ..., 19.990234, 19.99413 , 19.960477],; [19.001953, 19.005859, 19.009766, ..., 19.990234, 19.994097, 19.922942],; [19.001953, 19.005859, 19.009766, ..., 19.990235, 19.993974, 19.885847]]); Coordinates:; * zC (zC) float64 -99.8 -99.41 -99.02 -98.63 ... -0.9766 -0.5859 -0.1953; * time (time) float64 0.0 603.0 1.206e+03 1.803e+03; Attributes:; units: °C; longname: Horizontally averaged temperature; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/859#issuecomment-683222865:184,variab,variables,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/859#issuecomment-683222865,1,['variab'],['variables']
Modifiability,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:27,adapt,adapt,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851,19,"['Adapt', 'adapt', 'extend']","['Adapt', 'adapt', 'adaptions', 'adaptor', 'adapts', 'extend']"
Modifiability,"Perhaps a more concise and extendable implementation would be. ```julia; compute!(collection::Union{Tuple, NamedTuple}) = map(compute!, collection); ```. inspired by [Adapt](https://github.com/JuliaGPU/Adapt.jl/blob/ff4419424b6b48b4440c5235f5a4070880fcdf79/src/base.jl#L3)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1928751483:27,extend,extendable,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1928751483,3,"['Adapt', 'extend']","['Adapt', 'extendable']"
Modifiability,"Perhaps start a git repo and post a link to it? It's best to include the julia environment you're using with the file (otherwise it will go stale as Oceananigans evolves). If you want to just post the file then you can use a [gist](https://gist.github.com), or copy/paste the code here if its short.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1296014219:162,evolve,evolves,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1296014219,1,['evolve'],['evolves']
Modifiability,"Perhaps we rename all variables to `closures` when they are tuples of 2 elements or more? Just a suggestion, feel free to ignore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2551#issuecomment-1126166730:22,variab,variables,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2551#issuecomment-1126166730,1,['variab'],['variables']
Modifiability,"Perhaps worth stating here that I think RK3 is vastly superior to AB2 not only because of the faster time-to-solution but also because it is ""self-starting"" (does not depend on tendencies from previous time-steps), checkpointing is cheaper and simplified, and the chance of bugs (which cost us nearly 6 months during parameterization development in the past) wherein ""restarted"" simulations can fail when the prior tendencies have NaN _even_ if we attempt to start with an Euler time-step. So RK3 is both faster _and_ simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441607679:317,parameteriz,parameterization,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441607679,1,['parameteriz'],['parameterization']
Modifiability,"Perhaps, there is no need for an environment variable that modify the filename, instead this is something that could be done if the user is using a checkpoint. But rather than using this convoluted workflow that will require renaming and deleting files, I thought the optimal implementation is to append to the previous existing file when using checkpoints. If the filename is `vel_fields.nc`, the expected files after the second pickup should be:; ```; vel_fields_part1.nc vel_fields_part3.nc vel_fields_part5.nc ; vel_fields_part2.nc vel_fields_part4.nc ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391960027:45,variab,variable,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391960027,1,['variab'],['variable']
Modifiability,"Playing around with an internal wave test case I think we actually need todo something more like the adaptive boundary described in section 4.1 of this paper https://doi.org/10.1016/S1463-5003(00)00013-5 as I have come across two problems: when the flow is directed out of the domain on a prescribed interface (e.g. u = cos(pi/h(z+h)) then information can't get out, and on the ""Orlanski"" side where information is travelling into the domain I am getting instability as it is just keeping the boundary value constant which by default is zero. This might present some more user interface issues as it is going to require us to set a ""known"" value on every open boundary unless we're confident that the flow will only be leaving.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971287155:101,adapt,adaptive,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971287155,1,['adapt'],['adaptive']
Modifiability,"Pressure is different from other variables because it doesn't have a dedicated `compute!` function. I do actually think it would be nice to ""regularize"" the code in this way by making the pressure (and eddy diffusivities) into `KernelComputedField`s (or other kinds of special fields) so that `compute!` works on them in the same way it works on other `ComputedField`s. The reason it is different is because while we have always had pressure auxiliary variables, `ComputedField`s are only a relatively recent addition to the code. In fact, it hadn't even occurred to me that it would be nice if we could use `compute!(hydrostatic_pressure)` until recently. More on the top of this issue, there is a small difference between the two kernels: in one the reference density (which is otherwise arbitrary?) appears to be `1027` and in the other its `1024`. But otherwise I don't see why it wouldn't work and I am a bit stumped.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786242341:33,variab,variables,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786242341,2,['variab'],['variables']
Modifiability,Pretty sure what I wrote will work. May need `adapt` as well.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3840#issuecomment-2402599146:46,adapt,adapt,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3840#issuecomment-2402599146,1,['adapt'],['adapt']
Modifiability,"Probably not the best use of time to try to get `reverse` to work. But if someone is interested in looking further, we can see that `reverse` starts by building a new object with `copymutable`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L59-L60. `copymutable` works correctly because it relies on 1) `similar` and 2) `copyto!`, both of which we define for `Field`. So that's nice, showing the power of extending those functions. The error that @siddharthabishnu finds occurs because we haven't defined `view` for `CartesianIndices`. This is used by `_reverse`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L95. The fix is pretty easy I think. We simply need to extend `reverse!`:. ```julia; Base.reverse!(f::Field; dims=:) = reverse!(parent(f); dims); ```. This seems to work as expected:. ```julia; julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.14945052605940137; -0.25420686637327716; 0.36399517922432356; -0.03994475992128757; 0.018968176930285508; -0.5607261175546058. julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.5607261175546058; 0.018968176930285508; -0.03994475992128757; 0.36399517922432356; -0.25420686637327716; -0.14945052605940137; ```. But again I don't know why we want reverse for `Field`. Do we?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965:459,extend,extending,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965,2,['extend'],"['extend', 'extending']"
Modifiability,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006:595,parameteriz,parameterization,595,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006,1,['parameteriz'],['parameterization']
Modifiability,Probably something to implement when we have a time stepper that’s more appropriate for adaptive time stepping like RK3?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/431#issuecomment-535903452:88,adapt,adaptive,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/431#issuecomment-535903452,1,['adapt'],['adaptive']
Modifiability,"Problem with coolFFT.jl is that it's fairly slow as it doesn't allow for `plan_fft` and `plan_rfft`, both should be supported by FourierTransforms.jl though, but I don't know how type-flexible they are.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/552#issuecomment-562546446:184,flexible,flexible,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/552#issuecomment-562546446,1,['flexible'],['flexible']
Modifiability,"Re solving the problem with the user interface (eg the `immersed` boundary condition that we currently have) --- @simone-silvestri and I discussed how to implement this, and our tentative plan is to add a new term to the tendency kernels:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tendency_kernel_functions.jl. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/velocity_and_tracer_tendencies.jl. The reason for this approach is to avoid entangling the immersed boundary condition calculations with the existing closure kernel functions. We're not totally sure what the immersed boundary condition stuff will entail and we think this approach will be easier to maintain and extend in the near future. Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675:781,extend,extend,781,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675,2,"['adapt', 'extend']","['adapt', 'extend']"
Modifiability,"Ready to be reviewed. I could not make the oceanic les regression test work for the moment, but we still have to build a bit on this PR so this is a good starting point to not blow up this PR too much. Next steps should be; - include an example (to be ran on the distributed pipeline); - include a tridiagonal solve; - relax the constraints on the divisibility of the grid size by the ranks, this will require a bit of experimenting but it can be easily done by modifying the buffers in `TransposableField` to be of variable size",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2183310740:516,variab,variable,516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2183310740,1,['variab'],['variable']
Modifiability,Regarding vanishing layers: what MOM6 does (I think) is that layers never vanish but they are restricted to have height of 1e-10.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117964473:20,layers,layers,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117964473,2,['layers'],['layers']
Modifiability,"Reply:. > 1. No, non-hydrostatic is good... it's just to double check... ; >; > 2. Yes... either varied grid or topography is fine as long as it works. I guess I should try to test it to see which is the easy way... ; >; > 3. That is ok. Not in an urgent manner. It's perfectly fine to test the non-parameterised eddy resolving case at relative high resolution, since efficiency is the claimed strength of Julia and I want to check how efficient it is as well.; > ; > 4. Naively thought it will just be coating 1-3 nonslip layers by enforcing 0 velocities around the topographic feature, well, if the topographic feature is set correctly.. is it more complicated?; > ; > _Originally posted over email_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/770#issuecomment-640693102:523,layers,layers,523,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/770#issuecomment-640693102,1,['layers'],['layers']
Modifiability,"Right --- the core functions cannot allocate memory. Even `@views` may not be best for the final code because it allocates some memory. I would have written the `xderiv` functions, but I wasn't exactly sure how to deal with the staggered grid --- does the differentiation formula depend on whether the variable is stored at cell centers or cell faces?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/4#issuecomment-437202068:302,variab,variable,302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/4#issuecomment-437202068,1,['variab'],['variable']
Modifiability,"Right `InMemory` is more like a `nothing` backend, there's nothing back there. . On ClimaOcean there's an example how we extended this infrastructure to a particular kind of NetCDF backend: https://github.com/CliMA/ClimaOcean.jl/blob/dd9148a8f702699ddf2947d3a1a094adddbd9bb1/src/DataWrangling/JRA55.jl#L218. The implementation in this PR seems simple enough though. @ali-ramadhan maybe can you provide a little syntax example how you expect this to be used? @navidcy take a look and see what you think",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2314147354:121,extend,extended,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2314147354,1,['extend'],['extended']
Modifiability,"Right, and we are essentially looking for a keyword that the user can use to specify they want to use layers. This keyword can be anything we want, right? . I was advocating for something that seemed intuitive to me but any layered shallow water model is a plus for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1155740343:102,layers,layers,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1155740343,1,['layers'],['layers']
Modifiability,"Right, another reason to allow the user to specify the time attribute when using `NetCDFOutputWriter`. The default `IncompressibleModel` uses seconds so that could be an argument for ""seconds"" being the default for `NetCDFOutputWriter`. But right now it's not configurable by the user so I'll keep this issue open until this is resolved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791012283:260,config,configurable,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791012283,1,['config'],['configurable']
Modifiability,"Right. It serves the same purpose as the `OutputWriter` abstract type. It's dispatched on for functions like `run_diagnostic` and `time_to_run` in PR #352. https://github.com/climate-machine/Oceananigans.jl/blob/908ae4d23ce3e472d03fd69766edc457301df681/src/diagnostics.jl#L6. We did agree to refactor the diagnostics abstraction anyways, so maybe the need for an abstract `Diagnostics` type will disappear. I might hold off on this issue until it's clearer what `diagnostics.jl` will look like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/361#issuecomment-523429721:292,refactor,refactor,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/361#issuecomment-523429721,1,['refactor'],['refactor']
Modifiability,"Run with implicit vertical diffusion and implicit free-surface, 20 minutes time step, 2.8 degree resolution and 18 vertical layers (constant spacing), ""realistic"" bathymetry, 30 years in about 2 hrs. https://user-images.githubusercontent.com/33547697/149965680-be56233d-3a08-4d2b-8115-cdb14edfd1af.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1015517597:124,layers,layers,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1015517597,1,['layers'],['layers']
Modifiability,"Running the example to t = 100 rather than t=150 would yield a quick 2/3. I think we can also decrease the resolution and increase the time-step. The resolution also is not isotropic, which essentially wastes grid points. The x dimension is 2pi but y is width 20. So if we use Ny = 128 then we might as well use something like Nx = 64 or 48. Further decreasing the resolution would also help a lot, because the time steps could be increased. And I think the movie doesn't need to plot so many frames. I think the writing and notation can also be improved. It's confusing to use `L_z` to refer to the reference depth. The `ShallowWaterModel` calls this variable `h`, and it's easy to confuse with the vertical extent of a 3D grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3169#issuecomment-1630755758:652,variab,variable,652,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3169#issuecomment-1630755758,1,['variab'],['variable']
Modifiability,"See also. https://docs.julialang.org/en/v1/manual/variables-and-scoping/. to understand how scoping works, and how using the `const` keyword can help produce performant code when working with global variables. The last example at that link is:. ```julia; julia> const x = 1; 1. julia> f() = x; f (generic function with 1 method). julia> f(); 1. julia> x = 2; WARNING: redefining constant x; 2. julia> f(); 1; ```. which is illustrative.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470672237:50,variab,variables-and-scoping,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470672237,2,['variab'],"['variables', 'variables-and-scoping']"
Modifiability,See this post on how you might define a new `setproperty!` for appropriate types:. https://discourse.julialang.org/t/getproperty-decorations-inheritance-in-0-7/11237/3,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/213#issuecomment-488118692:141,inherit,inheritance-in-,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/213#issuecomment-488118692,1,['inherit'],['inheritance-in-']
Modifiability,"Seems maybe that we want to output to a single file for every MultiRegionGrid, but in some special way by extending stuff in. https://github.com/CliMA/Oceananigans.jl/blob/main/src/OutputWriters/fetch_output.jl. Whatever we do there can then be interpretable by `FieldTimeSeries` to make sense of things. ""reconstructing"" output writers can probably be implemented with function output right now. indices seem like a challenge for the cubed sphere. For simpler stuff I guess we can partition the indices. That'd be just amazing if cuFFTxt works out of the box eh?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116865059:106,extend,extending,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116865059,1,['extend'],['extending']
Modifiability,"Shall we extend the `ShallowWaterModel` type to incorporate single- and multi-layer configs? What other properties does a multilayer shallow water type need? The reduced gravities that correspond to each interface is an obvious one... any other?. The number of layers could be a parameter of the type so we can dispatch on it in various methods. E.g.,. ```julia; mutable struct ShallowWaterModel{N, G, A<:AbstractArchitecture, T, GR, RG, V, U, R, F, E, B, Q, C, K, TS, FR} <: AbstractModel{TS}; number_of_layers :: Int # Number of fluid layers; grid :: G # Grid of physical points on which `Model` is solved; architecture :: A # Computer `Architecture` on which `Model` is run; clock :: Clock{T} # Tracks iteration number and simulation time of `Model`; gravitational_acceleration :: GR # Gravitational acceleration; reduced_gravitational_acceleration :: RG # Reduced gravitational acceleration between for fluid interfaces; advection :: V # Advection scheme for velocities, mass and tracers; velocities :: U # Velocities in the shallow water model; coriolis :: R # Set of parameters for the background rotation rate of `Model`; forcing :: F # Container for forcing functions defined by the user; closure :: E # Diffusive 'turbulence closure' for all model fields; bathymetry :: B # Bathymetry/Topography for the model; solution :: Q # Container for transports `uh`, `vh`, and height `h`; tracers :: C # Container for tracer fields; diffusivity_fields :: K # Container for turbulent diffusivities; timestepper :: TS # Object containing timestepper fields and parameters; formulation :: FR # Either conservative or vector-invariant. function ShallowWaterModel(number_of_layers, grid, all_other_things...); arch = architecture(grid); return new{number_of_layers, typeof(G), typeof(arch), the_rest_of_parameters...}(number_of_layers, grid, arch, all_other_things...); end; end. const SingleLayerShallowWaterModel{N, G, A, T, GR, RG, V, U, R, F, E, B, Q, C, K, TS, FR} = ShallowWaterModel{1, G, A, T, GR, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469071910:9,extend,extend,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469071910,4,"['config', 'extend', 'layers']","['configs', 'extend', 'layers']"
Modifiability,Should be fine. I think the timestepper is flexible enough now to modify `χ` which is nice whereas before it was hard-coded in.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/160#issuecomment-520783782:43,flexible,flexible,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/160#issuecomment-520783782,1,['flexible'],['flexible']
Modifiability,"Should be ready to go when all tests pass. We can wait for PR #2121 to finish and then merge this in. Update. Actually need to finish adapting the solver for the `NonHydrostaticModel` (i.e., the `z_face_solver`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1013367087:134,adapt,adapting,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1013367087,1,['adapt'],['adapting']
Modifiability,Should we extend `mask_immersed_field` for `BinaryOperation`? And for `MultiaryOperation`? This might be useful also for post-processing,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269855711:10,extend,extend,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269855711,1,['extend'],['extend']
Modifiability,"Shouldn't the default be anisotropic diffusion with the anisotrop scaled by; delx, delz. This will be by far the most common model configuration. On Mon, May 27, 2019, 4:04 PM Ali Ramadhan <notifications@github.com> wrote:. > *@ali-ramadhan* commented on this pull request.; > ------------------------------; >; > In src/time_steppers.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/245#discussion_r287873945>; > :; >; > > @loop for j in (1:grid.Ny; (blockIdx().y - 1) * blockDim().y + threadIdx().y); >; > @loop for i in (1:grid.Nx; (blockIdx().x - 1) * blockDim().x + threadIdx().x); >; > - apply_z_top_bc!(top_bc, i, j, grid, ϕ, Gϕ, κ, t, iteration, u, v, w, T, S); >; > - apply_z_bottom_bc!(bottom_bc, i, j, grid, ϕ, Gϕ, κ, t, iteration, u, v, w, T, S); >; > +; >; > + κ_top = κ(i, j, 1, grid, closure, eos, g, u, v, w, T, S); >; > + κ_bottom = κ(i, j, grid.Nz, grid, closure, eos, g, u, v, w, T, S); >; > +; >; > + apply_z_top_bc!(top_bc, i, j, grid, ϕ, Gϕ, κ_top, t, iteration, u, v, w, T, S); >; > + apply_z_bottom_bc!(bottom_bc, i, j, grid, ϕ, Gϕ, κ_bottom, t, iteration, u, v, w, T, S); >; >; > It looks like if you want to impose a z boundary condition that does not; > depend on κ, you still have to calculate κ using the full closure which; > can be expensive if using an LES closure. Not sure how to get around this,; > probably some clever multiple dispatch?; >; > This is probably fine for now as constant Smagorinsky isn't integrated; > yet, and the performance hit probably isn't big enough to worry about right; > now.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/pull/245?email_source=notifications&email_token=AKXUEQURKUBCRVSBQUC2LQDPXQ5FPA5CNFSM4HP6AWMKYY3PNVWWK3TUL52HS4DFWFIHK3DMKJSXC5LFON2FEZLWNFSXPKTDN5WW2ZLOORPWSZGOBZZG3JY#pullrequestreview-242380199>,; > or mute the thread; > <https://github.com/notifications/unsubscri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496297122:131,config,configuration,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496297122,1,['config'],['configuration']
Modifiability,"Side note: hopefully we will have RK3 time stepping at some point, and then we will be able to dramatically improve our adaptive time-stepping as there will be no penalty in updating the step size every time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/802#issuecomment-659699785:120,adapt,adaptive,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/802#issuecomment-659699785,1,['adapt'],['adaptive']
Modifiability,"Since our intention is to make the code as readable as possible, I'd prefer `x=(0, Lx), y=(0, Ly), z=(-Lz, 0)`. We could also use Julia's built-in ranges, which are even more readable. Edit: Ranges wouldn't work with variable grid spacing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/413#issuecomment-533132769:217,variab,variable,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/413#issuecomment-533132769,1,['variab'],['variable']
Modifiability,So I removed `~/.julia` and ran the instantiate before and I got the following output; ```; [45606] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: 0; Installing known registries into `~/.julia`; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.2). Unexpected behavior may occur.; └ @ /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/Manifest.toml:0; Installed GPUArraysCore ─────────────── v0.1.6; Installed Crayons ───────────────────── v4.1.1; Installed Adapt ─────────────────────── v4.0.4; Installed TableTraits ───────────────── v1.0.1; Installed ColorTypes ────────────────── v0.11.5; Installed Scratch ───────────────────── v1.2.1; Installed Preferences ───────────────── v1.4.3; Installed PrettyTables ──────────────── v2.3.2; Installed SentinelArrays ────────────── v1.4.5; Installed CUDA_Driver_jll ───────────── v0.9.1+1; Installed DataAPI ───────────────────── v1.16.0; Installed PooledArrays ──────────────── v1.4.3; Installed Tables ────────────────────── v1.12.0; Installed FixedPointNumbers ─────────── v0.8.5; Installed GPUCompiler ───────────────── v0.26.7; Installed LLVMLoopInfo ──────────────── v1.0.0; Installed IteratorInterfaceExtensions ─ v1.0.0; Installed StaticArraysCore ──────────── v1.4.3; Installed JLLWrappers ───────────────── v1.5.0; Installed InlineStrings ─────────────── v1.4.2; Installed StaticArrays ──────────────── v1.9.7; Installed TimerOutputs ──────────────── v0.5.24; Installed AbstractFFTs ──────────────── v1.5.0; Installed PrecompileTools ───────────── v1.2.1; Installed DataValueInterfaces ───────── v1.0.0; Installed OrderedCollections ────────── v1.6.3; Installed NVTX_jll ──────────────────── v3.1.0+2; Installed CUDA_Runtime_Discovery ────── v0.3.4; Installed LLVMExtra_jll ─────────────── v0.0.30+0; Installed UnsafeAtomicsLLVM ─────────── v0.1.5; Installed LaT,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:642,Adapt,Adapt,642,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,1,['Adapt'],['Adapt']
Modifiability,"So [this section of the docs](https://clima.github.io/OceananigansDocumentation/stable/simulation_tips/#Global-variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters) is misleading (or maybe just plain wrong), no?. We should probably rewrite that with an example using a callable. I think the MWE here would suffice.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2960#issuecomment-1458492186:111,variab,variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2960#issuecomment-1458492186,2,"['rewrite', 'variab']","['rewrite', 'variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters']"
Modifiability,"So in summary, a future effort should take these steps:. 1. Write a function like `substepped_tracers(bgc::AbstractBiogeochemistry)` that can be extended by a hypothetical substepping BGC implementation.; 2. Prototype this concept by implementing a new (hopefully simple, one tracer) BGC model, and prototype the time-stepping algorithm that substeps the tracer forward during `update_biogeocemical_state!`. This should be easy to merge since it only requires defining the one new function `substepped_tracers` for skipping the tracer update. Furthermore, the prototype will demonstrate that the substepping is useful for a stiff problem, and will also develop a substepping scheme. Next, we can consider building an interface for doing the substepping itself, much like we have an interface for doing ordinary time-stepping. That will require a bit more design, but I think the initial prototype will give us a lot of information about the best way to go about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455678251:145,extend,extended,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455678251,1,['extend'],['extended']
Modifiability,"So then should we simply use `SlipVelocity` for the sake of the generality and leave the user to define a function for that velocity that could depend on field variables.; Should we also leave for users to define the way it will diverge at the boundary?; What do you think it could be the simplest example we could use for this validation, @johnryantaylor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830:160,variab,variables,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830,1,['variab'],['variables']
Modifiability,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:903,Adapt,Adapt,903,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260,1,['Adapt'],['Adapt']
Modifiability,"Some of the points that could be in the Goals/Mission section:. - Easy to install, understand and use; - Versatile: model is made in blocks that could be combined and easily configured across scales; - Modern: this might be no independent from the others.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059785806:174,config,configured,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059785806,1,['config'],['configured']
Modifiability,"Some of the validations are failing...?. What previously gave. ```Julia; julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); ERROR: ArgumentError: Must supply extent or x keyword when x-direction is Periodic; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Nothing, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:70; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:98; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:268; [5] top-level scope; @ REPL[3]:1; ```. now it goes through:. ```Julia; julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.0, 1.0) variably spaced with min(Δx)=0.0, max(Δx)=0.0; ├── Periodic y ∈ [1.0, 1.0) variably spaced with min(Δy)=0.0, max(Δy)=0.0; └── Bounded z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699; ```. Note that it creates an x and y coord `[1.0, 1.0)`!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762074777:1509,variab,variably,1509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762074777,2,['variab'],['variably']
Modifiability,"Some pretty promising Lagrangian particle tracking benchmarks!. Couple of takeaways (all assuming a model with 128^3 grid points and QAB2 time stepping):; 1. **Low overhead**: You can advect up to ~100,000 particles on the CPU and up to ~10,000,000 particles on a (Titan V) GPU before the model slows down by more than 30%.; 2. **Great on GPUs**: Seems that the GPU is great for advecting millions of particles. You can advect ~100,000,000 particles and your model only slows down by a factor of 4x. In this scenario, the GPU is ~620x faster than a single CPU core.; 3. Calculated using `(t_100000000 - t_0) / 100000000`, advecting a single particle on the CPU takes ~110 ns while on the GPU it only takes ~0.127 ns. This seems a little too good to be true but I'll double check this. I'll start refactoring this PR using @glwagner's and @zhenwu0728's feedback, but I think it would be really great if we can keep this performance. # Benchmarks. ```; Oceananigans v0.44.1; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23:17 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```. ```; Lagrangian particle tracking benchmarks; ┌───────────────┬─────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ N_particles │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 0 │ 361.749 ms │ 364.041 ms │ 364.293 ms │ 368.854 ms │ 293.44 KiB │ 1876 │; │ CPU │ 1 │ 375.030 ms │ 376.591 ms │ 377.959 ms │ 385.248 ms │ 297.16 KiB │ 1906 │; │ CPU │ 10 │ 377.251 ms │ 380.792 ms │ 387.560 ms │ 443.325 ms │ 297.16 KiB │ 1906 │; │ CPU │ 100 │ 378.867 ms │ 381.194 ms │ 381.328 ms │ 383.461 ms │ 297.16 KiB │ 1906 │; │ CPU │ 1000 │ 378.076 ms │ 384.114 ms │ 383.611 ms │ 388.507 ms │ 297.16 KiB │ 1906 │; │",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975:796,refactor,refactoring,796,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975,1,['refactor'],['refactoring']
Modifiability,Some sandbox stuff might've been added by accident,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-863619586:5,sandbox,sandbox,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-863619586,1,['sandbox'],['sandbox']
Modifiability,"Some stuff later in the docstring is also weird. For example it says. > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:. I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514:97,adapt,adapt,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514,3,['adapt'],"['adapt', 'adaptation']"
Modifiability,Some test pass and it makes no sense. Is it just random test failure past of the test natural variability?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881956216:94,variab,variability,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881956216,1,['variab'],['variability']
Modifiability,"Something a little puzzling to me is that we clearly succeed at type inference when running on the GPU. Do we have a better chance of succeeding there because of `adapt`? We do make some critical simplifications via `adapt`, most notably. https://github.com/CliMA/Oceananigans.jl/blob/f70d0949f7688df89a7f8a9e7d44177cde27091a/src/Fields/field.jl#L400",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480467620:163,adapt,adapt,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480467620,2,['adapt'],['adapt']
Modifiability,"Something else I tried was deleting the `Project.toml` and `Manifest.toml` file as well as `~/.julia`, and after running the following:; ```; using Pkg; Pkg.activate("".""); Pkg.add(""CUDA""); Pkg.instantiate(); using CUDA; ```; I got:; ```; [57577] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA_Runtime_jll/YgJCI/.pkg/platform_augmentation.jl:210; Allocations: 2907 (Pool: 2898; Big: 9); GC: 0; Activating new project at `/glade/derecho/scratch/knudsenl/BottomBoundaryLayer`; Installing known registries into `~/.julia`; Updating registry at `~/.julia/registries/General.toml`; Resolving package versions...; Installed GPUArraysCore ─────────────── v0.1.6; Installed Crayons ───────────────────── v4.1.1; Installed TableTraits ───────────────── v1.0.1; Installed ColorTypes ────────────────── v0.11.5; Installed Adapt ─────────────────────── v4.0.4; Installed Scratch ───────────────────── v1.2.1; Installed Preferences ───────────────── v1.4.3; Installed PrettyTables ──────────────── v2.3.2; Installed CUDA_Driver_jll ───────────── v0.9.1+1; Installed SentinelArrays ────────────── v1.4.5; Installed DataAPI ───────────────────── v1.16.0; Installed PooledArrays ──────────────── v1.4.3; Installed FixedPointNumbers ─────────── v0.8.5; Installed Tables ────────────────────── v1.12.0; Installed LLVMLoopInfo ──────────────── v1.0.0; Installed GPUCompiler ───────────────── v0.26.7; Installed StaticArraysCore ──────────── v1.4.3; Installed TimerOutputs ──────────────── v0.5.24; Installed JLLWrappers ───────────────── v1.5.0; Installed InlineStrings ─────────────── v1.4.2; Installed AbstractFFTs ──────────────── v1.5.0; Installed IteratorInterfaceExtensions ─ v1.0.0; Installed StaticArrays ──────────────── v1.9.7; Installed PrecompileTools ───────────── v1.2.1; Installed DataValueInterfaces ───────── v1.0.0; Installed CUDA_Runtime_Discovery ────── v0.3.4; Installed NVTX_jll ──────────────────── v3.1.0+2; Installed LLVMExtra_jll ───────",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2246012900:868,Adapt,Adapt,868,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2246012900,1,['Adapt'],['Adapt']
Modifiability,"Something fishy is happening. The error is. ```julia; Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64}); ```. This means we created a partially-applied function via `Fix1(adapt, x)`. . This looks like a bug that has to do with some package update, maybe to `Adapt`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041:128,Adapt,Adapt,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041,4,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,"Sorry I didn't mean to criticize this PR, it was more of a general comment. I agree that `fieldsets.jl` and `forcings.jl` will be refactored at some point in the near future. This PR seems ready to be merged if you want to do it. Still waiting to hear from the Julia Slack if CuArrays has a bug. > I don’t immediately see why putting those functions in separate files is helpful for readability, since I find it hard to read code that is spread across many small files. But I’m open to putting them back if my views are idiosyncratic. I think it's more about organization, especially for newcomers. We're pretty familiar with the code so we don't need files to be as neat or organized. But to a newcomer, a code base with a few long/dense files is much harder to understand, it's especially hard to figure out where to find stuff. Having more modular files would make it easier to see what Oceananigans offers and what parts are under the hood. I'm happy working with small or large files, just thinking what might be best for users or potential collaborators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/325#issuecomment-517669594:130,refactor,refactored,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/325#issuecomment-517669594,1,['refactor'],['refactored']
Modifiability,"Sorry about the GPU errors, they're much scarier than they look! Looks like a pretty involved setup so I'll let @glwagner comment on the setup. In this case it looks like Julia is complaining about an `unsupported dynamic function invocation (call to overdub)` in `Fxn_scale` at line 93. ```julia; @inline Fxn_scale(t) = spl_scale(t); ```. which itself is calling some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:917,Adapt,Adapt,917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660,2,"['Adapt', 'variab']","['Adapt', 'variable']"
Modifiability,"Sorry about the confusion @tomchor! Opening a new issue might actually be a good idea since it's true we currently only support a subset of the 3^3 = 27 possible topologies (I went ahead and quoted your post in this new issue). I actually might avoid using the `Flat` topology right now since until it's fully tested (see e.g. #1023). You can substitute `Bounded` for `Flat` and your simulation should do the same thing except it will take up some extra memory and slow down your model by a tiny bit. The functional difference is that halo regions have non-zero size along `Bounded` dimensions (and derivatives are computed along `Bounded` dimensions which will evaluate to zero unless you have some weird boundary conditions). Yeah currently the four supported topologies are:; 1. `(Periodic, Periodic, Periodic)`; 2. `(Periodic, Periodic, Bounded)`; 3. `(Periodic, Bounded, Bounded)`; 4. `(Bounded, Bounded, Bounded)` (unfortunately only works on the CPU, see #1007). We could support all possible topology combinations. The only bottleneck is implementing pressure solver that work for all topologies (see #586). This is on my current list of things to do but is not super trivial (see https://github.com/JuliaGPU/CUDA.jl/issues/119 and possibly related #1170) so it's taking some time... 😅 . Hopefully I can refactor the pressure solver(s) to support all topologies soon but either way it might be good to be explicit about which topologies are actually supported.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1192#issuecomment-732260751:1312,refactor,refactor,1312,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1192#issuecomment-732260751,1,['refactor'],['refactor']
Modifiability,"Sorry for the slow replies, I am currently away. I will put together a MWE when I am back. More out of interest, is there a benefit to passing variables explicitly?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1236299727:143,variab,variables,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1236299727,1,['variab'],['variables']
Modifiability,"Sorry if I'm missing something obvious (still new with the working of Oceananigans/Julia), but I was trying to test this feature and expand it to `BuoyancyTracer` over the weekend and I wonder if this implementation can be made more general. . The way I understand @ali-ramadhan created some functions `g_x` to extract the gravity components in each direction and then used them in the `x_dot_g_b` functions to calculate each component of the gravity acceleration. The thing is that gravity can only be a vector using `SeawaterBuoyancy`. When trying to apply this to `BuoyancyTracer` I found that I'd need to replicate the same feature but with a different name (since, as @glwagner pointed out, `gravitational_acceleration` would be a confusing name when working directly with buoyancy). Also, if you also think issue https://github.com/CliMA/Oceananigans.jl/issues/1372 is relevant, it might be nice to have one unified word/approach for the tilting of the domain. So what do you guys think if this tilting is implement at the `AbstractBuoyancy` level? If I understand correctly all buoyancy types inherit that, right? That way we'd have a keyword for the tilt (maybe `tilt`, `gravitational_direction` or `gravity_projection`) that would default to `(0, 0, 1)` and a similar option could be given to `FPlane`, avoiding confusion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782900312:1100,inherit,inherit,1100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782900312,1,['inherit'],['inherit']
Modifiability,"Sponge layers can be added with the existing API. A 1 line implementation (by defining the forcing function to implement a sponge layer, using the currently provided arguments) is currently possible. What is meant by “arbitrary”?. Strictly speaking, the information available to some forcing function cannot be greater than the union of (arguments to rhs kernel, global variables accessible to the forcing function at model instantiation). . In practice this includes all variables — and this can be implemented with the current API. So perhaps we need a narrow design spec?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/294#issuecomment-504415220:7,layers,layers,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/294#issuecomment-504415220,3,"['layers', 'variab']","['layers', 'variables']"
Modifiability,"Still a work in progress but I updated this PR to reflect the many changes that have happened since I opened it back in June. We have halos in the z direction and the `k` index is being reversed so the operators look much better!. For this PR, I want to focus on refactoring the operators so they can be extended to a vertically stretched grid. Once this is merged, I will open another PR that actually replaces `ops_regular_cartesian_grid.jl` with the new operators and ensures that regression tests pass. This PR is step 3/10 for moving to a vertically stretched grid (#471). Following up on #469, it turns out that `▷` cannot be used in function names, but I found `ℑ` which I'd like to propose to use for interpolation. It's big and distinctive, very easy to type (`\Im`), and is a big scripty `I`. Could be argued that it's used for returning the imaginary part of a complex number, but I haven't seen it used in code before, it's not used by `Base`, and it's unlikely to be confused like this in our code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-544295881:263,refactor,refactoring,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-544295881,2,"['extend', 'refactor']","['extended', 'refactoring']"
Modifiability,Stochastic CI variability? I restarted them...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2222364915:14,variab,variability,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2222364915,1,['variab'],['variability']
Modifiability,"StreamGetCaptureInfo; @ ~/.julia/packages/CUDA/Tl08O/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.jul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2072,adapt,adapt,2072,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,1,['adapt'],['adapt']
Modifiability,"Stuck with this error:. ```; julia> include(""test_enzyme.jl""); MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.22; MPIPreferences.jl: 0.1.11; MPICH_jll: 4.2.3+0. Library information:; libmpi: /Users/gregorywagner/.julia/artifacts/5b62c899cf8329a8d07e8fe6eda96039010046c7/lib/libmpi.12.dylib; libmpi dlpath: /Users/gregorywagner/.julia/artifacts/5b62c899cf8329a8d07e8fe6eda96039010046c7/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version:; MPICH Version: 4.2.3; MPICH Release date: Wed Oct 2 09:35:21 AM CDT 2024; MPICH ABI: 16:3:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --disable-doc --enable-fast=all,O3 --enable-static=no --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features:. Enzyme with CATKEVerticalDiffusivity: Error During Test at /Users/gregorywagner/Projects/Oceananigans.jl/test/test_enzyme.jl:264; Got exception outside of a @test; MethodError: no method matching getindex(::Base.RefValue{Tuple{Base.RefValue{Float64}, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, Nothing, Nothing, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596:602,config,configure,602,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596,1,['config'],['configure']
Modifiability,"Suggestions are definitely welcome for streamlining everything!. Note: in dedalus, this problem is handled by allowing users to accumulate parameters into something like `model.parameters` (in dedalus, this is essentially a dict whose keys are accessible by their names to any function/equation defined with a string expression). Having a ""global-like"" variable (like `model.parameters`) is pretty convenient, but also leads to more complicated code. The more democratic callable object strategy is a bit simpler and more modular, but may involve a slightly more complicated API (though I'm not 100% sure about that --- users must decide!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595948214:353,variab,variable,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595948214,1,['variab'],['variable']
Modifiability,"Summary of latest thoughts:. 1. Change `ParameterizedForcing` to `DiscreteForcing`.; 2. Change `SimpleForcing` to `ContinuousForcing`. Use the field name `ContinuousForcing.func` rather than `ContinuousForcing.forcing`. (This will then be consistent with `DiscreteForcing`.); 3. Change `field_in_signature` to more general a `depends_on` keyword. `ContinuousForcing` functions with dependent fields have the signature `f(x, y, z, t, field1, field2)`, where `depends_on=(:field1, :field2)`.; 4. Use assumed field locations (eg the names `u`, `v`, `w` are special and everything else is a tracer) to infer interpolating functions for the fields in `depends_on`. Move `AbstractOperations/interpolation_utils.jl` to `Operators` so they can be used in `Forcing/`.; 5. Implement a unified interface `Forcing` which permits the construction of both `ContinuousForcing` and `DiscreteForcing`.; 6. Change `ModelForcing` so that ""unwrapped"" inputs `forcing::Function` are automatically wrapped in `ContinuousForcing`. This means that unwrapped forcing functions are assumed to be functions of `x, y, z, t` (rather than a discrete forcing). Users that want to use discrete forcing must wrap their functions via `forcing = Forcing(func, discrete_form=true)`.; 7. Change the constructor for `IncompressibleModel` so that forcing functions are accepted via a `NamedTuple`, similar to boundary conditions. @ali-ramadhan thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/896#issuecomment-698312095:40,Parameteriz,ParameterizedForcing,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/896#issuecomment-698312095,1,['Parameteriz'],['ParameterizedForcing']
Modifiability,"Sure!. ```; (Oceananigans) pkg> status; Project Oceananigans v0.53.0; Status `~/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v3.2.0; [052768ef] CUDA v2.4.1; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.3.2; [e9467ef8] GLMakie v0.1.30; [c27321d9] Glob v1.3.0; [033835bb] JLD2 v0.4.3; [63c18a36] KernelAbstractions v0.5.4; [da04e1cc] MPI v0.16.1; [442fdcdd] Measures v0.3.1; [85f8d34a] NCDatasets v0.11.3; [6fe1bfb0] OffsetArrays v1.6.2; [bac558e1] OrderedCollections v1.4.0; [4a48f351] PencilFFTs v0.12.2; [d330b81b] PyPlot v2.9.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [09ab397b] StructArrays v0.5.0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```. ```; ERROR: LoadError: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928:154,Adapt,Adapt,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928,1,['Adapt'],['Adapt']
Modifiability,"Sure, we can talk about code design at the CliMa meeting. Let me summarize what we've discussed so far:. ## The current design. A ""boundary condition"" is a flux, gradient, or value of a field (`u`, `v`, `w`, `T`, `S`) at the end (`left`, `right`) in a given direction (`x`, `y`, `z`). ### Pros. * Generality: any boundary condition can be specified; * Similarity to the mathematics: this design corresponds to how boundary conditions are specified in PDEs; * Extensibility: the design accommodates changes in *types* of boundary conditions or changes in dimensionality. (Adding new solution variables requires code modification, but that is true throughout the code). ### Concerns. * It's more complicated than allowing only 3-4 possibilities to users; as @johncmarshall54 says:. > It's not obvious to me what a field boundary condition is, vs a coordinate boundary condition.; Fundamentally we are applying boundary conditions to u, v, w, T, and S fields, and that's it. It all seems a bit too complicated. * The hierarchical dependence of this design on parameterized types creates a lot of possibilities for different boundary conditions to be specified, and this is a concern for performance (@ali-ramadhan). * We aren't sure what to call the function (currently `bc.calc`) whose purpose is to return the value of the boundary condition (either the field value, flux, gradient, or whatever) at a given grid point and simulation time. ### Other miscellaneous thoughts. * This PR implements a backend / abstraction system for specifying boundary conditions. For users we can add as much sugar on top as we want. * As we have discussed, the way we implement boundary conditions is intimately connected to the way that we specify equations. This can be seen in the current code (though it is commented out) in that [the lines that specify a no-slip condition depend on the ""vertical viscosity""](https://github.com/climate-machine/Oceananigans.jl/blob/7fb355d77df98e37a80b3e796291fa2856d3e1ce/src/time_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472372026:591,variab,variables,591,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472372026,1,['variab'],['variables']
Modifiability,"Tar`; [8dfed614] Test `@stdlib/Test`; [cf7118a7] UUIDs `@stdlib/UUIDs`; [4ec0a83e] Unicode `@stdlib/Unicode`; [e66e0078] CompilerSupportLibraries_jll `@stdlib/CompilerSupportLibraries_jll`; [deac9b47] LibCURL_jll `@stdlib/LibCURL_jll`; [29816b5a] LibSSH2_jll `@stdlib/LibSSH2_jll`; [c8ffd9c3] MbedTLS_jll `@stdlib/MbedTLS_jll`; [14a3606d] MozillaCACerts_jll `@stdlib/MozillaCACerts_jll`; [05823500] OpenLibm_jll `@stdlib/OpenLibm_jll`; [efcefdf7] PCRE2_jll `@stdlib/PCRE2_jll`; [83775a58] Zlib_jll `@stdlib/Zlib_jll`; [8e850ede] nghttp2_jll `@stdlib/nghttp2_jll`; [3f19e933] p7zip_jll `@stdlib/p7zip_jll`; Precompiling project...; ✗ RecipesPipeline; ✗ Plots; 0 dependencies successfully precompiled in 7 seconds (205 already precompiled); 2 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages; Testing Running tests...; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads; [2023/02/21 06:36:13.652] WARN allowscalar([true]) is deprecated, use `allowscalar() do end` or `@allowscalar` to denote exactly which operations can use scalar operations. -@-> /g/data/v45/nc3020/OC.jl/test/dependencies_for_runtests.jl:71; [2023/02/21 06:36:18.673] WARN allowscalar([true]) is deprecated, use `allowscalar() do end` or `@allowscalar` to denote exactly which operations can use scalar operations. -@-> /g/data/v45/nc3020/OC.jl/test/dependencies_for_runtests.jl:71; [2023/02/21 06:36:18.728] WARN Over-writing registration of the datadep -@-> /g/data/v45/nc3020/.julia/packages/DataDeps/ae6dT/src/registration.jl:15; [2023/02/21 06:36:18.729] WARN Over-writing registration of the datadep -@-> /g/data/v45/nc3020/.julia/packages/DataDeps/ae6dT/src/registration.jl:15; [2023/02/21 06:36:19.136] INFO Running shallow wat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:10688,Config,Configuration,10688,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Config'],['Configuration']
Modifiability,"Tests fail on v0.76.5 on GPU... weird... ```Julia; nc3020@gadi-gpu-v100-0100:/g/data/v45/nc3020/OC.jl$ julia-1.6 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| |; |__/ |. (Oceananigans) pkg> test; Testing Oceananigans; Status `/jobfs/73413669.gadi-pbs/jl_XhyZPR/Project.toml`; [79e6a3ab] Adapt v3.3.3; [6e4b80f9] BenchmarkTools v1.3.2; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [124859b0] DataDeps v0.7.10; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.4.6; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [9e8cae18] Oceananigans v0.76.5 `/g/data/v45/nc3020/OC.jl`; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [91a5bcdd] Plots v1.36.0; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.7; [a759f4b9] TimerOutputs v0.5.19; [bdfc003b] TimesDates v0.3.1; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates `@stdlib/Dates`; [b77e0a4c] InteractiveUtils `@stdlib/InteractiveUtils`; [37e2e46d] LinearAlgebra `@stdlib/LinearAlgebra`; [56ddb016] Logging `@stdlib/Logging`; [44cfe95a] Pkg `@stdlib/Pkg`; [de0858da] Printf `@stdlib/Printf`; [9a3f8284] Random `@stdlib/Random`; [2f01184e] SparseArrays `@stdlib/SparseArrays`; [10745b16] Statistics `@stdlib/Statistics`; [8dfed614] Test `@stdlib/Test`; Status `/jobfs/73413669.gadi-pbs/jl_XhyZPR/Manifest.toml`; [621f4979] AbstractFFTs v1.1.0; [79e6a3ab] Adapt v3.3.3; [4fba245c] ArrayInterface v6.0.1; [30b0a656] ArrayInterfaceCore v0.1.2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:477,Adapt,Adapt,477,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Adapt'],['Adapt']
Modifiability,"Thank you @ali-ramadhan and @glwagner for the solutions. They worked!. However, calling `Model` twice was more memory intensive. I ran into out of memory error. Is the first instance not overwritten when the second instance is defined?. Since I have a uniform grid, I was able to manually define `xC`, `yC`, and `zC` and avoid the out of memory error. . ```julia; # Get location of the cell centers in x, y, z and reshape them to easily; # broadcast over them; xF, yF, zF = collect(0:Lx/Nx:Lx), collect(0:Ly/Ny:Ly), collect(0:Lz/Nz:Lz); xC, yC, zC = 0.5.*(xF[2:end] .+ xF[1:end-1]), 0.5.*(yF[2:end] .+ yF[1:end-1]), 0.5.*(zF[2:end] .+ zF[1:end-1]); xC, yC, zC = reshape(xC, (Nx, 1, 1)), reshape(yC, (1, Ny, 1)), reshape(zC, (1, 1, Nz)). # Set heating flux at the bottom.; Q = 9200 # W/m^2; Rp = 50 # plume radius [m]; r = @. sqrt((xC - Lx/2)^2 + (yC - Ly/2)^2); bottom_flux = zeros(Nx, Ny, 1); bottom_flux[r .< Rp] .= g * ɑ * Q / (ρ₀ * cₚ); bottom_flux = CuArray(bottom_flux). # Create boundary conditions; Tbcs = FieldBoundaryConditions(z=ZBoundaryConditions(; bottom = BoundaryCondition(Flux, bottom_flux))). # Set up the model and use an artificially high viscosity ν and diffusivity κ.; model = Model(N=(Nx, Ny, Nz), L=(Lx, Ly, Lz), arch=GPU(),; bcs = BoundaryConditions(T=Tbcs),; ν=1e-4, κ=1e-4); ```. To accommodate spatially variable boundary conditions, may be `Model` can be split up into a `geometry` component and `dynamics` component?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/314#issuecomment-515246317:1332,variab,variable,1332,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/314#issuecomment-515246317,1,['variab'],['variable']
Modifiability,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:290,variab,variable,290,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962,5,"['Config', 'config', 'variab']","['Config', 'Configuration', 'config', 'variable']"
Modifiability,"Thank you for reply, @glwagner!. > Can you clarify --- is the simulation on the right with the FFT-based _direct_ solver, or is it with a preconditioned conjugate gradient solver that use an FFT as a preconditioner?. On the left is FFT-based direct solver. On the right is the PCG solver with the FFT-based solver as a preconditioner. > My suggestion is to use a preconditioned conjugate gradient solver, with the FFT-based solver as a _preconditioner_ (not as the direct solver). It is what the right panel shows, if I am not mistaken. But the simulation crashed after thousands of iterations. I heard that the PCG solver in Oceananigans has not been widely tested, so that is why I turned to the `HeptadiagonalIterativeSolver`. > As for blow up I think the problem happens for very small time-steps? Perhaps try it without adaptive time-stepping for now and also cap the `max_iterations` as a small number. I am doing more testing on this. It is a different issue though. I will open a new issue if I can find a simple way to reproduce the blow up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071006297:825,adapt,adaptive,825,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071006297,1,['adapt'],['adaptive']
Modifiability,"Thank you for the links !. The Oceananigans src code is very clearly written so the reading is relatively OK (I could use some explanations on your closure usage). If it was up to me I would prefer an extended documentation of GPUifyLoops ;) I only understand how it works by reading what you do with it. . The GPU shared memory is basically a programmable cache while the cache of CPU can't be (easily) controlled. In both cases there is cache so, if you compute multiple partial derivatives of a given (set of) field(s) (d/dx,d/dy, d2/dx2,...) once a block has been fetched in the cache then the memory operations are cheap. Cache is also useful for performing tiny transpositions enabling fast access and vectorized (SIMD) CPU or GPU ops in both X,Y or Z directions. . I hope that obtaining an efficient code for both (multicore SIMD) CPUs and GPUs maybe possible adjusting the (recursive?) block sizes (i.e. controlling the data layout and adapt it to the computing target). I will try to use part of your code to rewrite the toy 2D CFD solver I have translated from Matlab (https://discourse.julialang.org/t/asynchronous-makie/27127/9?u=laurentplagne). Kudos again to your team for this inspiring package. Laurent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518372592:201,extend,extended,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518372592,3,"['adapt', 'extend', 'rewrite']","['adapt', 'extended', 'rewrite']"
Modifiability,"Thank you for the written explanation! Here are my comments:. > to split the bgc tendencies from the rest I needed a way to turn them off in the normal tendency computation, I did this by passing a keyword all the way through to biogeochemical_transitions - when I did it this way the intention was to touch as little of the existing code as possible, but it might not be the cleanest/most maintainable. I don't think we need to change anything in the existing kernels code. Instead, we can design an interface that allows biogeochemical models (like the models implemented in OceanBioME) to ""opt-in"" to a substepping scheme. In this design, there's no need to change the existing ""slow"" kernels I don't think. However, we could consider changing the name of them. For example, all that's needed is for the _implementation_ to know when to return a slow source term vs fast source term. > this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at timestepper.G / $G^-$, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned timestepper.physics.G etc. I'm not sure that new tendencies are needed for substepping. The substepping scheme for CATKE manages to avoid allocating any additional tendencies by preserving the ""slow"" source term:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl#L167-L171. The only change that is needed within Oceananigans (in principle) --- as far as I can tell --- is to skip the tracer update for certain tracers (like we do for CATKE and TKEDissipation):. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L78-L85. Then the ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851:390,maintainab,maintainable,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851,1,['maintainab'],['maintainable']
Modifiability,"Thank you for your feedback @maleadt! What is CUDAnative compilation? If you mean the precompilation phase when CUDAnative is first loaded, then it's not that as I start timing after all packages are loaded. I thought 6-7 minutes was normal/expected as @vchuravy et al. reported similar GPU compilation times for their shallow water model: https://github.com/JuliaLabs/ShallowWaterBench. I haven't done any rigorous benchmarking yet but out of those 6 minutes, ~1.5 minutes are spent on compiling code that creates CuFFT plans (the first plan takes 1.5 minutes then the others take <1 second). From watching the log I'm guessing the other 4.5 minutes are evenly split between setting up the model (creating CuArrays, initializing them, etc.) and the first time step (where the kernels are getting compiled presumably). I don't think we have that many kernels (just 5 bigger ones) but one of them; https://github.com/ali-ramadhan/Oceananigans.jl/blob/2b64d584c79ece0429f2421335ddb6bc0c6c6663/src/time_steppers.jl#L213; has several layers of inlining (it's inlining the majority of the functions in [operators/ops_regular_cartesian_grid_elementwise.jl](https://github.com/ali-ramadhan/Oceananigans.jl/blob/master/src/operators/ops_regular_cartesian_grid_elementwise.jl)) after which it probably balloons up to be a pretty big kernel. They also have tons of arguments crammed in as the structs I was passing weren't `isbitstype` (working on this #59). I should come back and update this issue once we do some proper benchmarking (note to self: nvprof seems like it's being deprecated in favor of Nsight). Caching kernels between sessions sounds tough but will definitely look into timing compilations in CUDAnative, might provide some insight on how to speed things up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/66#issuecomment-466847765:1030,layers,layers,1030,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/66#issuecomment-466847765,1,['layers'],['layers']
Modifiability,"Thanks @Mikejmnez , that is helpful. Any model can do this but I suspect that using `IncompressibleModel` in 2D is probably the best place to start. It is essentially equal to the 2D vorticity equation and does allow for variable shear flow. . I'm guessing you want to start off with a sinusoidal shear and add on a perturbation and see how things evolve? If the flow is supercritical then you will get a shear instability and that will give rise to all sorts of interesting dynamics. Sounds like a fun project and very interested to see what you find!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768524410:221,variab,variable,221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768524410,2,"['evolve', 'variab']","['evolve', 'variable']"
Modifiability,"Thanks @ali-ramadhan. I agree and confirmed that where the derivative is computed on faces and centres, the following line and the line below. This should extend to higher orders of course. https://github.com/CliMA/Oceananigans.jl/blob/ebd7858000c78f7b1754112a68c587e6195e620b/src/Operators/derivative_operators.jl#L18",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741927886:155,extend,extend,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741927886,1,['extend'],['extend']
Modifiability,"Thanks @glwagner and @ali-ramadhan for your suggestions. They all sound very interesting and gives me a lot to think about. Here are my initial reactions. Given that I don't know the numerics of Oceananigans, yet, but know the physics, I can imagine myself contributing to the following pretty quickly:. 1. Shallow Water model (and maybe even a Green-Naghdi version) with several layers for fun.; 2. Layered and stratified Quasi-Geostrophic Model; 3. Hydrostatic Boussinesq Model (rigid lid first and then a free-surface). Something that I can imagine giving to good undergraduate research students would be. 4. Verticall-Implicit time-stepping for diffusion. ; 5. Profiling parallelism. If I had keen student in computer science then maybe . 6. Distributed parallelism with MPI. . I have never used GPU's before but given the efficiency of GPU's vs CPU's that you have in the docs, I am definitely going to learn. Initial thougths on 1 and 2:; I know that FourierFlows has both QG and SW, which are spectrally based. I gather that Oceananigans is Finite Volume based. If I wanted to start with either of these would you suggest I start wtih FourierFlows or ignore that?. I kind of like the idea of having a QG code that can either be FV or Spectral, depending on the users whims, but that might be difficult, depending on how compatable these two libraries are. I suppose I should start in reading the code in detail and planning out what I think needs to be done. Any suggestions are welcome!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724274151:380,layers,layers,380,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724274151,1,['layers'],['layers']
Modifiability,"Thanks @glwagner and I agree, at the last time I definitely see more smaller scale features. Also, I agree that since velocity is always smoother than vorticity, that is perhaps a better field to use. Clever idea!. In the paper you mentioned, equation 33 is the at the core where the nonlinear Coriolis term is rewritten using WENO schemes to rewrite `\omega U_\perp` using WENO. Is this what is the part that is done differently where the velocity is used?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081927354:343,rewrite,rewrite,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081927354,1,['rewrite'],['rewrite']
Modifiability,"Thanks @glwagner for the help. Much appreciated. I tried to adapt it and the good news is that I don't get an error. The bad news is that I don't think the boundary conditions are being set correctly. . Below are a few ideas of things I think I need to do. Maybe you can confirm whether I understand this correctly?. - You had it set up for the sponge to depend on x but if I want the inflow and outflow to be in the south and north, respectively, then it should depend on `y`, right?; - `smoothed_step_mask` is currently only acting on the south. I pressume I need to add a similar function for the north?; - Do I need to have a sponge on `h` as well? I thought imposing this on `vh` might be enough in the case when the flow doesn't vary in the zonal direction. I imagine if I want inflow from the west only, which I do want, and the meridonal velocity depends on the zonal coordiante, then I should pick the sponge to relax to a geostrophically balanced state.; - Even though I am trying to set the inflow/outflow boundary conditions to `vh -> h` so that `v -> 1`, when I look at the final matrix, I have that `vh` is zero everywhere. This tells me that the boundary conditions are not being set. It does seem to say that `vh` does have `NormalFlow` boundary conditions so that seems like something is right. ```; using Oceananigans; using Oceananigans.Grids; using Oceananigans.Models; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. using Oceananigans.BoundaryConditions: NormalFlow. grid = RegularRectilinearGrid(size=(64, 64),; x=(-10, 10), y=(0, 5),; topology=(Periodic, Bounded, Flat)). bump(x, y, z) = y < exp(-x^2); grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). damping_rate = 1/100 # relax fields on a 100 second time-scale; const y0 = 0 # center point of sponge; const dy = 1.0 # sponge width; smoothed_step_mask(x, y, z) = 1/2 * (1 + tanh((y - y0) / dy)). vh_sponge = Relaxation(rate=damping_rate, mask=smoothed_step_mask, target",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852653935:60,adapt,adapt,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852653935,1,['adapt'],['adapt']
Modifiability,"Thanks @glwagner! We haven't been using background velocities in our setups, so won't have as much to say on that yet. But we'll continue testing the background tracer fluxes. @samlewin, are you using background shear in addition to background tracer fields in your configurations, or is the shear just in your initial conditions? This PR might be relevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2276121204:266,config,configurations,266,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2276121204,1,['config'],['configurations']
Modifiability,Thanks @simone-silvestri for adding a GPU test for `FieldTimeSeries`! I've adapted it correctly now and tests pass locally so I think this PR is ready for review. Actually I should add a test that uses the new kwargs. Would do a test where multiple threads open the same `FieldTimeSeries` but don't think we have multi-threaded tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2397361158:75,adapt,adapted,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2397361158,1,['adapt'],['adapted']
Modifiability,"Thanks @tomchor for your feedback. It is greatly apprecaited. For the first point, I completely appreciate that we need to be clear. This can be done in the docstrings but it is certainly nice to pick variable names that are intuitive and make the code easier to read. I think Oceananigans does this very well and I very much want to continue in this direction. . I wonder if something like `zF_stretch` might do the trick? The `zF` suggests the result will be at faces and `stretch` suggests that this is a stretching of some kind. Or maybe `z_Faces_stretched`?. I am sorry if I mispoke. I did not mean to say that users do not care about what kind of stretched grid we use. This is clearly not the case. What I wanted to say is that a beginning user probably would be more concerned about having a stretched grid and probably not so much of the details. Some users would of course care a great deal about the kind of grid, and we definitely want to help both kinds of users. I agree with @glwagner 's suggestion of us supply a few basic examples for people to use, as a starting point. Users should certainly be able to take these examples, build on them, and build whatever kind of stretched grid they want. This is currently available and this should always be the case. When defining our examples we should not only define the region (or regions where we want it stretched, as it shouldn't only have to be one spot), but also the degree to which it decays. I don't necessarily have the language to describe this accurately now, but when putting together a sample function/array, I think a lot of this will beome clearer (to me at least).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145:201,variab,variable,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145,1,['variab'],['variable']
Modifiability,"Thanks for all the context! . Good points about the time step being more restricted by Coriolis for coarse global simulations and error being dominated by spatial discretization. I'd also be very interested how AB2 compares against RK3 for time-to-solution. I guess this could be readily tested with the non-hydrostatic model simulating turbulence. I'd be curious if RK3 is always faster, or if it's case-dependent. Although it is risky to be on the edge of stability CFL-wise. > It may be a research project to adapt the split-explicit free surface. . Ah I didn't realize that RK3 was not really used for global ocean models, especially with a split-explicit free surface :(. > However, also in this form, successive tendencies do not cancel out. Is this neccessary or is this why Quasi AB2 is technically only first-order accurate? I guess right now with Euler steps the tendency terms do cancel out when an AB2 time step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418146640:512,adapt,adapt,512,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418146640,1,['adapt'],['adapt']
Modifiability,"Thanks for bringing these up! This stuff certainly needs some work, and we should probably make it clear what's e.g. a free parameter. > I see a few problems:; > * `f` is not a property of a planet. Agreed. Perhaps now that we're also thinking of channel models on a _β_-plane, we should also build a ""rotation"" abstraction to choose between _f_-plane, _β_-plane, and Coriolis force (possible with cosine term). > * 'Model configuration' is an obscure name for turbulent or molecular transport coefficients. Yes. This should be addressed by incorporating a `TurbulentDiffusivity` struct like the one you proposed in #120. I agree with John that when we do this, isotropic and anisotropic diffusion should be options. > * A reference density is not a parameter in an equation of state.; Hmmm, but if ρ₀ is needed to calculate ρ then isn't it a parameter of the EOS?. Sounds like this issue is worth discussing and strategizing about. We could maybe get some ideas and inspiration from how CliMA.jl is handling parameters?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491642405:423,config,configuration,423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491642405,1,['config'],['configuration']
Modifiability,"Thanks for confirming!. So the two outstanding issues are:. - [ ] Do we want to divide by volumes instead of areas to be more general? (Cosmetic but maybe worth fixing); - [ ] Figure out how the height field should be included to achieve higher accuracy, which neither formulation is able to do.; - [ ] Do we evolve the tracer or thickness weighted tracers?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165836785:309,evolve,evolve,309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165836785,1,['evolve'],['evolve']
Modifiability,"Thanks for embarking on this @glwagner!. > It's a bit of a work in progress. Before merging we need:; > * tests (simple 1D test with temperature to see if budgets are correct?). Just added ""WIP"" (work in progress) to the PR title. We can work on the tests together. For testing, we should be able to extend the 1D column model example: https://github.com/climate-machine/Oceananigans.jl/blob/master/examples/column_model.jl. > Also looks like Travis is failing; not sure why that is. Looks like it's just the one test in the time stepping section that's failing. Maybe something to do with how the boundary conditions are called during the time stepping? The Model test passes so it's not erroring during model initialization/construction. > I propose changing the struct `BoundaryConditions` to `ModelBoundaryConditions` for clarity. I'll always vote for clarity!. Just one initial question: I might be misunderstanding the purpose of `bc.calc` but why not `bc.impose(args...)` instead of `bc.calc(args...)` as we usually say that we _impose_ boundary conditions?. Have to run out but will have a more detailed look later today. Otherwise, looks really neat! On a more practical note, might end up being easier to discuss this PR in person.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-471182606:300,extend,extend,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-471182606,1,['extend'],['extend']
Modifiability,"Thanks for explaining why the `C` values are different, didn't realize that. Not sure where it comes from but shouldn't it be `C_roz = 4/24 = 0.167` or `C_roz = 8/24 = 0.33`?. > I'm open to changing the implementation, but I'm not sure what the best route is. Possibly we will phase out the Rozema version... ?. Not sure how much code overlaps between the two, but if both are deemed important enough to maintain, then the shared functionality can go into `amd_core.jl` or something. Although probably a bad idea to do this refactor before each AMD closure has it's own regression test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526191891:524,refactor,refactor,524,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526191891,1,['refactor'],['refactor']
Modifiability,"Thanks for finding this @navidcy!. Ah, this is annoying but this wasn't actually fixed... Apparently the commit to `gh-pages` is made during `makedocs` while the example file is deleted afterwards. See: https://travis-ci.com/climate-machine/Oceananigans.jl/jobs/262276959#L755-L756. I wonder if it's just better to delete the output file as part of the example, i.e. do it in `ocean_wind_mixing_and_convection.jl`. Thankfully the issue is isolated in the `gh-pages` branch. Thanks for the advice @c42f! Will see if I can rewrite the `gh-pages` branch which sounds like it should be minimally disruptive.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/509#issuecomment-560588037:521,rewrite,rewrite,521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/509#issuecomment-560588037,1,['rewrite'],['rewrite']
Modifiability,"Thanks for looking through the time stepping code, this is great feedback!. I agree it would be nice to dispatch on the array type (or even the architecture, another reason to use types instead of symbols). No reason why `xC, xF, yC, ...` have no assigned type in `RegularCartesianGrid`, just oversight on my part. There will probably be a major refactor of the code's design soon-ish to get all this little stuff right. I remember fields initially had the array type be a parameter, e.g. `CellField{T}` then `data::T` but I hit some performance issues with that I think. I may have just been encountering the [Avoid fields with abstract containers](https://docs.julialang.org/en/v1/manual/performance-tips/index.html#Avoid-fields-with-abstract-containers-1) Julia performance tip, but I think making the parameter an `AbstractArray` as you're suggesting shouldn't sacrifice performance. And yes, the solver is not spectral. Will probably generically call it `PoissonSolver` when the next refactor happens (and the documentation would make it clear what it actually does).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/45#issuecomment-462783213:346,refactor,refactor,346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/45#issuecomment-462783213,2,['refactor'],['refactor']
Modifiability,"Thanks for the additional changes and it seems to be doing much better! Still three tests that fail. I looked ath the initialize environments and saw what I copied below. It seems to have probelms with Oceananigans?. ```. ✗ Oceananigans; --;   | 105 dependencies successfully precompiled in 112 seconds;   | 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package;   | Precompiling project...;   | ✗ Oceananigans;   | 0 dependencies successfully precompiled in 22 seconds. 105 already precompiled.;   |  ;   | ERROR: The following 1 direct dependency failed to precompile:;   |  ;   | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];   |  ;   | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-9773/compiled/v1.8/Oceananigans/jl_yggB5x.;   | [NVBLAS] No Gpu available;   | [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf';   | [NVBLAS] Cannot open default config file 'nvblas.conf';   | [NVBLAS] Config parsed;   | [NVBLAS] CPU Blas library need to be provided;   | ERROR: LoadError: syntax: missing comma or ) in argument list;   | Stacktrace:;   | [1] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/non_traditional_beta_plane.jl:75;   | [2] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [3] include(x::String);   | @ Oceananigans.Coriolis ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:1;   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:28;   | [5] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [6] include(x::String);   | @ Oceananigans ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:5;   | [7] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:230;   | [8] include;   | @ ./Base.jl:419 [inlined];   | [9] include_package_for_output(pkg::Base.Pk",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445:926,variab,variable,926,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445,2,"['config', 'variab']","['config', 'variable']"
Modifiability,"Thanks for the feedback! We were also thinking that if the ocean and atmosphere shared the same vertical indexing then maybe using some shared parameterizations would be easy but as pointed out, vertical indexing isn't necessarily a rigid thing in DG. Also sounds like the ocean and atmosphere don't need to agree as they're arbitrary decisions anyways. Interesting point about setting the vertical index to be the fastest running index to help speed up vertical integrals. We only have one vertical integral in the time stepping core so not sure if it'll make a big difference on the ocean side but something to think about! Might be relevant to #21. We decided to switch our convention and use _k=1_ at the bottom. I'll submit a PR soon with this change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/90#issuecomment-469654068:143,parameteriz,parameterizations,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/90#issuecomment-469654068,1,['parameteriz'],['parameterizations']
Modifiability,"Thanks for the help guys. I also agree with @francispoulin that plotting the mask would make it very helpful! . Here are some thought that I had that might be worth discussing:. 1 - Sponge layers (afaik) should only alter the NS equations in a finite part of the domain, right? Otherwise, even far from the relaxed edge, you're not really solving the NS equations --- it's being modified by an extra unphysical forcing. So one question is: is this really the behavior you want your sponge layer to have? (And here I'm assuming you're using relaxation as a synonym for sponge, because that's what the docs imply.); 2 - The nomenclature is kinda misleading, because `width`, coupled with the wording used in the docs really makes one believe that the effects of the relaxation function are confined to a layer of width `width`. For a reference, here's what's written on the docs:. > We illustrate usage of mask and target by implementing a sponge layer that relaxes velocity fields to zero and restores temperature to a linear gradient in the bottom 1/10th of the domain. Hopefully that makes sense.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733207522:189,layers,layers,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733207522,1,['layers'],['layers']
Modifiability,"Thanks for the questions @simone-silvestri . I'll answer them here as it's probably easier for the discussion. **Q1**: You can certainly solve the equations in the non-conservative form and the method should work. But it does't have any advantages compared to other methods: i.e. doesn't help with conserving anything and does not easily extend to other geometries. **Q2**: The pressure term in the momentum equation is ` 1/\rho_0 \nabla p`. In the case of a rigid lid we have that `p` is the surface pressure. I thought that redefining pressure with ` p/\rho_p -> p` might be easier, to get rid of the constant, but it's easy enough to include the coefficent. We should continue to do whatever Oceananigans is currently doing, and I thought it was absorving the constant density, but I could be wrong. **Q3**: In the shallow water model with a free-surface the pressure is always hydrostatic, `p = p_0 + g \rho_0 (h - z)`, where `h` is the total depth. The case of a rigid lid is a bit different since we just have the surface pressure `p`. You are correct that the free-surface shallow water model is very similar to the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `Vec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:338,extend,extend,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381,1,['extend'],['extend']
Modifiability,Thanks for the suggestions @simone-silvestri! And I noticed you started doing some refactoring in PR #3847 so I'll close this in favor of your PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3830#issuecomment-2412498850:83,refactor,refactoring,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3830#issuecomment-2412498850,1,['refactor'],['refactoring']
Modifiability,"Thanks for your answer, i made some progress by using the JULIA_CUDA_USE_BINARYBUILDER env variable.; The download problem is fixed and CUDA.jl tests passed on the gpu node but i still have some errors with Oceaningans. ```; module load julia cuda; env JULIA_CUDA_USE_BINARYBUILDER=false julia —project; julia> using Oceananigans; julia> grid = RegularCartesianGrid(size=(100, 100, 50), extent=(2π, 2π, 1)); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [-5.496153587253255e-18, 6.283185307179586], y ∈ [-5.496153587253255e-18, 6.283185307179586], z ∈ [-1.0, 1.7080354225002348e-17]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (100, 100, 50); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.06283185307179587, 0.06283185307179587, 0.02). julia> model = IncompressibleModel(architecture=GPU(), grid=grid); ERROR: MethodError: no method matching plan_forward_transform(::CUDA.CuArray{Complex{Float64},3}, ::BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}, ::Array{Int64,1}); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1035#issuecomment-707677672:91,variab,variable,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1035#issuecomment-707677672,1,['variab'],['variable']
Modifiability,"Thanks guys for having a look. > diffusion.jl laplacian.jl and viscosity.jl are not right: should not involve Ax^2 and division by V^2 ; we talked about this already few times so no need to re-do it again. > @ali-ramadhan I took a look to, but kind of stopped at Ax^2 in the diffusion operator! That will just lead to confusion. I think these have to be faithful to div(k(grad(phi))) - otherwise it will get hard to check things. Yes I now see that these are wrong. I convinced myself that when properly using `ΔzC` and `ΔzF` it won't be `Ax^2` and `V^2` anymore so I'll revise these operators and make the docstrings more readable. I got to the wrong operator by implicitly assuming `ΔzC = ΔzF = Δz`. > In coriolis.jl, the comments are misleading since one of the 2 expressions should have a minus sign; to match: ""Operators that calculate the Corolis terms"". cf my old suggestion that has been dropped along the way.; > in ""divergence.jl"", line 25 should be with ""Ax(i+1, j ,k, grid)"" instead of ""Ax(i, j, k, grid)""; ans same issue line 31 and line 41. Thanks for catching these!. > I did not find where ϊx_V⁻¹ is defined. It appears in ""momentum_advection.jl"" (line 31) and should be; computed as 1/(V-averaged) but the notation might suggest (1/V)_averaged. Should be in `interpolation.jl` and it should be 1/(V-averaged) so I'll improve the notation here. > will need to check again when we consider ""practical"" variable resolution (e.g., varable in z); that everything looks good. I agree we can't really test these as is. Might be better to work on the vertically stretched grid first and test/merge them together.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-504566436:1418,variab,variable,1418,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-504566436,1,['variab'],['variable']
Modifiability,"Thanks to @jm-c I think I have a much better idea of how to implement these operators. Also, instead of having all these arcane derivative-type operators I want to refactor them into operators that calculate fluxes then pass them to difference or interpolation operators. I think that should make them a lot more readable and give each operator some physical meaning.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-504611239:164,refactor,refactor,164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-504611239,1,['refactor'],['refactor']
Modifiability,"Thanks! It would be nice though, if the flow field doesn't evolve so that it doesn't get unstable. That way I can look at the effective diffusivities without the 'eddy' perturbation growth. This is a classic approach when deriving effective diffusivities that are purely kinematic within homogenization theory (e.g. Majda and Kramer, 1999). I can prob code this myself, but from this issue it seemed like people were interested...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768531493:59,evolve,evolve,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768531493,1,['evolve'],['evolve']
Modifiability,"Thanks, that's helpful @jagoosw. Just one more thought... I realized after I did the testing for my previous post that the hang occurs at ""Initializing simulation..."". This implies that the problem isn't with any constructors (eg the `Field` constructor above) but rather the actual computations, probably. A big change from 0.85 (which [occurred in 0.88](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.88.0)) is the [introduction of the `KernelParameters` abstraction](https://github.com/CliMA/Oceananigans.jl/pull/3125) for offsetting indices within kernels, used here:. https://github.com/CliMA/Oceananigans.jl/blob/70536571523ad2eb71fd9a2200121eca63998ac4/src/AbstractOperations/computed_field.jl#L78. and I think other places, which @simone-silvestri can advise. `KernelParameters` extends some `KernelAbstractions` functionality in a non-trivial way I think. Maybe there are some things we can improve there:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Utils/kernel_launching.jl. Even if the issue is fixed on 1.10, I think we still ought to understand this problem better since it might come back in the future (things like this often do...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1808580651:797,extend,extends,797,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1808580651,1,['extend'],['extends']
Modifiability,"That could work --- though I'd point out that listing the model components that can be inconsistent with one another might be more explicit. I would advocate for a ""blacklisting"" method whereby blacklisted combinations of components are listed local to the implementation of the component. For example, in `beta_plane.jl` we could add. ```julia; validate_coriolis(::BetaPlane, ::AbstractGrid{FT, TX, <:Periodic}) where {FT, TX} = # error; ```. we also need, in `hydrostatic_spherical_coriolis.jl`,. ```julia; validate_coriolis(::HydrostaticSphericalCoriolis, ::AbstractRectilinearGrid) = # error; ```. I think a warning is better than an error for `WENO5` on a curvilinear grid. That'd be a fun scheme to experiment with and we don't know ""how wrong"" it is. If the curvilinear grid is almost regular, we have reason to think it might work. In cases like these where we aren't completely, rock-solid positive that a certain model configuration is invalid I think we should also err conservative and allow such models to be constructed. . We do need to strike a balance between being helicopter parents to users, and catching common mistakes. I don't think we should get in the business of curating science --- we should just provide useful software. Specialty applications can just avoid the kwarg-based constructor so I'm not sure we should worry much about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847:929,config,configuration,929,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847,1,['config'],['configuration']
Modifiability,That was just an example. There's a lot of erroneous usage. This might help:. ```; (base) gregorywagner:src/ (glw/fix-adapt) $ grep -r unroll ./* [11:11:55]; ./Advection/Advection.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Advection/stretched_weno_smoothness.jl: @unroll for j = 1:3; ./Advection/stretched_weno_smoothness.jl: @unroll for j = 1:3; ./BoundaryConditions/fill_halo_regions_open.jl:# and need to unroll a loop over the boundary normal direction.; ./BoundaryConditions/fill_halo_regions.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./BoundaryConditions/fill_halo_regions_periodic.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for i = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for j = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for k = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for i = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for j = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for k = 1:H; ./BoundaryConditions/fill_halo_regions_flux.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Fields/regridding_fields.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Fields/regridding_fields.jl: @inbounds @unroll for k = 1:target_grid.Nz; ./Fields/regridding_fields.jl: @unroll for k_src = k₋_src:k₊_src-1; ./Fields/regridding_fields.jl: @inbounds @unroll for j = 1:target_grid.Ny; ./Fields/regridding_fields.jl: @unroll for j_src = j₋_src:j₊_src-1; ./Fields/regridding_fields.jl: @inbounds @unroll for i = 1:target_grid.Nx; ./Fields/regridding_fields.jl: @unroll for i_src = i₋_src:i₊_src-1; ./Fields/field_boundary_buffers.jl:using KernelAbstractions.Extras.Lo,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874436155:118,adapt,adapt,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874436155,1,['adapt'],['adapt']
Modifiability,"That was the main issue we discussed in #2740 with locating the free surface at `grid.Nz+1`. . (from #2740); > Well the issue is that if we want to save the output at the surface `(:, :, grid.Nz)` we cannot include the free surface if this is defined at `grid.Nz+1` (it would not exist at `grid.Nz`). ... `grid.Nz+1` won against `grid.Nz` so, for the moment, you should define two different `OutptWriters`, one for grid-sized variables and one for the free surface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1267430238:426,variab,variables,426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1267430238,1,['variab'],['variables']
Modifiability,"That was used for smoothness indicators on variable grids (the previous `stretched_smoothness` in `WENO5(grid = grid, stretched_smoothness=true)`). I temporarily removed that keyword because it assumed that WENO was order 5. (also we weren't using it because it made everything quite slow). I had the plan to reintroduce it with the upcoming advection refactor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2747#issuecomment-1256262527:43,variab,variable,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2747#issuecomment-1256262527,2,"['refactor', 'variab']","['refactor', 'variable']"
Modifiability,"That's a good point @glwagner - I think it's a mix of CI tests and more involved experiments. Some of these can be easily integrated in to CI since they are very cheap to run. A one level wind-driven gyre should take only a few minutes of run time to equilibrate sufficiently. Full simulations from option 3 are almost certainly too heavy for CI (unless there are plans afoot to use external resources for CI). These sort of simulations are more likely to be run occasionally and interrogated by real eyeballs. Having said that, you could setup CI to run a few time steps and compare the output with blessed output - this is what MITgcm does for its CI tests. This comes with a couple of advantages:; - the tests are useful setups for people to start using; and; - because they run regularly (for at least a few time steps) you know when the examples break. I like your idea of designing a forcing that exactly cancels the expected tendencies. It is a more rigorous test than ""is the output the same as it was when I decided it was correct?"". > Is the algorithm in Oceananigans.jl identical to some configuration of MITgcm? If so that opens the possibility to compare a solution grid-point for grid-point. This might work, but you'll need to decide how closely it should match. You definitely won't get machine precision matches - we can't even do that with different MITgcm runs. The output from MITgcm depends on the machine, the compiler, and the optimisation level.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467570923:1099,config,configuration,1099,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467570923,1,['config'],['configuration']
Modifiability,"That's great news @ali-ramadhan . I guess by looking at your code I can learn how to adapt it to `ShallowWaterModel`. Maybe I will start by doing some tests for the two-dimensional turbulence example, or has someone done that already? By that I mean checking scalabiilty.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786696921:85,adapt,adapt,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786696921,1,['adapt'],['adapt']
Modifiability,"That's great that you want to do this @apaloczy ! I am also happy to help if I can. I think that @glwagner explained it very well. One question I will raise is, do we prefer to have to have height as a variable, or the free surface, which is more consistent with the hydrostatic model?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1114360766:202,variab,variable,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1114360766,1,['variab'],['variable']
Modifiability,"That's interesting. I think this could actually be solved when #902 is resolved, since I believe the 0/0 leading to NaNs would be elided in that case?. I think it does make sense to permit specification of a single coordinate in a `Flat` dimension. This is appropriate for a ""slice"" model. Note that a ""slice"" is not the only idealization that leads to a `Flat` topology --- an alternative idealization is a domain that is uniform in one direction (which includes domains that are infinitely extended in the `Flat` direction). But slices are important and I think we should support it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/940#issuecomment-692221057:492,extend,extended,492,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/940#issuecomment-692221057,1,['extend'],['extended']
Modifiability,"That's true, there's been a ton of refactoring so it's probably more than just one thing that's changed (I can't say for sure that my changes didn't slow things down). No point worrying too much until we get around to profiling (#162).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/147#issuecomment-479848626:35,refactor,refactoring,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/147#issuecomment-479848626,1,['refactor'],['refactoring']
Modifiability,"The Julia docs go into a lot of detail and have a useful summary (https://docs.julialang.org/en/v1.5/manual/modules/#Summary-of-module-usage-1) but I think `import` is used with the intention of extending a method via multiple dispatch. So you would `import Flux: σ` if you wanted to define a new method for `σ`, e.g. if you wanted to define a custom `σ(x::Complex)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1285#issuecomment-755264366:195,extend,extending,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1285#issuecomment-755264366,1,['extend'],['extending']
Modifiability,"The MIT grid seems to just copy the metrics from the first cell... ```; julia> grid = ConformalCubedSphereGrid(cs32_filepath, CPU(), Nz=1, z=(-1, 0));; ┌ Warning: ConformalCubedSphereGrid is experimental: use with caution!; └ @ Oceananigans.CubedSpheres ~/Research/OC.jl/src/CubedSpheres/conformal_cubed_sphere_grid.jl:163. julia> fgrid = grid.faces[1]; 32×32×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 1×1×1 halo and with precomputed metrics; ├── longitude: FullyConnected λ ∈ [-45.0, 44.0312) variably spaced with min(Δλ)=80152.3, max(Δλ)=3.23804e5; ├── latitude: FullyConnected φ ∈ [-45.0, 42.2888) variably spaced with min(Δφ)=80152.3, max(Δφ)=3.23804e5; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> fgrid.Δxᶠᶠᵃ[0:3, 0:3]; 4×4 Matrix{Float64}:; 80152.3 80152.3 1.36265e5 170108.0; 80152.3 80152.3 1.36265e5 170108.0; 1.33313e5 1.33313e5 1.51133e5 1.76175e5; 1.69174e5 1.69174e5 1.75781e5 1.90232e5; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384647750:545,variab,variably,545,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384647750,2,['variab'],['variably']
Modifiability,"The Thomas algorithm will work with variable del z and variable diffusion. I have implemented one of these methods for OceanTurb:. https://github.com/glwagner/OceanTurb.jl/blob/master/src/solvers.jl. This method is documented on wikipedia:. https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm. Won't these work for Oceananigans? Are we using a more restrictive method (for some reason)? I don't know how the other methods are related to the Thomas algorithm, but the Thomas algorithm is O(n) --- fast.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/587#issuecomment-572744995:36,variab,variable,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/587#issuecomment-572744995,2,['variab'],['variable']
Modifiability,The `SplitExplicitFreeSurfaces` module is only temporary here for easier manipulation and refactoring of the code. We can remove it if we decide we don't want the free surface in a module,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3894#issuecomment-2451588537:90,refactor,refactoring,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3894#issuecomment-2451588537,1,['refactor'],['refactoring']
Modifiability,"The advection-like Coriolis scheme was a non-sequitur because `f` is a very regular field, so upwinding it was just decreasing performance without a significative increase in quality of the simulation. On the other hand, upwinding `u` is very much discouraged because the energy builds up rapidly (by upwinding the velocity the divergence of the reconstructed tangential velocity is not a direct interpolation of the divergence of the original velocity, which is a necessary condition to maintain the algorithm stable). The only thing I can think to increase the order of velocity interpolation in the Coriolis force is to use a centered high-order scheme to interpolate velocity, but that would not help with the noise since a centered scheme is dispersive in nature. . I converted this PR to implement a `WetPointCoriolisScheme` (described in [Numerical boundary layers and spurious residual flows](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/JC091iC09p10621)). ; This is just a simple addition to an enstrophy conserving scheme where edge (""dry"") points are neglected in the interpolation of the velocity in the tangential direction. A comparison of the output of this scheme in a global 1 degree setup will follow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272:865,layers,layers,865,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272,1,['layers'],['layers']
Modifiability,"The buoyancy is actually a buoyancy perturbation, showing the growth of diffusive boundary layers + waves. But the viscosity and diffusivity help dissipate the grid scale waves so that larger scale waves dominate later on.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442594450:91,layers,layers,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442594450,1,['layers'],['layers']
Modifiability,"The climate machine shallow water model used DG numerics. I agree with Greg; that it would be nice to do a side-by-side comparison of two; numerical approaches to the same underlying equations. Not sure it used a; Bernoulli formulation.; john; ps Francis - great that you are involved with oceananigans!. On Fri, Nov 13, 2020 at 11:53 AM Gregory L. Wagner <notifications@github.com>; wrote:. > 2. Climate Machine also has a shallow water model; > <https://github.com/CliMA/ClimateMachine.jl/blob/master/src/Ocean/ShallowWater/ShallowWaterModel.jl>.; > I don't know the details of what this does but I should probably learn how; > the two models will differ.; >; > I'm not 100% sure how its implemented but I think at the end it'd be great; > if both ClimateMachine and Oceananigans shallow water models used the same; > equation set, since we can then compare the numerics. We don't have the; > bandwidth to develop the ClimateMachine shallow water model, but possibly; > at the time the Oceananigans has a nice one we'll be motivated to flesh out; > ClimateMachine's model.; >; > I'm not sure about immersed boundaries --- does the method generalize in a; > simple way? I'm not sure whether a special treatment is required for the; > height field, compared to an ordinary velocity variable, or tracer.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726873787>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQWKUQJEBFEYXSOVQO3SPVQABANCNFSM4TQVNFEA>; > .; >. -- ; ==========================================; John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726894931:1282,variab,variable,1282,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726894931,1,['variab'],['variable']
Modifiability,"The connectivity creates a ""cartesian grid"" of ranks which informs us which ranks are spatial neighbours. ; The more general way to arrange this grid, in absence of any other information is to wrap around the ranks as if the cartesian rank grid was `Periodic`. This is enough information for parsing the rank configuration, but not enough to perform fill halo regions. ; For this, we need a grid! Only with a grid, we will know if some directions are Bounded or Periodic, so, leveraging this information we can correctly assess which boundaries need communicating or not. Philosophically speaking, architecture provides the general rank layout while the grid concretizes this information ; leveraging the topology to decide whether to perform halo passing or not. Practically speaking the implementation leverages an `inject_halo_communication_boundary_conditions` implemented here:; https://github.com/CliMA/Oceananigans.jl/blob/34a3b930e0ace7df7dc7660f9c74f52315f41da7/src/DistributedComputations/halo_communication_bcs.jl#L14; previously only the connectivity was passed to this function, while this function should require also grid information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187:309,config,configuration,309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187,1,['config'],['configuration']
Modifiability,"The construction `Field(Average(op; dims))` allocates memory only for the result, and not for intermediate variables. So volume averages should not allocate much memory if constructed this way. Also note that you usually want to give abstract operations to output writers directly rather than `Field(abstract_op)`, because this will reduce memory allocation when you request sliced output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301497803:107,variab,variables,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301497803,1,['variab'],['variables']
Modifiability,"The convention we use for the other variables stored on faces is that our ""interior"" data spans from `i=1` to `i=N`. Thus we call the `i=N+1` a ""halo point"" for fields on faces, even though it really is not (its on the boundary, see #455). . In addition, we use a convention that face indices are ""left"" of cell indices. Thus `iFace=1` corresponds to the ""left"" boundary of the domain. `iCell=N` is the rightmost cell in the domain; and `iFace=N+1` corresponds to the rightmost boundary. Why do you want ""direct"" access to the surface at `k=Nz`? Can you explain why you want this? This is confusing to me and I don't see why we would want to have an odd and surprising convention for the vertical coordinate. The fact is simply that the face at `i=N` is a very concrete and real place. It lies in the interior of the domain, to the left of the cell point `i=N`. This is a fact of our grid and must be internalized by anyone who wants to work with the discrete data and index fields directly by raw index. If/when we use named axis conventions for `fields` (see #457), we would be able to access the surface via `u[Z(At(0))]` (or some syntax like that. We can also create an alias `Surface() = Z(At(0))`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542223106:36,variab,variables,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542223106,1,['variab'],['variables']
Modifiability,The conversation around metrics is still unsettled. AFAICT there's no way to put those in the SGRID variable. There are [CF conventions](http://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#cell-measures) for `cell_measures`: specifically `area` and `volume` but we would also need length. There is a `cell_thickness` standard_name that could be used for this. cc @jbusecke,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1480009990:100,variab,variable,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1480009990,1,['variab'],['variable']
Modifiability,"The definition of `ParameterizedForcing` is. ```julia; struct ParameterizedForcing{F, P}; func :: F; parameters :: P; end. (F::ParameterizedForcing)(i, j, k, grid, clock, state) = F.func(i, j, k, grid, clock, state, F.parameters); ```. easy peasy.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595944975:19,Parameteriz,ParameterizedForcing,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595944975,3,['Parameteriz'],['ParameterizedForcing']
Modifiability,The difference between this parameterization and the currently implemented `TwoDimensionalLeith` parameterization is that the diffusivities are user-provided rather than being a 3D field that's computed from the vorticity and divergence. That's why this parameterization is actually a simplification of `TwoDimensionalLeith`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1972#issuecomment-916410470:28,parameteriz,parameterization,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1972#issuecomment-916410470,3,['parameteriz'],['parameterization']
Modifiability,"The easiest way to add additional fields into a forcing is to create them before the forcing, eg. ```julia; eddy_diffusivity = CenterField(grid); ```. Such a field can be passed into a forcing function as a parameter, for example. (It can also be captured inside a function as a global variable). To use this, you'll have to use the ""discrete form"" forcing. More on that in the docs: https://clima.github.io/OceananigansDocumentation/stable/model_setup/forcing_functions/. To compute this field, write a callback,. ```julia; function compute_eddy_diffusivity(sim); νₑ = sim.model.diffusivity_fields.νₑ; Pr = sim.model.closure.Pr; parent(eddy_diffusivity) .= parent(νₑ) ./ Pr; return nothing; end; ```. Next add the callback to the simulation,. ```julia; add_callback!(simulation, compute_eddy_diffusivity); ```. By default the callback is called every time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2095186354:286,variab,variable,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2095186354,1,['variab'],['variable']
Modifiability,The issue is pretty general but here's an example; https://github.com/ali-ramadhan/Oceananigans.jl/blob/6ec7cc23393bd5fdce846e1b3eb601fcd1901af4/src/clock.jl#L1-L5. `Clock` should be `Clock{T} where T <: Number` then `time` and `Δt` should be of type `T`. This isn't the only struct that needs to be refactored in this way.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/19#issuecomment-462840687:300,refactor,refactored,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/19#issuecomment-462840687,1,['refactor'],['refactored']
Modifiability,"The issues with the `HydrostaticFreeSurfaceModel` are the tendency kernels. The difference with the non-hydrostatic model is that we do not know a priori which RHS function to call (for example CATKE has an `:e` tracer that requires a different RHS function and the same goes with a 1 equation parameterization of mesoscales that evolves an additional tracer equation for the mesoscale energy `:K`). Our solution now is to infer the RHS function and pass it as an argument to the kernel. Apparently, this prevents compilation. I ll come up with a solution today",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1485231926:294,parameteriz,parameterization,294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1485231926,2,"['evolve', 'parameteriz']","['evolves', 'parameterization']"
Modifiability,"The main advantage of having `DiskTimeSeries` in `Oceananigans` would be to use it in examples without depending on another package. I think the implementation of `DiskTimeSeries` is light. It also _requires_ certain features (for example, location metadata must be saved by `JLD2OutputWriter` for `DiskTimeSeries` to work). This tight coupling between `DiskTimeSeries` and `OutputWriters` could motivate including `DiskTimeSeries` in `Oceananigans.jl`. Other aspects of analyzing Oceananigans data might be more appropriate in another package. I'm not exactly sure what specific features are up for debate in this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-809902405:336,coupling,coupling,336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-809902405,1,['coupling'],['coupling']
Modifiability,"The more I think about it, the more I like the idea of an environment variable to have a ""pickup mode"". Let's see what others think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120302022:70,variab,variable,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120302022,1,['variab'],['variable']
Modifiability,"The next one I ran into is https://github.com/CliMA/Oceananigans.jl/blob/00f028bb37f13692e24921588aeb8a9150f6dd55/src/Advection/reconstruction_coefficients.jl#L215. So one alternative is to use named tuples instead of variables. ```; @inline function compute_reconstruction_coefficients(grid, FT, scheme; order). method = scheme == :Centered ? 1 : scheme == :Upwind ? 2 : 3. rect_metrics = (:xᶠᵃᵃ, :xᶜᵃᵃ, :yᵃᶠᵃ, :yᵃᶜᵃ, :zᵃᵃᶠ, :zᵃᵃᶜ). if grid isa Nothing; coeffs = (; (m => nothing for m in rect_metrics)...); else; metrics = coordinates(grid); dirsize = (:Nx, :Nx, :Ny, :Ny, :Nz, :Nz). arch = architecture(grid); Hx, Hy, Hz = halo_size(grid); new_grid = with_halo((Hx+1, Hy+1, Hz+1), grid); coeffs = (; (rect_metric => calc_reconstruction_coefficients(; FT, getfield(new_grid, metric), arch, getfield(new_grid, dir), Val(method); order = order); for (dir, metric, rect_metric) in zip(dirsize, metrics, rect_metrics))...); end. return tuple(coeffs...) # actually return named tuple to be order invariant; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3556#issuecomment-2064446102:218,variab,variables,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3556#issuecomment-2064446102,1,['variab'],['variables']
Modifiability,"The numbers look right (I'm not sure about the sign). This won't work for variable grid spacing though?. In the other boundary condition functions the diffusivity is called `κ`. Might be best to use `κ` here for consistency. What I was going to say:. The flux divergence contribution from the wall is `flux / Δc`, and the `flux` at the bottom (for example) is. ```; flux = -2 * κ * (c_bottom_cell - c_bndry) / Δf; ```. Note that we define flux so that the contribution to the RHS is minus the flux divergence.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/166#issuecomment-483772305:74,variab,variable,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/166#issuecomment-483772305,1,['variab'],['variable']
Modifiability,"The only distinction is that in the `VectorInvariantFormulation` (that evolves $u$ and $v$) you want to compute; $h^{-1} \nabla \nu h \nabla t$,; while in the `ConservativeFormulation` (that evolves $uh$ and $vh$) ; $\nabla \nu h \nabla t$",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2941#issuecomment-1443856384:71,evolve,evolves,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2941#issuecomment-1443856384,2,['evolve'],['evolves']
Modifiability,"The origin of this reference heat capacity is explained around equation 3.3.3 in this document:. https://unesdoc.unesco.org/in/documentViewer.xhtml?v=2.1.196&id=p::usmarcdef_0000188170&file=/in/rest/annotationSVC/DownloadWatermarkedAttachment/attach_import_3378fdfe-50b7-4e53-8795-fafc7913dcc0%3F_%3D188170eng.pdf&locale=en&multi=true&ark=/ark:/48223/pf0000188170/PDF/188170eng.pdf#%5B%7B%22num%22%3A298%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C-93%2C846%2C0%5D. Section 2.20 in that document discusses the isobaric heat capacity. Does the ""correct"" heat capacity then depend on our interpretation of the variable `T` in `Oceananigans.jl` (and therefore on the values we choose for the thermal expansion coefficient and saline contraction coefficient)? It's all a little unclear to me. . Note also that the TEOS-10 document uses `α` for the thermal expansion coefficient. The variable `βΤ` is [sometimes used to denote the 'isothermal compressibility'](https://en.wikipedia.org/wiki/Specific_heat_capacity#Relation_between_heat_capacities).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/190#issuecomment-525582098:616,variab,variable,616,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/190#issuecomment-525582098,2,['variab'],['variable']
Modifiability,"The reason that the advection term is the only term account for is because this is typically what one wants. If you want diffusion to act on the entire temperature profile (not just the perturbation), then perhaps you shouldn't use a background field at all. Instead you should initialize the temperature to `T(z) = N^2 * z + T'(z)` where `T'(z)` is the perturbation and evolve the entire temperature field. This is more correct anyways... Background fields are useful when one wants to consider either some kind of (implicit) forcing that maintains the background field, preventing it from evolving. If we include a diffusion term associated with the background field, then we defeat much of the purpose of having a background field feature in the first place. The same is true for boundary conditions. One important use case for background fields is when we can set up a problem where the perturbation is periodic even though the background is not. In that scenario the total field is not periodic, and we could not use a periodic domain. Enter `BackgroundFields`: decomposing the solution into background + perturbation allows us to model the perturbation in a periodic domain with periodic boundary conditions. If the periodic boundary condition were defined as a boundary condition on the total (background + perturbation), then we wouldn't be able to achieve this important case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2081949716:371,evolve,evolve,371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2081949716,1,['evolve'],['evolve']
Modifiability,"The solution is not too difficult, except for one annoying detail: if boundary conditions contain references to model fields, this means that `field.boundary_conditions` contains a circular reference. I guess we can work around this by giving boundary conditions a reference to field data, rather than the field itself. This preserves existing functionality and so its fine. We will, however, have to rewrite `VelocityFields` and `TracerFields` to a single `VelocityAndTracerFields` constructor, and perform the requisite gymnastics there. There are also challenges if users want to create `VelocityFields` and pass them to the model. I suppose we'll have to re-wrap the user-created data for that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/971#issuecomment-708092162:401,rewrite,rewrite,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/971#issuecomment-708092162,1,['rewrite'],['rewrite']
Modifiability,"The way I implemented it, the matrix ""constructors"" are saved in the solver without the variable diagonal term. Basically the constructors include all the terms except for the term that varies with the time step which is saved in `solver.diagonal`. ; i.e. the `Dᵢⱼₖ` in; ```; Axᵢ₊₁ ηᵢ₊₁ + Axᵢ ηᵢ₋₁ + Ayⱼ₊₁ ηⱼ₊₁ + Ayⱼ ηⱼ₋₁ + Azₖ₊₁ ηₖ₊₁ + Azₖ ηⱼ₋₁ ; - 2 ( Axᵢ₊₁ + Axᵢ + Ayⱼ₊₁ + Ayⱼ + Azₖ₊₁ + Azₖ ) ηᵢⱼₖ ; + ( Cᵢⱼₖ + Dᵢⱼₖ/Δt^2 ) ηᵢⱼₖ = b; ```. Every time that the time step changes this is the operation that is performed:; ```; constructors = deepcopy(solver.matrix_constructors); M = prod(solver.problem_size); update_diag!(constructors, arch, M, M, solver.diagonal, Δt, 0); solver.matrix = arch_sparse_matrix(arch, constructors) ; ```. So the matrix is constructed from a copy of the updated constructors. In this way there is no need to subtract anything to the diagonal because `solver.matrix_constructors` does not include the diagonal term. . `update_diag!` adds `Dᵢⱼₖ/Δt^2` to the diagonal elements. . If you want to do the something analogous with the linear operation, remove the time dependent term from it. Then add it separately with `update_diag!` every time the time step changes. Of course you want to make sure that you have elements in your diagonal, non trivial if `Cᵢⱼₖ` because a sparse matrix removes 0 elements. check out this function ; `ensure_diagonal_elements_are_present!(sparse_matrix)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403:88,variab,variable,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403,1,['variab'],['variable']
Modifiability,"The wizard uses `new_time_step`, which is correctly extended within `MultiRegion` ; https://github.com/CliMA/Oceananigans.jl/blob/40ac9d0efff7a0c877df652e3f9114fe53693bc2/src/MultiRegion/multi_region_models.jl#L63-L66.; I haven't extended `cell_advection_timescale` yet. Also, I haven't yet extended `interior`, because data can live on different GPUs, so `interior` should not be used if not after `reconstruct_global_field`.; Maybe I can add `cell_advection_timescale` to multi region, but then I have to extend also `cell_diffusion_timescale` and the extension of `new_time_step` has to be deleted. I ll think about the pros and the cons. ; For every function that does not work in `MultiRegion`, in the meantime, you can wrap it with `@apply_regionally` and you'll get a `MultiRegionObject` containing the local equivalent. In this case; ```; @apply_regionally new_Δt = wizard.cell_advection_timescale(model); new_Δt = minimum(new_Δt.regions); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304946176:52,extend,extended,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304946176,4,['extend'],"['extend', 'extended']"
Modifiability,"Then you can just load in your ""bottom"" from the `ImmersedBoundaryGrid` and set that to; ```; bottom[ bottom .>0 ] .= NaN; bottom[ bottom .<0 ] .= 0.0; ```; then when you lift the variable; ```; ζ′ = @lift file[""timestepper/ζ′/ *string($iter][:, 1:end-1, 1] .+ bottom; ```; (it is not going to be in the exact same position since `ζ′` is at faces and bottom is at centers, but on a 1/4 degree resolution I don't think makes much of a change)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128082953:180,variab,variable,180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128082953,1,['variab'],['variable']
Modifiability,"There are a lot of new instances of `@allowscalar`, but rather than adding new instances we should be refactoring the tests so they don't appear. When we find that we have to use `@allowscalar`, it often indicates that our `Field` infrastructure is somehow deficient / doesn't support necessary operations, which causes us to resort to indexing and other syntax that requires `@allowscalar`. @navidcy @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2865#issuecomment-1411314641:102,refactor,refactoring,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2865#issuecomment-1411314641,1,['refactor'],['refactoring']
Modifiability,"There are two issues open on this topic now. Where should we discuss?. Here is my proposed refactor:. https://github.com/glwagner/Oceananigans.jl/blob/poisson-solver-refactor/src/poisson_solver.jl. If we move to a new package, we can improve the documentation there. The more I think about a separate package the more it makes sense...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/102#issuecomment-469744389:91,refactor,refactor,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/102#issuecomment-469744389,2,['refactor'],['refactor']
Modifiability,"There are two things at play here. First, there is a refactoring of the equation set to allow for a generalized vertical coordinate. This actually involves rewriting the equations. To merge that generalization, I think we would also like to see the new equations that are being solved written up in the docs. When the equations are generalized, this would also involve implementing a new abstraction for the vertical coordinate, along with a `vertical_coordinate = ZVerticalCoordinate()` default, which preserves existing behavior. The second PR should then implement a `ZStarVerticalCoordinate()` (other better names are fine too). So to me this feels like we need two PRs, one with docs update and API design, and then a second with z* implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1867969677:53,refactor,refactoring,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1867969677,1,['refactor'],['refactoring']
Modifiability,"There is a choice we need to make about the third variable: the total depth (what we usually denote as `h`) or the free-surface (what we usually denote with `\eta`). In the equations you have above, the first set of equations is using `h` as the total depth, but the second uses it as a free-surface. I am fine with either but if we are using the variable `h`, I would vote for the layer depth.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128987220:50,variab,variable,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128987220,2,['variab'],['variable']
Modifiability,"There is a nonlocal contribution in the vertical. The pressure gradient at fluid layer $j$ depends on all fluid thicknesses of that layer and **all** layers above that. Does this impose any constraint on the technical design (in terms of whether we write 3D kernels or `Nz` 2D kernels, where `Nz` the number of fluid layers...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147075457:150,layers,layers,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147075457,2,['layers'],['layers']
Modifiability,There is no adapt method for the model. I don't know how it would play to send the whole model to the GPU. We might have some parameter space issue,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258425517:12,adapt,adapt,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258425517,1,['adapt'],['adapt']
Modifiability,"There is something for `Oceananigans`. But true, we need more ;). ```Julia; help?> Oceananigans; search: Oceananigans OceananigansLogger. Main module for Oceananigans.jl – a Julia software for fast, friendly, flexible, data-driven, ocean-flavored fluid dynamics on CPUs and GPUs.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/728#issuecomment-1480665184:209,flexible,flexible,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/728#issuecomment-1480665184,1,['flexible'],['flexible']
Modifiability,"There is still a problem. This time with the vector size:. > ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] No Gpu available; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 129 and 128""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs (repeats 3 times); @ ./broadcast.jl:495 [inlined]; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] instantiate; @ ./broadcast.jl:266 [inlined]; [6] materialize(bc::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3}, Nothing, typeof(*), Tuple{Array{Float64, 3}, Array{Float64, 3}}}); @ Base.Broadcast ./broadcast.jl:883; [7] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case13/c16_128_128m.jl:200. Also, shouldn't we set v (last line below, I added the commented v's):. `Random.seed!(1414). T = model.tracers.T; u, v, w = model.velocities. x, y, z = nodes(T, reshape=true); Lz = model.grid.Lz. shape = @. z / Lz * (1 + z / Lz); ΞT = randn(size(T)...) .* shape; Ξu = randn(size(u)...) .* shape; #Ξv = randn(size(v)...) .* shape; Ξw = randn(size(w)...) .* shape. Tᵢ = @. 20 + dTdz * z + dTdz * Lz * 1e-6 * ΞT; uᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξu; #vᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξv; wᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξw. #set!(model, u=uᵢ, v=vᵢ, w=wᵢ, T=Tᵢ, S=35); set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=35)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743:199,Config,Configuration,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743,5,"['Config', 'config', 'variab']","['Config', 'Configuration', 'config', 'variable']"
Modifiability,There must be a simple bug to fix. I remember the simulation was quite stable. I think it has to do with how bathymetry is defined in the code. A simple configuration might snoop out the issue,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973873627:153,config,configuration,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973873627,1,['config'],['configuration']
Modifiability,"There seems to be a problem with calculating fluxes in a `Flat` direction. . The `Horizontal` formulation It is trying to calculate the viscous flux in the horizontal direction using the vertical vorticity which requires at least 2 points in each horizontal direction. . (specifically these two lines); ```; @inline viscous_flux_vx(i, j, k, grid, closure::AHD, clock, U, args...) = - ν_ζᶠᶠᶜ(i, j, k, grid, clock, closure.ν, U.u, U.v); @inline viscous_flux_uy(i, j, k, grid, closure::AHD, clock, U, args...) = + ν_ζᶠᶠᶜ(i, j, k, grid, clock, closure.ν, U.u, U.v) ; ```. because this calls the circulation operator `Γᶠᶠᶜ`; which is calculated as. ```; @inline Γᶠᶠᶜ(i, j, k, grid, u, v) = Δy_qᶜᶠᶜ(i, j, k, grid, v) - Δy_qᶜᶠᶜ(i-1, j, k, grid, v) - Δx_qᶠᶜᶜ(i, j, k, grid, u) + Δx_qᶠᶜᶜ(i, j-1, k, grid, u); ```. requiring `i-1` which we do not have if `x` is `Flat`. ; I wonder how it was even working before? Maybe a workaround we can implement is to extend the circulation operator for `Flat` directions. ```; @inline Γᶠᶠᶜ(i, j, k, grid::AbstractGrid{<:Any, Flat}, u, v) = - Δx_qᶠᶜᶜ(i, j, k, grid, u) + Δx_qᶠᶜᶜ(i, j-1, k, grid, u); @inline Γᶠᶠᶜ(i, j, k, grid::AbstractGrid{<:Any, <:Any, Flat}, u, v) = Δy_qᶜᶠᶜ(i, j, k, grid, v) - Δy_qᶜᶠᶜ(i-1, j, k, grid, v); ```. Or maybe just put it to zero since it actually is zero",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054853703:945,extend,extend,945,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054853703,1,['extend'],['extend']
Modifiability,"There's no need for a new kernel because the diffusivities are `νₑ / Pr` so they can be calculated on the fly. We need to extend `κᶠᶜᶜ` and `κᶜᶠᶜ` and `κᶜᶜᶠ`. ```julia; @inline κᶠᶜᶜ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑxᶠᵃᵃ(i, j, k, grid, K.νₑ) / closure.Pr[id]; @inline κᶜᶠᶜ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑyᵃᶠᵃ(i, j, k, grid, K.νₑ) / closure.Pr[id]; @inline κᶜᶜᶠ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑzᵃᵃᶠ(i, j, k, grid, K.νₑ) / closure.Pr[id]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419238472:122,extend,extend,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419238472,1,['extend'],['extend']
Modifiability,"There's two challenges. One is refactoring `Reduction` to be more general. `cumsum!` has a diffeerent pattern, the dimensionality is not reduced for the output and it has a slightly different syntax. But I figured that stuff out here:. https://github.com/CliMA/Oceananigans.jl/pull/3590. The next challenge is to figure out how to integrate downwards rather than up; this is a little trickier I think because we may need an abstraction that reverses indices or something. There is also the metric part but that's kind of trivial, its the same thing as with `Integral` or `Average`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098993956:31,refactor,refactoring,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098993956,1,['refactor'],['refactoring']
Modifiability,"These are good points. I'll close the issue. I hope you don't mind if I use your comments in the documentation under the adaptive time-stepping section. I ended up finding other ways to transition to turbulence in a stable manner using `TimeStepWizard` as is, e.g. either increasing the CFL with time; ```julia; cfl(t) = min(0.005*t, 0.1); wizard.cfl = cfl(model.clock.time); ```; or changing the number of time steps between adaptive time steps with time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520902324:121,adapt,adaptive,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520902324,2,['adapt'],['adaptive']
Modifiability,"Thinking about this more, I think it would make sense to make an even more radical change. I think we should add `diagnostics`, `output_writers`, and `clock` to `Simulation`. . The `time_step!` function then performs a single time-step, whereas to run a simulation one should write `run!(simulation)`, which handles diagnostics, output writing, adaptive time-stepping, and logging in an integrated way. This orthogonalizes the design a bit: `diagnostics` and `output_writers` are not really aspects of a ""model"", if we use a narrow interpretation of a model as a discrete representation of a physical system. A single physical system might conceivably be associated with a wide range of disparate diagnostics and output, depending on what kind of science is being done. I think scripts become clearer. The user writes. ```julia; model = Model(; model_parameters...). simulation = Simulation(model; simulation_parameters...). simulation.diagnostics[:diag] = # something. run!(simulation); ```. As an example to illustrate why `Simulation` is orthogonal to `Model`, here's a possible clear and coherent usage of this separation:. ```julia; model = Model(; model_parameters...). set!(model; first_interesting_initial_condition...). first_simulation = Simulation(model, first_simulation_parameters...); first_simulation[:diag] = diag_specific_to_first_simulation; run!(first_simulation). set!(model; second_interesting_initial_condition...) # same physical model, but different starting initial condition... no new memory allocated, no recompilation --- fast. second_simulation = Simulation(model, second_simulation_parameters...); second_simulation[:diag] = diag_specific_to_second_simulation; run!(second_simulation); ```. We can use `run!(simulation, time_steps=nsteps)` to allow hand-coded user loops that achieve a functionality similar to what we have now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542294442:345,adapt,adaptive,345,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542294442,1,['adapt'],['adaptive']
Modifiability,"Thinking of revamping this, I think `T` is a good notation; we do not need to specify `U` and `C` since probably (in the future) we will need to refactor these a little to pass through boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2327849488:145,refactor,refactor,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2327849488,1,['refactor'],['refactor']
Modifiability,"This PR also includes code for the two-dimensional Leith parameterization, but it is not compiled or added to the code. Depending on when this PR is merged, that work could be added to this PR. Otherwise, it will come later. cc @navidcy @basileg",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/520#issuecomment-548591020:57,parameteriz,parameterization,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/520#issuecomment-548591020,1,['parameteriz'],['parameterization']
Modifiability,This PR might need to be closed or refactored. We now have `VerticallyImplicitTimeDiscretization`. A new turbulence closure called `ConvectiveAdjustmentDiffusivity` would probably useful for some users. For this the convective adjustment diffusivity should be precomputed. During this computation the vertical buoyancy gradient can be calculated on the fly with the function `∂z_b`; so there would be no need to store the vertical buoyancy gradient separately.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1342#issuecomment-848999805:35,refactor,refactored,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1342#issuecomment-848999805,1,['refactor'],['refactored']
Modifiability,This PR now adds a test to ensure that a Poisson equation with arbitrary/random source term can be solved on a vertically stretched grid with the `BatchedTridiagonalSolver` up to machine precision with the staggered grid difference operators. Figuring out the exact system to solve and getting it working in 3D took a while. I tried to add a struct for a vertically stretched Poisson solver but it required a finalized vertically stretched grid (currently under development in PR #543) so I think it'll be better if they're developed together. The test will then be refactored to make use of the `VerticallyStretchedCartesianGrid`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/306#issuecomment-568266257:566,refactor,refactored,566,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/306#issuecomment-568266257,1,['refactor'],['refactored']
Modifiability,"This PR was created yesterday to start a discussion about how we might want to change the input arguments for `VerticallyStetchedRectilinearGrid`. After some disucssion there is no concensus that a chance should be made so I'm going to close this PR. . I think it's better that users get to play with stretched grids in any or all dimensions sooner rather than later. Hence, I'm going to return to #1532 and change the arguments to be inline with what `VerticallyStretchedRectilinearGrid`. . One change that I would like to make is instead of having `zF` as input, I would prefer to have `zFs` or even `zFaces`, to emphasize that all the faces are specified. Usually, when I see `zF` I think of a face, and that's not the case here. @tomchor , what do you think about this?. When users have played with grid stretching we will be better able to asses from experience what is good for the user, and we will be able to adapt to that in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814054518:917,adapt,adapt,917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814054518,1,['adapt'],['adapt']
Modifiability,"This can be implemented by implementing a new method for [`update_source_terms!`](https://github.com/climate-machine/Oceananigans.jl/blob/341c17410189528bb07cdcfc42e7e55fb81c730e/src/time_steppers.jl#L161) that dispatches on `forcing::Forcing{Tu} where Tu <: AbstractArray`. No changes are needed to the code except for this addition. When the user passes arrays to the `Forcing` constructor, the code will do the right thing as long as this method is implemented. I would note unless we write *a lot* of new code, the user will be essentially limited to either providing an array for *all* fields, or forcing for *all* fields. To allow the user to implement either forcing functions or forcing arrays requires writing 5! = 120 new methods (right?) which is not desirable. A convenience constructor for `Forcing` that detects when the user passes arrays for any of the fields will help users avoid accidentally specifying forcing arrays for some fields and functions for others. However, once we resolve the `isbitstype` problem (perhaps also using `FieldVectors` or `LabeledArrays` for `velocities` and `tracers` to retain high performance) we can introduce abstractions for the idea of an `equation` function for each field individually (which would also be stored in a `LabeledArray`), and permit more flexible equation specification by the user without inducing a combinatorial explosion of code length.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470324259:1305,flexible,flexible,1305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470324259,1,['flexible'],['flexible']
Modifiability,This is an amazing refactor.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2214#issuecomment-1029976527:19,refactor,refactor,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2214#issuecomment-1029976527,1,['refactor'],['refactor']
Modifiability,"This is for explicit free surface, I ll extend the benchmarks for implicit and weak scaling",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116689634:40,extend,extend,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116689634,1,['extend'],['extend']
Modifiability,This is great to see!. I imagine we could use this for the height field in `ShallowWaterModel` to allow for wetting and drying for a single layer. And also to prevent layer collapse in the case of multiple layers.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1128280245:206,layers,layers,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1128280245,1,['layers'],['layers']
Modifiability,This kind of error arises when using the environment on the branch `integrate-turbulence-closures`:. ```juliarepl; (Oceananigans) pkg> st; Project Oceananigans v0.5.4; Status `/archive1/glwagner/Projects/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v0.4.2; [c5f51814] CUDAdrv v3.0.1; [be33ccc6] CUDAnative v2.1.1; [3a865a2d] CuArrays v1.0.2; [7a1cc6ca] FFTW v0.2.4; [ba82f77b] GPUifyLoops v0.2.3; [4138dd39] JLD v0.9.1; [30363a11] NetCDF v0.7.3; [90137ffa] StaticArrays v0.10.3; [a759f4b9] TimerOutputs v0.5.0; [8ba89e20] Distributed ; [37e2e46d] LinearAlgebra ; [de0858da] Printf ; [9a3f8284] Random ; [10745b16] Statistics ; [8dfed614] Test ; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496478250:246,Adapt,Adapt,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496478250,1,['Adapt'],['Adapt']
Modifiability,"This kind of feature can't be implemented directly in `Forcing`, because all explicit tendency terms are evaluated in the same kernel. So we have to evaluate `forcing` in every cell that requires a tendency. It is possible to expose a feature that allows kernels to be launched over some subset of cells. Then users could implement this kind of optimization in their script by using an array to represent the forcing, and then by precomputing the forcing into that array using a kernel that only evaluates some subset of all the cells in a callback. Or something like that. If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2028469830:750,layers,layers,750,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2028469830,1,['layers'],['layers']
Modifiability,This may help https://github.com/JuliaGPU/Adapt.jl/pull/88,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445748178:42,Adapt,Adapt,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445748178,1,['Adapt'],['Adapt']
Modifiability,This might be a duplicate of PR #3830 but looks like both will be superseded by PR #3847 which is doing the refactoring necessary for this fix.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3846#issuecomment-2412494690:108,refactor,refactoring,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3846#issuecomment-2412494690,1,['refactor'],['refactoring']
Modifiability,"This might require adding a new property to `IncompressibleModel` called `background_fields` (or something). Then users would write `background_fields = (u=background_u, T=background_T)`... We might also want to extend `FunctionField` to take parameters. @ali-ramadhan thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/960#issuecomment-699573822:212,extend,extend,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/960#issuecomment-699573822,1,['extend'],['extend']
Modifiability,"This sounds interesting but I'm not sure if I complete understand. . Can we think of an example of a prognistic field as velocity: `𝐯`, and a diagnostic field as vorticity: ζ?. If yes, I see that you need to fill halos to evolve the velocity and then you need to fill halos when you compute the vorticity. Are you simply saying we allocate the space for the two sets of halos at the same time?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860:222,evolve,evolve,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860,1,['evolve'],['evolve']
Modifiability,"This sounds like a good idea!. I guess it shouldn't be too hard to extend the implementation to support `fx`, `fy`, and `fz` like you're suggesting.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-783478944:67,extend,extend,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-783478944,1,['extend'],['extend']
Modifiability,"This will further crystallize the distinction between linear distances (x, y, z) and ""native coordinate systems"" (Cartesian for Rectilinear, geographic for LatitudeLongitude). We already have this partially implemented; ie `Δx` returns a linear distance. But the implementation has not extended to xnodes, ynodes, etc. Kind of a side note but it'd be nice to figure out a cleaner / more concise way to implement the `with_halos` feature. It's hard to read the code as it is now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2978#issuecomment-1470714440:286,extend,extended,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2978#issuecomment-1470714440,1,['extend'],['extended']
Modifiability,"This would be a major new feature for Oceananigans!. The implementation would probably resemble what we've done for ""CATKE"", which has a prognostic TKE variable:. https://github.com/CliMA/Oceananigans.jl/tree/main/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities. I would vote to implement Burchard and Umlauf's ""generic length scale"" equation. In this formulation there's a TKE variable (like CATKE), and also a ""length scale"" variable, which can either be epsilon, omega, or Mellor-Yamada's ""q^2 l"". So we get all of those models with one implementation:. https://www.ingentaconnect.com/content/jmr/jmr/2003/00000061/00000002/art00004. The implementation might also want to take into account / support a few other formulations like. * [Harcourt 2015](https://journals.ametsoc.org/view/journals/phoc/45/1/jpo-d-14-0046.1.xml); * [Kantha Clayon 2004](https://www.sciencedirect.com/science/article/abs/pii/S1463500302000628). I think @simone-silvestri could be interested in this kind of thing. It's a major undertaking! I think we should refactor `TurbulenceClosures` to make implementing new models (like this one) easier, either before or at the same time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051139114:152,variab,variable,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051139114,4,"['refactor', 'variab']","['refactor', 'variable']"
Modifiability,This would make the API much nicer! Would be especially nice to rewrite the examples when this is implemented so users won't have to juggle Arrays and CuArrays.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/174#issuecomment-482111597:64,rewrite,rewrite,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/174#issuecomment-482111597,1,['rewrite'],['rewrite']
Modifiability,"Those are all possible developments. To put fields in `closure` we have to implement a pattern (implemented for things like boundary conditions, though it's taken a lot of work to get it right) whereby users instantiate a ""template"" `closure`, to which fields / data are added later given knowledge of the grid in the model constructor. Otherwise, users have to provide `grid` as an argument when constructing both a closure and a model. Either pattern is possible --- but implementing a ""template + materialization"" design is complicated, whereas requiring users to provide `grid` when constructing a closure changes the API. When a complicated algorithm endows the code with more features, I feel it could be justified if the feature is good enough. But if its only purpose is to rearrange where array references are bound, it feels less worth the trade off of code maintenance and the work to implement it. Another solution is documentation. Storing constant values in `diffusivities` is possible, but could be interpreted as boilerplate. The coefficients need to be stored in `closure`, because that's where users specify them. So copying the constants or functions into `diffusivities` (this would have to be done individually for all closures) requires additional code. I think of all the changes to `diffusivities`, the one that makes the most sense is to eliminate that field and change the API so that `grid` is a required argument for closures that have fields associated with them. This is a substantial internal refactor, but perhaps someone wants to take it up?. Note: I don't this will work for memory parallel models until #1825 is resolved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883709160:1524,refactor,refactor,1524,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883709160,1,['refactor'],['refactor']
Modifiability,"Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.julia/packages/CUDA/Tl08O/src/CUDAKernels.jl:103; [23] (::KernelAbstractions.Kernel{CUDA.CUDAKernels.CUDABackend, KernelAbstractions.NDIteration.StaticSize{…}, KernelAbstractions.NDIteration.StaticSize{…}, typeof(Oceananigans.BoundaryConditions.gpu__no_fill!)})(::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{…}}, ::Vararg{Any}); @ CUDA.CUDAKernels ~/.julia/packages/CUDA/Tl08O/src/CUDAKe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2453,Adapt,Adapt,2453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,2,['Adapt'],['Adapt']
Modifiability,"To follow up on @ali-ramadhan and my in person conversation, the code that needs to be added to make `VerticalProfile`s work with `JLD2OutputWriter` is something like. ```julia; function (p::VerticalProfile)(model); run_diagnostic(model, p); return Array(p.profile); end; ```. I think. Users would then use this feature with something like. ```julia; uavg = VerticalProfile(...); output = JLD2OutputWriter(model, Dict(:uavg=>uavg,), ...); ```. (I'm not sure exactly how the `VerticalProfile` object is constructed.). However, it may make sense to refactor the PR so that this function is more transparent (ie, without using the intermediate function `run_diagnostic`), which will help improve maintainability in the future when diagnostics are refactored (which seems likely). Does it also make sense to change `VerticalProfile` to `HorizontalAverage`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-521289030:547,refactor,refactor,547,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-521289030,3,"['maintainab', 'refactor']","['maintainability', 'refactor', 'refactored']"
Modifiability,"Triggering TagBot for merged registry pull request. This extra notification is being sent because I expected a tag to exist by now, but it doesn't.; You may want to check your TagBot configuration to ensure that it's running, and if it is, check the logs to make sure that there are no errors.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1154#issuecomment-1949245988:183,config,configuration,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1154#issuecomment-1949245988,1,['config'],['configuration']
Modifiability,"True. Yeah if it's not checking output or model state then 1 time step should be enough. A hack could be that the test actually rewrites the file contents before running the example changing `time_step!(model, Nt, dt)` to `time_step!(model, 1, dt)` or something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/343#issuecomment-519690264:128,rewrite,rewrites,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/343#issuecomment-519690264,1,['rewrite'],['rewrites']
Modifiability,"Try. ```julia; const width = 100kilometers; @inline ν(x, y, z, t) = ifelse(abs(y - Ny*kilometers/2) < Ny*kilometers/2 - width, 1, 10) # sponge layers; ```. The `const` is necessary here for GPU and will also improve performance on CPU. The reason is that we need to assure the compiler that the type of `width` will not change for GPU compilation to be possible. If that fails you may also need to change `kilometers` to `1e3`, or to define another `const`. However, I think that `kilometers` should already b `const` so this may not be necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068643259:143,layers,layers,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068643259,1,['layers'],['layers']
Modifiability,Trying to think of a way to avoid adding another name... we can extend `on_architecture` to have different behavior when `grid::String` (and thus a path to file). But `on_architecture` isn't specific to `grid` so that doesn't really make sense.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2179#issuecomment-1025777420:64,extend,extend,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2179#issuecomment-1025777420,1,['extend'],['extend']
Modifiability,"Ultimately I think it’d be nice to build adaptive time stepping into the time step function itself, once we have time stepping methods that are well suited for it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520912411:41,adapt,adaptive,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520912411,1,['adapt'],['adaptive']
Modifiability,"Update: we think this error arises because `CUDAnative` is not a dependency of `Oceananigans`. As a result, a `launch` function is not compiled by `GPUifyLoops`. In principle, this problem *could* be solved by adding `CUDAnative` to `Oceananigans`. However, this is not possible because `CUDAnative` and `CUDA` (which `Oceananigans` currently uses for CUDA functions / abstractions) cannot be used in the same environment due to conflicting requirements for `Adapt`. cc @sandreza @ali-ramadhan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/784#issuecomment-652686565:459,Adapt,Adapt,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/784#issuecomment-652686565,1,['Adapt'],['Adapt']
Modifiability,"Upon thinking about it I think perhaps it makes more sense to run `dynamics` first before `advect_lagrangian_particles!`, one example of which might be that particles sink depending on the radius of the particle, which changes with time. In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it. Also provided a draft example of how one could set up a problem where the particle sinks with a drag in the form of $\frac{d \boldsymbol{v}}{dt} = \frac{C_d}{\tau}(\boldsymbol{u} - \boldsymbol{v})$. ; Note: in the calculation the velocity of the particle itself needs to be tracked. This is done in `u_particle`, `v_particle`, and `w_particle` in `particles.properties` where `particles::LagrangianParticles`. The particle velocities are computed and updated in the `dynamics` step, then `ParticleVelocities` only has functions that access the particle properties to grab the particle velocity. It is slightly clunky but unless we keep track of the particle velocities right out of the box and update them during the `advect_lagrangian_particles!` step, this is the way I could think of. Since particle velocities are not updated when the particle is bounced, it will not work if the particles bounce from the boundaries back into the interior during the advection step, but for doubly-periodic domian and sinking particles it might not be very important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350:277,evolve,evolve,277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350,1,['evolve'],['evolve']
Modifiability,"Using hu vs u: My reasoning was always the following: The dynamical balance of your model will depend on the practical problem and scales you will look at, hence the conclusion which (dominant) terms should be discretized ""naturally"" and ""nicely"" may vary. On the other hand, all incompressible models have the same volume conservation constraint which is most naturally discretized using hu as fundamental variables (specially on a C-grid). m2c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119302358:407,variab,variables,407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119302358,1,['variab'],['variables']
Modifiability,"Using the code from `fjp/benchmark-incompressiblemodel-WENO5` branch I get this:. ```Julia; julia> using Oceananigans; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/E3Wer/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> N = 32; 32. julia> grid = RegularRectilinearGrid(Float32, size=(N, N, N), extent=(1, 1, 1)); RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (32, 32, 32); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.03125f0, 0.03125f0, 0.03125f0). julia> model = IncompressibleModel(architecture=GPU(), float_type=Float32, advection=WENO5(), grid=grid); ┌ Warning: Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid.; └ @ Oceananigans.Grids /g/data/v45/nc3020/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; IncompressibleModel{GPU, Float32}(time = 0 seconds, iteration = 0); ├── grid: RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded}(Nx=32, Ny=32, Nz=32); ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: SeawaterBuoyancy{Float32, LinearEquationOfState{Float32}, Nothing, Nothing}; └── coriolis: Nothing. julia> time_step!(model, 1); ERROR: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelA",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360:257,Config,Configuration,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360,1,['Config'],['Configuration']
Modifiability,"Very cool. Many thanks!. Petr Krysl; Prof. and Vice chair for undergraduate education; Department of Structural Engineering; <https://urldefense.com/v3/__https://www.linkedin.com/company/uc-san-diego-structural-engineering-department/__;!!Mih3wA!DXYUp152SRRo03xCfQJ9NlAXovNVk-zBYRalwekzmzf2bGwdDMmY8gy9t6iQo9ok2_dvk8m987An93w0pnT_6lM$>; University of California, San Diego; 9500 Gilman Drive #0085; La Jolla, CA 92093. On Mon, Oct 7, 2024 at 6:38 AM Simone Silvestri ***@***.***>; wrote:. > Yep, we used nsys because our primary objective is to trace GPU execution.; > I think it will work also on CPU programs.; > There is nothing really specific about profiling julia with nsys, provided; > that MPI is correctly configured (i.e. your script works with MPI already).; > An example of a batch script that traces MPI calls is; >; > #!/bin/bash; > #SBATCH -N 2; > #SBATCH --ntasks-per-node=4; > #SBATCH --cpus-per-task=16; > #SBATCH --mem=500GB; > #SBATCH --time 24:00:00; > #SBATCH --gres=gpus:4; >; > cat > launch.sh << EoF_s; > #! /bin/sh; > export CUDA_VISIBLE_DEVICES=0,1,2,3; > exec \$*; > EoF_s; > chmod +x launch.sh; >; > srun nsys profile --trace=nvtx,cuda,mpi --output=report_%q{SLURM_PROCID} ./launch.sh julia --check-bounds=no --project scaling_experiments.jl; >; > Here, nsys will produce one report per processor. You can use mpirun or; > mpiexec instead of srun.; > If you want to insert NVTX annotations inside the code you need to add the; > environment variable (ref; > <https://urldefense.com/v3/__https://github.com/JuliaGPU/NVTX.jl__;!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6C7RIjP6$>; > ); >; > export JULIA_NVTX_CALLBACKS=gc; >; > —; > Reply to this email directly, view it on GitHub; > <https://urldefense.com/v3/__https://github.com/CliMA/Oceananigans.jl/pull/3125*issuecomment-2396961670__;Iw!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6H5RkVsz$>,; > or unsubscribe; > <https://urld",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396992719:715,config,configured,715,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396992719,1,['config'],['configured']
Modifiability,"Very nice @simone-silvestri . I think we have to regenerate the ocean LES regression test data. Unfortunately this regression test doesn't use `DataDeps` yet so regenerating it will increase the size of the repo by a little bit. Another option is to refactor the regression tests to use DataDeps but this might be best saved for a future PR. I think this fix may actually resolve some ancient issues that we didn't understand until now, for example:. https://github.com/CliMA/Oceananigans.jl/issues/1179. To summarize:. When running a model that has both `Periodic` and `Bounded` directions, _and_ when using a stencil that touches corner points (such as with `coriolis isa FPlane`, the order in which halos are filled matters. In particular, we must fill periodic directions _last_, because the corners then depend on a halo point which is just outside the boundary in the `Bounded` direction(s). The ocean large eddy simulation regression test is one such case (horizontally-periodic, bounded in z). There is a no-flux surface velocity boundary condition that creates a dependency between the bounded and periodic halo fills. The previous algorithm assumed that all halos could be filled simultaneously with no dependencies on one another. However, because the CPU is serial the halos were nevertheless filled in the ordering prescribed by `fill_halo_regions!`:. https://github.com/CliMA/Oceananigans.jl/blob/2d6ccfe94ce2c68857f70b2f8839020049932e00/src/BoundaryConditions/fill_halo_regions.jl#L32-L42. In other words, the vertical halos (the bounded direction) are filled last on the CPU. On the GPU the ordering may change because on the GPU KernelAbstractions is no longer serial. Thus on occasion the periodic halos might have been filled _after_ the bounded halos, leading to a failure of the regression test. This PR fixes that issue so that periodic directions are always filled last. So I think we should expect that regression tests fail on both the CPU and GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800:250,refactor,refactor,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800,1,['refactor'],['refactor']
Modifiability,"Visualization is taking a bit of time. I am adding the vorticity as an output field and then hope to adapt the following to create a similar plot to what you produced before. When I get something working I might push it so that others can use it too, if they like. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/near_global_lat_lon/visualize.jl. I have found that I couple of things don't work so easily. `Node(0)`. ` wireframe!(ax, Sphere(Point3f0(0), 1f0), show_axis=false)`. It seems that `Node` and `Point3f0` are not defined. Is there another library that I need?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126317483:101,adapt,adapt,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126317483,1,['adapt'],['adapt']
Modifiability,"Was just looking through this, and not sure if there is still room for comments from noobs (happy to be ignored). Would `tensor_diffusivity` be a good name - skewsymmetric seems a bit like saying that a T-junction is a left_right_turn. :) . > > May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it.; > ; > As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field.; > ; > If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component.; > ; > Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449:1058,parameteriz,parameterization,1058,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449,1,['parameteriz'],['parameterization']
Modifiability,"We also need to figure out how to adapt instruction 2:. <img width=""851"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/129913721-0a12190d-af28-43c6-9070-92eb9e8f5a25.png"">. to buildkite.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901149073:34,adapt,adapt,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901149073,1,['adapt'],['adapt']
Modifiability,"We can extend `SimpleForcing` with a field `.parameters` to optionally admit parameters via dispatch, eg. ```julia; u_forcing = SimpleForcing((x, y, z, t, parameters) -> something, parameters=user_defined_parameters); ```. What do you think?. Interestingly, putting parameters in the forcing object obviates the need for model.parameters. Ultimately this design may be preferred; I suppose we will see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/444#issuecomment-540006602:7,extend,extend,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/444#issuecomment-540006602,1,['extend'],['extend']
Modifiability,"We could also define this at the top level in `src/Oceananigans.jl`. For coupling, we will have to set these constants in the simulation constructor (hopefully we won't be changing source code)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2981#issuecomment-1472741495:73,coupling,coupling,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2981#issuecomment-1472741495,1,['coupling'],['coupling']
Modifiability,"We could also extend `push!` for objects of type `OrderedDict{Symbol, Diagnostic}`. Extending `push!` here for this Oceananigans-specific type would motivate keeping the `Diagnostic` abstract type, since we can ensure that this slightly hack-y extension of `push!` doesn't mess anything else up in an unexpected way. And a serious bonus is that it doesn't break the API.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/362#issuecomment-531485229:14,extend,extend,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/362#issuecomment-531485229,2,"['Extend', 'extend']","['Extending', 'extend']"
Modifiability,We have suitable defaults now: https://github.com/climate-machine/Oceananigans.jl/blob/74cfb85fd210e70313f19e9374dd4b9f119f2199/src/OutputWriters/netcdf_output_writer.jl#L90-L97. Closing this issue as long descriptive CMIP6 names like `sea_water_conservative_temperature` may not be the most suitable defaults for Oceananigans. But indeed `NetCDFOutputWriter` is flexible enough that you can use these names if you wish.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/91#issuecomment-595390071:363,flexible,flexible,363,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/91#issuecomment-595390071,1,['flexible'],['flexible']
Modifiability,"We have variables `∇²eᵢⱼₖ` implying that `∇²` acts on `eᵢⱼₖ`. But that's not always the case, right?. Let's change all `∇²eᵢⱼₖ` -> `Aeᵢⱼₖ`? And add a small remark, e.g.,. ```Julia; eᵢⱼₖ = similar(template_field) # the basis vector; Aeᵢⱼₖ = similar(template_field) # A * eᵢⱼₖ; ```. I think everything should be here:; https://github.com/CliMA/Oceananigans.jl/blob/639d337b4449c7aa846b1005ce5109ba590ff786/src/Solvers/multigrid_solver.jl#L192-L233",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241429332:8,variab,variables,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241429332,1,['variab'],['variables']
Modifiability,We maybe need to adapt the constructor of the `KrylovSolvers` (workspaces) for your specific type.; Example: https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/main/src/krylov_solvers.jl#L162. It works fine for CPU / GPU arrays as well as various partitioned arrays but `Field` seems quite different.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387573678:17,adapt,adapt,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387573678,1,['adapt'],['adapt']
Modifiability,"We need an MPI tips / wiki section... been working on getting distributed simulations running on Engaging since yesterday (we need people to be able to start running distributed simulations immediately with minimal start up time). Here are a few things I learned:. * Remember to load a system MPI on your HPC, eg `module load openmpi`; * MPI may have to be installed / configured carefully --- after loading a system MPI. `MPIPreferences` can help:. ```julia; using MPIPreferences; MPIPreferences.use_system_binary(); ```. https://juliaparallel.org/MPI.jl/stable/configuration/. * Configuring SLURM correctly may also require some trial and error, because the documentation is unclear and there are a huge number of options. I can't figure out if the documentation is wrong, in fact, or if instead the engaging cluster does not support some options. Either way, a small test script like. ```julia; using MPI. MPI.Init(); @show MPI.Comm_rank(MPI.COMM_WORLD); @show MPI.Comm_size(MPI.COMM_WORLD); ```. Is helpful for debugging. Also, I recommend first trying to start jobs interactively before using `sbatch`. Interactive jobs launch faster, so we get a faster trial-error iteration. I'm still working on things, but it seems like another point may be salient:. * Initialize / precompile outside of a parallel job before trying to launch a parallel job via `mpiexec`. Here are some notes that may be specific to engaging:. I'm using `srun` to get a 4-GPU node to use interactively:. ```; srun -p my_partition --tasks-per-node=4 --cpus-per-task=32 --gres=gpu:4 --gpus-per-node=4 --mem=0 -t 01:00:00 -N 1; ```. it seems we have to use the option `gpus-per-node`, rather than setting the total number of GPUs. Also we redundantly also have to specify `gres=gpu:4` (`gres` stands for ""generalized resource""). Why `gres` can't tell what `gpus-per-node` is, I don't know. `-N 1` means 1 node. Finally we also have to specify ``--tasks-per-node=4` (matching `gres` _and_ the number of GPUs per node), otherwise",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436:369,config,configured,369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436,3,"['Config', 'config']","['Configuring', 'configuration', 'configured']"
Modifiability,"We need tests for both the zonal average and the volume average before this can be merged. Side note: we probably want to do away with the notation ""Zonal"" and ""Horizontal"". It might be better to use something like `XAverage` and `XYAverage`. This naturally extends to the other possible averages, `YAverage`, `YZAverage`, etc)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/798#issuecomment-658176361:258,extend,extends,258,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/798#issuecomment-658176361,1,['extend'],['extends']
Modifiability,"We should modify the netCDF variable names to `λF`, `λC` or something... I didn't do this in #2979 because I didn't know if netCDF allows unicode (and because I felt it was outside of the scope of that PR).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1498446661:28,variab,variable,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1498446661,1,['variab'],['variable']
Modifiability,"We think there is a race condition in the CI. Partly discussed on #3661 and also #3662, although one conclusions is that we should update to use the buildkite plugin (started on #3042)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3751#issuecomment-2322236885:159,plugin,plugin,159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3751#issuecomment-2322236885,1,['plugin'],['plugin']
Modifiability,"We use that function to initialize a correct array before performing global reductions (i.e. all zeros for sums, all 1s for prods and so on...) which are called when showing a field (if you put a semicolon after `myfield = CenterField(grid)` the error will disappear) Apparently they have changed the signature of the function in julia-1.8. Adapting Oceananigans to the new `initarray!` was on the table, I guess it's a good time to fix it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2663#issuecomment-1185068632:341,Adapt,Adapting,341,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663#issuecomment-1185068632,1,['Adapt'],['Adapting']
Modifiability,"We'll be refactoring the way grids and architectures work soon, so this PR isn't needed anymore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1485#issuecomment-903978139:9,refactor,refactoring,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1485#issuecomment-903978139,1,['refactor'],['refactoring']
Modifiability,"We'll need a channel test configuration too, when it's ready to go. John. On Tue, May 14, 2019, 4:34 PM Ali Ramadhan <notifications@github.com> wrote:. >; > 1. Rising thermal bubble; > 2. Deep convection; > 3. Uniform free convection with wind stress; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/221?email_source=notifications&email_token=AKXUEQTOK5A5LT5WMDFMOJDPVMO6VA5CNFSM4HM5OBLKYY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4GTYTXPA>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQREHJN3TFKVI72NGPDPVMO6VANCNFSM4HM5OBLA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/221#issuecomment-492403159:26,config,configuration,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/221#issuecomment-492403159,1,['config'],['configuration']
Modifiability,"We've seen issues noise in the vertical velocity along immersed boundaries in other configurations too. I've seen at least one result in which the noise is substantially mitigated by using the PCG solver, which avoids the approximations of the ""naive"" FFT solver. Unfortunately, we don't yet have a performant PCG-based solver cc @simone-silvestri @xkykai . I think it's interesting and also convenient that the noise is mitigated in turbulent cases or by the inclusion of bottom drag.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028935410:84,config,configurations,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028935410,1,['config'],['configurations']
Modifiability,Weird. Probably we should just give these functions unique names rather than pointlessly trying to extend the definition of `OffsetArray` (my fault for the poor code design).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/991#issuecomment-700270532:99,extend,extend,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/991#issuecomment-700270532,1,['extend'],['extend']
Modifiability,"Well, fractional indices work, just not `DateTimes` indices. I am not super familiar with what date-times supports in terms of operations, if it supports summation and division it is straightforward to extend indexing with to `DateTimes`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1695852941:202,extend,extend,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1695852941,1,['extend'],['extend']
Modifiability,"Well. Reading the error message *very* closely, it looks like the failure occurs when the generator --- for some reason --- attempt to assign an Oceananigans Field at `Face, Cell, Cell` to a location expecting an Oceananigans field at `Cell, Cell, Cell`. This looks like a deep and strange issue associated with the generator function. Very odd. I think we can rewrite the code that extracts the output to use tuples rather than a dict, which might fix the issue. I'm not sure this is super important because we can never output fields directly on the GPU anyways. As stated above, however, it would be nice to fix this issue so that we can output fields directly for other purposes. I've changed the title to accurately reflect the error / bug. If this is investigated earlier it may be worthwhile raising this issue on the julia github. Something funny is happening here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/562#issuecomment-580297792:361,rewrite,rewrite,361,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/562#issuecomment-580297792,1,['rewrite'],['rewrite']
Modifiability,"What about designing an interface that's model-specific (since that's where the time-stepper lives). Something like. ```julia; validate_time_step_size(model, dt) = nothing; ```. that's optionally extendable; for example for `NonhydrostaticModel`, which can further dispatch on the time-stepper being used. Then we can implement. ```julia; function set_dt!(simulation, new_dt); validate_time_step_size(simulation.model, dt); simulation.dt = dt; return nothing; end; ```. Now, model developers have the option to implement this function (and the fallback would be `nothing`). I guess the annoying thing here is that in order to error or warn, we have to calculate the CFL which has a cost. So we may not really want to validate time steps all the time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276:196,extend,extendable,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276,1,['extend'],['extendable']
Modifiability,"What do we think about the pros and cons of an alternative design that adds `state_callbacks` to `Simulation` and extends `time_step(model, dt, state_callbacks)` to accept the state callbacks as a positional argument?. It might be slightly less code and we don't have to bloat the model structs anymore. It also keeps the callback implementations in `Simulation`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271627269:114,extend,extends,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271627269,1,['extend'],['extends']
Modifiability,"What does `find_neighboring_panels` do that is not already included in the `grid.connectivity`?; `find_neighboring_panels` seems like a bit of a ""hack"" to me that only works for 1-region-per-panel configs? `grid.connectivity` is general. Why don't we use the grid's connectivity to read out the rank of the neighboring panels. (I really should have made this comment in #3488, but it's never too late..)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3547#issuecomment-2045607056:197,config,configs,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3547#issuecomment-2045607056,1,['config'],['configs']
Modifiability,"What if `nu` varies? Do we write this. ```; h⁻¹ ∇ ⋅ (ν h ∇u); ```. ?. this could be implemented using the existing closures:. 1. Add a property `velocities = (u = uh / h, v = vh / h)` (the abstract operations, no data) to `ShallowWaterModel`; 2. Support only `HorizontalScalarDiffusivity` and `HorizontalScalarBiharmonicDiffusivity` (explicitly forbid other closures in the constructor); 3. Then in the constructor, rewrite the closures with. ```julia; if closure isa HorizontalScalarDiffusivity; ν = closure.ν; thickness_weighted_ν = h * ν # Works when `ν` is a number, field, or function of (x, y, z); thickness_weighted_closure = HorizontalScalarDiffusivity(ν = thickness_weighted_ν); end; ```. The same sort of logic applies to tracers diffusivities and also for biharmonic viscosity / diffusivities. 4. Write the kernel functions as. ```julia; 1 / h[i, j, k] * ∂ⱼ_τ₁ⱼ(i, j, k, grid, closure, diffusivities, velocities, tracers, clock, nothing); ```. (the `nothing` is `buoyancy` in our 3D models). I think that should work. The only case that won't work is diffusivities that are functions of `(x, y, z, t)`. But in fact this could be supported too by wrapping function `ν` in `FunctionField` with the model `clock` in the model constructor when `ν_effective` is calculated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084969833:416,rewrite,rewrite,416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084969833,1,['rewrite'],['rewrite']
Modifiability,"What is the error you are getting when you try to use it?. The only function you'd need to extend is `update_Δt!` I think, which is probably a small piece of work if we know what error we're getting. https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Simulations/time_step_wizard.jl#L32",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761079404:91,extend,extend,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761079404,1,['extend'],['extend']
Modifiability,"What is the intent of these tests? Are they intended to be included in CI, or are they more in the style of “benchmarks” that are run relatively infrequently?. @edoddridge A twist on option 1 is to design a forcing that exactly cancels the terms associated with nonlinear and linear terms in a given equation for some simple initial condition consisting of sines and cosines. For example, pick an initial condition, calculate all terms in a given equation, and then write a forcing that exactly cancels those terms. Then check that the initial condition doesn’t change after a few time-steps. This method allows a test at low resolution with low computational burden and allows each nonlinear and linear term in each equation to be assessed separately. . It would also be good to run “benchmarks” that are designed to be run less frequently, which is a category I think some of the suggested tests fall into (?) Is the algorithm in Oceananigans.jl identical to some configuration of MITgcm? If so that opens the possibility to compare a solution grid-point for grid-point.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467266242:966,config,configuration,966,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467266242,1,['config'],['configuration']
Modifiability,What make sense logically is that `validate_closure` is called first. Because if it's not a valid closure why bother doing anything else... But I'm not sure if it's difficult to refactor.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2347365219:178,refactor,refactor,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2347365219,1,['refactor'],['refactor']
Modifiability,What would you argue?. We discussed how exporting from submodules can be nice for readability. But after working with this paradigm for a while it actually feels like a major source of boilerplate. I would support exporting more stuff from the top level so that we don't have to import from submodules. I would also support removing all export statements from submodules (this would require some internal refactoring of import statements).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1131#issuecomment-720675118:405,refactor,refactoring,405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1131#issuecomment-720675118,1,['refactor'],['refactoring']
Modifiability,"When I try your suggestion I get that it is an Array, which is good to know. ; ```; julia> typeof(results[CenteredSecondOrder][1].cx.analytical); Array{Float64,1}; ```. I wonder if a simpler idea is to call the plotting for each advection_scheme, that way the scheme is fixed. . Clearly `results` is a very powerful and almost all knowing variable, but I am struggling with how to pin it down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729:339,variab,variable,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729,1,['variab'],['variable']
Modifiability,"When `StepRangeLen` is adapted to GPU it goes through this `adapt_structure`:. https://github.com/JuliaGPU/Adapt.jl/blob/5ef7c5329609df7ffb5b19942d6747b3dcc162c2/src/base.jl#L79-L80. This is invalid though, because it does not preserve the type of the range. It calls this constructor in Julia's base:. https://github.com/JuliaLang/julia/blob/9850a3881221a57a382e98c9b9ae2bf97ac3966d/base/range.jl#L524-L525. specifically we get a range of type `typeof(ref+zero(step))`, which is `Float64` if `step isa Float64`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445730630:23,adapt,adapted,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445730630,2,"['Adapt', 'adapt']","['Adapt', 'adapted']"
Modifiability,"When implementing the channel model, I think we should consider refactoring our algorithm so that we. 1. loop over interior cells that don't touch the boundary;; 2. loop over boundary cells taking into account the particular boundary condition. Note that right now, the algorithm instead is:. A. loop over all cells, treating boundary conditions with branches in low-level operators; B. loop over boundary cells to 'adjust' the boundary condition (if the boundary condition is different from what was assumed in A). I prefer 1 and 2 to A and B. 1 and 2 is also used by other codes, such as [Palm](https://palm.muk.uni-hannover.de/trac/wiki/palm):. > The model domain is then separated into three subdomains:. > A. grid points in free fluid without adjacent surfaces, where the standard PALM code is executed,; > B. grid points next to surface that require extra code (e.g., surface parametrization), and; > C. grid points within obstacles, where the standard PALM code is executed but multiplied by zero.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-483897785:64,refactor,refactoring,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-483897785,1,['refactor'],['refactoring']
Modifiability,"When using `with_halos = true` in the `JLD2OutputWriter` works well, however in `NetCDFOutputWriter` it crashes with the following error: . ```; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 11 seconds, wall time: 0 seconds; ERROR: LoadError: DimensionMismatch: new dimensions (156, 156, 22, 1) must be consistent with array size 24336; Stacktrace:; [1] (::Base.var""#throw_dmrsa#328"")(dims::NTuple{4, Int64}, len::Int64); @ Base ./reshapedarray.jl:41; [2] reshape(a::Array{Float64, 3}, dims::NTuple{4, Int64}); @ Base ./reshapedarray.jl:45; [3] setindex_disk!(::NCDatasets.Variable{Float64, 4, NCDataset{Nothing}}, ::Array{Float64, 3}, ::Function, ::Vararg{Any}); @ DiskArrays /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:56; [4] setindex!; @ /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/CommonDataModel/pO4st/src/cfvariable.jl:419; [6] save_output!(ds::NCDataset{…}, output::Field{…}, model::HydrostaticFreeSurfaceModel{…}, ow::NetCDFOutputWriter{…}, time_index::Int64, name::String); @ Oceananigans.OutputWriters /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/OutputWriters/netcdf_output_writer.jl:479; [7] write_output!(ow::NetCDFOutputWriter{…}, model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.OutputWriters /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/OutputWriters/netcdf_output_writer.jl:518; [8] initialize!(sim::Simulation{…}); @ Oceananigans.Simulations /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/Simulations/run.jl:212; [9] time_step!(sim::Simul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2007187819:601,Variab,Variable,601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2007187819,1,['Variab'],['Variable']
Modifiability,Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197356007:229,adapt,adapted,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197356007,1,['adapt'],['adapted']
Modifiability,Will do. Just opened the issue before I forgot about this. Especially important if we want to extend the boundary conditions API to x and y.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/363#issuecomment-523554936:94,extend,extend,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/363#issuecomment-523554936,1,['extend'],['extend']
Modifiability,Woops sorry I meant to delete the sandbox! Would be great to increase variety among the existing examples so it's a great idea.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1394#issuecomment-783459067:34,sandbox,sandbox,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1394#issuecomment-783459067,1,['sandbox'],['sandbox']
Modifiability,"Would it make sense to initialize with the analytical solution to the (linear or weakly nonlinear) barotropic problem? Even if a simple Laplacian viscosity is a poor parameterization for eddy effects, it should dramatically accelerate the equilibration process, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1085#issuecomment-1031920493:166,parameteriz,parameterization,166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1085#issuecomment-1031920493,1,['parameteriz'],['parameterization']
Modifiability,"Wow - :-). On Sat, Jan 11, 2020 at 09:28 Ali Ramadhan <notifications@github.com> wrote:. > This PR felt so good!; >; > The internal code base had to be massively refactored thus the size of; > this PR but I think it's taking the code base in the right direction with; > submodules for everything, and will make implementing big new features; > (like vertically stretched grid and MPI) much easier and cleaner.; >; > There were a few breaking changes, e.g. Face and Cell moving to; > Oceananigans.Fields. In particular, Oceananigans does not export day,; > minute, second, and hour anymore as they conflict with the Dates module; > used by the logger. And it might also confuse users as to why Oceananigans; > is exporting these common names. They are now exported by; > Oceananigans.Utils.; >; > But otherwise, the impact to user scripts is pretty minimal (the examples; > barely changed).; >; > Resolves #456; > <https://github.com/climate-machine/Oceananigans.jl/issues/456>; > Resolves #495; > <https://github.com/climate-machine/Oceananigans.jl/issues/495>; > Resolves #497; > <https://github.com/climate-machine/Oceananigans.jl/issues/497>; > Resolves #563; > <https://github.com/climate-machine/Oceananigans.jl/issues/563>; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/climate-machine/Oceananigans.jl/pull/591; > Commit Summary; >; > - New BoundaryConditions submodule feels so good.; > - Fix missing import statements; > - Coriolis submodule; > - Buoyancy submodule; > - Get rid of `set_ic!` legacy wrapper; > - Fields submodule; > - Models submodule; > - Forcing submodule; > - Utils submodule; > - Architectures submodule; > - Logger submodule; > - Export fewer things in Oceananigans top-level module; > - Update documentation API library; > - Update tests; > - Move field tuple constructions utils to Fields submodule; > - Get rid of most placeholder functions.; > - Update more tests; > - Update even more tes",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/591#issuecomment-573468618:162,refactor,refactored,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/591#issuecomment-573468618,1,['refactor'],['refactored']
Modifiability,"Writing `@allowscalar` will of course always fix a scalar indexing error. But you may end up with slow code, which defeats the purpose of using the GPU. Taking a look at the script: https://github.com/CliMA/Oceananigans.jl/blob/main/examples/kelvin_helmholtz_instability.jl. we see that there are calls to getindex in a few places:. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L190. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L197. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L256C1-L257C1. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L266. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L270. Wherever we write `energy[1, 1, 1]`, it is safe to use `@allowscalar`. This is just a single indexing operation and will be fast. However, where we write `collect`, its probably better to rewrite this in a different way. But note that `collect` is only used for plotting. So what we do here depends on the application. @sangeethasankar01 are you trying to get this to run on the GPU for some specific purpose? Or is this merely an educational exercise?. I also think we should convert this issue to a discussion. I don't think we want to make these changes to the example in the source code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2023037563:1200,rewrite,rewrite,1200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2023037563,1,['rewrite'],['rewrite']
Modifiability,"Yeah I agree with no code being better than broken code. So I guess that means nuke non-working scripts and they can always be revived later with the intention of maintaining them long-term. Also agree that sandbox is bad. We can discourage further short-term additions to `validation` and encourage people to use branches or other short-term repositories for them?. As for repo size yeah the biggest files are images and regression files which we could aim to get rid of in the long-term, maybe in one fell swoop with BFG repo cleaner. We've done in the past but it takes some preparation and is rewriting git history which is bad.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872562473:207,sandbox,sandbox,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872562473,1,['sandbox'],['sandbox']
Modifiability,"Yeah I think some of those one-off experiments in `validation` should probably be nuked. Maybe we should put them in a `sandbox` directory in the future. Ideally they would serve both as actual validation against existing results (e.g. convergence test, lid-driven cavity, viscous flow around a cylinder) and as advanced examples, so maybe they should become Literate examples (or Pluto examples/notebooks...).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872543143:120,sandbox,sandbox,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872543143,1,['sandbox'],['sandbox']
Modifiability,"Yeah I tried rerunning that doc build a few times but it doesn't seem to grab the correct `TRAVIS_REPO_SLUG` and deploy since the repo name technically changed I think (from `climate-machine/Oceananigans.jl` to `CliMA/Oceananigans.jl`): . https://travis-ci.com/github/CliMA/Oceananigans.jl/jobs/339867352#L1783-L1789:; ```; ┌ Info: Deployment criteria for deploying release build from Travis:; │ - ✘ ENV[""TRAVIS_REPO_SLUG""]=""CliMA/Oceananigans.jl"" occurs in repo=""github.com/climate-machine/Oceananigans.jl.git""; │ - ✔ ENV[""TRAVIS_PULL_REQUEST""]=""false"" is ""false""; │ - ✔ ENV[""TRAVIS_TAG""] contains a valid VersionNumber; │ - ✔ ENV[""DOCUMENTER_KEY""] exists; │ - ✔ ENV[""TRAVIS_EVENT_TYPE""]=""push"" is not ""cron""; └ Deploying: ✘; ```. I'm gonna try manually setting the `TRAVIS_REPO_SLUG` environment variable in the Travis CI settings and see if this hack does the trick haha.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/808#issuecomment-661453978:798,variab,variable,798,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/808#issuecomment-661453978,1,['variab'],['variable']
Modifiability,Yeah for sure we should add docs before merging. This PR may be open for a bit because I'd like to refactor the tests. Right now they take almost 2 hours on average which I feel is much too slow.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-905859491:99,refactor,refactor,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-905859491,1,['refactor'],['refactor']
Modifiability,"Yeah it looked great in LaTeX but I guess MathJax renders variables a little differently. > Although is not customary, in reality \upsilon really looks like a calligraphic v. If it makes the documentation more readable, then why not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470515931:58,variab,variables,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470515931,1,['variab'],['variables']
Modifiability,"Yeah it'll be slow but I figure we can always optimize later... The velocities stored are defined as averages over the cell faces (well the velocities are normal to the cell faces) while tracer variables (e.g. temperature T, salinity S, and pressure p) are defined as cell or volume averages. The difference is reflected in the different operators, e.g. [div_flux](https://github.com/ali-ramadhan/OceanLES.jl/blob/69d1b5794e297245289be993d254ec795469061a/src/operators.jl#L46) vs. [u_dot_u](https://github.com/ali-ramadhan/OceanLES.jl/blob/69d1b5794e297245289be993d254ec795469061a/src/operators.jl#L59), which I guess is why the δ operators aren't exactly derivatives as much as they are difference operators used by the actual divergence and curl operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/4#issuecomment-437340933:194,variab,variables,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/4#issuecomment-437340933,1,['variab'],['variables']
Modifiability,Yeah seems like it might be easiest to define a new `define_output_variable!` that dispatches on `WindowedTimeAverage{<:WindowedSpatialAverage}`. `define_output_variable!` is only used by `NetCDFOutputWriter` since it needs to know which dimensions belong to the variable.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784317252:263,variab,variable,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784317252,1,['variab'],['variable']
Modifiability,Yeah so Adapt v3.0.0 is blocked by CUDA.jl right now: https://github.com/JuliaGPU/CUDA.jl/pull/626. I think we just need to wait for a new tagged release.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756774971:8,Adapt,Adapt,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756774971,1,['Adapt'],['Adapt']
Modifiability,"Yeah sorry I wasn't expecting anyone to wade through #147, I also butchered the line endings in `time_steppers.jl`... That might be a nice enhancement where we change the AB-2 parameter to be `0.5 + χ`, then we can have two time stepping schemes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/160#issuecomment-479469850:139,enhance,enhancement,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/160#issuecomment-479469850,1,['enhance'],['enhancement']
Modifiability,"Yeah that would be better than hard coding things in. If we have flexible naming, then we should be able to output data that matches CliMA.jl or data that matches MITgcm output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/91#issuecomment-468294432:65,flexible,flexible,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/91#issuecomment-468294432,1,['flexible'],['flexible']
Modifiability,"Yeah that would definitely help with modularization. They might need to take in the whole model, e.g. `validate_coriolis(model)`, `validate_advection(model)`, etc. since it seems hard to anticipate all the inconsistent configurations. I remember you raised the concern of slowdowns in the case of running tons of small/column models. So maybe a kwarg like `check_consistency=true` would be good to add with this feature.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796342103:219,config,configurations,219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796342103,1,['config'],['configurations']
Modifiability,"Yeah the era of free Travis is over haha. We've already run out of Travis credits so some builds have stopped running. This is fine except for the fact that Travis currently builds our docs, so our docs won't update until we have more credits or we build and deploy docs elsewhere, e.g. from Buildkite. @maleadt has been setting up Buildkite pipelines for JuliaGPU and CUDA.jl so we could borrow from his `pipeline.yml`: https://github.com/JuliaGPU/CUDA.jl/blob/master/.buildkite/pipeline.yml. and his Buildkite plugins:. https://github.com/JuliaCI/julia-buildkite-plugin; https://github.com/JuliaCI/julia-test-buildkite-plugin; https://github.com/JuliaCI/julia-coverage-buildkite-plugin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1186#issuecomment-732312213:512,plugin,plugins,512,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1186#issuecomment-732312213,4,['plugin'],"['plugin', 'plugins']"
Modifiability,Yeah the model has changed so much since the branch but we refactored the 4th order `div_flux` operator to be element-wise and fit in with the new element-wise time stepping. I'll fix this pull request with that bit of code.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/76#issuecomment-466791096:59,refactor,refactored,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/76#issuecomment-466791096,1,['refactor'],['refactored']
Modifiability,"Yeah, rewriting the gh-pages branch should be good enough :+1: Generally I'd only rewrite a master branch as a tool of last resort because it can be quite disruptive :-)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/509#issuecomment-560949884:82,rewrite,rewrite,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/509#issuecomment-560949884,1,['rewrite'],['rewrite']
Modifiability,"Yeah, there a couple of bugs with the adaptive time step that I meant to fix with #3125 that reworks the internals of the split explicit solver to enable overlayed communication, but that is taking a bit too much, and we want to refactor the constructor (and internal structure) anyway so it's better to do it in a separate (maybe quicker) PR. I can adapt #3125 later",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695689450:38,adapt,adaptive,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695689450,3,"['adapt', 'refactor']","['adapt', 'adaptive', 'refactor']"
Modifiability,Yeah... Let's put this in the pot for a potential buoyancy refactor (see #2022).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2027#issuecomment-951393626:59,refactor,refactor,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2027#issuecomment-951393626,1,['refactor'],['refactor']
Modifiability,"Yeap, I agree. So are you thinking a config similar to the examples (e.g., rectilinear), start with mean state + some prescribed perturbation and run for up to, e.g., t=20 and compare output? How does that sound?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137969032:37,config,config,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137969032,1,['config'],['config']
Modifiability,"Yeap, let’s add them now and enhance/improve later",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880689429:29,enhance,enhance,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880689429,1,['enhance'],['enhance']
Modifiability,"Yep, we used nsys because our primary objective is to trace GPU execution. I think it will work also on CPU programs. ; There is nothing really specific about profiling julia with nsys, provided that MPI is correctly configured (i.e. your script works with MPI already). An example of a batch script that traces MPI calls is; ```; #!/bin/bash; #SBATCH -N 2; #SBATCH --ntasks-per-node=4; #SBATCH --cpus-per-task=16; #SBATCH --mem=500GB; #SBATCH --time 24:00:00; #SBATCH --gres=gpus:4. cat > launch.sh << EoF_s; #! /bin/sh; export CUDA_VISIBLE_DEVICES=0,1,2,3; exec \$*; EoF_s; chmod +x launch.sh. srun nsys profile --trace=nvtx,cuda,mpi --output=report_%q{SLURM_PROCID} ./launch.sh julia --check-bounds=no --project scaling_experiments.jl ; ```; Here, `nsys` will produce one report per processor. You can use `mpirun` or `mpiexec` instead of `srun`.; If you want to insert GC (garbage collection) annotations in the report through nvtx you need to add the environment variable ([ref](https://github.com/JuliaGPU/NVTX.jl)) ; ```; export JULIA_NVTX_CALLBACKS=gc; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396961670:217,config,configured,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396961670,2,"['config', 'variab']","['configured', 'variable']"
Modifiability,"Yes that would be ideal!. Actually I guess right now it might be tricky since you have to create the grid first for stretched and curvilinear grids. But for multi-architectures, you need to pass the grid as the grid topology could change the rank connectivity. So you end up having to specify `CPU()` for the grid, then pass it to the `MultiCPU` constructor, then pass that to the model. Would be great if we can specify the architecture in one place, but might require some refactoring that we'd have to think more about.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-799746052:475,refactor,refactoring,475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-799746052,1,['refactor'],['refactoring']
Modifiability,"Yes that's been fixed. We now have 77 rate of convergence tests that all pass (see below)! Running the Oceananigans tests with the `TEST_GROUP=convergence` environment variable will run all the convergence tests. # Convergence test plots. I also updated the figures:. ![point_exponential_decay_time_stepper_convergence](https://user-images.githubusercontent.com/20099589/91892428-a657aa00-ec60-11ea-9aac-fda57add457d.png). ![cosine_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91892442-abb4f480-ec60-11ea-9bbd-fc467558cc7f.png). ![cosine_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91895008-87f3ad80-ec64-11ea-81df-f7798ede83a7.png). ![gaussian_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91892452-afe11200-ec60-11ea-981c-eb8f406b2644.png). ![gaussian_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91895026-8de98e80-ec64-11ea-8254-e3027a41ca10.png). ![two_dimensional_diffusion_convergence](https://user-images.githubusercontent.com/20099589/91892463-b3749900-ec60-11ea-9915-ea9ea6232143.png). ![taylor_green_convergence](https://user-images.githubusercontent.com/20099589/91892468-b66f8980-ec60-11ea-9d05-0fafd0ca4dde.png). ![forced_free_slip_convergence](https://user-images.githubusercontent.com/20099589/91892470-b8394d00-ec60-11ea-8d6e-38419f4ad568.png). ![forced_fixed_slip_convergence](https://user-images.githubusercontent.com/20099589/91892479-b96a7a00-ec60-11ea-9301-7f9cf1322edd.png). # Rate of convergence tests; ```; [2020/09/01 13:29:06.313] INFO rate of convergence = 1.009563466619233 (expected ≈ 1.0, atol = 0.01); [2020/09/01 13:31:40.030] INFO 1D cosine diffusion only u_L₁ rate of convergence = -2.001484816201546 (expected ≈ -2.0, atol = 0.01); [2020/09/01 13:31:40.030] INFO 1D cosine diffusion only v_L₁ rate of convergence = -2.0014848162011636 (expected ≈ -2.0, atol = 0.01); [2020/09/01 13:31:40.030] INFO 1D c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/881#issuecomment-685075187:168,variab,variable,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/881#issuecomment-685075187,1,['variab'],['variable']
Modifiability,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:1065,rewrite,rewrite,1065,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970,1,['rewrite'],['rewrite']
Modifiability,"Yes we have some notes on the Fourier Poisson solver here: https://climate-machine.github.io/Oceananigans.jl/latest/algorithm/#Discrete-Fourier-spectral-method-1. Yes we'd need a _new_ Poisson solver with Neumann boundary conditions in two directions but this would be a minor change. I think we'd just have to use the same wavenumbers in the _y_-direction as we do for the _z_-direction [see equations (47) and (48)] and use DCTs in the _y_-direction instead of FFTs. I think that should be it but not 100% sure if it's that simple. **Note**: It's only this simple if _Δy_ and _Δz_ are constants (well, _Δz_ can be variable #46). But if both _Δy_ and _Δz_ are variable, then the Poisson solve will become much slower and more difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-468944198:616,variab,variable,616,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-468944198,2,['variab'],['variable']
Modifiability,"Yes, I’m happy to include general comments. We shouldn’t write too much on the topic. I think our advice will change when we have time stepping methods that are more appropriate for adaptive time stepping.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520910773:182,adapt,adaptive,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/356#issuecomment-520910773,1,['adapt'],['adaptive']
Modifiability,"Yes, most containers are ""adapted"" on the GPU. We adapt `field` to `field.data`:. https://github.com/CliMA/Oceananigans.jl/blob/7debded91d24520d72857c120303bcd22b805104/src/Fields/field.jl#L394. And note that `field.data` will be further adapted. For example, `CuArray` becomes `CuDeviceArray`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370320395:26,adapt,adapted,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370320395,3,['adapt'],"['adapt', 'adapted']"
Modifiability,"Yes, that is pretty much what I had in mind but for a different physical problem. . There are a variety of ways one can do this. Below are a few that come to mind. 1. Power method: worked well for Kelvin-Helmholtz instability and should work well for other problems. Two nice features are that it's pretty simple, and it's already coded up for one example so should be easy to adapt. One not so nice feature is that it only tells us the most unstable mode (spatial structure, growth rates and phase speed) but it doesn't tell us about any other unstable modes. 2. Arnoldi Method: A quick google search came across this [library](https://haampie.github.io/ArnoldiMethod.jl/stable/). I have not tried it but could try adapting it to the above mentioned KH problem. . 3. Standard eigenvals: If we assume periodicity in two directions it boils down to a 1D eigenvalue problem that should be easy to solve using eigenvals. There should be a direct solver that forms a full matrix and gives you all the eigenfunctions but the indirect uses Arnoldi and gives you some. . As for where they appera I don't kown but at some point, after I get a ShallowWaterModel off the ground, I will play around with different solvers and see what looks promising. This won't happen this week I'm pretty sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731274044:377,adapt,adapt,377,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731274044,2,['adapt'],"['adapt', 'adapting']"
Modifiability,"Yes. To be honest after your comments I'm completely lost. I thought I was getting a grasp on how structs and multiple dispatch worked, but now I'm 100% sure that I am 0% about everything :laughing: . I've defined something like this:. ```julia; struct SpatialWindowAverage{X, Y, Z, A, G, F, S, D} <: AbstractField{X, Y, Z, A, G}; data :: A; grid :: G; field :: F; field_slicer :: S; dims :: D; end. SpatialWindowAverage(field; dims, field_slicer=FieldSlicer()) =; SpatialWindowAverage(field.data, field.grid, field, field_slicer, dims); ```. But of course, it's missing `X, Y, Z`. But to get them I need those `drop_averaged_dims` functions and I'm not sure how to work them on reduced fields. . So far I've been looking at how `AveragedField` is defined, but that's exactly what @glwagner recommended I not do, since apparently it's difficult to adapt it for what I want... And in the mean time I'm computing these averages offline, which is taking a very long time haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783547675:848,adapt,adapt,848,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783547675,1,['adapt'],['adapt']
Modifiability,"Yes:. ```julia; cool_forcing_function(i, j, k, grid, clock, state, parameters) = # something that uses the parameters argument; cool_forcing = ParameterizedForcing(cool_forcing_function, parameters=(a=1, b=2)); ```. Pretty much the same way that it's used for `SimpleForcing`, except here we can make `parameters` a required keyword argument.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595944509:143,Parameteriz,ParameterizedForcing,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595944509,1,['Parameteriz'],['ParameterizedForcing']
Modifiability,"Yesterday, @ali-ramadhan and I discussed a new idea for improving the abstraction of equations. The idea is to abstract a `RightHandSide` consisting of a tuple of `Flux`es and `VolumeTerm`s or `SourceTerm`s. Each `Flux` or `VolumeTerm` type would define a `getindex` method, and carry around the references needed to execute that `getindex` method on CPU or GPU. This would greatly simplify the time-stepping routines, which currently involve long function signatures. There'd be no need for 'unpacking', because each term in the equation would perform unpacking upon instantiation. It would also probably be easier for users to extend / add terms to an equation. As an example, we can consider a simple implementation. ```julia; struct AdvectiveFlux{S, D, C, G}; u :: D; v :: D; w :: D; c :: C; grid :: G; scheme :: S; end. getindex(adv::AdvectiveFlux{Centered}, i, j, k) = # centered advective flux calculation. struct IsotropicDiffusiveFlux{N, D, G}; ν :: N; ψ :: D; grid :: G; end. getindex(diff::IsotropicDiffusiveFlux, i, j, k) = # calculates flux due to isotropic diffusion by ν. struct RightHandSide{F, V}; fluxes :: F; volume_terms :: V; end. advection = AdvectiveFlux(velocities..., tracers.c); diffusion = IsotropicDiffusiveFlux(ν, tracers.c). tracer_rhs = RightHandSide((advection, diffusion), nothing); ```. We'd have functions that look something like. ```julia; function x_flux_divergence(i, j, k, grid, fluxes...); incoming_flux = add_fluxes(i, j, k, grid, fluxes...); outgoing_flux = add_fluxes(i+1, j, k, grid, fluxes...); return (incoming_flux - outgoing_flux) * grid.Ax / grid.V; end; ```. ... for example. Obviously questions of performance are paramount, though in the case that _everything_ is inlined I think there is hope. A downside of this approach is that we can't use shared memory stencils on the GPU. Shared memory stencils on the GPU require _functions_ for all terms that avoid carrying around internal references to data (since we need to be able to pass them referen",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394:629,extend,extend,629,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394,1,['extend'],['extend']
Modifiability,"You can run then again the `forced_flow_fixed_slip.jl` with a slightly different configuration: now y should be the periodic direction. The solution this time should be the same as the original case but with x->y, y->x, no? Then you'll test all directions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/965#issuecomment-696358198:81,config,configuration,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/965#issuecomment-696358198,1,['config'],['configuration']
Modifiability,"You can use `FluxBoundaryCondition` with `closure=nothing` (it's `Value` and `Gradient` that won't work). You can obtain global dissipation by differencing globally integrated TKE (and perhaps a pointwise dissipation by evaluating the TKE budget), but I agree that it's probably more difficult. @simone-silvestri may have some tips as he has been developing an implicit LES scheme for mesoscale turbulence. Does `AnisotropicMinimumDissipation` work? Or other closures?. I'm wondering if the problem is the use of a `BinaryOperation` for the diffusivities with `SmagorinskyLilly`:. https://github.com/CliMA/Oceananigans.jl/blob/b7ad891c718c16db35d70ee86da81a74ad2f7370/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L214. It might be possible to avoid using that `BinaryOperation` by instead extending the three diffusivity getter functions:. https://github.com/CliMA/Oceananigans.jl/blob/b7ad891c718c16db35d70ee86da81a74ad2f7370/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L87-L89",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403103597:823,extend,extending,823,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403103597,1,['extend'],['extending']
Modifiability,"You cannot implement any kind of variable Coriolis force with horizontally periodic boundary conditions, because the equations are no longer periodic in that case. You *can* use a Cartesian grid with an arbitrarily variable Coriolis force if you implement non-periodic boundary conditions in the north-south direction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/28#issuecomment-462547373:33,variab,variable,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/28#issuecomment-462547373,2,['variab'],['variable']
Modifiability,"You need to use `Open` to set boundary-normal velocities. However, what you're trying to do may not be supported. @jagoosw may know more. Can you please provide more detail about the setup you are trying to run?. > Then, i have another question. i want to output wind stress (top flux boundary condition) to jld2 or netcdf. But i cannot save or find wind stress (top flux boundary condition) from model. So, which field or variable can i set to save wind stress. Is there a simple example?. This depends on how you are setting the wind stress --- are you using a function or array? If you provide more details we can figure it out. I converted this to a discussion because we are not trying to change the source code (as far as I can tell).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3612#issuecomment-2148897056:423,variab,variable,423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3612#issuecomment-2148897056,1,['variab'],['variable']
Modifiability,"You should write. ```julia; import Oceananigans.Utils: cell_advection_timescale; ```. at the top of the file `shallow_water_cell_advection_timescale.jl`. This ""imports"" the name `cell_advection_timescale` into your present scope such that the function can be extended with new methods. Next, you want to define a new method for `cell_advection_timescale` with the signature. ```julia; cell_advection_timescale(model::ShallowWaterModel) = # definition here; ```. Note that the function signature. ```julia; cell_advection_timescale(uh, vh, h, grid); ```. is already taken by one of the existing methods for `cell_advection_timescale`:. https://github.com/CliMA/Oceananigans.jl/blob/2016e730350e0b6b625a5cf85a68269a370686fd/src/Utils/cell_advection_timescale.jl#L2-L12. This means that you need to either use type annotations to distinguish the version that takes arguments `uh, vh, h, grid` from the method that takes `u, v, w, grid`, or (probably better) use a unique name. A good name for the method that takes the arguments `uh, vh, h, grid` could be. ```julia; shallow_water_cell_advection_timescale(uh, vh, h, grid) = # definition here; ```. Remember that with this new name, the function `cell_advection_timescale(model::ShallowWaterModel)` must call `shallow_water_cell_advection_timescale`; eg. ```; cell_advection_timescale(model::ShallowWaterModel) =; shallow_water_cell_advection_timescale(model.solution.uh.data.parent,; model.solution.vh.data.parent,; model.solution.h.data.parent,; model.grid); ```. when this file is put together, you should include it in `ShallowWaterModels.jl`. This should allow you to `run!` a `Simulation` with `TimeStepWizard`. Perhaps it makes sense to add a test for this in this PR?. If this does not work, feel free to copy/paste the error here so that we can debug the issue. Note: I was confused earlier --- I definitely prefer `shallow_water_cell_advection_timescale.jl` for the filename. But anything will do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764060246:259,extend,extended,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764060246,1,['extend'],['extended']
Modifiability,"You start with a very unstable stratification so you set up Rayleigh-Taylor instability. The reason you get inf temp is because simulation blows up. If I reduce the time-step I can integrate up to the final time of `t=80sec` that you chose, but if you need to integrate further probably you need to reduce the time-step further or add a time-step wizard... I enhanced your script a bit with a log message to keep track of the CFL... I also added RK3 time-step. I also reduced the resolution to 128^3 so I can experiment as my laptop cannot casually run 256^3 simulations :) . ```Julia; using Oceananigans; using Oceananigans.OutputWriters, Oceananigans.Fields; using Oceananigans.Utils:day, hour, minute, second. grid1 = RegularCartesianGrid(size=(128, 128, 128), y=(-500, 500), x=(-500, 500), z=(-500, 0),topology = (Periodic, Periodic, Bounded)). model1=IncompressibleModel(grid=grid1,architecture = CPU(),float_type=Float64,clock = Clock(time=0.0),coriolis = BetaPlane(rotation_rate=7.292115e-5, latitude=0, radius=6371e3), timestepper = :RungeKutta3,; tracers=(:T, :S),buoyancy=SeawaterBuoyancy(),closure=AnisotropicDiffusivity(νh=1e-3, νz=5e-2, κh=2e-3, κz=1e-1)). @inline thermoc(x, y, z) = 16-12*tanh((z+250)/10)+rand(Float64); @inline sal(x, y, z) = 16+12*tanh((z+250)/10)+rand(Float64); set!(model1, u=-0.05, v=0, T=thermoc, S=sal). using Oceananigans.Diagnostics: AdvectiveCFL. CFL = AdvectiveCFL(wizard). start_time = time_ns(). progress(sim) = @printf(""i: % 6d, sim time: % 10s, wall time: % 10s, Δt: % 10s, CFL: %.2e\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - start_time)),; prettytime(sim.Δt),; CFL(sim.model)). simulation = Simulation(model1, Δt=2., stop_time=80second, iteration_interval=4, progress=progress). function init_save_some_metadata!(file, model); file[""author""] = ""oofs""; return nothing; end. simulation.output_writers[:tracers] = JLD2OutputWriter(model1, model1.tracers,; prefix = ""Temp Data"",; schedule = TimeInterv",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-730997277:359,enhance,enhanced,359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-730997277,1,['enhance'],['enhanced']
Modifiability,"Your suggestion is easily achieved by defining a `getindex` method for objects of type `Field`. For example:. ```; import Base: getindex. getindex(f::Field, inds...) = getindex(f.f, inds...); ```; Then `u[i]` translates to `u.f[i]` when `u` is a `Field`. I am refactoring `fields.jl` right now and implementing something essentially like this. Ultimately I think a nice API will relieve the user of interacting with the data arrays at all. For example, the correct way to set temperature could be something like . ```; set_surface_temperature!(model, 300); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/5#issuecomment-439148055:260,refactor,refactoring,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/5#issuecomment-439148055,1,['refactor'],['refactoring']
Modifiability,"Yup it should be flexible enough to adapt it for ocean modeling. Might be worth thinking whether we need any additional abstractions. One important point is that the numerical method used does not time step pressure, it is instead diagnosed from potential temperature or entropy. May require some thought if we want to modify the speed of sound.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-579990039:17,flexible,flexible,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-579990039,2,"['adapt', 'flexible']","['adapt', 'flexible']"
Modifiability,"[`Relaxation`](https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Forcings/relaxation.jl#L24-L73) applies to more than just sponge layers --- it's a convenience wrapper for a forcing function that ""relaxes"" a field to some `target` at a specified `rate`, limited to a region outside a `mask` function. `Relaxation` is actually a special type of callable `ContinuousForcing`:. https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Forcings/relaxation.jl#L81-L82. The snippet shows that `mask` is callable with the signature `x, y, z` and target is callable with the signature `x, y, z, t`. Any appropriate `mask` and `target` will work. Also, we've provided a parameterized convenience type for a Gaussian `mask`. So, sponge layers are simply one application of `Relaxation`. @tomchor, perhaps what you're saying is that a Gaussian is not appropriate for a sponge layer `mask`, since one might want a function with a sharper cutoff (subject to @navidcy's caveats). I think this is a valid criticism --- it might make sense to add more appropriate parameterized types (using tanh's, etc?) This could be added in a PR that also updates the documentation and provides a better example for implementing a sponge layers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733252410:171,layers,layers,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733252410,5,"['layers', 'parameteriz']","['layers', 'parameterized']"
Modifiability,[da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [9e8cae18] Oceananigans v0.76.5 `/g/data/v45/nc3020/OC.jl`; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [91a5bcdd] Plots v1.36.0; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.7; [a759f4b9] TimerOutputs v0.5.19; [bdfc003b] TimesDates v0.3.1; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates `@stdlib/Dates`; [b77e0a4c] InteractiveUtils `@stdlib/InteractiveUtils`; [37e2e46d] LinearAlgebra `@stdlib/LinearAlgebra`; [56ddb016] Logging `@stdlib/Logging`; [44cfe95a] Pkg `@stdlib/Pkg`; [de0858da] Printf `@stdlib/Printf`; [9a3f8284] Random `@stdlib/Random`; [2f01184e] SparseArrays `@stdlib/SparseArrays`; [10745b16] Statistics `@stdlib/Statistics`; [8dfed614] Test `@stdlib/Test`; Status `/jobfs/73413669.gadi-pbs/jl_XhyZPR/Manifest.toml`; [621f4979] AbstractFFTs v1.1.0; [79e6a3ab] Adapt v3.3.3; [4fba245c] ArrayInterface v6.0.1; [30b0a656] ArrayInterfaceCore v0.1.2; [ab4f0b2a] BFloat16s v0.2.0; [6e4b80f9] BenchmarkTools v1.3.2; [d1d4a3ce] BitFlags v0.1.7; [fa961155] CEnum v0.4.2; [179af706] CFTime v0.1.2; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [49dc2e85] Calculus v0.5.1; [7057c7e9] Cassette v0.3.10; [d360d2e6] ChainRulesCore v1.15.0; [9e997f8a] ChangesOfVariables v0.1.3; [944b1d66] CodecZlib v0.7.1; [35d6a980] ColorSchemes v3.20.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.9.10; [5ae59095] Colors v0.12.10; [34da2185] Compat v3.43.0; [a216cea6] CompoundPeriods v0.5.1; [d38c429a] Contour v0.6.2; [a2441757] Coverage v1.6.0; [c36e975a] CoverageTools v1.3.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [9a962f9c] DataAPI v1.10.0; [124859b0] DataDeps v0.7.10; [864edb3b] DataStructures v0.18.12; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.11.0; [ffbed154] DocStringExtensions v0.8.6; [fa6b7ba4] DualNu,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:1917,Adapt,Adapt,1917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Adapt'],['Adapt']
Modifiability,"`PartialCellBottom` has a couple of bugs in the implementation that make it crash in simple cases like the `internal_tide.jl` example. @jm-c is working on fixing the implementation and should open a PR soon to fix the bugs.; However, it is indeed a problem in the adapt. ; I can it in a PR, still if you use PartialCellBottom know that probably it will lead to a crashing simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269880138:264,adapt,adapt,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269880138,1,['adapt'],['adapt']
Modifiability,"```; [e9e359dc] CUDA_jll v10.0.130+3; ```. That JLL is deprecated and shouldn't be used. For one, it `dlopen`s plenty of libraries eagerly, as can be seen at the start of the test:. ```; Testing Running tests...; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ```. Opening many copies of CUDA libraries easily breaks the whole system, and might explain the CUBLAS failure here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2902#issuecomment-1418738849:253,variab,variable,253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2902#issuecomment-1418738849,4,"['Config', 'config', 'variab']","['Config', 'config', 'variable']"
Modifiability,"```; julia> using Distributed. help?> addprocs; search: addprocs. addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers. Launches worker processes via the specified cluster manager. For example, Beowulf clusters are supported via a custom cluster manager implemented in the package ClusterManagers.jl. The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable; JULIA_WORKER_TIMEOUT in the worker process's environment. Relevant only when using TCP/IP as transport. To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute addprocs in its own task. Examples; ≡≡≡≡≡≡≡≡≡≡. # On busy clusters, call `addprocs` asynchronously; t = @async addprocs(...). # Utilize workers as and when they come online; if nprocs() > 1 # Ensure at least one new worker is available; .... # perform distributed execution; end. # Retrieve newly launched worker IDs, or any error messages; if istaskdone(t) # Check if `addprocs` has completed to ensure `fetch` doesn't block; if nworkers() == N; new_pids = fetch(t); else; fetch(t); end; end. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers. Add worker processes on remote machines via SSH. Configuration is done with keyword arguments (see below). In particular, the exename keyword; can be used to specify the path to the julia binary on the remote machine(s). machines is a vector of ""machine specifications"" which are given as strings of the form [user@]host[:port] [bind_addr[:port]]. user defaults to; current user and port to the standard SSH port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified; bind_addr and port. It is possible to launch multiple processes on a r",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:442,variab,variable,442,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['variab'],['variable']
Modifiability,"```julia; julia> f = Adapt.adapt(0); (::Base.Fix1{typeof(adapt), Int64}) (generic function with 1 method). julia> typeof(f); Base.Fix1{typeof(adapt), Int64}; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187:21,Adapt,Adapt,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187,4,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,"```julia; mutable struct Clock{T}; time :: T; iteration :: Int; end; ```; Ah right so mutable structs are not `isbits` and so they cannot be passed into GPU kernels... We might have to roll back to using `time, iteration` in kernel and forcing/boundary function signatures instead of `clock`. But maybe it's simple enough that it could be adapted to the GPU...?. @vchuravy @maleadt Would it be possible to adapt a very simple `mutable struct` like `Clock{T}` to work in GPU kernels with Adapt.jl? It's never modified in a GPU kernel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/697#issuecomment-599079071:339,adapt,adapted,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/697#issuecomment-599079071,3,"['Adapt', 'adapt']","['Adapt', 'adapt', 'adapted']"
Modifiability,"```julia> using Pkg; pkg""st --manifest""; Status `~/.julia/environments/v1.5/Manifest.toml`; [621f4979] AbstractFFTs v1.0.1; [79e6a3ab] Adapt v3.3.0; [4fba245c] ArrayInterface v3.1.7; [56f22d72] Artifacts v1.3.0; [ab4f0b2a] BFloat16s v0.1.0; [6e34b625] Bzip2_jll v1.0.6+5; [fa961155] CEnum v0.4.1; [179af706] CFTime v0.1.1; [052768ef] CUDA v2.4.3; [83423d85] Cairo_jll v1.16.0+6; [7057c7e9] Cassette v0.3.5; [d360d2e6] ChainRulesCore v0.9.38; [944b1d66] CodecZlib v0.7.0; [35d6a980] ColorSchemes v3.12.0; [3da002f7] ColorTypes v0.10.12; [5ae59095] Colors v0.12.7; [34da2185] Compat v3.27.0; [e66e0078] CompilerSupportLibraries_jll v0.3.4+0; [d38c429a] Contour v0.5.7; [a8cc5b0e] Crayons v4.0.4; [7445602f] CubedSphere v0.1.0; [9a962f9c] DataAPI v1.6.0; [864edb3b] DataStructures v0.18.9; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.0.2; [ffbed154] DocStringExtensions v0.8.4; [5ae413db] EarCut_jll v2.1.5+1; [b305315f] Elliptic v1.0.1; [2e619515] Expat_jll v2.2.7+6; [e2ba6199] ExprTools v0.1.3; [c87230d0] FFMPEG v0.4.0; [b22a6f82] FFMPEG_jll v4.3.1+4; [7a1cc6ca] FFTW v1.3.2; [f5851436] FFTW_jll v3.3.9+7; [53c48c17] FixedPointNumbers v0.8.4; [a3f928ae] Fontconfig_jll v2.13.1+14; [59287772] Formatting v0.4.2; [d7e528f0] FreeType2_jll v2.10.1+5; [559328eb] FriBidi_jll v1.0.5+6; [0656b61e] GLFW_jll v3.3.3+0; [0c68f7d7] GPUArrays v6.2.2; [61eb1bfa] GPUCompiler v0.8.3; [28b8d3ca] GR v0.57.4; [d2c73de3] GR_jll v0.57.2+0; [5c1252a2] GeometryBasics v0.3.12; [78b55507] Gettext_jll v0.20.1+7; [7746bdde] Glib_jll v2.59.0+4; [c27321d9] Glob v1.3.0; [42e2da0e] Grisu v1.0.0; [0234f1f7] HDF5_jll v1.12.0+1; [cd3eb016] HTTP v0.9.5; [615f187c] IfElse v0.1.0; [83e8ac13] IniFile v0.5.0; [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2; [c8e1da08] IterTools v1.3.0; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.3; [692b3bcd] JLLWrappers v1.3.0; [682c06a0] JSON v0.21.1; [0f8b85d8] JSON3 v1.8.0; [aacddb02] JpegTurbo_jll v2.0.1+3; [63c18a36] KernelAbstractions v0.5.5; [c1c5ebd",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824063115:135,Adapt,Adapt,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824063115,1,['Adapt'],['Adapt']
Modifiability,"`const` matters when a variable is referenced as a global variable in a function; something like. ```julia; const a = 2; f(x) = a * x; ```. `a` is not an argument to `f(x)`; it's value is taken from the global scope. In that case it needs to be `const`, or `f(x)` cannot be compiled on the GPU. When numbers are added to explicit data structures --- which is what happens when they are inserted into the `parameters` kwarg in the constructor for `BoundaryCondition` or `Forcing` --- then it's irrelevant whether a variable is declared `const`. This is because in that case the variable is explicitly an argument to the function (eg via the argument `p` in `boundary_condition(x, y, t, p)`). In fact, this is the purpose of the `parameters` kwarg --- to avoid having to use `const` (which is annoying or inconvenient, and has compilation / performance pitfalls). However the API has not developed enough to completely avoid `const` in all cases (eg for `BackgroundFields`, or for masking / target functions in things like `Relaxation`). So we still wrestle with it from time to time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697:23,variab,variable,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697,4,['variab'],['variable']
Modifiability,"`interior` is interesting. Are we sure that we should extend this at all? It's main purpose would be debugging I guess, since any time you are using MultiRegion for real, you likely wouldn't want to call it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1305850688:54,extend,extend,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1305850688,1,['extend'],['extend']
Modifiability,"`time_step_precomputations!` is. ```julia; function time_step_precomputations!(diffusivities, pressures, velocities, tracers, model). fill_halo_regions!(merge(velocities, tracers), model.boundary_conditions.solution, model.architecture,; model.grid, boundary_condition_function_arguments(model)...). calculate_diffusivities!(diffusivities, model.architecture, model.grid, model.closure, model.buoyancy,; velocities, tracers). fill_halo_regions!(diffusivities, model.boundary_conditions.diffusivities, model.architecture, model.grid). @launch(device(model.architecture), config=launch_config(model.grid, :xy),; update_hydrostatic_pressure!(pressures.pHY′, model.grid, model.buoyancy, tracers)). fill_halo_regions!(pressures.pHY′, model.boundary_conditions.pressure, model.architecture, model.grid). return nothing; end; ```. To implement the optimizations discussed in this issue, we need to also consider the calculation of hydrostatic pressure and nonlinear diffusivities to intertwine communication with interior tendency computation. Can this be done abstractly perhaps via some combination of launch configurations and macro specifications to `@loop_xyz`? This would allow us to exert control over the ""region"" of interior source term computation from the ""outside"", while keeping our kernels intact. Notice that the ""pre-computation"" of nonlinear diffusivities and the isolation of the hydrostatic pressure both add communication steps. We should monitor whether these become significantly suboptimal algorithms in the presence of expensive communication. We can easily combine hydrostatic pressure with nonhydrostatic pressure with no loss of performance (probably a small performance increase, in fact). We can also in principle calculate nonlinear diffusivities ""in-line"", though when we tried this previously we were unable to achieve good performance. Also, ""in-line"" calculation of diffusivities makes the application of diffusivity boundary conditions much more difficult (or impossible).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/615#issuecomment-583379290:2584,config,configurations,2584,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/615#issuecomment-583379290,1,['config'],['configurations']
Modifiability,a 'simple forcing' script to reproduce this error is here:. https://github.com/climate-machine/Oceananigans.jl/blob/631b861bcfdbfd894c4cb6b2257a16aa8c55f8cc/sandbox/simple_forcing.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496482547:157,sandbox,sandbox,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496482547,1,['sandbox'],['sandbox']
Modifiability,"adrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/Tl08O/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2028,Adapt,Adapt,2028,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,2,['Adapt'],['Adapt']
Modifiability,"ally $z_grid_type grid ...""; grid = lagrangian_particle_test_grid(arch, y_topo, z); # run_simple_particle_tracking_tests(arch, grid, timestepper); @show grid; end; ```. which would give us these 8 (per architecture) test cases. ```julia; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Periodic on vertically uniform grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Periodic on vertically stretched grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Flat on vertically uniform grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo ; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Flat on vertically stretched grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5 ; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Periodic on vertically uniform grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2063314232:1758,variab,variably,1758,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2063314232,1,['variab'],['variably']
Modifiability,"amadhan thanks a lot for this great work. I'm super excited to have this feature!. > Domain decomposition is supported and tested in x, y, and z. But for IncompressibleModel z-decomposition won't work right now because vertical integrals are done inside GPU kernels (so we probably don't want to decompose in z). And PencilFFTs.jl supports decompositions in dimensions 2 and 3 (since dimension 1 FFTs are the fastest). As a result, right now Oceananigans.jl only supports slab decompositions in y although we should figure out if pencil decompositions are possible. Sorry if I'm misunderstand some things (I'm not very familiar with the pressure-solver implementations) but it looks to me like this isn't an issue for the pressure solver, right? (Based on the fact that you got a 2D turbulence example going.) . If that's the case, then this limitation might be okay for now, as it would only affect cases we're you'd want to parallelize in `x` for efficiency purposes but you could still get away with running your set-up in a less-than-optimal configuration, no? I think this would be similar to the old limitation of being able to run `(Bounded, Periodic, Bounded)` domains only in CPUs. This was not optimal but if you wanted to circumvent this you could easily do so by rotating your domain to make it `(Periodic, Bounded, Bounded)` which _could_ be run on GPUs. Also (again correct me if I'm missing something) from my talks with you guys about this it seems that the primary goal of MPI-distributed parallelism is to run multi-GPU simulations, since GPUs have a relatively low memory limit. In this case, I think the way to use MPI is very different from the traditional multi-CPU runs. That is, I think the important capabilities when distributing a simulation across a few GPUs are different from the important capabilities when distributing it across hundreds of CPU cores. > I guess if we consider communication as a boundary conditions, then it makes sense to use Bounded in any case where",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-785220748:1052,config,configuration,1052,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-785220748,1,['config'],['configuration']
Modifiability,"an Diego; 9500 Gilman Drive #0085; La Jolla, CA 92093. On Mon, Oct 7, 2024 at 6:38 AM Simone Silvestri ***@***.***>; wrote:. > Yep, we used nsys because our primary objective is to trace GPU execution.; > I think it will work also on CPU programs.; > There is nothing really specific about profiling julia with nsys, provided; > that MPI is correctly configured (i.e. your script works with MPI already).; > An example of a batch script that traces MPI calls is; >; > #!/bin/bash; > #SBATCH -N 2; > #SBATCH --ntasks-per-node=4; > #SBATCH --cpus-per-task=16; > #SBATCH --mem=500GB; > #SBATCH --time 24:00:00; > #SBATCH --gres=gpus:4; >; > cat > launch.sh << EoF_s; > #! /bin/sh; > export CUDA_VISIBLE_DEVICES=0,1,2,3; > exec \$*; > EoF_s; > chmod +x launch.sh; >; > srun nsys profile --trace=nvtx,cuda,mpi --output=report_%q{SLURM_PROCID} ./launch.sh julia --check-bounds=no --project scaling_experiments.jl; >; > Here, nsys will produce one report per processor. You can use mpirun or; > mpiexec instead of srun.; > If you want to insert NVTX annotations inside the code you need to add the; > environment variable (ref; > <https://urldefense.com/v3/__https://github.com/JuliaGPU/NVTX.jl__;!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6C7RIjP6$>; > ); >; > export JULIA_NVTX_CALLBACKS=gc; >; > —; > Reply to this email directly, view it on GitHub; > <https://urldefense.com/v3/__https://github.com/CliMA/Oceananigans.jl/pull/3125*issuecomment-2396961670__;Iw!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6H5RkVsz$>,; > or unsubscribe; > <https://urldefense.com/v3/__https://github.com/notifications/unsubscribe-auth/ACLGGWEQFWMJVYNAYQ7WX4LZ2KFD3AVCNFSM6AAAAABPKAGA5GVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDGOJWHE3DCNRXGA__;!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6OcpZ5Rs$>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396992719:1470,variab,variable,1470,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396992719,1,['variab'],['variable']
Modifiability,"annoying that the tests need a little refactoring too, but maybe its all for the best.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1520495458:38,refactor,refactoring,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1520495458,1,['refactor'],['refactoring']
Modifiability,"arshall54 <https://github.com/johncmarshall54>, Ali experimented; > with a simple immersed boundary implemented via Oceananigans's user-defined; > forcing functions. The code is these 9 lines:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/a921fc3edbf795bf4a2193cca84cad41ebdd5625/verification/flow_around_cylinder/flow_around_cylinder.jl#L18-L27; >; > This implementation damps the velocity field to zero on a very fast; > time-scale (specified by the parameter K) within the immersed boundary.; > This is certainly a nice, simple immersed boundary implementation for; > Dirichlet / Value boundary conditions and could a good starting point.; > However, I also think there's some good reasons to pursue an alternate; > immersed boundary implementation to what @ali-ramadhan; > <https://github.com/ali-ramadhan> has done for the following reasons:; >; > 1. @ali-ramadhan <https://github.com/ali-ramadhan>'s implementation; > doesn't obviously extend to other boundary conditions, like prescribed; > gradients or fluxes (the latter being crucial for the geophysical problems; > we're interested in). So, even if we use a continuous forcing method; > similar to @ali-ramadhan <https://github.com/ali-ramadhan>'s; > implementation, we need to figure out how to enforce boundary conditions; > other than Dirichlet boundary conditions.; > 2. @ali-ramadhan <https://github.com/ali-ramadhan>'s implementation; > conforms exactly to the grid; however we would like to be able to model; > smoothly-varying boundaries.; > 3. As noted by @whitleyv <https://github.com/whitleyv>, @ali-ramadhan; > <https://github.com/ali-ramadhan>'s ""continuous forcing method""; > implementation introduces a time-step restriction due to the need to; > explicitly resolve the damping time-scale in the forcing function. It seems; > that a discrete forcing method overcomes this restriction and could prove; > crucial for geophysical problems that involve otherwise long time-steps.; >; > —; > You are receiving this becaus",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707413052:1148,extend,extend,1148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707413052,1,['extend'],['extend']
Modifiability,"art @visr @evetion @mkborregaard and @juliohm will be in a better position to comment about it.; > ; > *The packages in JuliaGeo have been mostly focused on IO and has not had the bandwidth to think about how it might interface with packages for (climate/ocean/etc) models. That might be useful down the line! Yes we're both around MIT. I think we're still figuring how we want to do IO in the long-term but will definitely want some way to output NetCDF. > Hey, original author of both https://github.com/JuliaGeo/NetCDF.jl and https://github.com/meggart/ZarrNative.jl here. Regarding the state of NetCDF.jl , yes I would say I mostly stopped developing the package due to time constraints and currently shift my focus towards Zarr since this is what we are using in our current project.; > ; > My last attempt at improving the NetCDF solved many of the issues with the package JuliaGeo/NetCDF.jl#61 but was not merged because of conflicts with other bugfix PRs. However, might be source of inspiration if someone wants to do a rewrite.; > ; > Regarding write performance, I would be very interested to see examples where NetCDF.jl performs worse than e.g. python-netcdf4, since most of the time should be spent in the same NetCDF C library. I have been using the package extensively and did not experience it to be slower than comparable packages.; > ; > I you are worried about the robustness of NetCDF.jl, you should not even look at ZarrNative.jl, since it is still very young and rather a prototype.; > ; > I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool. Thanks so much for working on NetCDF.jl! I didn't mean to sound ungrateful about NetCDF.jl's performance. We were just debating which package to use. With https://github.com/JuliaGeo/NetCDF.jl/issues/87 fixed, I think we'll be happy for a long time. The `compress=9` bug explains why the IO was slow. @glwagner has suggested that for a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847:1205,rewrite,rewrite,1205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847,1,['rewrite'],['rewrite']
Modifiability,"aryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}}, Const{NamedTuple{(:c,), Tuple{BoundaryCondition{Flux, Nothing}}}}, Const{Nothing}, Const{NamedTuple{(), Tuple{}}}, Const{typeof(Oceananigans.Forcings.zeroforcing)}, Duplicated{Clock{Float64}}}, dynamic::KernelAbstractions.NDIteration.NoDynamicCheck, static_threads::Bool);   | @ KernelAbstractions /storage5/buildkite-agent/.julia-14477/packages/KernelAbstractions/WoCk1/src/cpu.jl:82;   | [6] (::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(64, 64, 8)}, typeof(EnzymeExt.aug_fwd)})(::Function, ::Vararg{Any}; ndrange::Nothing, workgroupsize::Nothing);   | @ KernelAbstractions /storage5/buildkite-agent/.julia-14477/packages/KernelAbstractions/WoCk1/src/cpu.jl:44;   | [7] augmented_primal(::EnzymeCore.EnzymeRules.ConfigWidth{1, false, false, (false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true)}, ::Const{KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(64, 64, 8)}, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.cpu_compute_hydrostatic_free_surface_Gc!)}}, ::Type{Const{Nothing}}, ::Duplicated{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1953382929:17070,Config,ConfigWidth,17070,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1953382929,1,['Config'],['ConfigWidth']
Modifiability,"ase.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Vararg{Any}; ndrange::Nothing, workgroupsize::Nothing);   | @ EnzymeExt /storage5/buildkite-agent/.julia-14477/packages/KernelAbstractions/WoCk1/ext/EnzymeExt.jl:62;   | [8] augmented_primal(::EnzymeCore.EnzymeRules.ConfigWidth{1, false, false, (false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true)}, ::Const{KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(64, 64, 8)}, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.cpu_compute_hydrostatic_free_surface_Gc!)}}, ::Type{Const{Nothing}}, ::Duplicated{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1953382929:18835,Config,ConfigWidth,18835,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1953382929,1,['Config'],['ConfigWidth']
Modifiability,"at line 93. ```julia; @inline Fxn_scale(t) = spl_scale(t); ```. which itself is calling some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to your setup? Interpolations.jl might be an option but I'm not sure if it's GPU compatible. Worst case scenario maybe it wouldn't be too hard to code up a simple spline/interpolation scheme?. If you're looking for a 5~10x speedup you could try running multithreaded (run `julia",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:1280,variab,variables,1280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660,1,['variab'],['variables']
Modifiability,before it was 52 or 56min... so perhaps it helped slightly but also sometimes depending on how many thing tartarus is doing at the moment you can have some variability in times.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1601994163:156,variab,variability,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1601994163,1,['variab'],['variability']
Modifiability,"belms with Oceananigans?. ```. ✗ Oceananigans; --;   | 105 dependencies successfully precompiled in 112 seconds;   | 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package;   | Precompiling project...;   | ✗ Oceananigans;   | 0 dependencies successfully precompiled in 22 seconds. 105 already precompiled.;   |  ;   | ERROR: The following 1 direct dependency failed to precompile:;   |  ;   | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];   |  ;   | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-9773/compiled/v1.8/Oceananigans/jl_yggB5x.;   | [NVBLAS] No Gpu available;   | [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf';   | [NVBLAS] Cannot open default config file 'nvblas.conf';   | [NVBLAS] Config parsed;   | [NVBLAS] CPU Blas library need to be provided;   | ERROR: LoadError: syntax: missing comma or ) in argument list;   | Stacktrace:;   | [1] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/non_traditional_beta_plane.jl:75;   | [2] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [3] include(x::String);   | @ Oceananigans.Coriolis ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:1;   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:28;   | [5] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [6] include(x::String);   | @ Oceananigans ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:5;   | [7] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:230;   | [8] include;   | @ ./Base.jl:419 [inlined];   | [9] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing);   | @ Base ./loadi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445:1071,Config,Config,1071,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445,1,['Config'],['Config']
Modifiability,"bservation at [Ocean Station Papa](https://www.pmel.noaa.gov/ocs/Papa). The UW APL group has very nice [Waverider mooring observations there](https://cdip.ucsd.edu/themes/cdip?d2=p70&u2=s:166:v:parameter). Fig. 7 and Fig.8a,b of [this paper](https://doi.org/10.5194/gmd-14-4261-2021) is a comparison of the Stokes drift between the ""theory wave"" and OS Papa in one year. [Here](https://github.com/qingli411/A2020_CVMix_in_GOTM/blob/main/OSPapa/ospapa_stokes_drift.nc) is the half-hourly Stokes drift data I computed from the wave spectrum at OS Papa used in that paper (without directional spreading). It was computed on a 1 m vertical grid in the upper 36 m and a much coarser grid below. But I can easily compute it on a finer grid if we need. . > Since Oceananigans doesn't yet have bulk formulae, we have to ""invert"" a toy bulk formula to obtain an ""expected air speed"" for a given kinematic momentum flux τ. I'm not sure whether it makes more sense to parameterize Stokes drift in terms of U10 or momentum flux (momentum fluxes saturate when waves stop growing at high wind speeds?). The reason we used U10 in the ""theory wave"" is that the empirical relations we used to estimate the peak wave number are based on wind speed. We need a bulk formula to convert these relations to momentum flux. The relation between U10 and surface Stokes drift does vary with U10 (see, e.g., Fig. 6 of [Rascle & Ardhuin 2013](http://dx.doi.org/10.1016/j.ocemod.2012.12.001)). But Langmuir number also seems to vary with U10 even for fully developed waves (Below is an example showing the relation between the turbulent Langmuir number and U10 assuming Pierson-Moskowitz spectrum). So I'm not sure which way is better...; <img width=""519"" alt=""image"" src=""https://user-images.githubusercontent.com/12438579/156286196-846d07eb-e8a2-4762-b2c8-3d3226401334.png"">. >Another option is to use a model proposed by [Pizzo et al. 2019](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2019/06/2019_Pizzo_Melville_Deike-",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1056109704:1346,parameteriz,parameterize,1346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1056109704,1,['parameteriz'],['parameterize']
Modifiability,"but FYI:. ```; @setup example1; ```. is used to configure `@examples`, not doctests; that's why it didn't work. On a different note, using `# hide` notation won't work in the sense the code will run but it won't be hidden -- that's syntax from Literate.jl package and we are not liberating the docs; only examples.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3707#issuecomment-2287911921:48,config,configure,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3707#issuecomment-2287911921,1,['config'],['configure']
Modifiability,"ce to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then compare some statistic of the model (ideally the entire velocity field, but @sandreza has gotten away just comparing something like `[maximum(abs, u), maximum(abs, v), maximum(abs, w)]`). If there's no race condition, identical models should produce identical results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:1427,config,configurations,1427,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865,1,['config'],['configurations']
Modifiability,"cell is ""wet"" or not?. ```julia; inactive_node(i, j, k, grid, lx, ly, lz); ```. returns `true` if a cell is immersed / inactive, and `false` if a cell is active. The boundary points are special, because their status depends on whether they are a prognostic or diagnostic field. Therefore we have another function,. ```julia; peripheral_node(i, j, k, grid, lx, ly, lz); ```. which returns true if a cell is inactive _or_ if it lies on the boundary between active and inactive (ie, the ""periphery"" of the domain). This distinction is only meaningful for `Face`-centered fields: `Center` locations cannot lie on the boundary. > ```julia; > julia> using Oceananigans; > ; > julia> grid = RectilinearGrid(size = (4, 4, 4), x=(0,1), y=(0,1), z=0:0.25:1); > 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.25, max(Δz)=0.25; > ; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.25; > 0.25; > 0.25; > 0.25; > 0.25; > ```; > ; > To be in line with [`xgcm`'s standards for metrics](https://github.com/xgcm/xgcm/issues/306#issuecomment-776124591) the output in the above case (considering only the ""wet"" or interior or fluid-filled cells when calculating `Δz`) should be; > ; > ```julia; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.125; > 0.25; > 0.25; > 0.25; > 0.125; > ```; > ; > since the first and last spacings on a bounded grid are ""half inside the domain and half outside"". Are you sure? For immersed boundaries, this would mean that all the metrics must be 3D arrays even when the grid directions are separable --- greatly inflating the size of your output file. > Or maybe there's a way to use abstract operation metrics to do this that I'm not aware?. It is simple. Write a `KernelFunctionOperation` that checks if a node is `peripheral_nod",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561:1066,variab,variably,1066,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561,1,['variab'],['variably']
Modifiability,"center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); - `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells.; - `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells.; - `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes).; - `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells. I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. * It seems that we should really use `Bounded` topology to be synonymous with ""impenetrable"". This might help us disentangle a few issues (eg satisfying impenetrability, correct divergences, etc.) I think we are discovering that in some cases its better to hard code certain ""assumed boundary conditions"" directly into operators, such as impenetrable conditions (considering complex domains is the key to realize the right abstractions here, since there are many simple solutions for non-complex domains and no obvious way to distinguish their tradeoffs). This means that we need to ""assume"" boundary conditions based on grid topology (information centralized on the grid), rather than requiring knowledge of the field boundary conditions (information scattered throughout the fields); * Related to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430:1852,extend,extend,1852,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430,1,['extend'],['extend']
Modifiability,"chitectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced wit",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:1410,Config,Configuration,1410,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457,1,['Config'],['Configuration']
Modifiability,"cit_substep!(tendencies, velocities, tracers, pressures, diffusivities, model); time_step_precomputations!(diffusivities, pressures, velocities, tracers, model); calculate_tendencies!(tendencies, velocities, tracers, pressures, diffusivities, model); return nothing; end; ```. The function `calculate_tendencies!` calculates interior and boundary contributions to tendencies and does not involve communication. The function `time_step_precomputations!` is. ```julia; function time_step_precomputations!(diffusivities, pressures, velocities, tracers, model). fill_halo_regions!(merge(velocities, tracers), model.boundary_conditions.solution, model.architecture,; model.grid, boundary_condition_function_arguments(model)...). calculate_diffusivities!(diffusivities, model.architecture, model.grid, model.closure, model.buoyancy,; velocities, tracers). fill_halo_regions!(diffusivities, model.boundary_conditions.diffusivities, model.architecture, model.grid). @launch(device(model.architecture), config=launch_config(model.grid, :xy),; update_hydrostatic_pressure!(pressures.pHY′, model.grid, model.buoyancy, tracers)). fill_halo_regions!(pressures.pHY′, model.boundary_conditions.pressure, model.architecture, model.grid). return nothing; end; ```. To implement the optimizations discussed in this issue, we need to also consider the calculation of hydrostatic pressure and nonlinear diffusivities to intertwine communication with interior tendency computation. Can this be done abstractly perhaps via some combination of launch configurations and macro specifications to `@loop_xyz`? This would allow us to exert control over the ""region"" of interior source term computation from the ""outside"", while keeping our kernels intact. Notice that the ""pre-computation"" of nonlinear diffusivities and the isolation of the hydrostatic pressure both add communication steps. We should monitor whether these become significantly suboptimal algorithms in the presence of expensive communication. We can easily c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/615#issuecomment-583379290:2050,config,config,2050,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/615#issuecomment-583379290,1,['config'],['config']
Modifiability,"ckages/CUDA/Tl08O/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.julia/packages/CUDA/Tl08O/src/CUDAKerne",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2099,Adapt,Adapt,2099,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,2,['Adapt'],['Adapt']
Modifiability,"ckpointing or not. Also, I think that overwrite_existing should not delete your files if you are picking up from a checkpoint (regardless of what it is set to). Do you agree?. Yes, I completely agree, if the simulation picks up from a checkpoint it should not delete data. >Assume for the following discussion that the ""overwriting issue"" is solved for checkpointing:; >; >In my experience, I typically set up a script with overwrite_existing=true from the very beginning. This is because when we first write a script, we are prototyping. I have never then gone back and changed overwrite_existing=false because of some concern about overwriting data. It's inconvenient, in fact, to set overwrite_existing=false.; >; >My thought is that it makes more sense to ask people to intentionally request overwrite_existing=false in the rare case that this is desired. The key insight is that we spend the vast majority of time prototyping. I would even argue from an economic standpoint that the productivity saved from this setting outweights any rare instances of lost data, if they actually would ever occur due to changing the default. Now it is clear. If we handle properly picking up simulations, I completely agree with you that best option is for the user to manually change `overwrite_existing=false` to ensure their own data. I also follow the same workflow when creating a simulation in which I rely on the `overwrite_existing=true` until I reach the ""production"" phase of the simulation. > Also curious --- do you split files to make them easier to download? . I mostly do it to keep a consistent size and chunks across files for post-processing, but supporting both things will make the user workflow more flexible, particularly when running long simulations with multiple pickups. It's likely that the post-processing you suggest will be useful, but in that case it may be more useful to include support to zarr files within the possible simulation outputs (https://github.com/JuliaIO/Zarr.jl).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393101043:1876,flexible,flexible,1876,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393101043,1,['flexible'],['flexible']
Modifiability,"combinations of boundary conditions instead, which would reduce the number of possibilities. For example, we might have just doubly periodic in (x, y) plus flux in z on all fields, or singly-periodic in x and flux in (y, z) on all fields. Agree that `CoordinateBoundaryConditions` might be a weird name but yeah, maximum flexibility would be very powerful. Maybe the common use case isn't to impose each of the 30 boundary conditions one-by-one but we can just have nice helper functions/abstractions like; ```julia; model.boundary conditions += HorizontallyPeriodic(); ```. > @ali-ramadhan do you mean with regards to performance? I'm not sure. With multiple dispatch being core to julia it seems this scenario is not uncommon (30+ may not be very large). I'm still pretty new to Julia so yeah don't know if that will be an issue, especially on the GPU. Only way to find out is to try and benchmark! Maybe you're right and 30+ isn't a lot. @vchuravy any idea on whether 30+ parameterized types for a struct is too many? Would this hurt performance on the GPU?. > The function calc does not actually impose a boundary condition --- the imposition of boundary condition depends on, for example, the viscosity and diffusivity, and is a property of the equation (or turbulent closure) being implemented. Again for example, the K-Profile-Parameterization includes a modification of how a flux boundary condition is implemented. In other words, the ""specification of flux"" is separate from the ""imposition of a boundary condition"". The former is determined by the user. The latter is determined by the model/governing equation. I see. So if no parameterizations are being used, are the boundary conditions actually being _imposed_ then? Even with KPP, isn't the boundary condition still being _imposed_ only to later be modified by KPP?. I still feel like `bc.calc()` feels obscure, I'm not sure why a boundary condition should have to calculated. Perhaps it's just semantics but it would be nice to see bo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472241993:1017,parameteriz,parameterized,1017,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472241993,1,['parameteriz'],['parameterized']
Modifiability,"consider the tilted bottom boundary layer example: https://clima.github.io/OceananigansDocumentation/stable/literated/tilted_bottom_boundary_layer/. In this problem, the buoyancy is decomposed ($b=\bar{b} + b^{\prime}$) into a background component $\bar{b} = N^{2} \hat{z}$ (where $\hat{z}$ is positive in the direction opposite the gravitational vector) and the remaining perturbation. The current example script applies no boundary conditions to the perturbation buoyancy, which I believe defaults to a no-normal-flux condition at the top and bottom boundary. Because no boundary conditions are applied to the background field, there is an implied diffusive flux $\hat{\mathbf{n}} \cdot (-\kappa \nabla \bar{b}) = ±\kappa N^{2} \cos{\theta}$ across these boundaries. This means that the boundary condition on the total buoyancy is a non-zero flux across the seafloor, which does not make much sense for this problem. The normal way of implementing this problem is to apply a gradient boundary condition, $\frac{\partial b^{\prime}}{\partial z} = -N^{2}\cos{\theta}$, at the bottom, to impose the no-flux condition. (In my MITgcm configurations, I verified that implementing the boundary condition this way recovered the classical analytical solutions of [Garrett et al. 1993](https://www.annualreviews.org/doi/10.1146/annurev.fl.25.010193.001451). Here is [another example using Dedalus](https://github.com/hdrake/bmli-linear/blob/main/examples/evp_replicate_Wenegrat2018_growth_rates.ipynb) to replicate some of Jacob Wenegrat's results, where I also include a non-zero gradient boundary condition on the perturbation buoyancy to impose no flux on the total buoyancy.). I understand why one might want background fields to be constructed a certain way for idealized problems, but it should be communicated clearly (and consistently) to the user exactly how this works. Is the tilted bottom boundary layer example incorrectly implemented or do I still not understand how the background fields work?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083158198:1186,config,configurations,1186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083158198,1,['config'],['configurations']
Modifiability,"convert_diffusivity(FT, κ), strain_rate); end; end; ```. where `strain_rate = Traceless()` would inform the turbulence closure to use the traceless rate of strain. Stress divergences are computed here:. https://github.com/climate-machine/Oceananigans.jl/blob/042f8cf12928b53b36cfa2a61a6b6a8ec7dc71bc/src/TurbulenceClosures/closure_operators.jl#L38. For example, one component of the stress divergence is:. ```julia; @inline ∂x_2ν_Σ₁₁(i, j, k, grid, closure, U, diffusivities) =; 2 * ∂xᶠᵃᵃ(i, j, k, grid, ν_σᶜᶜᶜ, diffusivities.νₑ, Σ₁₁, U.u, U.v, U.w); ```. We can thus *extend* functionality via dispatch:. ```julia; @inline ∂x_2ν_Σ₁₁(i, j, k, grid, ::TracelessStrainRateClosure, U, diffusivities) =; 2 * ∂xᶠᵃᵃ(i, j, k, grid, ν_σᶜᶜᶜ, diffusivities.νₑ, traceless_Σ₁₁, U.u, U.v, U.w); ```. where `TracelessStrainRateClosure` is an alias for a closure that requires the traceless strain rate. > A turbulence closure can define ∂ⱼτᵢⱼ directly to elide or short circuit computations or in case the SGS stress tensor is not of the form ∂ⱼτᵢⱼ = νˢᵍˢSᵢⱼ. This is how the system already works for closures that don't have eddy diffusivities. Is something different from the current system being proposed?. > @thabbott suggested that νˢᵍˢ might have to dispatch on the thermodynamic variable as well. Is this true for the viscosity or only the diffusivities κˢᵍˢ? I.e. do we have to treat SGS fluxes of moisture and energy in a special way?. Currently, the `calculate_diffusivities!` functions receives `buoyancy`, `velocities`, and `tracers`, as arguments:. https://github.com/climate-machine/Oceananigans.jl/blob/042f8cf12928b53b36cfa2a61a6b6a8ec7dc71bc/src/TurbulenceClosures/turbulence_closure_implementations/verstappen_anisotropic_minimum_dissipation.jl#L176. If a different abstraction is needed we can change the `calculate_diffusivities` function appropriately. As for ensuring that compressible models always use the correct strain rate, this can be handled within the `CompressibleModel` constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/654#issuecomment-592732479:2295,variab,variable,2295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/654#issuecomment-592732479,1,['variab'],['variable']
Modifiability,"d = Int.(Ny/2-40:Ny/2+40); bottom[bound, bound] .= 0.5. grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)); mrg = MultiRegionGrid(grid, partition=XPartition(2), devices = 2); ```; and ; ```; u(x, y, z) = (x * z) / 10; ```. (with `ImplicitFreeSurface`) we get. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.85 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.12 minutes | 82.5% |. Scaling gets better?? at this point I a little confused...; Bottomline... ; there is still a bunch of optimization and more systematic benchmarking to be done, I'll merge this PR and then we can think about improving the scaling, the first things that come in mind are; - Ensure that all the `apply_regionally!` and `construct_regionally` calls are asynchronous. This might not be the case if there are memory copies inside function calls. That would serialize the execution of part of the code. To ensure this we require a more in-depth profiling using ***nsys***; - remove all `fill_halo_regions!` that are not `Periodic` or `Communication` which will allow asynchronous execution of halo filling across different direction (luckily already being done in #2477); - Bundle together the halo passing in a single boundary buffer to allow sending field tuples together (depends on #2509). Additional work to do on `MultiRegion` is ; - Perform more systematic benchmarking; - Design correct `OutputWriters` and `OutputReaders` for `MultiRegionFields`. Maybe not immediate priorities but definitely important; - Adapt `RungeKutta3` to `Multiregion` through `@apply_regionally`; - Implement a multi-region version of the Nonhydrostatic pressure solver; - Overlap computation and communication (for this we require _non-blocking_ `fill_halo_regions!` with returning `events`); - Optimize the distributed implicit solver (maybe using `PETSc.jl`? Might not be needed when the implicit solve fits in one GPU)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178:1787,Adapt,Adapt,1787,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178,1,['Adapt'],['Adapt']
Modifiability,"d = nested_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── ComputedField located at (Center, Center, Face) of BinaryOperation at (Center, Center, Face); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); ├── operand: BinaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(dwpdz_nested). julia> using Adapt. julia> adapt(Array, interior(dwpdz_nested)); 1×512×8 view(OffsetArray(::Array{Float64,3}, 0:2, 0:513, 0:9), [1], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10 … 503, 504, 505, 506, 507, 508, 509, 510, 511, 512], [1, 2, 3, 4, 5, 6, 7, 8]) with eltype Float64:; [:, :, 1] =; 0.0262775 0.014948 0.00902569 0.00559831 0.00351427 0.00221792 0.00140318 0.000888719 … 0.000263472 0.000420913 0.000674128 0.00108572 0.00177041 0.00296775 0.00528696. [:, :, 2] =; 0.0156731 0.0110235 0.00720451 0.00461103 0.00293129 0.00185902 0.00117792 0.00074609 … 0.000915116 0.00144732 0.00229007 0.00362638 0.0057484 0.00911035 0.0143023. [:, :, 3] =; 0.00844536 0.00652392 0.00451369 0.00297425 0.00191676 0.00122263 0.000776137 0.000491594 … 0.00126331 0.00199147 0.00313408 0.00491472 0.00764863 0.0117137 0.0173591. [:, :, 4] =; 0.00263363 0.0021138 0.00150181 0.00100316 0.000649705 0.000414395 0.000262323 0.00016544 … 0.00117766 0.00185426 0.00291374 0.00455993 0.00707827 0.0108175 0.0160812. [:, :, 5] =; -0.00276553 -0.00220933 -0.00157462 -0.00105926 -0.000692536 -0.000446557 -0.00028606 … 0.00062928 0.000993307 0.0015715 0.00249751 0.00400184 0.00649",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:6102,adapt,adapt,6102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011,1,['adapt'],['adapt']
Modifiability,"did you use the test environment or Oceananigans's enviroment? On Tartarus, branch main in the test environment does this. ```; Precompiling project...; 1 dependency successfully precompiled in 38 seconds. 218 already precompiled.; Testing Running tests...; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; [2023/02/14 16:22:39.804] INFO Running shallow water regression tests...; [2023/02/14 16:22:40.097] INFO Testing shallow water Bickley jet simulation regression [GPU, VectorInvariantFormulation]; [2023/02/14 16:23:08.854] WARN Inflating model grid halo size to (4, 4, 0) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point. -@-> /home/ssilvest/stable_oceananigans/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:233; [2023/02/14 16:24:01.792] INFO Initializing simulation...; [2023/02/14 16:24:08.481] INFO ... simulation initialization complete (6.689 seconds); [2023/02/14 16:24:08.481] INFO Executing initial time step...; [2023/02/14 16:24:43.227] INFO ... initial time step complete (34.746 seconds).; [2023/02/14 16:24:43.387] INFO Simulation is stopping after running for 41.593 seconds.; [2023/02/14 16:24:43.387] INFO Model iteration 20 equals or exceeds stop iteration 20.; [2023/02/14 16:24:48.950] INFO Δu: min=-1.671992e-04, max=+4.237079e-06, mean=-8.685825e-06, absmean=+8.778487e-06, std=+2.661356e-05 (16384/16384 matching grid points); [2023/02/14 16:24:48.951] INFO Δv: min=-2.347391e-05, max=+4.751164e-05, mean=+1.746998e-06, absmean=+3.169677e-06, std=+8.513593e-06 (10752/16512 matching grid points); [2023/02/14 16:24:48.952] INFO Δh: min=-1.340684e-04, max=+1.454704e-04, mean=+2.980232e-08, absmean=+1.029445e-05, std=+2.835074e-05 (16384/16384 matching grid points); Shallow Water Bickley jet simulation [GPU, VectorInvar",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430401637:298,variab,variable,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430401637,4,"['Config', 'config', 'variab']","['Config', 'config', 'variable']"
Modifiability,"different in that case. That seems OK:. ```Julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:1073,variab,variable,1073,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457,2,"['config', 'variab']","['config', 'variable']"
Modifiability,"e change we could make would be instead write. ```Julia; ""Calculate the right-hand-side of the u-momentum equation at I, j, k.""; u_eqn(args..., F::Function i, j, k) = stuff + F(u, v, w, T, S, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k); u_eqn(args..., F::AbstractArray i, j, k) = stuff + F[i, j, k]; u_eqn(args..., F::Nothing, i, j, k) = stuff. ""Store previous value of the source term and calculate current source term.""; function update_source_terms!(::Val{Dev}, fCor, χ, ρ₀, κh, κv, 𝜈h, 𝜈v, Nx, Ny, Nz, Δx, Δy, Δz,; u, v, w, T, S, pHY′, Gu, Gv, Gw, GT, GS, Gpu, Gpv, Gpw, GpT, GpS, F) where Dev; ; # ...; # u-momentum equation; @inbounds Gu[i, j, k] = u_eqn(args..., F.u, i, j, k); # ...; ```; We could write even less code if we created an abstraction for the right hand side, something like. ```Julia; struct Equation{TF}; G::Function; F::TF; end. (eq::Equation{TF})(args..., i, j, k) where TF <: Function = eq.G(args..., i, j, k) + eq.F(args..., i, j, k); (eq::Equation{TF})(args..., i, j, k) where TF <: AbstractArray = eq.G(args..., i, j, k) + eq.F(args..., i, j, k); (eq::Equation{TF})(args..., i, j, k) where TF <: Nothing = eq.G(args..., i, j, k) . u_eqn = Equation(Gu, Fu). ...; @inbounds Gu[i, j, k] = u_eqn(args..., i, j, k); ```. We can then load all the equations we have into a `FieldVector` or `LabeledArray` to make things even better and do something like . ```julia; @loop for k in (1:Nz; blockIdx().z); @loop for j in (1:Ny; (blockIdx().y - 1) * blockDim().y + threadIdx().y); @loop for i in (1:Nx; (blockIdx().x - 1) * blockDim().x + threadIdx().x); for (Gφ, i) in enumerate(G); φ_eqn = equation[i]; Gφ[i, j, k] = φ_eqn(args... i, j, k); end; end; end; end; ```. With a time-stepping kernel of that form we can easily add and subtract tracers, equations, sub grid closure variables, etc. I think the inner loop gets unrolled when the array is static, so the compiled code is no different from what we currently have. . This is somewhere down the line hopefully. Maybe v0.6... or 1.0. Heh.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470624169:2405,variab,variables,2405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470624169,1,['variab'],['variables']
Modifiability,"e code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks for all attention you are giving to me. As a new user, it makes me learn more and more and maybe sometime I can also retribute by contributing to the model development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:1817,parameteriz,parameterizations,1817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688,1,['parameteriz'],['parameterizations']
Modifiability,"e easier for users to extend / add terms to an equation. As an example, we can consider a simple implementation. ```julia; struct AdvectiveFlux{S, D, C, G}; u :: D; v :: D; w :: D; c :: C; grid :: G; scheme :: S; end. getindex(adv::AdvectiveFlux{Centered}, i, j, k) = # centered advective flux calculation. struct IsotropicDiffusiveFlux{N, D, G}; ν :: N; ψ :: D; grid :: G; end. getindex(diff::IsotropicDiffusiveFlux, i, j, k) = # calculates flux due to isotropic diffusion by ν. struct RightHandSide{F, V}; fluxes :: F; volume_terms :: V; end. advection = AdvectiveFlux(velocities..., tracers.c); diffusion = IsotropicDiffusiveFlux(ν, tracers.c). tracer_rhs = RightHandSide((advection, diffusion), nothing); ```. We'd have functions that look something like. ```julia; function x_flux_divergence(i, j, k, grid, fluxes...); incoming_flux = add_fluxes(i, j, k, grid, fluxes...); outgoing_flux = add_fluxes(i+1, j, k, grid, fluxes...); return (incoming_flux - outgoing_flux) * grid.Ax / grid.V; end; ```. ... for example. Obviously questions of performance are paramount, though in the case that _everything_ is inlined I think there is hope. A downside of this approach is that we can't use shared memory stencils on the GPU. Shared memory stencils on the GPU require _functions_ for all terms that avoid carrying around internal references to data (since we need to be able to pass them references to shared memory blocks, rather than references to global memory. This is a fair rewrite of the code internals. For example, each term in the `u_velocity_tendency`:. https://github.com/climate-machine/Oceananigans.jl/blob/8e3c27504be68ca06bacc7502cd6095ae390f8c6/src/TimeSteppers/velocity_and_tracer_tendencies.jl#L24. would get it's own type. It's worth brainstorming ways to implement such abstraction incrementally so we might avoid possibly time-consuming total-code-demolishment. This is mostly food for thought at this point. I don't think we should take action without substantial consideration.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394:2086,rewrite,rewrite,2086,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394,1,['rewrite'],['rewrite']
Modifiability,"e the memory issue! But I do get an error when writing to disk:. ```; ERROR: LoadError: NetCDF error: size mismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:1106,variab,variable,1106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165,1,['variab'],['variable']
Modifiability,"e to accommodate channels. Some notes:. A new Poisson solver has been added that solves Poisson's equation with periodic boundary conditions in the x and staggered Neumann BCs in the y and z. This involves computing a 2D DCT on the GPU, which has no native DCT, so I implemented the fast 2D cosine transform from Makhoul (1980). Unfortunately the 2D FCT does not generalize from the 1D version, and extra steps are involved. In particular, as Fourier coefficients need to be indexed in multiple ways in some statements, we need a second buffer/storage array until I can figure out whether this is necessary. A couple of 1D masks are also needed. Anyways, so this PNN Poisson solver is a little involved, but is still decently fast. We have more tests and more GPU tests in general, but this also means that the test suite takes even longer to run especially with GPUs. I've moved each test set to it's respective file so we can use the regression tests as a stand-alone . In particular, this PR heavily refactors `poisson_solvers.jl`. It's more modular, concrete, and better documented I still need to describe the algorithms in the docs, especially important as it's not easy to figure this out and the only references are sparse papers (no code or implementations as far as I can tell). `time_steppers.jl` has also been cleaned up. Several kernels were converted to broadcasts. I also removed several bits of code that aren't used anymore. I considered making separate PRs to clean things up but I had to refactor and clean up to implement stuff so I ended up doing it all in this PR. The front-end has not changed at all but this PR ended up changing/cleaning a lot of the backend so I'd like to merge it ASAP before it starts to go out of date. Currently it's twice as slow as running a doubly periodic model. Will have to profile to figure out where it's spending that extra time. For reference, a P100 is roughly 3x slower than a V100.; ```; Nvidia P100 N=128^3; Periodic: 12 ms/iteration; Chann",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/290#issuecomment-506884950:1166,refactor,refactors,1166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/290#issuecomment-506884950,1,['refactor'],['refactors']
Modifiability,"e). model = NonhydrostaticModel(; grid,; advection = WENO(grid=grid, order=5),; tracers = (:b, :τ1, :τ2, :τ3), # This runs fine with one fewer tracer now; closure = SmagorinskyLilly(C=0.1),; background_fields = (b=B_field,),; forcing = (u=Fᵤ, v=Fᵥ, w=Fw, b=Fb),; ); @info model. simulation = Simulation(model, Δt=1, stop_iteration=10). run!(simulation); ```. My actual production code is far too complicated to paste here, but the relevant forcings I'm using there are:. ```julia; const z₀ = -100; const z₂ = -120; const z₁ = -grid.Lz. @inline function bottom_mask_cos(x, y, z); if z₀ >= z > z₁; return 1/2 * (1 - cos( π*(z-z₀)/(z₁-z₀) )); elseif z₁ >= z #> z₂; return 1.0; else; return 0.0; end ; end. @inline sponge_u(x, y, z, t, u, p) = -bottom_mask_cos(x, y, z) * p.σ * u; @inline sponge_v(x, y, z, t, v, p) = -bottom_mask_cos(x, y, z) * p.σ * v; @inline sponge_w(x, y, z, t, w, p) = -bottom_mask_cos(x, y, z) * p.σ * w; @inline sponge_b(x, y, z, t, b, p) = -bottom_mask_cos(x, y, z) * p.σ * (b - b∞(0, 0, z, 0, p)). Fᵤ = Forcing(sponge_u, field_dependencies = :u, parameters = (; params.σ)); Fᵥ = Forcing(sponge_v, field_dependencies = :v, parameters = (; params.σ)); Fw = Forcing(sponge_w, field_dependencies = :w, parameters = (; params.σ)); Fb = Forcing(sponge_b, field_dependencies = :b, parameters = (; params.σ, params.N²∞)); ```. The above are the forcing functions, and below is the background field. There are also parameters passed for the boundary conditions. ```julia; @inline b_bg(x, y, z, t, p) = p.M² * x; B_field = BackgroundField(b_bg, parameters = (; params.M²)); ```. Changing things so that variables that are currently passed as parameters are set as `const`ants helps (as you can see I did with `z₀`, etc.). However, that also means I can't run back-to-back simulations where those parameters differ, which is something that makes my workflow way more streamlined, so I'm trying to avoid that. (Although I'll ultimately have to do that if we can't figure this error out...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401329050:3056,variab,variables,3056,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401329050,1,['variab'],['variables']
Modifiability,"e-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this change brings the experience of reading Oceananigans code into better alignment with most scientific text.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:2155,variab,variables,2155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405,2,['variab'],['variables']
Modifiability,"e. I guess you're trying to couple an agent-based larvae model to an ocean model?. Oceananigans.jl should have the features you need I think: mainly Lagrangian particle tracking to advect the larvae around and arbitrary forced passive tracers for the odor from the reef?. I've actually been meaning to set up an example of an agent-based model coupled to Oceananigans.jl (simulating interacting ""microbes"" in the ocean). It's not fully complete yet but might give you some ideas of how to use Lagrangian particles as agents: https://github.com/CliMA/Oceananigans.jl/pull/1244. > If that works, I will implement a continuity equation to simulate the odor which comes from the reef and which is supposed to help the larvae to find back to the home reef. What is the continuity equation for the odor? It should be easy to advect the odor around as a passive tracer but just curious what the equation looks like. > Since I have found Oceananigans, which is also a CFD tool, I was wondering what you think the differences are between that and WaterLily.jl? Given my description of the project above, would you tend to use either of them?. I'm not super familiar with WaterLily.jl but it's definitely a very nice package (and a great README)!. I think WaterLily.jl has a more mature immersed boundary implementation if you need to have complex boundaries and is auto-diff friendly if you need to do some optimization/inference. @weymouth might be able to elaborate!. Oceananigans.jl has native support for Lagrangian particle tracking and might have more mature diagnostics (e.g. if you need to compute vorticity or other statistics) and more mature output writers (among other quality of life features). The examples in the docs should give a pretty good of the current set of mature features. E.g. this example shows how to add in a passive tracer for plankton and evolve it according to some (continuity?) equation: https://clima.github.io/OceananigansDocumentation/stable/generated/convecting_plankton/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1438#issuecomment-793113703:2010,evolve,evolve,2010,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1438#issuecomment-793113703,1,['evolve'],['evolve']
Modifiability,"e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active project, LOAD_PATH, and DEPOT_PATH) from the main process. Keyword arguments:. • restrict::Bool: if true (default) binding is restricted to 127.0.0.1. • dir, exename, exeflags, env, topology, lazy, enable_threaded_blas: same effect as for SSHManager, see documentation for; addprocs(machines::AbstractVector). │ Julia 1.9; │; │ The inheriting of the package environment and the env keyword argument were added in Julia 1.9.; ```. Ha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:5705,variab,variable,5705,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['variab'],['variable']
Modifiability,"e.AS.Global},CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global},CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global},CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global},Forcing{typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(FS)}}}) at /data5/glwagner/.julia/packages/CUDAnative/9rZcJ/src/execution.jl:347; [10] cufunction(::Function, ::Type) at /data5/glwagner/.julia/packages/CUDAnative/9rZcJ/src/execution.jl:347; [11] macro expansion at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/GPUifyLoops.jl:113 [inlined]; [12] macro expansion at ./gcutils.jl:87 [inlined]; [13] #launch#46(::Base.Iterators.Pairs{Symbol,Tuple{Int64,Int64,Vararg{Int64,N} where N},Tuple{Symbol,Symbol},NamedTuple{(:threads, :blocks),Tuple{Tuple{Int64,Int64},Tuple{Int64,Int64,Int64}}}}, ::Function, ::GPUifyLoops.CUDA, ::typeof(Oceananigans.calculate_interior_source_terms!), ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}, ::Vararg{Any,N} where N) at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/GPUifyLoops.jl:110; [14] #launch at ./none:0 [inlined]; [15] macro expansion at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/GPUifyLoops.jl:54 [inlined]; [16] time_step!(::Model{GPU,RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},Oceananigans.TurbulenceClosures.ConstantAnisotropicDiffusivity{Float64},Float64}, ::Int64, ::Float64) at /archive1/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:74; [17] top-level scope at util.jl:156; [18] include at ./boot.jl:326 [inlined]; [19] include_relative(::Module, ::String) at ./loading.jl:1038; [20] include(::Module, ::String) at ./sysimg.jl:29; [21] include(::String) at ./client.jl:403; [22] top-level scope at none:0; in expression starting at /archive1/glwagner/Projects/Oceananigans.jl/sandbox/simple_forcing.jl:35; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496489468:7759,sandbox,sandbox,7759,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496489468,1,['sandbox'],['sandbox']
Modifiability,"eananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Int64,typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64,Int64}}}}; filepath::String, schedule::AveragedTimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:90; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[16]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:90; ```. Like I said, I'm not sure the best to deal with this. Should I define another separate function to deal with the `WindowedTimeAverage` case?. Also, I'm a little confused. Does this set-up only work at the moment with the NetCDF writer? Because if so, it seems to me it wouldn't be recommended to add to Oceananigans liek this, right? I think we'd want diagnostics on Oceananigans to be independent of the writing method, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:16088,sandbox,sandbox,16088,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449,2,['sandbox'],['sandbox']
Modifiability,"ease the time step) but the solution should converge as you do so. It's not a built-in feature but is pretty easy to implement by adding appropriate forcing functions to an Oceananigans model. For example, in PR #693 we used such a method to simulate viscous flow around a cylinder (in 2D). Here is the simulation script: https://github.com/climate-machine/Oceananigans.jl/blob/ar/flow-around-cylinder/verification/flow_around_cylinder/flow_around_cylinder.jl. These are the most relevant lines: https://github.com/climate-machine/Oceananigans.jl/blob/a921fc3edbf795bf4a2193cca84cad41ebdd5625/verification/flow_around_cylinder/flow_around_cylinder.jl#L18-L27. In this case the boundary was described analytically and `boundary(x, y, z)` evaluates to `1` inside the cylinder and to `0` outside. In your case maybe it's easier to describe the boundary or missing nodes with a mask or array (also updated snippet for v0.29):; ```julia; # ... Create boundary[i, j, k] array that's 1.0 inside the boundary and 0.0 outside ... K = 50.0 # ""Spring constant"" for immersed boundary method ; parameters = (boundary=boundary, K=K). # Continuous forcing immersed boundary method ; @inline u_immersed_boundary(i, j, k, grid, clock, state, params) =; @inbounds -params.boundary[i, j, k] * params.K * state.velocities.u[i, j, k] ; @inline w_immersed_boundary(i, j, k, grid, clock, state, params) =; @inbounds -params.boundary[i, j, k] * params.K * state.velocities.w[i, j, k] . u_forcing = ParameterizedForcing(u_immersed_boundary, parameters); w_forcing = ParameterizedForcing(w_immersed_boundary, parameters). forcing = ModelForcing(u=u_forcing, w=w_forcing) ; ```. Note that the API has changed a bit since PR #693 so the example is a little out of date. See release notes for details, especially for v0.26.0 onward: https://github.com/climate-machine/Oceananigans.jl/releases. Let us know if this helps and if you run into any issues. We're more than happy to help with setting up simulations and debugging them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/743#issuecomment-622406785:1809,Parameteriz,ParameterizedForcing,1809,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/743#issuecomment-622406785,2,['Parameteriz'],['ParameterizedForcing']
Modifiability,"ed MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced with min(Δz)=0.0106134, max(Δz)=0.12559. julia> u = Field{Face, Center, Center}(rectilinear_grid); 128×128×64 Field{Face, Center, Center} on RectilinearGrid on GPU; ├── grid: 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0. julia> maximum(abs, u); 0.0. julia> v = Field{Center, Face, Center}(rectilinear_grid); 128×129×64 Field{Center, Face, Center} on RectilinearGrid on GPU; ├── grid: 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:2380,variab,variably,2380,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457,1,['variab'],['variably']
Modifiability,"er.elsevier.com/reader/sd/pii/S0377042717303035?token=83A413B5659B8B16B96E1D0CBDAD5865D8552AE5B2FF2FDFE78FFDEF064F2820B38D1BBFF646D3F7B75D58FE010DF7DB&originRegion=us-east-1&originCreation=20230125193548). You can always try with higher order (maybe 7th?) but the higher the order the lower the stability (i.e. at a certain order your implicit dissipation will be so low that you will start to generate grid-scale noise). . The KE dissipation is there with `closure=nothing` and a WENO scheme, it is just not strictly physical: it's (roughly) akin to a 4th to a 6th-order hyperviscosity. You can compare this to using `UpwindBiased(order = 5)` which would give you everywhere a dissipation that converges to a 6th-order hyperviscosity. In general:. $$\partial_x {uu}^{Upwind_N} \sim \partial_x {uu}^{Centered_{N+1}} + \partial_x {K_{numerical}} \partial_x^{N} u$$. where $K_{numerical} \sim \Delta x u$ and $N$ is the order. The nice thing about using WENO instead of a simple Upwind discretization is that the order of the hyperviscosity adapts to the smoothness of the field. Therefore, where the field is noisier (like in regions of higher gradients) the dissipation is more aggressive. . This procedure not only ensures a smooth field but can be thought of as mimicking the subgrid-scale dissipation (which also increases with the gradient of resolved scale variables. As such people have referred to using particularly diffusive advective schemes (such as WENO) as _Implicit_ LES. I like the idea of implicit LES because it allows you to ""fill in"" for the subgrid-scale dissipation without committing to any sophisticated formulation derived in a particularly idealized situation (take the example of Leith derived in homogeneous 2D turbulence and the geostrophic eddies in the ocean), and guarantees (or at least helps) stability. For this reason, it's pretty handy when you have different unresolved processes at different scales that may be characterized by different dissipation characteristi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433:1426,adapt,adapts,1426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433,1,['adapt'],['adapts']
Modifiability,"er_regression.jl:12 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:11 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [6] top-level scope; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:6; Test Summary: | Pass Fail Total; Oceananigans | 4 2 6; Shallow Water Regression | 4 2 6; Shallow Water Bickley jet simulation [GPU, VectorInvariantFormulation] | 2 1 3; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation] | 2 1 3; ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored, 0 broken.; in expression starting at /g/data/v45/nc3020/OC.jl/test/runtests.jl:3; ERROR: Package Oceananigans errored during testing. (Oceananigans) pkg> st; Project Oceananigans v0.76.5; Status `/g/data/v45/nc3020/OC.jl/Project.toml`; [79e6a3ab] Adapt v3.3.3; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.4.6; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.7; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. julia> versioninfo(); Julia Version 1.6.7; Commit 3b76b25b64* (2022-07-19 15:11 UTC); Platform Info:; OS: L",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:17669,Adapt,Adapt,17669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Adapt'],['Adapt']
Modifiability,"es because serialization and code distribution might fail; otherwise. • exeflags: additional flags passed to the worker processes. • topology: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.; • topology=:all_to_all: All processes are connected to each other. The default.; • topology=:master_worker: Only the driver process, i.e. pid 1 connects to the workers. The workers do not connect to each; other.; • topology=:custom: The launch method of the cluster manager specifies the connection topology via fields ident and; connect_idents in WorkerConfig. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for conne",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:4899,variab,variables,4899,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['variab'],['variables']
Modifiability,"escribes a time-evolving state. In this case, parent velocities and tracers are specified at each point in space and time -- both on the boundary, and inside the ""child"" `NonhydrostaticModel` domain. We can imagine that this case would involve a utility that takes in the parent state (or a filename / list of filenames) and returns boundary conditions on velocities and tracers. The utility might also return forcing functions that prescribe a sponge layer that relaxes the model solution to the parent state near the boundary, like [MITgcm's ""relaxation boundary conditions"" package](https://mitgcm.readthedocs.io/en/latest/phys_pkgs/rbcs.html). As for how the boundary conditions work, an arbitrary parent state will dictate wall-normal velocities that are variously either inward or outward (fluxing information out of the domain). Somehow, the inflow / outflow specified by the parent state has to be reconciled with the model state. The discussion on this PR seems to suggest that the outflow velocity used by the boundary condition may need to be _different_ than what is specified by the parent state (otherwise, why would we need to ""compute"" an outflow velocity?). But I don't understand anything further than that. I also don't understand the implications of a sponge layer, which almost certainly seems required. . 2. Constant or idealized inflows and outflows. This seems to be the case in the movie on the original post and also of @simone-silvestri 's movie. On one (or more?) boundaries, an inflow state is prescribed. The inflow boundaries could use 1) `OpenBoundaryCondition` on both velocities and tracers, or 2) `OpenBoundaryCondition` for velocities and `ValueBoundaryCondition` on tracers. The second case would be used when attempting to prescribe the tracer fluxes precisely. There are also outflow boundaries, which either have a prescribed outflow velocity, a computed-yet-still-spatially-uniform bulk outflow velocity, or a computed and spatially-variable outflow velocity?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979894207:2130,variab,variable,2130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979894207,1,['variab'],['variable']
Modifiability,f2h/lib/pkgconfig:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/lib/pkgconfig:/glade/u/apps/casper/23.10/opt/view/lib64/pkgconfig:/glade/u/apps/casper/23.10/opt/view/lib/pkgconfig; INFOPATH = :/glade/u/apps/casper/23.10/opt/view/share/info:/usr/local/share/info:/usr/share/info; NCAR_LDFLAGS_JULIA = /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.9.2/gcc/7.5.0/mjea/lib; NCAR_LDFLAGS_HDF5 = /glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/lib; NCAR_WRAPPER_MPI_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6/bin/mpi; __LMOD_STACK_LMOD_PACKAGE_PATH = L2dsYWRlL3dvcmsvY3NndGVhbS9zcGFjay1kZXBsb3ltZW50cy9jYXNwZXIvMjMuMTAvZW52cy9wdWJsaWMvdXRpbA==:L2dsYWRlL3dvcmsvY3NndGVhbS9zcGFjay1kZXBsb3ltZW50cy9jYXNwZXIvMjMuMTAvZW52cy9wdWJsaWMvdXRpbA==; ```; and the status check message gave me:; ```; Status `~/.julia/environments/v1.9/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; [79e6a3ab] Adapt v4.0.4; ⌅ [4fba245c] ArrayInterface v7.7.1; [a9b6321e] Atomix v0.1.0; [ab4f0b2a] BFloat16s v0.5.0; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.4.3; [1af6417a] CUDA_Runtime_Discovery v0.3.4; [d360d2e6] ChainRulesCore v1.24.0; [3da002f7] ColorTypes v0.11.5; [5ae59095] Colors v0.12.11; [1fbeeb36] CommonDataModel v0.3.6; [34da2185] Compat v4.15.0; [187b0558] ConstructionBase v1.5.5; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [9a962f9c] DataAPI v1.16.0; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.20; [e2d170a0] DataValueInterfaces v1.0.0; ⌅ [3c3547ce] DiskArrays v0.3.23; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [b305315f] Elliptic v1.0.1; [e2ba6199] ExprTools v0.1.10; [7a1cc6ca] FFTW v1.8.0; [5789e2e9] FileIO v1.16.3; [53c48c17] FixedPointNumbers v0.8.5; [0c68f7d7] GPUArrays v10.2.3; [46192b85] GPUArraysCore v0.1.6; [61eb1bfa] GPUCompiler v0.26.7; [c27321d9] Glob v1.3.1; [615f187c] IfElse v0.1.1;,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:16102,Adapt,Adapt,16102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['Adapt'],['Adapt']
Modifiability,"f5c54c55a7a9a3aa42bf931c72aa""; uuid = ""85f8d34a-cbdd-5861-8df4-14fed0d494ab""; version = ""0.11.3"". [[NNlib]]; deps = [""Adapt"", ""ChainRulesCore"", ""Compat"", ""LinearAlgebra"", ""Pkg"", ""Requires"", ""Statistics""]; git-tree-sha1 = ""80b8360670f445d88b3475e88b33bbcc92f7866e""; uuid = ""872c559c-99b0-510c-b3b7-b6c96a88d5cd""; version = ""0.7.19"". [[NaNMath]]; git-tree-sha1 = ""bfe47e760d60b82b66b61d2d44128b62e3a369fb""; uuid = ""77ba4419-2d1f-58cd-9bb1-8ffee604a2e3""; version = ""0.3.5"". [[NetCDF_jll]]; deps = [""Artifacts"", ""HDF5_jll"", ""JLLWrappers"", ""LibCURL_jll"", ""LibSSH2_jll"", ""Libdl"", ""MbedTLS_jll"", ""Pkg"", ""Zlib_jll"", ""nghttp2_jll""]; git-tree-sha1 = ""d5835f95aea3b93965a1a7c06de9aace8cb82d99""; uuid = ""7243133f-43d8-5620-bbf4-c2c921802cf3""; version = ""400.701.400+0"". [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""FFTW"", ""Glob"", ""InteractiveUtils"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SafeTestsets"", ""SeawaterPolynomials"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""861d8cca4447304a21a94110e3ffc786cab52dce""; uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; version = ""0.56.0"". [[OffsetArrays]]; deps = [""Adapt""]; git-tree-sha1 = ""87a728aebb76220bd72855e1c85284c5fdb9774c""; uuid = ""6fe1bfb0-de20-5000-8ca7-80f57d26f881""; version = ""1.7.0"". [[OpenMPI_jll]]; deps = [""Libdl"", ""Pkg""]; git-tree-sha1 = ""41b983e26a7ab8c9bf05f7d70c274b817d541b46""; uuid = ""fe0851c0-eecd-5654-98d4-656369965a5c""; version = ""4.0.2+2"". [[OpenSSL_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""71bbbc616a1d710879f5a1021bcba65ffba6ce58""; uuid = ""458c3c95-2e84-50aa-8efc-19380b2a3a95""; version = ""1.1.1+6"". [[OpenSpecFun_jll]]; deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""9db77584158d0ab52307f8c04f8e7c08ca76b5b3""; uuid = ""efe28fd5-8261-553b-a9e1-b2916fc3738e""; version",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:11070,Adapt,Adapt,11070,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,"face on which the boundary condition is defined, in other words `n̂ ⋅ u = 0`. This is true for the time being because we don't have 'open' or non-zero 'penetration' boundary conditions. On the other hand, a penetration boundary condition is a condition on *mass* specifically --- a condition on `n̂ ⋅ u`. More specifically because we only have `NoPenetration`, it is the statement that `n̂ ⋅ u = 0` on that boundary. Currently we only have horizontal boundaries in the vertical direction, so this boundary condition can only be applied to `w`. Consider that we can apply a no penetration condition to the velocity field on all boundaries, but still permit a (diffusive) flux of velocity / momentum at the boundaries --- this will be the case, for example, for the free decay of turbulence to a quiescent state in a closed, impermeable box. Earlier there was also confusion about the difference between a `Value` (Dirichlet) condition and a no penetration condition. Mathematically speaking I do think these are the same. However, their implementation on the staggered grid differs, since we assume that `Value` conditions are applied to fields that are not defined *on* the boundary, but in between the boundary face and the boundary-adjacent face. On the other hand, we assume that a penetration boundary condition applies to fields that have values on boundaries; e.g. to the velocity components that are normal to that boundary. Does that make sense? Documentation is of course easy, but I'm open to changing the API or refactoring the code internally as well. I think that in part an internal refactoring will require dispatching on field type / location at some level; for example we have to interpret a `Value` condition applied to a field that is defined on a certain boundary in the same way that we interpret a `Penetration` condition currently, while interpreting a `Value` condition applied to a field defined between the boundary and boundary-adjacent face in the same way that we do now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-527164624:2272,refactor,refactoring,2272,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-527164624,2,['refactor'],['refactoring']
Modifiability,for the GPU config you can see the hardware it is being run on here:; https://buildkite.com/clima/oceananigans-central/builds/8#5ef96bf8-7b5f-47d3-84fd-726b4cb3fc33/9-11,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906765232:12,config,config,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906765232,1,['config'],['config']
Modifiability,"g. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active project, LOAD_PATH, and DEPOT_PATH) from the main process. Keyword arguments:. • restrict::Bool: if true (default) binding is restricted to 127.0.0.1. • dir, exename, exeflags, env, topology, lazy, enable_threaded_blas",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:5483,variab,variables,5483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['variab'],['variables']
Modifiability,"githubusercontent.com/33547697/225382686-301b4f32-73b5-40a3-b5e3-74c52fa189f1.png). ~left is `k = grid.Nz-1` and right is `k = grid.Nz`. `grid.Nz-1` seems to be correct, while `grid.Nz` is completely off.; This is the code I used to generate the regridded data~. ```; using ClimaOcean; using ClimaOcean.DataWrangling; using Oceananigans ; using Oceananigans.BoundaryConditions; using DataDeps; using GLMakie; using JLD2 . regrid_in_z = true. path = ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/ss/new_hydrostatic_data_after_cleared_bugs/quarter_degree_near_global_input_data/"". dh = DataDep(""quarter_degree_near_global_lat_lon"",; ""Forcing data for global latitude longitude simulation"",; path * ""z_faces-50-levels.jld2""; ). DataDeps.register(dh). datadep""quarter_degree_near_global_lat_lon"". datadep_path = @datadep_str ""quarter_degree_near_global_lat_lon/z_faces-50-levels.jld2""; file_z_faces = jldopen(datadep_path); z_faces = file_z_faces[""z_faces""][3:end];. file_init = jldopen(""evolved-initial-conditions-1105days.jld2""). # A spherical domain; grid12 = LatitudeLongitudeGrid(size = (4320, 1800, 48),; longitude = (-180, 180),; latitude = (-75, 75),; z = z_faces,; precompute_metrics = true). T12 = set!(CenterField(grid12), file_init[""T""]); S12 = set!(CenterField(grid12), file_init[""S""]). @inline exponential_profile(z; Lz, h) = (exp(z / h) - exp( - Lz / h)) / (1 - exp( - Lz / h)) . function exponential_z_faces(Nz, Depth; h = Nz / 4.5). z_faces = exponential_profile.((1:Nz+1); Lz = Nz, h). # Normalize; z_faces .-= z_faces[1]; z_faces .*= - Depth / z_faces[end]; ; z_faces[1] = 0.0. return reverse(z_faces); end. Depth = - grid12.Lz. @info ""start regridding in Z!!""; grid12z = LatitudeLongitudeGrid(size = (4320, 1800, 120),; longitude = (-180, 180),; latitude = (-75, 75),; z = exponential_z_faces(120, Depth),; precompute_metrics = true). T12z = CenterField(grid12z); S12z = CenterField(grid12z). using Oceananigans.Fields: regrid!; fill_halo_regions!((T12, S12)); regrid!(T12z, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2881#issuecomment-1470377304:1213,evolve,evolved-initial-conditions-,1213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2881#issuecomment-1470377304,1,['evolve'],['evolved-initial-conditions-']
Modifiability,"global tracer conservation for the hydrostatic lock-release configuration in `validation/moving_coordinate/z_star_lock_release.jl`. Better than the z-coordinate but still not machine-precision conserving. <img width=""289"" alt=""Screenshot 2023-12-21 at 11 00 02 AM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/33547697/e7f913c5-07e6-47ab-a391-24af71ea65a5"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1865979201:60,config,configuration,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1865979201,1,['config'],['configuration']
Modifiability,"hat sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. The pressure source term is the divergence of the predictor velocity divided by time-step. As the time-step vanishes, the divergence of the predictor velocity also vanishes (because the flow has not evolved from its previous, non-divergent solution). We get a situation tending to 0/0. I think there's a few things we could do to solve this. First of all if we take a very small time-step, I think we can actually just re-set the model time rather than taking a time-step. Second I am wondering if we want to implement a time type that has finite resolution (ie there is a smallest time increment one can take). For example, datetimes have a smallest unit (micro or nanoseconds). A non-dimensional or dimensional-agnostic time type could also be designed analogously (eg every time is the multiple of an integer by the fundamental unit). This would eliminate round off error but it's a bit of work and also we have to put some thought into how best to accomplish it. There might also be a simpler solution by adjusting how we increment time. I'm not sure. > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?. I think so, but I also don't think that you can guarantee this problem won't ever occur. The presence of the buoyancy does somehow impact the divergence that accumulates during a time-step / the pressure correction that has to be applied. So it's possible that the buoyancy configuration affects these results. Not sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025:2335,config,configuration,2335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025,1,['config'],['configuration']
Modifiability,"he current design. A ""boundary condition"" is a flux, gradient, or value of a field (`u`, `v`, `w`, `T`, `S`) at the end (`left`, `right`) in a given direction (`x`, `y`, `z`). ### Pros. * Generality: any boundary condition can be specified; * Similarity to the mathematics: this design corresponds to how boundary conditions are specified in PDEs; * Extensibility: the design accommodates changes in *types* of boundary conditions or changes in dimensionality. (Adding new solution variables requires code modification, but that is true throughout the code). ### Concerns. * It's more complicated than allowing only 3-4 possibilities to users; as @johncmarshall54 says:. > It's not obvious to me what a field boundary condition is, vs a coordinate boundary condition.; Fundamentally we are applying boundary conditions to u, v, w, T, and S fields, and that's it. It all seems a bit too complicated. * The hierarchical dependence of this design on parameterized types creates a lot of possibilities for different boundary conditions to be specified, and this is a concern for performance (@ali-ramadhan). * We aren't sure what to call the function (currently `bc.calc`) whose purpose is to return the value of the boundary condition (either the field value, flux, gradient, or whatever) at a given grid point and simulation time. ### Other miscellaneous thoughts. * This PR implements a backend / abstraction system for specifying boundary conditions. For users we can add as much sugar on top as we want. * As we have discussed, the way we implement boundary conditions is intimately connected to the way that we specify equations. This can be seen in the current code (though it is commented out) in that [the lines that specify a no-slip condition depend on the ""vertical viscosity""](https://github.com/climate-machine/Oceananigans.jl/blob/7fb355d77df98e37a80b3e796291fa2856d3e1ce/src/time_steppers.jl#L293). Adding other diffusive terms (hyperdiffusivity, Leith diffusivity, various turbulent diffu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472372026:1056,parameteriz,parameterized,1056,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472372026,1,['parameteriz'],['parameterized']
Modifiability,"he source code. As for the source code and the topic of this issue, I think it will be generally impossible to include the diffusivity fields in the model fields. First of all, closures and diffusivity fields can be user defined. We want people to be free to do creative things in closure design without having to worry about whether trying to merge the diffusivity fields into `model_fields` will cause their model to fail to compile, preventing them from doing work. However, it might be possible to ""whitelist"" some fields when the situation calls for it, like the eddy diffusivities in LES closures. For that we need to introduce a new function, something like `nonhydrostatic_fields` (mirroring the `hydrostatic_fields` we have now for the `HydrostaticFreeSurfaceModel`) which, unlike `fields`, is more low-level and not user facing. Then this function can be designed to take `closure` as an argument to support the inclusion of diffusivity fields where appropriate, something like. ```julia; @inline nonhydrostatic_model_fields(closure, velocities, tracers, aux_fields, diffusivity_fields) =; merge(velocities, tracers, aux_fields) # fallback. @inline nonhydrostatic_model_fields(::SmagorinskyLilly, velocities, tracers, aux_fields, diffusivity_fields) =; merge(velocities, tracers, aux_fields, (; νₑ=diffusivity_fields.νₑ)) # desired behavior; ```. then we can use that in the tendency kernel functions. I think this would probably succeed because we can simply omit the closures with too-complex diffusivity fields. It might require a bit more work for closure tuples though. It's an interesting idea for a contribution. But note that the current ways to solve this problem (creating a new field for the forcing, and then utilizing callbacks to compute the needed field during time stepping) are fairly straightforward and also generalize to much more complex situations that I'm not sure it makes sense to go down the rabbit hole of extending `model_fields` to cover more exotic situations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2095180262:2450,extend,extending,2450,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2095180262,1,['extend'],['extending']
Modifiability,"hink we should add type information to the turbulence closure itself, eg:. ```julia; struct VerstappenAnisotropicMinimumDissipation{FT, PK, PN, K} <: AbstractAnisotropicMinimumDissipation{FT, S}; Cν :: PN; Cκ :: PK; Cb :: FT; ν :: FT; κ :: K; strain_rate :: S; function VerstappenAnisotropicMinimumDissipation{FT}(Cν, Cκ, Cb, ν, κ, strain_rate) where FT; return new{FT, typeof(Cκ), typeof(Cν), typeof(κ)}(Cν, Cκ, Cb, ν, convert_diffusivity(FT, κ), strain_rate); end; end; ```. where `strain_rate = Traceless()` would inform the turbulence closure to use the traceless rate of strain. Stress divergences are computed here:. https://github.com/climate-machine/Oceananigans.jl/blob/042f8cf12928b53b36cfa2a61a6b6a8ec7dc71bc/src/TurbulenceClosures/closure_operators.jl#L38. For example, one component of the stress divergence is:. ```julia; @inline ∂x_2ν_Σ₁₁(i, j, k, grid, closure, U, diffusivities) =; 2 * ∂xᶠᵃᵃ(i, j, k, grid, ν_σᶜᶜᶜ, diffusivities.νₑ, Σ₁₁, U.u, U.v, U.w); ```. We can thus *extend* functionality via dispatch:. ```julia; @inline ∂x_2ν_Σ₁₁(i, j, k, grid, ::TracelessStrainRateClosure, U, diffusivities) =; 2 * ∂xᶠᵃᵃ(i, j, k, grid, ν_σᶜᶜᶜ, diffusivities.νₑ, traceless_Σ₁₁, U.u, U.v, U.w); ```. where `TracelessStrainRateClosure` is an alias for a closure that requires the traceless strain rate. > A turbulence closure can define ∂ⱼτᵢⱼ directly to elide or short circuit computations or in case the SGS stress tensor is not of the form ∂ⱼτᵢⱼ = νˢᵍˢSᵢⱼ. This is how the system already works for closures that don't have eddy diffusivities. Is something different from the current system being proposed?. > @thabbott suggested that νˢᵍˢ might have to dispatch on the thermodynamic variable as well. Is this true for the viscosity or only the diffusivities κˢᵍˢ? I.e. do we have to treat SGS fluxes of moisture and energy in a special way?. Currently, the `calculate_diffusivities!` functions receives `buoyancy`, `velocities`, and `tracers`, as arguments:. https://github.com/climate-machi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/654#issuecomment-592732479:1592,extend,extend,1592,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/654#issuecomment-592732479,1,['extend'],['extend']
Modifiability,"hmmm I cannot reproduce the bug; ```; julia> underlying_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded), ; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced with min(Δz)=0.0106134, max(Δz)=0.12559. julia> . julia> . julia> const H_deep = H = underlying_grid.Lz; 2.9999999999999996. julia> const H_shelf = h = 0.5; 0.5. julia> const width_shelf = 100; 100. julia> . julia> shelf(x, y) = -(H + h)/2 - (H - h)/2 * tanh(y / width_shelf); shelf (generic function with 1 method). julia> bathymetry(x, y) = shelf(x, y); bathymetry (generic function with 1 method). julia> . julia> grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=-2.99e+00, max(h)=0.00e+00); ├── underlying_grid: 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced with min(Δz)=0.0106134, max(Δz)=0.12559. julia> u = XFaceField(grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152:487,variab,variably,487,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152,1,['variab'],['variably']
Modifiability,"how about if we make it to something like. ```julia; julia> b′b′; mean! over dims (1,) of BinaryOperation at (Center, Center, Center); └── operand: BinaryOperation at (Center, Center, Center); call b′b′.operand to see the operation tree; └── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ```. I tried but I can't seem to be able to get the variable name as a string, e.g., a string with `""b′b′""` for this case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2365#issuecomment-1073153192:384,variab,variable,384,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2365#issuecomment-1073153192,1,['variab'],['variable']
Modifiability,"ich is kind of similar to #73 #85. I suppose we can interpret every term in the momentum equation as an ""arbitrary function"". The design I've been using is to define a type that represents part of the governing equation to make the equation modular and changeable by the user. Definitely suggest alternative designs if good alternatives come to mind. > Is a closure always meant to replace the viscous dissipation (𝜈∇²u) operators? Will Smag/AMD replace the Laplacian diffusion operators (e.g. κ∇²T) as well?. I am proposing that we consider using this conceptual model for a ""closure"". Perhaps a better name than ""closure"" is `Dissipation`... ? All of the turbulent closures we are considering introduce a ""turbulent"" viscosity and diffusivity which is typically much larger than the molecular value. Thus a ""molecular"" isotropic diffusivity can be interpreted as the limiting case of a turbulent closure. The reason it might be good design is because turbulent closures can modify boundary conditions (which depend on viscosity/diffusivity), and because we may want to use common implicit time-stepping methods for the turbulent diffusivity in addition to a ""molecular"" diffusivity. > Out of curiousity, can these closures be framed as ODEProblems using DifferentialEquations.jl?. A subgrid turbulent kinetic energy variable in a typical turbulence closure obeys a three-dimensional PDE and is advected, diffused, dissipated, and interacts with terms in the momentum and tracer equation via nonlinear terms. It is a first-class solution variable similar to the velocity field or active tracers. See equation 12 in [Moeng 1984](https://journals.ametsoc.org/doi/pdf/10.1175/1520-0469%281984%29041%3C2052%3AALESMF%3E2.0.CO%3B2). > Sounds like #115 (and #59 (comment)) should be resolved before this closure abstraction is merged in?. I think it makes sense to resolve #107, #115, and #59 before implementing anything; especially #59 because this affects the function signature we use for the closures.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/120#issuecomment-472222089:1431,variab,variable,1431,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/120#issuecomment-472222089,2,['variab'],['variable']
Modifiability,"iff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fY29udmVjdGlvbl93aXRoX3BsYW5rdG9uLmps) | `0.00% <0.00%> (ø)` | |; | [examples/ocean\_wind\_mixing\_and\_convection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fd2luZF9taXhpbmdfYW5kX2NvbnZlY3Rpb24uamw=) | `0.00% <0.00%> (ø)` | |; | [src/AbstractOperations/AbstractOperations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `50.00% <ø> (ø)` | |; | [src/AbstractOperations/derivatives.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9kZXJpdmF0aXZlcy5qbA==) | `88.88% <ø> (ø)` | |; | [src/AbstractOperations/show\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9zaG93X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `16.66% <ø> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <ø> (ø)` | |; | [src/BoundaryConditions/show\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zaG93X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `0.00% <ø> (ø)` | |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0.00% <ø> (ø)` | |; | ... and [41 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989#issuecomment-699576002:2489,parameteriz,parameterized,2489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989#issuecomment-699576002,1,['parameteriz'],['parameterized']
Modifiability,"iguration/. * Configuring SLURM correctly may also require some trial and error, because the documentation is unclear and there are a huge number of options. I can't figure out if the documentation is wrong, in fact, or if instead the engaging cluster does not support some options. Either way, a small test script like. ```julia; using MPI. MPI.Init(); @show MPI.Comm_rank(MPI.COMM_WORLD); @show MPI.Comm_size(MPI.COMM_WORLD); ```. Is helpful for debugging. Also, I recommend first trying to start jobs interactively before using `sbatch`. Interactive jobs launch faster, so we get a faster trial-error iteration. I'm still working on things, but it seems like another point may be salient:. * Initialize / precompile outside of a parallel job before trying to launch a parallel job via `mpiexec`. Here are some notes that may be specific to engaging:. I'm using `srun` to get a 4-GPU node to use interactively:. ```; srun -p my_partition --tasks-per-node=4 --cpus-per-task=32 --gres=gpu:4 --gpus-per-node=4 --mem=0 -t 01:00:00 -N 1; ```. it seems we have to use the option `gpus-per-node`, rather than setting the total number of GPUs. Also we redundantly also have to specify `gres=gpu:4` (`gres` stands for ""generalized resource""). Why `gres` can't tell what `gpus-per-node` is, I don't know. `-N 1` means 1 node. Finally we also have to specify ``--tasks-per-node=4` (matching `gres` _and_ the number of GPUs per node), otherwise we cannot launch `mpiexec` with 4 tasks (1 for each GPU). It's helpful to have the maximum number of CPUs for precompilation. Otherwise precompilation is very slow. I also set. ```; export JULIA_NUM_PRECOMPILE_TASKS=64; ```. (half the total) --- adapt for your system. Here is also a small test script for debuggin Oceananigans:. ```julia; using Oceananigans; arch = Distributed(GPU()); @show arch; ```. as a side note, it would be nice if we could print to the screen from different ranks without them talking over one another. It makes it hard to read the output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436:2248,adapt,adapt,2248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436,1,['adapt'],['adapt']
Modifiability,"ilities. For example, we might have just doubly periodic in (x, y) plus flux in z on all fields, or singly-periodic in x and flux in (y, z) on all fields. Agree that `CoordinateBoundaryConditions` might be a weird name but yeah, maximum flexibility would be very powerful. Maybe the common use case isn't to impose each of the 30 boundary conditions one-by-one but we can just have nice helper functions/abstractions like; ```julia; model.boundary conditions += HorizontallyPeriodic(); ```. > @ali-ramadhan do you mean with regards to performance? I'm not sure. With multiple dispatch being core to julia it seems this scenario is not uncommon (30+ may not be very large). I'm still pretty new to Julia so yeah don't know if that will be an issue, especially on the GPU. Only way to find out is to try and benchmark! Maybe you're right and 30+ isn't a lot. @vchuravy any idea on whether 30+ parameterized types for a struct is too many? Would this hurt performance on the GPU?. > The function calc does not actually impose a boundary condition --- the imposition of boundary condition depends on, for example, the viscosity and diffusivity, and is a property of the equation (or turbulent closure) being implemented. Again for example, the K-Profile-Parameterization includes a modification of how a flux boundary condition is implemented. In other words, the ""specification of flux"" is separate from the ""imposition of a boundary condition"". The former is determined by the user. The latter is determined by the model/governing equation. I see. So if no parameterizations are being used, are the boundary conditions actually being _imposed_ then? Even with KPP, isn't the boundary condition still being _imposed_ only to later be modified by KPP?. I still feel like `bc.calc()` feels obscure, I'm not sure why a boundary condition should have to calculated. Perhaps it's just semantics but it would be nice to see boundary conditions be _imposed_ in the code and see something like `bc.impose(...)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472241993:1376,Parameteriz,Parameterization,1376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472241993,2,"['Parameteriz', 'parameteriz']","['Parameterization', 'parameterizations']"
Modifiability,"imilar).; >; > What does the jargon ""sounding"" mean?; >; > Merger means we need to think carefully about how to reduce boilerplate to; > minimize (within reason) the cost of maintaining two parallel models as we; > develop their shared subcomponents.; >; > I wonder if splitting off the output writers and diagnostics into a; > Simulation type that wraps AbstractModel may help. In this paradigm, a; > ""Model"" is reduced to numerics + physics specification. This would be easy; > to implement (while I think an Equation abstraction would be relatively; > difficult due to myriad difficult design problems, including the; > abstraction of tuples of terms with heterogeneous function signatures; > numerical aspects of the equation, implicit vs explicit treatment of terms,; > etc).; > The Simulation type can then be used to ""run"" simulations over multiple; > time steps, eg; >; > simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); > run!(simulation); >; > and is tasked with managing things like output writing, diagnostics; > calculation, adaptive time-stepping, and progress logging. Each Model; > then simply needs to define a function that performs a single time-step to; > interface with Simulation. This is discussed further in #447; > <https://github.com/climate-machine/Oceananigans.jl/issues/447>. Such a; > orthogonalization of the code means we can develop the Simulation; > abstraction without having to worry about updating each AbstractModel; > individually.; >; > —; > You are receiving this because you commented.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/605?email_source=notifications&email_token=AKXUEQRA7COBFTVWBSDE3ATRALQCRA5CNFSM4KNLLK52YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEKLF25Y#issuecomment-580279671>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQSOSWBJGZJKTTSGCZ3RALQCRANCNFSM4KNLLK5Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805:2180,adapt,adaptive,2180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805,1,['adapt'],['adaptive']
Modifiability,"in dimensionality. (Adding new solution variables requires code modification, but that is true throughout the code). ### Concerns. * It's more complicated than allowing only 3-4 possibilities to users; as @johncmarshall54 says:. > It's not obvious to me what a field boundary condition is, vs a coordinate boundary condition.; Fundamentally we are applying boundary conditions to u, v, w, T, and S fields, and that's it. It all seems a bit too complicated. * The hierarchical dependence of this design on parameterized types creates a lot of possibilities for different boundary conditions to be specified, and this is a concern for performance (@ali-ramadhan). * We aren't sure what to call the function (currently `bc.calc`) whose purpose is to return the value of the boundary condition (either the field value, flux, gradient, or whatever) at a given grid point and simulation time. ### Other miscellaneous thoughts. * This PR implements a backend / abstraction system for specifying boundary conditions. For users we can add as much sugar on top as we want. * As we have discussed, the way we implement boundary conditions is intimately connected to the way that we specify equations. This can be seen in the current code (though it is commented out) in that [the lines that specify a no-slip condition depend on the ""vertical viscosity""](https://github.com/climate-machine/Oceananigans.jl/blob/7fb355d77df98e37a80b3e796291fa2856d3e1ce/src/time_steppers.jl#L293). Adding other diffusive terms (hyperdiffusivity, Leith diffusivity, various turbulent diffusivity parameterizations/closures) can affect how the boundary condition is implemented. We are not ready to develop an equation abstraction system yet, but we must keep in mind the difference between *implementing* a boundary condition in the context of a set of equations, and *specifying* a boundary condition. This PR attempts to solve the latter problem. . * It would be nice to know how MITgcm implements different boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472372026:2117,parameteriz,parameterizations,2117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472372026,1,['parameteriz'],['parameterizations']
Modifiability,"in general. We currently handle this only during time-stepping --- there is no guarantee, for example, that the diffusivities or ghost cell values are consistent with the velocity field if the velocity field is set by the function `set!` (in fact, the diffusivities are *always* inconsistent with the current velocity field due to the fact that they are calculated *prior* to taking a time-step). If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). What does the jargon ""sounding"" mean?. Merger means we need to think carefully about how to reduce boilerplate to minimize (within reason) the cost of maintaining two parallel models as we develop their shared subcomponents. I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. In this paradigm, a ""Model"" is reduced to numerics + physics specification. This would be easy to implement (while I think an `Equation` abstraction would be relatively difficult due to myriad difficult design problems, including the abstraction of tuples of terms with heterogeneous function signatures, numerical aspects of the equation, implicit vs explicit treatment of terms, etc).; The `Simulation` type can then be used to ""run"" simulations over multiple time steps, eg. ```julia; simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); run!(simulation); ```. and is tasked with managing things like output writing, diagnostics calculation, adaptive time-stepping, and progress logging. Each `Model` then simply needs to define a function that performs a single time-step to interface with `Simulation`. This is discussed further in #447. Such a orthogonalization of the code means we can develop the `Simulation` abstraction without having to worry about updating each `AbstractModel` individually.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671:1960,adapt,adaptive,1960,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671,1,['adapt'],['adaptive']
Modifiability,"in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit. The other option to not use MPI variables is to hardcode the number of processors",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890582696:84,variab,variables,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890582696,2,['variab'],['variables']
Modifiability,"inition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:1210,Config,Config,1210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457,1,['Config'],['Config']
Modifiability,"interpolated u on coarse grid; coarse_grid = RectilinearGrid(size = (grid.Nx, grid.Ny, grid.Nz÷2), extent = (grid.Lx, grid.Ly, grid.Lz)); coarse_u = Field{Face, Center, Center}(coarse_grid). using Oceananigans.Fields: interpolate!; update_coarse_u(simulation) = interpolate!(coarse_u, simulation.model.velocities.u); simulation.callbacks[:update_interp] = Callback(update_coarse_u). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(model, (; coarse_u,), coarse_grid;; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; overwrite_existing=true,). run!(simulation); ```. Throws the following error:. ```; ERROR: LoadError: DimensionMismatch: new dimensions (1, 1, 8, 1) must be consistent with array size 4; Stacktrace:; [1] (::Base.var""#throw_dmrsa#328"")(dims::NTuple{4, Int64}, len::Int64); @ Base ./reshapedarray.jl:41; [2] reshape(a::Array{Float64, 3}, dims::NTuple{4, Int64}); @ Base ./reshapedarray.jl:45; [3] setindex_disk!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing, Missing}}, ::Array{Float64, 3}, ::Function, ::Vararg{Any}); @ DiskArrays ~/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:56; [4] setindex!; @ ~/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel ~/.julia/packages/CommonDataModel/GGvMn/src/cfvariable.jl:477; [6] save_output!(ds::NCDatasets.NCDataset{…}, output::Field{…}, model::NonhydrostaticModel{…}, ow::NetCDFOutputWriter{…}, time_index::Int64, name::String); @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:482; [7] write_output!(ow::NetCDFOutputWriter{…}, model::NonhydrostaticModel{…}); @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:525; [8] initialize!(sim::Simulation{…}); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:212; [9] time_step!(sim:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084:1548,Variab,Variable,1548,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084,1,['Variab'],['Variable']
Modifiability,"ismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Ste",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:1184,Variab,Variable,1184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165,1,['Variab'],['Variable']
Modifiability,"ive.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, Forcing{typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(FS)}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to Cassette.overdub); Stacktrace:; [1] S★ at /archive1/glwagner/Projects/Oceananigans.jl/sandbox/simple_forcing.jl:21; [2] FS at /archive1/glwagner/Projects/Oceananigans.jl/sandbox/simple_forcing.jl:22; [3] calculate_interior_source_terms! at /archive1/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:178; [4] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136; Reason: unsupported dynamic function invocation (call to Cassette.overdub); Stacktrace:; [1] FS at /archive1/glwagner/Projects/Oceananigans.jl/sandbox/simple_forcing.jl:22; [2] calculate_interior_source_terms! at /archive1/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:178; [3] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136; Reason: unsupported dynamic function invocation (call to Cassette.overdub); Stacktrace:; [1] calculate_interior_source_terms! at /archive1/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:178; [2] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136; Stacktrace:; [1] check_ir(::CUDAnative.CompilerJob, ::LLVM.Module) at /data5/glwagner/.julia/packages/CUDAnative/9rZcJ/src/compiler/validation.jl:114; [2] macro expansion at /data5/glwagner/.julia/packages/TimerOutputs/7zSea/src/TimerOutput.jl:216 [inlined]; [3] #codegen#119(::Bool, ::Bool, ::Bool, ::Bool, ::Bool, ::Function, ::Symbol, ::CUDAnative.CompilerJob) at /data5/glwagner/.julia/packages/CUDAnative/9rZcJ/src/compiler/driver.jl:186; [4] #codegen at /data5/glwagner/.julia/packages/CUDAnative/9rZcJ/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496489468:3378,sandbox,sandbox,3378,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496489468,1,['sandbox'],['sandbox']
Modifiability,ll/698/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `87.50% <0.00%> (-12.50%)` | :arrow_down: |; | [src/Models/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `80.00% <0.00%> (-8.89%)` | :arrow_down: |; | [src/Models/Models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `100.00% <0.00%> (ø)` | |; | [src/TimeSteppers/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <0.00%> (ø)` | |; | [src/Forcing/parameterized\_forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvcGFyYW1ldGVyaXplZF9mb3JjaW5nLmps) | `100.00% <0.00%> (ø)` | |; | [src/BoundaryConditions/apply\_no\_penetration\_bcs.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9ub19wZW5ldHJhdGlvbl9iY3Muamw=) | `58.33% <0.00%> (+1.19%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `92.30% <0.00%> (+3.41%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/698#issuecomment-599273522:2601,parameteriz,parameterized,2601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/698#issuecomment-599273522,1,['parameteriz'],['parameterized']
Modifiability,"lliptic]]; git-tree-sha1 = ""71c79e77221ab3a29918aaf6db4f217b89138608""; uuid = ""b305315f-e792-5b7a-8f41-49f472929428""; version = ""1.0.1"". [[ExprTools]]; git-tree-sha1 = ""10407a39b87f29d47ebaca8edbc75d7c302ff93e""; uuid = ""e2ba6199-217a-4e67-a87a-7c52f15ade04""; version = ""0.1.3"". [[FFTW]]; deps = [""AbstractFFTs"", ""FFTW_jll"", ""IntelOpenMP_jll"", ""Libdl"", ""LinearAlgebra"", ""MKL_jll"", ""Reexport""]; git-tree-sha1 = ""1b48dbde42f307e48685fa9213d8b9f8c0d87594""; uuid = ""7a1cc6ca-52ef-59f5-83cd-3a7055c09341""; version = ""1.3.2"". [[FFTW_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""5a0d4b6a22a34d17d53543bd124f4b08ed78e8b0""; uuid = ""f5851436-0d7a-5f13-b9de-f02708fd171a""; version = ""3.3.9+7"". [[FileIO]]; deps = [""Pkg"", ""Requires"", ""UUIDs""]; git-tree-sha1 = ""b647ed22f176a4f12eabe2afd90d19a95af2e8ca""; uuid = ""5789e2e9-d7fb-5bc7-8068-2c6fae9b9549""; version = ""1.8.0"". [[GPUArrays]]; deps = [""AbstractFFTs"", ""Adapt"", ""LinearAlgebra"", ""Printf"", ""Random"", ""Serialization""]; git-tree-sha1 = ""9c95b2fd5c16bc7f97371e9f92f0fef77e0f5957""; uuid = ""0c68f7d7-f131-5f86-a1c3-88cf8149b2d7""; version = ""6.2.2"". [[GPUCompiler]]; deps = [""DataStructures"", ""InteractiveUtils"", ""LLVM"", ""Libdl"", ""Scratch"", ""Serialization"", ""TimerOutputs"", ""UUIDs""]; git-tree-sha1 = ""c853c810b52a80f9aad79ab109207889e57f41ef""; uuid = ""61eb1bfa-7361-4325-ad38-22787b887f55""; version = ""0.8.3"". [[Glob]]; git-tree-sha1 = ""4df9f7e06108728ebf00a0a11edee4b29a482bb2""; uuid = ""c27321d9-0574-5035-807b-f59d2c89b15c""; version = ""1.3.0"". [[HDF5_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""LibCURL_jll"", ""Libdl"", ""OpenSSL_jll"", ""Pkg"", ""Zlib_jll""]; git-tree-sha1 = ""fd83fa0bde42e01952757f01149dd968c06c4dba""; uuid = ""0234f1f7-429e-5d53-9886-15a909be8d59""; version = ""1.12.0+1"". [[IfElse]]; git-tree-sha1 = ""28e837ff3e7a6c3cdb252ce49fb412c8eb3caeef""; uuid = ""615f187c-cbe4-4ef1-ba3b-2fcf58d6d173""; version = ""0.1.0"". [[IntelOpenMP_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""d979e54b71da82f3a65",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:5373,Adapt,Adapt,5373,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,looking at the benchmarks in #2335 it seems that it does. But only for some configurations,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261412615:76,config,configurations,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261412615,1,['config'],['configurations']
Modifiability,"losures for LES and ocean modeling (Dynamic Smagorinsky, Deardorff, k-epsilon, Gent-McWilliams, convective adjustment (?) etc --- physics). We have a need to implement new turbulence closures new and old alike. Gent-McWilliams is probably easy since we already have a Leith closure implemented which calculates the tensor needed to rotate the diffusivity into an isopycnal coordinate. The others are a bit more challenging. 4. Extensive profiling and benchmarking on the GPU to identify bottlenecks / places for improvement in the algorithm (numerics). We might be able to make the code a lot faster (but we aren't sure). 5. A solver for hydrostatic problems with a free surface that uses a split-explicit time-integration method. This is notoriously tricky, but we've made a lot of progress on this for the purposes of the ClimateMachine and it might be interesting to translate what we've learned into Oceananigans. There's also some minor package stuff that I want to work on, such as refactoring the output writer (#963), improving logging / feedback while oceananigans builds a model or runs a simulation (#1013), getting arrays with named axes to work (#457), and figuring out what's going wrong with models that have `Flat` dimensions (#1024). A more fun project is to come up with cool plotting recipes in 1D, 2D, and 3D (!) We'd like to show people how to use Makie (for example) to create really cool visualizations / animations of turbulence. The examples do some animation, but more complicated stuff (such as 3D contourf plots, or volume rendering) might require dedicated scripts. @navidcy and I have also discussed projects to implement 1) a shallow water model using Oceananigans functionality and 2) a quasi-geostrophic model in Oceananigans (which would use the tridiagonal solver I mentioned earlier). What else? The best project is probably one that aligns with you and your students' research... ? Definitely happy to chat further and also collaborate on something if you'd like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281:2654,refactor,refactoring,2654,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281,1,['refactor'],['refactoring']
Modifiability,"lsevier.com/reader/sd/pii/S0377042717303035?token=83A413B5659B8B16B96E1D0CBDAD5865D8552AE5B2FF2FDFE78FFDEF064F2820B38D1BBFF646D3F7B75D58FE010DF7DB&originRegion=us-east-1&originCreation=20230125193548). You can always try with higher order (maybe 7th?) but the higher the order the lower the stability (i.e. at a certain order your implicit dissipation will be so low that you will start to generate grid-scale noise). . The KE dissipation is there with `closure=nothing` and a WENO scheme, it is just not strictly physical: it's (roughly) akin to a 4th to a 6th-order hyperviscosity. You can compare this to using `UpwindBiased(order = 5)` which would give you everywhere a dissipation that converges to a 6th-order hyperviscosity. In general:. $$\partial_x {uu}^{Upwind_N} \sim \partial_x {uu}^{Centered_{N+1}} + \partial_x {K_{numerical}} \partial_x^{N} u$$. where $K_{numerical} \sim \Delta x u$ and $N$ is the order. The nice thing about using WENO instead of a simple Upwind discretization is that the order of the hyperviscosity adapts to the smoothness of the field. Therefore, where the field is noisier (like in regions of higher gradients) the dissipation is more aggressive. . This procedure not only ensures a smooth field but can be thought of as mimicking the subgrid-scale dissipation (which also increases with the gradient of resolved scale variables. As such people have referred to using particularly diffusive advective schemes (such as WENO) as _Implicit_ LES. I like the idea of implicit LES because it allows you to ""fill in"" for the subgrid-scale dissipation without committing to any sophisticated formulation derived in a particularly idealized situation (take the example of Leith derived in homogeneous 2D turbulence and the geostrophic eddies in the ocean), and guarantees (or at least helps) stability. For this reason, it's pretty handy when you have different unresolved processes at different scales that may be characterized by different dissipation characteristics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433:1749,variab,variables,1749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433,1,['variab'],['variables']
Modifiability,"lways have them together. At some point we have to get the external value, and if it's in the condition slot in `BoundaryCondition` we can get it like this:; https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/fill_halo_regions_value_gradient.jl#L9. which can be e.g.; https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/continuous_boundary_function.jl#L124-L133; which is called because of there being a `ContinuousBoundaryFunction` in the `BoundaryCondition` type:; https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/continuous_boundary_function.jl#L119; which was automatically set-up and then `regularize`-d. https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/boundary_condition.jl#L53-L67. https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/continuous_boundary_function.jl#L74-L75. But if we have this as part of the condition we get something like:; ```julia; BoundaryCondition{<:Open, <:OpenConditions{ES, MS}}; ```. then we'd have to rewrite loads of stuff to make it so the user can specify whatever they want for the external state. In the existing code the condition and classification are never directly accessed (except from inside `getbc`) and all of the other bits are based on the types:. https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/fill_halo_regions_value_gradient.jl#L15. so we can just write methods like:. ```julia; @inline function _fill_west_halo!(j, k, grid, c, bc::BoundaryCondition{Open{<:SomeMatchingScheme}}, loc, args...); ```. I don't really understand how it makes the code any harder to understand if we then get the condition as above v.s. writing new things so we can do `external_state = some_function(bc)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988307344:1370,rewrite,rewrite,1370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988307344,1,['rewrite'],['rewrite']
Modifiability,"macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7089,Adapt,Adapt,7089,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685,2,['Adapt'],['Adapt']
Modifiability,more flexible and less code -- what can go wrong?. yeap!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2239#issuecomment-1034433920:5,flexible,flexible,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2239#issuecomment-1034433920,1,['flexible'],['flexible']
Modifiability,"n . using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)). # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. # Temperature initial condition: a stable density gradient with random noise superposed. Tᵢ(x, y, z) = T0 + dTz * z + dTz * model.grid.Lz * Factor_T * Ξ(z). # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * Factor_V * Ξ(z). # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl= CFL, Δt = initial_timestep, max_change = max_allowable_change_in_Δt, max_Δt = maximum_Δt). # A type for calculating adaptive time steps based on capping the CFL number at `cfl`.; # On calling `update_Δt!(wizard, model)`, the `TimeStepWizard` computes a time-step such that; # ``cfl = max(u/Δx, v/Δy, w/Δz) Δt``, where ``max(u/Δx, v/Δy, w/Δz)`` is the maximum ratio; # between model velocity and along-velocity grid spacing anywhere on the model grid. The new; # `Δt` is constrained to change by a multiplicative factor no more than `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_n",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999:4483,adapt,adaptive,4483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999,1,['adapt'],['adaptive']
Modifiability,"nd see an unfamiliar function so I scroll to the top to see where it was imported from. If the `import` statement is in the module file, then I have to scroll through a screenful of import statements in another file in search of the relevant line. > What is the problem that this change would solve? If one is reading code in a file, and an unfamiliar function appears, one presumably looks to the top-level to see where it is imported. If one is reading a module, why is it crucial to know where in the code the package is used?. It solves two problems: messy module files, and makes it easier to understand where import statements are used. Maybe we do things differently, but I always scroll to the top of the current file to look for import statements. I've never thought to look the module top-level file. Additionally, a list of import statements at the top of the file tell me what to expect in this file. I always skim the import statements before reading a file, although this may be Pythonic behavior haha. > This new convention could create issues in which functionality from a package imported in one file is used elsewhere, making it hard to trace exactly where an unfamiliar function first arrived in the namespace. Or, if two packages conflict with one another. In julia, resolving method conflicts when two packages export the same name can be tricky and the resolution depends on the order in which packages are imported. We can break with convention when needed, but presumably this is the rare exception rather than rule. > I think having more submodules (#495, #456) is really the right solution to this problem; in that case each module is short so the issue of tracing import statements to usage within a huge module is alleviated. Yeah maybe after we have more submodule it'll be clearer how to tackle this issue and maybe it won't be as bad. Although I think some refactoring/reorganizing/reordering of import statements may be needed to make the import statements more local.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-547225547:3004,refactor,refactoring,3004,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-547225547,1,['refactor'],['refactoring']
Modifiability,"ndaryConditions/boundary\_function.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9mdW5jdGlvbi5qbA==) | `81.48% <0.00%> (-4.24%)` | :arrow_down: |; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `96.66% <0.00%> (-3.34%)` | :arrow_down: |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `94.20% <0.00%> (-1.04%)` | :arrow_down: |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/fill\_halo\_regions\_value\_gradient.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9uc192YWx1ZV9ncmFkaWVudC5qbA==) | `28.30% <0.00%> (ø)` | |; | ... and [14 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905?src=pr&el=footer). Last update [f13a0a2...a40305f](https://c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/905#issuecomment-686484714:2788,parameteriz,parameterized,2788,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/905#issuecomment-686484714,1,['parameteriz'],['parameterized']
Modifiability,"nditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, Nothing}, Float64, Float64, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractDiagnostic}, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractOutputWriter}, OrderedCollections.OrderedDict{Symbol, Callback}}); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:195; ```. That is to say `NetCDFWriter` isn't correctly inferring the sizes for each variable when creating the NetCDF file. I think atm each file creating assumes all outputs are sliced similarly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:49725,variab,variable,49725,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655,1,['variab'],['variable']
Modifiability,"ndom""]; git-tree-sha1 = ""6a8a2a625ab0dea913aba95c11370589e0239ff0""; uuid = ""1914dd2f-81c6-5fcd-8719-6d5c9610ff09""; version = ""0.5.6"". [[Markdown]]; deps = [""Base64""]; uuid = ""d6f4376e-aef5-505a-96c1-9c027394607a"". [[MbedTLS_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""0eef589dd1c26a3ac9d753fe1a8bcad63f956fa6""; uuid = ""c8ffd9c3-330d-5841-b78e-0817d7145fa1""; version = ""2.16.8+1"". [[MicrosoftMPI_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""e5c90234b3967684c9c6f87b4a54549b4ce21836""; uuid = ""9237b28f-5490-5468-be7b-bb81f5f5e6cf""; version = ""10.1.3+0"". [[Mmap]]; uuid = ""a63ad114-7e13-5084-954f-fe012c677804"". [[NCDatasets]]; deps = [""CFTime"", ""DataStructures"", ""Dates"", ""NetCDF_jll"", ""Printf""]; git-tree-sha1 = ""b71d83c87d80f5c54c55a7a9a3aa42bf931c72aa""; uuid = ""85f8d34a-cbdd-5861-8df4-14fed0d494ab""; version = ""0.11.3"". [[NNlib]]; deps = [""Adapt"", ""ChainRulesCore"", ""Compat"", ""LinearAlgebra"", ""Pkg"", ""Requires"", ""Statistics""]; git-tree-sha1 = ""80b8360670f445d88b3475e88b33bbcc92f7866e""; uuid = ""872c559c-99b0-510c-b3b7-b6c96a88d5cd""; version = ""0.7.19"". [[NaNMath]]; git-tree-sha1 = ""bfe47e760d60b82b66b61d2d44128b62e3a369fb""; uuid = ""77ba4419-2d1f-58cd-9bb1-8ffee604a2e3""; version = ""0.3.5"". [[NetCDF_jll]]; deps = [""Artifacts"", ""HDF5_jll"", ""JLLWrappers"", ""LibCURL_jll"", ""LibSSH2_jll"", ""Libdl"", ""MbedTLS_jll"", ""Pkg"", ""Zlib_jll"", ""nghttp2_jll""]; git-tree-sha1 = ""d5835f95aea3b93965a1a7c06de9aace8cb82d99""; uuid = ""7243133f-43d8-5620-bbf4-c2c921802cf3""; version = ""400.701.400+0"". [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""FFTW"", ""Glob"", ""InteractiveUtils"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SafeTestsets"", ""SeawaterPolynomials"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""861d8cca4447304a21a94110e3ffc786cab52dce""; uuid = ""9e8cae18-63c1-5223-a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:10403,Adapt,Adapt,10403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,"nearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo ; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Flat on vertically stretched grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5 ; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Periodic on vertically uniform grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Periodic on vertically stretched grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Flat on vertically uniform grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo ; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Flat on vertically stretched grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo ; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5 ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2063314232:3222,variab,variably,3222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2063314232,2,['variab'],['variably']
Modifiability,"necessarily reproduce the Manifest. I think unless you pin something, Pkg will try to get the latest set of packages that are still compatible. In fact, I don't think it's even recommended to add a Manifest with the github repo (at least not according to github: https://github.com/github/gitignore/blob/b0012e4930d0a8c350254a3caeedf7441ea286a3/Julia.gitignore#L20-L24). This is an example of a fresh Oceananigans install I just made. Notice it installed CUDA v3.4.2:. ```julia; (@v1.6) pkg> activate .; Activating new environment at `~/Dropbox/tests/fresh/Project.toml`. (fresh) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General`; Resolving package versions...; Installed ChainRulesCore ─ v1.7.2; Installed Tables ───────── v1.6.0; Installed Parsers ──────── v2.0.5; Installed StaticArrays ─── v1.2.13; Updating `~/Dropbox/tests/fresh/Project.toml`; [9e8cae18] + Oceananigans v0.63.1; Updating `~/Dropbox/tests/fresh/Manifest.toml`; [621f4979] + AbstractFFTs v1.0.1; [79e6a3ab] + Adapt v3.3.1; [4fba245c] + ArrayInterface v3.1.33; [ab4f0b2a] + BFloat16s v0.1.0; [fa961155] + CEnum v0.4.1; [179af706] + CFTime v0.1.1; [052768ef] + CUDA v3.4.2; [72cfdca4] + CUDAKernels v0.3.0; [7057c7e9] + Cassette v0.3.9; [d360d2e6] + ChainRulesCore v1.7.2; [34da2185] + Compat v3.39.0; [a8cc5b0e] + Crayons v4.0.4; [7445602f] + CubedSphere v0.1.0; [9a962f9c] + DataAPI v1.9.0; [864edb3b] + DataStructures v0.18.10; [e2d170a0] + DataValueInterfaces v1.0.0; [b552c78f] + DiffRules v1.3.1; [ffbed154] + DocStringExtensions v0.8.5; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + KernelAbstractions v0.7.0; [929cbde3] +",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:1041,Adapt,Adapt,1041,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237,1,['Adapt'],['Adapt']
Modifiability,need a test too I think. Probably some refactoring to come for Lagrangian particles...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2397#issuecomment-1083725453:39,refactor,refactoring,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2397#issuecomment-1083725453,1,['refactor'],['refactoring']
Modifiability,"ng. John; >; > On Tue, Jun 25, 2019, 7:49 PM Gregory L. Wagner <notifications@github.com>; > wrote:; >; > > Adaptive time-stepping is useful for a wide class of problems. The general; > > strategy is to use the CFL number to compute a stable time-step. This is; > > especially useful in problems with lots of time variability --- for; > > example, LES of a seasonal cycle. In addition, the CFL computation can be; > > used to stabilize the spin-up of a model, during which a transition to; > > turbulence occurs.; > >; > > Some complexity is introduced by the fact that we use Adams-Bashforth time; > > stepping (as opposed to a RK-method, which is more common and more stable),; > > since it means we need to re-initialize the ""previous source terms"" with a; > > forward Euler step when the time step is changed.; > >; > > I have been using adaptive time-stepping in my work, which along with a; > > strategy for handling model spinup / transition to turbulence, has proven; > > to be an important practical feature that makes running experimental; > > simulations under different conditions much easier, since all I need to do; > > is set my boundary conditions, and let the model run. I am then able to; > > start dozens of LES per day (if I want to) without having to choose my time; > > step size through a mistake-prone and time-consuming trial-and-error; > > process --- and I am guaranteed not to waste resources with a too-short; > > time-step.; > >; > > —; > > You are receiving this because you commented.; > > Reply to this email directly, view it on GitHub; > > <https://github.com/climate-machine/Oceananigans.jl/pull/297?email_source=notifications&email_token=AKXUEQVQYODJTMVZ46AOA3TP4JLCFA5CNFSM4H3I7NT2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODYRBT7Q#issuecomment-505551358>,; > > or mute the thread; > > <https://github.com/notifications/unsubscribe-auth/AKXUEQS54XWGGG7MKQWZZELP4JLCFANCNFSM4H3I7NTQ>; > > .; > >; >; > —; > You are receiving this because you are ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505614637:1141,adapt,adaptive,1141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297#issuecomment-505614637,1,['adapt'],['adaptive']
Modifiability,"ntAnisotropicDiffusivity{Float64}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, Forcing{typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(FS)}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to Cassette.overdub); Stacktrace:; [1] S★ at /archive1/glwagner/Projects/Oceananigans.jl/sandbox/simple_forcing.jl:21; [2] FS at /archive1/glwagner/Projects/Oceananigans.jl/sandbox/simple_forcing.jl:22; [3] calculate_interior_source_terms! at /archive1/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:178; [4] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136; Reason: unsupported dynamic function invocation (call to Cassette.overdub); Stacktrace:; [1] FS at /archive1/glwagner/Projects/Oceananigans.jl/sandbox/simple_forcing.jl:22; [2] calculate_interior_source_terms! at /archive1/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:178; [3] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136; Reason: unsupported dynamic function invocation (call to Cassette.overdub); Stacktrace:; [1] calculate_interior_source_terms! at /archive1/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:178; [2] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136; Stacktrace:; [1] check_ir(::CUDAnative.CompilerJob, ::LLVM.Mo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496489468:2930,sandbox,sandbox,2930,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496489468,1,['sandbox'],['sandbox']
Modifiability,"nvironment. Relevant only when using TCP/IP as transport. To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute addprocs in its own task. Examples; ≡≡≡≡≡≡≡≡≡≡. # On busy clusters, call `addprocs` asynchronously; t = @async addprocs(...). # Utilize workers as and when they come online; if nprocs() > 1 # Ensure at least one new worker is available; .... # perform distributed execution; end. # Retrieve newly launched worker IDs, or any error messages; if istaskdone(t) # Check if `addprocs` has completed to ensure `fetch` doesn't block; if nworkers() == N; new_pids = fetch(t); else; fetch(t); end; end. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers. Add worker processes on remote machines via SSH. Configuration is done with keyword arguments (see below). In particular, the exename keyword; can be used to specify the path to the julia binary on the remote machine(s). machines is a vector of ""machine specifications"" which are given as strings of the form [user@]host[:port] [bind_addr[:port]]. user defaults to; current user and port to the standard SSH port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified; bind_addr and port. It is possible to launch multiple processes on a remote host by using a tuple in the machines vector or the form (machine_spec, count), where; count is the number of workers to be launched on the specified host. Passing :auto as the worker count will launch as many workers as the number; of CPU threads on the remote host. Examples:. addprocs([; ""remote1"", # one worker on 'remote1' logging in with the current username; ""user@remote2"", # one worker on 'remote2' logging in with the 'user' username; ""user@remote3:2222"", # specifying SSH port to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:1470,Config,Configuration,1470,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['Config'],['Configuration']
Modifiability,"o switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length scale. So if you use MEKE with the Eady length scale `L_e` (see Appendix Ab in Kong and Jansen, 2021), you recover the GEOMETRIC source term.; c) **sub-grid dissipation**: MEKE assumes only bottom drag, GEOMETRIC uses one ""catch-all"" linear damping term as the energy sink term in the sub-grid energy budget. As highlighted in [Mak et al. (2022)](https://onlinelibrary.wiley.com/doi/abs/10.1029/2021GL097259), this sub-grid dissipation term is probably the big elephant in the room, which the solution is very sensitive to but noone knows what the term should look like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:2466,parameteriz,parameterizations,2466,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692,1,['parameteriz'],['parameterizations']
Modifiability,"o the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving and they can increase kinetic energy. I know of a form of the harmonic case that is positive preserving and we could include that. But does anyone case about those levels of details? If yes I can include the form in the writeup and even a short derivation of how to get it from the 3D equations.; 4. @glwagner pointed out that `ShallowWaterModel` is very separate from everything else in Oceananigans and that is a bit of a pain to maintain. One advantage of a `VectorInvariant` form is that it could rely heavily on `HydrostaticModel`, that way they grow together. It might even ben an embarassingly simply application.; 5. I would like there to be a switch from free-surface to rigid-lid. In the latter we have to solve an elliptic problem, and again probably easier with a `VectorInvariant` form but probably not difficult with a conservative form either. How do people sugge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:2116,adapt,adapt,2116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381,1,['adapt'],['adapt']
Modifiability,"o: Computing wτ6 done: time=292.708 μs; [ Info: Computing wτ2 done: time=192.674 ms; [ Info: Computing wτ5 done: time=190.263 ms; [ Info: Computing wτ4 done: time=193.185 ms; [ Info: Computing wτ1_yavg done: time=1.210 seconds; [ Info: Computing wτ4_yavg done: time=2.954 seconds; [ Info: Computing wτ3_yavg done: time=2.953 seconds; [ Info: Writing done: time=17.732 seconds, size=19.5 KiB, Δsize=0.0 B; [ Info: ... simulation initialization complete (18.528 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (30.965 seconds).; [ Info: Simulation is stopping after running for 49.565 seconds.; [ Info: Model iteration 4 equals or exceeds stop iteration 4.; ```. and then . ```Julia; julia> using NCDatasets. julia> ds = NCDataset(simulation.output_writers[:xz1_writer].filepath, ""r""); NCDataset: ./test.nc; Group: /. Dimensions; zC = 16; zF = 17; xC = 16; yF = 1; xF = 16; yC = 1; time = 1. Variables; zC (16); Datatype: Float64; Dimensions: zC; Attributes:; units = m; longname = Locations of the cell centers in the z-direction. zF (17); Datatype: Float64; Dimensions: zF; Attributes:; units = m; longname = Locations of the cell faces in the z-direction. xC (16); Datatype: Float64; Dimensions: xC; Attributes:; units = m; longname = Locations of the cell centers in the x-direction. yF (1); Datatype: Float64; Dimensions: yF; Attributes:; units = m; longname = Locations of the cell faces in the y-direction. xF (16); Datatype: Float64; Dimensions: xF; Attributes:; units = m; longname = Locations of the cell faces in the x-direction. yC (1); Datatype: Float64; Dimensions: yC; Attributes:; units = m; longname = Locations of the cell centers in the y-direction. time (1); Datatype: Float64; Dimensions: time; Attributes:; units = seconds; longname = Time. wτ3 (16 × 1 × 17 × 1); Datatype: Float64; Dimensions: xC × yC × zF × time. wτ2_yavg (16 × 17 × 1); Datatype: Float64; Dimensions: xC × zF × time. wτ6_yavg (16 × 17 × 1); Datatype: Float64; Dimension",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1435832387:2563,Variab,Variables,2563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1435832387,1,['Variab'],['Variables']
Modifiability,"odel::NonhydrostaticModel{…}, callbacks::Vector{…}); > @ Oceananigans.Models.NonhydrostaticModels ~/Research/OC10.jl/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl:31; > [11] #apply_regionally!#56; > @ ~/Research/OC10.jl/src/Utils/multi_region_transformation.jl:121 [inlined]; > [12] apply_regionally!; > @ ~/Research/OC10.jl/src/Utils/multi_region_transformation.jl:118 [inlined]; > [13] macro expansion; > @ ~/Research/OC10.jl/src/Utils/multi_region_transformation.jl:206 [inlined]; > [14] update_state!(model::NonhydrostaticModel{…}, callbacks::Vector{…}; compute_tendencies::Bool); > @ Oceananigans.Models.NonhydrostaticModels ~/Research/OC10.jl/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl:47; > [15] update_state!; > @ ~/Research/OC10.jl/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl:19 [inlined]; > [16] update_state!(model::NonhydrostaticModel{…}); > @ Oceananigans.Models.NonhydrostaticModels ~/Research/OC10.jl/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl:19; > [17] NonhydrostaticModel(; grid::RectilinearGrid{…}, clock::Clock{…}, advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, stokes_drift::Nothing, forcing::@NamedTuple{…}, closure::Nothing, boundary_conditions::@NamedTuple{}, tracers::Tuple{}, timestepper::Symbol, background_fields::@NamedTuple{}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, pressures::Nothing, diffusivity_fields::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing, auxiliary_fields::@NamedTuple{}); > @ Oceananigans.Models.NonhydrostaticModels ~/Research/OC10.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:198; > [18] top-level scope; > @ REPL[5]:1; > Some type information was truncated. Use `show(err)` to see complete types.; > ```. Ok I fixed that. Probably we should use a `Field` rather than `ones` for the test and examples, because it automatically adapts to GPU, distributed, etc, so its a bit better.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1986430708:5212,adapt,adapts,5212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1986430708,1,['adapt'],['adapts']
Modifiability,"ok, @simone-silvestri, I did what you were suggesting.; we now need to refactor the tests....... oh dear........",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3503#issuecomment-1994981771:71,refactor,refactor,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3503#issuecomment-1994981771,1,['refactor'],['refactor']
Modifiability,"ok, now that #2522 is merged we can start thinking of multiple layers :) ; I put an overleaf doc with eqs at https://www.overleaf.com/read/mtyjxnnrjpqv",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1146735146:63,layers,layers,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1146735146,1,['layers'],['layers']
Modifiability,"ok, so now we have. ```julia. julia> grid; 32×32×24 RectilinearGrid{Float64} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 64.0) regularly spaced with Δx = 2.0; ├── Periodic y ∈ [0.0, 64.0) regularly spaced with Δy = 2.0; └── Bounded z ∈ [-32.0, -0.0] variably spaced with min(Δz) = 0.682695, max(Δz) = 1.830909; ```. and. ```julia; julia> c; 32×32×24 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── data: 34×34×26 OffsetArray(::Array{Float64, 3}, 0:33, 0:33, 0:25) with eltype Float64 with indices 0:33×0:33×0:25; │ └── max=0.999994, min=0.000024, mean=0.497759; ├── grid: 32×32×24 RectilinearGrid{Float64} on CPU with 1×1×1 halo; └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux; ```. what do we think so far?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017914892:253,variab,variably,253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017914892,1,['variab'],['variably']
Modifiability,"onal changes and it seems to be doing much better! Still three tests that fail. I looked ath the initialize environments and saw what I copied below. It seems to have probelms with Oceananigans?. ```. ✗ Oceananigans; --;   | 105 dependencies successfully precompiled in 112 seconds;   | 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package;   | Precompiling project...;   | ✗ Oceananigans;   | 0 dependencies successfully precompiled in 22 seconds. 105 already precompiled.;   |  ;   | ERROR: The following 1 direct dependency failed to precompile:;   |  ;   | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];   |  ;   | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-9773/compiled/v1.8/Oceananigans/jl_yggB5x.;   | [NVBLAS] No Gpu available;   | [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf';   | [NVBLAS] Cannot open default config file 'nvblas.conf';   | [NVBLAS] Config parsed;   | [NVBLAS] CPU Blas library need to be provided;   | ERROR: LoadError: syntax: missing comma or ) in argument list;   | Stacktrace:;   | [1] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/non_traditional_beta_plane.jl:75;   | [2] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [3] include(x::String);   | @ Oceananigans.Coriolis ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:1;   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:28;   | [5] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [6] include(x::String);   | @ Oceananigans ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:5;   | [7] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:230;   | [8] include;   | @ ./Base.jl:419 [inlined];   | [9] include_package_for_output(pkg::Base.PkgId, input::String, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445:1031,config,config,1031,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445,1,['config'],['config']
Modifiability,"pInfo]]; > git-tree-sha1 = ""2e5c102cfc41f48ae4740c7eca7743cc7e7b75ea""; > uuid = ""8b046642-f1f6-4319-8d3c-209ddc03c586""; > version = ""1.0.0""; 412c431; < git-tree-sha1 = ""f2355693d6778a178ade15952b7ac47a4ff97996""; ---; > git-tree-sha1 = ""50901ebc375ed41dbf8058da26f9de442febbbec""; 414c433; < version = ""1.3.0""; ---; > version = ""1.3.1""; 499c518; < git-tree-sha1 = ""781916a2ebf2841467cda03b6f1af43e23839d85""; ---; > git-tree-sha1 = ""8f6af051b9e8ec597fa09d8885ed79fd582f33c9""; 501c520; < version = ""0.1.9""; ---; > version = ""0.1.10""; 526c545; < git-tree-sha1 = ""a7023883872e52bc29bcaac74f19adf39347d2d5""; ---; > git-tree-sha1 = ""b01beb91d20b0d1312a9471a36017b5b339d26de""; 528c547; < version = ""10.1.4+0""; ---; > version = ""10.1.4+1""; 570a590,601; > [[deps.Oceananigans]]; > deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""Distances"", ""DocStringExtensions"", ""FFTW"", ""Glob"", ""IncompleteLU"", ""InteractiveUtils"", ""IterativeSolvers"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilArrays"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SeawaterPolynomials"", ""SparseArrays"", ""Statistics"", ""StructArrays""]; > path = ""/Users/gregorywagner/Projects/Oceananigans.jl""; > uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; > version = ""0.90.1""; >; > [deps.Oceananigans.extensions]; > OceananigansEnzymeCoreExt = ""EnzymeCore""; >; > [deps.Oceananigans.weakdeps]; > EnzymeCore = ""f151be2c-9106-41f4-ab19-57ee4f262869""; >; 588,589c619,620; < deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""JLLWrappers"", ""LazyArtifacts"", ""Libdl"", ""MPIPreferences"", ""TOML""]; < git-tree-sha1 = ""e25c1778a98e34219a00455d6e4384e017ea9762""; ---; > deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""Hwloc_jll"", ""JLLWrappers"", ""LazyArtifacts"", ""Libdl"", ""MPIPreferences"", ""PMIx_jll"", ""TOML"", ""Zlib_jll"", ""libevent_jll"", ""prrte_jll""]; > git-tree-sha1 = ""694458ae803b684f09c07f90459cb79655fb377d""; 591c622; < version = ""4.1.6+0""; ---; > versi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:7871,Adapt,Adapt,7871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361,1,['Adapt'],['Adapt']
Modifiability,"propriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don't need that). `DiscreteBoundaryFunction` won't be very convenient for most people for immersed boundary conditions, but we can treat it the same way we treat constant `Value` or `Flux`. I wasn't planning to implement support for `Gradient` just yet, though this can be done too. Finally, one remaining task is to define or generalize the existing `conditional_flux` so that it adds fluxes only on _immersed_ boundaries. It looks like right now it's too eager and will add fluxes on non-immersed boundaries. Associated with this development I'd like to refactor our naming scheme for the boolean tools we have. Right now these are `solid_node` and `solid_interface`. I'd like to change `solid_node` to `external_node` (ie external to the active domain) and perhaps something like `external_or_boundary_node` for `solid_interface` to represent _both_ nodes that are completely external, or which lie _on_ the boundary. A better name is welcome...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:2553,refactor,refactor,2553,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991,1,['refactor'],['refactor']
Modifiability,"ps://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.1.0 (2019-01-21); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using CUDAnative; julia> using Oceananigans; julia> model = Model(N=(128, 128, 128), L=(100, 100, 100), arch=GPU(), float_type=Float32);; julia> time_step!(model, 1, 1); julia> CUDAnative.timings(); ────────────────────────────────────────────────────────────────────────────────────; Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 164s / 10.7% 6.24GiB / 29.4% ; Section ncalls time %tot avg alloc %tot avg; ────────────────────────────────────────────────────────────────────────────────────; LLVM middle-end 14 9.08s 52.0% 649ms 637MiB 33.9% 45.5MiB; IR generation 14 7.00s 40.1% 500ms 567MiB 30.2% 40.5MiB; linking 14 2.49s 14.2% 178ms 224B 0.00% 16.0B; emission 14 2.28s 13.0% 163ms 406MiB 21.6% 29.0MiB; rewrite 14 2.13s 12.2% 152ms 157MiB 8.34% 11.2MiB; hide unreachable 2.02k 540ms 3.09% 267μs 20.9MiB 1.11% 10.6KiB; find 2.02k 295ms 1.69% 146μs 902KiB 0.05% 456B; predecessors 2.02k 162ms 0.93% 80.1μs 13.2MiB 0.70% 6.68KiB; replace 2.02k 68.7ms 0.39% 34.0μs 368KiB 0.02% 186B; lower throw 14 528ms 3.03% 37.7ms 47.8MiB 2.55% 3.42MiB; hide trap 14 65.8ms 0.38% 4.70ms 4.23MiB 0.23% 309KiB; clean-up 14 98.9ms 0.57% 7.06ms 4.85MiB 0.26% 355KiB; optimization 14 1.99s 11.4% 142ms 69.8MiB 3.71% 4.98MiB; device library 14 83.7ms 0.48% 5.98ms 11.5KiB 0.00% 839B; runtime library 14 6.44ms 0.04% 460μs 7.11KiB 0.00% 520B; verification 14 2.97ms 0.02% 212μs 0.00B 0.00% 0.00B; Julia front-end 14 6.70s 38.3% 478ms 1.11GiB 60.6% 81.3MiB; CUDA object generation 14 919ms 5.26% 65.6ms 31.9MiB 1.70% 2.28MiB; linking 14 780ms 4.47% 55.7ms 14.0MiB 0.75% 1.00MiB; compilation 14 139ms 0.79% 9.91ms 17.9MiB 0.95% 1.28MiB; LLVM back-end 14 769ms 4.40% 54.9ms 71.1MiB 3.78% 5.08MiB; machine-code generation 14 124ms 0.71",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/66#issuecomment-478985611:1301,rewrite,rewrite,1301,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/66#issuecomment-478985611,1,['rewrite'],['rewrite']
Modifiability,"reates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.Twic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:1161,Variab,Variable,1161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655,1,['Variab'],['Variable']
Modifiability,"rettytime(wizard.Δt). function Base.print(progress::ProgressMessenger); @printf(""i: %04d, t: %s, Δt: %s, ; progress.model.clock.iteration, prettytime(progress.model.clock.time), pretty_Δt(progress.Δt)) ; return nothing; end; ```. One could then expand on this design by setting up the `diagnostics` field to accept a list of callable objects or functions. Or even better, a list of objects that look something like. ```julia; struct PrintableDiagnostic{D}; diagnostic :: D; format :: String; name :: String; units :: String; end. function pretty_diagnostic(pd::PrintableDiagnostic, model); return @sprintf(""%s: $(pd.format) %s"", pd.name, pd.diagnostic(model), pd.units); end; ```. with this design, the user can pass a list of `PrintableDiagnostics` to `ProgressPrinter`, which are then evaluated and the results turned into a string via the function `pretty_diagnostic`. As for option 1 of using a logging package, perhaps it could be nice to use some logging functionality that's configurable with global variables (?) rather than manually creating a `ProgressPrinter` that does ""brute force"" printing as I have described above. However I think that it would require some customization of existing logging packages, since the typical `info` or `debug` settings are not sufficient for the purposes of logging simulation output (right?) Instead, we would need more options, and it'd be nice to obtain the ability to also print the output of diagnostics / monitoring functions, as we do in the example script. And I think doing it this way might involve adding some lines to our time stepping loop. Perhaps @ali-ramadhan has more to say. Another thing we have talked about is somehow having the ability to live-update messages in the terminal (rather than printing a stream of message). This would be nice because it could dramatically reduce the text-noise that a stream of messages invokes, allowing the user to much more easily read and interpret the output of a simulation progress (in addition to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:3265,config,configurable,3265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,2,"['config', 'variab']","['configurable', 'variables']"
Modifiability,"rsed_bc, velocities, tracers, clock, buoyancy); ```. This would allow the `immersed` boundary condition specified by the user to make its way into the tendency calculation. We think this might be simpler (in terms of the code) than passing `immersed_bc` into ` ∂ⱼ_τ₁ⱼ` (where we would throw it away unless we are on `ImmersedBoundaryGrid`.). Another advantage is that we can then isolate the code that calculates flux divergences for `Value` and `Gradient` (eg for no-slip boundary conditions), which could get a little complicated. I'm also trying to figure out if that would cover this case. I think we can use `ContinuousBoundaryCondition` for this kind of drag boundary condition. So in the user script we'd write something like. ```julia; u_drag(x, y, z, t, u, v, w, Cd) = - Cd * u * sqrt(u^2 + v^2 + w^2); v_drag(x, y, z, t, u, v, w, Cd) = - Cd * v * sqrt(u^2 + v^2 + w^2); w_drag(x, y, z, t, u, v, w, Cd) = - Cd * w * sqrt(u^2 + v^2 + w^2). u_immersed_bc = FluxBoundaryCondition(u_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); v_immersed_bc = FluxBoundaryCondition(v_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); w_immersed_bc = FluxBoundaryCondition(w_drag, parameters=Cd, field_dependencies=(:u, :v, :w)). u_boundary_conditions = FieldBoundaryConditions(immersed=u_immersed_bc); v_boundary_conditions = FieldBoundaryConditions(immersed=v_immersed_bc); w_boundary_conditions = FieldBoundaryConditions(immersed=w_immersed_bc); ```. and then under the hood, if we implement fluxes across immersed boundaries correctly, we'll get the right thing? Note the above code assumes that fluxes are along the ""inward facing normal"" --- one of the complications of the user API for this... The corresponding code for no-slip would be. ```julia; u_immersed_bc = ValueBoundaryCondition(0); v_immersed_bc = ValueBoundaryCondition(0); w_immersed_bc = ValueBoundaryCondition(0); ```. Should we work on adapting this PR in the direction of implementing such a user API? What do you recommend?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624:2389,adapt,adapting,2389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624,1,['adapt'],['adapting']
Modifiability,"ry\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zaG93X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `0.00% <0.00%> (ø)` | |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | `98.46% <ø> (ø)` | |; | [src/BoundaryConditions/boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9jb25kaXRpb24uamw=) | `72.72% <78.57%> (+16.47%)` | :arrow_up: |; | [test/test\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `97.86% <90.69%> (+6.95%)` | :arrow_up: |; | [...rc/BoundaryConditions/field\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWVsZF9ib3VuZGFyeV9jb25kaXRpb25zLmps) | `90.00% <93.33%> (+6.00%)` | :arrow_up: |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <100.00%> (ø)` | |; | ... and [13 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894?src=pr&el=footer). Last update [fbbb5f8...1503288](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/894#issuecomment-685006190:2983,parameteriz,parameterized,2983,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/894#issuecomment-685006190,1,['parameteriz'],['parameterized']
Modifiability,"s.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Center,Center,Face,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:38; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[21]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:17418,sandbox,sandbox,17418,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013,2,['sandbox'],['sandbox']
Modifiability,"sBashforth2] with y Periodic on vertically stretched grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Flat on vertically uniform grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo ; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Flat on vertically stretched grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5 ; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Periodic on vertically uniform grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Periodic on vertically stretched grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Flat on vertically uniform grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2063314232:2444,variab,variably,2444,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2063314232,1,['variab'],['variably']
Modifiability,"so one way to do this is to say `adapt(Array, A)` which then requires no knowledge where A was an Array or a CuArray or a complicated model.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/171#issuecomment-481430614:33,adapt,adapt,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/171#issuecomment-481430614,1,['adapt'],['adapt']
Modifiability,"solves to calling a function, whereas calling `getindex` on a `Field` / `Array` fetches data from memory. So they are different. Naively I would expect that evaluating a complicated advection term involving `BackgroundField` would be cheaper than one that involved two concrete `Array`. But sometimes unexpected things happen (the compiler might decide to optimize the code differently...). Can you try running the code on the GPU? I think it would be enlightening to see if there's a slowdown in that case. We could potentially implement an interface whereby `Field`s can be used as `BackgroundField` rather than functions. That might give us some insight, because then the ""additional"" advection terms associated with `BackgroundField` would truly be identical to the ""original"" advection term. > because presumably the advection of the background state by the background state is zero. I would say that the background self-interaction terms are _neglected_ rather than presumed to be zero. Linear terms associated with the background fields are also neglected. The idea being that if there is a valid way to decompose a flow into background and perturbation components, then the equation that governs the background component is completely neglected (this includes both the nonlinear terms and any linear terms involving the background flow). _Side note:_ some nonlinear terms are additionally neglected in the case of nonlinear viscosity. Ideally I think we would include these because the above argument doesn't justify neglecting them, but the implementation seemed too complicated the last time I thought about it so I put it off. I think it's a solvable problem but requires a bit of thought to integrate into the current algorithm seamlessly. > Mu understanding is that it is required for GPU runs, but it also helps optimize CPU runs. This is correct --- if you're missing a `const` on a variable that's used in a kernel, that kernel will fail to compile on the GPU (it won't just be slow).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623:2557,variab,variable,2557,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623,1,['variab'],['variable']
Modifiability,"sonally quite picky about specifying outputs and output file names, so I might always end up with verbose boilerplate for output writing (and I'm personally fine with that). But I'd support reducing boilerplate and maybe just a bit of flexibility would work even for picky people! I remember having this conversation in #1171 actually!. One-line flexible output writing would be especially great for examples, new user friendliness, and quick iteration. Some thoughts:; 1. I think the name `output!` is a bit vague in what it does. Does it just output the current state of the simulation? Would `add_output_writers!` be clearer and align more closely with existing Oceananigans nomenclature? For the same reason, I'd suggest keeping `add_callback!` over renaming to `callback!`.; 2. I frequently output both JLD2 and NetCDF versions of the exact same data. So ideally subsequent calls to `add_output_writers!` with `JLD2Format()` and `NetCDFFormat()` would add both.; 3. Would definitely support extending this to NetCDF as well!. > First, we need to default `with_halos=true` for JLD2OutputWriter. The time has come because `FieldTimeSeries` is mature. We do, in fact, want halos. Sounds good! Will be nice for derivatives to work by default. Although `FieldTimeSeries` could do with a bit more maturing, e.g. issues #3144 and #3750. > The other conundrum is `overwrite_existing` which is discussed on #3543. In short I am wondering whether the best course of action is simply to make default `overwrite_existing=true` and solve so much boilerplate. Is the ""so much boilerplate"" just the extra one line `overwrite_existing = true` for each output writer? Maybe I'm too conservative here but I think the default should be `overwrite_existing = false` just because the cost of overwriting and losing data can be very high. But I really like the suggestions in #3543 of having the option to save output in unique directories be easily specifiable. If we want an easy default, then maybe it could do som",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875:1059,extend,extending,1059,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875,1,['extend'],['extending']
Modifiability,"step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > ; > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. The pressure source term is the divergence of the predictor velocity divided by time-step. As the time-step vanishes, the divergence of the predictor velocity also vanishes (because the flow has not evolved from its previous, non-divergent solution). We get a situation tending to 0/0. I think there's a few things we could do to solve this. First of all if we take a very small time-step, I think we can actually just re-set the model time rather than taking a time-step. Second I am wondering if we want to implement a time type that has finite resolution (ie there is a smallest time increment one can take). For example, datetimes have a smallest unit (micro or nanoseconds). A non-dimensional or dimensional-agnostic time type could also be designed analogously (eg every time is the multiple of an integer by the fundamental unit). This would eliminate round off error but it's a bit of work and also we have to put some thought into how best to accomplish it. There might also be a simpler solution by adjusting how we increment time. I'm not sure. > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?. I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025:1091,evolve,evolved,1091,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025,1,['evolve'],['evolved']
Modifiability,"t place to start to justify changing the `Open` classification. > For example, in a nested case, this would prevent higher resolution eddies from exiting the domain without un-physically modifying the upstream solution. I apologize if this is just a problem with communication style, but I don't think this statement can possibly be correct. The above example seems to demonstrate, for example, that the cylinder wake can be represented well by _either_ making the domain large enough (with sponge layers), _or_ by using a better numerical method with a smaller domain. Basically this allows us to exclude statements like ""we can't model X flow"". The question is not whether or not we can represent the physics of a flow. The question is rather about representing the flow in a domain that is as small as possible / with optimal computational expense. We're pursuing performance optimization. Our language has to take the form ""this scheme allows us to reduce the sponge layer thickness by XX%"", or ""this scheme reduces the width of the near-boundary region where the interior physics are modified"". The statement ""this scheme does not unphysically modify the solution"" makes no sense to me. The presence of the open boundary is unphysical by definition... I personally don't need much convincing that a matching scheme of some kind is needed. I'm just confused about how all of the different pieces that seem to enter into nesting interact with one another --- sponge layers, matching scheme, and also the particular physics of the flow in question (idealized in and outflows vs true nesting). With so many degrees of freedom and complexity I think a systematic approach is absolutely essential. I really hope that the outcome of this work are a set of solid recommendations for nesting (better yet, a recipe that does not have to be changed --- a recommended matching scheme, or a combination of matching scheme and sponge layer) which is supported by unequivocal and rationally presented evidence.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291:2271,layers,layers,2271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291,1,['layers'],['layers']
Modifiability,"t regard the power method algorithm as predicated on a hypothesis (not an exact theory), which we provide empirical evidence for. This is one of the advantages of the power method that uses the full original system, I think, over more brute force approaches that forcefully remove nonlinear terms.; > ; > It is possible to replace the approx with an `=` and also include all of the nonlinear terms what one would get from the manipulations that lead to the equation for `Phi`. This is precisely what you would do if you were interested in continuing the asymptotic expansion _that linearization implies_ to investigate things like saturation, etc. So there's also a neat pedagogical power in the approx symbol in that it provides a hint for further learning and exploration of the mathematics of the system. I agree with **all** of the above. However, you missed one of my points... my disagreement was mostly of the phrasing. You suggested writing:. > Linear instabilities such as the Kelvin-Helmholtz instability, are described by equations of the form ∂_t Φ + L Φ ≈ 0 ... This statement is wrong --- that was my only objection. When accompanied with the messages you posted above it makes absolutely sense! But would you expect users to infer all these just from the ≈ symbol?. Reading your post made me think. I now suggest the following restructure (I'll present here a skeleton). - first discuss linear instabilities... the fact that Oceananigans.jl won't give you the linear operator but will evolve the full nonlinear system and the ""hack"" to get _approximately linear dynamics_ (I'll use ≈ here ;)) by utilizing `BackgroundFields`+**small amplitude**; - next discuss how we do eigenanalysis of the linear operator (without having the `L` in hand in the first place): here describe the power method and how we use the `simulation` of the ""approximately linear dynamics"" for `Δτ`described above as a way to ""apply `L`... How do you like this? (I'll work on this refactoring tomorrow probably.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282:2410,evolve,evolve,2410,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282,2,"['evolve', 'refactor']","['evolve', 'refactoring']"
Modifiability,"t; > writers as being logically separate from the main code. As a stand alone; > package, OceananigansOutput.jl doesn't do anything useful. Something like; > TurbulenceClosures.jl could though.; >; > Keeping things in tidy submodules within a single repository increases; > code visibility, which I think is important. When I see a package or; > framework spread across multiply small packages I find it hard to get an; > idea about what it can do.; >; > Another nice thing is we currently have ""unified versioning"" so when; > releases occur we know everything works together. We don't have to worry; > about running with Oceananigans v0.x with OceananigansPlotting v0.y and; > OceananigansOutput#master to fix some issue.; >; > From a development perspective, issues and pull requests are now spread; > across multiple repositories and we can end up with pull requests that; > depend on other pull requests in other repositories, e.g. when adding in; > halo regions the main code got refactored but so did the output writers and; > plotting code would change as well. We can also end up with multiple test; > suites that need to pass, plus possibly multiple CI pipelines to manage. So; > right now it's easy to make atomic changes that touch upon multiple pieces; > of code (and we'll probably be in this stage where we need to refactor; > frequently for a while).; >; > I also don't have to git clone a bunch of repositories just to work on a; > simple example.; >; > But this is getting off-topic.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/284?email_source=notifications&email_token=AA27DYA55SSJKHXQBFUSJDLP2OVODA5CNFSM4HXEYRJ2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODXXAHFI#issuecomment-502137749>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AA27DYEHNERHN4MHAGJQZH3P2OVODANCNFSM4HXEYRJQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502146049:1640,refactor,refactored,1640,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502146049,2,['refactor'],"['refactor', 'refactored']"
Modifiability,"th gravity tilted at 45 degrees; >; > [image: tilted_gravity_plume]; > <https://user-images.githubusercontent.com/20099589/100940093-5ab5d600-34c5-11eb-918e-f574f284f024.gif>; >; > This is an experimental feature since it needs more rigorous testing and; > because full support for tilted gravity may require more work, e.g.; >; > 1. Should AMD use z_dot_g_b now?; > 2. Should ∂x_b return a vector or should it be split up into x_dot_∂x_b,; > etc.? The Leith closure uses ∂x_b.; > 3. We may want to clean up and refactor the implementation, taking; > some suggestions from #1151; > <https://github.com/CliMA/Oceananigans.jl/issues/1151>.; >; > cc @tomchor <https://github.com/tomchor>; >; > Resolves #1151 <https://github.com/CliMA/Oceananigans.jl/issues/1151>; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1242; > Commit Summary; >; > - Make room for tuple gravity; > - Some `{x,y,z}_dot_g_b`; > - Tilted gravity plume sandbox; >; > File Changes; >; > - *A* sandbox/tilted_gravity_plume.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-9f5abd06fd694cf6f0d35019ea409e07e100a801fbfcd9a2a8d3737801a341b0>; > (53); > - *M* src/Buoyancy/Buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-55d14f16043b022b6a286fd9881d334208e6b6251d122555d3ede4014ea59e55>; > (10); > - *A* src/Buoyancy/gravitational_acceleration.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-bb73385a8b574af8f9b259bd480acf1bdd913e8969bb440833342c0fba3f1150>; > (7); > - *M* src/Buoyancy/linear_equation_of_state.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-f3c384915af5bdd55a7a9cb929dee20fcca1682630706def515ed65b5a3cb490>; > (42); > - *M* src/Buoyancy/seawater_buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-17b154b6d4fa0d986ee4ef99715cced4bc7eac3c93690c52239d83745090c334>; > (56); > - *M* src/Models/Incom",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819:1604,sandbox,sandbox,1604,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819,2,['sandbox'],['sandbox']
Modifiability,"thanks for the explanation. On Mon, Oct 12, 2020 at 8:25 PM Gregory L. Wagner <notifications@github.com>; wrote:. > Greg, Doesn't Ali have a version of immersed boundary layers going?; >; > @johncmarshall54 <https://github.com/johncmarshall54>, Ali experimented; > with a simple immersed boundary implemented via Oceananigans's user-defined; > forcing functions. The code is these 9 lines:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/a921fc3edbf795bf4a2193cca84cad41ebdd5625/verification/flow_around_cylinder/flow_around_cylinder.jl#L18-L27; >; > This implementation damps the velocity field to zero on a very fast; > time-scale (specified by the parameter K) within the immersed boundary.; > This is certainly a nice, simple immersed boundary implementation for; > Dirichlet / Value boundary conditions and could a good starting point.; > However, I also think there's some good reasons to pursue an alternate; > immersed boundary implementation to what @ali-ramadhan; > <https://github.com/ali-ramadhan> has done for the following reasons:; >; > 1. @ali-ramadhan <https://github.com/ali-ramadhan>'s implementation; > doesn't obviously extend to other boundary conditions, like prescribed; > gradients or fluxes (the latter being crucial for the geophysical problems; > we're interested in). So, even if we use a continuous forcing method; > similar to @ali-ramadhan <https://github.com/ali-ramadhan>'s; > implementation, we need to figure out how to enforce boundary conditions; > other than Dirichlet boundary conditions.; > 2. @ali-ramadhan <https://github.com/ali-ramadhan>'s implementation; > conforms exactly to the grid; however we would like to be able to model; > smoothly-varying boundaries.; > 3. As noted by @whitleyv <https://github.com/whitleyv>, @ali-ramadhan; > <https://github.com/ali-ramadhan>'s ""continuous forcing method""; > implementation introduces a time-step restriction due to the need to; > explicitly resolve the damping time-scale in the forcing function. It se",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707413052:170,layers,layers,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707413052,1,['layers'],['layers']
Modifiability,"the Redi tensor and GM for TwoDimensionalLeith so GM-Redi might; > not need too much extra work:; > https://github.com/CliMA/Oceananigans.jl/blob/master/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl; > Questions/proposal; >; > 1. Do we make the small-angle approximation? I would say yes.; >; > In Oceananigans.jl right now each component of the tensor diffusivity is; > calculated on-the-fly so the unapproximated tensor could end up being 2-4x; > more expensive to compute. We cannot compute the full tensor in one go; > (reusing the isopycnal slopes) and we may not want to since it takes up a; > lot of memory (9 extra field?). But maybe there's a good reason to not make; > the small-angle approximation? We could eventually support both; > (unapproximated and small-angle approximation).; >; > See; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#redi-scheme-isopycnal-diffusion; > for a comparison of the two.; >; > 1. Is GM-Redi the main parameterization of interest? Would people use; > the fully symmetric or the fully anti-symmetric diffusivity tensor by; > themselves?; >; > If not then maybe we can save some time by just implementing one new; > closure, GMRedi or GentMcWilliamsRedi. If we take the isopycnal; > diffusivity to be the same for both the symmetric and anti-symmetric tensor; > then we the resulting tensor is quite cheap to compute (only 3 components); > if performance is important:; >; > From; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#griffies-skew-flux; > [image: image]; > <https://user-images.githubusercontent.com/20099589/111556957-1abbeb80-8762-11eb-9fb3-870d447efa5f.png>; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1492>, or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQT2T2NK46W7G7ZS5ULTEFFH5ANCNFSM4ZLUCVJQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587:1871,parameteriz,parameterization,1871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587,1,['parameteriz'],['parameterization']
Modifiability,"these are if we want to make the particle velocity depend on other _eulerian_ fields (like forcing for our prognostic variables). An example can be the buoyancy field for buoyant particles. If we decide that that role can be undertaken by the `dynamics` kernel, we can remove the `i, j, k` from the signature. We should probably come up with a couple of examples to include in this PR that show the implementation of different particle dynamics. ; I would include:; - buoyant particles (sinking or rising with a density-dependent vertical velocity); - particles with drag",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852745078:118,variab,variables,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852745078,1,['variab'],['variables']
Modifiability,"this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect it might not be but it's worth a shot (you might learn something). . > Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. I guess that's sort of what we're doing here. The main issue is reducing boilerplate / making this as easy as possible. It'd be nice to write parameterizations with more abstract syntax rather than having to write a low-level kernel function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:2950,parameteriz,parameterizations,2950,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513,2,['parameteriz'],['parameterizations']
Modifiability,"this work if you have one spin up script and another script for the interesting part of the simulation that picks up from the checkpoint made at the end of spin up?. This is an interesting and I think common use case that's worth thinking about (cc @sandreza). The current mode, which I think works well, is to build a new model `restore_from_checkpoint` but reassigning some properties of model (as well as including the ones that couldn't be checkpointed). (Thinking about it more, we might almost rename `restore_from_checkpoint` to `IncompressibleModel`, since it sort of is an alternative constructor for `IncompressibleModel`...). If we deprecate `restore_from_checkpoint`, then users would be required to rebuild `IncompressibleModel` from scratch and use a function. ```julia; set!(model, checkpoint_filepath::String); ```. which would be implemented as part of the `pickup` feature we're discussing. I think this method has pros and cons over the ""constructor"" method:. ### Cons. 1. It generates boilerplate in user scripts, since the second script will inevitably reproduce much of the original ""spinup"" run script. 2. It wastes memory. ### Pro. 1. The setup script for the second simulation is easier to interpret, since its more ""stand-alone"", containing all the information necessary to understand basic aspects of the model configuration, like the grid, coriolis, buoyancy, etc. In other words, using `restore_from_checkpoint` ties two scripts together, since one cannot understand the script containing `restore_from_checkpoint` without looking at the script that produced the checkpoint in the first place. I think we can mitigate Con.1 by designing helper functions that restore individual model properties. Something like. ```julia; grid = restore(checkpoint_filepath, :grid); coriolis = restore(checkpoint_filepath, :coriolis); ```. (This kind of feature is important for post processing with the the other output writers too.). I guess we can't solve Con.1 without diluting Pro.1.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1068#issuecomment-711042722:1350,config,configuration,1350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068#issuecomment-711042722,1,['config'],['configuration']
Modifiability,"thub.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593. There may be other problems that we haven't uncovered. An important additional case that doesn't work right now is operations that have embedded `AveragedField`. I think this is some kind of type inference issue. For `Field` on the GPU we ""throw away"" the wrapper and expose the underlying `OffsetArray` to GPU kernels. So compilation of functions of `Field` is ""no more difficult"" than compilation of functions with `OffsetArray`. This idealization is successful because indexing into the underlying `field.data` is identical indexing into the field itself, and because we don't require field locations _inside_ the kernel (we build expression trees for AbstractOperations on the CPU, prior to launching the kernel). But this idealization doesn't hold for `AveragedField` or any `ReducedField`. In particular, abstract operations index into these objects at all `i, j, k`. However, they don't vary on one or more of these directions; the indexing operation needs to be ""collapsed"" so that reduced indices are translated correctly. Thus when we adapt `AveragedField` for the GPU, we hold onto the wrapper:. https://github.com/CliMA/Oceananigans.jl/blob/98cd4f7a56aa581defc721a01d6e1ab89b534d26/src/Fields/averaged_field.jl#L94-L96. Peeking at the broadcasting code used by julia Base gives a hint. Broadcasting has to solve the same problem: we have to be able to make computations between arrays of size (Nx, Ny, 1) and (Nx, Ny, Nz), for example. In this case, the indices of the first array are ""extruded"" into the third dimension. There are [some shenanigans in `Base.Broadcast`](https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630) that look like they are solving some type instability problem (which would doom GPU compilation for us if it were occurring). So we might be able to learn / borrow code from `Base.Broadcast`. All speculation from a naive julia programmer...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550:2531,adapt,adapt,2531,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550,1,['adapt'],['adapt']
Modifiability,"time-stepping loop in our wind mixing and convection example:. https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/examples/ocean_wind_mixing_and_convection.jl#L199. This printing produces a stream of messages during the simulation:. ```julia; julia> include(""ocean_wind_mixing_and_convection.jl""); i: 0010, t: 11.000 s, Δt: 1.100 s, wmax = 7.8e-04 ms⁻¹, wall time: 594.383 ms; i: 0020, t: 23.100 s, Δt: 1.210 s, wmax = 1.5e-03 ms⁻¹, wall time: 581.628 ms; i: 0030, t: 36.410 s, Δt: 1.331 s, wmax = 2.3e-03 ms⁻¹, wall time: 567.346 ms; i: 0040, t: 51.051 s, Δt: 1.464 s, wmax = 3.2e-03 ms⁻¹, wall time: 562.455 ms; i: 0050, t: 1.119 min, Δt: 1.611 s, wmax = 4.2e-03 ms⁻¹, wall time: 576.511 ms; i: 0060, t: 1.415 min, Δt: 1.772 s, wmax = 5.2e-03 ms⁻¹, wall time: 571.096 ms; ```. In this case, the information we decide to print is:. * iteration number `i`; * the simulation time `t`; * the time-step (because we are using adaptive time-stepping); * the maximum vertical velocity; * the elapsed wall time for time stepping *only* (not including plotting) between print messages. I think this issue is about a better way to achieve the printing of simulation progress. Two ideas are:. 1. Somehow use a logging package (though I'm not 100% what this would look like --- perhaps this means adding lines to our [time-stepping loop](https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/src/time_steppers.jl#L28)?; 2. Create some types that allow the user to more easily manage the printing of progress messages, expanding on the pattern used in our example. I've thought a bit about 2: I think a generic progress messenger would be both configurable but also include some comforting defaults. A simple way to start could be something like. ```julia; struct ProgressPrinter{DT, M, D}; Δt :: DT; model :: M; diagnostics :: D; end; ```. with some kind of print function, something like. ```julia; pretty_Δt(Δt::Number) =",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:1200,adapt,adaptive,1200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,1,['adapt'],['adaptive']
Modifiability,"tl;dr. 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.). 2. How do we feel about wrapping boundary conditions for immersed boundaries in `FieldBoundaryConditions` (this requires refactoring `FieldBoundaryConditions` under the hood, but does not change the API). We can do 2. without 1. In that case we'll be able to support a lot of common cases, including ordinary oceanic cases (where boundaries do not overhang, and we only specify drag on tangential components). It's really LES cases that become tricky because we can't specify drag on vertical velocity components, or on tangential components when the boundary overhangs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-867684689:625,refactor,refactoring,625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-867684689,1,['refactor'],['refactoring']
Modifiability,"ts closer than a; chosen distance from the upper boundary. John. On Mon, Nov 23, 2020, 8:35 PM Ali Ramadhan <notifications@github.com> wrote:. > Some pretty promising Lagrangian particle tracking benchmarks!; >; > Couple of takeaways (all assuming a model with 128^3 grid points and QAB2; > time stepping):; >; > 1. *Low overhead*: You can advect up to ~100,000 particles on the CPU; > and up to ~10,000,000 particles on a (Titan V) GPU before the model slows; > down by more than 30%.; > 2. *Great on GPUs*: Seems that the GPU is great for advecting millions; > of particles. You can advect ~100,000,000 particles and your model only; > slows down by a factor of 4x. In this scenario, the GPU is ~620x faster; > than a single CPU core.; > 3. Calculated using (t_100000000 - t_0) / 100000000, advecting a; > single particle on the CPU takes ~110 ns while on the GPU it only takes; > ~0.127 ns. This seems a little too good to be true but I'll double check; > this.; >; > I'll start refactoring this PR using @glwagner; > <https://github.com/glwagner>'s and @zhenwu0728; > <https://github.com/zhenwu0728>'s feedback, but I think it would be; > really great if we can keep this performance.; > Benchmarks; >; > Oceananigans v0.44.1; > Julia Version 1.5.2; > Commit 539f3ce943 (2020-09-23 23:17 UTC); > Platform Info:; > OS: Linux (x86_64-pc-linux-gnu); > CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; > WORD_SIZE: 64; > LIBM: libopenlibm; > LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); > GPU: TITAN V; >; > Lagrangian particle tracking benchmarks; > ┌───────────────┬─────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; > │ Architectures │ N_particles │ min │ median │ mean │ max │ memory │ allocs │; > ├───────────────┼─────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; > │ CPU │ 0 │ 361.749 ms │ 364.041 ms │ 364.293 ms │ 368.854 ms │ 293.44 KiB │ 1876 │; > │ CPU │ 1 │ 375.030 ms │ 376.591 ms │ 377.959 ms │ 385.248 ms │ 29",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982:1181,refactor,refactoring,1181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982,1,['refactor'],['refactoring']
Modifiability,"uildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:1705; [17] (::Pkg.Operations.var""#115#120""{Dict{String, Any}, Bool, Bool, Bool, Pkg.Operations.var""#130#134""{Bool, Cmd, Cmd, Nothing, Pkg.Types.Context, Vector{Tuple{String, Base.Process}}, String, Pkg.Types.PackageSpec}, Pkg.Types.Context, Pkg.Types.PackageSpec, String, Pkg.Types.Project, String})(tmp::String); @ Pkg.Operations /storage5/buildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:1794; [18] mktempdir(fn::Pkg.Operations.var""#115#120""{Dict{String, Any}, Bool, Bool, Bool, Pkg.Operations.var""#130#134""{Bool, Cmd, Cmd, Nothing, Pkg.Types.Context, Vector{Tuple{String, Base.Process}}, String, Pkg.Types.PackageSpec}, Pkg.Types.Context, Pkg.Types.PackageSpec, String, Pkg.Types.Project, String}, parent::String; prefix::String); @ Base.Filesystem ./file.jl:766; [19] mktempdir(fn::Function, parent::String); @ Base.Filesystem ./file.jl:762; [20] mktempdir; @ ./file.jl:762 [inlined]; [21] sandbox(fn::Function, ctx::Pkg.Types.Context, target::Pkg.Types.PackageSpec, target_path::String, sandbox_path::String, sandbox_project_override::Pkg.Types.Project; preferences::Dict{String, Any}, force_latest_compatible_version::Bool, allow_earlier_backwards_compatible_versions::Bool, allow_reresolve::Bool); @ Pkg.Operations /storage5/buildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:1752; [22] test(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing, force_latest_compatible_version::Bool, allow_earlier_backwards_compatible_versions::Bool, allow_reresolve::Bool); @ Pkg.Operations /storage5/buildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:1955; [23] test; @ /storage5/buildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:1899 [inlined]; [24] test(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; coverage::Bool, test_fn::Nothing, jul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988500458:5965,sandbox,sandbox,5965,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988500458,1,['sandbox'],['sandbox']
Modifiability,"underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_diffusivity.jl#L247-L248. If we introduce a new parameter, say `minimum_entrainment_buoyancy_frequency`, then we can modify this criteria to read. ```julia; convecting = N² < 0 # applies regardless of Qᵇ . N²_entrainment = minimum_entrainment_buoyancy_frequency; entraining = (N²_above < 0) & (N² > N²_entrainment) (Qᵇ > 0); ```. Now the user can determine `minimum_entrainment_buoyancy_frequency` to stabilize their model. Probably some default like `minimum_entrainment_buoyancy_frequency = 1e-7` would work for Earth-like situations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718:1618,parameteriz,parameterization,1618,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718,1,['parameteriz'],['parameterization']
Modifiability,"using the script . https://github.com/climate-machine/Oceananigans.jl/blob/631b861bcfdbfd894c4cb6b2257a16aa8c55f8cc/sandbox/simple_forcing.jl. on the branch `integrate-turbulence-closures` that is part of PR #245 , I get the following error:. ```; julia> include(""simple_forcing.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition recurse(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /data5/glwagner/.julia/packages/Cassette/xggAf/src/overdub.jl:521 overwritten in module GPUifyLoops at /data5/glwagner/.julia/packages/Cassette/xggAf/src/overdub.jl:521.; WARNING: Method definition overdub(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /data5/glwagner/.julia/packages/Cassette/xggAf/src/overdub.jl:508 overwritten in module GPUifyLoops at /data5/glwagner/.julia/packages/Cassette/xggAf/src/overdub.jl:508. CUDA-enabled GPU(s) detected:; CuDevice(0): Quadro P6000; [ Info: Building the CUDAnative run-time library for your sm_61 device, this might take a while...; ERROR: LoadError: InvalidIRError: compiling #12(RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}, PlanetaryConstants{Float64}, LinearEquationOfState{Float64}, Oceananigans.TurbulenceClosures.ConstantAnisotropicDiffusivity{Float64}, CUDAnative.CuDeviceArray{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496489468:116,sandbox,sandbox,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496489468,1,['sandbox'],['sandbox']
Modifiability,"utflow speed may have caused some confusion here as it is neither the specified outflowing velocity, the outflowing velocity at the boundary point, or the outflowing velocity in the interior, but an approximation of bulk velocity advecting the interior solution to the boundary point (and its approximation is case specific).**. The next problem is that if the interior solution is outflowing and then switches to inflow it may have deviated from the external solution causing oscillations near the boundary. This is why we might want relaxation rather than specifying as described before. . What I have been calling the ""inflow_speed"" is $1/\tau$ because I don't see why the ""relaxation"" should be fixed and the user might want to change it. For example it seems to me it would be reasonable to pretend that the specified external velocity is a further halo point and upwind it into the actual boundary point. I believe sponge layers are both a different solution to over-specifying at the boundary, and a way to dampen the residual reflection/oscillation from the unwinding approximation. In the first case, the sponge has to be large enough to fully restore the interior solution to the external solution before the boundary, but in the latter, it can be smaller (so having a complicated boundary saves computational expense). . > 2. Constant or idealized inflows and outflows. I think the only real difference for these idealised cases is that you normally know that information will only travel away from one of the boundaries and so can specify the halo point with `Open`. With both of the cases shown above we also know that the mean outflowing velocity will be the same as the inflow so can approximate the ""bulk velocity"" as a constant instead of having to compute it (but we still can't specify the boundary points of the outflow because otherwise, perturbations generated in the interior wouldn't be able to escape). The other difference in this case is that we don't know the external sol",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1980880295:2076,layers,layers,2076,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1980880295,1,['layers'],['layers']
Modifiability,"ution using Oceananigans, and then illustrate embedding a high resolution domain inside that solution. A two-dimensional turbulent case would be sufficient. > To resolve this PR I could tidy up a simple matching scheme where we compute the mean outflow on the boundary and do a 1D advection for the boundary point, or relax to the external state if there is inflow. I think this shows how to use all parts of the new infrastructure, and is a satisfactory boundary condition for some cases. Would this be okay?. A simple matching scheme is a great place to start to justify changing the `Open` classification. > For example, in a nested case, this would prevent higher resolution eddies from exiting the domain without un-physically modifying the upstream solution. I apologize if this is just a problem with communication style, but I don't think this statement can possibly be correct. The above example seems to demonstrate, for example, that the cylinder wake can be represented well by _either_ making the domain large enough (with sponge layers), _or_ by using a better numerical method with a smaller domain. Basically this allows us to exclude statements like ""we can't model X flow"". The question is not whether or not we can represent the physics of a flow. The question is rather about representing the flow in a domain that is as small as possible / with optimal computational expense. We're pursuing performance optimization. Our language has to take the form ""this scheme allows us to reduce the sponge layer thickness by XX%"", or ""this scheme reduces the width of the near-boundary region where the interior physics are modified"". The statement ""this scheme does not unphysically modify the solution"" makes no sense to me. The presence of the open boundary is unphysical by definition... I personally don't need much convincing that a matching scheme of some kind is needed. I'm just confused about how all of the different pieces that seem to enter into nesting interact with one anoth",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291:1300,layers,layers,1300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291,1,['layers'],['layers']
Modifiability,"uts are constructed appropriately now, but the outputs still can't be written to NetCDF because the writer creates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:1083,variab,variable,1083,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655,1,['variab'],['variable']
Modifiability,"veUtils]]; deps = [""Markdown""]; uuid = ""b77e0a4c-d291-57a0-90e8-8db25a27a240"". [[IteratorInterfaceExtensions]]; git-tree-sha1 = ""a3f24677c21f5bbe9d2a714f95dcd58337fb2856""; uuid = ""82899510-4779-5014-852e-03e436cf321d""; version = ""1.0.0"". [[JLD2]]; deps = [""DataStructures"", ""FileIO"", ""MacroTools"", ""Mmap"", ""Pkg"", ""Printf"", ""Reexport"", ""Requires"", ""TranscodingStreams"", ""UUIDs""]; git-tree-sha1 = ""d4962712594ec5d39e0b10745e44e3a06abec0d2""; uuid = ""033835bb-8acc-5ee8-8aae-3f567f8a3819""; version = ""0.4.4"". [[JLLWrappers]]; deps = [""Preferences""]; git-tree-sha1 = ""642a199af8b68253517b80bd3bfd17eb4e84df6e""; uuid = ""692b3bcd-3c85-4b1f-b108-f13ce0eb3210""; version = ""1.3.0"". [[JSON3]]; deps = [""Dates"", ""Mmap"", ""Parsers"", ""StructTypes"", ""UUIDs""]; git-tree-sha1 = ""65798ad6ddb0d7068f2b1885e0b0d876efca16f5""; uuid = ""0f8b85d8-7281-11e9-16c2-39a750bddbf1""; version = ""1.8.1"". [[KernelAbstractions]]; deps = [""Adapt"", ""CUDA"", ""Cassette"", ""InteractiveUtils"", ""MacroTools"", ""SpecialFunctions"", ""StaticArrays"", ""UUIDs""]; git-tree-sha1 = ""f16c8dfdd75ae4fa927fcf3aa71e1dbbd195befb""; uuid = ""63c18a36-062a-441e-b654-da1e3ab1ce7c""; version = ""0.5.5"". [[LLVM]]; deps = [""CEnum"", ""Libdl"", ""Printf"", ""Unicode""]; git-tree-sha1 = ""b616937c31337576360cb9fb872ec7633af7b194""; uuid = ""929cbde3-209d-540e-8aea-75f648917ca0""; version = ""3.6.0"". [[LazyArtifacts]]; deps = [""Pkg""]; git-tree-sha1 = ""4bb5499a1fc437342ea9ab7e319ede5a457c0968""; uuid = ""4af54fe1-eca0-43a8-85a7-787d91b784e3""; version = ""1.3.0"". [[LibCURL_jll]]; deps = [""LibSSH2_jll"", ""Libdl"", ""MbedTLS_jll"", ""Pkg"", ""Zlib_jll"", ""nghttp2_jll""]; git-tree-sha1 = ""897d962c20031e6012bba7b3dcb7a667170dad17""; uuid = ""deac9b47-8bc7-5906-a0fe-35ac56dc84c0""; version = ""7.70.0+2"". [[LibGit2]]; deps = [""Printf""]; uuid = ""76f85450-5226-5b5a-8eaa-529ad045b433"". [[LibSSH2_jll]]; deps = [""Libdl"", ""MbedTLS_jll"", ""Pkg""]; git-tree-sha1 = ""717705533148132e5466f2924b9a3657b16158e8""; uuid = ""29816b5a-b9ab-546f-933c-edad1886dfa8""; version = ""1.9.0+3"". [[Libdl]]; uuid = ""8f399da",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:7453,Adapt,Adapt,7453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,"verdub.jl:0; # I truncated the huge error message here; ```. However, the nested calculation appears to work!:. ```julia; julia> dwpdz_nested = nested_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── ComputedField located at (Center, Center, Face) of BinaryOperation at (Center, Center, Face); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); ├── operand: BinaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(dwpdz_nested). julia> using Adapt. julia> adapt(Array, interior(dwpdz_nested)); 1×512×8 view(OffsetArray(::Array{Float64,3}, 0:2, 0:513, 0:9), [1], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10 … 503, 504, 505, 506, 507, 508, 509, 510, 511, 512], [1, 2, 3, 4, 5, 6, 7, 8]) with eltype Float64:; [:, :, 1] =; 0.0262775 0.014948 0.00902569 0.00559831 0.00351427 0.00221792 0.00140318 0.000888719 … 0.000263472 0.000420913 0.000674128 0.00108572 0.00177041 0.00296775 0.00528696. [:, :, 2] =; 0.0156731 0.0110235 0.00720451 0.00461103 0.00293129 0.00185902 0.00117792 0.00074609 … 0.000915116 0.00144732 0.00229007 0.00362638 0.0057484 0.00911035 0.0143023. [:, :, 3] =; 0.00844536 0.00652392 0.00451369 0.00297425 0.00191676 0.00122263 0.000776137 0.000491594 … 0.00126331 0.00199147 0.00313408 0.00491472 0.00764863 0.0117137 0.0173591. [:, :, 4] =; 0.00263363 0.0021138 0.00150181 0.00100316 0.000649705 0.000414395 0.000262323 0.00016544 … 0.00117766 0.00185426 0.00291374 0.00455993 0.00707827 0.0108175 0.0160812. [:, :, 5] =; -0.002765",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:6088,Adapt,Adapt,6088,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011,1,['Adapt'],['Adapt']
Modifiability,"y=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced with min(Δz)=0.0106134, max(Δz)=0.12559. julia> . julia> . julia> const H_deep = H = underlying_grid.Lz; 2.9999999999999996. julia> const H_shelf = h = 0.5; 0.5. julia> const width_shelf = 100; 100. julia> . julia> shelf(x, y) = -(H + h)/2 - (H - h)/2 * tanh(y / width_shelf); shelf (generic function with 1 method). julia> bathymetry(x, y) = shelf(x, y); bathymetry (generic function with 1 method). julia> . julia> grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=-2.99e+00, max(h)=0.00e+00); ├── underlying_grid: 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced with min(Δz)=0.0106134, max(Δz)=0.12559. julia> u = XFaceField(grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0. julia> u = Field((Face, Center, Center), grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152:1435,variab,variably,1435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152,1,['variab'],['variably']
Modifiability,"you need to extend the same functions specifically for `scheme::AbstractUpwindBiasedAdvectionScheme` because of. https://github.com/CliMA/Oceananigans.jl/blob/74ce7d2248792560ea0c9286a3274c2dbacfabea/src/Advection/upwind_biased_reconstruction.jl#L92-L98. ```suggestion; @inline symmetric_interpolate_xᶠᵃᵃ(i, j, k, grid::XFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, c) = @inbounds c[i, j, k]; @inline symmetric_interpolate_yᵃᶠᵃ(i, j, k, grid::YFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, c) = @inbounds c[i, j, k]; @inline symmetric_interpolate_zᵃᵃᶠ(i, j, k, grid::ZFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, c) = @inbounds c[i, j, k]. @inline symmetric_interpolate_xᶜᵃᵃ(i, j, k, grid::XFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, u) = @inbounds c[i, j, k]; @inline symmetric_interpolate_yᵃᶜᵃ(i, j, k, grid::YFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, v) = @inbounds c[i, j, k]; @inline symmetric_interpolate_zᵃᵃᶜ(i, j, k, grid::ZFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, w) = @inbounds c[i, j, k]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1279818970:12,extend,extend,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1279818970,1,['extend'],['extend']
Modifiability,"y}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.julia/packages/CUDA/Tl08O/src/CUDAKernels.jl:103; [23] (::KernelAbstractions.Kernel{CUDA.CUDAKernels.CUDABackend, KernelAbstractions.NDIteration.StaticSize{…}, KernelAbstractions.NDIteration.StaticSize{…}, typeof(Oceananigans.BoundaryConditions.gpu__no_fill!)})(::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{…}}, ::Vararg{Any}); @ CUDA.CUDAKernels ~/.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2426,adapt,adapt,2426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,1,['adapt'],['adapt']
Modifiability,"~I've been getting the following error right at the end of docs on buildkite that I can't reproduce locally (and therefore have not been able to solve):~. ```julia; ┌ Error: 4 docstrings not included in the manual:; │ ; │ Oceananigans.TurbulenceClosures.Smagorinskys.DynamicCoefficient :: Union{Tuple{}, Tuple{Any}}; │ Oceananigans.TurbulenceClosures.Smagorinskys.SmagorinskyLilly :: Union{Tuple{}, Tuple{Any}, Tuple{Any, Any}}; │ Oceananigans.TurbulenceClosures.Smagorinskys.LillyCoefficient :: Union{Tuple{}, Tuple{Any}}; │ Oceananigans.TurbulenceClosures.Smagorinskys.Smagorinsky :: Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD; │ ; │ These are docstrings in the checked modules (configured with the modules keyword); │ that are not included in canonical @docs or @autodocs blocks.; └ @ Documenter /storage5/buildkite-agent/.julia-18496/packages/Documenter/C1XEF/src/utilities/utilities.jl:44; ```. ~Anyone know what that's about? Those are the 4 new docstrings that I added, all in the `Smagorinskys` module.~. Nevermind, it appears I have solved it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2449552734:689,config,configured,689,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2449552734,1,['config'],['configured']
Modifiability,~~~; (Oceananigans) pkg> status; Project Oceananigans v0.40.0; Status `/gpfs7kw/linkhome/rech/genbes01/use25mx/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v2.0.2; [052768ef] CUDA v1.3.3; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.2.4; [033835bb] JLD2 v0.1.14; [63c18a36] KernelAbstractions v0.4.0; [85f8d34a] NCDatasets v0.10.4; [6fe1bfb0] OffsetArrays v1.1.3; [bac558e1] OrderedCollections v1.3.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [90137ffa] StaticArrays v0.12.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics. shell> module list; Currently Loaded Modulefiles:; 1) cuda/10.2 2) julia/1.5.2 ; ~~~,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1035#issuecomment-707688295:153,Adapt,Adapt,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1035#issuecomment-707688295,1,['Adapt'],['Adapt']
Modifiability,"“face to edge” delta z must refer to an operation on an x-interface or; y-interface — not a z-interface to an edge?. On Sat, Mar 9, 2019 at 8:38 AM Ali Ramadhan <notifications@github.com>; wrote:. > Dispatching on the location as a parameterized type looks neat, would; > definitely clean things up! Thanks for coding up the example.; >; > I see how this would clean things up for δz_f2c and δz_e2f but the δz; > operator also needs to know onto which location to interpolate, so how; > would this work with δz_f2c and δz_f2e?; >; > @inline function δz_f2c(f, Nz, i, j, k); >; > if k == Nz; >; > @inbounds return f[i, j, k]; >; > else; >; > @inbounds return f[i, j, k] - f[i, j, k+1]; >; > end; > end; >; >; > @inline function δz_f2e(f, Nz, i, j, k); >; > if k == 1; >; > return 0; >; > else; >; > @inbounds return f[i, j, k-1] - f[i, j, k]; >; > end; > end; >; > To me it looks like they both fit; >; > δz(f::Field{Lx, Ly, Lz}, i, j, k) where {Lx, Ly, Lz<:Interface} = ...; >; > so I'm not sure how dispatch between the two.; >; > —; > You are receiving this because you were assigned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-471177715>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AOkIBkzcm1N5EI8VXyk1UgseDS6muPk9ks5vU7lYgaJpZM4bEKew>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-471178583:232,parameteriz,parameterized,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-471178583,1,['parameteriz'],['parameterized']
Modifiability,🕵️ https://github.com/JuliaGPU/Adapt.jl/pull/88,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445743138:31,Adapt,Adapt,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445743138,1,['Adapt'],['Adapt']
Performance," ######################################################################## 100.0%; &nbsp; | Building MPI ─→ `/storage7/buildkite-agent/.julia-2581/packages/MPI/b7MVG/deps/build.log`; &nbsp; | [ Info: using default MPI jll; &nbsp; | Building FFTW → `/storage7/buildkite-agent/.julia-2581/packages/FFTW/G3lSO/deps/build.log`; &nbsp; | Precompiling project...; &nbsp; | WARNING: Error during initialization of module GMP:; &nbsp; | ErrorException(""could not load library ""libgmp""; &nbsp; | libgmp.so: ELF load command past end of file""); &nbsp; | WARNING: Error during initialization of module LinearAlgebra:; &nbsp; | ErrorException(""could not load library ""libopenblas64_""; &nbsp; | libopenblas64_.so: ELF load command past end of file""); &nbsp; | ┌ Error: Error during initialization of module CHOLMOD; &nbsp; | │ exception =; &nbsp; | │ could not load library ""libcholmod""; &nbsp; | │ libopenblas64_.so.0: ELF load command past end of file; &nbsp; | │ Stacktrace:; &nbsp; | │ [1] dlopen(::String, ::UInt32; throw_error::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109; &nbsp; | │ [2] dlopen at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:951; &nbsp; | [2] unsafe_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:1005; &nbsp; | [3] write(::Base.PipeEndpoint, ::",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:2785,load,load,2785,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['load']
Performance," ./Base.jl:386; [2] include(x::String); @ Oceananigans.Models.ShallowWaterModels ~/software/Oceananigans.jl/src/Models/ShallowWaterModels/ShallowWaterModels.jl:1; [3] top-level scope; @ ~/software/Oceananigans.jl/src/Models/ShallowWaterModels/ShallowWaterModels.jl:15; [4] include(mod::Module, _path::String); @ Base ./Base.jl:386; [5] include(x::String); @ Oceananigans.Models ~/software/Oceananigans.jl/src/Models/Models.jl:1; [6] top-level scope; @ ~/software/Oceananigans.jl/src/Models/Models.jl:20; [7] include(mod::Module, _path::String); @ Base ./Base.jl:386; [8] include(x::String); @ Oceananigans ~/software/Oceananigans.jl/src/Oceananigans.jl:1; [9] top-level scope; @ ~/software/Oceananigans.jl/src/Oceananigans.jl:179; [10] include; @ ./Base.jl:386 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:16; in expression starting at /home/fpoulin/software/Oceananigans.jl/src/Models/ShallowWaterModels/ShallowWaterModels.jl:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/src/Models/Models.jl:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /home/fpoulin/.julia/compiled/v1.6/Oceananigans/jl_cnHalv.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _r",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-843316815:1568,load,loading,1568,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-843316815,1,['load'],['loading']
Performance," ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_zRopeZ"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/o",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:2933,Load,LoadError,2933,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['Load'],['LoadError']
Performance," /home/travis/.julia/packages/Cassette/1rVkq/src/overdub.jl:512.; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] top-level scope at none:2; [11] eval at ./boot.jl:328 [inlined]; [12] eval(::Expr) at ./client.jl:404; [13] top-level scope at ./none:3; in expression starting at /home/travis/.julia/packages/CuArrays/qZCAt/src/deprecated.jl:5; in expression starting at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:54; ERROR: LoadError: LoadError: LoadError: LoadError: UndefVarError: @setup not defined; Stacktrace:; [1] top-level scope; [2] #macroexpand#35 at ./expr.jl:107 [inlined]; [3] macroexpand at ./expr.jl:106 [inlined]; [4] docm(::LineNumberNode, ::Module, ::Any, ::Any, ::Bool) at ./docs/Docs.jl:509 (repeats 2 times); [5] @doc(::LineNumberNode, ::Module, ::String, ::Vararg{Any,N} where N) at ./boot.jl:459; [6] include at ./boot.jl:326 [inlined]; [7] include_relative(::Module, ::String) at ./loading.jl:1038; [8] include at ./sysimg.jl:29 [inlined]; [9] include(::String) at /home/travis/build/climate-machine/Oceananigans.jl/src/Oceananigans.jl:1; [10] top-level scope at none:0; [11] include at ./boot.jl:326 [inlined]; [12] include_relative(::Module, ::String) at ./loading.jl:1038; [13] include(::Module, ::String) at ./sysimg.jl:29; [14] top-level scope at none:2; [15] eval at ./boot.jl:328 [inlined]; [16] eval(::Expr) at ./client.jl:404; [17] top-level scope at ./none:3; in expression starting at /home/travis/build/climate-machine/Oceananigans.jl/src/poisson_solv",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/153#issuecomment-477579168:3477,Load,LoadError,3477,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/153#issuecomment-477579168,4,['Load'],['LoadError']
Performance," 35.4428 │ 450.0 │ 224.5 │; │ 256 │ (Bounded, Periodic, Bounded) │ 36.8697 │ 368.4 │ 320.5 │; │ 256 │ (Periodic, Bounded, Bounded) │ 37.0953 │ 369.6 │ 323.5 │; │ 256 │ (Periodic, Periodic, Bounded) │ 53.4034 │ 179.0 │ 146.0 │; └─────┴───────────────────────────────┴─────────┴────────┴────────┘; ```. ### CPU relative performance. ```; FFT-based Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.61224 │ 1.2 │ 2.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.34917 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.35141 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴────────┴────────┘; ```. ### GPU relative performance. ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 2.42923 │ 3.01676 │ 3.07534 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.95419 │ 2.0581 │ 2.19521 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.94553 │ 2.0648 │ 2.21575 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴─────────┴─────────┘; ```. ---. ## System info. ```; Oceananigans v0.50.0; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23:17 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); GPU: TITAN V; `",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:12412,perform,performance,12412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050,1,['perform'],['performance']
Performance, : 3; Device Max : 3; Host Max : 3; Link Width; Max : 16x; Current : 16x; Bridge Chip; Type : N/A; Firmware : N/A; Replays Since Reset : 0; Replay Number Rollovers : 0; Tx Throughput : 0 KB/s; Rx Throughput : 0 KB/s; Atomic Caps Inbound : N/A; Atomic Caps Outbound : N/A; Fan Speed : N/A; Performance State : P0; Clocks Throttle Reasons; Idle : Active; Applications Clocks Setting : Not Active; SW Power Cap : Not Active; HW Slowdown : Not Active; HW Thermal Slowdown : Not Active; HW Power Brake Slowdown : Not Active; Sync Boost : Not Active; SW Thermal Slowdown : Not Active; Display Clock Setting : Not Active; FB Memory Usage; Total : 32768 MiB; Reserved : 267 MiB; Used : 0 MiB; Free : 32500 MiB; BAR1 Memory Usage; Total : 32768 MiB; Used : 2 MiB; Free : 32766 MiB; Compute Mode : Default; Utilization; Gpu : 0 %; Memory : 0 %; Encoder : 0 %; Decoder : 0 %; Encoder Stats; Active Sessions : 0; Average FPS : 0; Average Latency : 0; FBC Stats; Active Sessions : 0; Average FPS : 0; Average Latency : 0; Ecc Mode; Current : Enabled; Pending : Enabled; ECC Errors; Volatile; Single Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : N/A; Total : 0; Double Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : 0; Total : 0; Aggregate; Single Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : N/A; Total : 0; Double Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : 0; Total : 0; Retired Pages; Single Bit ECC : 0; Double Bit ECC : 0; Pending Page Blacklist : No; Remapped Rows : N/A; Temperature; GPU Current Temp : 41 C; GPU Shutdown Temp : 90 C; GPU Slowdown Temp : 87 C; GPU Max Operating Temp : 83 C; GPU Target Temperature : N/A; Memory Current Temp : 44 C; Memory Max Operating Temp : 85 C; Power Readings; Powe,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:21269,Latency,Latency,21269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Latency'],['Latency']
Performance," ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there may not be a need for using explicit dissipation right now, so we might as well do the easy thing and avoid it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226:1624,perform,perform,1624,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226,1,['perform'],['perform']
Performance," <td style = ""text-align: right; "">1.37815</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">192</td>; <td style = ""text-align: right; "">(Periodic, Periodic, Bounded)</td>; <td style = ""text-align: right; "">1.10985</td>; <td style = ""text-align: right; "">1.12536</td>; <td style = ""text-align: right; "">1.12605</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">192</td>; <td style = ""text-align: right; "">(Periodic, Periodic, Periodic)</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; </table>. <table>; <caption style = ""text-align: center; "">Topologies relative performance (GPU)</caption>; <tr class = ""header headerLastRow"">; <th style = ""text-align: right; "">Architectures</th>; <th style = ""text-align: right; "">Ns</th>; <th style = ""text-align: right; "">Topologies</th>; <th style = ""text-align: right; "">slowdown</th>; <th style = ""text-align: right; "">memory</th>; <th style = ""text-align: right; "">allocs</th>; </tr>; <tr>; <td style = ""text-align: right; "">GPU</td>; <td style = ""text-align: right; "">192</td>; <td style = ""text-align: right; "">(Periodic, Bounded, Bounded)</td>; <td style = ""text-align: right; "">2.67701</td>; <td style = ""text-align: right; "">1.31634</td>; <td style = ""text-align: right; "">1.36185</td>; </tr>; <tr>; <td style = ""text-align: right; "">GPU</td>; <td style = ""text-align: right; "">192</td>; <td style = ""text-align: right; "">(Periodic, Periodic, Bounded)</td>; <td style = ""text-align: right; "">1.10911</td>; <td style = ""text-align: right; "">1.1314</td>; <td style = ""text-align: right; "">1.13269</td>; </tr>; <tr>; <td style = ""text-align: right; "">GPU</td>; <td style = ""text-align: right; "">192</td>; <td style = ""text-align: right; "">(Periodic, Periodic, Periodic)</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; <t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594:15242,perform,performance,15242,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594,1,['perform'],['performance']
Performance," <td style = ""text-align: right; "">14.9961</td>; <td style = ""text-align: right; "">2.60208</td>; <td style = ""text-align: right; "">3.56557</td>; </tr>; <tr>; <td style = ""text-align: right; "">Float64</td>; <td style = ""text-align: right; "">128</td>; <td style = ""text-align: right; "">79.6534</td>; <td style = ""text-align: right; "">2.89207</td>; <td style = ""text-align: right; "">3.56876</td>; </tr>; <tr>; <td style = ""text-align: right; "">Float64</td>; <td style = ""text-align: right; "">256</td>; <td style = ""text-align: right; "">108.399</td>; <td style = ""text-align: right; "">3.46246</td>; <td style = ""text-align: right; "">3.5645</td>; </tr>; </table>. ## Topologies benchmarks. <table>; <caption style = ""text-align: center; "">Topologies relative performance (CPU)</caption>; <tr class = ""header headerLastRow"">; <th style = ""text-align: right; "">Architectures</th>; <th style = ""text-align: right; "">Ns</th>; <th style = ""text-align: right; "">Topologies</th>; <th style = ""text-align: right; "">slowdown</th>; <th style = ""text-align: right; "">memory</th>; <th style = ""text-align: right; "">allocs</th>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">192</td>; <td style = ""text-align: right; "">(Periodic, Bounded, Bounded)</td>; <td style = ""text-align: right; "">1.26896</td>; <td style = ""text-align: right; "">1.27649</td>; <td style = ""text-align: right; "">1.37815</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">192</td>; <td style = ""text-align: right; "">(Periodic, Periodic, Bounded)</td>; <td style = ""text-align: right; "">1.10985</td>; <td style = ""text-align: right; "">1.12536</td>; <td style = ""text-align: right; "">1.12605</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">192</td>; <td style = ""text-align: right; "">(Periodic, Periodic, Periodic)</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; <",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594:13866,perform,performance,13866,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594,1,['perform'],['performance']
Performance," <td style = ""text-align: right; "">2.05742</td>; <td style = ""text-align: right; "">1.02812</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">GPU</td>; <td style = ""text-align: right; "">UpwindBiasedThirdOrder</td>; <td style = ""text-align: right; "">1.47568</td>; <td style = ""text-align: right; "">1.02677</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">GPU</td>; <td style = ""text-align: right; "">WENO5</td>; <td style = ""text-align: right; "">3.04361</td>; <td style = ""text-align: right; "">1.02812</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; </table>. ## Arbitrary tracers benchmarks. <table>; <caption style = ""text-align: center; "">Arbitrary tracers relative performance (CPU)</caption>; <tr class = ""header headerLastRow"">; <th style = ""text-align: right; "">Architectures</th>; <th style = ""text-align: right; "">Ns</th>; <th style = ""text-align: right; "">tracers</th>; <th style = ""text-align: right; "">slowdown</th>; <th style = ""text-align: right; "">memory</th>; <th style = ""text-align: right; "">allocs</th>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">128</td>; <td style = ""text-align: right; "">(0, 0)</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">128</td>; <td style = ""text-align: right; "">(0, 1)</td>; <td style = ""text-align: right; "">1.19815</td>; <td style = ""text-align: right; "">1.18011</td>; <td style = ""text-align: right; "">1.1898</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">128</td>; <td style = ""text-align: right; "">(0, 2)</td>; <td style = ""text-align: right; "">1.36597</td>; <td style = ""text-align: right; "">1.43581</td>; <td style = ""text-align: right; "">1.4021</td>; </tr>; <tr>; <t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594:3506,perform,performance,3506,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594,1,['perform'],['performance']
Performance," @navidcy experienced with FourierFlows.jl -- did you get this resolved? Looks to be happening on 1.3+. Backtrace from GDB:. ```; (gdb) bt; #0 0x00007f5e2a4626d6 in do_futex_wait.constprop () from target:/lib/x86_64-linux-gnu/libpthread.so.0; #1 0x00007f5e2a4627c8 in __new_sem_wait_slow.constprop.0 () from target:/lib/x86_64-linux-gnu/libpthread.so.0; #2 0x00007f5debf04b42 in lock_planner_mutex () from target:/builds/JuliaGPU/Oceananigans-jl/.julia/artifacts/e40697527cebb56d421346210295905df6e421dc/lib/libfftw3.so; #3 0x00007f5debdf3ae7 in fftw_destroy_plan () from target:/builds/JuliaGPU/Oceananigans-jl/.julia/artifacts/e40697527cebb56d421346210295905df6e421dc/lib/libfftw3.so; #4 0x00007f5d470b48c7 in ?? (); #5 0x00007f5d47fff8a8 in ?? (); #6 0x00007f5e2ab310cc in _jl_invoke (world=27509, mfunc=<optimized out>, nargs=1, args=0x7f5d47fff8a8, F=0x7f5e1a1c80e0) at /buildworker/worker/package_linux64/build/src/gf.c:2144; #7 jl_apply_generic (F=<optimized out>, args=args@entry=0x7f5d47fff8a8, nargs=nargs@entry=1) at /buildworker/worker/package_linux64/build/src/gf.c:2328; #8 0x00007f5e2ab7a9bf in jl_apply (nargs=2, args=0x7f5d47fff8a0) at /buildworker/worker/package_linux64/build/src/julia.h:1695; #9 run_finalizer (o=0x7f5dc6ae1210, ff=0x7f5e1a1c80e0, ptls=0x7f5e2b4794a0) at /buildworker/worker/package_linux64/build/src/gc.c:277; #10 0x00007f5e2ab7b500 in jl_gc_run_finalizers_in_list (ptls=ptls@entry=0x7f5e2b4794a0, list=list@entry=0x7f5d47fffa10) at /buildworker/worker/package_linux64/build/src/gc.c:363; #11 0x00007f5e2ab83885 in run_finalizers (ptls=0x7f5e2b4794a0) at /buildworker/worker/package_linux64/build/src/gc.c:391; #12 jl_gc_collect (collection=JL_GC_INCREMENTAL) at /buildworker/worker/package_linux64/build/src/gc.c:3128; #13 0x00007f5e0e8477a7 in ?? (); #14 0x00007f5e0e847730 in ?? (); #15 0x00007f5decb6e760 in ?? (); #16 0x00007f5e2b4794a0 in ?? (); #17 0x00007f5d47fffdb8 in ?? (); #18 0x00007f5e2b4794a0 in ?? (); #19 0x00007f5ded987590 in ?? (); #20 0x00007f",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/636#issuecomment-589245137:990,optimiz,optimized,990,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/636#issuecomment-589245137,1,['optimiz'],['optimized']
Performance," AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:86 [inlined]; [11] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:129; [12] codegen; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:110 [inlined]; [13] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:106; [14] compile; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:98 [inlined]; [15] #40; @ ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:140 [inlined]; [16] JuliaContext(f::AMDGPU.Compiler.var""#40#41""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:47; [17] hipcompile(job::GPUCompiler.CompilerJob); @ AMDGPU.Compiler ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:139; [18] actual_compilation(cache::Dict{Any, AMDGPU.H",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:1827,optimiz,optimize,1827,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,2,['optimiz'],['optimize']
Performance," D] + \delta_j V}^i \right)\frac{\boldsymbol{i}}{b_u} +v\left( \overline{ \delta_i U + [\delta_j V; D] }^j \right)\frac{\boldsymbol{j}}{b_v}$; - kinetic energy gradient: $\left(\overline{[\delta_i u^2; u]}^i + \delta_i \overline{v^2}^j \right)\frac{\boldsymbol{i}}{\Delta x_u} + \left(\delta_j \overline{u^2}^i + \overline{[\delta_j v^2; v]}^j\right) \frac{\boldsymbol{j}}{\Delta y_v}$. #### `CrossAndSelfUpwinding`. - divergence flux: $u \overline{[D; D]}^i \frac{\boldsymbol{i}}{b_u}+ v \overline{ [D; D] }^j\frac{\boldsymbol{j}}{b_v}$; - kinetic energy gradient: $\left(\overline{[\delta_i u^2; u]}^i + \delta_i \overline{v^2}^j\right) \frac{\boldsymbol{i}}{\Delta x_u} + \left(\delta_j \overline{u^2}^i + \overline{[\delta_j v^2; v]}^j\right) \frac{\boldsymbol{j}}{\Delta y_v}$. #### `VelocityUpwinding`. - divergence flux: $u \left( \delta_i \overline{[U; U]}^i + \overline{\delta_j V}^i \right)\frac{\boldsymbol{i}}{b_u}+ v\left( \overline{ \delta_i U} + \delta_j\overline{[V; V] }^j \right) \frac{\boldsymbol{j}}{b_v}$; - kinetic energy gradient: $\left(\delta_i \overline{[u^2; u^2]}^i + \delta_i \overline{v^2}^j\right)\frac{\boldsymbol{i}}{\Delta x_u}+ \left(\delta_j \overline{u^2}^i + \delta_j \overline{[v^2; v^2]}^j\right) \frac{\boldsymbol{j}}{\Delta y_v}$. #### For all three formulations; - vertical advection: $\delta_k \left(\overline{W}^i \overline{[u; u]}^k \right)\frac{\boldsymbol{i}}{b_u} + \delta_k \left( \overline{W}^j \overline{[v; v]}^k\right) \frac{\boldsymbol{j}}{b_v}$. where $D = \delta_i U + \delta_j V$, $U = Ax \cdot u$, $V = Ay \cdot v$, $W = Az \cdot w$ and $b = \Delta x \cdot \Delta y \cdot \Delta z$. $[u; v]$ refers to a WENO biased reconstruction of $u$ using $v$ as a smoothness measure. Upwinding is always performed with respect to the velocity corresponding to the reconstruction direction. ; i.e.: reconstructions in $i$ upwind with respect to $u$, reconstructions in $j$ upwind with respect to $v$ and reconstructions in $k$ upwind with respect to $w$",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1577285777:1925,perform,performed,1925,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1577285777,1,['perform'],['performed']
Performance," PDE in a user's model, and there's no way to pull out intermediate steps in that calculation to use elsewhere. It's important to note when considering optimization strategies that our computations are probably memory-limited, rather than compute-limited. In other words, we think the process of transferring data from global memory to local thread memory is a bottleneck for our computations (we can really only know this through profiling a particular application, however, since all models are different...) Storing intermediate components of the tendency terms would probably create more memory accesses overall (since rather than immediately using intermediate results for subsequent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField`s are fused into one, we overlap memory accesses for different computations. Our computations are usually memory-limited... so its possible this strategy could produce significant speed ups. For example, for two `ComputedField`s we might have something like. ```julia; function compute!(field1, field2); # calls _compute_two(field1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:1411,optimiz,optimization,1411,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837,1,['optimiz'],['optimization']
Performance," Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: LoadError: LoadError: UndefVarError: NFBC not defined; Stacktrace:; [1] top-level scope; @ ~/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; [2] include(mod::Module, _path::String); @ Base ./Base.jl:386; [3] include(x::String); @ Oceananigans.BoundaryConditions ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; [4] top-level scope; @ ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:45; [5] include(mod::Module, _path::String); @ Base ./Base.jl:386; [6] include(x::String); @ Oceananigans ~/Research/OC/src/Oceananigans.jl:1; [7] top-level scope; @ ~/Research/OC/src/Oceananigans.jl:173; [8] include; @ ./Base.jl:386 [inlined]; [9] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1213; [10] top-level scope; @ none:1; [11] eval; @ ./boot.jl:360 [inlined]; [12] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [13] top-level scope; @ none:1; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; in expression starting at /Users/navid/Research/OC/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_fSB7qw.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334:1840,load,loading,1840,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334,5,['load'],['loading']
Performance," [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1235; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:360 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [19] top-level scope; @ none:1; during initialization of module AMGX; in expression starting at /Users/navid/Research/OC.jl/src/Solvers/multigrid_so",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:2433,load,loading,2433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987,1,['load'],['loading']
Performance," [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1235; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:360 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [19] top-level scope; @",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:2308,load,loading,2308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987,1,['load'],['loading']
Performance," [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] top-level scope at none:2; [11] eval at ./boot.jl:328 [inlined]; [12] eval(::Expr) at ./client.jl:404; [13] top-level scope at ./none:3; in expression starting at /home/travis/.julia/packages/CuArrays/qZCAt/src/deprecated.jl:5; in expression starting at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:54; ERROR: LoadError: LoadError: LoadError: LoadError: UndefVarError: @setup not defined; Stacktrace:; [1] top-level scope; [2] #macroexpand#35 at ./expr.jl:107 [inlined]; [3] macroexpand at ./expr.jl:106 [inlined]; [4] docm(::LineNumberNode, ::Module, ::Any, ::Any, ::Bool) at ./docs/Docs.jl:509 (repeats 2 times); [5] @doc(::LineNumberNode, ::Module, ::String, ::Vararg{Any,N} where N) at ./boot.jl:459; [6] include at ./boot.jl:326 [inlined]; [7] include_relative(::Module, ::String) at ./loading.jl:1038; [8] include at ./sysimg.jl:29 [inlined]; [9] include(::String) at /home/travis/build/climate-machine/Oceananigans.jl/src/Oceananigans.jl:1; [10] top-level scope at none:0; [11] include at ./boot.jl:326 [inlined]; [12] include_relative(::Module, ::String) at ./loading.jl:1038; [13] include(::Module, ::String) at ./sysimg.jl:29; [14] top-level scope at none:2; [15] eval at ./boot.jl:328 [inlined]; [16] eval(::Expr) at ./client.jl:404; [17] top-level scope at ./none:3; in expression starting at /home/travis/build/climate-machine/Oceananigans.jl/src/poisson_solvers.jl:173; in expression starting at /home/travis/build/climate-machine/Oceananigans.jl/src/poisson_solvers.jl:171; in expression starting at /home/travis/build/climate-machine/Oceananigans.jl/src/poisson_solvers.jl:171; in expression starting at /home/travis/build/climate-machine/Oceananigans.jl/src/Oceananigans.jl:149; ERROR: LoadError: Failed to precompile Oceananigans [6e00b360-fae3-11e8-3922-3d7cb9e50aad] to /home",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/153#issuecomment-477579168:3958,load,loading,3958,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/153#issuecomment-477579168,1,['load'],['loading']
Performance," [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/Oceananigans/jl_k7YOZN"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:5530,Load,LoadError,5530,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['Load'],['LoadError']
Performance," `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI>; > .; > You are receiving this because you commented.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098:1085,load,loading,1085,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098,3,['load'],['loading']
Performance," ```; ERROR: LoadError: Enzyme cannot deduce type; Current scope:; ; Function Attrs: mustprogress nofree readonly willreturn; define ""enzyme_type""=""{[0]:Integer, [1]:Integer, [2]:Integer, [3]:Integer, [4]:Integer, [5]:Integer, [6]:Integer, [7]:Integer, [8]:Integer, [9]:Integer, [10]:Integer, [11]:Integer, [12]:Integer, [13]:Integer, [14]:Integer, [15]:Integer, [16]:Integer, [17]:Integer, [18]:Integer, [19]:Integer, [20]:Integer, [21]:Integer, [22]:Integer, [23]:Integer, [24]:Integer, [25]:Integer, [26]:Integer, [27]:Integer, [28]:Integer, [29]:Integer, [30]:Integer, [31]:Integer, [32]:Integer, [33]:Integer, [34]:Integer, [35]:Integer, [36]:Integer, [37]:Integer, [38]:Integer, [39]:Integer, [40]:Integer, [41]:Integer, [42]:Integer, [43]:Integer, [44]:Integer, [45]:Integer, [46]:Integer, [47]:Integer, [48]:Float@double, [56]:Float@double, [64]:Float@double, [72]:Float@double, [80]:Float@double, [88]:Float@double, [96]:Float@double, [104]:Float@double, [112]:Float@double, [120]:Integer, [121]:Integer, [122]:Integer, [123]:Integer, [124]:Integer, [125]:Integer, [126]:Integer, [127]:Integer, [128]:Integer, [129]:Integer, [130]:Integer, [131]:Integer, [132]:Integer, [133]:Integer, [134]:Integer, [135]:Integer, [136]:Integer, [137]:Integer, [138]:Integer, [139]:Integer, [140]:Integer, [141]:Integer, [142]:Integer, [143]:Integer, [144]:Float@double, [152]:Float@double, [160]:Float@double, [168]:Float@double, [176]:Integer, [177]:Integer, [178]:Integer, [179]:Integer, [180]:Integer, [181]:Integer, [182]:Integer, [183]:Integer, [184]:Integer, [185]:Integer, [186]:Integer, [187]:Integer, [188]:Integer, [189]:Integer, [190]:Integer, [191]:Integer, [192]:Integer, [193]:Integer, [194]:Integer, [195]:Integer, [196]:Integer, [197]:Integer, [198]:Integer, [199]:Integer, [200]:Float@double, [208]:Float@double, [216]:Float@double, [224]:Float@double, [232]:Float@double, [240]:Float@double, [248]:Integer, [249]:Integer, [2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436402140:78,Load,LoadError,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436402140,1,['Load'],['LoadError']
Performance," allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 1.34309 │ 1.46266 │ 1.48014 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 1.25281 │ 1.30927 │ 1.30084 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 1.05249 │ 1.30927 │ 1.30084 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 1.07645 │ 1.14247 │ 1.08664 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 1.0409 │ 1.30927 │ 1.30084 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 0.938853 │ 1.14247 │ 1.08664 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 1.17749 │ 1.14247 │ 1.08664 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. ## GPU slowdown (vs. triply-periodic). ```; Topologies relative performance (GPU); ┌───────────────┬─────┬────────────────────────────────┬──────────┬──────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼──────────┼─────────┤; │ GPU │ 192 │ (Bounded, Bounded, Bounded) │ 2.22277 │ 0.965821 │ 1.70133 │; │ GPU │ 192 │ (Bounded, Bounded, Periodic) │ 1.82308 │ 0.980729 │ 1.496 │; │ GPU │ 192 │ (Bounded, Periodic, Bounded) │ 1.82349 │ 0.984497 │ 1.4736 │; │ GPU │ 192 │ (Bounded, Periodic, Periodic) │ 2.26462 │ 0.989389 │ 1.24018 │; │ GPU │ 192 │ (Periodic, Bounded, Bounded) │ 1.82237 │ 0.984695 │ 1.47467 │; │ GPU │ 192 │ (Periodic, Bounded, Periodic) │ 1.54676 │ 0.992331 │ 1.25653 │; │ GPU │ 192 │ (Periodic, Periodic, Bounded) │ 1.30183 │ 0.99405 │ 1.22631 │; │ GPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴──────────┴─────────┘; ```. # Performance vs. main branch. ## Main branch. ```; Topologies benchmarks; ┌───────────────┬─────┬────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬─",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:9976,perform,performance,9976,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296,1,['perform'],['performance']
Performance," based on latitude easily.; > ; > Questions:; > ; > * Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); > * I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?. For API this is what I suggest:. Three ""modes"":. 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). The code might look something like. ```julia; zero_if_nothing(f) = f; zero_if_nothing(::Nothing) = 0. function ConstantBackgroundRotation(FT=Float64; fx=nothing, fy=nothing, fz=nothing, rotation_rate=Ω_Earth, rotation_axis=nothing, latitude=nothing). if latitude !=nothing; isnothing(rotation_axis) && throw(ArgumentError(""Cannot specify latitude and rotation axis."")); all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify latitude and (fx, fy, fz)."")); # calculate rotation axis; end. if rotation_axis != nothing; all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify rotation_axis and (fx, fy, fz)."")); # calculate fx, fy, fz; end. fx, fy, fz = zero_if_nothing.((fx, fy, fz)) # set default fx, fy, fz. return ConstantBackgroundRotation(FT(fx), FT(fy), FT(fz)); end; ```. There's also the possibility of a somewhat minor optimization by keeping the possibility that `fx, fy, fz` might be `nothing`, and eliding the associated Coriolis operations in kernel functions for that case. This requires the struct to accomodate different types for each of them. I think `GeneralFPlane` is ambiguous, so I propose using a more specific name.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990:2335,optimiz,optimization,2335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990,1,['optimiz'],['optimization']
Performance," example:. ```julia; julia> a, b, c = (CenterField(GPU(), grid) for i = 1:3); Base.Generator{UnitRange{Int64}, var""#5#6""}(var""#5#6""(), 1:3). julia> @time a .= b + c; 0.929868 seconds (180.70 k allocations: 11.424 MiB, 99.79% compilation time). julia> @time a .= b + c; 0.924904 seconds (159.14 k allocations: 10.031 MiB, 99.79% compilation time); ```. Note that if we avoid constructing an `AbstractOperation` we get. ```julia; julia> @time a .= b .+ c; 1.339598 seconds (2.24 M allocations: 127.662 MiB, 2.91% gc time, 47.98% compilation time). julia> @time a .= b .+ c; 0.000280 seconds (180 allocations: 41.109 KiB); ```. Then I noticed this:. ```julia; julia> a_plus_1 = a + 1; BinaryOperation at (Center, Center, Center); ├── grid: RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded}; domain: longitude λ ∈ [-10.0, 10.0], latitude ∈ [0.0, 45.0], z ∈ [-1000.0, 0.0]; topology: (Bounded, Bounded, Bounded); size (Nx, Ny, Nz): (512, 512, 32); halo (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δλ, Δφ, Δz): (0.0390625, 0.087890625, 31.25); │ └── domain: longitude λ ∈ [-10.0, 10.0], latitude ∈ [0.0, 45.0], z ∈ [-1000.0, 0.0]; └── tree: ; + at (Center, Center, Center);    ├── Field located at (Center, Center, Center);    └── 1. julia> a .= a_plus_1. julia> @time a .= a_plus_1; 1.674752 seconds (2.22 M allocations: 127.371 MiB, 2.18% gc time, 56.65% compilation time). julia> @time a .= a_plus_1; 0.280226 seconds (17.11 k allocations: 1.104 MiB, 99.87% compilation time). julia> @time a .= a_plus_1; 1.525796 seconds (2.22 M allocations: 127.356 MiB, 2.15% gc time, 51.88% compilation time). julia> @time a .= a_plus_1; 0.294972 seconds (17.11 k allocations: 1.104 MiB, 99.88% compilation time). julia> @time a .= a_plus_1; 0.000274 seconds (170 allocations: 35.438 KiB). julia> @time a .= a_plus_1; 0.000274 seconds (170 allocations: 35.438 KiB); ```. Basically the compiler is ""stubborn"" and only caches our method after many tries... might be worth an issue on `KernelAbstractions.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958603853:2060,cache,caches,2060,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958603853,1,['cache'],['caches']
Performance," functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells.; > ; > I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. Quick question: Have you checked the performance here? I ask because the model was running pretty slowly when I was testing https://github.com/CliMA/Oceananigans.jl/pull/2275...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847:2247,perform,performance,2247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847,1,['perform'],['performance']
Performance," important changes:. * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition.; * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Minor changes:. * Update style to be consistent with other examples / source code (commas, spaces, etc); * Reorganized the script to read like the other examples / tutorials (like a paper, parameters are introduced when they are used rather than at the top); * Reorganized a few other misc stuff for pedagogical reasons, like building buoyancy + coriolis together; * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; * Change tilting angle to 3 degrees rather than 0.05 radians; * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated); * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity; * Plotting fewer contours makes the animation faster (the most expensive part of this example); * We don't need to form `Field`s any more for the output writers any more. Idle thoughts:. * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?; * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449:1201,perform,perform,1201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449,1,['perform'],['perform']
Performance," infrastructure, and is a satisfactory boundary condition for some cases. Would this be okay?. A simple matching scheme is a great place to start to justify changing the `Open` classification. > For example, in a nested case, this would prevent higher resolution eddies from exiting the domain without un-physically modifying the upstream solution. I apologize if this is just a problem with communication style, but I don't think this statement can possibly be correct. The above example seems to demonstrate, for example, that the cylinder wake can be represented well by _either_ making the domain large enough (with sponge layers), _or_ by using a better numerical method with a smaller domain. Basically this allows us to exclude statements like ""we can't model X flow"". The question is not whether or not we can represent the physics of a flow. The question is rather about representing the flow in a domain that is as small as possible / with optimal computational expense. We're pursuing performance optimization. Our language has to take the form ""this scheme allows us to reduce the sponge layer thickness by XX%"", or ""this scheme reduces the width of the near-boundary region where the interior physics are modified"". The statement ""this scheme does not unphysically modify the solution"" makes no sense to me. The presence of the open boundary is unphysical by definition... I personally don't need much convincing that a matching scheme of some kind is needed. I'm just confused about how all of the different pieces that seem to enter into nesting interact with one another --- sponge layers, matching scheme, and also the particular physics of the flow in question (idealized in and outflows vs true nesting). With so many degrees of freedom and complexity I think a systematic approach is absolutely essential. I really hope that the outcome of this work are a set of solid recommendations for nesting (better yet, a recipe that does not have to be changed --- a recommended matching sc",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291:1669,perform,performance,1669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance," makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can. I've reconsidered this now and think we may not even need any source code change to properly implement this behaviour and integrate some particle induced tracer forcing. If we have a model with some tracers `(:A, :B)` which we want to force with some particles, we can define an auxiliary field `G\_p=TracerFields((:A, :B), grid)`. We can then have a particle dynamics function that modifies `model.auxiliary_fields.G\_p`, for example sets the points surrounding the particles to `-A[i, j, k]` for `A`, and `+A[i, j, k]` for `B` like in my example above. You can then define a discrete forcing function for each of the tracers like `a_forcing(i, j, k, grid, clock, model_fields) = model_fields.G\_p.A[i, j, k]` etc. (this would only work with my other PR #2733 added so that the `auxiliary_fields` are available). > It seems the memory requirement of the forcing function approach is proportional to the number of tracers, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. My reservation with this was that if there's e.g. 1 particle effecting loads of tracers you have to store lots more fields, but I see now that this is much less of an issue. Sorry about making this much more complicated than it should have been!. Edit: updated the gist example with how this can be implemented (requires PR #2733 branch)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312:1958,load,loads,1958,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312,1,['load'],['loads']
Performance," mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_zRopeZ"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_ag",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:3260,load,loading,3260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance," mostly a matter of choice (if the reconstruction is performed correctly for all stencils!). The general way to do this is to make them functions of a ""local smoothness indicator"" <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> which is calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r} = \sum_{l=1}^k \int_{x_{i-1/2}}^{x_{i %2B 1/2}} \Delta x^{2l -1} \left( \frac{\partial^l p_r(x)}{\partial x^l} \right)^2 dx""> . These <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> simplify quite nicely for uniform grids. the `streched_smoothness=true` option calculates the coefficients of these smoothness indicators for a stretched grid, by assuming that (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Then the weights are calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=w_{r} = \frac{\alpha_r}{\alpha_0 %2B \alpha_1 %2B \alpha_2}""> . where <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r""> depends on the scheme used and differs between JS-WENO and Z-WENO. In the former; <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r = \frac{d_r}{(\beta_r %2B \varepsilon)^2}"">; In the latter ; <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r = d_r \left[ 1 %2B \left( \frac{ \left |\beta_2 - \beta_0 \right|}{\beta_r %2B \varepsilon} \right)^2 \right] "">; <img src=""https://render.githubusercontent.com/render/math?math=d_r""> are optimized constants equal in both the schemes. the `zweno = true` flag just switches between these two formulations. Now, I believe that `stretched_smoothness` does not have a such big impact because if you assure that the reconstruction is correct, then all stencil correctly interpolate to the face and weights will still be between 0 and 1. This might be more impactful for grids that are much more non-uniform (or ""irregular"") than what we usually use.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397:3530,optimiz,optimized,3530,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397,1,['optimiz'],['optimized']
Performance," of file""); &nbsp; | ┌ Error: Error during initialization of module CHOLMOD; &nbsp; | │ exception =; &nbsp; | │ could not load library ""libcholmod""; &nbsp; | │ libopenblas64_.so.0: ELF load command past end of file; &nbsp; | │ Stacktrace:; &nbsp; | │ [1] dlopen(::String, ::UInt32; throw_error::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109; &nbsp; | │ [2] dlopen at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:951; &nbsp; | [2] unsafe_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:1005; &nbsp; | [3] write(::Base.PipeEndpoint, ::String) at ./strings/io.jl:183; &nbsp; | [4] create_expr_cache(::String, ::String, ::Array{Pair{Base.PkgId,UInt64},1}, ::Base.UUID) at ./loading.jl:1194; &nbsp; | [5] compilecache(::Base.PkgId, ::String) at ./loading.jl:1286; &nbsp; | [6] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [7] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [8] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:1; &nbsp; | [12] top-level scope at /storage7/buildkite-agent/.julia-2581/packages",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:3526,load,load,3526,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,3,"['Load', 'load']","['LoadError', 'load']"
Performance," right; "">CPU</td>; <td style = ""text-align: right; "">UpwindBiasedFifthOrder</td>; <td style = ""text-align: right; "">3.19781</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">UpwindBiasedThirdOrder</td>; <td style = ""text-align: right; "">2.84754</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">WENO5</td>; <td style = ""text-align: right; "">8.25962</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; </table>. <table>; <caption style = ""text-align: center; "">Advection schemes relative performance (GPU)</caption>; <tr class = ""header headerLastRow"">; <th style = ""text-align: right; "">Architectures</th>; <th style = ""text-align: right; "">Schemes</th>; <th style = ""text-align: right; "">slowdown</th>; <th style = ""text-align: right; "">memory</th>; <th style = ""text-align: right; "">allocs</th>; </tr>; <tr>; <td style = ""text-align: right; "">GPU</td>; <td style = ""text-align: right; "">CenteredFourthOrder</td>; <td style = ""text-align: right; "">1.67825</td>; <td style = ""text-align: right; "">1.02677</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">GPU</td>; <td style = ""text-align: right; "">CenteredSecondOrder</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">GPU</td>; <td style = ""text-align: right; "">UpwindBiasedFifthOrder</td>; <td style = ""text-align: right; "">2.05742</td>; <td style = ""text-align: right; "">1.02812</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">GPU</td>; <td style = ""text-align: right; "">UpwindBiasedThirdOrder</td",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594:1800,perform,performance,1800,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594,1,['perform'],['performance']
Performance," runtime_module(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/interface.jl:173; [3] build_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:101; [4] (::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:86 [inlined]; [11] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:129; [12] codegen; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:110 [inlined]; [13] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:106; [14] compile; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:98 [inlined]; [15] #40; @ ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:140 [inlined]; [16] JuliaContext(f::AMDGPU.Compiler.var""#40#41""{GPUCompiler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:1521,optimiz,optimize,1521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,2,['optimiz'],['optimize']
Performance," search: plan_fft plan_fft! plan_rfft plan_ifft plan_bfft plan_ifft! plan_bfft! plan_irfft plan_brfft. plan_fft(A [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf). Pre-plan an optimized FFT along given dimensions (dims) of arrays matching the shape and type of A. (The first two arguments have the same meaning as for fft.) Returns an object P which; represents the linear operator computed by the FFT, and which contains all of the information needed to compute fft(A, dims) quickly. To apply P to an array A, use P * A; in general, the syntax for applying plans is much like that of matrices. (A plan can only be applied to arrays of the same size as the A for which; the plan was created.) You can also apply a plan with a preallocated output array Â by calling mul!(Â, plan, A). (For mul!, however, the input array A must be a complex floating-point; array like the output Â.) You can compute the inverse-transform plan by inv(P) and apply the inverse plan with P \ Â (the inverse plan is cached and reused for subsequent calls to inv or; \), and apply the inverse plan to a pre-allocated output array A with ldiv!(A, P, Â). The flags argument is a bitwise-or of FFTW planner flags, defaulting to FFTW.ESTIMATE. e.g. passing FFTW.MEASURE or FFTW.PATIENT will instead spend several seconds (or more) benchmarking; different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags. The optional timelimit argument specifies a rough upper bound on; the allowed planning time, in seconds. Passing FFTW.MEASURE or FFTW.PATIENT may cause the input array A to be overwritten with zeros during plan creation. plan_fft! is the same as plan_fft but creates a plan that operates in-place on its argument (which must be an array of complex floating-point numbers). plan_ifft and so on are similar; but produce plans that perform the equivalent of the inverse transforms ifft and so on. help?> plan_fft!; search: plan_fft! plan_ifft! plan_bfft! plan_fft plan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179127:1066,cache,cached,1066,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179127,1,['cache'],['cached']
Performance," second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If we use short-circuiting logic, then I guess many optimizations are not possible, because execution on one branch or another must be completely excluded. Some of this is discussed here: https://discourse.julialang.org/t/multiplying-by-booleans-faster-than-if-else/64117. > What about @inline?. This a little hazier. The compiler decides based on a heuristic whether or not to ""inline"" a function (meaning, rather than compiling code for a function independently and jumping to that code at the right moment, it combines the function code with the code that calls the function). We want to inline everything basically, so that every tendency evaluation involves evaluating one giant function. Inlining lets LLVM magic optimize our code to the highest degree (at least that's my impression). For whatever reason the compiler often decides _not_ to inline our functions unless we spec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:1866,optimiz,optimize,1866,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583,1,['optimiz'],['optimize']
Performance," slowdown │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼──────────┼────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 2.76522 │ 1.0 │ 1.0 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 2.14077 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 2.32425 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 1.64349 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 2.44462 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 1.79278 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 1.72073 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴──────────┴────────┘; ```. ## GPU slowdown (vs. triply-periodic). ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 192 │ (Bounded, Bounded, Bounded) │ 4.83605 │ 76.8 │ 29.1613 │; │ GPU │ 192 │ (Bounded, Bounded, Periodic) │ 3.90501 │ 52.5714 │ 21.0 │; │ GPU │ 192 │ (Bounded, Periodic, Bounded) │ 3.91006 │ 52.4 │ 20.8065 │; │ GPU │ 192 │ (Bounded, Periodic, Periodic) │ 5.59024 │ 25.4571 │ 9.48387 │; │ GPU │ 192 │ (Periodic, Bounded, Bounded) │ 3.88581 │ 52.5714 │ 21.0 │; │ GPU │ 192 │ (Periodic, Bounded, Periodic) │ 2.96267 │ 28.0 │ 12.4516 │; │ GPU │ 192 │ (Periodic, Periodic, Bounded) │ 2.03389 │ 25.4571 │ 9.48387 │; │ GPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. # Static ocean benchmarks for all topologies. ## Raw numbers. ```; Topologies benchmarks; ┌───────────────┬─────┬────────────────────────────────┬───────────┬───────────┬───────────┬───────────",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:4731,perform,performance,4731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296,1,['perform'],['performance']
Performance," than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time= stop_time_info, iteration_interval = iteration_interval_info,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = Name_of_simulation,; schedule = TimeInterval(0.2minute),; force = true). run!(simulation). using JLD2. using Plots. # load(""modified_open_ocean_convection_Fplane_GPU.jld2""). file = jldopen(""ocean_convection_Fplane_Vertical_strecthed_grid.jld2""). # Coordinate arrays; xC, yC, zC = file[""grid/xC""][1:256],file[""grid/yC""][1:256],file[""grid/zC""][1:65]; Lx, Ly, Lz = file[""grid/Lx""],file[""grid/Ly""],file[""grid/Lz""]. # Extract a vector of iterations; iterations = parse.(Int, keys(file[""timeseries/t""])). @info ""Making a neat movie of verticle velocity and Temperature..."". anim = @animate for (i, iteration) in enumerate(iterations). @info ""Plotting frame $i from iteration $iteration..."". t = file[""timeseries/t/$iteration""]; u_snapshot = file[""timeseries/u/$iteration""][:, :, 60]; v_snapshot = file[""timeseries/v/$iteration""][:, :, 60]; w_snapshot = file[""timeseries/w/$iteration""][:, 128, :]; speed_snapshot = sqrt.(u_snapshot.*u_snapshot + v_snapshot.*v_snapshot); # T_snapshot = file[""timeseries/T/$iteration""][:, 128, :]; . ulims = 0.0025; ; ulevels = range(-ulims, stop=ulims, length=50); ; slims = 0.025; ; slevels = range(0, stop=slims, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999:5903,load,load,5903,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999,1,['load'],['load']
Performance," this might be useful to people if its more visible. > Why you need to define f², wouldn't work simply using ∂zᶠᶜᶠ and squaring the operation?. Because we need to interpolate `∂zᶠᶜᶠ` using `ℑxzᶜᵃᶜ`. Note that Oceananigans operators (derivatives, interpolation, differences) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:1322,optimiz,optimized,1322,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513,1,['optimiz'],['optimized']
Performance," tridiagonal solver in the pure FFT solver. You might argue that we just put nothing if we don't need it, but then we have more ""ambiguous"" fields like eigenvalues that are not needed in the tridiagonal solver and source_term that is not needed in the FFT. I am not convinced that a single solver would lead to less (or cleaner) code. Mostly because the underlying code (constructor and `solve!` functions) is compact and slender enough to justify writing individual functions for different grids (the number of lines in the docstring for the `DistributedFourierTridiagonalPoissonSolver` is comparable to the code related to the solver). I think this improves the interpretability of the algorithm. Maybe an improvement would be writing a unified constructor that would spit out the different solvers. > 2. It might make sense to split the constructor into two parts, so that we can build a tridiagonal solver even when all three directions are regular. That could be useful for testing, for example. . I have added this capability by passing the `stretched_direction` kwarg. > Also note that in terms of operation count the tridiagonal solve is cheaper than FFT... I think, all things considered, the mixed FFT / tridiagonal solve will have basically the same computational cost as the pure FFT solve only for a stretched x direction. The additional transposes required for a y or stretched z direction will completely dominate the cost of the actual operations. As an example, this is a slab decomposition with a fairly big grid (512 x 256^2) split on 2 GPUs on Tartarus; ![311333172-43dba752-a91f-4b33-8ade-5a6ec57c982b](https://github.com/user-attachments/assets/1a376c1e-9912-4e00-8dca-91deb46338f8); The AlltoAllv is the dominant cost, while the FFT (in between the two transposes) is quite irrelevant. In the near future, I'll perform scaling tests on Perlmutter, which has a much better network, so it might be that (even if I think it's unlikely) the cost is not all communication after all.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3689#issuecomment-2276030073:2336,perform,perform,2336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3689#issuecomment-2276030073,1,['perform'],['perform']
Performance," using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: LoadError: LoadError: UndefVarError: NFBC not defined; Stacktrace:; [1] top-level scope; @ ~/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; [2] include(mod::Module, _path::String); @ Base ./Base.jl:386; [3] include(x::String); @ Oceananigans.BoundaryConditions ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; [4] top-level scope; @ ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:45; [5] include(mod::Module, _path::String); @ Base ./Base.jl:386; [6] include(x::String); @ Oceananigans ~/Research/OC/src/Oceananigans.jl:1; [7] top-level scope; @ ~/Research/OC/src/Oceananigans.jl:173; [8] include; @ ./Base.jl:386 [inlined]; [9] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1213; [10] top-level scope; @ none:1; [11] eval; @ ./boot.jl:360 [inlined]; [12] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [13] top-level scope; @ none:1; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; in expression starting at /Users/navid/Research/OC/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_fSB7qw.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334:1085,load,loading,1085,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334,1,['load'],['loading']
Performance," using `ℑxzᶜᵃᶜ`. Note that Oceananigans operators (derivatives, interpolation, differences) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:1419,perform,performance,1419,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513,1,['perform'],['performance']
Performance,"""Done"" isn't very precise since the cubed sphere will never be ""done"". But perhaps we can put a number on performance for the first milestone, which will allow us to conclude whether we need this optimization or not. Can you explain where the gut feeling comes from? Will filling halos be so expensive even on just one GPU, or is this a distributed problem? Currently, 1/4 degree is performant on one GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718744032:106,perform,performance,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718744032,3,"['optimiz', 'perform']","['optimization', 'performance', 'performant']"
Performance,"# Some selected benchmark results. ## Advection scheme benchmarks. <table>; <caption style = ""text-align: center; "">Advection schemes relative performance (CPU)</caption>; <tr class = ""header headerLastRow"">; <th style = ""text-align: right; "">Architectures</th>; <th style = ""text-align: right; "">Schemes</th>; <th style = ""text-align: right; "">slowdown</th>; <th style = ""text-align: right; "">memory</th>; <th style = ""text-align: right; "">allocs</th>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">CenteredFourthOrder</td>; <td style = ""text-align: right; "">2.68376</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">CenteredSecondOrder</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">UpwindBiasedFifthOrder</td>; <td style = ""text-align: right; "">3.19781</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">UpwindBiasedThirdOrder</td>; <td style = ""text-align: right; "">2.84754</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">WENO5</td>; <td style = ""text-align: right; "">8.25962</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; </table>. <table>; <caption style = ""text-align: center; "">Advection schemes relative performance (GPU)</caption>; <tr class = ""header headerLastRow"">; <th style = ""text-align: right; "">Architectures</th>; <th style = ""text-align: right; "">Schemes</th>; <th style = ""text-align: right; """,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594:143,perform,performance,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594,1,['perform'],['performance']
Performance,"################# 100.0%; &nbsp; | Downloading artifact: MPICH; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibCURL; &nbsp; | ######################################################################## 100.0%; &nbsp; | Building MPI ─→ `/storage7/buildkite-agent/.julia-2581/packages/MPI/b7MVG/deps/build.log`; &nbsp; | [ Info: using default MPI jll; &nbsp; | Building FFTW → `/storage7/buildkite-agent/.julia-2581/packages/FFTW/G3lSO/deps/build.log`; &nbsp; | Precompiling project...; &nbsp; | WARNING: Error during initialization of module GMP:; &nbsp; | ErrorException(""could not load library ""libgmp""; &nbsp; | libgmp.so: ELF load command past end of file""); &nbsp; | WARNING: Error during initialization of module LinearAlgebra:; &nbsp; | ErrorException(""could not load library ""libopenblas64_""; &nbsp; | libopenblas64_.so: ELF load command past end of file""); &nbsp; | ┌ Error: Error during initialization of module CHOLMOD; &nbsp; | │ exception =; &nbsp; | │ could not load library ""libcholmod""; &nbsp; | │ libopenblas64_.so.0: ELF load command past end of file; &nbsp; | │ Stacktrace:; &nbsp; | │ [1] dlopen(::String, ::UInt32; throw_error::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109; &nbsp; | │ [2] dlopen at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_wri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:2579,load,load,2579,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,2,['load'],['load']
Performance,"&nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:951; &nbsp; | [2] unsafe_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:1005; &nbsp; | [3] write(::Base.PipeEndpoint, ::String) at ./strings/io.jl:183; &nbsp; | [4] create_expr_cache(::String, ::String, ::Array{Pair{Base.PkgId,UInt64},1}, ::Base.UUID) at ./loading.jl:1194; &nbsp; | [5] compilecache(::Base.PkgId, ::String) at ./loading.jl:1286; &nbsp; | [6] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [7] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [8] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:1; &nbsp; | [12] top-level scope at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | [13] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [14] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [15] top-level scope at none:2; &nbsp; | [16] eval at ./boot.jl:347 [inlined]; &nbsp; | [17] eval(::Expr) at ./client.jl:467; &nbsp; | [18] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/Pencils/Pencils.jl:7; &nbsp; | in expression starting at /storage7/buildkite-agent/.ju",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:4142,load,loading,4142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['loading']
Performance,"'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using CUDAnative; julia> using Oceananigans; julia> model = Model(N=(128, 128, 128), L=(100, 100, 100), arch=GPU(), float_type=Float32);; julia> time_step!(model, 1, 1); julia> CUDAnative.timings(); ────────────────────────────────────────────────────────────────────────────────────; Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 164s / 10.7% 6.24GiB / 29.4% ; Section ncalls time %tot avg alloc %tot avg; ────────────────────────────────────────────────────────────────────────────────────; LLVM middle-end 14 9.08s 52.0% 649ms 637MiB 33.9% 45.5MiB; IR generation 14 7.00s 40.1% 500ms 567MiB 30.2% 40.5MiB; linking 14 2.49s 14.2% 178ms 224B 0.00% 16.0B; emission 14 2.28s 13.0% 163ms 406MiB 21.6% 29.0MiB; rewrite 14 2.13s 12.2% 152ms 157MiB 8.34% 11.2MiB; hide unreachable 2.02k 540ms 3.09% 267μs 20.9MiB 1.11% 10.6KiB; find 2.02k 295ms 1.69% 146μs 902KiB 0.05% 456B; predecessors 2.02k 162ms 0.93% 80.1μs 13.2MiB 0.70% 6.68KiB; replace 2.02k 68.7ms 0.39% 34.0μs 368KiB 0.02% 186B; lower throw 14 528ms 3.03% 37.7ms 47.8MiB 2.55% 3.42MiB; hide trap 14 65.8ms 0.38% 4.70ms 4.23MiB 0.23% 309KiB; clean-up 14 98.9ms 0.57% 7.06ms 4.85MiB 0.26% 355KiB; optimization 14 1.99s 11.4% 142ms 69.8MiB 3.71% 4.98MiB; device library 14 83.7ms 0.48% 5.98ms 11.5KiB 0.00% 839B; runtime library 14 6.44ms 0.04% 460μs 7.11KiB 0.00% 520B; verification 14 2.97ms 0.02% 212μs 0.00B 0.00% 0.00B; Julia front-end 14 6.70s 38.3% 478ms 1.11GiB 60.6% 81.3MiB; CUDA object generation 14 919ms 5.26% 65.6ms 31.9MiB 1.70% 2.28MiB; linking 14 780ms 4.47% 55.7ms 14.0MiB 0.75% 1.00MiB; compilation 14 139ms 0.79% 9.91ms 17.9MiB 0.95% 1.28MiB; LLVM back-end 14 769ms 4.40% 54.9ms 71.1MiB 3.78% 5.08MiB; machine-code generation 14 124ms 0.71% 8.89ms 192KiB 0.01% 13.7KiB; preparation 14 38.2ms 0.22% 2.73ms 2.94MiB 0.16% 215KiB; ────────────────────────────────────────────────────────────────────────────────────; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/66#issuecomment-478985611:1744,optimiz,optimization,1744,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/66#issuecomment-478985611,1,['optimiz'],['optimization']
Performance,(fyi I stopped the tests because everything was clogged... all tests in PRs have been running for 6-7 hrs... so perhaps restart when there is less load),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2890#issuecomment-1416674470:147,load,load,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2890#issuecomment-1416674470,3,['load'],['load']
Performance,", Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, SubArray{Float64, 1, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Tuple{UnitRange{Int64}}, true}}}}}); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/driver.jl:76; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:346; [10] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/cache.jl:90; [11] cufunction(f::typeof(Oceananigans.Fields.gpu__regrid!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Nothing, Nothing}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRange",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:6644,cache,cache,6644,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574,1,['cache'],['cache']
Performance,", Bounded) │ 23.479 ms │ 23.727 ms │ 23.792 ms │ 24.619 ms │ 771.44 KiB │ 1115 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 30.863 ms │ 30.990 ms │ 31.205 ms │ 31.858 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 31.041 ms │ 31.521 ms │ 31.982 ms │ 33.815 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Bounded) │ 25.631 ms │ 26.845 ms │ 26.749 ms │ 28.206 ms │ 837.97 KiB │ 1154 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Periodic) │ 31.354 ms │ 31.398 ms │ 31.477 ms │ 32.215 ms │ 771.44 KiB │ 1115 │ 10 │; └───────────────┴───────────────┴────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┴─────────┘; [2022/05/03 00:56:15.050] INFO Writing Topologies_benchmarks.html...; Topologies relative performance (CPU); ┌───────────────┬───────────────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼───────────────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Bounded) │ 0.865858 │ 1.45702 │ 1.14257 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Periodic) │ 1.01269 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Bounded) │ 0.760326 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 0.999539 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Bounded) │ 0.765277 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 1.01667 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Bounded) │ 0.756078 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴───────────────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. # This PR. ## Modest 3D model (128x128x128). ```; Topologies benchmarks; ┌───────────────┬",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:5129,perform,performance,5129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728,1,['perform'],['performance']
Performance,", Nothing, Nothing, Nothing}}:; ERROR: KernelException: exception thrown during kernel execution on device Tesla V100-SXM2-32GB; Stacktrace:; [1] check_exceptions(); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/src/compiler/exceptions.jl:34; [2] nonblocking_synchronize; @ /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/context.jl:331 [inlined]; [3] device_synchronize(); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/context.jl:319; [4] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/module.jl:41; [5] CuModule; @ /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/module.jl:23 [inlined]; [6] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/src/compiler/execution.jl:479; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/XyxTy/src/cache.jl:95; [8] cufunction(f::typeof(CUDA.partial_mapreduce_grid), tt::Type{Tuple{typeof(identity), typeof(max), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, Val{true}, CUDA.CuDeviceArray{Float64, 4, 1}, Oceananigans.AbstractOperations.ConditionalOperation{Face, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, typeof(identity), ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871:5688,cache,cache,5688,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871,1,['cache'],['cache']
Performance,", Periodic, Bounded) │ 23.208 ms │ 23.282 ms │ 23.646 ms │ 24.667 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Bounded) │ 23.736 ms │ 24.691 ms │ 24.854 ms │ 26.482 ms │ 771.44 KiB │ 1115 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 31.277 ms │ 32.486 ms │ 32.212 ms │ 32.999 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 30.844 ms │ 30.903 ms │ 31.003 ms │ 31.769 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Bounded) │ 23.704 ms │ 23.832 ms │ 24.042 ms │ 25.055 ms │ 837.97 KiB │ 1154 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Periodic) │ 31.354 ms │ 31.632 ms │ 31.816 ms │ 32.916 ms │ 772.19 KiB │ 1131 │ 10 │; └───────────────┴───────────────┴────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┴─────────┘; [2022/05/03 00:42:25.915] INFO Writing Topologies_benchmarks.html...; Topologies relative performance (CPU); ┌───────────────┬───────────────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼───────────────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Bounded) │ 0.669516 │ 1.45702 │ 1.14257 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Periodic) │ 0.888622 │ 1.34264 │ 1.1198 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Bounded) │ 0.665425 │ 1.34264 │ 1.1198 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 0.912619 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Bounded) │ 0.693639 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 0.868158 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Bounded) │ 0.654046 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; ```. The fastest is fully bounded for whatever reason.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:10798,perform,performance,10798,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728,1,['perform'],['performance']
Performance,"-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; │ [6] #mkpidlock#6; │ @ ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; │ [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined]; │ [9] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); │ @ Base ./loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [26] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [27] _require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1803; │ [28] macro exp",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:2586,load,loading,2586,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"./client.jl:404; [13] top-level scope at ./none:3; in expression starting at /home/travis/.julia/packages/CuArrays/qZCAt/src/deprecated.jl:5; in expression starting at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:54; ERROR: LoadError: LoadError: LoadError: LoadError: UndefVarError: @setup not defined; Stacktrace:; [1] top-level scope; [2] #macroexpand#35 at ./expr.jl:107 [inlined]; [3] macroexpand at ./expr.jl:106 [inlined]; [4] docm(::LineNumberNode, ::Module, ::Any, ::Any, ::Bool) at ./docs/Docs.jl:509 (repeats 2 times); [5] @doc(::LineNumberNode, ::Module, ::String, ::Vararg{Any,N} where N) at ./boot.jl:459; [6] include at ./boot.jl:326 [inlined]; [7] include_relative(::Module, ::String) at ./loading.jl:1038; [8] include at ./sysimg.jl:29 [inlined]; [9] include(::String) at /home/travis/build/climate-machine/Oceananigans.jl/src/Oceananigans.jl:1; [10] top-level scope at none:0; [11] include at ./boot.jl:326 [inlined]; [12] include_relative(::Module, ::String) at ./loading.jl:1038; [13] include(::Module, ::String) at ./sysimg.jl:29; [14] top-level scope at none:2; [15] eval at ./boot.jl:328 [inlined]; [16] eval(::Expr) at ./client.jl:404; [17] top-level scope at ./none:3; in expression starting at /home/travis/build/climate-machine/Oceananigans.jl/src/poisson_solvers.jl:173; in expression starting at /home/travis/build/climate-machine/Oceananigans.jl/src/poisson_solvers.jl:171; in expression starting at /home/travis/build/climate-machine/Oceananigans.jl/src/poisson_solvers.jl:171; in expression starting at /home/travis/build/climate-machine/Oceananigans.jl/src/Oceananigans.jl:149; ERROR: LoadError: Failed to precompile Oceananigans [6e00b360-fae3-11e8-3922-3d7cb9e50aad] to /home/travis/.julia/compiled/v1.1/Oceananigans/VuIZ2.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1197; [3] _require(::Base.PkgId) at ./loading.jl:960; [4] require(::Base.PkgId) at ./loading.jl:858; [5] require(::M",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/153#issuecomment-477579168:4235,load,loading,4235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/153#issuecomment-477579168,1,['load'],['loading']
Performance,".PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); │ @ Base ./loading.jl:2468; │ [3] compilecache; │ @ ./loading.jl:2340 [inlined]; │ [4] (::Base.var""#968#969""{Base.PkgId})(); │ @ Base ./loading.jl:1974; │ [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; │ [6] #mkpidlock#6; │ @ ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; │ [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined]; │ [9] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); │ @ Base ./loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:2186,load,loading,2186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,".jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:1; &nbsp; | [12] top-level scope at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | [13] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [14] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [15] top-level scope at none:2; &nbsp; | [16] eval at ./boot.jl:347 [inlined]; &nbsp; | [17] eval(::Expr) at ./client.jl:467; &nbsp; | [18] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/Pencils/Pencils.jl:7; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | ERROR: LoadError: Failed to precompile PencilArrays [0e08944d-e94e-41b1-9406-dcf66b6a9d2e] to /storage7/buildkite-agent/.julia-2581/compiled/v1.5/PencilArrays/yKKUy_zV1Ut.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] error(::String) at ./error.jl:33; &nbsp; | [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1305; &nbsp; | [3] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [4] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [5] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [6] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [7] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [8] top-level scope at none:2; &nbsp; | [9] eval at ./boot.jl:347 [inlined]; &nbsp; | [10] eval(::Expr) at ./client.jl:467; &nbsp; | [11] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilFFTs/Xwxei/src/PencilFFTs.jl:11; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:5223,Load,LoadError,5223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['Load'],['LoadError']
Performance,"/3VnCC/src/device/intrinsics.jl:22; [7] include(mod::Module, _path::String); @ Base ./Base.jl:386; [8] include(x::String); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; [9] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:46; [10] include; @ ./Base.jl:386 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics/math.jl:5; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /home/tomas/.julia/compiled/v1.6/CUDA/jl_q4lPlx.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; [7] include; @ ./Base.jl:386 [inlined]; [8] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [9] top-level scope; @ none:1; [10] eval; @ ./boot.jl:360 [inlined]; [11] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [12] top-level scope; @ none:1; in expression starting at /home/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371:1804,Load,LoadError,1804,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371,1,['Load'],['LoadError']
Performance,"/DTEhf/src/PencilArrays.jl:12; &nbsp; | ERROR: LoadError: Failed to precompile PencilArrays [0e08944d-e94e-41b1-9406-dcf66b6a9d2e] to /storage7/buildkite-agent/.julia-2581/compiled/v1.5/PencilArrays/yKKUy_zV1Ut.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] error(::String) at ./error.jl:33; &nbsp; | [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1305; &nbsp; | [3] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [4] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [5] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [6] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [7] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [8] top-level scope at none:2; &nbsp; | [9] eval at ./boot.jl:347 [inlined]; &nbsp; | [10] eval(::Expr) at ./client.jl:467; &nbsp; | [11] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilFFTs/Xwxei/src/PencilFFTs.jl:11; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:6302,load,load,6302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,9,['load'],['load']
Performance,"/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:86 [inlined]; [11] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:129; [12] codegen; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:110 [inlined]; [13] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:106; [14] compile; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:98 [inlined]; [15] #40; @ ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:140 [inlined]; [16] JuliaContext(f::AMDGPU.Compiler.var""#40#41""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:47; [17] hipcompile(job::GPUCompiler.CompilerJob); @ AMDGPU.Compiler ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:139; [18] actual_compilation(cache::Dict{Any, AMDGPU.HIP.HIPFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}, compiler::typeof(AMDGPU.Compiler.hipcompile), linker::typeof(AMDGPU.Compiler.hiplink)); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/execution.jl:125; [19] cached_co",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:2169,optimiz,optimize,2169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,2,['optimiz'],['optimize']
Performance,"/loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [26] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [27] _require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1803; │ [28] macro expansion; │ @ ./loading.jl:1790 [inlined]; │ [29] macro expansion; │ @ ./lock.jl:267 [inlined]; │ [30] __require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1753; │ [31] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [32] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [33] require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1746; │ [34] eval; │ @ ./boot.jl:385 [inlined]; │ [35] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; │ [36] repl_backend_loop(backend::REPL.REPLBacke",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:3182,load,loading,3182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing); throw_api_error at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; check at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; cuStreamDestroy_v2 at /home/js2430/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; #834 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:86 [inlined]; #context!#887 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170; unknown function (ip: 0x7f08bc0a0880); context! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; unsafe_destroy! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:85; unknown function (ip: 0x7f08bc0a0622); _jl_invoke at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2758 [inlined]; ijl_apply_generic at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2940; run_finalizer at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:417; jl_gc_run_finalizers_in_list at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:507; run_finalizers at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:553; ijl_atexit_hook at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/init.c:299; jl_repl_entrypoint at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/jlapi.c:718; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x401098); ```; </details>; </summary>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:4390,cache,cache,4390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129,7,['cache'],['cache']
Performance,"/td>; <td style = ""text-align: right; "">1.36185</td>; </tr>; <tr>; <td style = ""text-align: right; "">GPU</td>; <td style = ""text-align: right; "">192</td>; <td style = ""text-align: right; "">(Periodic, Periodic, Bounded)</td>; <td style = ""text-align: right; "">1.10911</td>; <td style = ""text-align: right; "">1.1314</td>; <td style = ""text-align: right; "">1.13269</td>; </tr>; <tr>; <td style = ""text-align: right; "">GPU</td>; <td style = ""text-align: right; "">192</td>; <td style = ""text-align: right; "">(Periodic, Periodic, Periodic)</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; </table>. ## Turbulence closure benchmarks. <table>; <caption style = ""text-align: center; "">Turbulence closures relative performance (CPU)</caption>; <tr class = ""header headerLastRow"">; <th style = ""text-align: right; "">Architectures</th>; <th style = ""text-align: right; "">Closures</th>; <th style = ""text-align: right; "">slowdown</th>; <th style = ""text-align: right; "">memory</th>; <th style = ""text-align: right; "">allocs</th>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">AnisotropicBiharmonicDiffusivity</td>; <td style = ""text-align: right; "">2.05198</td>; <td style = ""text-align: right; "">1.00469</td>; <td style = ""text-align: right; "">1.00536</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">AnisotropicDiffusivity</td>; <td style = ""text-align: right; "">1.16121</td>; <td style = ""text-align: right; "">1.00469</td>; <td style = ""text-align: right; "">1.00536</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">IsotropicDiffusivity</td>; <td style = ""text-align: right; "">1.16634</td>; <td style = ""text-align: right; "">1.00139</td>; <td style = ""text-align: right; "">1.00536</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594:16660,perform,performance,16660,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594,1,['perform'],['performance']
Performance,"/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:951; &nbsp; | [2] unsafe_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:1005; &nbsp; | [3] write(::Base.PipeEndpoint, ::String) at ./strings/io.jl:183; &nbsp; | [4] create_expr_cache(::String, ::String, ::Array{Pair{Base.PkgId,UInt64},1}, ::Base.UUID) at ./loading.jl:1194; &nbsp; | [5] compilecache(::Base.PkgId, ::String) at ./loading.jl:1286; &nbsp; | [6] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [7] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [8] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:1; &nbsp; | [12] top-level scope at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | [13] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [14] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [15] top-level scope at none:2; &nbsp; | [16] eval at ./boot.jl:347 [inlined]; &nbsp; | [17] eval(::Expr) at ./client.jl:467; &nbsp; | [18] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/Pencils/Pencils.jl:7; &nbsp;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:4084,load,loading,4084,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['loading']
Performance,0 │; │ CPU │ TEOS10EquationOfState │ 2.270 s │ 2.401 s │ 2.378 s │ 2.464 s │ 372.53 KiB │ 2090 │; │ GPU │ LinearEquationOfState │ 10.058 ms │ 13.161 ms │ 12.856 ms │ 13.215 ms │ 1022.19 KiB │ 7154 │; │ GPU │ RoquetEquationOfState │ 10.688 ms │ 13.236 ms │ 12.991 ms │ 13.322 ms │ 1.00 MiB │ 7054 │; │ GPU │ TEOS10EquationOfState │ 10.204 ms │ 13.463 ms │ 13.145 ms │ 13.504 ms │ 1017.58 KiB │ 7154 │; └───────────────┴───────────────────────┴───────────┴───────────┴───────────┴───────────┴─────────────┴────────┘; ```. ```; Equation of state CPU -> GPU speedup; ┌───────────────────────┬─────────┬─────────┬─────────┐; │ EquationsOfState │ speedup │ memory │ allocs │; ├───────────────────────┼─────────┼─────────┼─────────┤; │ LinearEquationOfState │ 154.965 │ 2.74298 │ 3.42297 │; │ RoquetEquationOfState │ 133.062 │ 2.74052 │ 3.37512 │; │ TEOS10EquationOfState │ 178.317 │ 2.73152 │ 3.42297 │; └───────────────────────┴─────────┴─────────┴─────────┘; ```. ```; Equation of state relative performance (CPU); ┌───────────────┬───────────────────────┬──────────┬──────────┬────────┐; │ Architectures │ EquationsOfState │ slowdown │ memory │ allocs │; ├───────────────┼───────────────────────┼──────────┼──────────┼────────┤; │ CPU │ LinearEquationOfState │ 1.0 │ 1.0 │ 1.0 │; │ CPU │ RoquetEquationOfState │ 0.863549 │ 1.00298 │ 1.0 │; │ CPU │ TEOS10EquationOfState │ 1.17707 │ 0.999665 │ 1.0 │; └───────────────┴───────────────────────┴──────────┴──────────┴────────┘; ```. ```; Equation of state relative performance (GPU); ┌───────────────┬───────────────────────┬──────────┬──────────┬──────────┐; │ Architectures │ EquationsOfState │ slowdown │ memory │ allocs │; ├───────────────┼───────────────────────┼──────────┼──────────┼──────────┤; │ GPU │ LinearEquationOfState │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ RoquetEquationOfState │ 1.00569 │ 1.00208 │ 0.986022 │; │ GPU │ TEOS10EquationOfState │ 1.02292 │ 0.995491 │ 1.0 │; └───────────────┴───────────────────────┴──────────┴──────────┴──────────┘. ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099:1965,perform,performance,1965,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099,2,['perform'],['performance']
Performance,"00; [3] compilecache; @ ./loading.jl:2167 [inlined]; [4] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1805; [5] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1660; [6] macro expansion; @ ./loading.jl:1648 [inlined]; [7] macro expansion; @ ./lock.jl:267 [inlined]; [8] require(into::Module, mod::Symbol); @ Base ./loading.jl:1611; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; ```; The versioninfo gave me the following as output:; ```; Julia Version 1.9.2; Commit e4ee485e90 (2023-07-05 09:39 UTC); Platform Info:; OS: Linux (x86_64-suse-linux); ""openSUSE Leap 15.4""; uname: Linux 5.14.21-150400.24.46-default #1 SMP PREEMPT_DYNAMIC Thu Feb 9 08:38:18 UTC 2023 (2d95137) x86_64 x86_64; CPU: Intel(R) Xeon(R) Gold 6240 CPU @ 2.60GHz: ; speed user nice sys idle irq; #1-72 2600 MHz 922553194 s 727867 s 363212152 s 5414020342 s 0 s; Memory: 370.290340423584 GB (301775.56640625 MB free); Uptime: 9.37897786e6 sec; Load Avg: 13.61 25.96 27.94; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-14.0.6 (ORCJIT, cascadelake); Threads: 1 on 72 virtual cores; Environment:; LD_LIBRARY_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/lib:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/nvvm/lib64:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/extras/CUPTI/lib64:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/extras/Debugger/lib64:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/lib:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/lib/x64:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/lib/oclfpga/host/linux64/lib:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/compiler/lib/intel64_lin:/glade",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:1635,Load,Load,1635,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['Load'],['Load']
Performance,"110 ms │ 57.56 KiB │ 641 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 13.975 ms │ 30.948 ms │ 29.250 ms │ 30.985 ms │ 57.75 KiB │ 647 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 7.257 ms │ 15.907 ms │ 15.044 ms │ 15.927 ms │ 27.97 KiB │ 292 │; └───────────────┴─────┴───────────────────────────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┘; ```. ### CPU to GPU speedup. ```; FFT-based Poisson solver CPU -> GPU speedup; ┌─────┬───────────────────────────────┬─────────┬────────┬────────┐; │ Ns │ Topologies │ speedup │ memory │ allocs │; ├─────┼───────────────────────────────┼─────────┼────────┼────────┤; │ 256 │ (Bounded, Bounded, Bounded) │ 35.4428 │ 450.0 │ 224.5 │; │ 256 │ (Bounded, Periodic, Bounded) │ 36.8697 │ 368.4 │ 320.5 │; │ 256 │ (Periodic, Bounded, Bounded) │ 37.0953 │ 369.6 │ 323.5 │; │ 256 │ (Periodic, Periodic, Bounded) │ 53.4034 │ 179.0 │ 146.0 │; └─────┴───────────────────────────────┴─────────┴────────┴────────┘; ```. ### CPU relative performance. ```; FFT-based Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.61224 │ 1.2 │ 2.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.34917 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.35141 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴────────┴────────┘; ```. ### GPU relative performance. ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:11727,perform,performance,11727,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050,1,['perform'],['performance']
Performance,"111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_zRopeZ"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwop",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:2467,load,loading,2467,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/Oceananigans/jl_k7YOZN"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgI",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:5048,load,loading,5048,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"1; &nbsp; | [12] top-level scope at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | [13] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [14] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [15] top-level scope at none:2; &nbsp; | [16] eval at ./boot.jl:347 [inlined]; &nbsp; | [17] eval(::Expr) at ./client.jl:467; &nbsp; | [18] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/Pencils/Pencils.jl:7; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | ERROR: LoadError: Failed to precompile PencilArrays [0e08944d-e94e-41b1-9406-dcf66b6a9d2e] to /storage7/buildkite-agent/.julia-2581/compiled/v1.5/PencilArrays/yKKUy_zV1Ut.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] error(::String) at ./error.jl:33; &nbsp; | [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1305; &nbsp; | [3] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [4] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [5] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [6] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [7] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [8] top-level scope at none:2; &nbsp; | [9] eval at ./boot.jl:347 [inlined]; &nbsp; | [10] eval(::Expr) at ./client.jl:467; &nbsp; | [11] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilFFTs/Xwxei/src/PencilFFTs.jl:11; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:5516,load,loading,5516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['loading']
Performance,"213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics/math.jl:5; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /home/tomas/.julia/compiled/v1.6/CUDA/jl_q4lPlx.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; [7] include; @ ./Base.jl:386 [inlined]; [8] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [9] top-level scope; @ none:1; [10] eval; @ ./boot.jl:360 [inlined]; [11] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [12] top-level scope; @ none:1; in expression starting at /home/tomas/repos/Oceananigans.jl/src/Oceananigans.jl:1; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /home/tomas/.julia/compiled/v1.6/Oceananigans/jl_psrPk0.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371:2359,load,loading,2359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371,1,['load'],['loading']
Performance,"5.4428 │ 450.0 │ 224.5 │; │ 256 │ (Bounded, Periodic, Bounded) │ 36.8697 │ 368.4 │ 320.5 │; │ 256 │ (Periodic, Bounded, Bounded) │ 37.0953 │ 369.6 │ 323.5 │; │ 256 │ (Periodic, Periodic, Bounded) │ 53.4034 │ 179.0 │ 146.0 │; └─────┴───────────────────────────────┴─────────┴────────┴────────┘; ```. ### CPU relative performance. ```; FFT-based Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.61224 │ 1.2 │ 2.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.34917 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.35141 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴────────┴────────┘; ```. ### GPU relative performance. ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 2.42923 │ 3.01676 │ 3.07534 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.95419 │ 2.0581 │ 2.19521 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.94553 │ 2.0648 │ 2.21575 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴─────────┴─────────┘; ```. ---. ## System info. ```; Oceananigans v0.50.0; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23:17 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:12464,perform,performance,12464,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050,1,['perform'],['performance']
Performance,"558 │; > │ 100000000 │ 618.565 │ 3.01714 │ 6.04355 │; > └─────────────┴─────────┴─────────┴─────────┘; >; > Lagrangian particle tracking relative performance (CPU); > ┌───────────────┬─────────────┬──────────┬─────────┬─────────┐; > │ Architectures │ N_particles │ slowdown │ memory │ allocs │; > ├───────────────┼─────────────┼──────────┼─────────┼─────────┤; > │ CPU │ 0 │ 1.0 │ 1.0 │ 1.0 │; > │ CPU │ 1 │ 1.03447 │ 1.01267 │ 1.01599 │; > │ CPU │ 10 │ 1.04601 │ 1.01267 │ 1.01599 │; > │ CPU │ 100 │ 1.04712 │ 1.01267 │ 1.01599 │; > │ CPU │ 1000 │ 1.05514 │ 1.01267 │ 1.01599 │; > │ CPU │ 10000 │ 1.05397 │ 1.01267 │ 1.01599 │; > │ CPU │ 100000 │ 1.07213 │ 1.01267 │ 1.01599 │; > │ CPU │ 1000000 │ 1.34006 │ 1.01267 │ 1.01599 │; > │ CPU │ 10000000 │ 4.09045 │ 1.01267 │ 1.01599 │; > │ CPU │ 100000000 │ 31.6534 │ 1.01267 │ 1.01599 │; > └───────────────┴─────────────┴──────────┴─────────┴─────────┘; >; > Lagrangian particle tracking relative performance (GPU); > ┌───────────────┬─────────────┬──────────┬─────────┬─────────┐; > │ Architectures │ N_particles │ slowdown │ memory │ allocs │; > ├───────────────┼─────────────┼──────────┼─────────┼─────────┤; > │ GPU │ 0 │ 1.0 │ 1.0 │ 1.0 │; > │ GPU │ 1 │ 1.02262 │ 1.01395 │ 1.0135 │; > │ GPU │ 10 │ 1.02786 │ 1.01314 │ 1.00947 │; > │ GPU │ 100 │ 1.02347 │ 1.01314 │ 1.00947 │; > │ GPU │ 1000 │ 1.02548 │ 1.01395 │ 1.0135 │; > │ GPU │ 10000 │ 1.0309 │ 1.01314 │ 1.00947 │; > │ GPU │ 100000 │ 1.02327 │ 1.01314 │ 1.00947 │; > │ GPU │ 1000000 │ 1.03536 │ 1.01395 │ 1.0135 │; > │ GPU │ 10000000 │ 1.31966 │ 1.01391 │ 1.01332 │; > │ GPU │ 100000000 │ 4.20799 │ 1.01317 │ 1.00964 │; > └───────────────┴─────────────┴──────────┴─────────┴─────────┘; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQS3WD4CLJSVF23H433SRME",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982:5392,perform,performance,5392,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982,1,['perform'],['performance']
Performance,"5] @doc(::LineNumberNode, ::Module, ::String, ::Vararg{Any,N} where N) at ./boot.jl:459; [6] include at ./boot.jl:326 [inlined]; [7] include_relative(::Module, ::String) at ./loading.jl:1038; [8] include at ./sysimg.jl:29 [inlined]; [9] include(::String) at /home/travis/build/climate-machine/Oceananigans.jl/src/Oceananigans.jl:1; [10] top-level scope at none:0; [11] include at ./boot.jl:326 [inlined]; [12] include_relative(::Module, ::String) at ./loading.jl:1038; [13] include(::Module, ::String) at ./sysimg.jl:29; [14] top-level scope at none:2; [15] eval at ./boot.jl:328 [inlined]; [16] eval(::Expr) at ./client.jl:404; [17] top-level scope at ./none:3; in expression starting at /home/travis/build/climate-machine/Oceananigans.jl/src/poisson_solvers.jl:173; in expression starting at /home/travis/build/climate-machine/Oceananigans.jl/src/poisson_solvers.jl:171; in expression starting at /home/travis/build/climate-machine/Oceananigans.jl/src/poisson_solvers.jl:171; in expression starting at /home/travis/build/climate-machine/Oceananigans.jl/src/Oceananigans.jl:149; ERROR: LoadError: Failed to precompile Oceananigans [6e00b360-fae3-11e8-3922-3d7cb9e50aad] to /home/travis/.julia/compiled/v1.1/Oceananigans/VuIZ2.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1197; [3] _require(::Base.PkgId) at ./loading.jl:960; [4] require(::Base.PkgId) at ./loading.jl:858; [5] require(::Module, ::Symbol) at ./loading.jl:853; [6] include at ./boot.jl:326 [inlined]; [7] include_relative(::Module, ::String) at ./loading.jl:1038; [8] include(::Module, ::String) at ./sysimg.jl:29; [9] exec_options(::Base.JLOptions) at ./client.jl:267; [10] _start() at ./client.jl:436; in expression starting at /home/travis/build/climate-machine/Oceananigans.jl/docs/make.jl:5; The command ""julia --project=docs/ docs/make.jl"" exited with 1.; Skipping the after_success step, as specified in the configuration.; Done. Your build exited with 1.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/153#issuecomment-477579168:4870,Load,LoadError,4870,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/153#issuecomment-477579168,6,"['Load', 'load']","['LoadError', 'loading']"
Performance,7.22 KiB │ 11561 │; > │ GPU │ 100000000 │ 4.910 ms │ 18.629 ms │ 17.245 ms │ 18.757 ms │ 896.56 KiB │ 11519 │; > └───────────────┴─────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; >; > Lagrangian particle tracking CPU -> GPU; > speedup; > ┌─────────────┬─────────┬─────────┬─────────┐; > │ N_particles │ speedup │ memory │ allocs │; > ├─────────────┼─────────┼─────────┼─────────┤; > │ 0 │ 82.2319 │ 3.01565 │ 6.08156 │; > │ 1 │ 83.1848 │ 3.01946 │ 6.06663 │; > │ 10 │ 83.6845 │ 3.01704 │ 6.0425 │; > │ 100 │ 84.1322 │ 3.01704 │ 6.0425 │; > │ 1000 │ 84.6106 │ 3.01946 │ 6.06663 │; > │ 10000 │ 84.072 │ 3.01704 │ 6.0425 │; > │ 100000 │ 86.1581 │ 3.01704 │ 6.0425 │; > │ 1000000 │ 106.432 │ 3.01946 │ 6.06663 │; > │ 10000000 │ 254.889 │ 3.01935 │ 6.06558 │; > │ 100000000 │ 618.565 │ 3.01714 │ 6.04355 │; > └─────────────┴─────────┴─────────┴─────────┘; >; > Lagrangian particle tracking relative performance (CPU); > ┌───────────────┬─────────────┬──────────┬─────────┬─────────┐; > │ Architectures │ N_particles │ slowdown │ memory │ allocs │; > ├───────────────┼─────────────┼──────────┼─────────┼─────────┤; > │ CPU │ 0 │ 1.0 │ 1.0 │ 1.0 │; > │ CPU │ 1 │ 1.03447 │ 1.01267 │ 1.01599 │; > │ CPU │ 10 │ 1.04601 │ 1.01267 │ 1.01599 │; > │ CPU │ 100 │ 1.04712 │ 1.01267 │ 1.01599 │; > │ CPU │ 1000 │ 1.05514 │ 1.01267 │ 1.01599 │; > │ CPU │ 10000 │ 1.05397 │ 1.01267 │ 1.01599 │; > │ CPU │ 100000 │ 1.07213 │ 1.01267 │ 1.01599 │; > │ CPU │ 1000000 │ 1.34006 │ 1.01267 │ 1.01599 │; > │ CPU │ 10000000 │ 4.09045 │ 1.01267 │ 1.01599 │; > │ CPU │ 100000000 │ 31.6534 │ 1.01267 │ 1.01599 │; > └───────────────┴─────────────┴──────────┴─────────┴─────────┘; >; > Lagrangian particle tracking relative performance (GPU); > ┌───────────────┬─────────────┬──────────┬─────────┬─────────┐; > │ Architectures │ N_particles │ slowdown │ memory │ allocs │; > ├───────────────┼─────────────┼──────────┼─────────┼─────────┤; > │ GPU │ 0 │ 1.0 │ 1.0 │ 1.0 │; > │ GPU │ 1 │ 1.022,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982:4594,perform,performance,4594,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982,1,['perform'],['performance']
Performance,7.22 KiB │ 11561 │; │ GPU │ 100000000 │ 4.910 ms │ 18.629 ms │ 17.245 ms │ 18.757 ms │ 896.56 KiB │ 11519 │; └───────────────┴─────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Lagrangian particle tracking CPU -> GPU; speedup; ┌─────────────┬─────────┬─────────┬─────────┐; │ N_particles │ speedup │ memory │ allocs │; ├─────────────┼─────────┼─────────┼─────────┤; │ 0 │ 82.2319 │ 3.01565 │ 6.08156 │; │ 1 │ 83.1848 │ 3.01946 │ 6.06663 │; │ 10 │ 83.6845 │ 3.01704 │ 6.0425 │; │ 100 │ 84.1322 │ 3.01704 │ 6.0425 │; │ 1000 │ 84.6106 │ 3.01946 │ 6.06663 │; │ 10000 │ 84.072 │ 3.01704 │ 6.0425 │; │ 100000 │ 86.1581 │ 3.01704 │ 6.0425 │; │ 1000000 │ 106.432 │ 3.01946 │ 6.06663 │; │ 10000000 │ 254.889 │ 3.01935 │ 6.06558 │; │ 100000000 │ 618.565 │ 3.01714 │ 6.04355 │; └─────────────┴─────────┴─────────┴─────────┘; ```. ```; Lagrangian particle tracking relative performance (CPU); ┌───────────────┬─────────────┬──────────┬─────────┬─────────┐; │ Architectures │ N_particles │ slowdown │ memory │ allocs │; ├───────────────┼─────────────┼──────────┼─────────┼─────────┤; │ CPU │ 0 │ 1.0 │ 1.0 │ 1.0 │; │ CPU │ 1 │ 1.03447 │ 1.01267 │ 1.01599 │; │ CPU │ 10 │ 1.04601 │ 1.01267 │ 1.01599 │; │ CPU │ 100 │ 1.04712 │ 1.01267 │ 1.01599 │; │ CPU │ 1000 │ 1.05514 │ 1.01267 │ 1.01599 │; │ CPU │ 10000 │ 1.05397 │ 1.01267 │ 1.01599 │; │ CPU │ 100000 │ 1.07213 │ 1.01267 │ 1.01599 │; │ CPU │ 1000000 │ 1.34006 │ 1.01267 │ 1.01599 │; │ CPU │ 10000000 │ 4.09045 │ 1.01267 │ 1.01599 │; │ CPU │ 100000000 │ 31.6534 │ 1.01267 │ 1.01599 │; └───────────────┴─────────────┴──────────┴─────────┴─────────┘; ```. ```; Lagrangian particle tracking relative performance (GPU); ┌───────────────┬─────────────┬──────────┬─────────┬─────────┐; │ Architectures │ N_particles │ slowdown │ memory │ allocs │; ├───────────────┼─────────────┼──────────┼─────────┼─────────┤; │ GPU │ 0 │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ 1 │ 1.02262 │ 1.01395 │ 1.0135 │; │ GPU │ 10 │ 1.02786 │ 1.01314 │ ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975:4056,perform,performance,4056,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975,1,['perform'],['performance']
Performance,"7.257 ms │ 15.907 ms │ 15.044 ms │ 15.927 ms │ 27.97 KiB │ 292 │; └───────────────┴─────┴───────────────────────────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┘; ```. ### CPU to GPU speedup. ```; FFT-based Poisson solver CPU -> GPU speedup; ┌─────┬───────────────────────────────┬─────────┬────────┬────────┐; │ Ns │ Topologies │ speedup │ memory │ allocs │; ├─────┼───────────────────────────────┼─────────┼────────┼────────┤; │ 256 │ (Bounded, Bounded, Bounded) │ 35.4428 │ 450.0 │ 224.5 │; │ 256 │ (Bounded, Periodic, Bounded) │ 36.8697 │ 368.4 │ 320.5 │; │ 256 │ (Periodic, Bounded, Bounded) │ 37.0953 │ 369.6 │ 323.5 │; │ 256 │ (Periodic, Periodic, Bounded) │ 53.4034 │ 179.0 │ 146.0 │; └─────┴───────────────────────────────┴─────────┴────────┴────────┘; ```. ### CPU relative performance. ```; FFT-based Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.61224 │ 1.2 │ 2.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.34917 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.35141 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴────────┴────────┘; ```. ### GPU relative performance. ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 2.42923 │ 3.01676 │ 3.07534 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.95419 │ 2.0581 │ 2.19521 │; │ GPU │ 256 │ (Periodic, Bounded, Bo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:11779,perform,performance,11779,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050,1,['perform'],['performance']
Performance,"90% sure, but if it's not there it's in `centered_reconstruction.jl` or `upwind_biased_reconstruction.jl`; I haven't gotten around to test performance for non-weno schemes but I should do it.... I ll guess I ll dedicate today to searching the issue, so we can merge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185584632:139,perform,performance,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185584632,1,['perform'],['performance']
Performance,"::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [26] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [27] _require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1803; │ [28] macro expansion; │ @ ./loading.jl:1790 [inlined]; │ [29] macro expansion; │ @ ./lock.jl:267 [inlined]; │ [30] __require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1753; │ [31] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [32] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [33] require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1746; │ [34] eval; │ @ ./boot.jl:385 [inlined]; │ [35] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; │ [36] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; │ [37] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; │ [38] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; │ [39] run_repl(repl::REPL.AbstractREPL, consumer::Any); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; │ [40] (::Base.var""#1013#1015""{Bool, Bool, Bool})(REPL::Module); │ @ Base ./client.jl:432; │ [41] #invokelatest#2; │ @ ./essentials.jl:892 [inlined]; │ [42] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [43] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); │ @ Base ./client.jl:416; │ [44] exec_options(opts::Base.JLOptions); │ @ Base ./client.jl:333; │ [45] _start(); │ @ Base ./client.jl:552; └ @ Base loading.jl:1301; ```. perhaps some compat entry is needed? I get this w GLMakie v0.10.5 in my main Julia env....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:5213,load,loading,5213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics/math.jl:5; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /home/tomas/.julia/compiled/v1.6/CUDA/jl_q4lPlx.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; [7] include; @ ./Base.jl:386 [inlined]; [8] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [9] top-level scope; @ none:1; [10] eval; @ ./boot.jl:360 [inlined]; [11] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [12] top-level scope; @ none:1; in expression starting at /home/tomas/repos/Oceananigans.jl/src/Oceananigans.jl:1; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /home/tomas/.julia/compiled/v1.6/Oceananigans/jl_psrPk0.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371:2177,load,loading,2177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371,1,['load'],['loading']
Performance,"; > > ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there may not be a need for using explicit dissipation right now, so we might as well do the easy thing and avoid",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226:1057,perform,perform,1057,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226,1,['perform'],['perform']
Performance,; GPU Link Info; PCIe Generation; Max : 3; Current : 3; Device Current : 3; Device Max : 3; Host Max : 3; Link Width; Max : 16x; Current : 16x; Bridge Chip; Type : N/A; Firmware : N/A; Replays Since Reset : 0; Replay Number Rollovers : 0; Tx Throughput : 0 KB/s; Rx Throughput : 0 KB/s; Atomic Caps Inbound : N/A; Atomic Caps Outbound : N/A; Fan Speed : N/A; Performance State : P0; Clocks Throttle Reasons; Idle : Active; Applications Clocks Setting : Not Active; SW Power Cap : Not Active; HW Slowdown : Not Active; HW Thermal Slowdown : Not Active; HW Power Brake Slowdown : Not Active; Sync Boost : Not Active; SW Thermal Slowdown : Not Active; Display Clock Setting : Not Active; FB Memory Usage; Total : 32768 MiB; Reserved : 267 MiB; Used : 0 MiB; Free : 32500 MiB; BAR1 Memory Usage; Total : 32768 MiB; Used : 2 MiB; Free : 32766 MiB; Compute Mode : Default; Utilization; Gpu : 0 %; Memory : 0 %; Encoder : 0 %; Decoder : 0 %; Encoder Stats; Active Sessions : 0; Average FPS : 0; Average Latency : 0; FBC Stats; Active Sessions : 0; Average FPS : 0; Average Latency : 0; Ecc Mode; Current : Enabled; Pending : Enabled; ECC Errors; Volatile; Single Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : N/A; Total : 0; Double Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : 0; Total : 0; Aggregate; Single Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : N/A; Total : 0; Double Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : 0; Total : 0; Retired Pages; Single Bit ECC : 0; Double Bit ECC : 0; Pending Page Blacklist : No; Remapped Rows : N/A; Temperature; GPU Current Temp : 41 C; GPU Shutdown Temp : 90 C; GPU Slowdown Temp : 87 C; GPU Max Operating Temp : 83 C; GPU Target Temperature : N/A; Memory Curre,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:21199,Latency,Latency,21199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Latency'],['Latency']
Performance,"; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_zRopeZ"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:3299,load,loading,3299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"; | ErrorException(""could not load library ""libopenblas64_""; &nbsp; | libopenblas64_.so: ELF load command past end of file""); &nbsp; | ┌ Error: Error during initialization of module CHOLMOD; &nbsp; | │ exception =; &nbsp; | │ could not load library ""libcholmod""; &nbsp; | │ libopenblas64_.so.0: ELF load command past end of file; &nbsp; | │ Stacktrace:; &nbsp; | │ [1] dlopen(::String, ::UInt32; throw_error::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109; &nbsp; | │ [2] dlopen at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:951; &nbsp; | [2] unsafe_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:1005; &nbsp; | [3] write(::Base.PipeEndpoint, ::String) at ./strings/io.jl:183; &nbsp; | [4] create_expr_cache(::String, ::String, ::Array{Pair{Base.PkgId,UInt64},1}, ::Base.UUID) at ./loading.jl:1194; &nbsp; | [5] compilecache(::Base.PkgId, ::String) at ./loading.jl:1286; &nbsp; | [6] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [7] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [8] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilA",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:3480,load,loading,3480,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['loading']
Performance,"; │ @ ./loading.jl:2340 [inlined]; │ [4] (::Base.var""#968#969""{Base.PkgId})(); │ @ Base ./loading.jl:1974; │ [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; │ [6] #mkpidlock#6; │ @ ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; │ [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined]; │ [9] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); │ @ Base ./loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::S",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:2324,load,loading,2324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"<td style = ""text-align: right; "">LinearEquationOfState</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">RoquetEquationOfState</td>; <td style = ""text-align: right; "">1.14378</td>; <td style = ""text-align: right; "">1.00266</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">TEOS10EquationOfState</td>; <td style = ""text-align: right; "">1.32274</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; </table>. <table>; <caption style = ""text-align: center; "">Equation of state relative performance (GPU)</caption>; <tr class = ""header headerLastRow"">; <th style = ""text-align: right; "">Architectures</th>; <th style = ""text-align: right; "">EquationsOfState</th>; <th style = ""text-align: right; "">slowdown</th>; <th style = ""text-align: right; "">memory</th>; <th style = ""text-align: right; "">allocs</th>; </tr>; <tr>; <td style = ""text-align: right; "">GPU</td>; <td style = ""text-align: right; "">LinearEquationOfState</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">GPU</td>; <td style = ""text-align: right; "">RoquetEquationOfState</td>; <td style = ""text-align: right; "">1.00497</td>; <td style = ""text-align: right; "">1.00222</td>; <td style = ""text-align: right; "">1.00018</td>; </tr>; <tr>; <td style = ""text-align: right; "">GPU</td>; <td style = ""text-align: right; "">TEOS10EquationOfState</td>; <td style = ""text-align: right; "">1.02813</td>; <td style = ""text-align: right; "">0.999823</td>; <td style = ""text-align: right; "">1.00018</td>; </tr>; </table>. ## Static ocean benchmarks. <table>; <caption style = ""text-align: center; "">Incompr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594:10255,perform,performance,10255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594,1,['perform'],['performance']
Performance,"> ""Done"" isn't very precise since the cubed sphere will never be ""done"". But perhaps we can put a number on performance for the first milestone, which will allow us to conclude whether we need this optimization or not. True. Ideally we want to be close to the scalings/performance we got with lat-lon grid? That’s perhaps not feasible..? I don’t know how close is good enough tho. . > Can you explain where the gut feeling comes from? Will filling halos be so expensive even on just one GPU, or is this a distributed problem? Currently, 1/4 degree is performant on one GPU. Well at least some gut feeling comes from that am pretty sure that it can be reduced in half by getting done in a single pass. But you are on point, I don’t have a gut feeling regarding how much impact the two passes have on performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718757478:108,perform,performance,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718757478,5,"['optimiz', 'perform']","['optimization', 'performance', 'performant']"
Performance,"> * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition. The docs preview hasn't updated yet, so I can't see the video, but I suspect removing `v` as a background creates oscillations. @glwagner have you checked? If not, let's wait for the video to see what happens... > * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Good move :+1: . > * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; > * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated). I tried to make it 100% GPU friendly actually (although I didn't test it). You already pointed out one flaw, which is the use of an array instead of a tuple for the unit vertical vector. > * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity. This only happens with me when the NetCDF file is open by another program (generally python in my case) while Julia is trying to write to it. Was that the case? If so, that's the usual behavior afaik and I don't think we can do anything on our end except inform users about it. > * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?. If we can get away with t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138:865,perform,perform,865,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138,1,['perform'],['perform']
Performance,"> 90% sure, but if it's not there it's in `centered_reconstruction.jl` or `upwind_biased_reconstruction.jl` I haven't gotten around to test performance for non-weno schemes but I should do it....; > ; > I ll guess I ll dedicate today to searching the issue, so we can merge. `@inbounds` in . https://github.com/CliMA/Oceananigans.jl/blob/91dfb119917f33514dbf8cd833778c44f6cea9b3/src/Advection/weno_interpolants.jl#L45-L46",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185611545:140,perform,performance,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185611545,1,['perform'],['performance']
Performance,"> === means that ""no program can distinguish"" between the objects. For arrays this basically means they point to the same space in memory; changes to one imply changes in another. == is a weaker statement, usually about numerical equality. What's counter intuitive?. Oh yeah I know about `===`. What I mean is that you test two grids with `==`, but Julia then tests each property with `===`. So the user is actually performing a much stricter operation than what it seems at first sight. That's the un-intuitive part to me. Although I may be missing something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945862255:416,perform,performing,416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945862255,1,['perform'],['performing']
Performance,"> > 90% sure, but if it's not there it's in `centered_reconstruction.jl` or `upwind_biased_reconstruction.jl` I haven't gotten around to test performance for non-weno schemes but I should do it....; > > I ll guess I ll dedicate today to searching the issue, so we can merge; > ; > `@inbounds` in; > ; > https://github.com/CliMA/Oceananigans.jl/blob/91dfb119917f33514dbf8cd833778c44f6cea9b3/src/Advection/weno_interpolants.jl#L45-L46. I'm not sure that this is the deal breaker... I should have phrased is as a ""perhaps add @inbounds in.... ???""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185612738:142,perform,performance,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185612738,1,['perform'],['performance']
Performance,"> > > > @glwagner any idea why `gpu-simulations-tests` fail?; > > > ; > > > ; > > > Which grid points are specifically failing in the test?; > > ; > > ; > > How does one go about and answers this question? The log is not informative... Shall I run the tests myself online and then printout the two arrays?; > ; > Yeah, that's what you have to do to determine it... not urgent though... I tried to do that but the HPC at ANU when I use a queue with GPU access it does not have internet access. So it stops at `include(""data_dependencies.jl"")` line...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330:437,queue,queue,437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330,1,['queue'],['queue']
Performance,"> > > The preview isn't showing for me. But we can fix any issues later, so I say merge away.; > > ; > > ; > > Yeah, It's also not loading for me. It feels like whenever I try to check PR previews it's kinda hit or miss. I wonder if this is an issue with Documenter.; > > But if you're okay with it, I'll merge it and we can fix any problems later.; > ; > It looks like it works for PRs that I submit, but not others. It may have to do with repo privileges. I think, for some reason whatsoever, the preview is not pushed just from the first commit. I think it's because there is a test whether that was a commit on a PR. And unless you first open the PR and then made the first commit that test returns false...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963656757:131,load,loading,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963656757,1,['load'],['loading']
Performance,> > @TZTsai thanks for this! I'm wondering whether this worths your time and effort since after we [removed](https://github.com/CliMA/Oceananigans.jl/pull/3052) the multigrid pressure solver from the code perhaps this is not so much needed.; > ; > Alright. But is `compute_matrix_for_linear_operation` still used in this project? If so it may still provide some optimization. @navidcy can you answer @TZTsai's question?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1708642106:362,optimiz,optimization,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1708642106,1,['optimiz'],['optimization']
Performance,> > @TZTsai thanks for this! I'm wondering whether this worths your time and effort since after we [removed](https://github.com/CliMA/Oceananigans.jl/pull/3052) the multigrid pressure solver from the code perhaps this is not so much needed.; > ; > Alright. But is `compute_matrix_for_linear_operation` still used in this project? If so it may still provide some optimization. Sorry I missed the question!. I think in principle it could be used for the construction of the Heptadiagonal solver matrix (cc @simone-silvestri) but even for that the matrix is actually hardcoded for the particular free-surface problem. Right @simone-silvestri?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1711066770:362,optimiz,optimization,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1711066770,1,['optimiz'],['optimization']
Performance,"> > @siddharthabishnu, `CUDA.@allowscalar` introduced by [3cdd470](https://github.com/CliMA/Oceananigans.jl/pull/3488/commits/3cdd4705fedf3238d8858bb0f56e9b27b01ba34a) is detrimental for performance. Like it induces O(10-100x) slowdown I think....; > > Is this a temporary solution?; > > cc @glwagner, @simone-silvestri; > ; > I think it is. We can try to see if this works on one GPU. If it does we can keep the allowscalar for the moment otherwise we can remove them. In the end all this will have to live in a kernel. Note that this will still not work on multiple GPUs as you cannot explicitly access one region from another one on a different GPU without switching to the device that holds the data. @simone-silvestri and @navidcy, I totally agree. I only introduced CUDA.@allowscalar under the impression it was necessary for certain GPU tests to pass. However, now understanding that isn’t the case, I've removed it in commit [7f54c3c](https://github.com/CliMA/Oceananigans.jl/pull/3488/commits/7f54c3c451c9753524056d45c6578a9cf865be68).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2035930379:187,perform,performance,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2035930379,1,['perform'],['performance']
Performance,"> > @siddharthabishnu, how do we know that now the metrics are filled correctly? you were comparing with a grid from MITgcm?; > ; > Yes. Consider the following sources for the grid metrics:; > ; > 1. the `cs32` grid with one halo layer, used by:; > ; > * Ali for the Rossby-Haurwitz test case in Oceananigans v0.82.0; and; > * yourself to check the interior coordinates and grid metrics of the Oceananigans `cc32` grid;; > 2. the `cs32` grid with 4 halo layers created by @jm-c using MITgcm;; > 3. the `cc32` grid created by Oceananigans.; > ; > In the validation scripts for solid body rotation and the Rossby-Haurwitz wave within the `ncc-glw/cubed-sphere-dynamics` branch associated with PR #3306, I compared the metrics of grid (3) against both (1) and (2), and plotted their absolute and relative differences. With the latest modifications, these differences have been minimized though not entirely eliminated. OK, so the benchmark is the `cs32` grid by MITgcm. Can we do the comparison in this PR? I'd like to see a test ideally because otherwise how do we assess that the changes we are suggesting here are correct. I can also do that, just give me a code snippet that loads the two grids?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1978039025:1176,load,loads,1176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1978039025,1,['load'],['loads']
Performance,"> > @simone-silvestri will the changes here impact CATKE on [CliMA/ClimaOcean.jl#17](https://github.com/CliMA/ClimaOcean.jl/pull/17) ?; > ; > not on the GPU, this PR affects only CPU performance. sorry, I was not clear... I was asking whether any syntax for adding parametrization with additional tracers changed. (But I think, no, right?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1487536293:183,perform,performance,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1487536293,1,['perform'],['performance']
Performance,"> > As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models).; > ; > I agree, but this patch-up will not work for immersed boundaries anyway. What do you mean? What patch-up?. > I still advocate for (maybe not now but later down the line) a general line of thought that ensures consistency between immersed boundaries and ""regular"" boundaries (a la MITgcm) treating them always the same way. I agree I think that would be nice. It means that operators need to know about boundary conditions though, which is a major refactor... > As an example, this issue could have been brought up for immersed boundaries, which would have required a (definitely more lengthy) rework of boundaries in abstract operations but would have solved the issue in both boundaries and immersed boundaries. We support values and gradients on non-immersed boundaries, but we do _not_ support evaluating them across immersed boundaries. We have to support what we claim / say that we support, that is the only issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786:434,perform,performance,434,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786,1,['perform'],['performance']
Performance,"> > Average reduction with conditional expressions, e.g., like; > > https://github.com/CliMA/Oceananigans.jl/blob/748feab10a55fa65a46455620203252a6fc0646e/test/test_field_reductions.jl#L107; > > ; > > induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,; > > ```julia; > > @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > Only mentioning this here in case it might something in the source code that could be affecting code performance.; > ; > The condition should be a function of `f(i, j, k, grid, args...)` returning a boolean, or an `AbstractArray` of booleans.; > ; > We should implement boolean operations with fields to return boolean fields, so we will be able to pass an `AbstractOperation`; > ; > ```; > condition = T > 3 # This should be a boolean AbstractOperation; > @compute Txyz = Field(Average(T; condition)) ; > ```; > ; > at the moment the best way to specify a condition is through a function; > ; > ```; > @inline condition(i, j, k, grid, T) = T[i, j, k] > 3; > @compute Txyz = Field(Average(T; condition)) ; > ```. Agree with this. What is `T .> 3`? Is that a field? Either way, what we really want is to pass `T > 3` as @simone-silvestri says.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1239601022:559,perform,performance,559,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1239601022,1,['perform'],['performance']
Performance,"> > Average reduction with conditional expressions, e.g., like; > > https://github.com/CliMA/Oceananigans.jl/blob/748feab10a55fa65a46455620203252a6fc0646e/test/test_field_reductions.jl#L107; > > ; > > induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,; > > ```julia; > > @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > Only mentioning this here in case it might something in the source code that could be affecting code performance.; > ; > The condition should be a function of `f(i, j, k, grid, args...)` returning a boolean, or an `AbstractArray` of booleans.; > ; > We should implement boolean operations with fields to return boolean fields, so we will be able to pass an `AbstractOperation`; > ; > ```; > condition = T > 3 # This should be a boolean AbstractOperation; > @compute Txyz = Field(Average(T; condition)) ; > ```; > ; > at the moment the best way to specify a condition is through a function; > ; > ```; > @inline condition(i, j, k, grid, T) = T[i, j, k] > 3; > @compute Txyz = Field(Average(T; condition)) ; > ```. I get an error... ```Julia; navidcy@tartarus:~/Oceananigans.jl$ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.1 (2022-09-06); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> using Oceananigans; [ Info: Oceananigans will use 4 threads. julia> using Oceananigans.Fields: CenterField, @compute. julia> trilinear(x, y, z) = x + y + z; trilinear (generic function with 1 method). julia> arch = GPU(); GPU(). julia> grid = RectilinearGrid(arch, size = (2, 2, 2),; x = (0, 2), y = (0, 2), z = (0, 2),; topology = (Periodic, Periodic, Bounded)); 2×2×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 2.0) regularly spaced with Δx=1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568:559,perform,performance,559,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568,1,['perform'],['performance']
Performance,"> > Can't we just plot a fixed-color shape on top on the mount on all panels? [`Makie.poly`](https://docs.makie.org/stable/reference/plots/poly/) seems to be able to do that.; > ; > We can.; > ; > We can also mask the output after we load it, e.g, via; > ; > using something like; > ; > ```julia; > using Oceananigans.ImmersedBoundaries: mask_immersed_field!; > ; > function mask_and_get_interior(φ_t, n; value=NaN); > mask_immersed_field!(φ_t[n], value); > return interior(φ_t[n], :, 1, :); > end; > ; > u′ₙ = @lift mask_and_get_interior(u′_t, $n); > ```; > ; > which gives; > ; > internal_tide.mp4 ; > But either of these solutions complicate the example a bit. Ideally, `mask_immersed_field!` should not be user-facing. And plotting a mountain on top of the mountain is a bit of a hack and would require a bit of explaining and justifying why we do that. I think we should mask the solution during visualization in the script. This is actually what users will need to do currently to make decent visualizations, so it is good to illustrate how to do it --- even if, hopefully, we will eventually have a better solution. As for plotting a shape on top, I'm inclined to encourage visualization that directly represents the domain / data for the purposes of an Oceananigans example. I think its ok if people want to incorporate visualizations like that in their own work but we may not want to promote it as ""the best"" way to visualize complex domains in this example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986381358:234,load,load,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986381358,1,['load'],['load']
Performance,"> > I think something like you're proposing would have added to my confusion.; > ; > Isn't the confusion a problem with the output writers API? I think it sounds like a great idea to support `AbstractOperation` output. It's kind of logical. Doing this even allows us to do some clever stuff behind the scenes, like using one underlying array to store the results of multiple computations performed serial (thus saving memory). The confusion is that I wasn't aware that that a `Field` has `data`, and therefore takes up memory, which allows it to store values. While an `AbstractOperation` is just instructions on how to compute things. This extended to the output writers, but I wouldn't say output writers were the source of confusion. If we make it so that users don't have to know what a `Field` is and we can use abstract operations everywhere, then my comment is moot.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036795591:388,perform,performed,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036795591,1,['perform'],['performed']
Performance,"> > I think to preserve the work in this PR, we should add a `Float32` test which will fail if a spurious promotion undermines performance; > ; > Agreed. I'll revisit this PR later to see if I can find where the conversion happens. The test I added only checks to see if we can take a time step. But I should be able to also add a test to ensure no spurious promotion occurred. Ah, that will work as a test if we remove the `convert`. The `convert` is a good sanity check to find where the problem is, but its not a solution since it merely allows the code to run without error --- it doesn't actually allow us to realize the benefits of using `Float32`. Arguably with this it is actually worse to use `Float32`, since the numerics are degraded bbut the perfrmance benefit is not fully realized",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445330720:127,perform,performance,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445330720,1,['perform'],['performance']
Performance,"> > I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors.; > ; > That's a good point. Although I think we could avoid creating another page and put that information in the [""Using GPUs""](https://clima.github.io/OceananigansDocumentation/stable/using_gpus/) page, so that things are more condensed. 🤦 there's already Using GPUs of course, silly me...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818368200:118,perform,performance,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818368200,2,"['optimiz', 'perform']","['optimizations', 'performance']"
Performance,"> > If our objective purely regards broadcasting, then we could probably generalize broadcasting so that `Fields` with singleton indices and/or `Nothing` location act more like reduced-dimensionality arrays. Is that what you would like to see?; > ; > Yes, it would be nice to have that feature. Do you want to have a crack at it? I don't use broadcasting with fields so much personally. It's a bit slow for some reason, which we have never quite figured out. Convenient for some things but not to be relied on unless we can solve the performance issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038969357:534,perform,performance,534,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038969357,1,['perform'],['performance']
Performance,"> > The preview isn't showing for me. But we can fix any issues later, so I say merge away.; > ; > Yeah, It's also not loading for me. It feels like whenever I try to check PR previews it's kinda hit or miss. I wonder if this is an issue with Documenter.; > ; > But if you're okay with it, I'll merge it and we can fix any problems later. It looks like it works for PRs that I submit, but not others. It may have to do with repo privileges.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963592320:119,load,loading,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963592320,1,['load'],['loading']
Performance,"> > To use python, we'd have to invoke `PyCall` right? Running python directly in the CI is possible but a bit of work and might be a pain to maintain.; > > I think its ""good"" to illustrate python usage, but also building and maintaining that example requires work that might be put to better use elsewhere... I'd shy away from doing this until there's either a more compelling need, or we have more resources for code development / maintenance...; > ; > Yes I think we'd need to use `Pycall`. I agree that's hard to maintain so let's not pursue that now.; > ; > I still think it'd be good to show one example with `NetCDF` writer though. Here's a question: is post-processing results directly in julia (making animations, plots, etc.) using the `NetCDF` output as easy as with the `jld2` output?. There's currently one example with NetCDF: https://clima.github.io/OceananigansDocumentation/stable/generated/shallow_water_Bickley_jet/. I'm not totally sure what's meant by easy. If plotting arrays, then the tasks are identical. If using `FieldTimeSeries` (to perform non-trivial finite volume calculations in post-processing for example) then that isn't supported with `NetCDFOutputWriter` (this is possible, but requires someone passionate about NetCDF to put in the effort there).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-954122449:1060,perform,perform,1060,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-954122449,1,['perform'],['perform']
Performance,"> > Very nice work @glwagner , and thanks for making this. Lots of good stuff here.; > > In your calculations, you find that there is saturation at 16 threads. I might guess that you have 16 cores on one node? I would think that this should be node dependent.; > > Also, in the table, might it be possible to compute the efficiency as well? I think that's more standard than speed up.; > ; > Ah, this machine has 48 cores. Since threading has an overhead cost, we expect saturation at some point. It's surprising that this happens at just 16 cores for such a large problem (512^3) though.; > ; > We can calculate more metrics for sure.; > ; > I think it would be worthwhile to investigate whether other threading paradigms scale differently for the same problem. Numba + parallel accelerator might be a good test case. @hennyg888 would you be interested in that?; > ; > Here are some docs:; > ; > https://numba.pydata.org/numba-doc/latest/user/parallel.html. You run out of memory bandwidth at some point - usually before you get to saturate all the cores for something; like diffusion. So some of 16 thread drop off could be that. . I guess we could get even more minimalist and check a multi-threaded stream benchmark to see that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886090304:1188,multi-thread,multi-threaded,1188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886090304,1,['multi-thread'],['multi-threaded']
Performance,"> > When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; > > ```julia; > > ERROR: LoadError: UndefVarError: `settings` not defined; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; > > ```julia; > > ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; > > ```; > ; > Do you need help fixing these?. @glwagner thanks for your help on Zoom yesterday. @navidcy thanks for creating a new PR #3305 to fix the second issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747159712:220,Load,LoadError,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747159712,2,['Load'],['LoadError']
Performance,"> > Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?; > ; > I was planning was to implement the tridiagonal solve similarly to what we do for single GPU as such:; > ; > ```julia; > transpose_z_to_y!(storage) # copy data from storage.zfield to storage.yfield; > solver.plan.forward.y!(parent(storage.yfield), buffer.y) ; > transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; > solver.plan.forward.x!(parent(storage.xfield), buffer.x); > transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; > transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; > ; > # Perform the implicit vertical solve here on storage.zfield...; > ; > transpose_z_to_y!(storage); > solver.plan.backward.y!(parent(storage.yfield), buffer.y); > transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; > solver.plan.backward.y!(parent(storage.xfield), buffer.x); > transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; > transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; > ```; > ; > This is not super great because it requires eight transposes, but I think it's the same thing that was happening in #2538. Can you just say, you are planning to implement the algorithm in #2538? The way you describe it, I can't figure out if you are coming up with something new or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197393925:837,Perform,Perform,837,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197393925,1,['Perform'],['Perform']
Performance,"> > Yeah this is pretty worrying... I'm pretty sure this is the cause of #1420 which has been open for a while so this slowdown must have been around for a while (and just flew under the radar). [Profiling](https://docs.julialang.org/en/v1/manual/profile/) might help pinpoint the bottleneck.; > ; > It looks like there are some extra temporary arrays being created for the cases with non-trivial (although still pretty trivial) indexing patterns. Profiling could be good - also just turning off as much as possible and then building up from the FFT alone, simple stencil etc... - if that is possible?. I did try with a different advection scheme (and `halo_size=(1, 1, 1)`) and the allocations were mitigated. This and @tomchor's result suggests that halo filling for periodic directions is a likely culprit. Profiling is a good idea. I also had the thought of commenting out much of the time-stepping loop and building up to try to pinpoint which functions trigger allocations as @christophernhill suggests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891521065:281,bottleneck,bottleneck,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891521065,1,['bottleneck'],['bottleneck']
Performance,"> > the time integral when we use variable time stepping that is a feature we use quite often; > ; > What do you mean by this?. Actually, I should probably say that I use the wizard quite often to change the time step. In my opinion, AB2 is a good compromise between accuracy, stability, and performance. RK3 is better only when you can achieve a CFL 3 times larger. We should fix the variable AB2 time stepper or discourage the use of frequent updates of the time step when using AB2. The first option is probably better in my opinion. I ll look into fixing AB2 and what it entails",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313376167:292,perform,performance,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313376167,1,['perform'],['performance']
Performance,> @TZTsai thanks for this! I'm wondering whether this worths your time and effort since after we [removed](https://github.com/CliMA/Oceananigans.jl/pull/3052) the multigrid pressure solver from the code perhaps this is not so much needed. Alright. But is `compute_matrix_for_linear_operation` still used in this project? If so it may still provide some optimization.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1703878093:353,optimiz,optimization,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1703878093,1,['optimiz'],['optimization']
Performance,"> @ali-ramadhan are those regressions on the CPU or GPU? On the CPU, we might need `inline` (we need inline to elide a number of potential memory allocation points I think). Not sure about GPU. Just CPU right now. They're taking too long so I'm just gonna kill it and run the GPU tests by themselves. I'd be pretty surprised if `@inline` gives a 100x performance boost but I'm still not super familiar with writing performant Julia code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496473977:351,perform,performance,351,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496473977,2,['perform'],"['performance', 'performant']"
Performance,"> @ali-ramadhan do you mind running some benchmarks to test for performance regression under this PR?. Looks really bad, still waiting on GPU results but CPU is ~100x slower! We can't merge this as is. Something must be wrong somewhere. Memory allocations went from `6.00 KiB` per iteration to `1.04 GiB` per iteration. It used to be resolution independent but now the allocation increases with the number of grid points. I'll edit this comment with the full benchmark timings when they're done. I benchmarked master yesterday so I know it's still performing well (maybe 2-3% slower because of the extra stuff and fixes we recently introduced).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496472556:64,perform,performance,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496472556,2,['perform'],"['performance', 'performing']"
Performance,"> @glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future).; > ; > 1. Rigid lid (solve for the surface pressure); > 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping); > ; > Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. I would vote for implementing a rigid lid / vertically-`Flat` mode for the hydrostatic model instead, in order to keep the shallow water model as simple as possible (generalizing to multiple layers as an alternative direction would be nice I think). Have you benchmarked this? It is true that vertically `Flat` avoids a few vertical operations in the vertical advection term but since the kernel sizes are the same I'd be surprised if the performance differences are huge in terms of cost per time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736:942,perform,performance,942,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736,1,['perform'],['performance']
Performance,"> @glwagner CUDA aware MPI is supported for 11.2 but it is only built against OpenMPI 4.1.0 and 4.1.1, I think we had previously 4.0.4. Also julia 1.6.2 is available. good beta, I'll upgrade, thanks!. > looks like maybe some more race conditions on different hardware?. Heh yeah, pretty interesting. sverdrup is running on Quadro P6000 with CUDA 11; tartarus (where we sometimes run tests for development) has a Titan V, also I think with CUDA 11. These are running on a P100? With this new CI I'll need to make sure I can log in to central to debug.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906751484:230,race condition,race conditions,230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906751484,1,['race condition'],['race conditions']
Performance,"> @glwagner I also ran into some problems using `StatProfilerHTML.jl` to make flame graphs for CPU profiles. This is from the same script used to obtain the results above and shown in #1914 and it's a 128^3 nonhydrostatic model. The flame graphs don't display the function names, and all I can see is ""overdub"". By hovering my mouse over the slabs and going up each flame stack I can usually find a function name that makes sense somewhere but that prevents us from making at-a-glance analysis of the profile flame graph.; > ![image](https://user-images.githubusercontent.com/45054739/128443657-7b18d4f9-0168-4bee-b85b-2ade021165d3.png); > I thought that this might have something to do with profiling `run(simulation, 10)` instead of a for loop of `time_step!(model,1)` but apparently the result is the same for both cases. I believe this is inevitable, because all our kernels are compiled through `Cassette.jl`, which ""overdubs"" the julia compiler when compiling functions tagged with `@kernel` (the majority of our expensive kernels). This is part of the design of `KernelAbstractions.jl`... Really great work @hennyg888. Perhaps the complexity of our function calls via `KernelAbstractions.jl` argues for a better profiling approach? Is there a way to ""filter"" the profiled output to remove data? . I think the next step towards improving performance is to figure out how to optimize the tendency calculations for CPU or GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894239292:1344,perform,performance,1344,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894239292,2,"['optimiz', 'perform']","['optimize', 'performance']"
Performance,"> @glwagner I'm not sure whats causing these tests to fail now?. @jagoosw afaik sometimes we get errors of the kind. `ERROR: LoadError: SystemError: opening file ""/data5/glwagner/.julia-10703/compiled/v1.8/Oceananigans/hU93i_Y0P9A.ji"": No such file or directory`. on the gpu tests. Which is what's hapenning now. It's now clear to me at least what the cause is, but restarting the tests generally makes them pass. I just restarted them so it be fine. I should note that we got an error of the kind. `Expression: all(test_fields.v .≈ truth_fields.v)`. in the GPU shallow water tests, which I thought were corrected. Is this something we need to worry about?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1481364658:125,Load,LoadError,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1481364658,1,['Load'],['LoadError']
Performance,"> @glwagner, regarding the; > ; > ```julia; > ERROR: LoadError: UndefVarError: bc not defined; > ```; > ; > in the Docs, is it related to; > [JuliaDocs/Documenter.jl#228](https://github.com/JuliaDocs/Documenter.jl/issues/228); > perhaps?. Nice find!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1843#issuecomment-879849296:53,Load,LoadError,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1843#issuecomment-879849296,1,['Load'],['LoadError']
Performance,"> @matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. For the moment those two elements are part of this PR.; > ; > This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft, the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult. Nice, thanks for that explanation. Why are we following 2decomp? PencilArrays has some benchmarking that shows it can compete with the fastest codes out there. I don't see anything similar for 2decomp, so I can't figure out what the motivation for following that strategy would be. I'm not sure if they are different, either. Something we do not previously support (but which is implemented in https://github.com/CliMA/Oceananigans.jl/pull/2538) was an algorithm that could support any topology with vertically-stretched grids. What is the relationship between this PR and https://github.com/CliMA/Oceananigans.jl/pull/2538, and does this PR support vertically stretched grids?. One of the main limitations of PencilArrays from our perspective is that it could not distribute an array along the first dimension. Since we almost always would like to use vertically stretched grids (and for various reasons, we may want to also compute the hydrostatic pressure with a vertical integral), ocean LES are typically distributed in x and y. Therefore, in order to support 2D domain decompositions, we were faced with somehow ch",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859:49,perform,performant,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859,1,['perform'],['performant']
Performance,"> @navidcy thanks for the commits. I am now testing the script against a free-explicit free surface and a MultiRegionGrid. @navidcy, as you may have anticipated, a MultiRegionGrid does not result in this error. Code Modification:; ```julia; #=; grid = ConformalCubedSphereGrid(; panel_size = (Nx, Ny, Nz),; z = (-1, 0),; radius = R,; horizontal_direction_halo = 6,; partition = CubedSpherePartition(; R = 1)); =#. latlongrid = LatitudeLongitudeGrid(size=(Nx, Ny, Nz),; longitude = (-90, 90),; latitude = (-45, 45),; z = (-1, 0)); grid = MultiRegionGrid(latlongrid, partition = XPartition(2)); ```; Terminal Output:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/MultiRegion/multi_region_grid.jl:102; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 7.722 days, wall time: 0 seconds; [ Info: ... simulation initialization complete (111.288 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (994.424 ms).; [ Info: Simulation is stopping after running for 0 seconds.; [ Info: Simulation time 628.319 ms equals or exceeds stop time 628.319 ms.; [ Info: Making an animation from the saved data...; ```; When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; ```; When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; ```julia; ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155:1675,Load,LoadError,1675,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155,2,['Load'],['LoadError']
Performance,> @sandreza might be a good idea to code up the case we were using the diagnose the race condition as a test and see if we can catch the race condition in CI @ali-ramadhan. Perhaps a regression test would work for this... and it'd be nice to have a regression test for the hydrostatic model too.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926695971:84,race condition,race condition,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926695971,2,['race condition'],['race condition']
Performance,"> @sangeethasankar01 are you trying to get this to run on the GPU for some specific purpose? Or is this merely an educational exercise?. I am a research scholar at IIT Madras, working under the supervision of Dr. Arjun Jagannathan. Currently, I'm exploring various problems related to flow instabilities. However, my current focus on this Kelvin-Helmholtz instability problem is purely for educational practice. I aim to understand the architecture of the code and optimize it for GPU execution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2029214744:465,optimiz,optimize,465,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2029214744,1,['optimiz'],['optimize']
Performance,"> @siddharthabishnu, `CUDA.@allowscalar` introduced by [3cdd470](https://github.com/CliMA/Oceananigans.jl/pull/3488/commits/3cdd4705fedf3238d8858bb0f56e9b27b01ba34a) is detrimental for performance. Like it induces O(10-100x) slowdown I think....; > ; > Is this a temporary solution?; > ; > cc @glwagner, @simone-silvestri. I think it is. We can try to see if this works on one GPU. If it does we can keep the allowscalar for the moment otherwise we can remove them.; In the end all this will have to live in a kernel.; Note that this will still not work on multiple GPUs as you cannot explicitly access one region from another one on a different GPU without switching to the device that holds the data.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2034043615:185,perform,performance,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2034043615,1,['perform'],['performance']
Performance,"> @simone-silvestri will the changes here impact CATKE on [CliMA/ClimaOcean.jl#17](https://github.com/CliMA/ClimaOcean.jl/pull/17) ?. not on the GPU, this PR affects only CPU performance",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486715558:175,perform,performance,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486715558,1,['perform'],['performance']
Performance,"> @xkykai do you think you could run some immersed boundary tests with this branch to make sure this change doesn’t affect your work? I think we’re interested in both performance and making sure the solution is high quality. Do you mean using the immersed pressure solver in this branch, and comparing the solution this produces with the one before this change?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1582859937:167,perform,performance,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1582859937,1,['perform'],['performance']
Performance,"> A more hierarchical organization of the docs is; > ; > 1. Introduction; > ; > * What's Oceananigans?; > * Installation; > * Writing your first script; > 2. Examples; > 3. Model setup; > ; > * Fields, BoundaryCondition, and AbstractOperations; > * IncompressibleModel; > * HydrostaticFreeSurfaceModel; > * ShallowWaterModel; > * Setting initial conditions; > * Diffusion, viscosity, and TurbulenceClosures; > * Forcing functions; > * Coriolis forces; > * Buoyancy forces; > 4. Simulations and post processing; > ; > * Simulation; > * OutputWriters; > * OutputReaders, post-processing, and plotting; > 5. Useful tips; > ; > * Using Graphics Processing Units (GPUs); > * Common errors and performance pitfalls; > 6. Contributor's guide; > 7. Gallery (this should be way higher eventually, but we need more recent content to motivate that...); > 8. Physics and numerical implementation; > 9. Appendix. I wholeheartedly agree with this structure :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879265116:688,perform,performance,688,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879265116,1,['perform'],['performance']
Performance,"> Ah interesting. Does this work because broadcasting over GPU subarray views is a little rough around the edges?; > ; > Also, is it worth adding the MWE from [#1767 (comment)](https://github.com/CliMA/Oceananigans.jl/issues/1767#issuecomment-868793917) as a test?. Certainly _something_ is rough... I think it's ""broadcasting over ReducedField"" that's the issue here. Prior to this PR, `mean!` used a broadcast over `R::AbstractReducedField` to compute the normalization. For some reason this has data synchronicity issues on the GPU (I'm at a loss to explain why). This PR just changes that broadcast operation to compute over all members of `R`. The halo regions of `R` (presumably) aren't touched during `sum!`, so doing some extra normalization in the halos doesn't really matter, I guess... (if we want halos to be right we should probably fill them after executing `mean!` in `compute!`, or something). But the _reason_ why this change fixes the issue isn't at all obvious to me. Maybe there's a bad interaction between `KernelAbstractions` (which gets used for the broadcast) and `sum!`? Not sure. Maybe another solution would wrap `sum!` in `CUDA.@sync` (eg the solution here could _implicitly_ synchronize in order to perform the broadcast correctly; otherwise CUDA wouldn't work generally... ?!?). Might be worth testing that, though I don't know which solution we should prefer (if any). In fact, it seems better to avoid using custom broadcasting machinery if possible (which is the current solution)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-868839671:1228,perform,perform,1228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-868839671,1,['perform'],['perform']
Performance,"> Ah sorry I must have misunderstood your question. Yeah I think broadcasts; > tend to perform really well on scalar operations so I don't see why not. there is sadly a performance difference between `map`, since `broadcast` need to check dimensions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/108#issuecomment-469891336:87,perform,perform,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/108#issuecomment-469891336,2,['perform'],"['perform', 'performance']"
Performance,"> Ah thanks for pointing this out @zhenwu0728! I didn't realize that.; > ; > It also seems that `deleteat!` is not defined for `StructArray`...; > ; > ```julia; > julia> s = StructArray{ComplexF64}((randn(5), randn(5))); > 5-element StructArray(::Array{Float64,1}, ::Array{Float64,1}) with eltype Complex{Float64}:; > 0.6663581952584336 - 1.5283519296646326im; > -0.4906568589874505 - 0.325094980686686im; > 1.1453745422319603 + 0.07874273417016024im; > 1.0280155738262986 - 0.37561698848991654im; > 1.1466416201897343 - 1.1904623364760012im; > ; > julia> deleteat!(s, 2); > ERROR: MethodError: no method matching deleteat!(::StructArray{Complex{Float64},1,NamedTuple{(:re, :im),Tuple{Array{Float64,1},Array{Float64,1}}},Int64}, ::Int64); > Closest candidates are:; > deleteat!(::Array{T,1} where T, ::Integer) at array.jl:1306; > deleteat!(::Array{T,1} where T, ::Any) at array.jl:1343; > deleteat!(::BitArray{1}, ::Integer) at bitarray.jl:935; > ...; > Stacktrace:; > [1] top-level scope at REPL[13]:1; > ```. Yes, I think so. But there's `StructArrays.append!!` to add particles. I don't know why there's no `delete!!` or `deleteat!!`. Maybe we could open an issue in `StructArrays.jl`. Also we need to pay attention to the performance as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-733888198:1227,perform,performance,1227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-733888198,1,['perform'],['performance']
Performance,> Also I found it quite cumbersome in scripts when I wanted to load these constants I had to load one from `Grids` and one from `Coriolis` and one from `BuoyancyModels`.... That's a bit counterintuitive from a user's perspective. Shouldn't you be defining and setting constants in the scripts if you are doing that?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492624226:63,load,load,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492624226,2,['load'],['load']
Performance,"> Although I'm somewhat worried whether the errors in this PR are acceptable. A test that should be implemented is that mass does not accumulate in time. In other words, the round-off error incurred by the pressure projection is constant, as expected. > Do we still expect the velocity field to be divergence-free up to machine precision?. We should regard the calculated divergence as an empirical measurement of the round-off error that accumulates during the discrete pressure solve. If the divergence is incorrect (ie, larger than expected due to round off error), then the pressure solver is incorrect, and the fix for that certainly should not be to recompute w!. I am not 100% sure how to theoretically determine the expected round off error associated with the pressure solve. I suppose that we expect that eigenfunction pressure solution to be accurate to within machine precision. However, we subsequently perform a 3D inverse FFT, followed next by a subtraction to calculate the velocity update, and then a second subtraction to calculate the divergence. > The sum still accumulates in time but went from e-22 -> e-20 to e-18 -> e-12. Any significant change in accuracy may be an indication that this PR is important. If the divergence changes significantly after recomputing w, this indicates that a substantial amount of round off error is being accumulated in the velocity field. . We may be able to calculate the expected round off error per grid point.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/711#issuecomment-602552703:916,perform,perform,916,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711#issuecomment-602552703,1,['perform'],['perform']
Performance,"> Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. Not sure how it would work with JLD2 but `Base.read!` can fill an array by reading data from disk: [https://docs.julialang.org/en/v1/base/io-network/#Base.read!](https://docs.julialang.org/en/v1/base/io-network/#Base.read!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1068#issuecomment-711036331:181,load,loaded,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068#issuecomment-711036331,1,['load'],['loaded']
Performance,"> Another thought for @christophernhill; > ; > At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have. @francispoulin thanks. I think we probably just want to do some buffer. I looked at LazyArrays.jl and I could imagine how that could maybe also be included, but I suspect the main thing is having a buffer (which https://github.com/eth-cscs/ImplicitGlobalGrid.jl has). I don't see any sign of LazyArrays in https://github.com/eth-cscs/ImplicitGlobalGrid.jl code! We can check with Ludovic though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885972875:185,optimiz,optimize,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885972875,1,['optimiz'],['optimize']
Performance,"> Another thought for @christophernhill; > ; > At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have. We think that we cannot send non-contiguous data over MPI between GPUs (only CPUs). Thus certain `view`s will not work. Possibly in this case the data is transferred to CPU, sent over MPI, and then copied back to the GPU (slow).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885935875:185,optimiz,optimize,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885935875,1,['optimiz'],['optimize']
Performance,"> Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?; > ; > ```julia; > wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; > ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; > └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; > ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); > Stacktrace:; > [1] check; > @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; > [2] nc_create(path::String, cmode::UInt16); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; > [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; > [4] NCDataset; > @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; > [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Per",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:601,Load,LoadError,601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839,1,['Load'],['LoadError']
Performance,"> Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... The CUDA.jl implementation is such an implementation: https://github.com/JuliaGPU/CUDA.jl/blob/2310b88738c11449867e6f37c5acbfcd453dc2c8/src/mapreduce.jl#L60-L69. It probably needs to be profiled and optimized if you really want to squeeze out performance, but it isn't a naive implementation either. It's exposed via `Base.mapreducedim` and friends.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152:13,optimiz,optimizing,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152,4,"['optimiz', 'perform']","['optimized', 'optimizing', 'performance']"
Performance,> Are we making AMDGPU an extension?. I was asked to keep the PR minimal. I have a good deal of follow up work related to performance coming. You'll need to make AMDGPU a package extension after.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936969288:122,perform,performance,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936969288,1,['perform'],['performance']
Performance,"> As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models). I agree, but this patch-up will not work for immersed boundaries anyway. I still advocate for (maybe not now but later down the line) a general line of thought that ensures consistency between immersed boundaries and ""regular"" boundaries (a la MITgcm) treating them always the same way. As an example, this issue could have been brought up for immersed boundaries, which would have required a (definitely more lengthy) rework of boundaries in abstract operations but would have solved the issue in both boundaries and immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689967113:432,perform,performance,432,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689967113,1,['perform'],['performance']
Performance,"> Average reduction with conditional expressions, e.g., like; > ; > https://github.com/CliMA/Oceananigans.jl/blob/748feab10a55fa65a46455620203252a6fc0646e/test/test_field_reductions.jl#L107; > ; > induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,; > ; > ```julia; > @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); > ```; > ; > Only mentioning this here in case it might something in the source code that could be affecting code performance. The condition should be a function of `f(i, j, k, grid, args...)` returning a boolean, or an `AbstractArray` of booleans. . We should implement boolean operations with fields to return boolean fields, so we will be able to pass an `AbstractOperation`; ```; condition = T > 3 # This should be a boolean AbstractOperation; @compute Txyz = Field(Average(T; condition)) ; ```. at the moment the best way to specify a condition is through a function; ```; @inline condition(i, j, k, grid, T) = T[i, j, k] > 3; @compute Txyz = Field(Average(T; condition)) ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1224162912:489,perform,performance,489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1224162912,1,['perform'],['performance']
Performance,"> Benchmark? The reason we combined the updates for velocities was a perceived performance gain. Probably we were wrong about that, but it'd be good to show it. Do I understand that to mean that you want to test the performance of the code before and after the PR? If there are tests that I can run to do this with both versions, I would be happy to try that on my desktop, only CPU, but that probably wouldn't be as nice as trying it on a better computer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-734371151:79,perform,performance,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-734371151,2,['perform'],['performance']
Performance,> Better than multi-threading though. Them fighting words ;),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-795861999:14,multi-thread,multi-threading,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-795861999,1,['multi-thread'],['multi-threading']
Performance,"> Billy mentioned it in some other comments but while we do splat args for some of the function calls, the function definitions use Varargs instead. This should avoid the catastrophic slowdown we saw with splatting earlier, but I agree that it should be tested. Do you have any good CPU performance tests set up @glwagner ?. Any simple test will do, for example one of the examples",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150416681:287,perform,performance,287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150416681,1,['perform'],['performance']
Performance,"> Bonus, also the `mask_immersed_field` was missing. I don't expect it will be ever used (why using an immersed boundary grid in a single column?), however I have added a test for it. We can remove it if not needed. Good to have because it might be useful for testing and also, its definitely best if the single column mode is identical (except for performance) to 3D mode.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3756#issuecomment-2326759623:349,perform,performance,349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3756#issuecomment-2326759623,1,['perform'],['performance']
Performance,"> But it gets worse. If the average of a field is taken, we zero out the halo regions. Looks like we can use `mean!` on views to fix this issue as they don't perform scalar operations (interestingly `mean` uses scalar operations). Not sure if it recently started working or if I was blind to `mean!` when we first started taking horizontal averages but if we are using `sum!` we must have considered `mean!`... ```julia; julia> using Statistics, BenchmarkTools, CUDA. julia> CUDA.allowscalar(false). julia> N = 512;. julia> Rgpu = randn(N+2, N+2, N+2) |> CuArray;. julia> Vgpu = @views Rgpu[2:N+1, 2:N+1, 2:N+1];. julia> vgpu = zeros(1, 1, N) |> CuArray;. julia> mean!(vgpu, Vgpu);. julia> @benchmark CUDA.@sync mean!(vgpu, Vgpu); BenchmarkTools.Trial: ; memory estimate: 2.08 KiB; allocs estimate: 85; --------------; minimum time: 2.427 ms (0.00% GC); median time: 2.567 ms (0.00% GC); mean time: 2.584 ms (0.00% GC); maximum time: 8.747 ms (0.00% GC); --------------; samples: 1930; evals/sample: 1; ```. which is basically the same speed as `sum!`. ```julia; julia> @benchmark CUDA.@sync sum!(vgpu, Vgpu); BenchmarkTools.Trial: ; memory estimate: 1.48 KiB; allocs estimate: 62; --------------; minimum time: 2.428 ms (0.00% GC); median time: 2.564 ms (0.00% GC); mean time: 2.566 ms (0.00% GC); maximum time: 3.228 ms (0.00% GC); --------------; samples: 1944; evals/sample: 1; ```. and ~34x faster than the CPU version (maybe we usually expect more but reduction operations aren't the best for GPUs). ```julia; julia> using Statistics, BenchmarkTools. julia> N = 512;. julia> Rcpu = randn(N+2, N+2, N+2);. julia> Vcpu = @views Rcpu[2:N+1, 2:N+1, 2:N+1];. julia> vcpu = zeros(1, 1, N);. julia> mean!(vcpu, Vcpu);. julia> @benchmark mean!(vcpu, Vcpu); BenchmarkTools.Trial: ; memory estimate: 0 bytes; allocs estimate: 0; --------------; minimum time: 85.751 ms (0.00% GC); median time: 86.201 ms (0.00% GC); mean time: 86.316 ms (0.00% GC); maximum time: 87.483 ms (0.00% GC); --------------; samp",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1063#issuecomment-708314963:158,perform,perform,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1063#issuecomment-708314963,1,['perform'],['perform']
Performance,"> By the way @tomchor, is this also the ratio that you find in your simulations (maybe with the latest commit)? If yes, I ll give up trying to inbound and only try to speed up the advection. I just tried with the latest commit and got this error:. ```julia; ERROR: LoadError: TaskFailedException. nested task error: UndefVarError: coeff_β_2_0 not defined; Stacktrace:; [1] left_biased_β(::Tuple{Float64, Float64}, ::WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, ::Val{0}); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:115 [inlined]; [2] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:115 [inlined]; [3] beta_loop(::WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, ::Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}, ::typeof(Oceananigans.Advection.left_biased_β)); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:163 [inlined]; [4] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:163 [inlined]; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:265,Load,LoadError,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132,1,['Load'],['LoadError']
Performance,"> By the way, i didn't use the scheme described in #1704 because it didn't give great results when implemented. I have implemented the ENO coefficients as derived before the assumption of uniform grid to the stencil interpolation (tomorrow I'll go back and check the report which describes them) . The smoothness functions are kept the same. That's interesting. Does that mean you were not able to reproduce the results reported in ""[A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2)""?. > > By the way, it would be quite easy to modify the type to include the order of the WENO scheme which we could change at will. What do you think? Would it be usefull to do that?; > ; > If it's easy, then I definitely vote that we do that! A lower order, faster WENO scheme may be a good compromise between computational cost and accuracy. If that's true, we could use it as the default scheme for models. I think a higher order WENO scheme is more important than lower-order scheme. However, a low-order WENO method is proposed [here](https://link.springer.com/article/10.1007/s10915-020-01164-6). I think the 3rd order scheme may be quite diffusive and runs the risk of limiting to 1st order (?!). #995 attempts to implement nth order WENO but I think failed to achieve good CPU performance / compilation on the GPU. But @simone-silvestri perhaps you're able to achieve this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093:468,perform,performance,468,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093,2,['perform'],['performance']
Performance,"> Can we check with atmospheric clima model and with emerging DG hydrostatic ocean model, that z index increases upwards there too... best to have consistency across models. Last time this came up in https://github.com/climate-machine/Oceananigans.jl/issues/90 it seemed that `k` increases as you move away from the surface of the Earth (although they may have meant the center of the Earth? Otherwise DG ocean and atmosphere would have opposing conventions). Also mentioned was that the unstructured grid means sometimes you just do unstructured stuff and there's no `k` index I guess. @blallen Does increasing the vertical `k` index go up or down for the DG ocean model?. > Finite volume is good and hopefully need not slow model down. If we do move on to other grids, will be useful. Yeah for uniform grids it shouldn't. We have benchmarks we can check against. Things might slow down a bit with `z` operators, but that's to be expected. If we do shared memory right, it might not be by a huge amount. > Be good to chat next week. The general FV piece intersects with thinking about one day being able to do LES with bathymetry and still some performance. That would be good, haven't though much about topography. I'll be around.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/471#issuecomment-541423970:1146,perform,performance,1146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471#issuecomment-541423970,1,['perform'],['performance']
Performance,"> Can you put @inline in front of sponge_u_disc, etc?. Done. Same result. I also tried `ContinuousForcing` with `bottom_mask(x, y, z) = 1` and it's slower than its discrete counterpart. Apparently `DiscreteForcing` is a bit faster than `ContinuousForcing`, everything else being the same. > Again unsure if it affects performance but since rate is referenced as global it needs to be const; eg const rate = 1/10. Yes! That makes a big difference! I feel silly that I forgot that. With `const rate=1/10` and `DiscreteForcing` things are as fast as with no forcing. Using the same ""trick"" with `ContinuousForcing` doesn't change things though. So it does seem like the source of the issue is `ContinuousForcing`. I should say though, I'm having some trouble securing a GPU right now, so I haven't been able to run these tests on a GPU. Would a MWE help here?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875702050:318,perform,performance,318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875702050,1,['perform'],['performance']
Performance,"> Can you try this branch and see if it goes better? `ss/fix-memory-issue`. It seems to solve the memory issue! But I do get an error when writing to disk:. ```; ERROR: LoadError: NetCDF error: size mismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:169,Load,LoadError,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165,1,['Load'],['LoadError']
Performance,"> Can't we just plot a fixed-color shape on top on the mount on all panels? [`Makie.poly`](https://docs.makie.org/stable/reference/plots/poly/) seems to be able to do that. We can. We can also mask the output after we load it, e.g, via. using something like. ```Julia; using Oceananigans.ImmersedBoundaries: mask_immersed_field!. function mask_and_get_interior(φ_t, n; value=NaN); mask_immersed_field!(φ_t[n], value); return interior(φ_t[n], :, 1, :); end. u′ₙ = @lift mask_and_get_interior(u′_t, $n); ```. which gives. https://github.com/CliMA/Oceananigans.jl/assets/7112768/a402bfcd-ef72-42d8-bbb9-97fb98be4fe3. But either of these solutions complicate the example a bit. Ideally, `mask_immersed_field!` should not be user-facing. And plotting a mountain on top of the mountain is a bit of a hack and would require a bit of explaining and justifying why we do that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1983782339:218,load,load,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1983782339,1,['load'],['load']
Performance,"> Copied below.; > ; > ```; > ERROR: LoadError: `makedocs` encountered an error. Terminating build; > --; >   | Stacktrace:; >   | [1] error(s::String); >   | @ Base ./error.jl:33; >   | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document); >   | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255; >   | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document); >   | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170; >   | [4] #2; >   | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined]; >   | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String); >   | @ Base.Filesystem ./file.jl:106; >   | [6] #makedocs#1; >   | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined]; >   | [7] top-level scope; >   | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >   | 🚨 Error: The command exited with status 1; >   | user command error: exit status 1; > ```. This is only the top of the error. Farther down, we see. ```; ┌ Warning: failed to run `@example` block in src/generated/shallow_water_Bickley_jet.md:70-77; --;   | │ ```@example shallow_water_Bickley_jet;   | │ model = ShallowWaterModel(architecture = GPU(),;   | │ timestepper = :RungeKutta3,;   | │ advection = WENO5(),;   | │ grid = grid,;   | │ gravitational_acceleration = g,;   | │ coriolis = FPlane(f=f));   | │ ```;   | │ c.value = CUDA error (code 100, CUDA_ERROR_NO_DEVICE);   | └ @ Documenter.Expanders /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Expanders.jl:563; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390:37,Load,LoadError,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390,1,['Load'],['LoadError']
Performance,"> Could you explain why using ifelse has better performance?; Is this because the ternary ? : is an alias for ifelse?. No, the ternary operator `a ? b : c` is shorthand for . ```julia; if a; b; else; c; end; ```. This `if`-statement (as well as the logicals `&&` and `||`) are _short-circuiting_. That is, `c` is guaranteed _not_ to run if `a === true`. For example. ```; julia> f(a, first) = first ? a[1] : a[2]; f (generic function with 1 method). julia> a = rand(1); 1-element Vector{Float64}:; 0.6018054291910822. julia> f(a, true); 0.6018054291910822. julia> f(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] f(a::Vector{Float64}, first::Bool); @ Main ./REPL[7]:1; [3] top-level scope; @ REPL[10]:1; ```. The first call to `f(a, true)` executes without problems, because the second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If w",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:48,perform,performance,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583,1,['perform'],['performance']
Performance,"> Distributed IO is not supported yet and will require a lot of work and refactor so for the time being we have to do with the rank in the output writers. Distributed IO is not necessary to solve this problem. We can introduce a convention for filenames whereby the rank number is automatically inserted into the filename for distributed simulations. Similarly the convention can be reversed for `FieldTimeSeries` to make the process seamless for users. There are probably plenty of other possible solutions. The first step is recognizing that a problem or deficiency exists, and having the desire to fix it. Then we can do the fun part, which is to design solutions to an important problem. Note that distributed IO is unlikely to ever be supported for JLD2. So to provide a seamless experience with JLD2, we really do require a filename convention to solve the problem. (For NetCDF, we could envision providing a choice between file splitting or distributed IO.). Filename conventions also seem preferred to me for many cases in a world of GPUs where each rank likely needs to hold a substantial portion of the computation for performance. Splitting files by rank will limit the filesize, which makes it easier to transfer data when the simulations are very large --- which will probably often be the case when doing distributed simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895891029:1129,perform,performance,1129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895891029,1,['perform'],['performance']
Performance,"> Do I understand that to mean that you want to test the performance of the code before and after the PR? If there are tests that I can run to do this with both versions, I would be happy to try that on my desktop, only CPU, but that probably wouldn't be as nice as trying it on a better computer. We would like to test the performance of the version of Oceananigans on this PR versus Oceananigans#master on the CPU and GPU and for a variety of problem sizes. Maintaining good performance is a top priority of ours. Generally speaking we would like to avoid performance regressions --- even small ones (which accumulated over many PRs could become significant).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-734413997:57,perform,performance,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-734413997,4,['perform'],['performance']
Performance,"> For non local directions, if `storage` and `plan` are `unified_array`s, the non local FFT can be performed by permuting the partitioning of the `MultiRegionGrid` without having to transpose memory (that will happen under the hood thanks to unified memory). Just `storage` is an array; `plan` is a `CUFFT` object, not an array. If we use `cufftxt` would this happen be default?. ie with `cufftxt` we have to build a unified `storage` (and maybe unified eigenvalues). Then provided we can fill up storage correctly, and empty it correctly at the end, the thing that's left is to ""just do"" the fft (transposes etc handled under the hood). Does broadcasting work with unified memory arrays?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119868092:99,perform,performed,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119868092,1,['perform'],['performed']
Performance,"> Hello, @amontoison. Nice work. Do you see a performance improvement when switching to this package? There should be some benchmarks in the `benchmark` folder that we can test (probably we need to update that folder a bit, let me know if you have problems with it). Hi @simone-silvestri, `cg` is not too hard to implement, so I don't think we will see a significant performance improvement on CPU. ; However, for other methods like `gmres`, `Krylov.jl` easily outperforms `IterativeSolvers.jl`.; On GPU, though, we might see a difference because I try to dispatch to the BLAS/LAPACK routines of the GPU vendors as much as possible, whereas `IterativeSolvers.jl` relies on some broadcast. Also, to the best of my knowledge, only `cg` works on (NVIDIA) GPUs for `IterativeSolvers.jl`, while all solvers in `Krylov.jl` work on the GPUs of any vendor. I'll try to run some benchmarks before the end of the week.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3778#issuecomment-2373076041:46,perform,performance,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3778#issuecomment-2373076041,2,['perform'],['performance']
Performance,"> Hmm. I believe that scalar operations are (or were) _specifically_ allowed globally in our `runtests.jl`, overriding any default. I was considering deprecating that option though, so that scalar iteration would be disabled by default and can only be allowed for a limited number of statements using `@allowscalar` or `allowscalar() do ... end`, because it's such a performance trap. Is there so much scalar iteration being triggered by the Oceananigans tests?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-863772729:367,perform,performance,367,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-863772729,1,['perform'],['performance']
Performance,"> Hmm... is this called every time Oceananigans is _run_, or only when it is _built_? The number of threads at build-time may not be equal to the number of threads desired at run-time... ?. It's at run-time (it worked for #869). From https://docs.julialang.org/en/v1/manual/modules/#Module-initialization-and-precompilation. > In particular, if you define a function `__init__()` in a module, then Julia will call `__init__()` immediately after the module is loaded (e.g., by `import`, `using`, or `require`) at runtime for the _first_ time (i.e., `__init__` is only called once, and only after all statements in the module have been executed).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/868#issuecomment-681952346:459,load,loaded,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/868#issuecomment-681952346,1,['load'],['loaded']
Performance,"> Hmmm, I was thinking it would be good to benchmark each operator at least once but I suppose if sin is fast then we can assume cos and tanh will also be fast. I think the proper benchmark is to compare a unary operation via one function of our choice (say, `sin`) and a hand-coded benchmark for the same function. We don't benchmark additional functionality of `AbstractOperations` by testing multiple unary functions; those would just benchmark the performance of the unary function itself, which we don't care about (because we are not going to improve the performance of `Base.sin` or `CUDAnative.sin`.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-545895227:452,perform,performance,452,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-545895227,2,['perform'],['performance']
Performance,"> I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators. At least that is what @siddharthabishnu told me, I am not sure about the timings, can you confirm @siddharthabishnu?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353979984:99,perform,performance,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353979984,1,['perform'],['performance']
Performance,"> I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators. For example, if the boundary is fixed and not dependent on the interior variables, it might be possible just to fix the BC once before the sub stepping and just iterate without needing to use any update",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319:99,perform,performance,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319,1,['perform'],['performance']
Performance,"> I believe in this case that the function d.▶ from the above is identity, which could fail because it's also called in the calculation of the binary operation w * v?. I gotta be honest that whole discussion went right over my head, haha. I think mostly because I don't really understand what's the exact use of `identities` and what the functions `d.▶` actually do. . Am I correct in assuming that if I specify where each calculation is performed (by using `@at`) I can decrease the computational complexity and maybe make `ComputedField`s easier to compile on GPUs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786854048:438,perform,performed,438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786854048,1,['perform'],['performed']
Performance,"> I could use some explanations on your closure usage. @glwagner is the mastermind behind the implementation of the LES closures. It's still not documented but he's written up some documentation about them in a different package: https://dedales.readthedocs.io/en/latest/summaryclosures.html. > If it was up to me I would prefer an extended documentation of GPUifyLoops ;) I only understand how it works by reading what you do with it. Yeah GPUifyLoops could do with an extra example or two... I have an old and still open PR showing an example of a 3D stencil computation but you probably already know how to do this: https://github.com/vchuravy/GPUifyLoops.jl/pull/18. Ah interesting, yeah I found papers online that described a 50-80% speedup but sounds like a lot of manual work which Julia may be able to do for us :) We've barely thought about CPU performance let alone SIMD but maybe something like GPUifyLoops.jl can figure out the multicore SIMD code. > I will try to use part of your code to rewrite the toy 2D CFD solver I have translated from Matlab (https://discourse.julialang.org/t/asynchronous-makie/27127/9?u=laurentplagne). That's awesome! Do let us know if you have any questions. That's a pretty cool use of Makie with `fillrange=true`!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518441255:854,perform,performance,854,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518441255,1,['perform'],['performance']
Performance,"> I don't know exactly what to do, so we'll need help. I've started with a post to the julia slack: https://julialang.slack.com/archives/C67910KEH/p1635909337281400; > ; > On the other hand, it may not be a huge issue if it only affects diagnostics that are evaluated fewer than 5 times. For long running simulations, our methods do eventually get cached? Do you have an example of a method that doesn't get cached after 5 evaluations?. ~When I was running an actual simulation this issue seemed to persist after many evaluations (i.e. writings to disk), and not just the first few times. So it may be that doing it 5 times consecutively on the REPL is different from the simulation behavior. That said, I didn't pay a ton a attention to that, so I may have been wrong.~. ~I'll try to investigate this further tomorrow on my end if I have time.~",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958632710:348,cache,cached,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958632710,2,['cache'],['cached']
Performance,"> I don't think we ever used `power_by_squaring`, because the ""pre 1.6"" Oceananigans kernels were defined via`KernelAbstractions`, which in turn translated `^(a, b)` to `CUDA.pow(a, b)`:. I know, I was thinking about what would be a good ""new"" default behavior. CUDA.jl used to truncate Int64 exponents to Int32, resulting in `powi` use, but although that was good for Oceananigans it's a bad default. Using `pow` after casting the exponent to Float64 seemed like a good idea, but is apparently slow in your use case. `Base.power_by_squaring` is slow in microbenchmarks, but may perform better in a realistic application? If that's the case, I could change the implementation of `^` in CUDA.jl. But I also realize now that exponentation by a small constant, which you seem to be doing here, should probably be handled differently. Base has `literal_pow`, not sure why that isn't kicking in here. Feel free to file an issue about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870021086:579,perform,perform,579,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870021086,1,['perform'],['perform']
Performance,"> I guess I also see timers as a debugging tool for users. Totally agree since simulation performance can depend entirely on performance of forcing functions, boundary conditions, and diagnostics; not just code that ships in src.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888341027:90,perform,performance,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888341027,2,['perform'],['performance']
Performance,"> I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:; > ; > `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`; > ; > Then it returns the following error:; > ; > Error output:; > Any idea what it could be, @simone-silvestri ?. That's related with #3374 and the warning comes from Julia v1.10 (wasn't there with Julia v1.9).; The PR #3403 will deal with these warnings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895005561:235,optimiz,optimizer,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895005561,2,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,"> I never understood why a `CFL` object had to be pre-constructed, but I always assumed there was a good (probably GPU-related) reason for that. I guess it's helpful if we have competing functions for computing time-scales (for performance reasons). But if we have just one fast function then it doesn't seem like there's a good reason.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958584552:228,perform,performance,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958584552,1,['perform'],['performance']
Performance,"> I over-simplified. FFTs are efficient when there are a small number of prime divisors --- 2, 3, 5, 7 --- of the length of the sample. 100 may actually be ok because it is 2*2*5*5. I don't feel strongly, but you will find that most people running simulations are using powers of 2 and 3 (128, 192, 256, 384, 512, 768, 1024) --- even when their code has no FFTs! Perhaps the purpose of this convention is so people who _do_ use codes that rely _heavily_ on FFTs are able to run code comparisons. I find the convention to be an appropriate best practice. An 1D FFT of length 257, for example, is 4 times slower than an FFT of length 256 on my machine. For tests, of course, using small numbers of prime divisors is completely irrelevant; I just want to encourage best practices and promote awareness of them, and also implicitly emphasize to users that this code uses FFTs, and don't want random person X to read the tests and scratch their head and ask ""doesn't this code rely on FFTs?"" (like I did when I saw the examples). I don't disagree with anything here. I just think users should be able to run using whatever resolution they want and know that the code has been tested and works with weird inefficient resolutions. To encourage users maybe we can print a ""performance warning"" if the grid resolution is not the product of a small number of prime divisors?. > I certainly prefer that. It may be academic because the architecture should probably be a parameter of `Model`. That makes sense. I think we should just be wary of having too many parametric types but architecture probably warrants being one as we'll dispatching on it so frequently.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468537451:1265,perform,performance,1265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468537451,1,['perform'],['performance']
Performance,"> I see a problem. The kernels seem to make an assumption about a relationship between the axes of the data arrays and the size of the blocks. It seems that generalizing this problem will involve rewriting all of the kernels... ?. Hmmm, I don't immediately see it, but yes for example the kernels that perform vertical integrals do assume this. Actually, the vertical integrals are precisely fast because we use `NT=2` for them. I don't think kernels need to be rewritten, we just need to use an appropriate thread-block layout with `NT=2` in this example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-496520500:302,perform,perform,302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-496520500,1,['perform'],['perform']
Performance,"> I see that one of the errors is `UndefVarError: device_event not defined`, which I suppose means we need to load it?. Indeed, I'll fix that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890028428:110,load,load,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890028428,1,['load'],['load']
Performance,"> I share here a double drake experiment that makes full use of this PR; > ; > #### Grid setup; > * latitude longitude grid from 75 S to 75 N; > * 1/3 of a degree in the horizontal (1080 points in longitude, 450 in latitude); > * 150 exponentially stretched vertical levels for a 3km deep ocean; > * double drake bathymetry (https://doi.org/10.1175/2009JCLI3197.1); > ; > #### Top BC:; > * temperature: restoring to reference profile (cosine shape); > * salinity: prescribed latitudinally dependent surface flux; > * zonal velocity: prescribed latitudinally dependent wind stress; > ; > #### Bottom BC:; > * velocities: linear bottom drag with a drag coefficient of 0.003 ms⁻¹; > ; > #### Initial conditions; > * zero velocities; > * exponentially stratified temperature with SST equal to the reference temperature; > * constant salinity; > ; > #### Model setup; > * linear equation of state; > * Richardson-based diffusivity for BL mixing; > * vertical background viscosity and diffusivity of 5e-4 and 3e-5, respectively; > * vector invariant momentum advection with WENO for vorticity and divergence flux as well as vertical transport (no horizontal viscosity); > * WENO for tracer advection (no horizontal diffusivity); > * Split explicit free surface using an averaging shape function and a CFL of 0.7 (23 substeps per time step); > ; > #### Simulation setup; > * time step of 10 minutes; > * ran on 2 MPI processes with CUDA-aware MPI; > * performs about 10 simulated years per day; > ; > On the left, there is the free surface evolution, on the right the surface vertical vorticity (evolved for 9 years). This would be a good setup to add to `ClimaOcean.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431581342:1445,perform,performs,1445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431581342,1,['perform'],['performs']
Performance,"> I think prior to the changes we grouped into our ""upgrade to julia 1.6"" we were using the function `CUDA.pow` (from an ancient `CUDA.jl` version). Ah, in that case we were doing something pretty bad: https://github.com/JuliaGPU/CUDAnative.jl/blob/199f9b8ebb1f2fc9d7c14547efa9bcc14f4130c3/src/device/cuda/math.jl#L209. The new default, converting Int64 exponents to Float64, seems better. Unless `power_by_squaring` performs better in realistic applications?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869833684:417,perform,performs,417,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869833684,1,['perform'],['performs']
Performance,"> I think something like you're proposing would have added to my confusion. Isn't the confusion a problem with the output writers API? I think it sounds like a great idea to support `AbstractOperation` output. It's kind of logical. Doing this even allows us to do some clever stuff behind the scenes, like using one underlying array to store the results of multiple computations performed serial (thus saving memory).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036767779:379,perform,performed,379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036767779,1,['perform'],['performed']
Performance,"> I think that should be revisited when we decide to take on the more challenging issue of checkpointing partially-accumulated time-averages so that windowed_time_average always works as intended when picking up from checkpoints. good point!. There is a possibility that it is not very hard. It will require reshuffling code (which I can do), but with Julia we can serialize objects to disk and then load them back seamlessly in a single line... which might be all we need. The only limitation of serialization is that we haven't yet figured out how to serialize _methods_ (eg functions) which prevents us from serializing entire models. When functions are not involved things can be pretty simple.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379890956:400,load,load,400,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379890956,1,['load'],['load']
Performance,> I think the new diffusion/cosine tests? Can't think of something else... Ah indeed. It's also possible that some PRs caused a compile-time regression. Hopefully not a performance regression though. We should test that.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2324#issuecomment-1062527828:169,perform,performance,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2324#issuecomment-1062527828,1,['perform'],['performance']
Performance,"> I think this makes things more intuitive, no? Are there any downsides besides a slightly longer building time for `model`?. There's no downside. `update_state!` has to be efficient for the model to run so I don't think there's a performance issue. I think it's more ""correct"", since without that call the auxiliary state may be wrong initially.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708:231,perform,performance,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708,1,['perform'],['performance']
Performance,> I think to do this cleanly we might want to follow up with what @vchuravy was doing here #3042. I tried experimenting with this on the OceanBioME tests and it seems to be preventing it from segfaultinig https://github.com/OceanBioME/OceanBioME.jl/pull/190 (and testing running them both at the same time here https://github.com/OceanBioME/OceanBioME.jl/pull/196). But it does also seem to run quite a bit slower so I'm going to see how much I can get it to cache without it causing problems. And then I can copy the implementation over to here.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3662#issuecomment-2265916968:459,cache,cache,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3662#issuecomment-2265916968,1,['cache'],['cache']
Performance,"> I think to preserve the work in this PR, we should add a `Float32` test which will fail if a spurious promotion undermines performance. Agreed. I'll revisit this PR later to see if I can find where the conversion happens. The test I added only checks to see if we can take a time step. But I should be able to also add a test to ensure no spurious promotion occurred.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445251168:125,perform,performance,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445251168,1,['perform'],['performance']
Performance,"> I think we can achieve this by splitting a kernel like calculate_interior_source_terms! into two kernels, one that computes source terms ""near"" the boundary (1-2? grid points from any boundary as needed), then halo communication can happen while a second more compute-intensive kernel computes the source terms in the rest of the interior. Don't you want the opposite? You want a kernel that computes source terms in the ""deep interior"", which can be performed without knowledge of halos and thus can be performed simultaneous to performing communication. After communication + deep interior calculations are complete, you then perform calculations on near-boundary elements. Are communications restricted to `fill_halo_regions!` and the pressure solve? If so, we can start to prepare for such optimizations by refactoring the time-stepping slightly. This is is the part of our current algorithm that involves interior tendency computation (there are additional halo filling calls associated with the fractional step):. ```julia; function calculate_explicit_substep!(tendencies, velocities, tracers, pressures, diffusivities, model); time_step_precomputations!(diffusivities, pressures, velocities, tracers, model); calculate_tendencies!(tendencies, velocities, tracers, pressures, diffusivities, model); return nothing; end; ```. The function `calculate_tendencies!` calculates interior and boundary contributions to tendencies and does not involve communication. The function `time_step_precomputations!` is. ```julia; function time_step_precomputations!(diffusivities, pressures, velocities, tracers, model). fill_halo_regions!(merge(velocities, tracers), model.boundary_conditions.solution, model.architecture,; model.grid, boundary_condition_function_arguments(model)...). calculate_diffusivities!(diffusivities, model.architecture, model.grid, model.closure, model.buoyancy,; velocities, tracers). fill_halo_regions!(diffusivities, model.boundary_conditions.diffusivities, model.architecture, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/615#issuecomment-583379290:453,perform,performed,453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/615#issuecomment-583379290,5,"['optimiz', 'perform']","['optimizations', 'perform', 'performed', 'performing']"
Performance,"> I think we should distinguish between output we need when we run the model, and output we may eventually provide to the broader community. Ideally, formats for both would be the same, but this may not be the best solution. E.g., netCDF has obvious disadvantages but is still widely used. That does not mean it should be the output format we use by default (although we may want to provide model statistics in netCDF in the end, if a few years from now this is still what everyone uses). So: separate the discussion of what is best for us now from what we should provide (e.g., in any CMIPx archive down the line). Zarr and HDF both seem worth discussing.; > ; > Also important to keep in mind in this discussion: Our workflow will be different from most standard models, which write out instantaneous output that then is post-processed to get statistics etc. We will have to accumulate statistics on the fly, and we can (and should) forgo most instantaneous output, at least for the atmosphere. The model will learn from the accumulated statistics. Otherwise, with instantaneous output, the data volume, especially with embedded LES, will create an I/O and data transfer bottleneck that will limit us, and, e.g., will limit our ability to use distributed computing platforms. I agree. Ideally we'd support different formats (e.g. NetCDF, JLD2, HDF, Zarr, etc.) and have the option to use the best format for your application. We can already switch between output writers and choose which field(s)/diagnostics to output but we only do binary, NetCDF, and JLD for now. We were just focusing on NetCDF for our short-term needs, but this will definitely be a challenge for large problems.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476303978:1173,bottleneck,bottleneck,1173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476303978,1,['bottleneck'],['bottleneck']
Performance,"> I think you may need @inline in front of most of those functions (only matters for CPU). ~That was my first attempt, but I get an error saying `ERROR: LoadError: LoadError: -(grid.Lz) + grid.Δz * (k - 1 / 2) is not a function expression`. I guess I need to choose between `@inline` or `@inbounds`?~. Nevermind, I was doing something very dumb. Inlining gives me exact same performance as not inlining (0.20% of the simulation). I guess the compiler is getting smarter about inlining. > If the slow down is the same for DiscreteForcing then the problem may really just be evaluating exp, sadly... You could try @inline bottom_mask(k) = 1 to test... I'll try that. Although I have tried non-exponential masks in the past with a similar slowdown, so I'm not sure if that's the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875673783:153,Load,LoadError,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875673783,3,"['Load', 'perform']","['LoadError', 'performance']"
Performance,"> I would advocate again for moving both CUDA and AMDGPU support into package extensions (see #3066 for an outdated start); > ; > Having the user install both AMDGPU and CUDA unconditionally is both space and time consuming, loading them both should be unnecessary on most systems and they may at times be incompatible with each other since both are developed independently from each other. That's a good idea. Maybe we can start by developing AMD support (this PR) in an extension, and then move CUDA after that (just to relieve some pressure on @fluidnumerics-joe).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935396471:225,load,loading,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935396471,1,['load'],['loading']
Performance,"> I'll explain quickly what is happening to document it. In this new PR I added a new way to check boundary stencils for advection so that the correct reconstruction method is always used.; > ; > This entails checking differently for `Face` reconstructions (where we have to ensure that `Center` locations are active) and vice versa for `Center` reconstructions where `Face` locations have to be active.; > ; > The problem occurs when checking the last cell for `Center` reconstructions (on a `Periodic` direction) let's say the advection is centered order 4 so hypothetically it requires two halo points. We then need to ensure that the nodes at `N + 1` and `N + 2` are active. A `Face` node (i) is active if either centered cell (i) or (i+1) is active, which means that the check will be performed on cells `N+1`, `N+2` and `N+3` (one more than the required halo size = 2!).; > ; > This is not a problem for a underlying grid where the `inactive_node` function can check out-of-bounds locations and will just return a `true`. On the other hand, it is a problem for an `ImmersedBoundary` where a conditional has to be evaluated against an AbstractArray.; > ; > My first solution was to increase by one the halo under the hood in the `ImmersedBoundaryGrid` constructor. This bug with `set!` demonstrated that this is probably not the best solution as this can have a lot of unwanted repercussions. The way I implemented it now is that, when performing the halo checking in the model constructor, if the grid is an `ImmersedBoundaryGrid`, the `required_halo` is incremented by one, and an appropriate warning message is displayed. This was the problem. So in the end I decided to just require one additional halo for the immersed boundary grid",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181806144:790,perform,performed,790,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181806144,2,['perform'],"['performed', 'performing']"
Performance,"> I'm a little worried about the increase in size of the already-quite-large time_step! function, but otherwise as far as I can tell things look ok. I agree and at some point in this PR I switched to using broadcasts for the permutations which gets rid of all the `idct_permute!` kernels and keeps one `calculate_pressure_source_term` kernel, but I couldn't get it to perform well on the GPU so I scrapped it. Worth revisiting... > One question: is it the name of the field that needs to be known for halo regions, or the type (FaceFieldZ, FaceFieldX, etc). If its the type, then this suggests two improvements:. Yeah it's kind of hacked together for now. When you want to fill halo regions you feed in a tuple like `(:u, bcs, u_data)` which fills the halos of `u_data` assuming it's a u-velocity field with boundary conditions `bcs`. It kind of crap because for pressure halos I fill them like I would fill in the w-velocity field. This makes the code confusing I think. Might be good to attach boundary conditions to each field, so that all fields get assigned boundary conditions, not just `u, v, w, T, S`. Would be great if we can can adapt fields to work well on GPUs. I think last time we tried we couldn't get them to perform for some reason. One of our oldest issues: https://github.com/climate-machine/Oceananigans.jl/issues/13",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/290#issuecomment-506899367:368,perform,perform,368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/290#issuecomment-506899367,2,['perform'],['perform']
Performance,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:637,perform,performance,637,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869,2,['perform'],"['perform', 'performance']"
Performance,> I'm not sure if we've tested but I've assumed there is a performance benefit to the simpler version for regularly spaced grids rather than using the binary search. @simone-silvestri have you ever benchmarked this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775545546:59,perform,performance,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775545546,1,['perform'],['performance']
Performance,"> I'm still confused about how this changes what was previously done. Did we previously create arrays on the GPU, copy checkpoint from the CPU to ""temporary"" GPU arrays, and then copy from temporary GPU arrays to previously-instantiated model data?. Yeah this is what we were previously doing in `restore_fields!`:; https://github.com/climate-machine/Oceananigans.jl/blob/8352e56f5839b23d3441f6f8bd0f297f3e0b508f/src/OutputWriters/checkpointer.jl#L102. which is kinda stupid stupid because you create a temporary `CuArray` then copy elements over (we already allocated memory for the fields in the `model`). We could have done it with a `copyto!(::CuArray, ::Array)` which would avoid unnecessary allocations except for one temporary array. Now we construct the fields with the restored data and pass it to the model constructor so there are no temporary arrays and zero unnecessary allocations.; https://github.com/climate-machine/Oceananigans.jl/blob/4ed366019c3f6a9b3ba9cf19691fef721204ea3c/src/OutputWriters/checkpointer.jl#L110-L114. > is it possible to load data from disk directly to the GPU?. Hmmm, not sure but doesn't seem impossible. At the lowest level it'll have to do some host to device copies though I think. @leios or @vchuravy would know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/628#issuecomment-589160127:1059,load,load,1059,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/628#issuecomment-589160127,1,['load'],['load']
Performance,"> I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors. That's a good point. Although I think we could avoid creating another page and put that information in the [""Using GPUs""](https://clima.github.io/OceananigansDocumentation/stable/using_gpus/) page, so that things are more condensed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818364275:116,perform,performance,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818364275,2,"['optimiz', 'perform']","['optimizations', 'performance']"
Performance,"> If I understand correctly this would make the `field_slicer` argument for output writers obsolete, no?. I missed this! Yes, that's correct. We _could_ keep it, however I think it's nicer to remove because it's one of the best ways to ensure that the ""windowing infrastructure"" implemented in this PR is performant and easy to use. In place of `field_slicer`, we will add some convenience arguments (`indices` and `with_halos`) that allow output fields to be ""constructed"" from what's given to `OutputWriter`. This will also allow us to close #2242 (but I haven't implemented that yet here).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2246#issuecomment-1044762888:305,perform,performant,305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2246#issuecomment-1044762888,1,['perform'],['performant']
Performance,"> If I understand this issue correctly, we are facing a basic trade-off between (compiler?) performance and the use of convenient but complicated abstraction objects?. It's a hardware limitation, really. The compiler could anticipate though, e.g. by not passing very large objects by value, or by providing an escape hatch (like the `Ref` suggestion in https://github.com/JuliaGPU/CUDA.jl/issues/267). You can experiment with this yourself, by changing which arguments get tagged `byval` in https://github.com/JuliaGPU/GPUCompiler.jl/blob/master/src/irgen.jl#L607, and changing the logic that packs arguments in https://github.com/JuliaGPU/CUDA.jl/blob/master/lib/cudadrv/execution.jl#L8-L37 accordingly (to pass a pointer to a pointer instead of a pointer to a value).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/746#issuecomment-655304824:92,perform,performance,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/746#issuecomment-655304824,1,['perform'],['performance']
Performance,"> If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp. From my tests I think this optimization can shave off 10% of time on the CPU and 25% on the GPU. This isn't bad, but I anticipate launching `Forcing` only where necessary would shave of much more in the situations I mentioned. Although when I originally posted the issue I thought it could be directly implemented in `Forcing`, but you make a good point that it can't, so it might not be worth the effort (at least not right now). I'll close this for now but feel free to re-open it if you think it's worth discussing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092:69,perform,performance,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092,3,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"> If it doesn't slow the tests down, I'm happy to merge and we can consider changing the optimization level in the future if its warranted. I think being explicit and deliberate about it is a positive change. Looks like this makes a significant difference as the latest build on this PR took 25 minutes 1 second (https://buildkite.com/clima/oceananigans/builds/333). Previous 3 builds (which all passed) took 32~33 minutes:; https://buildkite.com/clima/oceananigans/builds/330; https://buildkite.com/clima/oceananigans/builds/331; https://buildkite.com/clima/oceananigans/builds/332. > We do have a small number of tests that might benefit from faster code, like the pressure solver convergence tests?. Yes but pressure solver FFTs go through the FFTW C library where the `julia -O` flag doesn't affect performance. If we want some performance optimization for specific test sets we can do that, e.g. `-O2` on unit tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1078#issuecomment-712939378:89,optimiz,optimization,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1078#issuecomment-712939378,4,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"> If we assume that reduced fields ""lives"" nowhere in the reduced direction, then we can remove the k index and just perform an ""immersed-boundary-unaware"" derivative. > On the other hand, if the reduced field lives on the whole reduced column (like for example an integral) then we need to be aware of the ""immersed column"", because if the whole column is immersed then the derivative should return a zero. What is the difference between ""living nowhere"" and ""living on the whole column""?. I think the point of reduced fields is that they are derived from a reduction over one or more dimensions. Since they are derived from a reduction, they invoke values from every element in the column / reduced direction. I don't understand what it means to ""live nowhere"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2099199410:117,perform,perform,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2099199410,1,['perform'],['perform']
Performance,"> Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the Distributed module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). I think (but am not 100% sure) that PencilArrays is tied to MPI. So I guess for 1 we are either ""borrowing"" (but not using directly) the transpose algorithm from PencilArrays, or we are extending the code so that it works ""without MPI"" -- and also with GPUs, which is work in progress: https://github.com/jipolanco/PencilFFTs.jl/pull/37. Another reason to focus on 2 is that we can use PencilFFTs for _distributed_ (but _not_ `MultiRegion`) nonhydrostatic model. So even if PencilFFTs had support for CuArray now (and if `Distributed` were performant for multi GPU --- both of which may not be too close), using cufftxt could still _potentially_ be motivated by performance reasons. In other words, if we develop a capability with cufftxt, then in the future we can also support multi GPU via PencilFFT and `Distributed`, and we have two options (one perhaps performant on single node, multi GPU, and another to use when you need GPUs spread across multiple nodes).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852:124,perform,perform,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852,6,['perform'],"['perform', 'performance', 'performant']"
Performance,"> In particular, this PR introduces the async keyword argument to fill_halo_regions! that allows launching MPI operations without waiting for the communication to complete. Would `blocking=true/false` be a better word to describe how we are controlling `fill_halo_regions!`?. I think ""async"" isn't quite the right word. ""async"" describes the overall algorithm (eg performing some computation while the communication is taking place), but does not describe what is happening specifically within `fill_halo_regions`. It's possible to write `async=true` without overlapping communication and computation. https://github.com/CliMA/Oceananigans.jl/pull/2881 introduces the kwarg `blocking` for `mask_immersed_field!`, which means the same thing:. https://github.com/CliMA/Oceananigans.jl/blob/4a71c834cbc057fcc27061a1d22b4a7cc3eb38fe/src/ImmersedBoundaries/mask_immersed_field.jl#L13. so either way let's use one word.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2953#issuecomment-1452252842:364,perform,performing,364,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2953#issuecomment-1452252842,1,['perform'],['performing']
Performance,"> Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example.; > ; > This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth. I think there may be a bug in the setup that produces 100x slowdown. (@tomchor if you supply the whole script, we can investigate.) We've run many successful problems with trig functions. Some recent work by @simone-silvestri suggests we can get 2x speed up for _some_ problems by precomputing grid metrics for the `RegularLatitudeLongitudeGrid` rather than computing them on the fly:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/Operators/spacings_and_areas_and_volumes.jl#L178-L179. But I don't think we've definitely shown that we _always_ will get 2x speed up. Thus we are going to retain the option to compute metrics on the fly in #2025 so we can continue to investigate it. 2x is a long way from 100x though. If used in a boundary conditions, its basically irrelevant whether one uses a trig function or not. Even a forcing function is only evaluated once per grid point compared to 15x (or more?) for a `BackgroundField` velocity component with high-order advection. Some of these thoughts might be distilled into useful advice in this section of the docs. But we should definitely focus on _approaches_ to performance optimization rather than advice for specific scenarios.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050:176,perform,performed,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050,3,"['optimiz', 'perform']","['optimization', 'performance', 'performed']"
Performance,"> Interesting idea @christophernhill . For the last results that @hennyg888 posted in #1722, I did some calculations and found the following.; > ; > ```; > GPU; > N=256 3.0e9; > N=128 2.6e9; > N=64 6.6e8; > ; > CPU; > N=256 8.6e6; > N=128 9.1e6; > N=64 9.0e6; > ```; > ; > In an article that @ali-ramadhan referenced on the slack channel recently, a paper using a shallow water model in python, Roullet and Gaillard (2021), said they were getting 2 TFlops per second using a thousand cores. We are getting 3 GigaFlops on GPU and 9 MegaFlops.; > ; > Certainly very good speedup since we have O(400) with `WENO5`, but this makes me wonder whether we could do better?; > ; > But to answer your question, when @hennyg888 has the data, we can certainly produce these plots easily enough (unless there is a problem that I'm missing). We have to do more work to compare with Roullet and Gaillard (2021). First of all, there are typos in the paper: sometimes the performance is listed as 2 GFlops, other times as 2 TFlops. Second --- if I understand the situation correctly --- I don't think we've ever measured floating point operations per second. The numbers you've calculated are grid points per second; however we do many floating point operations per grid point. Roullet and Gaillard (2021) estimate their code performs something like 700-800 Flops per grid point. ![image](https://user-images.githubusercontent.com/15271942/126053492-345154c2-22e2-4af8-a898-ac68e889733d.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881986070:955,perform,performance,955,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881986070,2,['perform'],"['performance', 'performs']"
Performance,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800:617,perform,performed,617,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800,2,['perform'],"['performed', 'performing']"
Performance,"> Is that what you recommend?. That wouldn't solve your problem here. KA gives you reasonable performance on the CPU, but since KA 0.8 it is execution story on the CPU much closer to the rest of Julia and it doesn't play special tricks.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481565094:94,perform,performance,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481565094,1,['perform'],['performance']
Performance,"> Is there a way to test x_f_cross_U et al?. Yes: construct a model with the given feature and then perform a time-step. I guess ideally we would form a giant matrix representing all possible model configurations and time-step them all once. This would be expensive. Maybe we should just loop over each physics specification individually and cross our fingers that there's no bad interactions (I can already tell this would be naive, for example, when a turbulence closure depends on buoyancy).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/616#issuecomment-583371090:100,perform,perform,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/616#issuecomment-583371090,1,['perform'],['perform']
Performance,"> It is what the right panel shows, if I am not mistaken. But the simulation crashed after thousands of iterations. I heard that the PCG solver in Oceananigans has not been widely tested, so that is why I turned to the HeptadiagonalIterativeSolver. Both of those solvers actually use the preconditioned conjugate gradient method. It's also not true --- the `PreconditionedConjugateGradientSolver` has been validated. I'm not even sure it's possible to use the FFT-based preconditioner with the heptadiagonal solver, they have different interfaces. Maybe you worked on that. It's not obvious how to generalize the `HeptadiagonalIterativeSolver` to support `Distributed` architecture, and its also likely more difficult to optimize for immersed boundary methods using an active cells map. We shouldn't waste our time with the `HeptadiagonalIterativeSolver`. If the `PreconditionedConjugateGradientSolver` has issues, we should fix them. It's a waste of energy to work on both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071221835:721,optimiz,optimize,721,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071221835,1,['optimiz'],['optimize']
Performance,"> It returns a int with the value of the number of files or file divisions already performed and the file name. if files are file_part_1.nc, file_part_2.nc, file_part_3.nc, the output will be: `3 file_part_3.nc`. How about calling it `split_files` or `number_of_split_files`?. Could also improve clarity to split it into two functions. One to return the number of split files, and the other to return `current_split_filename`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2414761941:83,perform,performed,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2414761941,1,['perform'],['performed']
Performance,"> It seems very strange to me that evaluating trig functions is slow on GPUs. Is this we problem known to CUDA.jl?; > ; > The information you have here seems good to me. ""slow"" is ill-defined. We recently found that precomputing grid metrics for the latitude-longitude grid leads to a 2x speed up for simple 2D cases (less for more complex cases, probably). But it's all relative to other calculations that are being performed. For many ocean codes the limiting step is evaluating the nonlinear equation of state (a 55 term polynomial) at various locations on the grid. For these cases, the cost of trigonometric functions may not be noticeable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425085:417,perform,performed,417,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425085,1,['perform'],['performed']
Performance,"> It'd be nice to state in writing the justification for writing a separate CPU solver for certain problems. In general, I think that any algorithm that works on the GPU will also work on the CPU. Thus at least in principle the simplest choice is presumably to use the same solver on both architectures. Good point, I've been meaning to set up a script for benchmarking the different pressure solvers. We should use performance benchmarking results to make decisions. > Also, I'd encourage writing this code into as self-contained a submodule as possible. I think there are other codes in the julia ecosystem (not least FourierFlows.jl!) that would benefit from fast and multi-architecture Poisson solvers. We don't have to break this into a separate package just yet, but we do want to ensure this is easy to do in the future. Another good point. As you pointed out some of these solvers depend on the `grid` but if we take that out (which would be trivial) then I think the solvers in PR #589 would be pretty reusable by other packages. Although right now they're pretty specific to staggered grids (except for `BatchedTridiagonalSolver`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586#issuecomment-572303204:416,perform,performance,416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586#issuecomment-572303204,1,['perform'],['performance']
Performance,"> Just a quick update, zero-viscosity Bicklet jet test case for `VectorInvariant`, `WENOVectorInvariant` (smoothness calculated based on `ζ`), modified VectorInvariant WENO with smoothness based on 2D stencils of `u` and `v`, here called `WENOVectorInvariantZVEL`; > ; > `VectorInvariant` https://user-images.githubusercontent.com/33547697/157745561-a8e5f128-2f4e-42e3-9305-3f624498590b.mp4; > ; > `WENOVectorInvariant` https://user-images.githubusercontent.com/33547697/157745569-41c52e2d-c80b-4d43-b2bf-8a914e8856a2.mp4; > ; > `WENOVectorInvariantZVEL` https://user-images.githubusercontent.com/33547697/157745571-725ea604-8dec-44bd-bd08-dcd70d9ed4b1.mp4; > ; > `WENOVectorInvariantZVEL` seems to perform actually very well compared to a (somewhat) standard ""vorticity-reconstruction"" `WENOVectorInvariant` and compared to the very noisy standard `VectorInvariant` in lie of the fact that; > ; > * Noise is reduced significantly despite dissipation not being too high; > * Agreement between different resolutions is much higher. Both the WENO vector invariant forms look great, and much less noisy than the non-WENO version. Why do you say the third is better than the second? I don't doubt that it us but my eyes don't see much of a difference. . Out of curiosity, have you computed a time series of the energy?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064467000:699,perform,perform,699,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064467000,1,['perform'],['perform']
Performance,"> Just an idea but in #685 the performance regression was actually due to not eliding _apply_*_bcs! for NotFluxBC so maybe we could be eliding some computation or function call?. That's a good hint, I'll look. . But it also seems like a problem that not eliding those functions leads to massive allocation. Why is that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/710#issuecomment-605241310:31,perform,performance,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/710#issuecomment-605241310,1,['perform'],['performance']
Performance,"> Just ran into this and wanted to mention [NCTiles.jl](https://github.com/gaelforget/NCTiles.jl) which we, https://github.com/lmilechin and myself, recently released.; > ; > Not sure if `NCTiles.jl` is readily applicable to your package output but maybe it would be interesting to discuss some sort of integration. What do you think?. Hi @gaelforget , . Thank you for bringing this to our notice! From what I understand, NCTiles provides convenient functions to either use NCDatasets.jl or NetCDF.jl and integrates with MeshArrays.jl, which has representations for tri-polar grids and such. I haven't had the time to read your 2015 paper so please correct me if I did not grasp the full extent of NCTiles' capabilities. So far Oceananigans does not have support for anything other than regular cartesian grids so NCTiles might be an overkill. But we can definitely consider it in the future when Oceananigans gains new capabilities. . By the way, did you notice any differences in performance between NCDatasets.jl and Netcdf.jl?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/433#issuecomment-537189439:982,perform,performance,982,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/433#issuecomment-537189439,1,['perform'],['performance']
Performance,"> Nah…; > ; > Every preview is 200MB of load on the repo I then have to clean and it’s not that easy to clean up a repository’s history. I’d rather I make the PR twice or built the docs locally :). Oof, didn't know that. Sounds fair :). I'll approve it, although we probably have to restart the failed GPU tests",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2886#issuecomment-1409061309:40,load,load,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2886#issuecomment-1409061309,1,['load'],['load']
Performance,"> Naively, I would think that if one term is computed with WENO5 then 4 terms would be 4 times the cost. Okay, I understand what you're saying and I agree. Assuming that the advection term dominates the cost of a time-step, we could count the number of times the advection term is evaluated and calculate a multiplicative slowdown based on that assumption. One issue with that assumption is that the advection terms compile to different code when using a `BackgroundField`. With a `BackgroundField` the velocity field is stored as a `FunctionField` (with almost no additional memory allocation) rather than raw data. Calling `getindex` on a `FunctionField` resolves to calling a function, whereas calling `getindex` on a `Field` / `Array` fetches data from memory. So they are different. Naively I would expect that evaluating a complicated advection term involving `BackgroundField` would be cheaper than one that involved two concrete `Array`. But sometimes unexpected things happen (the compiler might decide to optimize the code differently...). Can you try running the code on the GPU? I think it would be enlightening to see if there's a slowdown in that case. We could potentially implement an interface whereby `Field`s can be used as `BackgroundField` rather than functions. That might give us some insight, because then the ""additional"" advection terms associated with `BackgroundField` would truly be identical to the ""original"" advection term. > because presumably the advection of the background state by the background state is zero. I would say that the background self-interaction terms are _neglected_ rather than presumed to be zero. Linear terms associated with the background fields are also neglected. The idea being that if there is a valid way to decompose a flow into background and perturbation components, then the equation that governs the background component is completely neglected (this includes both the nonlinear terms and any linear terms involving the background flo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623:1015,optimiz,optimize,1015,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623,1,['optimiz'],['optimize']
Performance,"> New log level should be enough if we just need flat per-iteration timings to time a few blocks for a few iterations. Are you thinking of just logging raw `@time` data?; > ; > I'm not sure if we need anything more than a new log level, but I imagine some of the benefits of using a package like TimerOutputs.jl would make the timer blocks much more useful for debugging and for users. It allows for nested timers and produces a very nice table summary at the end which includes number of calls and average time/memory allocations.; > ; > This could also be useful for users wishing to time their simulations to figure out how much time is being spent on I/O vs. in kernels vs. solvers vs. callbacks, etc. I guess I also see timers as a debugging tool for users. Could help be figure out cluster filesystem issues or figure out whether Oceananigans or my coupled model (via callback) is the bottleneck.; > ; > Otherwise if the timers are just a developer debugging tool that dumps timing information, that's useful but it might not be useful for timing real-world scripts/simulations since the log would fill up with a huge number of lines that can't be interpreted without further processing.; > ; > Here's an example of it in use: [JuliaGPU/CUDA.jl#149 (comment)](https://github.com/JuliaGPU/CUDA.jl/issues/149#issuecomment-461943376) (CUDA.jl has been using TimerOutputs.jl for a long time I think); > ; > TimerOutputs.jl is easy to use since you just add `@timeit` blocks but that does add some noise to the code (not sure if more or less than using a timing log level). @ali-ramadhan I was thinking timing would be useful for general use around figuring out where time is going in day-to-day modeling - so some summary table as in TimerOutputs.jl would be a great thing to aim for - I think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887967029:891,bottleneck,bottleneck,891,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887967029,1,['bottleneck'],['bottleneck']
Performance,> Nice one. Should we benchmark anything just to make sure this hasn't affected performance?. That's a good idea!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-971712282:80,perform,performance,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-971712282,1,['perform'],['performance']
Performance,"> No flux are the default for immersed boundary. It looks like you are explicitly setting an immersed boundary condition for a non-immersed field. What is `b`s grid?. The same as `model`s: a MultiRegion grid. I'm not yet using the IB grid since apparently `MultiRegionGrid` isn't working with IBs yet. When I use it, I get this error. ```julia; ERROR: LoadError: MethodError: no method matching PressureSolver(::CPU, ::MultiRegionGrid{Float64, Periodic, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}); Closest candidates are:; PressureSolver(::Any, ::ImmersedBoundaryGrid) at ~/.julia/packages/Oceananigans/Kq8xW/src/Models/NonhydrostaticModels/NonhydrostaticMod",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1309394728:352,Load,LoadError,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1309394728,1,['Load'],['LoadError']
Performance,"> No. I have no idea why that happened. What can we do to remove them?. Looks like you already did. I would usually try something like `]update Printf` which should remove orphaned packages from `Manifest.toml`. > We can. Such a test may end up running on the CPU via scalar operations though... ?. Ah ok, maybe not a great idea then as it would slow testing down. I guess the computations are tested on the GPU which is good enough. > Note that `Computation` allows the user to specify their own temporary array. `model.pressures.pHY′` is used as a default when `model` is passed to `Computation` in place of an array or field. Ah nice. I guess I was thinking in case `model.pressures.pHY′` disappears one day. > I think just a few will suffice for shallow and deep operations trees, perhaps choosing common use cases to ensure that using abstract operations rather than hard-coded kernels doesn't result in a big performance hit. It will be hard to interpret the results of a benchmark on a deep tree anyways, because we won't have an alternate implementation to compare against. Future performance optimization could use some kind of tree analysis utility + shared memory to accelerate kernels. . Hmmm, I was thinking it would be good to benchmark each operator at least once but I suppose if `sin` is fast then we can assume `cos` and `tanh` will also be fast. Shallow and deep trees makes sense. True we may not have an alternative implementation but we can compare the deep and shallow tree computations to get an idea. I find comparing the computation time to the time per iteration (~30 ms for 256^3) to be helpful. > Why extensive? I'm just not sure what to write: the rules for how things work are already all there in the docstrings. Maybe examples are what's needed?. Didn't mean to suggest that we need extensive documentation right away. Having examples of what's possible will be really useful, but we can build up a collection of good examples over time. PS: Think you missed half my c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-545887965:915,perform,performance,915,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-545887965,1,['perform'],['performance']
Performance,"> Okay finally tests passed!; > ; > @navidcy I tried restarting the tests over and over (honestly more than 10 times over the past few days) and they always failed. I could only make them pass this morning when I restarted them one at a time. That is, starting one, and only restarting the next failed test when the previous one had fully run.; > ; > So maybe the variability we see in tests has to do with different processes trying to access the same resources... ?. Yes it is a race condition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223710307:481,race condition,race condition,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223710307,1,['race condition'],['race condition']
Performance,> On Satori using stupidly large meshes gives 85% - 89% efficiency going from 1 to 2 GPU for the `multi_region_turbulence.jl` benchmark (Note `1440×600×48` is the size of the 1/4 degree simulation) Unfortunately the efficiency decreases on a larger number of GPUs... we definitely have to fix the scaling; > ; > #### Strong Scaling; > Grid size	Grid	GPUs	wall time	efficiency; > `1024×1024×100`	`RectilinearGrid`	1	3.4 minutes	100%; > `1024×1024×100`	`MultiRegionGrid`	2	1.9 minutes	89.5%; > `1440×600×48`	`RectilinearGrid`	1	1.4 minutes	100%; > `1440×600×48`	`MultiRegionGrid`	2	49.2 seconds	85.4%; > `1440×600×48`	`MultiRegionGrid`	3	38.8 seconds	72.2%; > Going to smaller meshes than these hampers the efficiency incredibly. I think there might be a lot of low hanging fruits to optimize multi GPU. Nice results though! Is this for implicit or explicit free surface?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116681325:782,optimiz,optimize,782,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116681325,1,['optimiz'],['optimize']
Performance,"> One issue with that assumption is that the advection terms compile to different code when using a `BackgroundField`. With a `BackgroundField` the velocity field is stored as a `FunctionField` (with almost no additional memory allocation) rather than raw data. Calling `getindex` on a `FunctionField` resolves to calling a function, whereas calling `getindex` on a `Field` / `Array` fetches data from memory. So they are different. Good to know. Thanks for explaining. > Naively I would expect that evaluating a complicated advection term involving `BackgroundField` would be cheaper than one that involved two concrete `Array`. But sometimes unexpected things happen (the compiler might decide to optimize the code differently...). Agreed! Often unexpected things happen, which keeps us on our toes. > We could potentially implement an interface whereby `Field`s can be used as `BackgroundField` rather than functions. That might give us some insight, because then the ""additional"" advection terms associated with `BackgroundField` would truly be identical to the ""original"" advection term. I don't pretend to understand the details of this and don't know the potential pay off so not sure whether I think this will bear fruit or not. > I would say that the background self-interaction terms are _neglected_ rather than presumed to be zero. Linear terms associated with the background fields are also neglected. . Good. > _Side note:_ some nonlinear terms are additionally neglected in the case of nonlinear viscosity. Ah, I don't think I'm getting into that now but it's something to be aware of.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816780988:699,optimiz,optimize,699,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816780988,1,['optimiz'],['optimize']
Performance,"> One thing to note is that the current implementation appears to be very slow. While the simulation with the `SmagorinskyLilly` closure runs on my laptop in 10 seconds, it takes 4 minutes for the simulation with the `ScaleInvariantSmagorinsky`. I know the dynamic model will be slower given the extra computations, but such a difference seems large to me, so I'm hoping something can be changed here to improve performance:. Avoided recomputation of the strain rate at `ccc` and sped things up a bit more. Now it runs in 2.9 minutes. A lot more to go...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2241696460:412,perform,performance,412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2241696460,1,['perform'],['performance']
Performance,"> Output needs to be arbitrary. We may need to perform on-line analysis and output the result (example: turbulent dissipation rate, time-averages, slices of fields, point values, etc).; > ; > We should design an additional interface for Fields. The type of the field indicates the coordinates on which the field is defined, so we should design an interface that uses that information.; > ; > _Originally posted by @glwagner in https://github.com/ali-ramadhan/Oceananigans.jl/pull/93#issuecomment-468290310_. Just adding your comment here as I think there are two new questions raised:; 1. How to integrate diagnostics with the output writing framework?; 2. Right now each NetCDF output file shows a single snapshot. Maybe it makes more sense to keep appending to an existing NetCDF file. This might also make addressing (1) easier especially if the diagnostics have a different output frequency that other fields.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/31#issuecomment-468304803:47,perform,perform,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/31#issuecomment-468304803,1,['perform'],['perform']
Performance,"> Perhaps a silly question but with the new MPI parallelism, will be able to do a traditional multi-CPU run with Oceananigans? I presume so but the fact that people are talking about the MPI mostly supporting GPU's, I'm a bit confused. Yes! Actually only CPU + MPI is supported right now haha. GPU + MPI will require distributed FFTs across multiple GPUs. Unfortunately right now PencilFFTs.jl only provides distributed FFTs across multiple CPUs. The benefit for multi-GPU parallelism was brought up since we are currently limited to decomposing the domain in the y-direction only. This is probably fine if you don't have too many ranks so the current limitation favors multi-GPU performance over multi-CPU performance. For models that don't need distributed FFTs, e.g. `ShallowWaterModel`, we can decompose in x, y, and/or z, and getting multi-GPU support might not be that much more extra work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786687524:680,perform,performance,680,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786687524,2,['perform'],['performance']
Performance,"> Perhaps we could convert to this: https://github.com/DTolm/VkFFT which supports hardware-accelerated FFT on CUDA, Metal and lots of others. It looks like that library is more performant than `cuFFT` as well. Why do we have to convert? Can we use that only for Metal?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734543134:177,perform,performant,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734543134,1,['perform'],['performant']
Performance,"> Point taken, but I think there are still Oceananigans-relevant applications where Value / Gradient boundary conditions on non-immersed boundaries are useful enough to be a ""core"" feature (e.g. imposing observed SST patterns rather than observed air-sea heat fluxes), but there is always the workaround of strongly restoring boundary-adjacent sponge regions. I think this is what many ocean modelers do to implement such boundary conditions anyway. True! I'm not aware that has ever been done, but since it's not difficult to support (notwithstanding @simone-silvestri's concerns about parallel performance) it's interesting to allow it --- agree. For future readers I want to point out that SST restoring (and similar models) are typically be implemented as a `FluxBoundaryCondition` using a piston velocity model, rather than using `ValueBoundaryCondition` (which implies a flux mediated by some diffusivity / viscosity, possibly derived from a parameterization). (`FluxBoundaryCondition` is mathematically identical to restoring in the surface grid point, though it would be a slightly different model to distribute the restoring over some depth). It could be an interesting project to explore using some parameterization-derived diffusivity together with `ValueBoundaryCondition` to predict surface fluxes, though, I'm not sure what the implications would be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452:596,perform,performance,596,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452,1,['perform'],['performance']
Performance,"> Possibly, we should start using a merge queue that would disallow PRs from being merged unless tests pass. Yeap. I added these in https://github.com/CliMA/Oceananigans.jl/settings/branches. <img width=""905"" alt=""Screenshot 2023-12-23 at 1 10 26 pm"" src=""https://github.com/CliMA/Oceananigans.jl/assets/7112768/3137d7ef-2f34-4f05-86fa-c759177ac164"">. How does this sound?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868271224:42,queue,queue,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868271224,1,['queue'],['queue']
Performance,"> Seems like we have to ensure that types are correct... I ll take a look. This is really a compiler issue... I guess we ""shouldn't"" have to enforce types, but maybe it helps with inlining (which we need for performant code and GPU compilation)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2558#issuecomment-1128949553:208,perform,performant,208,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558#issuecomment-1128949553,1,['perform'],['performant']
Performance,"> Shoudn't we write a kernel? Presumably that explicit 3D loop is incredibly slow?. Indeed! Unfortunately it's not embarrassingly parallel so my kernel skills are no longer sophisticated enough :) I don't know how to gather `count`, `rowval` or `colval`. The conditional preseumably also leads to poor performance (but no where near as poor as it is now!).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2737#issuecomment-1248734171:302,perform,performance,302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2737#issuecomment-1248734171,1,['perform'],['performance']
Performance,"> Should we also try things like; > ; > ```julia; > node(i, j, k, grid, ::Nothing, ℓy, ℓz) = _node(i, j, k, grid, nothing, ℓy, ℓz)[1:2]; > ```; > ; > I think we determined there could be a tiny performance loss but it would make the code a little simpler and also easier to read since we don't have to define every combination of locations for `_node`. Hmm this is more annoying than I thought so I'll leave it for later.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775509960:194,perform,performance,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775509960,1,['perform'],['performance']
Performance,"> Since the aim is to work with abstract operations, FieldTimeSeries right now only work with JLD2 data that includes halos. Do we want to support loading data without halos?. We generally need to support `SlicedField` so I suggest we implement such support in that context. Until then, I think users need to be aware that they need `field_slicer=nothing` to use this experimental feature. Once this feature is mature, I think that `field_slicer=nothing` should be the default. Some of the most important calculations we do are on boundaries. The reason to omit halos that contain useful information about boundary conditions is only for ""convenience"" --- this feature eliminates that concern so that more science can be done.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1641#issuecomment-835434572:147,load,loading,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1641#issuecomment-835434572,1,['load'],['loading']
Performance,"> Since we need the performance provided by KA 0.7, and we need to use KA 0.8+ on GPU, does that mean that we should invest in developing our own CPU infrastructure (replicating what KA 0.7 offered) to achieve that performance?; > ; > Another possibility is that we re-write much of the code base to avoid the performance pitfalls we are currently facing in order to get back to the level of performance we have with current code + KA 0.7. I believe the issue is basically an interaction between some of the abstractions / indirection we have developed and the compiler, so possibly rolling back that abstraction / indirection will bring us back to where we were previously. To follow up with @vchuravy, it seems that rewriting just _some_ of the code was sufficient, so we are (probably) in the clear! The lesson learned is that we cannot slurp / splat `@kernel` function arguments, because it prevents the kernel code from being inlined.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198741:20,perform,performance,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198741,4,['perform'],['performance']
Performance,"> So it appears that there are two competing bug here, which kinda cancel out in the case where gravity aligned with the vertical direction. I also think that back in #1910 when we saw some weird effects when not separating the pressure, this might have been it. No, I don't think so. We reconstructed correctly previously when performing the hydrostatic pressure integral. The only bug was for tilted gravity, or not using the pressure integral.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518046160:328,perform,performing,328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518046160,1,['perform'],['performing']
Performance,"> So the first task is to extend the tridiagonal solver to support integrals in `x` and `y`.; > ; > This could be straightforwardly supported by adding some kind of tag to indicate the ""tridiagonal direction"" (ie `:x`, `:y`, or `:z`), and copy-pasting the functionality for each case. It's a bit of code duplication but pretty straightforward...; > ; > Alternatively we could introduce some kind of abstraction that permutes array dimensions. Then we just have one algorithm which assumes the tridiagonal index is `k`, and support `i` or `j` under the hood via an array wrapper that performs an index permutation.; > ; > I'm leaning towards copy/paste because it's a little easier to understand and it's not that much code in this case... I also prefer the copy/paste method (that's what I used in https://github.com/CliMA/Oceananigans.jl/pull/3111). If I understand correctly these two functions are the only ones that need to be generalized, no?: . https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L74-L83. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L88. if so, that's not too bad. Is duplicating one of the tests in [test_batched_tridiagonal_solver.jl](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_batched_tridiagonal_solver.jl) but rotating everything to two different directions enough to test this new functionality?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1560271584:583,perform,performs,583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1560271584,1,['perform'],['performs']
Performance,"> Some of the abstract operations tests are CPU-only (the non-computation ones?). Would it make sense to run them on the GPU as well?. We can. Such a test may end up running on the CPU via scalar operations though... ?. > It seems that model.pressures.pHY′ has taken on the role of being the temporary array. Can't think of a great way of doing temporary arrays without using up extra memory but maybe it makes sense to define a function so it's easy to change the temporary array?. That's a good idea for sure to permit dispatch on various type parameters of `model`. . Note that `Computation` allows the user to specify their own temporary array. `model.pressures.pHY′` is used as a default when `model` is passed to `Computation` in place of an array or field. > Performance benchmarking (will likely be quite extensive to cover many possible use cases). I think just a few will suffice for shallow and deep operations trees, perhaps choosing common use cases to ensure that using abstract operations rather than hard-coded kernels doesn't result in a big performance hit. It will be hard to interpret the results of a benchmark on a deep tree anyways, because we won't have an alternate implementation to compare against. Future performance optimization could use some kind of tree analysis utility + shared memory to accelerate kernels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-545718073:766,Perform,Performance,766,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-545718073,4,"['Perform', 'optimiz', 'perform']","['Performance', 'optimization', 'performance']"
Performance,"> Sorry I don't quite understand: Is this potentially affecting the calculations right now, or will it only be an issue if we upgrade to CUDA 3.5+?. CUDA 3.8 includes features that may allow us to decrease register pressure or implement performance optimizations that would otherwise be difficult or impossible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2202#issuecomment-1025963063:237,perform,performance,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202#issuecomment-1025963063,2,"['optimiz', 'perform']","['optimizations', 'performance']"
Performance,"> Sorry for not following, but I don't see what breaks here for the end user! Could someone give a quick example/explanation?. Apologies that my explanation was not clear. It's a breaking change because the same user input, such as. ```julia; tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2) / 2; ```. produces a different object after this update:. * Before this PR, `u - U` would be interpolated to `(Center, Center, Center)`, and then the binary operation `^(2, u - U)` would be calculated at `(Center, Center, Center)`.; * After this PR, both `u - U` and `^(2, u - U) = (u - U)^2` are calculated at `(Face, Center, Center)`. Interpolation is then performed to `(Center, Center, Center)` _after_ the exponentiation to form the three-part sum. Let me know if that makes sense or if another example would be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1599#issuecomment-823698116:667,perform,performed,667,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599#issuecomment-823698116,1,['perform'],['performed']
Performance,"> Sponge layers can be added with the existing API. A 1 line implementation (by defining the forcing function to implement a sponge layer, using the currently provided arguments) is currently possible. Yes that's how I did it in PR #291. It can be done in a user script but I figured why not have a `add_sponge_layer!(model; damping_timescale)` convenience function in case users want one. > What is meant by “arbitrary”?. By arbitrary I mean you can keep adding or piling on forcing functions. The purpose of this PR is just to prototype this and see if it can be made performant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/294#issuecomment-504417716:570,perform,performant,570,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/294#issuecomment-504417716,1,['perform'],['performant']
Performance,> Testing with validation/mesoscale/baroclinic_adjustment.jl seems to indicate that the race condition is eliminated from the changes to the fill_halo_region! function. Was there a race condition there?. Could you please point to the relevant issue describing the condition just for completeness?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920113136:88,race condition,race condition,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920113136,2,['race condition'],['race condition']
Performance,"> That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer). Seems I can't reproduce the supposed error so, sorry, my bad... Something else must have been the issue. 😔",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393:220,perform,performance,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393,1,['perform'],['performance']
Performance,"> That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale. 3D averages require scratch space for accumulating the average; this is why they are memory intensive. It's possible to compute averages just on slices or windowed regions of the domain. If this works for your application, you can consider it to reduce memory allocation. > I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. . In principle, you can use a callback to accumulate an average on the CPU from data on disk, and then delete the data periodically as the simulation runs. You can also accumulate the time-average on the CPU. These methods may not be performant, however, depending on the balance between the cost of CPU-GPU data transfer, and other costs in your simulation. If you have to accumulate a 3D time-average for performance reasons, then you have no choice but to allocate a 3D field on the GPU for this purpose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685:740,perform,performant,740,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685,2,['perform'],"['performance', 'performant']"
Performance,"> The Roquet’s approximation is perfectly sufficient for Oceananigans, because it will never be used for global calculations where local approximations are an issue. However I agree with everybody else that it would be best to use the same EOS in Ocenanigans and Climate_Ocean. in that case we should adopt TEOS-10. Be warned that it is quite inefficient through. So we may be hit performance-wise. Hard to tell without trying. Thanks for the feedback @rafferrari. I talked to @leios earlier today and we think it shouldn't be a problem on the GPU. It's just straight up number crunching so it might benefit from being run on a GPU. But we can make sure by doing a quick benchmark.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/692#issuecomment-596868076:381,perform,performance-wise,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/692#issuecomment-596868076,1,['perform'],['performance-wise']
Performance,"> The main issues are when the entirety of a heavy kernel (like one that calculates a tendency) may be promoted to higher precision. `fill(var, 0)` is cheap and unlikely to affect performance.; > ; > That said it's just more precise to write `fill(var, zero(eltype(var)))` (this is _exactly_ what you are trying to do) and therefore the preferred way to write it. You were meant to write `fill!` not `fill` right? For `fill!(::AbstractArray,0)` this is what happens. ```julia; julia> a = Float32[1,2,3]; 3-element Vector{Float32}:; 1.0; 2.0; 3.0. julia> @code_llvm fill!(a,0); ; @ array.jl:346 within `fill!`; define nonnull {}* @""julia_fill!_127""({}* noundef nonnull align 16 dereferenceable(40) %0, i64 signext %1) #0 {; top:; ; @ array.jl:347 within `fill!`; ; ┌ @ number.jl:7 within `convert`; ; │┌ @ float.jl:159 within `Float32`; %2 = sitofp i64 %1 to float; ; └└; ```. So the very first thing is that if `eltype` of the array and type of second argument aren't the same then it's converted (the `%2 ...` line); Using `fill!(var, zero(eltype(var)))` then can skip this conversion (it's compiled away) but the result is the same. You can make and educated guess of the type of the zero, but honestly, I wouldn't even bother. It has probably zero impact on performance for any larger than a few elements and I find `fill!(A,0)` very clear to read too, so that's what I now always try to write.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723777023:180,perform,performance,180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723777023,2,['perform'],['performance']
Performance,> The new commit follows the suggestion of overloading the compute! method to apply it on a tuple of ComputedField. Good point that we may not need an independent type (except for the very minor performance optimization of precomputing the compatibility between fields -- which probably doesn't matter),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1696117967:195,perform,performance,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1696117967,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"> The new default, converting Int64 exponents to Float64, seems better. Unless `power_by_squaring` performs better in realistic applications?. I don't think we ever used `power_by_squaring`, because the ""pre 1.6"" Oceananigans kernels were defined via`KernelAbstractions`, which in turn translated `^(a, b)` to `CUDA.pow(a, b)`:. https://github.com/JuliaGPU/KernelAbstractions.jl/blob/fdb7415b6f6083c23451cc526b0637144322b1cb/lib/CUDAKernels/src/CUDAKernels.jl#L289. This means that ""pre 1.6"" we were exponentiating with `nv_powi`... In ""current"" Oceanagnians (before this PR), changes to KernelAbstractions and CUDA seem to imply that we invoke `nv_pow` instead. And for some reason this can slow down our code by 10-15x (!!) as discussed on #1764 . Does CUDA C do special transformations for `powi(x, Int32(2))`? Eg, does it convert `powi(x, Int32(2))` to `x*x` (or something like that)? I've no idea but maybe there are some massive algebra reductions / expression eliminations that occur for our weird WENO5 code when we ask for `x*x` versus `x^2.0` ... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870014674:99,perform,performs,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870014674,1,['perform'],['performs']
Performance,"> The point of this was to finally close issue #13. I believe issue #13 occurs when `@inbounds` is not used. I found this same issue (and its resolution) a while ago during the development of `OceanTurb.jl`. Edit: I see the benchmarks in thabbott/JULES.jl#22. Are you sure that corresponds to a measurable performance improvement (eg, is signal, not noise). It seems more likely to me that the two benchmarks are identical, which is consistent with the fact that `@propagate_inbounds` implies `@inline` (what we have been told).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/434#issuecomment-536318549:306,perform,performance,306,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/434#issuecomment-536318549,1,['perform'],['performance']
Performance,"> The preview isn't showing for me. But we can fix any issues later, so I say merge away. Yeah, It's also not loading for me. It feels like whenever I try to check PR previews it's kinda hit or miss. I wonder if this is an issue with Documenter. But if you're okay with it, I'll merge it and we can fix any problems later.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963566951:110,load,loading,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963566951,1,['load'],['loading']
Performance,"> The problem is not only with the `Nothing`, it's that the reduced fields are effectively launched with a reduced grid size; > ; > for example the west boundary kernel launch for a `(Center, Center, Center)` field will be of size `Ny*Nz` for a `(Center, Center, Nothing)` it will be of size `Ny`; > ; > For the moment I just filter the reduced fields and do them individually. I don't think it will create too much problem. This is only an optimization for time-stepping where we do not have too many reduced fields (only free surface I think). Ah indeed, I see now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065529029:441,optimiz,optimization,441,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065529029,1,['optimiz'],['optimization']
Performance,"> The tests use a lot of scalar indexing that's why they fail on the GPU:; > ; > https://buildkite.com/clima/oceananigans/builds/15604#018f40ed-787d-4e74-a5f4-ae1656fa3043/18-724; > ; > I think if we are comparing single numbers it makes sense to use `@allowscalar`.; > ; > If we are comparing vectors it could be nice to figure out how to get the tests to run without `@allowscalar` since presumably this is possible. Given that we're comparing elements of vectors with a maximum length of 6, I opted to use `CUDA.@allowscalar`. The impact on performance in this situation is minimal when running on a GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2103388821:544,perform,performance,544,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2103388821,1,['perform'],['performance']
Performance,"> There was a bug in some recent updates to KernelAbstractions.jl that caused Enzyme to break on broadcasting arrays in Oceananigans. This PR includes a test to make sure this bug doesn't occur again. Interesting! I think it's ok to add a broadcasting test. But it will be confusing to future developers if the test is explained / written as somehow testing a bug in _another_ package. If there's a bug somewhere else, we need a test in that packge (presumably that has been added). . This test also seems a little complicated. Why not just write a simple function that does a broadcast, and then try to autodiff that? Why do we need initial conditions, models, etc?. For example. ```julia; function times_c!(a, b, c); a .= b .* c # c is a number; return sum(a) # or whatever we gotta return; end. grid = RectilinearGrid(arch, size=(1, 1, 1), extent=(1, 1, 1)); a = CenterField(grid); b = CenterField(grid); c = 2; @test try ; autodiff(times_c!, a, b, c... # or something); true; catch; false; end; ```. It's super important for tests to be as short and easy to understand as possible, because maintaining test code is one of the main bottlenecks on development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2105014020:1135,bottleneck,bottlenecks,1135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2105014020,1,['bottleneck'],['bottlenecks']
Performance,"> Thinking of revamping this, I think `T` is a good notation; we do not need to specify `U` and `C` since probably (in the future) we will need to refactor these a little to pass through boundary conditions. Hopefully we don't have to pass boundary conditions 🥺 . Not all complexity is justified by the performance gains...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2329666236:303,perform,performance,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2329666236,1,['perform'],['performance']
Performance,"> This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains. No stretched mesh is supported at the moment (that will come in a later PR); > ; > The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes; > ; > * the starting configuration is always a _z-free_ configuration.; > * the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; > * the y-direction is integer divisible by the number of ranks that divide the x-direction; > * the z-direction is integer divisible by the number of ranks that divide the y-direction; > ; > An additional assumption is that:; > ; > * if TY is Bounded, also TZ needs to be Bounded; > * if TX is Bounded, also TY needs to be Bounded; > ; > All these assumptions can be relaxed in following PRs. Are these statements still accurate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850:303,perform,performed,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850,1,['perform'],['performed']
Performance,"> This is only relevant for CPU models --- correct? In other words, when running on the GPU we still need to load data onto the CPU and then transfer to the GPU. That is technically true although in general you tend to have a lot more CPU memory than GPU memory so I suspect it won't be an issue there. You could reduce memory allocation even further by loading all fields from disk into a temporary array, then copying to a CuArray one field at a time. But I don't think that'll work with JLD2 as the entire file is loaded into memory at once. You could do it with chunked NetCDF files, for example, where you read specific chunks into memory at a time. > Previously, the option was available to create a model on the GPU, load data on to the CPU, and then copy that data to the GPU --- right? Or am I missing something?. You could do that but no user would have gone through the trouble. > Does this PR impact the user API for checkpointing at all, or does it just change `restore_from_checkpoint`, which does everything behind the scenes?. Just changes what happens behind the scenes. The API is the same but checkpoint files now have file names like `convection_iteration12500.jld2` instead of just `convection_12500.jld2` although maybe we should use the word `checkpoint` in the file names. > We may want to move the section on checkpointing that is currently in the documentation at Model setup > Output writers to its own section within the documentation. Sounds like a good idea, will do before merging.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/628#issuecomment-588990471:109,load,load,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/628#issuecomment-588990471,4,['load'],"['load', 'loaded', 'loading']"
Performance,"> This is super exciting! Out of curiosity is there any/which Krylov solver is compatible on multiple GPUs? Seems to be an important bottleneck for our current `PreconditionedConjugateGradientSolver` approach. Also to be clear about what this can do --- with Krylov, we can still use the FFT preconditioner. When we do that the parallelism issues are identical to the issues with our current CG solver, it's just that tweaking the solver method might allow us to do fewer iterations. So there are two things going on in this discussion which are independent. First is whether conjugate gradient is optimal or whether we should use a different method. The second issue is the preconditioner, which is the more uncertain part but where we might have more gains.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387264231:133,bottleneck,bottleneck,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387264231,1,['bottleneck'],['bottleneck']
Performance,"> This is the same benchmark performed with `ImplicitFreeSurface`, by imposing a divergent velocity `u(x, y, z) = x / 10` to make sure the implicit solver iterates. Looking at the results it seems like it doesn't iterate too much... (probably WENO cleans up?) And it is very weird that the `RectilinearGrid` version is not affected by the FreeSurface calculation? (I have double checked that the free surface solver is correct); > ; > #### Strong Scaling; > Grid size	Grid	GPUs	wall time	efficiency; > `1440×600×48`	`RectilinearGrid`	1	1.37 minutes	100%; > `1440×600×48`	`MultiRegionGrid`	2	1.05 minutes	65.2%. THATS CALLED A SPEED UP 🍻 . I think bathymetry interferes with the solver more. When the velocity field is _purely_ divergent + barotropic, it just produces waves that dissipate nearly instantly ?. It'd be good to come up with a reliable 3D initial condition for benchmarking iterative solver stuff....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116787626:29,perform,performed,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116787626,1,['perform'],['performed']
Performance,"> True. Ideally we want to be close to the scalings/performance we got with lat-lon grid? That’s perhaps not feasible..? I don’t know how close is good enough tho. We expect to be at lower performance. For that reason we have dedicated two independent milestones to the cubed sphere. The first milestone is rather susinct ""complete the cubed sphere implementation"". The second milestone pertain to performance: ""achieve 10 SYPD at 25 km resolution"". I think this is nice, because we want to separate tasks into ones that are _required_ for correct functionality, versus tasks that are oriented towards performance rather than correctness.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719389468:52,perform,performance,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719389468,4,['perform'],['performance']
Performance,"> We could restrict ourselves to specific combinations of boundary conditions instead, which would reduce the number of possibilities. For example, we might have just doubly periodic in (x, y) plus flux in z on all fields, or singly-periodic in x and flux in (y, z) on all fields. Agree that `CoordinateBoundaryConditions` might be a weird name but yeah, maximum flexibility would be very powerful. Maybe the common use case isn't to impose each of the 30 boundary conditions one-by-one but we can just have nice helper functions/abstractions like; ```julia; model.boundary conditions += HorizontallyPeriodic(); ```. > @ali-ramadhan do you mean with regards to performance? I'm not sure. With multiple dispatch being core to julia it seems this scenario is not uncommon (30+ may not be very large). I'm still pretty new to Julia so yeah don't know if that will be an issue, especially on the GPU. Only way to find out is to try and benchmark! Maybe you're right and 30+ isn't a lot. @vchuravy any idea on whether 30+ parameterized types for a struct is too many? Would this hurt performance on the GPU?. > The function calc does not actually impose a boundary condition --- the imposition of boundary condition depends on, for example, the viscosity and diffusivity, and is a property of the equation (or turbulent closure) being implemented. Again for example, the K-Profile-Parameterization includes a modification of how a flux boundary condition is implemented. In other words, the ""specification of flux"" is separate from the ""imposition of a boundary condition"". The former is determined by the user. The latter is determined by the model/governing equation. I see. So if no parameterizations are being used, are the boundary conditions actually being _imposed_ then? Even with KPP, isn't the boundary condition still being _imposed_ only to later be modified by KPP?. I still feel like `bc.calc()` feels obscure, I'm not sure why a boundary condition should have to calculated. Perhaps it's jus",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472241993:661,perform,performance,661,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472241993,1,['perform'],['performance']
Performance,"> We need some PlotRecipes for fields...; > ; > (In general, not for this PR!). We need that badly... I think we should take the approach in `ClimaCore.jl` which is to develop an ""external"" package that lives in `/lib`. Perhaps `Makinanigans.jl` or `Vizinanigans.jl`. Performing new releases is a little more arduous with that setup but its probably worth it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2238#issuecomment-1034179606:268,Perform,Performing,268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2238#issuecomment-1034179606,1,['Perform'],['Performing']
Performance,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281:115,perform,performance,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281,2,"['optimiz', 'perform']","['optimizations', 'performance']"
Performance,"> What does the `T(0.5)` term do in the following snippet? Does it translate to `Float64(0.5)`?. Yeah exactly, it's there so we don't mix precisions when running with e.g. `Float32`. That can slow down the code as you have to convert between `Float32` and `Float64` to do operations. Could do `/ 2` which gets converted to the correct float type, but division is more expensive than multiplication and not sure if `x / 2` will get optimized to `0.5 * x` in all cases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/438#issuecomment-537955930:431,optimiz,optimized,431,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/438#issuecomment-537955930,1,['optimiz'],['optimized']
Performance,"> What if we get rid of `parameters` and `computed_dependencies`, and call `compute!` on all the arguments?. That'd work for me. Would that have the same performance or would it add some overhead?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1068561902:154,perform,performance,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1068561902,1,['perform'],['performance']
Performance,"> What if you edit the forcing functions into the discrete form, e.g. invoking `Forcing` with `discrete_form=true`?. It helps! But doesn't solve the problem. In particular the MWE above (with two tracer) in discrete form compiles for me. But when I add more tracers (I need at least 6 tracers for my simulations) it fails again. Sometimes with a different error:. ```; ERROR: LoadError: Failed to compile PTX code (ptxas exited with code 255); Invocation arguments: --generate-line-info --verbose --gpu-name sm_60 --output-file /glade/scratch/tomasc/jl_hs9AZo7IJq.cubin /glade/scratch/tomasc/jl_XSJ4P4z47a.ptx; ptxas /glade/scratch/tomasc/jl_XSJ4P4z47a.ptx, line 5136; error : Entry function '_Z23julia_gpu_calculate_Gu_7ContextI14__CUDACtx_Namevv14__PassType_312v12DisableHooksE18_gpu_calculate_Gu_16CompilerMetadataI10StaticSizeI9_8__8__6_E12DynamicCheckvv7NDRangeILi3ES5_I9_1__1__6_ES5_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE15RectilinearGridIS9_8PeriodicS12_7BoundedS9_S9_S8_IS9_Li1ES10_IS9_Li1ELi1EEES8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES15_IS9_E5Int64EES8_IS9_Li1ES14_IS9_S15_IS9_ES15_IS9_ES16_EES8_IS9_Li1ES10_IS9_Li1ELi1EEEvE4WENOILi3ES9_vv5TupleIS8_IS18_IS9_S9_S9_ELi1ES10_IS18_IS9_S9_S9_ELi1ELi1EEES8_IS18_IS9_S9_S9_ELi1ES10_IS18_IS9_S9_S9_ELi1ELi1EEES8_IS18_IS9_S9_S9_ELi1ES10_IS18_IS9_S9_S9_ELi1ELi1EEES8_IS18_IS9_S9_S9_ELi1ES10_IS18_IS9_S9_S9_ELi1ELi1EEEELitrueEvS17_ILi2ES9_vvS18_IS8_IS18_IS9_S9_ELi1ES10_IS18_IS9_S9_ELi1ELi1EEES8_IS18_IS9_S9_ELi1ES10_IS18_IS9_S9_ELi1ELi1EEES8_IS18_IS9_S9_ELi1ES10_IS18_IS9_S9_ELi1ELi1EEEELitrueEv12UpwindBiasedILi1ES9_vvvv8CenteredILi1ES9_vvvvEES20_ILi1ES9_vvvvEES20_ILi2ES9_vvvS20_ILi1ES9_vvvvEEEvv16SmagorinskyLillyI26ExplicitTimeDiscretizationS9_10NamedTupleI34__b____1____2____3____4____5____6_S18_IS9_S9_S9_S9_S9_S9_S9_EEE17BoundaryConditionI4FluxvEvS23_I23__velocities___tracers_S18_IS23_I12__u___v___w_S18_I9ZeroFieldIS16_Li3EES26_IS16_Li3EES26_IS16_Li3EEEES23_I34__b____1____2____3____4____5____6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401133112:376,Load,LoadError,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401133112,1,['Load'],['LoadError']
Performance,"> What parallelism strategy makes sense? One particle per thread?. I think that makes sense, and we just queue up a huge amount of blocks like we already do with 3D kernels. Although if we use DifferentialEquations.jl then maybe we won't have to worry about parallelism here?. > Do we use linear interpolation between velocity nodes or assume a constant velocity within each cell (nearest neighbor interpolation)?. Yeah I'm not super sure what's a good approach here. We're on a regular Cartesian grid right now so maybe the difference isn't huge?. The [Parcels v2.0 paper by Delandmeter & van Sebille (2019)](https://www.geosci-model-dev.net/12/3571/2019/) discusses interpolation schemes for curvilinear C-grids using mostly Lagrange polynomials. But on a rectilinear grid like ours, it seems that it just reduces down to linear interpolation [see Eq. (3)]. Maybe a good question for @jm-c. > Obtaining prognostic quantities within particles (like reacting chemical species with reaction rates that depend on ambient temperature) may be challenging and probably requires a careful design. Agreed. It may not even be clear what a good solution is. Apparently DARWIN has a similar problem I think where many plankton species may be uptaking nutrients so the question of what to do when a nutrient are depleted is hard to solve, especially as having nutrients go below zero can be bad for the model.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547215399:105,queue,queue,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547215399,1,['queue'],['queue']
Performance,> When I ran this locally I got a load of `@test_broken` passing for computed fields which is quite strange. We don't test those regularly --- it might be a new compiler etc. You can feel free to convert those to `@test` if you want to be a hero 💪,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2181261472:34,load,load,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2181261472,1,['load'],['load']
Performance,"> When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; > ; > ```julia; > ERROR: LoadError: UndefVarError: `settings` not defined; > ```; > ; > When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; > ; > ```julia; > ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; > ```. Do you need help fixing these?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1744978276:218,Load,LoadError,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1744978276,2,['Load'],['LoadError']
Performance,"> Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?. I was planning was to implement the tridiagonal solve similarly to what we do for single GPU as such:; ```julia; transpose_z_to_y!(storage) # copy data from storage.zfield to storage.yfield; solver.plan.forward.y!(parent(storage.yfield), buffer.y) ; transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; solver.plan.forward.x!(parent(storage.xfield), buffer.x); transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; ; # Perform the implicit vertical solve here on storage.zfield... transpose_z_to_y!(storage); solver.plan.backward.y!(parent(storage.yfield), buffer.y); transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; solver.plan.backward.y!(parent(storage.xfield), buffer.x); transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; ```. This is not super great because it requires eight transposes, but I think it's the same thing that was happening in #2538",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197384003:807,Perform,Perform,807,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197384003,1,['Perform'],['Perform']
Performance,"> Where in the model should we store the forcing array in this case?. The user would define an array in a script, declare it `const` to the compiler, and then write a function that indexes into it as a global:. ```julia; # define a; forcing(..., i, j, k) = a[i, j, k]; ```. We can also include a constructor for `Forcing` that allows the user to pass some function that defines a constant array, and set up the same functionality internally. > The main motivation being that we don't have to write extra functions that dispatch on the forcing, thus simplifying the time stepping code. As you point out we don't want to write 5! = 120 new functions. The update_source_terms! function is already 52 lines long so I'd rather avoid having to dispatch on this function. I think the problem is that our functions are trying to do too much at once. We need smaller functions that perform more atomic operations so we can dispatch on atomic operations. I don't think we need to re-invent multiple dispatch with macros. We just need to refactor the code so we can use multiple dispatch effectively.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470556414:873,perform,perform,873,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470556414,1,['perform'],['perform']
Performance,"> While we should try to use powers of 2 for performance, I think that overly restricts the model resolutions we can be running at. There are a LOT of choices between e.g. `512x512x128` and `1024x1024x128`. It might be that the largest model that fits in memory isn't nice powers of 2. Users may have various reasons for running resolutions that aren't powers of 2. I over-simplified. FFTs are efficient when there are a small number of prime divisors --- 2, 3, 5, 7 --- of the length of the sample. 100 may actually be ok because it is 2\*2\*5\*5. I don't feel strongly, but you will find that most people running simulations are using powers of 2 and 3 (128, 192, 256, 384, 512, 768, 1024) --- even when their code has no FFTs! Perhaps the purpose of this convention is so people who *do* use codes that rely *heavily* on FFTs are able to run code comparisons. I find the convention to be an appropriate best practice. An 1D FFT of length 257, for example, is 4 times slower than an FFT of length 256 on my machine. For tests, of course, using small numbers of prime divisors is completely irrelevant; I just want to encourage best practices and promote awareness of them, and also implicitly emphasize to users that this code uses FFTs, and don't want random person X to read the tests and scratch their head and ask ""doesn't this code rely on FFTs?"" (like I did when I saw the examples). > Just a note that if we want to reuse `model.metadata.arch` with GPUifyLoops.jl then the options should be `:CPU` and `:GPU` (instead of `:cpu:` and `:gpu` which is what `ModelMetadata` currently uses) as I believe GPUifyLoops.jl expects ""capitalized"" Symbols. I certainly prefer that. It may be academic because the architecture should probably be a parameter of `Model`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468533848:45,perform,performance,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468533848,1,['perform'],['performance']
Performance,"> Yeah exactly, it's there so we don't mix precisions when running with e.g. Float32. That can slow down the code as you have to convert between Float32 and Float64 to do operations. Just to expand on what @ali-ramadhan said: in writing numbers, we adopt a mixed approach -- in some cases we use integers and rely on promotion to obtain the correct floating point precision. In other cases, we explicitly impose the precision of a number. For fractions, we typically impose precision. For multiplication by integers, we just use the integer and promotion. Also, I don't think its actually the floating point conversation that is costly here. Rather I think the added cost is doing the arithmetic at higher precision. Also, due to promotion rules, I think if a single kernel operator outputs the wrong floating point type, we could end up performing much of an entire kernel's computation at the wrong precision. This appears to have a negligible effect on a Tesla V100 --- but it may have more important effects on other machines, especially if we try to run at half precision on machines especially designed for half precision calculations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/438#issuecomment-537997825:838,perform,performing,838,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/438#issuecomment-537997825,1,['perform'],['performing']
Performance,"> Yeah sure, we can do it. ~~Is there a performance difference?~~. ~~The best solution might use dispatch to enable ""non-stretched WENO"" automatically when the grid has constant spacing.~~. After actually looking at the code, it seems this is what this PR does do, indeed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969063314:40,perform,performance,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969063314,1,['perform'],['performance']
Performance,"> Yeah this is pretty worrying... I'm pretty sure this is the cause of #1420 which has been open for a while so this slowdown must have been around for a while (and just flew under the radar). [Profiling](https://docs.julialang.org/en/v1/manual/profile/) might help pinpoint the bottleneck. It looks like there are some extra temporary arrays being created for the cases with non-trivial (although still pretty trivial) indexing patterns. Profiling could be good - also just turning off as much as possible and then building up from the FFT alone, simple stencil etc... - if that is possible?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891443627:279,bottleneck,bottleneck,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891443627,1,['bottleneck'],['bottleneck']
Performance,"> Yep, I would call it bulk velocity though, instead of phase speed, and change the name from `Orlanski` to something more descriptive like `AdvectiveOutflow`. But these are mathematically identical right? Orlanski called is a ""phase speed"", but ""outflow velocity"" is equally valid and refers to exactly the same mathematical object. The reference you posted says. > The test results also confirm that this type of boundary condition, which was originally designed by Orlanski primarily for equations which are hyperbolic in nature, also performs well for parabolic problems. I think we can keep the name ""Orlanski"" and provide a generic interface for specifying the outflow speed (whatever you want to call it). It can be user-specific, dynamically computed, etc. The code can be extensible, so if users want to experiment with different methods for computing the outflow speed, this is possible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965488832:538,perform,performs,538,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965488832,1,['perform'],['performs']
Performance,"> You can't have multiple threads incrementing the same variable, you get a race condition. Ok, that's just me showing my ignorance. . Perhaps we can change the name of `gpu_accumulate_xy` to something like `horizontal_integral!` that works on both the CPU and GPU? And with a docstring that explains inputs and outputs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520524067:76,race condition,race condition,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520524067,1,['race condition'],['race condition']
Performance,"> You could do that but no user would have gone through the trouble. Well, fair, I was more commenting that ""we"" could have done that behind the scenes for the GPU case. > That is technically true although in general you tend to have a lot more CPU memory than GPU memory so I suspect it won't be an issue there. I'm still confused about how this changes what was previously done. Did we previously create arrays on the GPU, copy checkpoint from the CPU to ""temporary"" GPU arrays, and then copy from temporary GPU arrays to previously-instantiated model data? Or am I missing something (is it possible to load data from disk directly to the GPU?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/628#issuecomment-589151190:605,load,load,605,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/628#issuecomment-589151190,1,['load'],['load']
Performance,"> [AMGX.jl](https://github.com/JuliaGPU/AMGX.jl) only has prebuilt libraries for linux systems. That said, calling using AMGX will fail on, e.g., Mac OS X. What's the best way to optionally load AMGX.jl? Or is there another way around that?. @simone-silvestri any ideas for how to solve this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1242544194:190,load,load,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1242544194,1,['load'],['load']
Performance,"> `2)` is because I cannot think of a situation where you would want to output something different than Array? But please correct me if I'm wrong. I haven't found another example in this repository. We chose `array_type` to permit the flexibility of other array types. I don't know enough to say that we would _never_ want another array type. Better to be defensive than aggressively constraining user action?. `Float32` used to be the default. However, this produced a lot of pain in some testing situations where we wanted to show bitwise reproducability / accuracy in saving. I can't remember all the details, but after a few user issues (in addition to our own pain), we decided to switch to Float64. I agree that Float32 is better, but could be regarded as ""premature optimization"" in this case. Definitely open to discuss though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3214#issuecomment-1679415894:773,optimiz,optimization,773,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3214#issuecomment-1679415894,1,['optimiz'],['optimization']
Performance,"> ```julia; > [ Info: ... simulation initialization complete (1.471 minutes); > [ Info: Executing initial time step...; > ERROR: LoadError: TaskFailedException; > ; > nested task error: TaskFailedException; > ; > nested task error: type Tuple has no field surface_TKE_flux; > Stacktrace:; > [1] getproperty(x::Tuple{CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.MixingLength{Float64}, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.SurfaceTKEFlux{Float64}}, AnisotropicDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Float64, Float64, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}}}, f::Symbol); > @ Base ./Base.jl:33; > [2] call; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:456 [inlined]; > [3] fallback; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:454 [inlined]; > [4] overdub; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:279 [inlined]; > [5] overdub; > @ ~/.julia/packages/Oceananigans/H39qI/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/surface_TKE_flux.jl:39 [inlined]; > [6] getbc(::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.TKETopBoundaryConditionParameters{NamedTuple{(:b, :c, :e), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{NamedTuple{(:Ly, :Lz, :Qᵇ, :y_shutoff, :τ, :μ, :ΔB, :H, :h, :y_sponge, :λt), NTuple{11, Float64}}, typeof(buoyancy_flux)}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, NamedTuple{(:u, :v), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030744418:129,Load,LoadError,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030744418,1,['Load'],['LoadError']
Performance,"> and we'll only have to dispatch on one type instead of three. I guess the point of this design is to simplify more generalized dispatch by ""unfusing"" the three directions. The solution you're proposing is simply returning to what we were doing before, right?. Note one immediate advantage: the `nodes` function now works with *any* field (and the implementation is actually less code than before). We lose this feature and must return to dispatching on lots of different cases (as you say, unions), if we fuse the three directions into one type. . However, this becomes even more critical when we think about abstracting operators. When performing an `x` derivative, for example, we know that the field changes location from `{Cell, Y, Z}` to `{Face, Y, Z}`. If the directions were fused, we would have to code each 3D case manually, rather than the 1 (or 2) cases we need with this design. When writing an abstracted interpolation function from an arbitrary location `X1, Y1, Z1` to `X2, Y2, Z2`, it greatly simplifies the task if the directions are ""unfused"". I think it's also easier to reason about abstracted operators on fields this way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/409#issuecomment-531763391:639,perform,performing,639,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/409#issuecomment-531763391,1,['perform'],['performing']
Performance,"> as performance during testing doesn't matter. We do have a small number of tests that might benefit from faster code, like the pressure solver convergence tests? . > Should we still consider merging this? Once tests run I can do a comparison to see how many minutes (or seconds?) `-O0` saves us?. If it doesn't slow the tests down, I'm happy to merge and we can consider changing the optimization level in the future if its warranted. I think being explicit and deliberate about it is a positive change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1078#issuecomment-712844340:5,perform,performance,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1078#issuecomment-712844340,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"> new HorizontallyAveragedVerticalProfile diagnostic that can calculate; > vertical profiles efficiently on-the-fly on CPUs and GPUs. Other; > diagnostics like product and covariance profiles can be built on top of it.; >; > HorizontallyAveragedVerticalProfile is kind of a mouthful, suggestions; > welcome if anyone has a better name. I wanted to explicitly state; > ""horizontally averaged"" as vertical profiles are commonly used as well and; > imply no averaging.; >; > The profile can be passed to an output writer which can write it to disk.; >; > The horizontal averaging currently relies on a parallel reduction prefix; > sum algorithm that I hacked over a CUDAnative.jl example, although I do; > have a test for the diagnostic so it does work. The algorithm can be more; > efficient (see JuliaGPU/CuArrays.jl#68; > <https://github.com/JuliaGPU/CuArrays.jl/issues/68>).; >; > It allocates very minimal amounts of memory (less than mean) and; > benchmarks show that it is ~20x faster than what we were doing before; > (copying to CPU and calculating there) which is great but it's ~5x slower; > than optimal performance.; >; > As it does not allocate memory, we can now calculate vertical profiles; > even when running large models that fill up memory.; >; > Although I should mention that an intermediate array with a size of at; > least 1*Ny*Nz is required for the parallel reduction step (so I'm using; > poisson_solvers.storage because it's a vanilla CuArray that can be; > overwritten).; >; > N, H = 512, 1; > T = N + 2H; >; > a = rand(T, T, T) |> CuArray; > h = zeros(N) |> CuArray; >; > What we were doing before:; >; > @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]); >; > BenchmarkTools.Trial:; > memory estimate: 1.01 GiB; > allocs estimate: 250; > --------------; > minimum time: 684.013 ms (2.29% GC); > median time: 712.570 ms (6.28% GC); > mean time: 732.480 ms (8.79% GC); > maximum time: 807.437 ms (16.95% GC); > --------------; > samples: 7; > ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520187010:1276,perform,performance,1276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520187010,1,['perform'],['performance']
Performance,"> the constructors of a CuSparseMatrix are different from the ones for a SparseMatrix. Can the constructors for CuSparse be derived from Sparse? If so, we just build the sparse on CPU, and then implement `arch_array`. > It means that we will first have to create the full matrix (of size Nx * Ny x Nx * Ny!!) Or is this computationally/memory-wise restrictive?. I think you should avoid allocating the whole matrix and build the sparse representation on the fly. The sparse representation is like a graph --- we add nodes only when they exist. Once we've built the graph, we can convert it to a computationally efficient format for time-stepping on CPU or GPU. > Also it is kind of a brute force which would be quite computationally inefficient because it scales badly. I propose we get this up and running in 2D and see whether this is a feasible calculation to perform during model construction. There is the question of preconditioners / changing time-step. Do the sparse matrix implementations we work with have efficient implementations for operations like. ```julia; A += b * I; ```. where `I isa UniformScaling` and `b` is a scalar?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109680238:863,perform,perform,863,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109680238,1,['perform'],['perform']
Performance,> the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. What does this have to do with putting boundary conditions in operators?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2356567627:14,perform,performance,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2356567627,1,['perform'],['performance']
Performance,"> then we'd have to rewrite loads of stuff to make it so the user can specify whatever they want for the external state. I think see your point (I'm not sure I grasp the totality of it). Is your point that we are able to _re-use_ more existing code if we allow `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction` as `condition`? I didn't understand this previously so thank you for clarifying. To re-use that code with a new `condition`, we can use a nesting technique:. ```julia; function getbc(open_bc::OpenBoundaryCondition, ...); state_value = getbc(open_bc.condition.external_state, ...); # other stuff related to matching; end; ```. This means that we don't have to rewrite anything, we just add new functionality for open boundary conditions on top. You could make the point that we have less _new_ code to write though, if we implement a design that allows conditions to be the same. And for users, this could be clearer, so I see the advantage of that. On the flip side, the advantage of making a new `OpenCondition` is that `getbc` retains its meaning as ""the function that returns the boundary condition value"". When we have an external state + matching scheme, the boundary condition values are not exactly the external state and are modified by the matching scheme. So I see pros and cons to both, but the good news is that we can actually talk coherently about the pros and cons. And if there are other pros and cons please mention them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988781194:28,load,loads,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988781194,1,['load'],['loads']
Performance,> we now perform tons of little memory allocations somewhere. But only on CPU?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/395#issuecomment-530398617:9,perform,perform,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/395#issuecomment-530398617,1,['perform'],['perform']
Performance,"> why not replace `const ƞ = 2` with `const ƞ = 2.0`, i.e. with a Float64?. I believe that if we do this, then we have to live with WENO5 that's 20x slower than the other schemes. I believe its the exponentiation with `Float64` that is slow (since exponentiation is compute intensive in general in my understanding) --- not the conversion from Int64 to Float64 (type conversions between numeric types are basically instantaneous as far as I know). In other words, the function `pow` for exponentiation with `Float64`:. https://github.com/JuliaGPU/CUDA.jl/blob/5d6127dbbef495c94d3dd8de98162188062e11b1/src/device/intrinsics/math.jl#L218. creates a bottleneck in simulations that use WENO5, whereas using `powi`:. https://github.com/JuliaGPU/CUDA.jl/blob/5d6127dbbef495c94d3dd8de98162188062e11b1/src/device/intrinsics/math.jl#L221. is much faster. > My understanding is that replacing it with with Int32 can make us forfeit some precision, no?. Why is that?. I believe we only need `Int64` if we need to represent very large integers. `Int32` integers can range from +/- 2^32 - 1, whereas 64 bit integers can range from +/- 2^64 - 1. Since 2 is represented with `Int32` there's no need to express its value in `Int64`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869776360:647,bottleneck,bottleneck,647,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869776360,1,['bottleneck'],['bottleneck']
Performance,"> would there be 30+ nested parameterized types for ModelBoundaryConditions. Is/should that be a concern?. @ali-ramadhan do you mean with regards to performance? I'm not sure. With multiple dispatch being core to julia it seems this scenario is not uncommon (30+ may not be very large). > Just one initial question: I might be misunderstanding the purpose of bc.calc but why not bc.impose(args...) instead of bc.calc(args...) as we usually say that we impose boundary conditions?. The function `calc` does not actually impose a boundary condition --- the imposition of boundary condition depends on, for example, the viscosity and diffusivity, and is a property of the equation (or turbulent closure) being implemented. Again for example, the K-Profile-Parameterization includes a modification of how a flux boundary condition is implemented. In other words, the ""specification of flux"" is separate from the ""imposition of a boundary condition"". The former is determined by the user. The latter is determined by the model/governing equation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472225606:149,perform,performance,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472225606,1,['perform'],['performance']
Performance,">Maybe I am misunderstanding you, but isn't that already what is done in the horizontal convection example?. No, you are understanding me! I think you're on to something. > Is the intended behavior that output writers automatically call fill_halo_region! before saving when with_halos=true?. Ah no this is not default. However, for prognostic fields, the halos are filled within `update_state!`:. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl#L24C1-L24C1. However, halos are not filled for diagnostic fields. We probably don't want to make filling halos default, since filling halo regions is expensive and useful only for a subset of experiments. However, we could add a keyword argument to `JLD2OutputWriter`, something like `fill_halos = true`. (Thinking about this with a little more coffee, it probably doesn't make sense to add something like this, because generally speaking the halo values for diagnostic fields are not useful except for periodic boundary conditions; only prognostic fields can have specified / meaningful boundary conditions.). I wonder if this is a bug in `FieldTimeSeries`. Are you using `FieldTimeSeries` to compute the diagnostics offline? Perhaps the halo data is saved correctly, but is not loaded correctly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689838510:1333,load,loaded,1333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689838510,1,['load'],['loaded']
Performance,">[AMGX.jl](https://github.com/JuliaGPU/AMGX.jl) only has prebuilt libraries for linux systems. That said, calling using AMGX will fail on, e.g., Mac OS X. What's the best way to optionally load AMGX.jl? Or is there another way around that?. We may be able to optionally call `using AMGX` + all the `AMGX`-related functionality by using:. [`@static` + `islinux()`]( https://docs.julialang.org/en/v1/manual/handling-operating-system-variation/) + [`CUDA.has_cuda_gpu()`](https://cuda.juliagpu.org/stable/api/essentials/#CUDA.has_cuda_gpu)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1244923054:189,load,load,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1244923054,1,['load'],['load']
Performance,"@ChrisRackauckas can the constant-dt Runge-Kutta methods be adapted to accept a changing time-step? This is important because we often have external criteria available (the CFL criterion, for example) that can be used to adapt time-step size. As for the fractional step method, we can also write a function that performs the fractional step algorithm using two substeps and an implicit pressure solve. Multiple fractional steps can then be embedded in a multi-step algorithm like Runge-Kutta; this may provide a route to integration with DifferentialEquations.jl. Note that the implicit pressure solves that forms the second part of the fractional step method requires a specialized fast solver for the 3D elliptic problem. We use this method:. https://www.sciencedirect.com/science/article/pii/0021999188901027. Integration with DifferentialEquations.jl will require integration of this FFT-based Poisson/Helmholtz solver into the algorithm. Our implicit solves are usually coupled, such that they require the use of fast methods for the solution of elliptic PDEs to time-step efficiently (either the FFT-based algorithm described above, or a fast batched tridiagonal solver for the GPU that we are currently working on). Can the user provide their own fast solver for implicit time stepping with the split ODE solver?. Our time-stepping method is roughly described here:. https://climate-machine.github.io/Oceananigans.jl/stable/manual/time_stepping/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/391#issuecomment-549149954:312,perform,performs,312,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/391#issuecomment-549149954,1,['perform'],['performs']
Performance,"@Yixiao-Zhang do you want to open a PR?. Sensible errors on GPU are a persistent problem... this seems like one of the trickiest though... I think the best easy thing we can do in this case is to add an article in our Wiki about how to debug `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`, making @simone-silvestri 's points. For documentation the error being referred to is. ```julia; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemcpyHtoDAsync_v2; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #unsafe_copyto!#9; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:397 [inlined]; [5] (::CUDA.var""#1012#1013""{ComplexF64, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, Int64, Vector{ComplexF64}, Int64, Int64})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:464; [6] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [7] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [8] unsafe_copyto!(dest::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, doffs::Int64, src::Vector{ComplexF64}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:457; [9] copyto!; @ ~/.julia/packages/CUDA/35NC6/src/array.jl:415 [inlined]; [10] setindex!(::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, ::ComplexF64, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:20; [11] setindex!; @ ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:24 [inlined]; [12] macro expansion; @ ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:136 [inlined]; [13] solve!(ϕ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332:435,Load,LoadError,435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332,1,['Load'],['LoadError']
Performance,"@ali-ramadhan , I tried running the example using the following `julia --project -p 4 mpi_shallow_water_turbulence.jl; `, and it seemed to fail because of error, see below. Any idea what I might have done wrong?. ```; ERROR: LoadError: ProcessExitedException(3). ...and 2 more exception(s). Stacktrace:; [1] sync_end(::Channel{Any}) at ./task.jl:314; [2] macro expansion at ./task.jl:333 [inlined]; [3] _require_callback(::Base.PkgId) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Distributed/src/Distributed.jl:75; [4] #invokelatest#1 at ./essentials.jl:710 [inlined]; [5] invokelatest at ./essentials.jl:709 [inlined]; [6] require(::Base.PkgId) at ./loading.jl:931; [7] require(::Module, ::Symbol) at ./loading.jl:923; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/examples/mpi_shallow_water_turbulence.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-792895347:225,Load,LoadError,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-792895347,3,"['Load', 'load']","['LoadError', 'loading']"
Performance,"@ali-ramadhan ; Thanks for the suggestion. I tried running it on the CPU and got a different error message, which is shown below. Additionally, the error occurs when defining background fields in the model as such; ```julia ; background_fields = Oceananigans.BackgroundFields(; background_closure_fluxes=true, b=B̄_field); ```; But it runs fine like the usual way; ```julia; background_fields = (; b=B̄_field); ```. ```; [ Info: Initializing simulation...; ERROR: LoadError: type BackgroundFields has no field u; Stacktrace:; [1] getproperty; @ ./Base.jl:37 [inlined]; [2] assemble_closure_velocities; @ ~/.julia/packages/Oceananigans/xmqSH/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:35 [inlined]; [3] u_velocity_tendency; @ ~/.julia/packages/Oceananigans/xmqSH/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:92 [inlined]; [4] cpu_compute_Gu!; @ ~/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; [5] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; [6] __run(obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck, static_threads::Bool); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; [7] (::KernelAbstractions.Kernel{…})(::Field{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; [8] (::KernelAbstractions.Kernel{…})(::Field{…}, ::Vararg{…}); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; [9] launch!(::CPU, ::ImmersedBoundaryGrid{…}, ::Symbol, ::typeof(Oceananigans.Models.Nonhydros",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2432725343:464,Load,LoadError,464,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2432725343,1,['Load'],['LoadError']
Performance,"@ali-ramadhan I found that expanding the tuple did not affect performance, while adding `@inbounds` was dramatic. Tips on writing performant (and also GPU compile-able) forcing functions is a good idea. `@inbounds` seems to be the main trip-up for us.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/365#issuecomment-525328128:62,perform,performance,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/365#issuecomment-525328128,2,['perform'],"['performance', 'performant']"
Performance,"@ali-ramadhan I'm running on my desktop's GPU just to get a sense of the performance increase at the moment. According to `nvidia-smi` my card is a `NVS 310` (I apologize if I didn't get that right, I really have zero experience with GPUs). I'll create another issue to report this properly. Thanks for the feedback, though!. And I'm running our own group's LES model. Unfortunately I'm not allowed to share the code, but you can read about it [here](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/2018GL080296). @glwagner I'd be very willing to compare performances of our LES with Oceananigans. The caveats here being that; - our model of choice ([lagrangian-averaged scale-dynamic](https://aip.scitation.org/doi/10.1063/1.1839152)) takes relatively long to calculate compared to other models, but generally needs lower resolution to achieve the same results (so in this sense it might be similar to AMD) and that; - I'm not sure how relevant it would be to compare with us, being that I'm not allowed to share the source code. If you're still interested to make a comparison just let me know! I'd be happy to help. @ali-ramadhan @glwagner I'm not expecting at all to run their simulation at the resolution that they're running. My intent was to set-up the same case (but very coarse) and see how much I could increase the resolution (and how much activity I could see) until it became too slow or until I ran out of memory. This is basically a fun side-project, and not an actual research attempt if I'm being honest :). Thank you both for the helpful responses! I'm glad to help with whatever bugs or attempts at simulations that I can!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539785839:73,perform,performance,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539785839,2,['perform'],"['performance', 'performances']"
Performance,"@ali-ramadhan I've addressed your concerns: we now have a LES regression test, and some changes to inner kernels means that performance is now *improved* by this PR over master (for large models).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452#issuecomment-543208118:124,perform,performance,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452#issuecomment-543208118,1,['perform'],['performance']
Performance,"@ali-ramadhan agree that good performance would be great. I think that having a flexible and maximally useful feature might be a higher priority though. @johncmarshall54 's requirements provide a good design target, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-733191938:30,perform,performance,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-733191938,1,['perform'],['performance']
Performance,"@ali-ramadhan and @glwagner I tried the code below in some simple tests while waiting; for my car to be serviced. . ```; using Pkg; Pkg.add(""LinearAlgebra""); using LinearAlgebra. function solveLinearSystem(A,f); # Solve Aϕ=f; tol=1.e-12; E=eigen(A);; L=E.values;; V=E.vectors;; # Get amplitudes, F, of eigenvectors that give f; F=V'*f; # Get inverse eigenvalues (zeroing inverse for v. small ones); rL=map(x -> if (abs(x)>tol) 1.0/x; else 0. ; end , L);; # Get amplitudes, Φ, of eigenvectors that give ϕ; Φ=F.*rL; # Solve for ϕ given Φ; ϕ=V*Φ; println(A*ϕ,f,ϕ); return ϕ; end. Acyc=[-2. 1 1; 1 -2. 1; 1 1 -2.];; Aneu=[-1 1 0; 1. -2. 1; 0. 1. -1];; s=size(Acyc);; nx=s[1];; g=rand(nx+1,1);; divg=g[1:end-1]-g[2:end]; mdivg=sum(divg)./size(divg)[1]; divg=divg.-mdivg; solveLinearSystem(Acyc,divg); solveLinearSystem(Aneu,divg); ```. This is algorithm that underlies the FFT approach. The FFT just optimizes (and makes it more complicated) by utilizing the fact that the eigenvector/eigenvalue coefficients for the simple, constant spacing Poisson problem, are the cos and sin terms in an FFT. Code appears to work so I am going to try and hack together a ""_plugin_"" for ```solve_poisson_3d_mbc```. . The code won't be super high performance (or work for really big problems) but (fingers crossed) it should give something clean (and short) to get started and help with debugging/optimizing on GPU. Then we can work on various FFT approaches on CPU and GPU (3-d FFT, 2-d + cyclic reduction), Greg's thought on saving for gradients in continuous form. . In principle the eigenvectors and eigenvalues above should correspond with amplitudes that come out of FFTW - except that there are a bunch of 1/2 factors, N versus m numbers, complex versus split cos/sin notation bits that need to be carefully understood etc.... . Just going to learn a little about sparse matrices in Julia - I assume they must exist! Hopefully the car will take a little longer to be finished. . Chris",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-442521365:895,optimiz,optimizes,895,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-442521365,3,"['optimiz', 'perform']","['optimizes', 'optimizing', 'performance']"
Performance,"@ali-ramadhan can you maybe summarize the problem? Sounds like there are some non-trivial trade-offs; eg opening and closing is expensive, so you don't want to do it often; but optimization has downsides... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1227#issuecomment-739537712:177,optimiz,optimization,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1227#issuecomment-739537712,1,['optimiz'],['optimization']
Performance,"@ali-ramadhan currently waiting for the preview to load so that I can merge, but I don't think it'll do that with the GPU test failing. How do we fix that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819553284:51,load,load,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819553284,1,['load'],['load']
Performance,@ali-ramadhan do you mind running some benchmarks to test for performance regression under this PR?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496335163:62,perform,performance,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496335163,1,['perform'],['performance']
Performance,"@ali-ramadhan do you mind running the benchmarks again?. There are still some performance issues, especially with `ConstantSmagorinsky`. But I think it might be wise to deal with these in a future PR if we are happy with these changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496891797:78,perform,performance,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496891797,1,['perform'],['performance']
Performance,"@ali-ramadhan ok, that sounds good to me to run in a separate PR. To clarify, is the intent of this PR to perform benchmarking, or just to ensure that the benchmark scripts do not fall out of date?. If the goal is the latter, it could make sense to decrease the size of the benchmark run to as small a model as possible --- 16^3? . What's the increase in the time taken to run a test? Looks like its about 1/3, from 20m to 30m? That's not so bad, but we should make sure this is what we want given that we may not be able to use the benchmark run output directly due to stochasticity in the Travis build. Looks like gitlab is failing...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/727#issuecomment-613360541:106,perform,perform,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/727#issuecomment-613360541,1,['perform'],['perform']
Performance,@ali-ramadhan this looks good. Be good to chat next week. The general FV piece intersects with thinking about one day being able to do LES with bathymetry and still some performance.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/471#issuecomment-541363473:170,perform,performance,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471#issuecomment-541363473,1,['perform'],['performance']
Performance,@ali-ramadhan why not broadcast over CuArrays? Is there a Performance hit?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/104#issuecomment-469749450:58,Perform,Performance,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/104#issuecomment-469749450,1,['Perform'],['Performance']
Performance,"@christophernhill : I wanted to confirm that I took your clever idea of using `select_device()` and added that into my code. When I ran it on 1, 2 and 4 GPUs I was able to get efficiences of 97 percent. So the code is performing very well, and the server can be efficent on multi GPUs. . The link to where the function is defined is copied below. Is this something that is done automatically in Oceananigans through `AbstractKernels.jl` or something else?. https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/src/select_device.jl. In chatting with the developers of `ImplicitGlobalGrid.jl` they mentioned that to get efficiency I should use something called `@hide_communication` in `ParallelKernel.jl`. Again, I don't pretend to understand what this does but wanted to share the information I was given. https://github.com/omlins/ParallelStencil.jl/blob/main/src/ParallelKernel/hide_communication.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885799405:218,perform,performing,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885799405,1,['perform'],['performing']
Performance,"@christophernhill Do you know if it's possible/reasonable to change the Slurm limit on Satori to 4 GPUs per user (instead of the current 1 job/1 node/4 GPU limit)? If it's a helpful change to other Satori users and does not impact cluster performance/scheduling, it might help enable all the automation we develop for Satori to seamlessly work on other clusters?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1137#issuecomment-720610838:239,perform,performance,239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1137#issuecomment-720610838,1,['perform'],['performance']
Performance,"@christophernhill I also took a look at the `GFlops.jl` package. As said on its homepage: ""GFlops.jl does not see what happens outside the realm of Julia code. It especially does not see operations performed in external libraries such as BLAS calls.""; It works similarly to the profile macro and it can count basic math operations performed by whatever follows the macro or benchmark it for its Flops metric. These doesn't seem to work with simulations but works fine for `time_step!(model, 1)` due to the benchmarking process performing many evaluations of the code.; For the nonhydrostatic model running on CPU, `@count_ops` did not produce any results for either the simulation run or the time_step!, and `@gflops` produced the results below for time step!:; ```; 0.02 GFlops, 0.04% peak (1.89e+07 flop, 1.01e+00 s); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898103351:198,perform,performed,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898103351,3,['perform'],"['performed', 'performing']"
Performance,"@francispoulin ! No worries about the question. I like questions. To answer your latest question --- our nonhydrostatic pressure solver is based on FFTs for regular grids and is therefore quite fast. In simple benchmarks long ago we found that other parts of the algorithm dominated the cost of a time-step. Because of that we aren't sure that having a hydrostatic-only solver would help. Of course, the story is different if we need to stretch the grid in horizontal directions. That said, it would still be interesting to be able to solve hydrostatic-only problems. This would complicate the algorithm a bit because you have to distinguish the barotropic mode, and perform a 2D pressure solve. We already have a function to integrate the buoyancy field to obtain the hydrostatic pressure. For ""things I want worked on"" my wish list falls into three categories: new physics features, new numerics / algorithms, and more boring software / UI work. Here's a couple... 1. Finishing the vertically-stretched grid implementation (numerics). We started work on this but its incomplete. This is a tricky and arduous task but would be quite nice to have... 2. Vertically-implicit time-stepping for diffusion terms (numerics). Ocean models typically use a time-stepping method that treats vertical diffusion terms implicitly. We haven't worried about this because we are focused on LES for the most part, or problems with very little diffusion. But ultimately we will need this, especially when we get around to implementing boundary layer closures. We have a tridiagonal solver that works on the GPU, so in some respects the hard work is already done for this problem. 3. Closures for LES and ocean modeling (Dynamic Smagorinsky, Deardorff, k-epsilon, Gent-McWilliams, convective adjustment (?) etc --- physics). We have a need to implement new turbulence closures new and old alike. Gent-McWilliams is probably easy since we already have a Leith closure implemented which calculates the tensor needed to rot",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281:667,perform,perform,667,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281,1,['perform'],['perform']
Performance,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:1356,tune,tune,1356,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441,1,['tune'],['tune']
Performance,@francispoulin I think it's always helpful to post the full error and stacktrace. From your original post. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!; ```. suggests that the error could be happening since `b̄` is being used in a `ComputedField`'s `compute!`: https://github.com/CliMA/Oceananigans.jl/blob/9eca5780658bb8f5c0debd34146a0ad5cb73c872/examples/inertially_unstable_jet.jl#L51,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815055237:119,Load,LoadError,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815055237,1,['Load'],['LoadError']
Performance,"@francispoulin sounds like a good plan! Then we can see how to proceed. Concerning the way forward with `WENOVectorInvariant`, it seems that it is very diffusive when compared to standard WENO. an example on a 256^2 periodic Bickley jet below, contours are of vertical vorticity (left) and zonal velocity (right). WENO5. https://user-images.githubusercontent.com/33547697/157509797-d61f45ba-8284-40f2-b9e9-4cafcba6db68.mp4. WENOVectorIvariant. https://user-images.githubusercontent.com/33547697/157533165-9281949b-1579-462d-ad16-e27b2f954969.mp4. Integrated Enstrophy (blue is 64^2, red is 128^2, green is 256^2, solid lines are WENO5, dashed are WENOVectorInvariant); ![enstrophy](https://user-images.githubusercontent.com/33547697/157510310-3acfaeaf-4d05-4fac-b332-e7b66563147e.png). @sandreza was pointing out that maybe the extra diffusivity comes from the fact that we are advecting vorticity which contains much thinner structures than velocity, then maybe the ""optimal WENO weight"" are not so optimal anymore. These weights are 3 constant parameters, which are quite empirical and ""free-to-choose"" (in our case just `1/10` for the downstream, `6/10` for the central and `3/10` for the upstream stencil). Dissipation can be reduced by increasing the ""central stencil weight"". The idea with @sandreza was to perform an easy calibration to try to ""reasonably"" preserve enstrophy in the Bickley jet (then maybe calibrate it also against the spherical bicklet jet or R-H waves where also Coriolis is involved). The objective is to completely eliminate explicit viscous dissipation in the horizontal direction (harmonic and/or biharmonic) for the global simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741:1313,perform,perform,1313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741,1,['perform'],['perform']
Performance,"@glwagner ; After merging this PR and running it on the GPU, I encounter the following error. (I'm using Julia 1.10.2 and Oceananigans v0.92.0):. ```; [ Info: Initializing simulation...; ERROR: LoadError: InvalidIRError: compiling MethodInstance for Oceananigans.Models.NonhydrostaticModels.gpu_compute_Gu!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(10, 10, 10)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 10)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, ::OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ::ImmersedBoundaryGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Periodic, Bounded, RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, Nothing, Nothing, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, Float64, Nothing, Nothing, Nothing}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, Nothing, Nothing}, ::Nothing, ::Tuple{WENO{3, Float64, Nothing, Nothing, Nothing, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, ConstantCartesia",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700:194,Load,LoadError,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700,1,['Load'],['LoadError']
Performance,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426:140,perform,performances,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426,2,['perform'],"['performance', 'performances']"
Performance,@glwagner Do you think you'll have some time to review this PR this week?. It affects a lot of code you've written and is a bit of a bottleneck as it refactors a lot of the existing code.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/529#issuecomment-558325070:133,bottleneck,bottleneck,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/529#issuecomment-558325070,1,['bottleneck'],['bottleneck']
Performance,"@glwagner I'm running into a similar issue (v0.30.0):. ```; ERROR: LoadError: AssertionError: CUDAdrv.jl did not successfully initialize, and is not usable.; Stacktrace:; [1] libcuda at /home/mike/.julia/packages/CUDAdrv/Uc14X/src/CUDAdrv.jl:82 [inlined]; [2] (::CUDAdrv.var""#535#cache_fptr!#11"")() at /home/mike/.julia/packages/CUDAapi/XuSHC/src/call.jl:31; [3] macro expansion at /home/mike/.julia/packages/CUDAapi/XuSHC/src/call.jl:39 [inlined]; [4] macro expansion at /home/mike/.julia/packages/CUDAdrv/Uc14X/src/libcuda.jl:36 [inlined]; [5] macro expansion at /home/mike/.julia/packages/CUDAdrv/Uc14X/src/error.jl:110 [inlined]; [6] cuDeviceGetCount at /home/mike/.julia/packages/CUDAapi/XuSHC/src/call.jl:93 [inlined]; [7] length at /home/mike/.julia/packages/CUDAdrv/Uc14X/src/devices.jl:105 [inlined]; [8] iterate(::CUDAdrv.DeviceSet, ::Int64) at /home/mike/.julia/packages/CUDAdrv/Uc14X/src/devices.jl:100 (repeats 2 times); [9] iterate at ./iterators.jl:139 [inlined]; [10] iterate(::Base.Iterators.Enumerate{CUDAdrv.DeviceSet}) at ./iterators.jl:138; [11] top-level scope at /home/mike/.julia/packages/Oceananigans/1xP6n/src/Oceananigans.jl:131; [12] include(::Module, ::String) at ./Base.jl:377; [13] top-level scope at none:2; [14] eval at ./boot.jl:331 [inlined]; [15] eval(::Expr) at ./client.jl:449; [16] top-level scope at ./none:3; in expression starting at /home/mike/.julia/packages/Oceananigans/1xP6n/src/Oceananigans.jl:124; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/788#issuecomment-653563655:67,Load,LoadError,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788#issuecomment-653563655,1,['Load'],['LoadError']
Performance,"@glwagner [AMGX.jl](https://github.com/JuliaGPU/AMGX.jl) only has prebuilt libraries for linux systems. That said, calling `using AMGX` will fail on, e.g., Mac OS X. What's the best way to optionally load AMGX.jl? Or is there another way around that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241308749:200,load,load,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241308749,1,['load'],['load']
Performance,"@glwagner please help here... I can't even say `using Oceananigans`.... ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: LoadError: LoadError: UndefVarError: NFBC not defined; Stacktrace:; [1] top-level scope; @ ~/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; [2] include(mod::Module, _path::String); @ Base ./Base.jl:386; [3] include(x::String); @ Oceananigans.BoundaryConditions ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; [4] top-level scope; @ ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:45; [5] include(mod::Module, _path::String); @ Base ./Base.jl:386; [6] include(x::String); @ Oceananigans ~/Research/OC/src/Oceananigans.jl:1; [7] top-level scope; @ ~/Research/OC/src/Oceananigans.jl:173; [8] include; @ ./Base.jl:386 [inlined]; [9] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1213; [10] top-level scope; @ none:1; [11] eval; @ ./boot.jl:360 [inlined]; [12] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [13] top-level scope; @ none:1; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; in expression starting at /Users/navid/Research/OC/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_fSB7qw.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334:190,Load,LoadError,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334,3,['Load'],['LoadError']
Performance,"@glwagner that sounds like a good strategy, ideally you would want to front-load the most useful tests for catching errors to the degree possible (the whole goal here is to reduce iteration time). If using Linux we can have up to 60 concurrent actions going so spawning as many as is useful for reducing the iteration time is the correct strategy (probably you could set this up as a job matrix for compactness). If spawning up a ton of github actions you can maximize concurrency by killing stale jobs (old push commits) as we do here: https://github.com/CliMA/ClimaCore.jl/blob/main/.github/workflows/Linux-UnitTests.yml#L24",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906584759:76,load,load,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906584759,3,"['concurren', 'load']","['concurrency', 'concurrent', 'load']"
Performance,"@glwagner the solution seems the same but two difference are that (1) `VectorInvariant` does not crash, (2) `WENOVectorInvariant` deviates from the pattern later. ; ; In this paper https://www.tandfonline.com/doi/pdf/10.3402/tellusa.v52i2.12258 they claim that : ""In the FV model, small departures from the flow pattern are triggered initially by grid related truncation errors but subsequently grow through the dynamical instability"" . I guess ""time-to-instability"" is itself a diagnostic of the performance of the scheme? . @francispoulin As implemented in (https://reader.elsevier.com/reader/sd/pii/S0021999105800166?token=A3A72AC493072CED8ECF098513A0BD1F822D2F2224207E533C86FB7D40361903E7AC0B4304841E64E089CBBFCEAFD08B&originRegion=us-east-1&originCreation=20220308154939) the cosine bell advection only tests the tracer advection, do you have any example of a test of that kind that tests momentum advection?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061931114:497,perform,performance,497,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061931114,1,['perform'],['performance']
Performance,"@glwagner, @navidcy ; Poll to decide where to put `η` in `z`. . The possibilities are:; - location `Face`, index `grid.Nz+1`. Pros: natural location of `η` field (same position of the `w` velocity).; - location `Center`, index `grid.Nz`. Pros: every calculation dealing with `η` is now performed at centers (ex `Az_∇h²ᶜᶜᶜ` and `linear_operation!`. . In case of the second option should we change all the metrics to reflect the fact that we are at faces?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1248631573:286,perform,performed,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1248631573,1,['perform'],['performed']
Performance,"@glwagner, I think you're right that the error is coming from this line:; https://github.com/CliMA/Oceananigans.jl/blob/10a9479ec462f4f5f053e7447ff667fdfe20542d/src/Distributed/distributed_fft_based_poisson_solver.jl#L65; I checked the sizes of these variables, and here xc is sized on the global grid while lambda x is sized on the local grid. I'm not sure which grid this operation is intended to be performed on. The code here is impressively compact but not particularly easy to decipher (at least for me).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067340658:402,perform,performed,402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067340658,1,['perform'],['performed']
Performance,"@glwagner, regarding the; ```Julia; ERROR: LoadError: UndefVarError: bc not defined; ```; in the Docs, is it related to; https://github.com/JuliaDocs/Documenter.jl/issues/228; perhaps?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1843#issuecomment-879623792:43,Load,LoadError,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1843#issuecomment-879623792,1,['Load'],['LoadError']
Performance,"@hennyg888 do you have the same problems using MPI instead of multi-threaded, and on the same CPU ( Intel(R) Xeon(R) Platinum 8260 CPU @ 2.40GHz ). ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880838040:62,multi-thread,multi-threaded,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880838040,1,['multi-thread'],['multi-threaded']
Performance,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:709,load,load,709,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444,1,['load'],['load']
Performance,"@matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. ; For the moment those two elements are part of this PR. This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft,; the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521:47,perform,performant,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521,1,['perform'],['performant']
Performance,"@navidcy I'm trying to add a drag flux to this example like we talked about in https://github.com/CliMA/Oceananigans.jl/issues/3148 but I'm getting an error that I can't figure out. Using `u` as an example, I'm trying to implement the BCs as . ```julia; @inline u_drag(x, y, t, u, v, w, p) = - p.cᵈ * u * √(u^2 + v^2 + w^2); @inline u_drag(x, y, z, t, u, v, w, cᵈ) = u_drag(x, y, t, u, v, w, cᵈ). u_drag_bc = FluxBoundaryCondition(u_drag, field_dependencies=(:u, :v, :w), parameters=(; cᵈ=1e-3)); boundary_conditions = (u = FieldBoundaryConditions(bottom=u_drag_bc),); ```. but when time-stepping the model I get. ```; ERROR: LoadError: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, ::NamedTuple{(:u, :v, :w, :b, :η), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.Cent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1667152069:626,Load,LoadError,626,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1667152069,1,['Load'],['LoadError']
Performance,"@navidcy In the context of Enzyme (a tool for automatically differentiating LLVM), to ""mark"" a function as non-differentiable means to use `inactive_noinl` to tell Enzyme that it should not try to apply the chain rule to that function. Marking functions as non-differentiable has various reasons but here the reason is given as ""performance"". The code changed is also quite short so I think the description is complete.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3799#issuecomment-2383154154:329,perform,performance,329,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3799#issuecomment-2383154154,1,['perform'],['performance']
Performance,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:373,concurren,concurrent,373,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778,1,['concurren'],['concurrent']
Performance,"@navidcy thanks for the review! ; Indeed maybe we should document it. . Just to give a quick explanation of the different flavours. WENO involves the reconstruction of the value of the advected quantity on the face performed on different ""biased stencils"". <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2 ,r} = p_r(x_{i %2B 1/2}) = \sum_{j=0}^k c_{rj} \overline{v}_{i - r %2B j}"">. where <img src=""https://render.githubusercontent.com/render/math?math=p""> is the reconstruction polynomial constructed from the biased stencil <img src=""https://render.githubusercontent.com/render/math?math=r""> and <img src=""https://render.githubusercontent.com/render/math?math=k""> is the order of the polynomial. As we want a 5th order scheme, there will be three polynomials (<img src=""https://render.githubusercontent.com/render/math?math=r = 0, 1, 2"">) with (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Now the coefficients of these polynomials (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are based on the Lagrange interpolation of the integral of <img src=""https://render.githubusercontent.com/render/math?math=\overline{v}_{i}""> and, as such, are coordinate-dependent. The first thing to do, when wanting to implement the WENO scheme on a stretched grid, is then to make sure that the reconstruction is correctly done, and, as such, `WENO5(grid = grid)` takes care that (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are correctly calculated based on the underlying grid. Now, WENO schemes differ from ENO schemes since they do not just choose the ""smoothest stencil"" among the (in this case) three stencils, but weight them as such. <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2} = \sum_{r=0}^k w_{r} v_{i %2B 1/2,r} "">. Those weights have to satisfy <img src=""https://render.githubusercontent.com/render/math?math=\sum_{r=0}^k w_{r} = 1""> and are mostly a matte",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397:215,perform,performed,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397,1,['perform'],['performed']
Performance,@navidcy what's the last version before the catastrophic performance loss? I'll do a benchmark to compare with `main`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480454534:57,perform,performance,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480454534,1,['perform'],['performance']
Performance,"@raphaelouillon I can reproduce `ERROR: LoadError: CUDA error (code 201, CUDA_ERROR_INVALID_CONTEXT)` when running `pkg> test Oceananigans` for `0.28.0`--`0.30.0`. Tests run for `0.27.1`, however.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/788#issuecomment-654868729:40,Load,LoadError,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788#issuecomment-654868729,1,['Load'],['LoadError']
Performance,@sandreza might be a good idea to code up the case we were using the diagnose the race condition as a test and see if we can catch the race condition in CI @ali-ramadhan,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926693915:82,race condition,race condition,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926693915,2,['race condition'],['race condition']
Performance,"@siddharthabishnu, `CUDA.@allowscalar` introduced by [3cdd470](https://github.com/CliMA/Oceananigans.jl/pull/3488/commits/3cdd4705fedf3238d8858bb0f56e9b27b01ba34a) is detrimental for performance. Like it induces O(10-100x) slowdown I think.... Is this a temporary solution?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2033827149:183,perform,performance,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2033827149,1,['perform'],['performance']
Performance,"@simone-silvestri : I tried running the branch in it's current version and received a GPU error. Is this something that works on your machine?. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Guh!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.v; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1130253785:156,Load,LoadError,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1130253785,1,['Load'],['LoadError']
Performance,@simone-silvestri @jagoosw I think this PR may solve the race condition issue. The essential reason is that the Manifest was being re-resolved after init because downstream tests imported additional packages that were not imported during the initial instantiation.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2361545069:57,race condition,race condition,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2361545069,1,['race condition'],['race condition']
Performance,"@simone-silvestri In addition to the NetCDF issue I mentioned [here](https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524), I found out that the `cell_advection_timescale()` and `interior()` aren't working with `MultiRegionGrids` yet. Here's an error example:. ```julia; ERROR: LoadError: type MultiRegionObject has no field parent; Stacktrace:; [1] getproperty; @ ./Base.jl:38 [inlined]; [2] cell_advection_timescale(model::NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, MultiRegionGrid{Float64, Bounded, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, RightConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, RectilinearGrid{Float64, LeftConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}, MultiRegionObject{Tuple{Tuple{Colon, Colon, Colon}, Tuple{Colon, Colon, Colon}}, Tuple{CPU, CPU}}, MultiRegionObject{Tuple{OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}}, Tuple{CPU, CPU}}, Any, MultiRegionObject{Tuple{FieldBoundaryConditions{Nothing, Bo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304574572:300,Load,LoadError,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304574572,1,['Load'],['LoadError']
Performance,"@simone-silvestri Will do!. At the moment I am using `momentum_advection = VectorInvariant()`. If it goes unstable I will try the one you suggested on the other PR. I also tried what you suggested on the other PR,. ```; VectorInvariant(vorticity_scheme = WENO(), kinetic_energy_gradient_scheme = WENO()); ```. This failed because of the error below. Any idea what I need to do to fix this?. ```; ERROR: LoadError: MethodError: no method matching _symmetric_interpolate_yᵃᶜᵃ(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{…}, ::EnergyConserving{…}, ::typeof(Oceananigans.Advection.δx_v²), ::Field{…}, ::Field{…}). Closest candidates are:; _symmetric_interpolate_yᵃᶜᵃ(::Any, ::Any, ::Any, ::ImmersedBoundaryGrid, ::Union{Centered{2}, Centered{3}, Centered{4}, Centered{5}, Centered{6}, UpwindBiased{2}, UpwindBiased{3}, UpwindBiased{4}, UpwindBiased{5}, UpwindBiased{6}, WENO}, ::Any...); @ Oceananigans ~/Software/Oceananigans.jl/src/ImmersedBoundaries/conditional_fluxes.jl:210; _symmetric_interpolate_yᵃᶜᵃ(::Any, ::Any, ::Any, ::ImmersedBoundaryGrid, ::Union{Centered{1}, UpwindBiased{1}}, ::Any...); @ Oceananigans ~/Software/Oceananigans.jl/src/ImmersedBoundaries/conditional_fluxes.jl:207; _symmetric_interpolate_yᵃᶜᵃ(::Any, ::Any, ::Any, ::Any, ::VectorInvariant{<:Any, <:Any, true}, ::Any, ::Any...); @ Oceananigans ~/Software/Oceananigans.jl/src/Advection/vector_invariant_advection.jl:250; ... ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1984534233:403,Load,LoadError,403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1984534233,1,['Load'],['LoadError']
Performance,"@simone-silvestri any tips?. For conditionals, we should use `ifelse`; then there is no issue for performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2737#issuecomment-1252872891:98,perform,performance,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2737#issuecomment-1252872891,1,['perform'],['performance']
Performance,"@simone-silvestri this doesn't seem to be working when the domain is `Bounded` in the x direction. Is this expected?:. ```julia; ERROR: LoadError: MethodError: no method matching PressureSolver(::CPU, ::MultiRegionGrid{Float64, Bounded, Bounded, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, RightConnected, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, RectilinearGrid{Float64, LeftConnected, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}); Closest candidates are:; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number, <:Number}) at ~/.julia/packages/Oceananigans/F1fni/src/Models/NonhydrostaticModels/NonhydrostaticModels.jl:24; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number}) at ~/.julia/packages/Oceananigans/F1fni/src/Models/NonhydrostaticModels/NonhydrostaticModels.jl:25; PressureSolver(::Any, ::ImmersedBoundaryGrid) at ~/.julia/packages/Oceananigans/F1fni/src/Models/NonhydrostaticModels/NonhydrostaticModels.jl:28; ...; Stacktrace:; [1] NonhydrostaticModel(; grid::MultiRegionGrid{Float64, Bounded, Bounded, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1302898706:136,Load,LoadError,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1302898706,1,['Load'],['LoadError']
Performance,@simone-silvestri you mentioned that in this PR the pressure solver is done on a single GPU for the time being. Can https://github.com/CliMA/Oceananigans.jl/pull/2538 be a stating point to optimize that as well? That PR is really close to ready I think,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1302354230:189,optimiz,optimize,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1302354230,1,['optimiz'],['optimize']
Performance,"@tomchor I agree wholeheartedly, both performance and model accuracy are interesting. I focused on performance because I suspect that because `Oceananigans` uses the GPU, it may be substantially faster than existing CPU-based codes. Also, I feel performance optimization can be a bit tricky, and in some cases is limited more by technology / hardware / programming language than software --- thus its important to know where `Oceananigans` stands now so we know how much effort we need to invest there. Implementing a new LES model or upgrading model numerics is, on other hand, typically easier and mostly a case of upgrading high-level software, I think --- especially in a high-level language like julia. We may also have abstractions soon that make implementing new LES models / equations much easier. (Verifying the accuracy of the LES model is another story...). It could be interesting to set up a model intercomparison project like you suggest, similar to what's been done in the atmosphere. We could pick a few physical scenarios for the comparison --- perhaps a reproduction of observations in a place that we think LES might be successful, and perhaps some idealized experiment(s), maybe involving submesoscales or reactive tracers or a combination of the two. Are you interested in helping set something like that up? . We have a nice opportunity at the upcoming Ocean Sciences to coordinate such a project --- people will be there who have deep familiarity with most of the ocean LES codes that I'm aware of (all 7 of them...). In fact, they are all presenting in the boundary layer turbulence session that we are both presenting in!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-540072744:38,perform,performance,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-540072744,4,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,@tomchor I guess we are hoping we can merge without the 3/4 performance penalty.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1190886871:60,perform,performance,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1190886871,1,['perform'],['performance']
Performance,"@tomchor just wanted to echo @ali-ramadhan's thank you for finding that bug!. Right now Oceananigans shines for medium-size LES problems around 256^3, perhaps up to 384^3. For that application I think you may find it is as fast or faster than other codes. On that note, it'd be great to compare performance with other codes for this problem size. . For utterly massive problems like the one reported in the Sullivan paper you've posted, Oceananigans is probably not the right tool right now. We haven't experimented with multi-node parallelism yet, but as @ali-ramadhan suggests, its possible we will start working on either multi-CPU parallelism or multi-GPU parallelism soon. For reproducing the Sullivan paper, you may want multi-CPU parallelism simply because of the sheer number of nodes you'll need. It's worth noting that our AMD turbulence closure *may* be less resolution-dependent than the TKE-based closure used by NCAR LES / Sullivan (and yourself?) and thus it may be possible to run at lower resolution (potentially saving factors of 10-100 in resolution. A [paper by Abkar and Moin (2017)](https://link.springer.com/article/10.1007/s10546-017-0288-4) hints at the potential for very coarse simulations with AMD.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539774569:295,perform,performance,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539774569,1,['perform'],['performance']
Performance,"@tomchor unfortunately we don't have an issue for this problem. @sandreza is it possible to open an issue to document the problem that we are seeing? In the case that this PR does not resolve the issue, we'd like to have an issue open... I don't have much hard evidence to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then co",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:568,race condition,race condition,568,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865,4,['race condition'],['race condition']
Performance,"@tomchor when I get the chance, I will open another issue about performance comparisons and tag you. Right now for 256^3 we are around 0.03--0.05 s per time-step with two tracers and the AMD closure. This means that an 8 day simulation with 5 s time-steps will run in a few hours of wall time. Since we haven't attempted much of any performance optimization, we hope that performance will improve further in the future. It's unclear what will happen for multi-CPU and multi-GPU architectures, however. Interesting that you're using a Lagrangian-averaged dynamic closure. I'd like to see how that compares to AMD. It's possible we could implement a Lagrangian-averaged dynamic closure, but probably not in the near term since I think we'd want to have particle advection features first.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539801646:64,perform,performance,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539801646,4,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"@vchuravy - I modified `src/Grid/zeros_and_ones.jl` to be; ```; using CUDA; using AMDGPU; using Oceananigans.Architectures: CPU, CUDAGPU, ROCmGPU, AbstractArchitecture; using KernelAbstractions; import Base: zeros. zeros(FT, ::CPU, N...) = zeros(FT, N...); zeros(FT, ::CUDAGPU, N...) = CUDA.zeros(FT, N...); zeros(FT, ::ROCmGPU, N...) = KernelAbstractions.zeros(AMDGPU.ROCBackend(), FT, N...). zeros(arch::AbstractArchitecture, grid, N...) = zeros(eltype(grid), arch, N...); zeros(grid::AbstractGrid, N...) = zeros(eltype(grid), architecture(grid), N...). @inline Base.zero(grid::AbstractGrid) = zero(eltype(grid)); @inline Base.one(grid::AbstractGrid) = one(eltype(grid)); ```. This throws the same error as just using `AMDGPU.jl`. For reference. ```; ERROR: LoadError: Not implemented; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] runtime_module(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/interface.jl:173; [3] build_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:101; [4] (::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GP",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936309420:760,Load,LoadError,760,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936309420,1,['Load'],['LoadError']
Performance,"@vchuravy Just benchmarked again with `@unroll` but couldn't see any difference in performance. Good to know about it though, will try it if we have more loops that could be unrolled.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/172#issuecomment-481445838:83,perform,performance,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/172#issuecomment-481445838,1,['perform'],['performance']
Performance,@xkykai do you think you could run some immersed boundary tests with this branch to make sure this change doesn’t affect your work? I think we’re interested in both performance and making sure the solution is high quality.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1582732172:165,perform,performance,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1582732172,1,['perform'],['performance']
Performance,"A consideration when picking up from a checkpoint and using `NetCDFOutputWriter` is that `mode=""a""` (append) needs to be used instead of `mode=""c""` (create or clobber) when creating the `NetCDFOutputWriter`. This functionality works and is tested, but currently needs to be set manually by the user. Not sure of the best way of making this easy for users without accidentally overwriting their data. I can think of three solutions:; 1. Not specifying a `mode` causes `mode=""c""` if the file does not exist and `mode=""a""` if the file does exist. I like this solution the most as it works well with and without a checkpointer (and users don't have to do anything to get reasonable default behavior).; 2. Add a `force` kwarg to `NetCDFOutputWriter` that is `false` by default. The `NetCDFOutputWriter` will error if you try to overwrite an existing file, allowing the user to go back and set `mode=""a""` without any data loss. A `pickup` kwarg could perform a similar function if it's `false` by default.; 3. Setting the `PICKUP` environment variable causes `mode=""a""` to be the default if the file already exists. But I think we should avoid using global environment variables to modify internal behavior.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1068#issuecomment-711035671:945,perform,perform,945,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068#issuecomment-711035671,1,['perform'],['perform']
Performance,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142:849,perform,performance,849,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142,1,['perform'],['performance']
Performance,"A new idea for extending the pressure solver to `MultiRegion` is to divide the FFT computations into ""local"" and ""non-local"" directions. . The FFT in local directions can be easily performed wrapping the transform in `@apply_regionally`; For non local directions, if `storage` and `plan` are `unified_array`s, the non local FFT can be performed by permuting the partitioning of the `MultiRegionGrid` without having to transpose memory (that will happen under the hood thanks to unified memory). . This strategy would not be easily extensible to generally subdivided regions and will play well only with one direction partitioning, but given the current limitations of the FFT solver (only regular grid), I think it is a good strategy to get something to work",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969:181,perform,performed,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969,2,['perform'],['performed']
Performance,"A performance warning is a pretty cool idea. Yes, let's do the changes tomorrow. Agreed that many parametric types becomes cumbersome. I think architecture is appropriate for the current model type (perhaps we will eventually call it `LESModel`... ?) We can define new types for new flavors of model (`HydrostaticModel`, `VariableBathymetryModel`...), rather than introducing type parameters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468538413:2,perform,performance,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468538413,1,['perform'],['performance']
Performance,"ADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fullscreen::Bool, monitor::Nothing, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:344; [4] GLMakie.Screen(; resolution::Tuple{Int64, Int64}, visible::Bool, title::String, kw_args::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:373; [5] Screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:345 [inlined]; [6] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:1386,Load,LoadError,1386,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985,1,['Load'],['LoadError']
Performance,"According to @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:856,optimiz,optimized,856,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654,1,['optimiz'],['optimized']
Performance,"Adapt.jl isn't relevant here, that's for CPU->GPU conversions. This is a tuple operation not getting inferred properly, leading to a dynamic call to a runtime function. Those aren't supported. With 1.5, there's been a bunch of latency optimizations that have affected inference quality, e.g., when not forcing specialization on functions with `::F where F`. Your best bet here would be to step through using Cthulhu and figure out which code isn't inferring properly. If it's tough code to get though, you could always add the call to `Cthulhu.descend_code_warntype` at the place where the InvalidIRError is thrown.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-673479769:227,latency,latency,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-673479769,2,"['latency', 'optimiz']","['latency', 'optimizations']"
Performance,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:637,Load,Loading,637,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590,1,['Load'],['Loading']
Performance,"After discussing with @ali-ramadhan, it seems more clear that a simple solution is just to use a default halo size of 3. For most models that use the highest order advection scheme we offer this has no effect. For models that use a lower-order advection scheme but don't change the halo size, the memory foot print of the model is ever-so-slightly larger than it needs to be. But this slightly-larger footprint probably isn't noticeable for most problems. So in summary, minimal halo sizes are a minor optimization that has little effect on most problems. Auto-optimizing the halo size has major downsides for usability, so I think the trade-off leans towards big default halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883:502,optimiz,optimization,502,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883,2,['optimiz'],"['optimization', 'optimizing']"
Performance,"After some discussion with @glwagner , I'm going to close this PR and rebase off of CLIMA:main. Stay tuned for a new PR..",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3466#issuecomment-1934850421:101,tune,tuned,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3466#issuecomment-1934850421,1,['tune'],['tuned']
Performance,Again unsure if it affects performance but since `rate` is referenced as global it needs to be `const`; eg `const rate = 1/10`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875683170:27,perform,performance,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875683170,1,['perform'],['performance']
Performance,"Agreed. Useful and related comment. > I was thinking of doing some prototyping and benchmarking in a sandbox by building off the example in my PR [vchuravy/GPUifyLoops.jl#18](https://github.com/vchuravy/GPUifyLoops.jl/pull/18).; > ; > The PR contains an example that can be extended to rely on a `Grid` struct, multiple `FaceField`s and ` CellField`. So I'll prototype grids and fields that are `isbitstype` (you already helped by doing this for a grid in [#59 (comment)](https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-467660181)) and test to see if they work on the GPU with GPUifyLoops.jl. If they do work and performance isn't degraded then I'll rewrite the operators to use grid and field structs.; > ; > You probably know how to do this better than me, but might be good if I rewrite the operators as they's still undocumented and do some _slightly convoluted_ stuff to avoid having to store intermediate calculations.; > ; > Right now I'm focusing on system tests and benchmarks but once @christophernhill @jm-c and I get closer to implementing the variable _Δz_ grid #47 I will work on this.; >; >_Originally posted by @ali-ramadhan in https://github.com/climate-machine/Oceananigans.jl/issues/115#issuecomment-470782067_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-470297910:639,perform,performance,639,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-470297910,1,['perform'],['performance']
Performance,"Ah I think you encountered an example of CUDA scalar operations: https://juliagpu.gitlab.io/CUDA.jl/usage/workflow/#UsageWorkflowScalar. This is when the GPU doesn't know how to do a certain operation quickly using GPU kernels, in this case `any(isnan.(oc.interior(model.velocities.u)))`, so it does it one-by-one on the CPU. We disable CUDA scalar operations in Oceananigans.jl because it can lead to huge performance hits that can be hard to locate. In your case I think it's because `interior(model.velocities.u)` returns a view into `u` without halos (but CUDA.jl doesn't always know how to broadcast over views into CuArrays). I think it should work if you change it to. ```julia; if any(isnan, model.velocities.u.data.parent); throw(""Simulation crashed!""); end; ```. Hopefully we can merge PR #1198 soon so you don't have to worry about this kind of stuff...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1196#issuecomment-733827588:407,perform,performance,407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1196#issuecomment-733827588,1,['perform'],['performance']
Performance,"Ah ok I see why your original script didn't work now. When executing. ```julia; model = IncompressibleModel(grid=grid,; closure = closure,; boundary_conditions = (v=v_bcs); ); ```. this assigned `v_bcs` to the new variable `v` and passes it to the `IncompressibleModel` function. `v_bc` itself is a `NamedTuple` containing `x, y, z` properties so the `IncompressibleModel` constructor does not complain. Since the named tuple that is passed does not not have a `v` property, the velocities get the default boundary conditions (free slip and no normal flow). Then when you call `set!(model, v=-0.5)` it fills v to be -0.5 everywhere but then `update_state!(model)` is called to ensure that the velocity field is incompressible (divergence-free) by performing a pressure projection step. Since the default boundary condition enforces no-normal flow, the velocity cannot be -0.5 everywhere so the pressure field updates it to be zero to enforce incompressibility. This is a pretty subtle bug (related to #1204)... Since the proper named tuple can't be checked for in the constructor function signature, I wonder if it's worth adding a manual check to make sure a `NamedTuple{(:x,:y,:z)}` was not passed to the model constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756979930:747,perform,performing,747,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756979930,1,['perform'],['performing']
Performance,"Ah so I've realised this isn't the fix we needed, and I was just hiding it from myself in the profile because I replaced the function by writing it in the REPL. I made an MWE:. ```jula; using Oceananigans. grid = RectilinearGrid(GPU(), topology = (Flat, Flat, Bounded), size = (100, ), extent = (400, )). model = HydrostaticFreeSurfaceModel(; grid, velocities = PrescribedVelocityFields(), momentum_advection=nothing, buoyancy=nothing, tracers = ntuple(n->Symbol(:T, n), Val(30))); ```; <img width=""1361"" alt=""Screenshot 2024-09-26 at 12 00 29"" src=""https://github.com/user-attachments/assets/2cf2a379-88e9-428f-8156-4ddead2a02e4"">; You can see from this profile that `fill_open_boundary_regions!` takes a lot longer than `fill_halo_event!`, even though there are no velocity open boundaries. This is because it is launching a load of zero size kernels where as `fill_halo_event!` just returns nothing instead. I've fixed this now and get this from the profile instead:; <img width=""1251"" alt=""Screenshot 2024-09-26 at 12 02 11"" src=""https://github.com/user-attachments/assets/0bf91086-bc12-4a17-ba48-89b9b1c2e7ae"">. In numbers, the original version benchmarks `time_step!` at around 4.074 ms ± 581.472 μs and the new version 2.438 ms ± 501.642 μs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3792#issuecomment-2376508207:827,load,load,827,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3792#issuecomment-2376508207,1,['load'],['load']
Performance,"Ah sorry I must have misunderstood your question. Yeah I think broadcasts; tend to perform really well on scalar operations so I don't see why not. On Tue, Mar 5, 2019, 12:13 PM Gregory L. Wagner <notifications@github.com>; wrote:. > I'm not suggesting we should always use broadcasting. I'm just wondering; > if it's ok to use it for simple operations. It's a nice abstraction that; > works on CPUs and GPUs for simple calculations / global array updates (for; > example; > <https://github.com/glwagner/StaggeredPoisson.jl/blob/d104825ba33f184af3b90ca0d958247d0011c7ad/src/solvers.jl#L148>; > ).; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/108#issuecomment-469768233>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/ATKyBSiIR6hlh-r4hjpSmahUJhp3x7Gzks5vTqXEgaJpZM4bfFUj>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/108#issuecomment-469769111:83,perform,perform,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/108#issuecomment-469769111,1,['perform'],['perform']
Performance,"Ah yes as noted here:. > This speed issue disappears either when ζ = ∂x(v) - ∂y(u) is replaced with ζ = Field(∂x(v) - ∂y(u)), or when ζ is the only variable in fields_slice. That's pretty bizarre. That makes me think it's some kind of weird interaction between `NCDatasets` and `Oceananigans`. I can say, with `ζ = Field(∂x(v) - ∂y(u))` the output type is different. It would seem more complex in fact, because it has one more layer of indirection (ie it's the window that refers to a 3D computed field, rather than a windowed computed field). So I don't know why that would compile faster. Honestly I don't think any of us has much experience optimizing compile time. Perhaps first reading this blog post:. https://julialang.org/blog/2020/08/invalidations/. and then the source code for `NetCDFOutputWriter` will lead to revelations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805104189:644,optimiz,optimizing,644,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805104189,1,['optimiz'],['optimizing']
Performance,"Ah! In `HydrostaticFreeSurfaceModel`, the implicit free surface algorithm uses a pressure correction / operator splitting method. It's really a sort of pseudo-implicit treatment (because the velocity field is _corrected_ rather than time-stepped concurrently with the free surface. I think it would be possible to implement an operator splitting method in `ShallowWaterModel`. But is this useful? This could lead to a loss of accuracy (I'm not sure). In the event that the pressure / free surface displacement is passive (so one doesn't care about accuracy), it might be better to use a rigid lid approximation (and thus a two-dimensional `IncompressibleModel`, rather than `ShallowWaterModel`). But I am ready to stand corrected.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1378#issuecomment-781574578:246,concurren,concurrently,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1378#issuecomment-781574578,1,['concurren'],['concurrently']
Performance,"Ah, apparently the error appears when we have an `AveragedTimeInterval`. Change the `simple_output` call to. ```julia; simulation.output_writers[:simple_output] = NetCDFOutputWriter(model, wout,; schedule = AveragedTimeInterval(10seconds),; filepath = ""windowed_avg.nc"", mode = ""c""); ```. and we have the following error:. ```; ERROR: LoadError: Custom output Uw needs dimensions!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:357; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{Coordinat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056:335,Load,LoadError,335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056,1,['Load'],['LoadError']
Performance,"Ah, nice! Maybe using `ConditionalOperation` is a bit slower than `WindowSpatialAverage` because the reduction is performed on the whole domain. Anyways, I don't think reduction is performance-critical so I agree to nuke `WindowSpatialAverage`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022501885:114,perform,performed,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022501885,2,['perform'],"['performance-critical', 'performed']"
Performance,"Ah, thanks for that @maleadt. So microbenchmarks suggest squaring by `Float64` and `Int32` are virtually indistinguishable in simple code. Is there any way that this change is somehow affected by compiler heuristics; eg code inlining is somehow much more effective / optimized when we can invoke `nv_pow`... ? Otherwise I'm at a loss. I think prior to the changes we grouped into our ""upgrade to julia 1.6"" we were using the function `CUDA.pow` (from an ancient `CUDA.jl` version).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869812530:267,optimiz,optimized,267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869812530,1,['optimiz'],['optimized']
Performance,Alright I think `WENO5` is fully working now and good to be merged. Some comments about the contents of this PR:; 1. For now we have a fast and accurate `WENO5` implementation.; 2. We can look at optimizing the `WENO{N}` schemes down the road. They are currently are very experimental since they allocate tons of memory and only define the left-biased interpolants. I'll need to think a bit to get both left- and right-biased interpolants working so I'm proposing merging `weno_nth_order.jl` as-is. It still works and looks good if you run `periodic_advection.jl` with `WENO{N}` with positive velocities.; 3. I added a _temporary_ thermal bubble verification to quickly test whether advection schemes behave responsible near boundaries. We can remove it when we have a better (and more rigorous) test/verification.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-699497422:196,optimiz,optimizing,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-699497422,1,['optimiz'],['optimizing']
Performance,"Alright so I decided to compromise so the NaN checker is always correct. Now it goes back to checking for NaNs in the entire field (halos included). But to reduce the performance impact, the simulation's default NaN checker only checks once every 100 iterations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1198#issuecomment-732960955:167,perform,performance,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1198#issuecomment-732960955,1,['perform'],['performance']
Performance,"Alright, I think this is ready to be merged. Performance looks alright. Model has slowed down a tiny bit (6% for large GPU stuff) but that's expected because we're using halo regions but still computing differences the ""slow"" way with `incmod1` and `decmod1`. The next PR will address this. We also do more calculations for the Poisson equation RHS and in diagnosing _w_ which is why the 6% slowdown is expected.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/250#issuecomment-497048059:45,Perform,Performance,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/250#issuecomment-497048059,1,['Perform'],['Performance']
Performance,"Also important to keep in mind in this discussion: Our workflow will be different from most standard models, which write out instantaneous output that then is post-processed to get statistics etc. We will have to accumulate statistics on the fly, and we can (and should) forgo most instantaneous output, at least for the atmosphere. The model will learn from the accumulated statistics. Otherwise, with instantaneous output, the data volume, especially with embedded LES, will create an I/O and data transfer bottleneck that will limit us, and, e.g., will limit our ability to use distributed computing platforms.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475692509:509,bottleneck,bottleneck,509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475692509,1,['bottleneck'],['bottleneck']
Performance,"Also, I forgot to post an example of the error that happens when you pass an operation as a `condition`. Here's the error that I get in that case:. ```; ERROR: LoadError: MethodError: no method matching arch_array(::CPU, ::KernelFunctionOperation{Center, Center, Face, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64, typeof(boundary_node), Tuple{Center, Center, Face}}). Closest candidates are:; arch_array(::Distributed, ::Any); @ Oceananigans ~/repos/Oceananigans.jl/src/DistributedComputations/distributed_architectures.jl:263; arch_array(::CPU, ::Array); @ Oceananigans ~/repos/Oceananigans.jl/src/Architectures.jl:59; arch_array(::CPU, ::CUDA.CuArray); @ Oceananigans ~/repos/Oceananigans.jl/src/Architectures.jl:60; ... Stacktrace:; [1] condition_operand; @ ~/repos/Oceananigans.jl/src/ImmersedBoundaries/immersed_reductions.jl:24 [inlined]; [2] sum(f::Function, c::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, Periodic, Periodic, B",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1907385408:160,Load,LoadError,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1907385408,1,['Load'],['LoadError']
Performance,"Also, the docs are failing to build with this error:. ```; ERROR: LoadError: IOError: sendfile: no space left on device (ENOSPC); ```. Do we still have a storage problem? I believe these tests run on tartarus, not sverdrup, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867678106:66,Load,LoadError,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867678106,1,['Load'],['LoadError']
Performance,"Also, the implicit vertical solver seems to affect the performance. I would have to guess that it is because we are passing functions as arguments to the kernel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1485410927:55,perform,performance,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1485410927,1,['perform'],['performance']
Performance,"Also, what's the correct syntax to define kernel_parameters over one dimension? For example, the line; ```julia; kernel_parameters = KernelParameters((Nc, 1), (0, Nz_grid-1)); ```; works correctly. However, when I try to define it for one dimension with; ```julia; kernel_parameters = KernelParameters((1,), (Nz_grid-1,)); ```; I encounter the following error:; ```julia; ERROR: LoadError: MethodError: no method matching heuristic_workgroup(::Int64). Closest candidates are:; heuristic_workgroup(::Any, ::Any, ::Any, ::Any); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-aquaplanet/src/Utils/kernel_launching.jl:48; heuristic_workgroup(::Any, ::Any, ::Any); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-aquaplanet/src/Utils/kernel_launching.jl:48; heuristic_workgroup(::Any, ::Any); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-aquaplanet/src/Utils/kernel_launching.jl:48; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3611#issuecomment-2138476721:379,Load,LoadError,379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3611#issuecomment-2138476721,1,['Load'],['LoadError']
Performance,"An easier course of action would be to forget about performance at first and just fill halos every substep.; This will be quite inefficient but will allow us to test open boundary conditions for the hydrostatic model and validate them first. There is an implementation of a split explicit free surface solver that does not require special operators (specifically for a multi region grid) in #3596 ; https://github.com/CliMA/Oceananigans.jl/blob/a6e9a465aa9528b5b3afd49737310e710e4681b0/src/MultiRegion/multi_region_split_explicit_free_surface.jl#L130-L170. We could adapt this implementation for normal grids by implementing a keyword argument in the `SpliExplicitFreeSurface` constructor. Something like the `extended_halos` that is mentioned here; https://github.com/CliMA/Oceananigans.jl/blob/a6e9a465aa9528b5b3afd49737310e710e4681b0/src/MultiRegion/multi_region_split_explicit_free_surface.jl#L19-L28. For serial grids, `extended_halos` is not the correct argument, though, because we do not extend halos (we do that only on distributed and multi region grids), so maybe something like `use_boundary_aware_operators.` . Once the numerics have been settled we can adapt the open boundary condition implementation to the special operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2399186268:52,perform,performance,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2399186268,1,['perform'],['performance']
Performance,"Another important point is that this discussion is not about ""deciding"" on a _single_ user interfaces, but rather deciding what interfaces we want to put into the code. We can and perhaps should have multiple ways of specifying stretched grids. We have already agreed that specifying cell interface locations with an array (loaded from file, for example) is an important pattern to support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814924072:324,load,loaded,324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814924072,1,['load'],['loaded']
Performance,"Another thought for @christophernhill . At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885901320:178,optimiz,optimize,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885901320,1,['optimiz'],['optimize']
Performance,"Apologies - other urgent work and family needs have delayed me. I'm using; Julia 1.9.3; CairoMakie v0.9.4; and have in my status report; GLMakie v0.7.4 and Makie v0.18.4. I tried to use update with the pkg manager to no effect, but see I should be using CairoMakie@0.11, which I am now installing.; This was not successful. For example the file S7LmV_3TYIX.dll would not load giving a permission denied error, but my check of the properties/security did not reveal a deficiency. However, the example worked fine. Many thanks - Kevin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3442#issuecomment-1920152651:371,load,load,371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3442#issuecomment-1920152651,1,['load'],['load']
Performance,"Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?. ```julia; wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); Stacktrace:; [1] check; @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; [2] nc_create(path::String, cmode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; [4] NCDataset; @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784:585,Load,LoadError,585,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784,1,['Load'],['LoadError']
Performance,"Are the current options (`@async` blocks) not sufficient? I'd rather not have a parallel mechanism and have to maintain the APIs (explicitly passing streams/queues) to support it. Even right now it's relatively broken, only supporting kernel launches and memory copies (i.e. BLAS APIs do not take explicit stream arguments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1429353692:157,queue,queues,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1429353692,1,['queue'],['queues']
Performance,"Are we ok with this as a user interface? it's a little implicit. We could alternatively use a function-based API to make things a little more obvious, something like. ```julia; fts[1, 2, 3, 4] # get 4th time-index; ```. ```julia; at_time(4, fts, 1, 2, 3) # linearly interpolate to t=4; ```. mainly i'd be worried about issues like. ```julia; fts[1, 2, 3, 4] \ne fts[1, 2, 3, 4.0]; ```. which is rather easy to confuse?. We also might be able to use syntax like. ```julia; fts[1, 2, 3, time=4]; ```. if that is performant. Or. ```julia; fts[1, 2, 3, Time(4)]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696028139:510,perform,performant,510,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696028139,1,['perform'],['performant']
Performance,"Are you proposing a third interface that takes a 3-argument function of `x, L, N`? I think that's fine as a proposal, I just want to be clear about what is being suggested, exactly. What I didn't understand is how one can specify the cell interface locations (call it the ""`z_faces` interface"" --- the one we currently have) without knowing the number of grid points:. > I agree that to define the grid with z_faces we need to know the number of grid points, but that can be done internally. I agree there are other possible interfaces that _do not_ require passing the number of grid points as a parameter; or rather simplify this process by performing calculations under the hood. It could be nice to design types such as `LinearStretching` or `ChebyshevStretching` that provide users with out-of-the-box stretched grids to be used with interface 2 proposed above (call this the ""coordinate map interface""). We can incorporate dispatch on such types (versus on plain functions) in the grid constructor. An example of this being used is. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = ChebyshevStretching()); ```. or, when a parameter is involves such as for hyperbolic stretching, something like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = HyperbolicStretching(stretching_parameter=1.3)); ```. It seems like maybe there is a 3rd option too? It looks somewhat similar to the coordinate map interface, except that the map expects three arguments rather than one, and returns an array rather than a scalar value that represents the map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100:643,perform,performing,643,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100,1,['perform'],['performing']
Performance,"As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689901112:430,perform,performance,430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689901112,1,['perform'],['performance']
Performance,"As an update, I have pushed a commit consisting of a working version of the double gyre example, where Δz is replaced by zspacings and znodes, the plots are improved with additional attributes, and visualization is performed on the CPU even if the code runs on the GPU. I still need to incorporate some of the suggested modifications listed above. I am uploading the plots and animation here. In today's meeting with Navid and Simone, we looked at switching to the lat-lon grid and more. In the upcoming commits, I will run for longer time on a lat-lon grid, introduce checkpoints for restarting the simulation, and add a topography. . [double_gyre_grid_spacing.pdf](https://github.com/CliMA/Oceananigans.jl/files/11493173/double_gyre_grid_spacing.pdf). [double_gyre_circulation.pdf](https://github.com/CliMA/Oceananigans.jl/files/11493174/double_gyre_circulation.pdf). https://github.com/CliMA/Oceananigans.jl/assets/12926768/cf148a0c-58c8-4ba2-b649-cb40418d0665",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3087#issuecomment-1550535207:215,perform,performed,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3087#issuecomment-1550535207,1,['perform'],['performed']
Performance,"As discussed via zoom with @kburns, passing a key to computations to be stored and used to determine whether a computation needs to be performed is a simple method that may work for us. A simple option for a key is the current model time, which works for all the time stepping methods we employ and has the additional advantage of interpretability. One complication is that we allow users to specify memory space for `ComputedField`s and `AveragedField`s. As a result, two `ComputedField`s that share memory space may have incorrect `data` if the memory is overwritten. This is, in fact, a problem even in the current code and not dependent on the optimizations discussed in this issue. Since we think it is important to give users the option of avoiding unnecessary memory allocation by managing the allocation of scratch space for computations, we cannot prevent incorrect output resulting from overwriting of scratch space during operations with embedded averaged fields and computed fields. We simply have to document this potential ""gotcha"". We can make avoiding repeated operations a bit safer by requiring users to enable it when a `ComputedField` or `AveragedField` is constructed by a keyword argument, something like `recompute_safely`: . ```julia; U = AveragedField(model.velocities.u, dims=(1, 2), data=scratch, recompute_safely=false); ```. When `recompute_safely` is disabled, the model time at computation will be cached. The cache can either be inside `AveragedField`, or in a global cache. (A global cache has the advantage of being on the CPU; a local cache has the advantage of being local).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694601458:135,perform,performed,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694601458,7,"['cache', 'optimiz', 'perform']","['cache', 'cached', 'optimizations', 'performed']"
Performance,"As far as I know the stock FFTW comes in multithreaded version. Passing; nthreads to the planner will result in a planned fft. Could make an “fftkwargs” argument to Model. Then the user can specify; whatever arg they want to the planner via a Dict. On Sat, Mar 9, 2019 at 8:42 AM Gregory Wagner <; gregory.leclaire.wagner@gmail.com> wrote:. > I think “Nthreads” is a keyword argument in plan_fft.; >; > On Sat, Mar 9, 2019 at 8:27 AM Ali Ramadhan <notifications@github.com>; > wrote:; >; >> From Googling around I believe FFTW.jl is build in serial mode? I; >> couldn't see how to make use of multi-threading or specify the number of; >> threads.; >>; >> A related performance optimization would be to consider using Intel's MKL; >> which is usually faster on Intel machines (and might come with; >> multi-threading out of the box).; >>; >> But since we're not running large models on single-core CPUs this seems; >> like a low priority consideration for now.; >>; >> —; >> You are receiving this because you were mentioned.; >> Reply to this email directly, view it on GitHub; >> <https://github.com/climate-machine/Oceananigans.jl/issues/119#issuecomment-471176913>,; >> or mute the thread; >> <https://github.com/notifications/unsubscribe-auth/AOkIBka4H13o1NmaeZ8LRM2DPBpur-kDks5vU7a0gaJpZM4bmrZ0>; >> .; >>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471178290:593,multi-thread,multi-threading,593,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471178290,4,"['multi-thread', 'optimiz', 'perform']","['multi-threading', 'optimization', 'performance']"
Performance,"As suggested by @francispoulin, the following was commented out https://github.com/CliMA/Oceananigans.jl/blob/master/src/Models/ShallowWaterModels/update_shallow_water_state.jl#L19-L22 to remove filling halo regions and buffering between ranks.; This gave perfect efficiency up to 3 ranks. This was mainly done to locate where possible bottlenecks are and not a legitimate change to the code. It was expected that buffering is what's causing efficiency decreases, and this confirms that there are no other additional undetected causes for efficiency drops.; <html>; <body>; <!--StartFragment-->. size | ranks | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 1.0 | 1.0 | 1.0 | 1.0; (4096, 512) | (1, 2) | 0.988079 | 1.01206 | 1.06328 | 1.0406; (4096, 768) | (1, 3) | 0.992832 | 1.00722 | 1.06328 | 1.0406. <!--EndFragment-->; </body>; </html>. system environment and CUDA.versioninfo():; ```; Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); Environment:; JULIA_MPI_PATH = /home/software/spack/openmpi/3.1.4-nhjzelonyovxks5ydtrxehceqxsbf7ik; JULIA_CUDA_USE_BINARYBUILDER = false; JULIA_DEPOT_PATH = /nobackup/users/henryguo/projects/henry-test/.julia; GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.1.243, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0; Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.1; - CUFFT: 10.1.1; - CUSOLVER: 10.2.0; - CUSPARSE: 10.3.0; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing; Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75; Environment:; - JULIA_CUDA_USE_BINARYBUILDER: false; 3 devices:; 0: Tesla V100-SXM2-32GB (",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846:336,bottleneck,bottlenecks,336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846,1,['bottleneck'],['bottlenecks']
Performance,"Average reduction with conditional expressions, e.g., like. https://github.com/CliMA/Oceananigans.jl/blob/748feab10a55fa65a46455620203252a6fc0646e/test/test_field_reductions.jl#L107. induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,. ```Julia; @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); ```. Only mentioning this here in case it might something in the source code that could be affecting code performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221170568:459,perform,performance,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221170568,1,['perform'],['performance']
Performance,"Averaging operations does not allocate any extra memory and is more performant than precalculating a field, storing the data, and then taking the average of that. In general, you only need 3D scratch space if you have 3D output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1439244612:68,perform,performant,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1439244612,1,['perform'],['performant']
Performance,"Awesome stuff! Should make scripting life much more comfortable. We should release v0.9.3 once this is merged. GPU tests don't start due to this error. Will see if I can fix it.; ```julia; ERROR: LoadError: LoadError: UndefVarError: T1 not defined; Stacktrace:; [1] top-level scope at none:0; [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /builds/JuliaGPU/Oceananigans-jl/src/Oceananigans.jl:1; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] top-level scope at none:2; [11] eval at ./boot.jl:328 [inlined]; [12] eval(::Expr) at ./client.jl:404; [13] top-level scope at ./none:3; in expression starting at /builds/JuliaGPU/Oceananigans-jl/src/fields.jl:188; in expression starting at /builds/JuliaGPU/Oceananigans-jl/src/Oceananigans.jl:204; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/343#issuecomment-519320783:196,Load,LoadError,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/343#issuecomment-519320783,4,"['Load', 'load']","['LoadError', 'loading']"
Performance,"Awesome! The two solvers do pretty different things at this point because; CuFFT doesn't do DCTs or r2r transforms but I've also baked in some; performance optimizations to reduce memory access and operation count. We; should be able to hide some of it away with dispatch but some of the; optimizations are baked into the time stepping so not completely... Might be easier to talk in person when we meet later today?. On Tue, Mar 5, 2019, 9:00 AM Gregory L. Wagner <notifications@github.com>; wrote:. > I'm going to work on this. I would also like to improve the solver; > implementation. Why are there different spectral solvers; > <https://github.com/climate-machine/Oceananigans.jl/blob/3cd4ae32cb4d716bc6470a6e7ba484ed98d60de7/src/spectral_solvers.jl#L4>; > for different devices; > <https://github.com/climate-machine/Oceananigans.jl/blob/3cd4ae32cb4d716bc6470a6e7ba484ed98d60de7/src/spectral_solvers.jl#L215>?; > Can we combine them into one type with the Device as a type parameter?; >; > —; > You are receiving this because you authored the thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/102#issuecomment-469689574>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/ATKyBV5TY3u4FjjnraBoJT3fw5L4JqWNks5vTnhggaJpZM4bahv3>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/102#issuecomment-469691219:144,perform,performance,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/102#issuecomment-469691219,3,"['optimiz', 'perform']","['optimizations', 'performance']"
Performance,"Based on some previous benchmarks I think so; https://github.com/climate-machine/Oceananigans.jl/blob/3cd4ae32cb4d716bc6470a6e7ba484ed98d60de7/benchmark/gpu.jl#L164-L198; Basically I wrote an _x_-difference operator that used `@. @views` which allowed it to act on Arrays and CuArrays, and when acting on a CuArray it was only ~10x faster compared to single-core CPU performance. While the entire time-stepping loop we have using GPUifyLoops.jl is ~90x faster. **However** I don't think I did the benchmarking there properly (have to use `@benchmark CuArrays.@sync` I believe) and maybe I didn't use `@. @views` properly. I think using broadcasts would make the code much more readable, but I can think of a few drawbacks (mainly related to performance):. 1. I don't know how to fuse kernels when doing broadcasts. E.g. we might be able to do something like; ```julia; @. Gu = calc_RHS_u(u, v, w, ...); @. Gv = calc_RHS_v(u, v, w, ...); ...; ```; which would look cleaner but then `update_source_terms!` would end essentially end up in several kernels. From talking with you I believe this shouldn't matter as kernel launches are cheap and the broadcast operator should essentially do exactly what `update_source_terms!` does, but I'm not 100% sure of this and we may lose out on performance. 2. We may want to fine tune our kernel launches, e.g. by using the thread-block layout we want which is probably possible, I'm just not very familiar with the CuArrays.jl package. 3. Some kernels, e.g. ones that do permutations like `calculate_source_term_divergence_gpu!` and `idct_permute!` can't be broadcasted over I think, but these are the exception rather than the rule. To really find out whether we take a performance hit we might have to refactor the time-stepping to use broadcasting then benchmark the two approaches on CPU, GPU, and multi-GPU architectures (not sure if CuArrays.jl will do multi-GPU arrays yet). This will become much easier once #67 is resolved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/108#issuecomment-469765393:367,perform,performance,367,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/108#issuecomment-469765393,5,"['perform', 'tune']","['performance', 'tune']"
Performance,"Based on the answers here I tried to set my own mask function. It appears to run fine on the CPU but when I try to run it on the GPU I get this error when running the simulation (with a few subsequent errors after these lines, but this is the first one):. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(2048, 1, 256)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(2048, 1, 256)},KernelAbstractions.NDIteration.StaticSize{(1, 256, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,1}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, UpwindBiasedThirdOrder, FPlane{Float64}, Nothing, AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:b,),Tuple{Float64}},NamedTuple{(:b,),Tuple{Float64}},NamedTuple{(:b,),Tuple{Float64}}}, NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:b,),Tuple{Oceananigans.Fields.ZeroField}}}}, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,1}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,1}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,1}}}}, NamedTuple{(:b,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,1}}}}, Nothing, NamedTuple{(:u, :v, :w, :b),Tuple{typeof(Oceananigans.Forcings.zeroforcing),typeof(Oceananigans.Forcings.zeroforcing),Oceananigans.Forcings.ContinuousForcing{Cell,Cell,Face,Noth",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733435704:268,Load,LoadError,268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733435704,1,['Load'],['LoadError']
Performance,"Below is a link to a paper that compares the scalability of multi-threading in Python, Julia and Chapel. . Brief Summary: They find that none of them do as well as OpenMP but give some reasons as to why. But they do find some improvements going up to 64 threads, but the effiicency in some cases go down to 20%. It seems that Python might do better on low numbers of threads but Julia does better on more. This was last year so I am sure this should probably redone. Also, I should mention I don't believe their problem is like ours but it's an example and has some pictures, so that's nice to see. https://hal.inria.fr/hal-02879767/document",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886076610:45,scalab,scalability,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886076610,2,"['multi-thread', 'scalab']","['multi-threading', 'scalability']"
Performance,"Benchmark results:. ```; Julia Version 1.3.1; Commit 2d5741174c (2019-12-30 21:36 UTC); Platform Info:; OS: macOS (x86_64-apple-darwin18.6.0); uname: Darwin 19.3.0 Darwin Kernel Version 19.3.0: Thu Jan 9 20:58:23 PST 2020; root:xnu-6153.81.5~1/RELEASE_X86_64 x86_64 i386; CPU: Intel(R) Core(TM) i7-7920HQ CPU @ 3.10GHz: ; speed user nice sys idle irq; #1 3100 MHz 7280472 s 0 s 3664940 s 37447135 s 0 s; #2 3100 MHz 962205 s 0 s 463846 s 46966309 s 0 s; #3 3100 MHz 6058127 s 0 s 2588161 s 39746073 s 0 s; #4 3100 MHz 940664 s 0 s 349843 s 47101853 s 0 s; #5 3100 MHz 5327039 s 0 s 1908912 s 41156410 s 0 s; #6 3100 MHz 958596 s 0 s 311019 s 47122744 s 0 s; #7 3100 MHz 4606842 s 0 s 1506190 s 42279330 s 0 s; #8 3100 MHz 985952 s 0 s 278546 s 47127861 s 0 s; ; Memory: 16.0 GB (398.0859375 MB free); Uptime: 4.914851e6 sec; Load Avg: 2.8193359375 2.333984375 1.83544921875; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-6.0.1 (ORCJIT, skylake); Environment:; JULIA_EDITOR = vim; TERM = xterm-256color; PALMHOME = /Users/gregorywagner/Software/palm; PATH = /Users/gregorywagner/opt/anaconda3/condabin:/opt/anaconda3/bin:/Users/gregorywagner/Software/palm/palm/current_version/trunk/SCRIPTS:/Applications/Julia-1.3.app/Contents/Resources/julia/bin:/usr/local/opt/ruby/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/TeX/texbin:/opt/X11/bin; XPC_FLAGS = 0x0; HOME = /Users/gregorywagner. ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 104s / 55.2% 7.44GiB / 0.08% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 44.9ms 0.08% 4.49ms 752KiB 12.5% 75.2KiB; 32× 32× 32 [CPU, Float64] 10 39.1ms 0.07% 3.91ms 752KiB 12.5% 75.2KiB; 64× 64× 64 [CPU, Float32] 10 428ms 0.75% 42.8ms 752KiB 12.5% 75.2KiB; 64× 64× 64 [CPU, Float64] 10 3",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/710#issuecomment-629688917:825,Load,Load,825,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/710#issuecomment-629688917,1,['Load'],['Load']
Performance,"Benchmark? The reason we combined the updates for velocities was a perceived performance gain. Probably we were wrong about that, but it'd be good to show it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-734369612:77,perform,performance,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-734369612,1,['perform'],['performance']
Performance,"Billy mentioned it in some other comments but while we do splat args for some of the function calls, the function definitions use Varargs instead. This should avoid the catastrophic slowdown we saw with splatting earlier, but I agree that it should be tested. Do you have any good CPU performance tests set up @glwagner ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150096206:285,perform,performance,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150096206,1,['perform'],['performance']
Performance,"But I'm not sure which part are you referring as ""good idea or not"". The fact that they belong to a different module? Perhaps we could have these constants loaded/exported with Oceananigans main module. Is this what you are thinking? That would work also!. What I think is _not_ good is having, e.g., every module redefining constants. E.g., `R_Earth` is currently defined in two places. Say we change one definition thinking it will affect everything but it won't. Also I found it quite cumbersome in scripts when I wanted to load these constants I had to load one from `Grids` and one from `Coriolis` and one from `BuoyancyModels`.... That's a bit counterintuitive from a user's perspective.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492618180:156,load,loaded,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492618180,3,['load'],"['load', 'loaded']"
Performance,"But definitely clean up and performance. Just to clarify fixing type inference doesn't change the result of the reduction, it just makes it go much faster",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2380363489:28,perform,performance,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2380363489,1,['perform'],['performance']
Performance,"By the way, WENO (and other advection schemes) are always going to be at most second order as they are implemented right now. So the _order_ might not be the correct metric to look at the performance, the truncation error is probably what we want to look at",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164473690:188,perform,performance,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164473690,1,['perform'],['performance']
Performance,"CUDA uses a special buffer, the parameter space, to put arguments in. This buffer is about 4K large, and has special semantics that benefit performance (read-only, so threads can read from it without synchronizing, etc). Although arguments in Julia are normally passed by reference, i.e. putting pointers in that space, when invoking kernels we change the calling convention and pass by reference such that loading e.g. the size or pointer of an array doesn't synchronize threads. That works great, until you pass a large (number of) arguments as you apparently do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/746#issuecomment-653428852:140,perform,performance,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/746#issuecomment-653428852,2,"['load', 'perform']","['loading', 'performance']"
Performance,"Can we use a wrapper that automagically loads data from file for the specified time index (and also perform spatial slicing), using the nice GeoData getindex syntax?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-738272413:40,load,loads,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-738272413,2,"['load', 'perform']","['loads', 'perform']"
Performance,"Can you tell us a bit more about your system?. What is `versioninfo(verbose=true)` and `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098:518,Load,LoadError,518,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098,4,"['Load', 'load']","['LoadError', 'loading']"
Performance,"Changing the function call to ; ```julia; function define_output_variable!(dataset,; wsa::Union{WindowedSpatialAverage, WindowedTimeAverage{<:WindowedSpatialAverage}},; name, array_type, compression, attributes, dimensions); ```; raises some other errors and I'm not sure the best way to fix them. I think the issue is that a `WindowedTimeAverage` doesn't have the properties `field` (it has `operand`) and it doesn't have the property `dims`. . For example, running the code above I get:. ```; ERROR: LoadError: type WindowedTimeAverage has no field field; Stacktrace:; [1] getproperty(::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::Symbol) at ./Base.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryCo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:502,Load,LoadError,502,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449,1,['Load'],['LoadError']
Performance,Closing as I think we agreed that in this case it's better to load initial conditions from disk than add a portable random number generate as a utility.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/176#issuecomment-506994970:62,load,load,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/176#issuecomment-506994970,1,['load'],['load']
Performance,"Compilation performance is affected by this, so I think it's more correct to say that performance is affected.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3851#issuecomment-2429332352:12,perform,performance,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3851#issuecomment-2429332352,2,['perform'],['performance']
Performance,"ContextName, Any...) in module Cassette at /home/travis/.julia/packages/Cassette/1rVkq/src/overdub.jl:500 overwritten in module GPUifyLoops at /home/travis/.julia/packages/Cassette/1rVkq/src/overdub.jl:500.; WARNING: Method definition recurse(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/travis/.julia/packages/Cassette/1rVkq/src/overdub.jl:512 overwritten in module GPUifyLoops at /home/travis/.julia/packages/Cassette/1rVkq/src/overdub.jl:512.; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] top-level scope at none:2; [11] eval at ./boot.jl:328 [inlined]; [12] eval(::Expr) at ./client.jl:404; [13] top-level scope at ./none:3; in expression starting at /home/travis/.julia/packages/CuArrays/qZCAt/src/deprecated.jl:5; in expression starting at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:54; ERROR: LoadError: LoadError: LoadError: LoadError: UndefVarError: @setup not defined; Stacktrace:; [1] top-level scope; [2] #macroexpand#35 at ./expr.jl:107 [inlined]; [3] macroexpand at ./expr.jl:106 [inlined]; [4] docm(::LineNumberNode, ::Module, ::Any, ::Any, ::Bool) at ./docs/Docs.jl:509 (repeats 2 times); [5] @doc(::LineNumberNode, ::Module, :",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/153#issuecomment-477579168:2816,load,loading,2816,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/153#issuecomment-477579168,1,['load'],['loading']
Performance,"Copied below. ```; ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33;   | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);   | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255;   | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);   | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170;   | [4] #2;   | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined];   | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);   | @ Base.Filesystem ./file.jl:106;   | [6] #makedocs#1;   | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined];   | [7] top-level scope;   | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;   | 🚨 Error: The command exited with status 1;   | user command error: exit status 1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299:26,Load,LoadError,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299,1,['Load'],['LoadError']
Performance,"Could be interesting to explore! @suyashbire1 has looked at this I think. The big concerns are obviously performance, GPU compatibility, and we probably don't want to depend on an immature or abandoned package. We depend heavily on OffsetArrays.jl but it doesn't really come with any features we use besides the array type itself.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/457#issuecomment-541417904:105,perform,performance,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/457#issuecomment-541417904,1,['perform'],['performance']
Performance,"Could you explain why using `ifelse` has better performance?; Is this because the ternary `? :` is an alias for `ifelse`? ; What about `@inline`?. In this case, we only had the wind velocity from the specifications of the computer fans we used for the rotating tank experiment, but I understand that even in this case, I could calculate `τ₀` using bulk formula while defining `p`. Thanks for the idea. For the boundary conditions. I was my bad. You specify on the [Documentation](https://clima.github.io/OceananigansDocumentation/stable/model_setup/boundary_conditions/#.-Spatially-and-temporally-varying-flux) that. > By default, a function boundary condition is called with the signature; > ; > `f(ξ, η, t)`; > ; > where t is time and ξ, η are spatial coordinates that vary along the boundary:; > ; > `f(y, z, t)` on x-boundaries;; > `f(x, z, t)` on y-boundaries;; > `f(x, y, t)` on z-boundaries. I am just repeating here in case someone falls in the same problem and comes to this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066113425:48,perform,performance,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066113425,1,['perform'],['performance']
Performance,"Currently in my workflow, I define an environment variable that contains an string like `$init_$end.nc`, where `init` is the initial time and `end` is the `stop_time` of the simulation. In the first instantiation of the model for 60 days, this string will be appended to my output filename e.g.`vel_field_`, resulting on something like `vel_field_0_60.nc`. For the next pickup the filename will be changed to `vel_field_60_120.nc`. This works well when the files are not split, i.e. `file_splitting = NoFileSplitting()`. However when splitting the file, e.g. `file_splitting = TimeInterval(30days)`, the first instantiation will result in the following files:; ```; vel_fields_0_60_part1.nc vel_fields_0_60_part2.nc vel_fields_0_60_part3.nc; ```; then the next pickup will result in files: ; ```; vel_fields_60_120_part1.nc vel_fields_60_120_part3.nc vel_fields_60_120_part5.nc; vel_fields_60_120_part2.nc vel_fields_60_120_part4.nc; ```; of this files, the first 2 parts (`vel_fields_60_120_part1.nc` and `vel_fields_60_120_part2.nc`) are empty, and the `vel_fields_60_120_part3.nc` contains data from the day 61 until 91. This makes the loading of the data for post-processing a bit tricky, since some of they are empty and the disk storage will make more difficult chunking data. . If I don't change the name each time I pickup, with the `overwrite_existing=false` it crashes, and with `overwrite_existing=true` it rewrites all the files. . Another workflow will be to create a new folder for each pickup keeping the same filename, but splitting the files will result in the same issue of file duplication. . I hope this description of the workflow is clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391946301:1139,load,loading,1139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391946301,1,['load'],['loading']
Performance,"Damn, it looks like the tests on the GPU are not working because CUDA is not loaded properly. ; I am trying to address this in #3880. A segmentation fault probably means the MPI is not CUDA-aware. Typically, the MPI that is shipped with MPI_jll is not cuda-aware. A good way to check is; ```julia; julia> using MPI. julia> MPI.has_cuda(); true; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878#issuecomment-2443869989:77,load,loaded,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878#issuecomment-2443869989,1,['load'],['loaded']
Performance,Data is loaded into `FieldTimeSeries` by. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/OutputReaders/field_time_series.jl#L146. which calls. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/OutputReaders/field_time_series.jl#L200-L205. The data seems to be loaded into the intermediate `Field`:. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/OutputReaders/field_time_series.jl#L237. so the problem may be. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/OutputReaders/field_time_series.jl#L205. Voila... https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/Fields/set!.jl#L43-L55,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689910675:8,load,loaded,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689910675,2,['load'],['loaded']
Performance,"Dedalus currently has a binary configuration option to cache the evaluation of every intermediate operation within a single timestep / sub-stage. The recursive evaluation of an operator tree accepts and propagates a cache-key argument, which could be related to e.g. the simulation iteration and sub-stage. If caching is enabled, each operator checks it's own size-1 cache for the cache-key, and returns the result if present. Otherwise it evaluates itself, and stores the result under the cache-key. . This eliminates the repeated evaluation of individual operators, but at the cost of storing the result of every intermediate operation. We're currently working on an upgrade that first traverses the tree, counts the number of references to a given operator, and deallocates the cached result after the cache has been accessed the corresponding number of times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694332991:55,cache,cache,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694332991,7,['cache'],"['cache', 'cache-key', 'cached']"
Performance,"Did a quick small strong scaling benchmark on Tartarus (256^3) up to 16 cores but results don't look super great? ~9.5x speedup on 16 cores. Better than multi-threading though. Maybe I'm not benchmarking properly though. Could also be missing some MPI barriers. Should probably learn how to profile MPI code. ```; Incompressible model strong scaling benchmark; ┌─────────────────┬───────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ size │ ranks │ min │ median │ mean │ max │ memory │ allocs │; ├─────────────────┼───────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ (256, 256, 256) │ 1 │ 3.641 s │ 3.686 s │ 3.686 s │ 3.730 s │ 355.28 KiB │ 2336 │; │ (256, 256, 256) │ 2 │ 1.917 s │ 1.918 s │ 1.921 s │ 1.928 s │ 346.00 KiB │ 2782 │; │ (256, 256, 256) │ 4 │ 1.249 s │ 1.283 s │ 1.279 s │ 1.300 s │ 348.47 KiB │ 2822 │; │ (256, 256, 256) │ 8 │ 652.029 ms │ 714.833 ms │ 704.940 ms │ 738.885 ms │ 353.84 KiB │ 2902 │; │ (256, 256, 256) │ 16 │ 377.153 ms │ 388.435 ms │ 394.780 ms │ 415.562 ms │ 366.16 KiB │ 3062 │; └─────────────────┴───────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Incompressible model strong scaling speedup; ┌─────────────────┬───────┬─────────┬──────────┬─────────┐; │ size │ ranks │ speedup │ memory │ allocs │; ├─────────────────┼───────┼─────────┼──────────┼─────────┤; │ (256, 256, 256) │ 1 │ 1.0 │ 1.0 │ 1.0 │; │ (256, 256, 256) │ 2 │ 1.92195 │ 0.973876 │ 1.19092 │; │ (256, 256, 256) │ 4 │ 2.87312 │ 0.980825 │ 1.20805 │; │ (256, 256, 256) │ 8 │ 5.15614 │ 0.995954 │ 1.24229 │; │ (256, 256, 256) │ 16 │ 9.48879 │ 1.03061 │ 1.31079 │; └─────────────────┴───────┴─────────┴──────────┴─────────┘; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-794954624:153,multi-thread,multi-threading,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-794954624,1,['multi-thread'],['multi-threading']
Performance,"Didn't know about lazy package loading, thanks for pointing it out!. The model runs on GPUs (albeit pretty slowly right right now) so I'm in the process of cleaning up the code before thinking about optimizing for performance, this should come in handy.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/14#issuecomment-459425779:31,load,loading,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/14#issuecomment-459425779,3,"['load', 'optimiz', 'perform']","['loading', 'optimizing', 'performance']"
Performance,"Doctests fail because of all the `loop not unrolled` warnings we get.; We should remedy this before we move to Julia v1.10. @glwagner you bumped onto this previously, right?. ```Julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 143 already precompiled.; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1)); 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> model = NonhydrostaticModel(; grid); warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requeste",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:845,optimiz,optimizer,845,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814,2,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,"Documents/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/compute_hydrostatic_free_surface_tendencies.jl:236; [7] gpu_compute_hydrostatic_free_surface_Gu!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:90; [8] gpu_compute_hydrostatic_free_surface_Gu!; @ ./none:0; Hint: catch this exception as `err` and call `code_typed(err; interactive = true)` to introspect the erronous code with Cthulhu.jl; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/validation.jl:147; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:440 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/RsWnF/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:439 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:89; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:83 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:129; [8] codegen; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:110 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:106; [10] compile; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:98 [inlined]; [11] #45; @ ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:57 [inlined]; [12] JuliaContext(f::Metal.var""#45#46""{GPUCompiler.CompilerJob{",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:36336,optimiz,optimize,36336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822,1,['optimiz'],['optimize']
Performance,Does this reduce performance or is the effect negligible? (Just curious.),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261409044:17,perform,performance,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261409044,1,['perform'],['performance']
Performance,"Exactly what I am struggling with right now: figuring out how to quickly get x, y, z coordinates when loading an output file created previously (with JLD2 output writer}). So as far as I understand in that case the 'model' and 'grid' variables do not exist. ; `xc = file([""grid/xC""]) `; etc. works, but contains the halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-1022295367:102,load,loading,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-1022295367,1,['load'],['loading']
Performance,"Executing the validation/multi_region/cubed_sphere_steady_state.jl file yields an error partially shown below:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 41.133 ms, wall time: 0 seconds; [ Info: ... simulation initialization complete (820.774 ms); [ Info: Executing initial time step...; ERROR: LoadError: MethodError: no method matching _fill_south_halo!(::Int64, ::Int64, ::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, NamedTuple{(:ξ, :η, :rotation), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}, Rotations.RotXY{Float64}}}, CPU}, ::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::BoundaryCondition{Oceananigans.BoundaryConditions.MultiRegionCommunication, Oceananigans.MultiRegion.CubedSphereRegionalConnectivity{Oceananigans.MultiRegion.South, Oceananigans.MultiRegion.North, Nothing}}, ::Tuple{Center, Center, Face}). Closest candidates are:; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Open}, ::Any, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_open.jl:36; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Flux}, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_flux.jl:32; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::Union{BoundaryCondition{<:Oceananigans.BoundaryConditions.Value}, BoundaryCondition{<:Oceananigans.BoundaryCondition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619:409,Load,LoadError,409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619,1,['Load'],['LoadError']
Performance,"Float32, 3, 1}}}}, Nothing, NamedTuple{(:u, :v, :w, :T, :S), NTuple{5, typeof(Oceananigans.Forcings.zeroforcing)}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float32, Int64, Int64}}}}}, args::LLVM.Module); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/validation.jl:111; [2] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/driver.jl:319 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/driver.jl:317 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/utils.jl:62; [6] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/mVgLI/src/compiler/execution.jl:313; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/cache.jl:89; [8] cufunction(f::typeof(Cassette.overdub), tt::Type{Tuple{Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CUDA.CuDeviceArray{Float32, 3, 1}}, RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360:17236,cache,cache,17236,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360,1,['cache'],['cache']
Performance,"For better or for worse, Oceananigans currently does not store intermediate terms in the computation of a PDE's right hand side (with notable exceptions hydrostatic pressure and eddy diffusivities). In other words, a single, sometimes large kernel that evaluates the right hand side at each grid point `i, j, k` is compiled for each PDE in a user's model, and there's no way to pull out intermediate steps in that calculation to use elsewhere. It's important to note when considering optimization strategies that our computations are probably memory-limited, rather than compute-limited. In other words, we think the process of transferring data from global memory to local thread memory is a bottleneck for our computations (we can really only know this through profiling a particular application, however, since all models are different...) Storing intermediate components of the tendency terms would probably create more memory accesses overall (since rather than immediately using intermediate results for subsequent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:484,optimiz,optimization,484,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837,2,"['bottleneck', 'optimiz']","['bottleneck', 'optimization']"
Performance,"For cases in which we need to utilize the original set-up script, would a function that looks something like . ```julia; set_to_checkpoint!(model, ""checkpoint_filename"", iteration); ```. do the trick? If the set-up script is provided, running from a checkpoint should be easy because we only need to load the solution and tendencies onto the CPU and then copy to the already-initialized GPU field, and set `model.clock.iteration` and `model.clock.time`. The more difficult code-design case is initializing a model when the original set-up script is not available. The above line can be placed just prior to time-stepping, and commented out when users want to run from the initial condition. So only one line needs to be changed provided that time-stepping is enclosed within a `while model.clock.time < end_time` or `while model.clock.iteration < end_iteration` block. . I agree with @ali-ramadhan that a `Simulation` type would make the scripting flow a bit more readable and robust.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/602#issuecomment-580286724:300,load,load,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/602#issuecomment-580286724,1,['load'],['load']
Performance,From Googling around I believe FFTW.jl is build in serial mode? I couldn't see how to make use of multi-threading or specify the number of threads. A related performance optimization would be to consider using Intel's MKL which is usually faster on Intel machines (and might come with multi-threading out of the box). But since we're not running large models on single-core CPUs this seems like a low priority consideration for now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471176913:98,multi-thread,multi-threading,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471176913,4,"['multi-thread', 'optimiz', 'perform']","['multi-threading', 'optimization', 'performance']"
Performance,"From a correctness and functionality stand point this PR should be ready to merge. I have some problems with performance though. It looks like with `--check-bounds=no` this PR has roughly the same wall time than main (slightly more if you have weno because of additional boundary weno schemes) but without it's 2 - 2.5X slower. (Exacerbated on the GPU). I guess it might be a matter of `@inbounds` having to be placed strategically, but I seem to miss it; @glwagner, @navidcy do you have any easy suggestion that I might have missed?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177948330:109,perform,performance,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177948330,1,['perform'],['performance']
Performance,"From the standpoint of `NonhydrostaticModel`, the only requirement (I think?) is a pressure solver that's valid on more grids. The `FourierTridiagonalPoissonSolver` combines FFTs with a tridiagonal solve in one direction to solve the Poisson equation. Thus, this method can be used if the grid is stretched in just one (1) direction. Right now, we only support grids that are stretched in `z`, the third direction / index. Presumably it's at most a matter of copy and paste and index permutation to support grids that are stretched in `x` (and regular in `y, z`) or stretched in `y` (and regular in `x, z`). Under the hood, the `FourierTridiagonalPoissonSolver` relies on the `BatchedTridiagonalSolver` to perform the tridiagonal solve:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/fourier_tridiagonal_poisson_solver.jl#L81-L82. The `BatchedTridiagonalSolver` launches a kernel over `xy` and performs a tridiagonal solve in `z`:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L79-L80. So the first task is to extend the tridiagonal solver to support integrals in `x` and `y`. . This could be straightforwardly supported by adding some kind of tag to indicate the ""tridiagonal direction"" (ie `:x`, `:y`, or `:z`), and copy-pasting the functionality for each case. It's a bit of code duplication but pretty straightforward... Alternatively we could introduce some kind of abstraction that permutes array dimensions. Then we just have one algorithm which assumes the tridiagonal index is `k`, and support `i` or `j` under the hood via an array wrapper that performs an index permutation. I'm leaning towards copy/paste because it's a little easier to understand and it's not that much code in this case...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1557689620:706,perform,perform,706,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1557689620,3,['perform'],"['perform', 'performs']"
Performance,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:385,optimiz,optimize,385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575,1,['optimiz'],['optimize']
Performance,"Given that there seems to be increasing interest in vertically-periodic simulations, we could revive #3080 (despite the caveats mentioned there, which mainly unknowns associated with the performance of potential future nonhydrostatic solvers for complex domains), since it's always possible to reverse course in the future and restore the separation (perhaps when the separation is restored, it can be done in a way that's compatible with vertically periodic domains).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782219409:187,perform,performance,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782219409,1,['perform'],['performance']
Performance,Going down to 128³ it still produced NaNs after ~10 iterations. Going down to 32³ it always seems to make it to 100 iterations. So race condition seems to make sense as they occur when the GPU is saturated I think. @glwagner Ah good point. I'll try again with just the `FluxBoundaryCondition` and then with just the `GradientBoundaryCondition`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/816#issuecomment-662727050:131,race condition,race condition,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/816#issuecomment-662727050,1,['race condition'],['race condition']
Performance,"Good idea, let's change the phrase but keep this issue open so that I remember to tackle the performance benchmarks",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3758#issuecomment-2327680150:93,perform,performance,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3758#issuecomment-2327680150,1,['perform'],['performance']
Performance,Good news is that using a `StructArray{Particle}` doesn't impact performance :rocket:,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-733713396:65,perform,performance,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-733713396,1,['perform'],['performance']
Performance,"Good news: shallow water tests pass!. Bad news: the halo tests now has 12 fails, of 600 in total. . ```; <div class=""JobLogOutputComponent"" style=""box-sizing: border-box; background: rgb(23, 23, 23); border-radius: 3px; min-height: 85px; color: white; font-size: 12px; padding: 0px 0px 15px; width: 1108px; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Helvetica, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;""><div class=""JobLogOutputComponent__Body"" style=""box-sizing: border-box; font-family: SFMono-Regular, Monaco, Menlo, Consolas, &quot;Liberation Mono&quot;, Courier, monospace;"">; Oceananigans \| 818 12 830; --; &nbsp; | Distributed MPI Oceananigans \| 816 12 828; &nbsp; | Multi architectures rank connectivity \| 28 28; &nbsp; | Local grids for distributed models \| 24 24; &nbsp; | Injection of halo communication BCs \| 168 168; &nbsp; | Halo communication \| 588 12 600; &nbsp; | Time stepping IncompressibleModel \| 4 4; &nbsp; | Time stepping ShallowWaterModel \| 4 4; &nbsp; | Distributed FFT-based Poisson solver \| 2 2; &nbsp; | ERROR: ERROR: ERROR: ERROR: LoadError: LoadError: LoadError: LoadError: Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:1477,Load,LoadError,1477,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,4,['Load'],['LoadError']
Performance,"Good question @simone-silvestri !. On main it doesn't run as is. There are two issues. . First, there is `device!(2)` in line 30 but I commented that out easily. . Second, on line 159 we load `VorticityStencil`, which is not defined. I deleted that and changed the momentum_advection to `VectorInvariant()`, but it occurs to me that this is not what was done before. Before it was using a vorticity stencil. How would I change to use the other formulation?. However, when I try running this on main it goes far beyond what I see in the PR. So I guess the version on main does run and is stable. Pasat a day easy. Hmm... If we have a problem with the height going negative, I wonder if this is a sign that the conservation of mass equation is not quite right? I will look at that today.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1983382184:187,load,load,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1983382184,1,['load'],['load']
Performance,"Greg, Ali, and what if we began to consider more complex geometries etc -; hard to resist going in that direction..... we'd have to change the solvers; - more MITgcm-like, congrad etc - but what would the implications be for; boundary conditions? More food for thought. John. On Sat, Mar 28, 2020 at 10:22 AM Gregory L. Wagner <notifications@github.com>; wrote:. > Mostly I am worried about scalability and sustainability in this design,; > or future designs.; >; > Currently our models are fairly simple, but its challenging to place; > bounds on potential future complexity. For example, models in the future; > may require additional fields associated with closures or; > parameterizations, such as (two-dimensional) boundary layer depth fields,; > plume quantities, mixing lengths and perhaps other auxiliary fields; > associated with various prognostic / diagnostic LES models. We probably; > can't plan to support setting boundary conditions on every possible field; > via the model constructor.; >; > With our current design we have essentially special-cased turbulent; > diffusivities because our focus is LES, turbulent diffusivities are; > relatively common, and it convenient for us. However doing this incurs some; > maintenance burden --- which will increase if we plan to hard-code; > validation and error checking.; >; > Food for thought.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/721#issuecomment-605453798>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQT642WME2EIX3DDSITRJYBYXANCNFSM4LVSZPAA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060:391,scalab,scalability,391,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060,1,['scalab'],['scalability']
Performance,Haha so the link is dead again since we don't have a `benchmarks.jl` file. It should link to the documentation page on performance benchmarks. I will open a PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/608#issuecomment-663171078:119,perform,performance,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/608#issuecomment-663171078,1,['perform'],['performance']
Performance,"Happy to open an issue (or post to #1634) when I have the time to work on CI. What should we do with this PR? I think it's a net positive change so I'm happy to approve as long as the images aren't in git history. If we decide to nuke this part of the docs then I suppose this PR is moot and should be closed. > _when_ / _if_ somebody can take responsibility for maintaining it. I think responsibility for maintaining the pipeline should fall on all maintainers/developers, otherwise it's not sustainable. Ideally if you open a PR that breaks a validation experiment you should fix it. If done concurrently it should only consist of small changes so it should only be a small burden (although burdens to add up). I guess we don't run the validation CI on every PR since it's too expensive so maintenance is tough right now. Maybe we can run validation CI before every tagged release or something? Better infrastructure is needed I suppose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872481889:594,concurren,concurrently,594,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872481889,1,['concurren'],['concurrently']
Performance,"Hello, @amontoison. Nice work. Do you see a performance improvement when switching to this package?; There should be some benchmarks in the `benchmark` folder that we can test (probably we need to update that folder a bit, let me know if you have problems with it)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3778#issuecomment-2353126955:44,perform,performance,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3778#issuecomment-2353126955,1,['perform'],['performance']
Performance,"Here are the results of `benchmark_tracers.jl` between the `arbitrary-tracers-outer-loops` branch (this PR) and the `arbitrary-tracers-inner-loops` branch. Outer loops is faster in all cases. PS: `arbitrary-tracers-inner-loops` errored for 0 active + 0 passive tracers so this particular benchmark isn't included below, but maybe it doesn't matter as outer loops seem to perform much better. ---. ### `arbitrary-tracers-outer-loops`; ```; ───────────────────────────────────────────────────────────────────────────────────────────────────────────; Tracer benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 119s / 2.11% 19.7GiB / 0.48% . Section ncalls time %tot avg alloc %tot avg; ───────────────────────────────────────────────────────────────────────────────────────────────────────────; 256×256×256 0 active + 0 passive (GPU, Float64) 10 206ms 8.24% 20.6ms 6.11MiB 6.37% 625KiB; 256×256×256 0 active + 1 passive (GPU, Float64) 10 234ms 9.36% 23.4ms 7.62MiB 7.94% 780KiB; 256×256×256 0 active + 2 passive (GPU, Float64) 10 258ms 10.3% 25.8ms 9.17MiB 9.56% 939KiB; 256×256×256 1 active + 0 passive (GPU, Float64) 10 232ms 9.28% 23.2ms 7.68MiB 8.01% 787KiB; 256×256×256 2 active + 0 passive (GPU, Float64) 10 266ms 10.6% 26.6ms 9.14MiB 9.53% 936KiB; 256×256×256 2 active + 3 passive (GPU, Float64) 10 348ms 13.9% 34.8ms 13.8MiB 14.4% 1.38MiB; 256×256×256 2 active + 5 passive (GPU, Float64) 10 409ms 16.3% 40.9ms 17.0MiB 17.7% 1.70MiB; 256×256×256 2 active + 10 passive (GPU, Float64) 10 551ms 22.0% 55.1ms 25.4MiB 26.5% 2.54MiB; ───────────────────────────────────────────────────────────────────────────────────────────────────────────; ```. ### `arbitrary-tracers-inner-loops`; ```; ───────────────────────────────────────────────────────────────────────────────────────────────────────────; Tracer benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 120s / 2.20% 19.1GiB / 0.33% . Section ncalls time %tot a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452#issuecomment-542302613:371,perform,perform,371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452#issuecomment-542302613,1,['perform'],['perform']
Performance,"Here's a few options for optimizing AbstractOperations with `^`:. 1. Auto-convert exponents to `Int32`. For this we'd define. ```julia; Base.^(L::Tuple, a::AbstractField, b::Int64) = ^(L::Tuple, a, Int32(b)); ```. Basically implementing the approach CUDA previously took. For us it's a ""less egregious"" hack since, unlike CUDA.jl, we can ""almost surely"" guarantee that users won't exponentiate with integers larger than `2^31-1 = 2147483647`. Probably the easiest thing to do in the near term. This is a specific extension of the abstract operation defined via `@binary ^` (such that `op = ^`):. https://github.com/CliMA/Oceananigans.jl/blob/1756bc9380999f160f3d2b96f64bf76771614c60/src/AbstractOperations/binary_operations.jl#L100-L108. 2. Convert small-power exponents to literal multiplications. Like `Base.literal_pow`:. ```julia; Base.^(L::Tuple, a::AbstractField, b::Integer) = our_literal_pow(L, a, Val(b)). our_literal_pow(L, a, Val{0}) = one(eltype(a)); our_literal_pow(L, a, Val{1}) = a; our_literal_pow(L, a, Val{2}) = *(L, a, a) # binary operation; our_literal_pow(L, a, Val{3}) = *(L, a, a, a) # multiary operation; our_literal_pow(L, a, Val(b)) where b = _binary_operation(location(a), ^, a, b, location(a), location(a), a.grid) ; ```. etc. I guess 2 would instead happen under the hood when abstract operations are compiled, hopefully, in the best of worlds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1832#issuecomment-876812225:25,optimiz,optimizing,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1832#issuecomment-876812225,1,['optimiz'],['optimizing']
Performance,"Here's a summary of the current design:. I've introduced a new type called `ImmersedBoundaryCondition` to represent boundary conditions on immersed boundaries. The type has 6 fields for each direction, west, east, south, north, bottom, top. I believe this covers the general case in which we might have different fluxes on any face of a cell that's the boundary between a wet node and an immersed node. For example, we can implement ""bottom drag"" for large scale ocean models, with no ""side drag"". In practice this is really just a performance optimization rather than a physical model (the horizontal drag has no effect on the solution), but it's probably important that we can support it. This low-level, but fully general interface allow advanced users to specify any kind of immersed flux / boundary condition they need to. The next challenge is to design a convenient API that interprets user-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don'",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:532,perform,performance,532,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,Here's the [PR](https://github.com/climate-machine/Oceananigans.jl/pull/478). I'm running into a `LoadError: MethodError for min_enabled_level(::ModelLogger)`. I'm not sure how to rectify that issue. Any help will be appreciated!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-542223794:98,Load,LoadError,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-542223794,1,['Load'],['LoadError']
Performance,"Here's the julia docs on constants for reference:. https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Constants. This statement in the julia docs could maybe be clarified:. > It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. because its ambiguous what ""code involving global variables"" is. For Oceananigans, this almost always means ""functions that capture global variables in their scope"". So `f(x) = a * x` is going to be slow unless `a` is `const`; otherwise `f(x)` cannot be inlined properly because the type of `a` is uncertain.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539:223,optimiz,optimize,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539,1,['optimiz'],['optimize']
Performance,"Here's where we're at.; I've made the following modifications to `baroclinic_adjustment.jl`. ```; using Oceananigans, AMDGPU; ```; and the grid construction now specifies GPU architecture with `GPU(AMDGPU.ROCBackend())`, ie,. ```; grid = RectilinearGrid(GPU(AMDGPU.ROCBackend());; size = (48, 48, 8),; x = (0, Lx),; y = (-Ly/2, Ly/2),; z = (-Lz, 0),; topology = (Periodic, Bounded, Bounded)); ```. When running this, we hit a runtime issue at `plan_forward_transform`. ```; $ julia --project=. baroclinic_adjustment.jl ; ERROR: LoadError: MethodError: no method matching plan_forward_transform(::ROCArray{ComplexF64, 3, AMDGPU.Runtime.Mem.HIPBuffer}, ::Periodic, ::Vector{Int64}, ::UInt32). Closest candidates are:; plan_forward_transform(::CUDA.CuArray, ::Union{Bounded, Periodic}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/DPfYS/src/Solvers/plan_transforms.jl:36; plan_forward_transform(::Array, ::Periodic, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/DPfYS/src/Solvers/plan_transforms.jl:16; plan_forward_transform(::Union{CUDA.CuArray, Array}, ::Flat, ::Any...); @ Oceananigans ~/.julia/packages/Oceananigans/DPfYS/src/Solvers/plan_transforms.jl:47; ... Stacktrace:; [1] plan_transforms(grid::RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, GPU{ROCBackend}}, storage::ROCArray{ComplexF64, 3, AMDGPU.Runtime.Mem.HIPBuffer}, planner_flag::UInt32); @ Oceananigans.Solvers ~/.julia/packages/Oceananigans/DPfYS/src/Solvers/plan_transforms.jl:93; [2] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.Offset",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1946746065:528,Load,LoadError,528,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1946746065,1,['Load'],['LoadError']
Performance,"Hey @ChrisRackauckas thanks for having a look!. We do this operator-splitting method and the pressure term is treated implicitly (while all other terms are treated explicitly). To step from time `n` to `n + 1` first an explicit 2nd-order Adams-Bashforth step is used to calculate the right-hand-side at time `n + 1/2` and the pressure is calculated at `n + 1/2` by solving a Poisson equation. Then we time step the solution from time `n` to `n + 1` via a forward Euler step (using the right-hand-side evaluated at `n + 1/2`). I'm not super familiar with IMEX schemes although perhaps this is equivalent to IMEXEuler?. PS: Yes our numerical methods are pretty pathetic :(. Could be a great idea to rely on DifferentialEquations.jl for time-stepping. We'd get more options and any performance boost would be awesome! In particular, we've been hoping to upgrade to a higher-order low-storage time stepping method. Maybe a good first step would be to try and replicate the current time-stepping method we use and see if all the tests pass?. I can start looking into trying to do this. I don't think I saw `AB2` as an [option](https://docs.juliadiffeq.org/latest/solvers/ode_solve.html) (only `AB3` and up) but maybe another method can replicate what `AB2` does for us (or I can code something up).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/391#issuecomment-528849991:779,perform,performance,779,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/391#issuecomment-528849991,1,['perform'],['performance']
Performance,"Hey @LaurentPlagne thank you for your kind words!. The code and documentation definitely needs to be improved, and the CUDAnative.jl, CuArrays.jl, and GPUifyLoops.jl packages have helped a lot. Julia has been perfect for this package. We haven't really considered improving CPU performance yet as we've been focusing mostly on single-GPU performance (and we've worked on a little bit of multi-GPU stuff with MPI). As a result, running the model on a CPU isn't very useful as it only uses one core :(. Julia 1.3 seems to have some really promising multithreading so it might become easy to parallelize across multiple cores of one CPU. I think when we start improving CPU performance, we'll probably look to Julia 1.3 first. Or maybe it'll be implemented in GPUifyLoops.jl (or a renamed version of the package). I didn't know about blocking stencil computations and had to look them up. I might be wrong but it sounds like utilizing shared memory like you suggested. We haven't implemented anything like that yet but we've been playing around with an `@stencil` macro abstraction implemented in GPUifyLoops.jl (https://github.com/vchuravy/GPUifyLoops.jl/pull/81) in PR https://github.com/climate-machine/Oceananigans.jl/pull/293.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518326019:278,perform,performance,278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518326019,3,['perform'],['performance']
Performance,"Hey @beta-effect!. Yes as of PR #282 (included in master, but not in v0.8.0), boundary conditions must be specified at `Model` creation time. This is part of an ongoing attempt at making the types we use in Oceananigans more concrete. If we use structs whose types are set once the struct is created (concrete types), then the compile can more easily optimize things as it knows the data type won't change. The default boundary conditions are given by `ModelBoundaryConditions()` where; ```julia; function ModelBoundaryConditions(;; u = DoublyPeriodicBCs(),; v = DoublyPeriodicBCs(),; w = DoublyPeriodicBCs(),; T = DoublyPeriodicBCs(),; S = DoublyPeriodicBCs(); ); return ModelBoundaryConditions(u, v, w, T, S); end; ```; so I think what you want instead is something like; ```julia; T_bc = FieldBoundaryConditions(; x = CoordinateBoundaryConditions(; BoundaryCondition(Periodic, nothing),; BoundaryCondition(Periodic, nothing)),; y = CoordinateBoundaryConditions(; BoundaryCondition(Periodic, nothing),; BoundaryCondition(Periodic, nothing)),; z = CoordinateBoundaryConditions(; BoundaryCondition(Flux, 0),; BoundaryCondition(Flux, bottom_flux))). bcs = ModelBoundaryConditions(; u = DoublyPeriodicBCs(),; v = DoublyPeriodicBCs(),; w = DoublyPeriodicBCs(),; T = T_bc,; S = DoublyPeriodicBCs()); ```. We still need to figure the API a little because this gets a little annoying: you need to compute `bottom_flux` before constructing the `Model` but it's nice to use `xC, yC, zC` to compute `bottom_flux` but we get them from `model.grid`... The easiest thing to do right now might be to just create the model again but with the new `bcs`:; ```julia; # Set up the model and use an artificially high viscosity ν and diffusivity κ.; model = Model(N=(Nx, Ny, Nz), L=(Lx, Ly, Lz), arch=GPU(),; ν=1e-4, κ=1e-4). # Get location of the cell centers in x, y, z and reshape them to easily; # broadcast over them when calculating hot_bubble_perturbation.; xC, yC, zC = model.grid.xC, model.grid.yC, model.grid.zC",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/314#issuecomment-515189875:351,optimiz,optimize,351,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/314#issuecomment-515189875,1,['optimiz'],['optimize']
Performance,"Hey thanks for doing all this! Things look a lot neater. Just have a few comments/thoughts that I'll pepper throughout but should be good to merge!. > A `Model` constructor is now provided in which all important information can be input via keyword arguments. This is great for understanding what the model does, I agree. Would still be nice to keep the ""legacy constructor"" around for when you just want to create a simple `Model` for playing around with or for testing. And it makes for very nice and simple example code. > I also reduced the computational burden of a few of the tests, and changed to factor of 2 resolutions since this makes sense for FFTs (though relatively unimportant for testing, I think should encourage users to use powers of 2 and make a habit of using them ourselves). I would argue against this. While we should try to use powers of 2 for performance, I think that overly restricts the model resolutions we can be running at. There are a LOT of choices between e.g. `512x512x128` and `1024x1024x128`. It might be that the largest model that fits in memory isn't nice powers of 2. Users may have various reasons for running resolutions that aren't powers of 2. Either way, we should always be testing a wide range of grid sizes (and weird grid sizes like `109x77x13`) because the code should work for all of them. If computational cost becomes an issue we should look into paying for extra CI resources rather than reduce testing. > A few more notes:. Might be good to create some new issues based on those just to keep track of what needs to be done. > The examples are outdated. We should probably reduce the number of examples until the code becomes more stable, and commit to maintaining the few that remain. This is something I'm actively working on in a different branch. I'll make sure they work with the changes in this pull request. > Lots of work to do!. For sure!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468525078:868,perform,performance,868,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468525078,1,['perform'],['performance']
Performance,"Hey, original author of both https://github.com/JuliaGeo/NetCDF.jl and https://github.com/meggart/ZarrNative.jl here. Regarding the state of NetCDF.jl , yes I would say I mostly stopped developing the package due to time constraints and currently shift my focus towards Zarr since this is what we are using in our current project. . My last attempt at improving the NetCDF solved many of the issues with the package https://github.com/JuliaGeo/NetCDF.jl/pull/61 but was not merged because of conflicts with other bugfix PRs. However, might be source of inspiration if someone wants to do a rewrite. . Regarding write performance, I would be very interested to see examples where NetCDF.jl performs worse than e.g. python-netcdf4, since most of the time should be spent in the same NetCDF C library. I have been using the package extensively and did not experience it to be slower than comparable packages. . I you are worried about the robustness of NetCDF.jl, you should not even look at ZarrNative.jl, since it is still very young and rather a prototype. . I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475680874:617,perform,performance,617,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475680874,2,['perform'],"['performance', 'performs']"
Performance,"Hi @pnavaro thanks for opening this issue. Yeah this is an issue on some clusters so it might be worth adding a note in the documentation. In my case I think the login node had a GPU so I was able to build on the login node then just precompile and run on the compute node without internet access. But this was also before CUDA.jl which very nicely downloads CUDA artifacts for you so it just relied on the local CUDA toolkit. Do you have access to the CUDA toolkit on the login node via something like `module load cuda`? Might allow you to build on the login node without a GPU but might be weird to have CUDA but no GPU. Your compute node must have a CUDA installation. Looks like the CUDA.jl documentation has a section on how to make use of a local CUDA installation: https://juliagpu.gitlab.io/CUDA.jl/installation/overview/#CUDA-toolkit. If you can find where the CUDA toolkit is installed on your compute node, then maybe all you have to do is set one of the `CUDA_HOME`, `CUDA_ROOT` or `CUDA_PATH` environment variables?. Looks like creating a container with CUDA.jl is an option but it still requires a CUDA toolkit at runtime: https://juliagpu.gitlab.io/CUDA.jl/installation/overview/#Containers. Let us know if this helps or if you're able to get up and running on your compute node. Would be good to figure this out and add to the documentation. The #gpu channel on Julia's Slack or the GPU section of the Julia Discourse might also be good places to ask if we can't figure it out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1035#issuecomment-707637840:511,load,load,511,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1035#issuecomment-707637840,1,['load'],['load']
Performance,"Hi @roxyboy, we'll make some docs/examples soon! There are some tools in a different repo but they are rough on the edges at the moment and I'm bit reluctant to point you to it. If you have the `bathymetry` loaded as an array of the same size as a flat-bottom latitude-longitude grid then you can use [GridFittedBottom](https://clima.github.io/OceananigansDocumentation/stable/appendix/library/#Oceananigans.ImmersedBoundaries.GridFittedBottom) to do something like:. ```Julia; underlying_grid = LatitudeLongitudeGrid(arch,; size = (Nx, Ny, Nz),; longitude = (-180, 180),; latitude = (-75, 75),; z = (-depth, 0),; topology = (Periodic, Bounded, Bounded)). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809223215:207,load,loaded,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809223215,1,['load'],['loaded']
Performance,"Hi, PencilArrays / PencilFFTs author here. I'd be happy to help solving this issue, and I'd also welcome any ideas that would help improve the PencilArrays interface and docs. I am not familiar with how you define your domain partition. However, from the point of view of PencilFFTs, there is one restriction, which is that the first dimension (`x`) must *not* be decomposed in physical space. This is because FFTs are first performed along this dimension (along which data is contiguous, as usual for Julia arrays). Also, to avoid potential issues, your eigenvalues should be `PencilArray` wrappers. For now, PencilArrays allows broadcasting together `PencilArray`s and regular `Array`s, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. So I'm thinking about changing the current behaviour in the future -- and improving documentation on this. Finally, when you write:. ```julia; xc = b = solver.storage[2]; ```. you probably mean `xc = solver.storage[3]` (or, equivalently, `last(solver.storage)`, as in [this example](https://jipolanco.github.io/PencilFFTs.jl/dev/generated/in-place/#Applying-plans)). `storage[2]` holds an intermediate state that has no ""physical"" meaning, since it has been overwritten by the end of a transform. I should clarify all this in the in-place transforms example... Feel free to ping me if things are unclear in the docs or if I can provide any other information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088:425,perform,performed,425,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088,1,['perform'],['performed']
Performance,"Hitting some weird stack overflow error on the GPU when attempting to launch the `calculate_interior_source_terms!` time stepping kernel. Just documenting it here in case it shows up again in the future (hopefully will follow up with a solution). ```; ERROR: StackOverflowError:; Stacktrace:; [1] snca_compress!(::Array{Core.Compiler.Node,1}, ::Array{UInt64,1}, ::UInt64, ::UInt64) at ./compiler/ssair/domtree.jl:209 (repeats 25910 times); [2] SNCA(::Core.Compiler.CFG) at ./compiler/ssair/domtree.jl:260; [3] construct_domtree(::Core.Compiler.CFG) at ./compiler/ssair/domtree.jl:104; [4] run_passes(::Core.CodeInfo, ::Int64, ::Core.Compiler.OptimizationState) at ./compiler/ssair/driver.jl:122; [5] optimize(::Core.Compiler.OptimizationState, ::Any) at ./compiler/optimize.jl:164; [6] typeinf(::Core.Compiler.InferenceState) at ./compiler/typeinfer.jl:35; [7] typeinf_edge(::Method, ::Any, ::Core.SimpleVector, ::Core.Compiler.InferenceState) at ./compiler/typeinfer.jl:497; [8] abstract_call_method(::Method, ::Any, ::Core.SimpleVector, ::Core.Compiler.InferenceState) at ./compiler/abstractinterpretation.jl:345; [9] abstract_call_gf_by_type(::Any, ::Array{Any,1}, ::Any, ::Core.Compiler.InferenceState) at ./compiler/abstractinterpretation.jl:85; [10] abstract_call(::Any, ::Tuple{}, ::Array{Any,1}, ::Array{Any,1}, ::Core.Compiler.InferenceState) at ./compiler/abstractinterpretation.jl:776; [11] abstract_apply(::Any, ::Array{Any,1}, ::Array{Any,1}, ::Core.Compiler.InferenceState) at ./compiler/abstractinterpretation.jl:519; [12] abstract_call(::Any, ::Array{Any,1}, ::Array{Any,1}, ::Array{Any,1}, ::Core.Compiler.InferenceState) at ./compiler/abstractinterpretation.jl:567; [13] abstract_eval_call(::Array{Any,1}, ::Array{Any,1}, ::Array{Any,1}, ::Core.Compiler.InferenceState) at ./compiler/abstractinterpretation.jl:805; [14] abstract_eval(::Any, ::Array{Any,1}, ::Core.Compiler.InferenceState) at ./compiler/abstractinterpretation.jl:890; [15] typeinf_local(::Core.Compiler.InferenceState",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/153#issuecomment-477727916:642,Optimiz,OptimizationState,642,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/153#issuecomment-477727916,4,"['Optimiz', 'optimiz']","['OptimizationState', 'optimize']"
Performance,"Hmmm - I am skeptical about that from a computer point of view? In an implicit algorithm and/or radiative transfer alg the next step often depends on the result of the previous steps. . As every CCE graduate student learns, computers take many tens of cycles to evaluate an operation like a an add or multiply. The operation is sequential and carried out in a multi-stage pipeline in the heart of a CPU (or GPU). So unless the compiler has something else for the processor to do, the processor will have to wait for one step to make it through the pipeline before the next step? . I think the normal way to do this is to have some inner horiz blocking that is flexible (and can be 1,1) and then iterate over levels with some intermediate stores? The horiz block can be some fraction of inner cache or GPU local proc shared mem. The math doesn't quite look at this way because it assumes that a+b and/or a*b etc.. happen ""instantaneously"". It does not take into account that the awnser from a*b might take; 5-10 clock cycles to pass through the CPU floating point unit. . I think that is fairly generally true? Functional style code in Julia should make it possible; to express this in a fairly clean way, but with flexibility to change blocking for different ; target arch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541363073:792,cache,cache,792,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541363073,1,['cache'],['cache']
Performance,Hmmm a lot of failures due to CUDA scalar `getindex` operations even though we explicitly set `CUDA.allowscalar(true)` in `runtests.jl`... We could take this opportunity to get rid of all scalar operations in the tests and just use `CUDA.@allowscalar` where it's needed. Maybe new CUDA scalar operations are hurting performance and that's why GPU CI has slowed down?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-816964002:316,perform,performance,316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-816964002,1,['perform'],['performance']
Performance,Hmmm yeah... Just an idea but in https://github.com/climate-machine/Oceananigans.jl/pull/685 the performance regression was actually due to not eliding `_apply_*_bcs!` for `NotFluxBC` so maybe we could be eliding some computation or function call?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/710#issuecomment-604372102:97,perform,performance,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/710#issuecomment-604372102,1,['perform'],['performance']
Performance,"Hmmm, since the conveniently shaped arrays won't be used in performance-critical code like time-stepping, maybe it makes sense to to just add a convenience function, e.g.; ```julia; xC, yC, zC = coordsC(grid); ```; that returns reshaped arrays.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/348#issuecomment-519872781:60,perform,performance-critical,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/348#issuecomment-519872781,1,['perform'],['performance-critical']
Performance,"Hmmm, yeah indeed the halos aren't exactly correct. For example, rows 1-2 (j=-1,0). ```; -0.0085938 -0.00844015 -0.0085938 -0.00844015 -0.0085938 -0.00844015; -0.010009 -0.0104645 -0.010009 -0.0104645 -0.010009 -0.0104645; ```. should exactly match rows 33-34 (j=Ny-1,Ny) but don't. ```; -0.0085938 -0.00844015 -0.0102716 -0.0103836 -0.0085938 -0.00844015; -0.010009 -0.0104645 -0.0101071 -0.0100802 -0.010009 -0.0104645; ```. I don't think this is a problem for time-stepping as the Oceananigans algorithm only fills halo regions right before it is needed (to improve performance). If you need the halo regions to be correct then you could manually call `fill_halo_regions!(model.velocities.u, CPU())`. A cleaner alternative if this is a desirable feature might be to add a `fill_halo_regions` keyword argument to `time_step!` (and `Simulation`) to ensure all halos are filled and the fields are consistent at the end of each time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/949#issuecomment-693639468:569,perform,performance,569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/949#issuecomment-693639468,1,['perform'],['performance']
Performance,How about benchmarking the examples?. We should have a fully-loaded example too.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1089#issuecomment-713730714:61,load,loaded,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1089#issuecomment-713730714,1,['load'],['loaded']
Performance,"How exactly would we enforce incompressibility? Should we perform a pressure correction step? Something like. ```julia; function set!(model; enforce_incompressibility=false, kwargs... # everything else in `set!`. if enforce_incompressibility; calculate_pressure_correction!(model, 1.0); pressure_correct_velocities!(model, 1.0); end. return nothing; end; ```. (This syntax will work once #1057 is merged). The ""1.0"" is a pseudo-timestep that is technically irrelevant (but can't be `Inf` or `0`). The two above functions come from the time-stepping routine:. https://github.com/CliMA/Oceananigans.jl/blob/c35af739186434d754c70966ecc52e4cc61db5a2/src/TimeSteppers/runge_kutta_3.jl#L73-L74. I suppose this projects the user-defined velocity field onto an incompressible field, which is more or less what we want? It seems better than recomputing `w` from continuity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1027#issuecomment-710686571:58,perform,perform,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1027#issuecomment-710686571,1,['perform'],['perform']
Performance,"Huh --- on my GPU I was getting 2x speed up for `Float32`. I'll have to check that again. The slow down has to do with the abstractions I have introduced. 30% is a huge slow down for one function, indicative of a major problem --- probably a type inference issue? . I think that once this problem is solved the code may become faster because of the disambiguation this PR lends to the innermost kernels. This problem becomes catastrophic for the closures, which make heavy use of the abstraction. So solving this problem is imperative. We can restore the performance of the default closure by simply pasting the old operators into `constant_diffusivity_closures.jl`. However, I believe the issue with type inference is solvable. . Unfortunately, I'm in `Cthulhu` hell right now trying to figure it out... I'm wondering whether these problems will vanish once we eliminate branches from the inmost functions...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496902962:555,perform,performance,555,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496902962,1,['perform'],['performance']
Performance,"I add a bit of context here:. @Yixiao-Zhang is doing a non-hydrostatic simulation with an immersed boundary and he finds that the code crashes with the PCG solver. That is not necessarily connected with the PCG solver but it might be caused by simulation setup or other issues. Since the pressure solver used is experimental (from [this branch](https://github.com/CliMA/Oceananigans.jl/tree/glw-xk/divergence-free-immersed-velocity-field)), as a way to assess where the crashing comes from, I suggested using another method to see if the crash would also happen, which would validate or not the experimental pressure solver. @Yixiao-Zhang, optimizing GPU preconditioners is a quite difficult task as demonstrated by the preconditioners slowing down the simulation, and probably not a good use of time of trying to figure out a way to speed up these solvers that we are not sure we want to use. ; Since this simple attempt to have a simulation that runs (with another _correct_ solver) up to the crashing point does not work, I would suggest to just trying to use a (slightly non-correct) FFT pressure solver to see if the simulation still crashes.; If not, then we can assume the crashing occurs due to the PCG solver and try to catch the bug. ; This will probably be a better way to ""optimize"" the solver since we know that the PCG preconditioned with FFT is faster than these other methods.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2052606749:640,optimiz,optimizing,640,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2052606749,2,['optimiz'],"['optimize', 'optimizing']"
Performance,I added a `.gitignore` to the `gh-pages` branch so we should be good now. This PR now deletes leftover JLD2 files before deploying (just to be safe and also to unclutter the CI server in case we need to cache files between builds).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/558#issuecomment-563309498:203,cache,cache,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/558#issuecomment-563309498,1,['cache'],['cache']
Performance,"I agree that I would expect it to saturate at higher than 16 if there were 48 cores, but clearly I'm wrong. Getting another benchmark would be a good idea. I'm happy to consider the numba + parallel idea since that would be good to test the architecture. This [mini-course](https://github.com/omlins/parallel-gpu-workshop-JuliaCon21) did give some threaded examples to solve the diffusion equation in 3D. I wonder if we might want to ask Ludovic if they have done any scalings for multi-threading?. I'm happy to discuss this with @hennyg888 on Monday and see what we come up with. Others are happy to join the discussion if they like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886074548:481,multi-thread,multi-threading,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886074548,1,['multi-thread'],['multi-threading']
Performance,"I agree with @navidcy's points. Of course, it doesn't even matter whether the tracer is initialized or not (referring to the comment in @navidcy's script). The main point is that you can ""re-initialize"" a state whenever you like. I'd also like to make the extra point that @navidcy's pattern is interpretable and readable. I'm not sure we would achieve the same if we hide such a feature inside the source code. Does @navidcy's suggestion work for you @tomchor ?. I also think it is preferred to use separate files for a situation like this (though it may not be necessary to save intermediate times in the spin-up at all --- so a second file might not be necessary). If the spin up is recorded, I think it's better to use a separate file for its data. If the spin up is expensive, the following performance optimization could be used (we can leverage the `velocities` kwarg to save a bit of allocation):. ```julia; # Spin up with no tracers; model = NonhydrostaticModel(; tracers=nothing, kwargs...); simulation = Simulation(model, ...) # etc; run!(simulation). # Run for real, re-using the old `velocities` fields but overwriting the old `model`; model = NonhydrostaticModel(; tracers=:c, velocities=model.velocities, kwargs...); simulation = Simulation(model, ...) # etc; ```. There is some additional memory allocation for tendencies in this case, however, so it may not work for simulations that push GPU memory. > (I'm not aware of any way to ""remove"" the old Simulation from the GPU memory, but if there is, then this downside can be negated.). This occurs automatically with garbage collection, provided that there's no reference to the old simulation in the name space. CUDA may have a way to manually call the garbage collector, after doing something like `model=nothing; simulation=nothing`. If you figure that out, it'd be nice to know. > It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work. I don't foll",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605717680:796,perform,performance,796,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605717680,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"I agree. The focus should be on moving to a proper file format (#30, #31) then this will be a non-issue. The only use case I see for frequent massive data dumps is if you're running such a massive simulation where writing output almost becomes a bottleneck (apparently was a big issue with [LLC4320](http://online.kitp.ucsb.edu/online/blayers18/menemenlis/)). No point worrying about this case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/37#issuecomment-462853542:246,bottleneck,bottleneck,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/37#issuecomment-462853542,1,['bottleneck'],['bottleneck']
Performance,"I also had this issue, as new into GPU running, I was super confused about this error. It will be helpful if this issue is not fixable, to at least point out in the documentation. . I encountered this error by running a simulation based on the tutorial ([Langmuir turbulence](https://clima.github.io/OceananigansDocumentation/stable/generated/langmuir_turbulence/#Langmuir-turbulence-example)) in GPUs. Note that the print function prints the `maximum(abs, u), maximum(abs, v), maximum(abs, w)`:; ```; msg = @sprintf(""i: %04d, t: %s, Δt: %s, umax = (%.1e, %.1e, %.1e) ms⁻¹, wall time: %s\n"",; iteration(simulation),; prettytime(time(simulation)),; prettytime(simulation.Δt),; maximum(abs, u), maximum(abs, v), maximum(abs, w),; prettytime(simulation.run_wall_time)); ```; thus resulting in the error:; ```; LoadError: CUDA error: too many resources requested for launch; ```; For reference, the code works once the `maximum` functions are removed:; ```; msg = @sprintf(""i: %04d, t: %s, �~Tt: %s, wall time: %s\n"",; iteration(simulation),; prettytime(time(simulation)),; prettytime(simulation.�~Tt),; prettytime(simulation.run_wall_time)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1992106103:807,Load,LoadError,807,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1992106103,1,['Load'],['LoadError']
Performance,"I also want to drop another optimization that can be used here --- using a `Float32` grid with the preconditioner. This will speed things up a bit. Eg:. ```julia; using Oceananigans.Grids: with_number_type. reduced_precision_grid = with_number_type(Float32, underlying_grid). pressure_solver = ConjugateGradientPoissonSolver(grid;; preconditioner = fft_poisson_solver(reduced_precision_grid),; maxiter = 10; ); ```. I also suggest plotting the divergence to get a handle on how the solver is working. A well-converged solution seems to have isotropically-distributed divergence errors. With looser tolerances, the divergence may be concentrated around the bathymetry (and of course with the naive FFT solver it has a thin layer adjacent to the bathymetry). I also think it would be nice if setting `maxiter=0` had a similar effect as simply using the FFT-based preconditioner. It's not the case right now, I think because we do not apply the preconditioner to the pressure initially before doing the CG iteration. It might not work (I believe I experimented briefly with that to no avail).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2414308611:28,optimiz,optimization,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2414308611,1,['optimiz'],['optimization']
Performance,I am actually looking into implementing a multidimensional _sweep_ approach that will allow us to break the 2nd order limit. https://d-nb.info/1124132775/34; https://www.sciencedirect.com/science/article/pii/S0021999104002281. I ll see if it is too difficult or unfeasible in terms of performance,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164483965:285,perform,performance,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164483965,1,['perform'],['performance']
Performance,"I am happy to open a PR but when I try the line you suggested , unfortunately, there is still a problem. Some good news! This fixes it for the vector invariant formulation. However, when I try the conervative form it complains about not knowing `u`. See the start of the output below. ```; ERROR: LoadError: TaskFailedException. nested task error: type NamedTuple has no field u; Stacktrace:; [1] getproperty(x::NamedTuple{(:uh, :vh, :h), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152672984:297,Load,LoadError,297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152672984,1,['Load'],['LoadError']
Performance,"I am happy with both names but do we need a distributed for each framework? I thought they were almost identical but don't remember the details. Francis; ________________________________; From: Ali Ramadhan ***@***.***>; Sent: Tuesday, March 23, 2021 10:34:09 AM; To: CliMA/Oceananigans.jl ***@***.***>; Cc: Francis Poulin ***@***.***>; Author ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] `MultiCPU` or `MPI_CPU` (#1502). True. I guess we don't have a separate architecture for multi-threaded. I agree that MPI_CPU or MPICPU would be more precise. What do you think of DistributedCPU and DistributedGPU?. -; You are receiving this because you authored the thread.; Reply to this email directly, view it on GitHub<https://github.com/CliMA/Oceananigans.jl/issues/1502#issuecomment-804952861>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AB63PQIRKGMIJUKMEU5CYQTTFCRGDANCNFSM4ZUIJ5FQ>.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1502#issuecomment-804964762:484,multi-thread,multi-threaded,484,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1502#issuecomment-804964762,1,['multi-thread'],['multi-threaded']
Performance,"I am not certain what the `ignore-cache` flag does, I borrowed the module loading sequence. I am pretty it ignores previously loaded modules with the same or similar name.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2256247465:34,cache,cache,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2256247465,3,"['cache', 'load']","['cache', 'loaded', 'loading']"
Performance,"I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353966686:97,perform,performance,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353966686,1,['perform'],['performance']
Performance,"I am talking about changes to `Field`, which wraps around `OffsetArrays` so there is no effect on performance. We currently use `OffsetArrays`, not `Field`s, in our kernels. For the way we currently time-step this would also have no effect on GPU compatibility, because, again, we use `OffsetArrays` in our kernels, rather than `Field`s.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/457#issuecomment-542272226:98,perform,performance,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/457#issuecomment-542272226,1,['perform'],['performance']
Performance,I believe #1770 does the trick:. ```; [2021/06/25 18:04:55.066] INFO Writing Advection_schemes_relative_performance_(CPU).html...; Advection schemes relative performance (GPU); ┌───────────────┬────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Schemes │ slowdown │ memory │ allocs │; ├───────────────┼────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ CenteredFourthOrder │ 1.36629 │ 1.07711 │ 1.66944 │; │ GPU │ CenteredSecondOrder │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ UpwindBiasedFifthOrder │ 1.53522 │ 1.11266 │ 1.9781 │; │ GPU │ UpwindBiasedThirdOrder │ 1.31322 │ 1.03505 │ 1.30432 │; │ GPU │ WENO5 │ 1.84272 │ 1.1889 │ 2.64008 │. ```. would be good to get confirmation from someone.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868903480:158,perform,performance,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868903480,1,['perform'],['performance']
Performance,"I believe there's some issue with initialization. It doesn't help to rebuild the individual jobs, because the initialization only happens once and the results are cached are re-used within each build. I think somehow we have to start a new build with a new ID.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3580#issuecomment-2371783629:163,cache,cached,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3580#issuecomment-2371783629,1,['cache'],['cached']
Performance,"I changed `∂xᶠᵃᵃ` to use `Δxᶠᵃᵃ` and when I try and compute the `x` derivative of the free surface in the `x` momentum equation I get the following error. It seems to me like we need to generalize this function, and others, to work on immersed grids. I pressume this is what the other models do? Looks like the fix could be easy. ```; ERROR: LoadError: TaskFailedException. nested task error: MethodError: no method matching ∂xᶠᵃᵃ(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Bounded, Flat, RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{typeof(bump)}}, ::typeof(Oceananigans.Models.ShallowWaterModels.gh2), ::Field{Center, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Flat, RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{typeof(bump)}}, Float64, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, CoordinateBoundaryConditions{Nothing, Nothing}}}}, ::Float64); Closest candidates are:; ∂xᶠᵃᵃ(::Any, ::Any, ::Any, ::AbstractRectilinearGrid, ::F, ::Any...) where F<:Function at /home/fpoulin/software/Oceananigans.jl/src/Operators/derivative_operators.jl:16; ∂xᶠᵃᵃ(::Any, ::Any, ::Any, ::AbstractRectilinearGrid, ::Any) at /home/fpoulin/software/Oceananigans.jl/src/Operators/derivative_operators.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-849719531:342,Load,LoadError,342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-849719531,1,['Load'],['LoadError']
Performance,"I completely agree. I'd even go further and suggest a section for simulation tips in general, and then a subsection for GPU tips specifically. As an example, I noticed that defining as many things as `const` as possible helps with performance, even if I'm running on a CPU. It seems kinda obvious in hindsight, but it took me a few months to think of that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800468178:231,perform,performance,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800468178,1,['perform'],['performance']
Performance,"I copied one of the errors below. I remember seeing this error before but I'm not sure how it was resolved. Restarting the tests?. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 87 seconds (200 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7803/compiled/v1.6/Oceananigans/hU93i_V4y9F.ji"": No such file or directory;   | Stacktrace:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343:305,Load,LoadError,305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343,2,['Load'],['LoadError']
Performance,"I d like to try to improve performance a bit first... Anyways, by next week I ll merge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1190872511:27,perform,performance,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1190872511,1,['perform'],['performance']
Performance,"I do hope that I found something useful but at the moment I am a bit confued as to what's going wrong. I'm going to copy the errors below so others can see this more easily. The error in the docs complains about `PlotUtils` failing to precompile. That doesn't seem related to shallow water so I am confused. The CPU test seems to be with `MPI`, but I didn't know we had any `MPI` tests that used shallow water that were being run. Docs:; ```; ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; --; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: Failed to precompile PlotUtils [995b91a9-d308-5afd-9ec6-746e21dbc043] to /storage7/buildkite-agent/.julia-2556/compiled/v1.5/PlotUtils/YveHG_R3lk8.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] top-level scope at none:2; &nbsp; | [2] eval at ./boot.jl:347 [inlined]; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2556/packages/Plots/SjqWU/src/Plots.jl:20; &nbsp; | ERROR: LoadError: Failed to precompile Plots [91a5bcdd-55d7-5caf-9e0b-520d859cae80] to /storage7/buildkite-agent/.julia-2556/compiled/v1.5/Plots/ld3vC_R3lk8.ji.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-1/clima/oceananigans/docs/make.jl:6; &nbsp; | 🚨 Error: The command exited with status 1. ```. CPU test; ```; [8] test() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:72; --; &nbsp; | [9] top-level scope at none:1; &nbsp; | Union{},Union{},Tuple{},NamedTuple{(test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; ERROR: failed process: Process(`/storage7/buildkite-agent/.julia-2556/artifacts/2fcd463fb9498f362be9d1c4ef70a63c920b0e96/bin/mpiexec -np 4 /storage7/buildkite-agent/julia-1.5.4/bin/julia -O0 --color=yes -e 'using Pkg; Pkg.test()'`, ProcessExited(1)) [1]; &nbsp; | &nbsp;; &nbsp; | Stacktrace:; &nbsp; | [1] pipeline_error at ./process.jl:525 [inlined]",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842643141:460,load,load,460,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842643141,3,"['Load', 'load']","['LoadError', 'load']"
Performance,"I don't follow everything here but it looks like the simulation is being performed on a login node in the above screenshot. @Sumanshekhar17, your cluster may have a policy in place to stop (""kill"") jobs that run on a login node. To sort out script vs cluster issues I suggest running the script on a local machine (for example, your laptop) first. If it runs to completion, and also starts and runs on the cluster with `architecture=GPU()`, then we know the problem is due to cluster policy or some other cluster-specific setting, rather than a problem with your script or Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-756149003:73,perform,performed,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-756149003,1,['perform'],['performed']
Performance,"I don't know exactly what to do, so we'll need help. I've started with a post to the julia slack: https://julialang.slack.com/archives/C67910KEH/p1635909337281400. On the other hand, it may not be a huge issue if it only affects diagnostics that are evaluated fewer than 5 times. For long running simulations, our methods do eventually get cached? Do you have an example of a method that doesn't get cached after 5 evaluations?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958631268:340,cache,cached,340,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958631268,2,['cache'],['cached']
Performance,"I don't know if this helps to make the issue clearer, but I just re-ran the code for just ; ```; using Oceananigans ; ```; and it executed without error. I ran it again to see if it was just a fluke and I got the following error:; ```. The following have been reloaded with a version change:; 1) cuda/12.2.1 => cuda/11.8.0. [59837] signal (11.1): Segmentation fault; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; Allocations: 605144 (Pool: 604223; Big: 921); GC: 1; /var/spool/pbs/mom_priv/jobs/1741845.casper-pbs.SC: line 31: 59837 Segmentation fault (core dumped) julia --project testcode.jl /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/; ```; Could it be an issue with the computer loading Oceananigans.jl with a bunch of extra functions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2237133645:739,load,loading,739,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2237133645,1,['load'],['loading']
Performance,"I don't know. Increasing grid points to 4, there's still a problem with 6 threads. ```julia; (base) gregorywagner:Oceananigans.jl/ (main✗) $ JULIA_NUM_THREADS=6 julia --project race_condition_test.jl [19:56:49]; [ Info: Oceananigans will use 6 threads; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (79.416 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (6.660 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; (parent(simulation.model.velocities.u))[1, 1, :] = [1.9557581998545617, 1.9557581998545617, 1.956214574857873, 1.9553566305291932, 1.9553371609848056, 1.9553371609848056]; Test Failed at /Users/gregorywagner/Projects/test/Oceananigans.jl/race_condition_test.jl:17; Expression: (parent(simulation.model.velocities.u))[1, 1, 2] == (parent(simulation.model.velocities.u))[1, 1, 3]; Evaluated: 1.9557581998545617 == 1.956214574857873; ERROR: LoadError: There was an error during testing; in expression starting at /Users/gregorywagner/Projects/test/Oceananigans.jl/race_condition_test.jl:17; ```. and also with 4. But with 3,. ```julia; (base) gregorywagner:Oceananigans.jl/ (main✗) $ JULIA_NUM_THREADS=3 julia --project race_condition_test.jl [19:58:49]; [ Info: Oceananigans will use 3 threads; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (98.396 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (6.548 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; (parent(simulation.model.velocities.u))[1, 1, :] = [1.9543734841879783, 1.9543734841879783, 1.9543734841879783, 1.9560232965664703, 1.9567081251492398, 1.9567081251492398]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308177839:988,Load,LoadError,988,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308177839,1,['Load'],['LoadError']
Performance,"I don't suspect this is the best place to post this but I'll start here and happy to move the conversation over to wherever it should be happening. I have created a new branch called ""ShallowWaterS1waveeqn"". S1 is for step 1. It doesn't do much right now but I'm trying to set up the skeleton so that we can actually do something intereting, like evolve the equation. At the moment I have the following:. - Created a ShallowWaterModels folder. - Created a ShallowWaterModels.jl module. It doesn't do much except include shallowwater_model.jl. - shallowwater_model.jl defines a mutable struct and a function. I couldn't get a lot of things to work but it does regularlize the boundary condtions, set up the velocities and a new variable called layer_depth. The name is not great and can go with depth or height, as people prefer. It will be in in the governing equations. - Created an example, in the same folder, called onedim_shallowwater.jl. Currently, this includes the module mentioned above, defines a grid (yes, a single point!), defines the initial conditions and sets the velocity. Questions: . 1. This is pretty bare bones so far but does this follow the philosophy of Oceananigans?; 2. I have tried to inititalze the layer_depth by adding an argument into the set! command but it failed. Below is the command that I thought would work and below is the error because layer_depth is not model.velocities or model.tracers. Can someone help me to see what silliness I am doing?. ``` ; set!(model, u = u, v = v, layer_deth = layer_depth); fails with ""ERROR: LoadError: ArgumentError: name layer_depth not found in model.velocities or model.tracers.""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-728964105:1563,Load,LoadError,1563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-728964105,1,['Load'],['LoadError']
Performance,"I don't think it's the tests that are slow. One of the tests involves time stepping a model for 10 time steps and it prints the wall clock time taken for each time step. It's only 2-3 ms so it's executing the tests at the expected speed. I've looked into the logs and it seems to be busy building packages. It's no different than what Travis and GitLab CI do, so maybe this just takes much longer on Windows CI? If we reduce the number of build dependencies that should help then. And if we can cache the builds then that would be excellent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/89#issuecomment-468291280:495,cache,cache,495,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/89#issuecomment-468291280,1,['cache'],['cache']
Performance,"I found this issue [here](https://github.com/JuliaGPU/CUDA.jl/issues/84) that seems to discuss the problem that we had with this PR (or at least my limited understanding of the problem). I went through the steps and I think they fixed it as it worked for me. . @ali-ramadhan , do you know which norm failed on a `CuArray` or did they all fail?. ```; julia> using LinearAlgebra, CUDA. julia> x=cu([1.,2.]); 2-element CuArray{Float32,1}:; 1.0; 2.0. julia> norm(x); 2.236068f0. julia> norm(x,2); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:43; 2.236068f0. julia> norm(x,0); 2.0f0. julia> norm(x,1); 3.0f0. julia> norm(x,4); 2.030543f0. julia> norm(x,Inf); 2.0f0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1562#issuecomment-817778463:504,Perform,Performing,504,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1562#issuecomment-817778463,1,['Perform'],['Performing']
Performance,I got good results in the past on discretized PDE problems. The main bottleneck is to perform the sparse triangular solves at each iteration of the Krylov method (`ldiv!`) on GPU but I did some operators in `KrylovPreconditioners.jl` to reuse the analysis of the sparsity pattern as well as the buffers:; - https://github.com/JuliaSmoothOptimizers/KrylovPreconditioners.jl/blob/main/ext/CUDA/operators.jl#L82; - https://github.com/JuliaSmoothOptimizers/KrylovPreconditioners.jl/blob/main/ext/AMDGPU/operators.jl#L103; - https://github.com/JuliaSmoothOptimizers/KrylovPreconditioners.jl/blob/main/ext/oneAPI/operators.jl#L50. We can also apply the same strategy for the ILU(0) preconditioner provided by the GPU vendors.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3789#issuecomment-2374729281:69,bottleneck,bottleneck,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3789#issuecomment-2374729281,2,"['bottleneck', 'perform']","['bottleneck', 'perform']"
Performance,"I got it. ```julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 139 already precompiled. julia> grid = RectilinearGrid(size=1, x=(0, 1), topology=(Periodic, Flat, Flat)); 1×1×1 RectilinearGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Flat y; └── Flat z. julia> grid = ImmersedBoundaryGrid(grid, GridFittedBoundary(x -> true)); warning: /Users/gregorywagner/.julia/packages/KernelAbstractions/MAxUm/src/cpu.jl:118:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; 1×1×1 ImmersedBoundaryGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo:; ├── immersed_boundary: GridFittedBoundary{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Bool, 3, Array{Bool, 3}}, Bool, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}; ├── underlying_grid: 1×1×1 RectilinearGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Flat y; └── Flat z. julia> c = CenterField(grid); 1×1×1 Field{Center, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 1×1×1 ImmersedBoundaryGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo; ├── boundary conditions: ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3742#issuecomment-2314132900:578,optimiz,optimizer,578,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3742#issuecomment-2314132900,2,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,"I guess in our terminology ""saving"" is a bit more restricted than ""serializing"". When we ""save"" an object, we do it in a way that might be readable from Python or MATLAB (for example). This means that we only ""save"" common types like numbers, arrays, strings. Anything we output to NetCDF is ""saved"". When we ""serialize"" we might embed a Julia struct in a file. So when we serialize something we can only load it back from Julia. We can only serialize with JLD2.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039401633:405,load,load,405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039401633,1,['load'],['load']
Performance,"I have a start to this soon to be PR (I hope) but nothing working yet. . One issue that comes up is that `automatic_halo_sizing.jl` should not extend the halo if the topology is flat This is easy enough to set this up in principle, however, when I try telling it what `Flat` means using the following `using Oceananigans.Grids: Flat`, it fails. . How should I load `Flat` at this stage?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-803738292:360,load,load,360,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-803738292,1,['load'],['load']
Performance,"I have been running on the system Julia for these, I attempted to do my own install but I do not think I ended up doing much with it. I believe `gcc` is a dependency for the subsequent modules as for example when I run:; ```; module --force purge; module load ncarenv/23.10 ; module load ncarcompilers/1.0.0; ```; the last line returns ; ```; Lmod has detected the following error: These module(s) or; extension(s) exist but cannot be loaded as requested: ""ncarcompilers/1.0.0""; Try: ""module spider ncarcompilers/1.0.0"" to see how to load the module(s).; ```; which does not happen if I include `gcc`. I was also able to run my code without netcdf!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258913846:255,load,load,255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258913846,4,['load'],"['load', 'loaded']"
Performance,"I have checked thoroughly _every_ function in the advection module for a `checkbounds()` call and couldn't produce any Bounds error. This is remaining a mystery to me because it seems that the whole advection module elides bounds checking. On the other hand, I found that `main` has the same problem, on the `near_global_quarter_degree.jl` experiment this is the wall time per 10 time steps; (with `--check-bounds=no`, without `--check-bounds=no`); main -> 2.7 / 3.6 s; this PR -> 3.3 / 4.4 s. so there is for sure a problem of performance (which I will try to solve) but it does not seem to be related to bounds checking as; `2.7 / 3.6 = 3.3 / 4.4 = 0.75`. It is a must to find out where these bounds checks are eating up 25% of our computational time (do you know an easy way to profile it?).; By the way @tomchor, is this also the ratio that you find in your simulations (maybe with the latest commit)? If yes, I ll give up trying to inbound and only try to speed up the advection.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186040507:528,perform,performance,528,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186040507,1,['perform'],['performance']
Performance,"I have moved the open fill to nominally be called within `fill_halo_regions!` as the new format (`fill_halo_regions!` and `fill_open_boundary_regions!` both having to be called separately) is confusing. I think a user would expect `fill_halo_regions!` to fill all of the halos. Instead `fill_halo_regions!` has a kwarg `fill_open_boundaries` which is nominally true, and I have set to `false` in the halo fill following the pressure correction. If we didn't do this we would also have needed to add loads of calls to `fill_open_boundary_regions!` in the hydrostatic model code, which would have confused matters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2150059461:499,load,loads,499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2150059461,1,['load'],['loads']
Performance,I have never tried benchmarking this. maybe the gain in performance is negligible. I guess it will depend on the number of particles and the size of the grid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775560431:56,perform,performance,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775560431,1,['perform'],['performance']
Performance,"I have some validation scripts already that work on the CPU and indicate that the new closure is working. However, I can't make this work on the GPU. I keep getting this error:. ```; ERROR: LoadError: GPU compilation of MethodInstance for Oceananigans.TurbulenceClosures.gpu__compute_scale_invariant_smagorinsky_viscosity!(::KernelAbstractions.CompilerMetadata{…}, ::OffsetArrays.OffsetArray{…}, ::Field{…}, ::Field{…}, ::RectilinearGrid{…}, ::ScaleInvariantSmagorinsky{…}, ::Nothing, ::@NamedTuple{…}, ::@NamedTuple{}) failed; KernelError: passing and using non-bitstype argument. Argument 7 to your kernel function is of type ScaleInvariantSmagorinsky{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Oceananigans.TurbulenceClosures.DirectionalAveraging{Tuple{Int64, Int64}}, Float64, @NamedTuple{}, Integer}, which is not isbits:; .update_frequency is of type Integer which is not isbits.; ```. Reading up on the CUDA.jl docs I _think_ I understand where this error comes from (although I thought `update_frequency`, which is an `Integer`, should work, but it throws an error). Still couldn't figure out how to fix it in this case here. I assume it's not hard to fix though, so I was wondering if someone (I'm assuming @simone-silvestri or @glwagner) can please give me a hand or at least point me in the right direction?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2294992357:190,Load,LoadError,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2294992357,1,['Load'],['LoadError']
Performance,I haven't looked at performance / GPU compilation in detail. I do think there is a type inference issue somewhere in this PR now because the flow over hills experiment is 7-8x slower on my laptop even without any immersed boundary condition. This likely indicates a problem with type inference in the flux divergence function (might also prevent GPU compilation). So we'll have to solve that and also add tests for CPU + GPU...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100751806:20,perform,performance,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100751806,1,['perform'],['performance']
Performance,"I implemented a simple new validation test that runs a two-dimensional barotropic turbulence problem with `ExplicitFreeSurface`: https://github.com/CliMA/Oceananigans.jl/blob/ss/multi_region/validation/multi_region/multi_region_turbulence.jl. Here's some miscellaneous notes:. * `WENO5(vector_invariant=VelocityStencil())` is faster than `WENO5()`. Note that when we write ""WENO5(vector_invariant=stencil)"" we mean that we are using the vector invariant formulation of momentum with a WENO reconstruction for vorticity, using either ""velocity"" or ""vorticity"" in the WENO smoothness metric. The ""WENO, Vector Invariant"" scheme is probably faster because it has fewer WENO interpolations (just one per momentum component rather than 2).; * `WENO5(vector_invariant=VelocityStencil())` blows up with `MultiRegionGrid`. Some timings:. | Resolution | Grid | Advection scheme | Wall time for 1000 time steps |; | ------------- | ------------- | -- | -- |; | 128^2 | `RegularRectilinearGrid` | `WENO5()` | 3.9 s |; | 128^2 | `MultiRegionGrid` | `WENO5()` | 7.4 s |; | 128^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 2.8 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5()` | 14.3 s |; | 256^2 | `MultiRegionGrid ` | `WENO5()` | 18.9 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 10.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5()` | 56.3 s |; | 512^2 | `MultiRegionGrid ` | `WENO5()` | 62.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 40.3 s |. I propose that we. 1) Close the gap between multi-region and single-region performance?; 2) Understand why WENO vector invariant blows up on a multi region grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730:1635,perform,performance,1635,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730,1,['perform'],['performance']
Performance,I just noticed:. https://buildkite.com/clima/oceananigans/builds/11955#018909c3-4c60-4b9c-b4e2-c6260d8b2189/40-2662. ```; [ Info: shallow_water_Bickley_jet.jl example took 28.452 minutes to build.; ```. We should optimize that or make it run first!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1613995023:213,optimiz,optimize,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1613995023,1,['optimiz'],['optimize']
Performance,"I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:. `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`. Then it returns the following error:. <details>; <summary>Error output:</summary>. ```; ERROR: ERROR: LoadError: ERROR: LoadError: LoadError: ERROR: LoadError: MethodError: no method matching MethodError: no method matching MethodError: iterate(::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212:227,optimiz,optimizer,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212,6,"['Load', 'optimiz', 'perform']","['LoadError', 'optimizer', 'perform']"
Performance,"I just want to point out that this involves an extra memory fetch so it might affect performance, probably very negligibly and maybe the compiler is smart enough to elide the extra node call, but it is an extra operation nonetheless.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3074#issuecomment-1516299701:85,perform,performance,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3074#issuecomment-1516299701,1,['perform'],['performance']
Performance,"I looked at one of the errors and saw the message below. I think this means we need to restart the tests. ```; ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-8057/compiled/v1.6/Oceananigans/hU93i_xHskz.ji"": No such file or directory;  ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246:118,Load,LoadError,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246,2,['Load'],['LoadError']
Performance,"I mean, we can move the docs to the caltech cluster but I think they will slow down a lot. This is a bottleneck for us right now so I don't think we can afford to move them... Notice that the out of memory error doesn't occur when we are using the GPU. We only use the GPU for the one quick start example --- and for nothing else. If we want to ""solve"" this, we can just get rid of the quick start example and then return to the previous behavior where we set `CUDA_VISIBLE_DEVICES=-1` for the docs build. Another solution is to hide / prevent tartarus users from using GPU 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356553645:101,bottleneck,bottleneck,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356553645,1,['bottleneck'],['bottleneck']
Performance,"I mean, we could actually provide this implementation ourself with something like. ```julia; u = TimeseriesField(filepath, ""u""). u[i] # returns `Field` at save point `i`. u[i, a, b, c] # calls `getindex(file[""output/u""][string(i)], a, b, c)`; ``` . actually with `TimeseriesField` we could also automatically wrap data loaded from file into the appropriate field type as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/963#issuecomment-702105112:319,load,loaded,319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/963#issuecomment-702105112,1,['load'],['loaded']
Performance,"I noticed ""On the other hand, a Z-WENO formulation is *always* beneficial (also in case of a uniform mesh) with no major; decrease in performance."". Why don't we then change `zweno = true`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976013319:134,perform,performance,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976013319,1,['perform'],['performance']
Performance,I opened an issue about the `Int128`/`UInt128` segfault (https://github.com/JuliaGPU/CUDA.jl/issues/793) but will revisit this PR later to look into the performance regression.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809568648:153,perform,performance,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809568648,1,['perform'],['performance']
Performance,"I ran the `benchmark_incompressible_model.jl` script on the master branch (twice) and this branch (also twice), and ; actually see a tiny bit of a speedup, maybe only significant for larger CPU models though. Hard to say whether it's noise, it might be more due to other processes causing small variations in runtime. To me I don't think this PR slows down or speeds up the code, but it simplifies and improves the time stepping code so it should be merged. There's a few more memory allocations now (due to extra kernel launches) but this shouldn't affect performance. # System info. ```; Oceananigans v0.44.1; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23:17 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```. # Master branch; ```; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ Float32 │ 32 │ 5.399 ms │ 5.668 ms │ 5.758 ms │ 7.186 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float32 │ 64 │ 36.710 ms │ 37.583 ms │ 37.974 ms │ 41.678 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float32 │ 128 │ 312.780 ms │ 313.477 ms │ 313.622 ms │ 314.726 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float32 │ 256 │ 2.802 s │ 2.819 s │ 2.819 s │ 2.836 s │ 242.42 KiB │ 1876 │; │ CPU │ Float64 │ 32 │ 5.828 ms │ 6.049 ms │ 6.157 ms │ 7.044 ms │ 293.44 KiB │ 1876 │; │ CPU │ Float64 │ 64 │ 43.084 ms │ 43.619 ms │ 43.650 ms │ 44.363 ms │ 293.44 KiB │ 1876 │; │ CPU │ Float64 │ 128 │ 365.051 ms │ 365.317 ms │ 365.475 ms │ 366.288 ms │ 293.44 KiB │ 1876 │; │ CPU │ Float64 │ 256 │ 3.602 s │ 3.653 s │ 3.653 s │ 3.703 s │ 293.44 KiB │ 1876 │; │ GPU │ Float32 │ 32 │ 2.797 ms │ 2.870 ms ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-736692263:557,perform,performance,557,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-736692263,1,['perform'],['performance']
Performance,"I ran the advection scheme benchmarks and comparing with some older Julia 1.5 results it definitely is slower on the GPU. WENO5 used to only be ~3x slower than CenteredSecondOrder, but now it's 26x slower. All other advection schemes are just as fast as they used to be. Not slow enough to be CUDA scalar operations so maybe the GPU compiler changed in some way that kernels calling/using WENO5 are compiling into suboptimal machine code?. @maleadt might have some ideas/suggestions but maybe we just have to profile and find the new bottleneck?. ---. ```; Advection schemes relative performance (GPU); ┌───────────────┬────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Schemes │ slowdown │ memory │ allocs │; ├───────────────┼────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ CenteredFourthOrder │ 1.38356 │ 1.05911 │ 1.60067 │; │ GPU │ CenteredSecondOrder │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ UpwindBiasedFifthOrder │ 1.53145 │ 1.0868 │ 1.88203 │; │ GPU │ UpwindBiasedThirdOrder │ 1.30611 │ 1.04135 │ 1.42012 │; │ GPU │ WENO5 │ 26.1429 │ 4.68526 │ 38.4468 │; └───────────────┴────────────────────────┴──────────┴─────────┴─────────┘; ```. Compare with: https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868093699:534,bottleneck,bottleneck,534,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868093699,2,"['bottleneck', 'perform']","['bottleneck', 'performance']"
Performance,"I ran the benchmark again with triply periodic but it's still much slower so the issue might be deeper than the logic in `topologically_conditional_interpolation.jl`. ```; Advection schemes relative performance (GPU); ┌───────────────┬────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Schemes │ slowdown │ memory │ allocs │; ├───────────────┼────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ CenteredFourthOrder │ 1.50326 │ 1.06836 │ 1.69674 │; │ GPU │ CenteredSecondOrder │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ UpwindBiasedFifthOrder │ 1.69787 │ 1.09472 │ 1.96539 │; │ GPU │ UpwindBiasedThirdOrder │ 1.39899 │ 1.05598 │ 1.57057 │; │ GPU │ WENO5 │ 33.2728 │ 5.21273 │ 43.9286 │; └───────────────┴────────────────────────┴──────────┴─────────┴─────────┘; ```. ```diff; diff --git a/benchmark/benchmark_advection_schemes.jl b/benchmark/benchmark_advection_schemes.jl; index 81b083e1..e6ba8cd6 100644; --- a/benchmark/benchmark_advection_schemes.jl; +++ b/benchmark/benchmark_advection_schemes.jl; @@ -7,7 +7,8 @@ using Benchmarks; # Benchmark function. function benchmark_advection_scheme(Arch, Scheme); - grid = RegularRectilinearGrid(size=(192, 192, 192), extent=(1, 1, 1)); + topo = (Periodic, Periodic, Periodic); + grid = RegularRectilinearGrid(topology=topo, size=(192, 192, 192), extent=(1, 1, 1)); model = IncompressibleModel(architecture=Arch(), grid=grid, advection=Scheme()); ; time_step!(model, 1) # warmup; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868122855:199,perform,performance,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868122855,1,['perform'],['performance']
Performance,"I removed `show_axis=false` and it still produces an error, see below. . ```; fpoulin@pop-os:~/Software/Oceananigans.jl/validation/barotropic_gyre$ julia visualize_barotropic_gyre.jl ; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fulls",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:203,LOAD,LOADER,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985,6,"['LOAD', 'load']","['LOADER', 'load']"
Performance,"I saw there's a problem with making the documentation, see below. This doesn't seem directly relelvant to what was changed here though?. ```. ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33;   | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);   | @ Documenter.Builder /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Builder.jl:255;   | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);   | @ Documenter.Utilities.Selectors /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Utilities/Selectors.jl:170;   | [4] #2;   | @ /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Documenter.jl:266 [inlined];   | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);   | @ Base.Filesystem ./file.jl:106;   | [6] #makedocs#1;   | @ /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Documenter.jl:265 [inlined];   | [7] top-level scope;   | @ ~/builds/tartarus-3/clima/oceananigans/docs/make.jl:154;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-3/clima/oceananigans/docs/make.jl:154;   | 🚨 Error: The command exited with status 1;   | user command error: exit status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119854495:149,Load,LoadError,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119854495,1,['Load'],['LoadError']
Performance,"I see that one of the errors is `UndefVarError: device_event not defined`, which I suppose means we need to load it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890011382:108,load,load,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890011382,1,['load'],['load']
Performance,"I see the error you got, its. ```julia; ERROR: LoadError: MethodError: no method matching AdvectiveForcing(::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true}; w=-1); Closest candidates are:; AdvectiveForcing(::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; AdvectiveForcing(::Any, ::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; AdvectiveForcing(::Any, ::Any, ::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; ```. This error means that we do indeed have the name `AdvectiveForcing`, but that the function signature is wrong. The reason here is a bug in the source code (missing semicolon: https://github.com/CliMA/Oceananigans.jl/pull/2389/commits/b30ce7ab846c713663949c3bb6ee8d1e2ec740b0).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082002537:47,Load,LoadError,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082002537,1,['Load'],['LoadError']
Performance,"I share here a double drake experiment that makes full use of this PR ; #### Grid setup; - latitude longitude grid from 75 S to 75 N; - 1/3 of a degree in the horizontal (1080 points in longitude, 450 in latitude); - 150 exponentially stretched vertical levels for a 3km deep ocean; - double drake bathymetry (https://doi.org/10.1175/2009JCLI3197.1); #### Top BC: ; - temperature: restoring to reference profile (cosine shape); - salinity: prescribed latitudinally dependent surface flux; - zonal velocity: prescribed latitudinally dependent wind stress; #### Bottom BC:; - velocities: linear bottom drag with a drag coefficient of 0.003 ms⁻¹; #### Initial conditions; - zero velocities; - exponentially stratified temperature with SST equal to the reference temperature; - constant salinity; #### Model setup; - linear equation of state; - Richardson-based diffusivity for BL mixing ; - vertical background viscosity and diffusivity of 5e-4 and 3e-5, respectively; - vector invariant momentum advection with WENO for vorticity and divergence flux as well as vertical transport (no horizontal viscosity); - WENO for tracer advection (no horizontal diffusivity); - Split explicit free surface using an averaging shape function and a CFL of 0.7 (23 substeps per time step); #### Simulation setup; - time step of 10 minutes; - ran on 2 MPI processes with CUDA-aware MPI; - performs about 10 simulated years per day. On the left, there is the free surface evolution, on the right the surface vertical vorticity (evolved for 9 years). https://user-images.githubusercontent.com/33547697/219039209-e99ad100-2730-4805-bf57-c3b438f64537.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431366185:1370,perform,performs,1370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431366185,1,['perform'],['performs']
Performance,I think @glwagner was able to run the 2D turbulence example with the `CenteredFourthOrder` advection scheme but we never performed a convergence test. It's possible a smaller time step is needed. @glwagner also suggested trying `AnisotropicBiharmonicDiffusivity`. Side note: Might be good to add two new convergence tests modified from; https://github.com/CliMA/Oceananigans.jl/blob/master/verification/convergence_tests/one_dimensional_gaussian_advection_diffusion.jl; https://github.com/CliMA/Oceananigans.jl/blob/master/verification/convergence_tests/one_dimensional_cosine_advection_diffusion.jl; to test advection only with `CenteredFourthOrder` to ensure we see fourth-order convergence. Advection-diffusion tests should only show 2nd order convergence.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/925#issuecomment-690411199:121,perform,performed,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/925#issuecomment-690411199,1,['perform'],['performed']
Performance,"I think @tomchor is hitting on the right solution: we should separate ""output for analysis"" from ""output for checkpointing"", if possible. Typically we need output for analysis more frequently than output for checkpointing, and we don't require things like the tendency fields for analysis. This motivates creating multiple output writers that are dedicated to their specific tasks. . On the possibility of a NetCDF checkpointer: the first checkpointer design that utilized `restore_from_checkpoint` attempted to serialize as much of a model's data structures as possible. This requirement prevented us from using NetCDF and motivated using JLD2 (there are a few other data formats that can serialize, but JLD2 is fast, simple, and HDF5 compatible, which means it can be loaded from python with `h5py`). However, we now support a simpler paradigm whereby the original run script needs to be modified with `run!(simulation, pickup=true)` in order to ""pick up"" a simulation from a checkpoint. With this simpler design we require only all the prognostic fields and tendencies (for AB2) in the checkpointer file and we could in principle support NetCDF. This has the downside that it would require us to maintain more code. If you do need to inspect, plot, or analyze data in JLD2 files, check out the [JLD2 documentation](https://juliaio.github.io/JLD2.jl/dev/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924:770,load,loaded,770,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924,1,['load'],['loaded']
Performance,I think I'm happy with the finite volume operators in this PR. Happy to make changes based on feedback so we have versatile and flexible operators. In the next PR I will fully integrate them with the code and make sure they are correct and performant. It will also show if I missed any operators.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-546648773:240,perform,performant,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-546648773,1,['perform'],['performant']
Performance,"I think high performance at 25 km resolution will prove difficult also because we are effectively dividing our kernel size by 1/6 (unless we figure out how to coalesce kernels across panels). On a large GPU this will lead to performance degredation at 25 km resolution, because even a single-panel kernel covering the whole globe at 25 km barely saturates one GPU. Recovering that performance for multi-region simulations may be difficult, especially in the face of the added complexity of distribution across multiple GPUs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719393187:13,perform,performance,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719393187,3,['perform'],['performance']
Performance,"I think it's a plotting issue. We are filling up the immersed boundaries with NaN and, apparently, we cannot plot NaNs anymore? The error says:; ```julia; ERROR: LoadError: On worker 2:;   | Looking up a non-finite or NaN value in a colormap is undefined.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3836#issuecomment-2407601775:162,Load,LoadError,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3836#issuecomment-2407601775,1,['Load'],['LoadError']
