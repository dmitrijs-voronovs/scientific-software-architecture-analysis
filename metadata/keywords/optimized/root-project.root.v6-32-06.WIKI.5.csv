quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Availability,". TEveProjected. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEveProjected. class TEveProjected. Abstract base class for classes that hold results of a non-linear; projection transformation. It is assumed that all classes deriving from TEveProjected are also; derived from TEveElement. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TEveProjected(); static TClass*Class(); Float_tGetDepth() const; TEveProjectionManager*GetManager() const; TEveProjectable*GetProjectable() const; virtual TEveElement*GetProjectedAsElement(); virtual TClass*IsA() const; virtual voidSetDepth(Float_t d); virtual voidSetProjection(TEveProjectionManager* mng, TEveProjectable* model); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidUnRefProjectable(TEveProjectable* assumed_parent, bool notifyParent = true); virtual voidUpdateProjection(). protected:. voidSetDepthCommon(Float_t d, TEveElement* el, Float_t* bbox); virtual voidSetDepthLocal(Float_t d). private:. TEveProjected&operator=(const TEveProjected&). Data Members; protected:. Float_tfDepthz coordinate; TEveProjectionManager*fManagermanager; TEveProjectable*fProjectablelink to original object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TEveProjected(); Destructor.; If fProjectable is non-null, *this is removed from its list of; projected replicas. TEveElement* GetProjectedAsElement(); Returns this projected dynamic-casted to TEveElement.; This is needed as class TEveProjected is used as secondary; inheritance. void SetProjection(TEveProjectionManager* mng, TEveProjectable* model); Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveProjected.html:608,avail,available,608,root/html534/TEveProjected.html,https://root.cern,https://root.cern/root/html534/TEveProjected.html,1,['avail'],['available']
Availability,". TEveProjection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEveProjection. class TEveProjection. Base-class for non-linear projections. Enables to define an external center of distortion and a scale to; fixate a bounding box of a projected point. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TEveProjection(); virtual Bool_tAcceptSegment(TEveVector&, TEveVector&, Float_t) const; voidAddPreScaleEntry(Int_t coord, Float_t max_val, Float_t scale); virtual voidBisectBreakPoint(TEveVector& vL, TEveVector& vR, Float_t eps_sqr = 1e-10f); voidChangePreScaleEntry(Int_t coord, Int_t entry, Float_t new_scale); static TClass*Class(); voidClearPreScales(); Float_tGetDistortion() const; Float_tGetFixR() const; Float_tGetFixZ() const; TEveProjection::EGeoMode_eGetGeoMode() const; Float_tGetLimit(Int_t i, Bool_t pos); Float_tGetMaxTrackStep() const; const Char_t*GetName() const; Float_tGetPastFixRFac() const; Float_tGetPastFixZFac() const; virtual Float_t*GetProjectedCenter(); virtual Float_tGetScreenVal(Int_t ax, Float_t value); TEveProjection::EPType_eGetType() const; Bool_tGetUsePreScale() const; virtual Float_tGetValForScreenPos(Int_t ax, Float_t value); virtual Bool_tHasSeveralSubSpaces() const; virtual Bool_tIs2D() const; virtual Bool_tIs3D() const; virtual TClass*IsA() const; virtual Bool_tIsOnSubSpaceBoundrary(const TEveVector&) const; TEveProjection&operator=(const TEveProjection&); voidPreScalePoint(Float_t& x, Float_t& y); voidPreScalePoint(Float_t& x, Float_t& y, Float_t& z); virtual voidProjectPoint(Float_t& x, Float_t& y, Float_t& z, Float_t d, TEveProjection::EPProc_e p = kPP_Full); voidProjectPointdv(Double_t* v, Float_t d); voidProjectPointdv(const TEv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveProjection.html:572,avail,available,572,root/html528/TEveProjection.html,https://root.cern,https://root.cern/root/html528/TEveProjection.html,1,['avail'],['available']
Availability,". TEveProjection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEveProjection. class TEveProjection. Base-class for non-linear projections. Enables to define an external center of distortion and a scale to; fixate a bounding box of a projected point. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TEveProjection(); virtual Bool_tAcceptSegment(TEveVector&, TEveVector&, Float_t) const; voidAddPreScaleEntry(Int_t coord, Float_t max_val, Float_t scale); virtual voidBisectBreakPoint(TEveVector& vL, TEveVector& vR, Float_t eps_sqr); virtual voidBisectBreakPoint(TEveVector& vL, TEveVector& vR, Bool_t project_result = kFALSE, Float_t depth = 0); voidChangePreScaleEntry(Int_t coord, Int_t entry, Float_t new_scale); static TClass*Class(); voidClearPreScales(); Bool_tGetDisplaceOrigin() const; Float_tGetDistortion() const; Float_tGetFixR() const; Float_tGetFixZ() const; TEveProjection::EGeoMode_eGetGeoMode() const; Float_tGetLimit(Int_t i, Bool_t pos); Float_tGetMaxTrackStep() const; const Char_t*GetName() const; TEveVectorGetOrthogonalCenter(int idx, TEveVector& out); Float_tGetPastFixRFac() const; Float_tGetPastFixZFac() const; virtual Float_t*GetProjectedCenter(); virtual Float_tGetScreenVal(Int_t ax, Float_t value); Float_tGetScreenVal(Int_t i, Float_t x, TEveVector& dirVec, TEveVector& oCenter); TEveProjection::EPType_eGetType() const; Bool_tGetUsePreScale() const; virtual Float_tGetValForScreenPos(Int_t ax, Float_t value); virtual Bool_tHasSeveralSubSpaces() const; virtual Bool_tIs2D() const; virtual Bool_tIs3D() const; virtual TClass*IsA() const; virtual Bool_tIsOnSubSpaceBoundrary(const TEveVector&) const; TEveProjection&operator=(const TEveProjection&); voidPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveProjection.html:572,avail,available,572,root/html530/TEveProjection.html,https://root.cern,https://root.cern/root/html530/TEveProjection.html,5,['avail'],['available']
Availability,". TEveShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEveShape. class TEveShape: public TEveElementList, public TAtt3D, public TAttBBox. Abstract base-class for 2D/3D shapes.; It provides:; - fill color / transparency, accessible via Get/SetMainColor/Transparency;; - frame line color / width;; - flag if frame should be drawn;; - flag specifying whether frame or whole shape should be emphasised for; highlight. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TEveShape(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTEveElementList::AcceptElement(TEveElement* el); virtual voidTEveElement::AddElement(TEveElement* el); virtual TGListTreeItem*TEveElement::AddIntoListTree(TGListTree* ltree, TGListTreeItem* parent_lti); virtual TGListTreeItem*TEveElement::AddIntoListTree(TGListTree* ltree, TEveElement* parent); virtual TGListTreeItem*TEveElement::AddIntoListTrees(TEveElement* parent); virtual voidTEveElement::AddParent(TEveElement* re); virtual voidTEveProjectable::AddProjected(TEveProjected* p); virtual voidTEveProjectable::AddProjectedsToSet(set<TEveElement*>& set); virtual voidTEveElement::AddStamp(UChar_t bits); virtual voidTEveElement::Annihilate(); virtual voidTEveElement::AnnihilateElements(); virtual voidTEveProjectable::AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); Float_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveShape.html:739,avail,available,739,root/html528/TEveShape.html,https://root.cern,https://root.cern/root/html528/TEveShape.html,6,['avail'],['available']
Availability,". TEveWindow. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEveWindow. class TEveWindow: public TEveElementList. Abstract base-class for representing eve-windows.; Sub-classes define a particular GUI frame that gets show; in the window. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TEveWindow(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTEveElementList::AcceptElement(TEveElement* el); virtual voidTEveElement::AddElement(TEveElement* el); virtual TGListTreeItem*TEveElement::AddIntoListTree(TGListTree* ltree, TGListTreeItem* parent_lti); virtual TGListTreeItem*TEveElement::AddIntoListTree(TGListTree* ltree, TEveElement* parent); virtual TGListTreeItem*TEveElement::AddIntoListTrees(TEveElement* parent); virtual voidTEveElement::AddParent(TEveElement* re); virtual voidTEveProjectable::AddProjected(TEveProjected* p); virtual voidTEveProjectable::AddProjectedsToSet(set<TEveElement*>& set); virtual voidTEveElement::AddStamp(UChar_t bits); virtual voidTEveElement::Annihilate(); virtual voidTEveElement::AnnihilateElements(); virtual voidTEveProjectable::AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveWindow.html:558,avail,available,558,root/html530/TEveWindow.html,https://root.cern,https://root.cern/root/html530/TEveWindow.html,5,['avail'],['available']
Availability,". TEveWindow. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEveWindow. class TEveWindow: public TEveElementList. Abstract base-class for representing eve-windows.; Sub-classes define a particular GUI frame that gets show; in the window. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TEveWindow(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTEveElementList::AcceptElement(TEveElement* el); virtual voidTEveElement::AddElement(TEveElement* el); virtual TGListTreeItem*TEveElement::AddIntoListTree(TGListTree* ltree, TGListTreeItem* parent_lti); virtual TGListTreeItem*TEveElement::AddIntoListTree(TGListTree* ltree, TEveElement* parent); virtual TGListTreeItem*TEveElement::AddIntoListTrees(TEveElement* parent); virtual voidTEveElement::AddParent(TEveElement* re); virtual voidTEveProjectable::AddProjected(TEveProjected* p); virtual voidTEveProjectable::AddProjectedsToSet(set<TEveElement*>& set); virtual voidTEveElement::AddStamp(UChar_t bits); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual Bool_tCanMakeNewSlots() const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveWindow.html:558,avail,available,558,root/html528/TEveWindow.html,https://root.cern,https://root.cern/root/html528/TEveWindow.html,1,['avail'],['available']
Availability,". TEventIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TEventIter. class TEventIter: public TObject. TEventIter. Special iterator class used in TProofPlayer to iterate over events; or objects in the packets. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TEventIter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TEventIter*Create(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetCacheSize(); virtual Option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEventIter.html:540,avail,available,540,root/html528/TEventIter.html,https://root.cern,https://root.cern/root/html528/TEventIter.html,6,['avail'],['available']
Availability,". TF1 * GetFunction(const char* name) const; -*-*-*Return pointer to function with name*-*-*-*-*-*-*-*-*-*-*-*-*. Functions such as TH1::Fit store the fitted function in the list of; functions of this histogram. Double_t GetBinError(Int_t bin) const; -*-*-*-*-*Return value of error associated to bin number bin*-*-*-*-*. if the sum of squares of weights has been defined (via Sumw2),; this function returns the sqrt(sum of w2).; otherwise it returns the sqrt(contents) for this bin. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Double_t GetBinErrorLow(Int_t bin) const; -*-*-*-*-*Return lower error associated to bin number bin*-*-*-*-*. The error will depend on the statistic option used will return; the binContent - lower interval value. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Double_t GetBinErrorUp(Int_t bin) const; -*-*-*-*-*Return upper error associated to bin number bin*-*-*-*-*. The error will depend on the statistic option used will return; the binContent - upper interval value. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Double_t GetBinError(Int_t binx, Int_t biny) const; -*-*-*-*-*Return error of bin number binx, biny. NB: Function to be called for 2-D histograms only. Double_t GetBinError(Int_t binx, Int_t biny, Int_t binz) const; -*-*-*-*-*Return error of bin number binx,biny,binz. NB: Function to be called for 3-D histograms only. Double_t GetCellContent(Int_t binx, Int_t biny) const; -*-*-*-*-*Return content of bin number binx, biny. NB: Function to be called for 2-D histograms only. Double_t GetCellError(Int_t binx, Int_t biny) const; -*-*-*-*-*Return error of bin number binx, biny. NB: Function to be called for 2-D histograms only. Double_t GetBinCenter(Int_t bin) const; return bin center for 1D historam; Better to use h1.GetXaxis().GetBinCenter(bin). Double_t GetBinLowEdge(Int_t bin) const; return bin lower edge for 1D historam; Better to use h1.GetXaxis().GetBinLowEdge(bi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:127232,error,error,127232,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,1,['error'],['error']
Availability,". TF1Convolution. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TF1Convolution. class TF1Convolution. (f*g)(t) = int(f(x)g(x-t)dx) *. class wrapping convolution of two function : evaluation of TF1(t) * TF1(x-t). The convolution is performed by default using FFTW if it is available .; One can pass optionally the range of the convolution (by default the first function range is used).; Note that when using Discrete Fouriere Transform (as FFTW), it is a circular transform, so the functions should be; approximatly zero at the end of the range. If they are significantly different than zero on one side (e.g. the left side); a spill over will occur on the other side (e.g right side).; If no function range is given by default the function1 range + 10% is used; One shoud use also a not too small number of points for the DFT (a minimum of 1000). By default 10000 points are used . Function Members (Methods); public:. ~TF1Convolution(); Int_tGetNpar() const; const char*GetParName(Int_t ipar) const; Double_tGetXmax() const; Double_tGetXmin() const; Double_toperator()(Double_t* t, Double_t* p); TF1Convolution&operator=(TF1Convolution&&); TF1Convolution&operator=(const TF1Convolution&); voidSetExtraRange(Double_t percentage); voidSetNofPointsFFT(Int_t n); voidSetNumConv(Bool_t flag = true); voidSetParameters(Double_t* p); voidSetParameters(Double_t p0, Double_t p1, Double_t p2 = 0., Double_t p3 = 0., Double_t p4 = 0., Double_t p5 = 0., Double_t p6 = 0., Double_t p7 = 0.); voidSetRange(Double_t a, Double_t b); TF1Convolution(TF1Convolution&&); TF1Convolution(const TF1Convolution&); TF1Convolution(TF1* function1, TF1* function2, Bool_t useFFT = true); TF1Convolution(TString formula, Double_t xmin = 1., Double_t xmax = 0., Bool_t useFFT = true); TF1Convolution(TF1* function1, TF1* function2, Double_t xmi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF1Convolution.html:457,avail,available,457,root/html604/TF1Convolution.html,https://root.cern,https://root.cern/root/html604/TF1Convolution.html,1,['avail'],['available']
Availability,". TFFTComplexReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplexReal. class TFFTComplexReal: public TVirtualFFT. TFFTComplexReal. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes the inverse of the real-to-complex transforms (class TFFTRealComplex); taking complex input (storing the non-redundant half of a logically Hermitian array); to real output (see FFTW manual for more details). How to use it:; 1) Create an instance of TFFTComplexReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointReal() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. 3) In Complex to Real transform the input array is destroyed. It cannot then; be retrieved when using the Get's methods. Function Members (Methods); public:. TFFTComplexReal(); TFFTComplexReal(const TFFTComplexReal&); TFFTComplexReal(Int_t n, Bool_t inPlace); TFFTComplexReal(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTComplexReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFFTComplexReal.html:596,redundant,redundant,596,root/html528/TFFTComplexReal.html,https://root.cern,https://root.cern/root/html528/TFFTComplexReal.html,4,['redundant'],['redundant']
Availability,". TFFTComplexReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplexReal. class TFFTComplexReal: public TVirtualFFT. TFFTComplexReal. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes the inverse of the real-to-complex transforms (class TFFTRealComplex); taking complex input (storing the non-redundant half of a logically Hermitian array); to real output (see FFTW manual for more details). How to use it:; 1) Create an instance of TFFTComplexReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointReal() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. 3) In Complex to Real transform the input array is destroyed. It cannot then; be retrieved when using the Get's methods. Function Members (Methods); public:. virtual~TFFTComplexReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFFTComplexReal.html:596,redundant,redundant,596,root/html602/TFFTComplexReal.html,https://root.cern,https://root.cern/root/html602/TFFTComplexReal.html,2,['redundant'],['redundant']
Availability,". TFoamIntegrand. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoamIntegrand. class TFoamIntegrand: public TObject. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TFoamIntegrand(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFoamIntegrand.html:437,avail,available,437,root/html528/TFoamIntegrand.html,https://root.cern,https://root.cern/root/html528/TFoamIntegrand.html,6,['avail'],['available']
Availability,". TFumili. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FUMILI; » TFumili. class TFumili: public TVirtualFitter. FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. ; FUMILI minimization package; FUMILI is used to minimize Chi-square function or to search maximum of; likelihood function.; Experimentally measured values $F_i$ are fitted with theoretical; functions $f_i({\vec x}_i,\vec\theta\,\,)$, where ${\vec x}_i$ are; coordinates, and $\vec\theta$ -- vector of parameters.; For better convergence Chi-square function has to be the following form; $$; {\chi^2\over2}={1\over2}\sum^n_{i=1}\left(f_i(\vec; x_i,\vec\theta\,\,)-F_i\over\sigma_i\right)^2 \eqno(1); $$; where $\sigma_i$ are errors of measured function.; The minimum condition is; $$; {\partial\chi^2\over\partial\theta_i}=\sum^n_{j=1}{1\over\sigma^2_j}\cdot; {\partial f_j\over\partial\theta_i}\left[f_j(\vec; x_j,\vec\theta\,\,)-F_j\right]=0,\qquad i=1\ldots m\eqno(2); $$; where m is the quantity of parameters.; Expanding left part of (2) over parameter increments and; retaining only linear terms one gets; $$; \left(\partial\chi^2\over\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k\left(\partial^2\chi^2\over\partial\theta_i\partial\theta_k\right)_{; \vec\theta={\vec\theta}^0}\cdot(\theta_k-\theta_k^0); = 0\eqno(3); $$; Here ${\vec\theta}_0$ is some initial value of parameters. In general; case:; $$; {\partial^2\chi^2\over\partial\theta_i\partial\theta_k}=; \sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k} +; \sum^n_{j=1}{(f_j - F_j)\over\sigma^2_j}\cdot; {\partial^2f_j\over\partial\theta_i\partial\theta_k}\eqno(4); $$; In FUMILI algorithm for second derivatives of Chi-square approximate; expressi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFumili.html:971,error,errors,971,root/html528/TFumili.html,https://root.cern,https://root.cern/root/html528/TFumili.html,6,['error'],['errors']
Availability,". TG16ColorSelector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TG16ColorSelector. class TG16ColorSelector: public TGCompositeFrame. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. TG16ColorSelector(const TGWindow* p = 0); virtual~TG16ColorSelector(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TG16ColorSelector.html:784,down,down,784,root/html528/TG16ColorSelector.html,https://root.cern,https://root.cern/root/html528/TG16ColorSelector.html,4,['down'],['down']
Availability,". TG16ColorSelector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TG16ColorSelector. class TG16ColorSelector: public TGCompositeFrame. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. virtual~TG16ColorSelector(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newnam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TG16ColorSelector.html:784,down,down,784,root/html602/TG16ColorSelector.html,https://root.cern,https://root.cern/root/html602/TG16ColorSelector.html,2,['down'],['down']
Availability,". TGColorFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColorFrame. class TGColorFrame: public TGFrame. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. TGColorFrame(const TGWindow* p = 0, Pixel_t c = 0, Int_t n = 1); virtual~TGColorFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGColorFrame.html:760,down,down,760,root/html528/TGColorFrame.html,https://root.cern,https://root.cern/root/html528/TGColorFrame.html,4,['down'],['down']
Availability,". TGColorFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColorFrame. class TGColorFrame: public TGFrame. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. virtual~TGColorFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGColorFrame.html:760,down,down,760,root/html602/TGColorFrame.html,https://root.cern,https://root.cern/root/html602/TGColorFrame.html,2,['down'],['down']
Availability,". TGColorPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColorPopup. class TGColorPopup: public TGCompositeFrame. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. TGColorPopup(const TGWindow* p = 0, const TGWindow* m = 0, Pixel_t color = 0); virtual~TGColorPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGColorPopup.html:769,down,down,769,root/html528/TGColorPopup.html,https://root.cern,https://root.cern/root/html528/TGColorPopup.html,4,['down'],['down']
Availability,". TGColorPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColorPopup. class TGColorPopup: public TGCompositeFrame. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. virtual~TGColorPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGColorPopup.html:769,down,down,769,root/html602/TGColorPopup.html,https://root.cern,https://root.cern/root/html602/TGColorPopup.html,2,['down'],['down']
Availability,". TGColorSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColorSelect. class TGColorSelect: public TGCheckButton. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. TGColorSelect(const TGWindow* p = 0, Pixel_t color = 0, Int_t id = -1); virtual~TGColorSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidAlphaColorSelected(ULong_t colptr = 0)SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGColorSelect.html:769,down,down,769,root/html534/TGColorSelect.html,https://root.cern,https://root.cern/root/html534/TGColorSelect.html,1,['down'],['down']
Availability,". TGColorSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColorSelect. class TGColorSelect: public TGCheckButton. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. TGColorSelect(const TGWindow* p = 0, Pixel_t color = 0, Int_t id = -1); virtual~TGColorSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGColorSelect.html:769,down,down,769,root/html528/TGColorSelect.html,https://root.cern,https://root.cern/root/html528/TGColorSelect.html,3,['down'],['down']
Availability,". TGColorSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColorSelect. class TGColorSelect: public TGCheckButton. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. virtual~TGColorSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidAlphaColorSelected(ULong_t colptr = 0)SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGColorSelect.html:769,down,down,769,root/html602/TGColorSelect.html,https://root.cern,https://root.cern/root/html602/TGColorSelect.html,2,['down'],['down']
Availability,". TGColumnLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColumnLayout. class TGColumnLayout: public TGRowLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGColumnLayout(const TGColumnLayout&); TGColumnLayout(TGCompositeFrame* main, Int_t s = 0); ~TGColumnLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGColumnLayout.html:787,down,downward,787,root/html528/TGColumnLayout.html,https://root.cern,https://root.cern/root/html528/TGColumnLayout.html,4,['down'],['downward']
Availability,". TGColumnLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColumnLayout. class TGColumnLayout: public TGRowLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. virtual~TGColumnLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGColumnLayout.html:787,down,downward,787,root/html602/TGColumnLayout.html,https://root.cern,https://root.cern/root/html602/TGColumnLayout.html,2,['down'],['downward']
Availability,". TGComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGComboBox. class TGComboBox: public TGCompositeFrame, public TGWidget. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); TGComboBox(const TGWindow* p, const char* text, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); virtual~TGComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddEntry(TGString* s, Int_t id); virtual voidAddEntry(const char* s, Int_t id); virtual voidAddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGComboBox.html:377,down,down,377,root/html528/TGComboBox.html,https://root.cern,https://root.cern/root/html528/TGComboBox.html,8,['down'],['down']
Availability,". TGComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGComboBox. class TGComboBox: public TGCompositeFrame, public TGWidget. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. virtual~TGComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddEntry(TGString* s, Int_t id); virtual voidAddEntry(const char* s, Int_t id); virtual voidAddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGComboBox.html:377,down,down,377,root/html602/TGComboBox.html,https://root.cern,https://root.cern/root/html602/TGComboBox.html,4,['down'],['down']
Availability,". TGComboBoxPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGComboBoxPopup. class TGComboBoxPopup: public TGCompositeFrame. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGComboBoxPopup(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kVerticalFrame, Pixel_t back = GetWhitePixel()); ~TGComboBoxPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGComboBoxPopup.html:375,down,down,375,root/html528/TGComboBoxPopup.html,https://root.cern,https://root.cern/root/html528/TGComboBoxPopup.html,8,['down'],['down']
Availability,". TGComboBoxPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGComboBoxPopup. class TGComboBoxPopup: public TGCompositeFrame. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. virtual~TGComboBoxPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGComboBoxPopup.html:375,down,down,375,root/html602/TGComboBoxPopup.html,https://root.cern,https://root.cern/root/html602/TGComboBoxPopup.html,4,['down'],['down']
Availability,". TGFontDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFontDialog. class TGFontDialog: public TGTransientFrame. TGFontDialog. Font selection dialog, allowing to select one in the list of available fonts; in the system. Function Members (Methods); public:. TGFontDialog(const TGWindow* parent = 0, const TGWindow* t = 0, TGFontDialog::FontProp_t* fontProp = 0, const TString& sample = """", char** fontList = 0, Bool_t wait = kTRUE); virtual~TGFontDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAlignSelected(Int_t a)SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidColorSelected(Pixel_t c)SIGNAL ; virtual Int_tTObject::Compare(const TObject* obj) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGFontDialog.html:379,avail,available,379,root/html528/TGFontDialog.html,https://root.cern,https://root.cern/root/html528/TGFontDialog.html,4,['avail'],['available']
Availability,". TGFontDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFontDialog. class TGFontDialog: public TGTransientFrame. TGFontDialog. Font selection dialog, allowing to select one in the list of available fonts; in the system. Function Members (Methods); public:. virtual~TGFontDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAlignSelected(Int_t a)SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidColorSelected(Pixel_t c)SIGNAL ; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGFontDialog.html:379,avail,available,379,root/html602/TGFontDialog.html,https://root.cern,https://root.cern/root/html602/TGFontDialog.html,2,['avail'],['available']
Availability,". TGFontDialog::FontProp_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFontDialog::FontProp_t. class TGFontDialog::FontProp_t. TGFontDialog. Font selection dialog, allowing to select one in the list of available fonts; in the system. Function Members (Methods); public:. ~FontProp_t(); TGFontDialog::FontProp_tFontProp_t(); TGFontDialog::FontProp_tFontProp_t(TGFontDialog::FontProp_t&&); TGFontDialog::FontProp_tFontProp_t(const TGFontDialog::FontProp_t&); TGFontDialog::FontProp_t&operator=(TGFontDialog::FontProp_t&&); TGFontDialog::FontProp_t&operator=(const TGFontDialog::FontProp_t&). Data Members; public:. UInt_tfAligntext alignment; Bool_tfBoldbold flag; Pixel_tfColortext color; Bool_tfItalicitalic flag; TStringfNamefont name; Int_tfSizefont size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: Bertrand Bellenot + Fons Rademakers 23/04/03 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGFontDialog__FontProp_t.html:390,avail,available,390,root/html602/TGFontDialog__FontProp_t.html,https://root.cern,https://root.cern/root/html602/TGFontDialog__FontProp_t.html,1,['avail'],['available']
Availability,". TGFontDialog::FontProp_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFontDialog::FontProp_t. class TGFontDialog::FontProp_t. TGFontDialog. Font selection dialog, allowing to select one in the list of available fonts; in the system. Function Members (Methods); public:. ~FontProp_t(); TGFontDialog::FontProp_tFontProp_t(); TGFontDialog::FontProp_tFontProp_t(TGFontDialog::FontProp_t&&); TGFontDialog::FontProp_tFontProp_t(const TGFontDialog::FontProp_t&); TGFontDialog::FontProp_t&operator=(TGFontDialog::FontProp_t&&); TGFontDialog::FontProp_t&operator=(const TGFontDialog::FontProp_t&). Data Members; public:. UInt_tfAligntext alignment; Bool_tfBoldbold flag; Pixel_tfColortext color; Bool_tfItalicitalic flag; TStringfNamefont name; Int_tfSizefont size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: Bertrand Bellenot + Fons Rademakers 23/04/03 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGFontDialog__FontProp_t.html:390,avail,available,390,root/html604/TGFontDialog__FontProp_t.html,https://root.cern,https://root.cern/root/html604/TGFontDialog__FontProp_t.html,1,['avail'],['available']
Availability,". TGFontTypeComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFontTypeComboBox. class TGFontTypeComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGFontTypeComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t bask = GetWhitePixel()); virtual~TGFontTypeComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGFontTypeComboBox.html:378,down,down,378,root/html528/TGFontTypeComboBox.html,https://root.cern,https://root.cern/root/html528/TGFontTypeComboBox.html,8,['down'],['down']
Availability,". TGFontTypeComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFontTypeComboBox. class TGFontTypeComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. virtual~TGFontTypeComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGFontTypeComboBox.html:378,down,down,378,root/html602/TGFontTypeComboBox.html,https://root.cern,https://root.cern/root/html602/TGFontTypeComboBox.html,4,['down'],['down']
Availability,". TGFrameElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGFrameElement. class TGFrameElement: public TObject. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. virtual~TGFrameElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGFrameElement.html:783,down,downward,783,root/html602/TGFrameElement.html,https://root.cern,https://root.cern/root/html602/TGFrameElement.html,2,['down'],['downward']
Availability,". TGGotoDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGGotoDialog. class TGGotoDialog: public TGTransientFrame. TGTextEditDialogs. This file defines several dialogs that are used by the TGTextEdit; widget via its associated context popup menu.; The following dialogs are available: TGSearchDialog, TGGotoDialog; and TGPrintDialog. Function Members (Methods); public:. TGGotoDialog(const TGWindow* p = 0, const TGWindow* main = 0, UInt_t w = 1, UInt_t h = 1, Long_t* ret_code = 0, UInt_t options = kVerticalFrame); virtual~TGGotoDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGGotoDialog.html:463,avail,available,463,root/html528/TGGotoDialog.html,https://root.cern,https://root.cern/root/html528/TGGotoDialog.html,4,['avail'],['available']
Availability,". TGGotoDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGGotoDialog. class TGGotoDialog: public TGTransientFrame. TGTextEditDialogs. This file defines several dialogs that are used by the TGTextEdit; widget via its associated context popup menu.; The following dialogs are available: TGSearchDialog, TGGotoDialog; and TGPrintDialog. Function Members (Methods); public:. virtual~TGGotoDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGGotoDialog.html:463,avail,available,463,root/html602/TGGotoDialog.html,https://root.cern,https://root.cern/root/html602/TGGotoDialog.html,2,['avail'],['available']
Availability,". TGHorizontalLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHorizontalLayout. class TGHorizontalLayout: public TGVerticalLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGHorizontalLayout(TGCompositeFrame* main); TGHorizontalLayout(const TGHorizontalLayout&); ~TGHorizontalLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGHorizontalLayout.html:804,down,downward,804,root/html528/TGHorizontalLayout.html,https://root.cern,https://root.cern/root/html528/TGHorizontalLayout.html,4,['down'],['downward']
Availability,". TGHorizontalLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGHorizontalLayout. class TGHorizontalLayout: public TGVerticalLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. virtual~TGHorizontalLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMEN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGHorizontalLayout.html:804,down,downward,804,root/html602/TGHorizontalLayout.html,https://root.cern,https://root.cern/root/html602/TGHorizontalLayout.html,2,['down'],['downward']
Availability,". TGLClip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLClip. class TGLClip: public TGLPhysicalShape. TGLClip. Abstract clipping shape - derives from TGLPhysicalShape; Adds clip mode (inside/outside) and pure virtual method to; approximate shape as set of planes. This plane set is used to perform; interactive clipping using OpenGL clip planes. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLClip(); voidTGLPhysicalShape::AddReference(TGLPShapeRef* ref); const TGLBoundingBox&TGLPhysicalShape::BoundingBox() const; virtual voidTGLPhysicalShape::CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*TGLPhysicalShape::Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*TGLPhysicalShape::GetLogical() const; TGLPhysicalShape::EManipTGLPhysicalShape::GetManip() const; TGLClip::EModeGetMode() const; const TGLPhysicalShape*TGLPhysicalShape::GetNextPhysical() const; TGLVector3TGLPhysicalShape::GetScale() const; UChar_tTGLPhysicalShape::GetSelected() const; TGLVertex3TGLPhysicalShape::GetTranslation() const; UInt_tTGLPhysicalShape::ID() const; voidIncTimeStamp(); voidInvalidate(); voidTGLPhysicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; Bool_tTGLPhysicalShape::IsInvisible() const; Bool_tTGLPhysicalShape::IsModified() const; Bool_tTGLPhysicalShape::IsSelected() const; Bool_tTGLPhysicalShape::IsTransparent() const; Bool_tIsValid() const; virtual voidModified(); TGLClip&operator=(const TGLClip&); virtual voidPlaneSet(TGLPlaneSet_t& set) const; virtual voidTGLPhysicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLClip.html:669,avail,available,669,root/html602/TGLClip.html,https://root.cern,https://root.cern/root/html602/TGLClip.html,2,['avail'],['available']
Availability,". TGLClip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLClip. class TGLClip: public TGLPhysicalShape. TGLClip. Abstract clipping shape - derives from TGLPhysicalShape; Adds clip mode (inside/outside) and pure virtual method to; approximate shape as set of planes. This plane set is used to perform; interactive clipping using OpenGL clip planes. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLClip(); voidTGLPhysicalShape::AddReference(TGLPShapeRef* ref); const TGLBoundingBox&TGLPhysicalShape::BoundingBox() const; virtual voidTGLPhysicalShape::CalculateShapeLOD(TGLRnrCtx& rnrCtx, Float_t& pixSize, Short_t& shapeLOD) const; static TClass*Class(); const Float_t*TGLPhysicalShape::Color() const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; const TGLLogicalShape*TGLPhysicalShape::GetLogical() const; TGLPhysicalShape::EManipTGLPhysicalShape::GetManip() const; TGLClip::EModeGetMode() const; const TGLPhysicalShape*TGLPhysicalShape::GetNextPhysical() const; TGLVector3TGLPhysicalShape::GetScale() const; UChar_tTGLPhysicalShape::GetSelected() const; TGLVertex3TGLPhysicalShape::GetTranslation() const; UInt_tTGLPhysicalShape::ID() const; voidIncTimeStamp(); voidInvalidate(); voidTGLPhysicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; Bool_tTGLPhysicalShape::IsInvisible() const; Bool_tTGLPhysicalShape::IsModified() const; Bool_tTGLPhysicalShape::IsSelected() const; Bool_tTGLPhysicalShape::IsTransparent() const; Bool_tIsValid() const; virtual voidModified(); virtual voidPlaneSet(TGLPlaneSet_t& set) const; virtual voidTGLPhysicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD, Short_t& quantLOD) const; voidTG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLClip.html:669,avail,available,669,root/html528/TGLClip.html,https://root.cern,https://root.cern/root/html528/TGLClip.html,4,['avail'],['available']
Availability,". TGLManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLManager. class TGLManager: public TNamed. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Bool_tAttachOffScreenDevice(Int_t ctxInd, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCreateGLContext(Int_t winInd); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteGLContext(Int_t ctxInd); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLManager.html:496,avail,available,496,root/html602/TGLManager.html,https://root.cern,https://root.cern/root/html602/TGLManager.html,4,['avail'],['available']
Availability,". TGLManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLManager. class TGLManager: public TNamed. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Bool_tAttachOffScreenDevice(Int_t ctxInd, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCreateGLContext(Int_t winInd); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteGLContext(Int_t ctxInd); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLManager.html:496,avail,available,496,root/html528/TGLManager.html,https://root.cern,https://root.cern/root/html528/TGLManager.html,8,['avail'],['available']
Availability,". TGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLManip. class TGLManip: public TVirtualGLManip. Abstract base class for viewer manipulators, which allow direct in; viewer manipulation of a (TGlPhysicalShape) object - currently; translation, scaling and rotation along/round objects local axes.; See derived classes for these implementations. This class provides binding to the zero or one manipulated physical,; hit testing (selection) for manipulator sub component (widget), and; some common mouse action handling/tracking. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLManip(); voidAttach(TGLPhysicalShape* shape); static TClass*Class(); virtual voidDraw(const TGLCamera& camera) const; Bool_tGetActive() const; TGLPhysicalShape*GetAttached() const; UInt_tGetSelectedWidget() const; virtual Bool_tHandleButton(const Event_t& event, const TGLCamera& camera); virtual Bool_tHandleMotion(const Event_t& event, const TGLCamera& camera); virtual TClass*IsA() const; virtual Bool_tSelect(const TGLCamera&, const TGLRect&, const TGLBoundingBox&); voidSetActive(Bool_t a); voidSetSelectedWidget(UInt_t s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLManip(); TGLManip(TGLPhysicalShape* shape). protected:. voidCalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3[3] axis) const; const UChar_t*ColorFor(UInt_t widget) const; TGLManip&operator=(const TGLManip&); TGLManip(const TGLManip&). Data Members; protected:. Bool_tfActive! manipulator is active?; TPointfFirstMouse! first (start) mouse position (in WINDOW coords); TPointfLas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLManip.html:856,avail,available,856,root/html602/TGLManip.html,https://root.cern,https://root.cern/root/html602/TGLManip.html,2,['avail'],['available']
Availability,". TGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLManip. class TGLManip: public TVirtualGLManip. Abstract base class for viewer manipulators, which allow direct in; viewer manipulation of a (TGlPhysicalShape) object - currently; translation, scaling and rotation along/round objects local axes.; See derived classes for these implementations. This class provides binding to the zero or one manipulated physical,; hit testing (selection) for manipulator sub component (widget), and; some common mouse action handling/tracking. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLManip(); voidAttach(TGLPhysicalShape* shape); static TClass*Class(); virtual voidDraw(const TGLCamera& camera) const; Bool_tGetActive() const; TGLPhysicalShape*GetAttached() const; UInt_tGetSelectedWidget() const; virtual Bool_tHandleButton(const Event_t& event, const TGLCamera& camera); virtual Bool_tHandleMotion(const Event_t& event, const TGLCamera& camera); virtual TClass*IsA() const; virtual Bool_tSelect(const TGLCamera&, const TGLRect&, const TGLBoundingBox&); voidSetActive(Bool_t a); voidSetSelectedWidget(UInt_t s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidCalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3* axis) const; const UChar_t*ColorFor(UInt_t widget) const; TGLManip&operator=(const TGLManip&). Data Members; protected:. Bool_tfActive! manipulator is active?; TPointfFirstMouse! first (start) mouse position (in WINDOW coords); TPointfLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tfSelectedWidget! active width (axis) compon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLManip.html:856,avail,available,856,root/html528/TGLManip.html,https://root.cern,https://root.cern/root/html528/TGLManip.html,3,['avail'],['available']
Availability,". TGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLManip. class TGLManip: public TVirtualGLManip. Abstract base class for viewer manipulators, which allow direct in; viewer manipulation of a (TGlPhysicalShape) object - currently; translation, scaling and rotation along/round objects local axes.; See derived classes for these implementations. This class provides binding to the zero or one manipulated physical,; hit testing (selection) for manipulator sub component (widget), and; some common mouse action handling/tracking. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLManip(); voidAttach(TGLPhysicalShape* shape); static TClass*Class(); virtual voidDraw(const TGLCamera& camera) const; Bool_tGetActive() const; TGLPhysicalShape*GetAttached() const; UInt_tGetSelectedWidget() const; virtual Bool_tHandleButton(const Event_t& event, const TGLCamera& camera); virtual Bool_tHandleMotion(const Event_t& event, const TGLCamera& camera); virtual TClass*IsA() const; virtual Bool_tSelect(const TGLCamera&, const TGLRect&, const TGLBoundingBox&); voidSetActive(Bool_t a); voidSetSelectedWidget(UInt_t s); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidCalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera, Double_t& base, TGLVector3* axis) const; const UChar_t*ColorFor(UInt_t widget) const; TGLManip&operator=(const TGLManip&). Data Members; protected:. Bool_tfActive! manipulator is active?; TPointfFirstMouse! first (start) mouse position (in WINDOW coords); TPointfLastMouse! last (latest) mouse position (in WINDOW coords); UInt_tfSelectedWidget! active ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLManip.html:856,avail,available,856,root/html534/TGLManip.html,https://root.cern,https://root.cern/root/html534/TGLManip.html,1,['avail'],['available']
Availability,". TGLManipSet. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLManipSet. class TGLManipSet: public TGLOverlayElement, public TGLPShapeRef. Combine all available manipulators in a collection. At first I wanted to merge them back into TGLManip (to have a; single class) but then it seemed somehow messy.; Maybe next time. Function Members (Methods); public:. TGLManipSet(); virtual~TGLManipSet(); static TClass*Class(); TGLManip*GetCurrentManip() const; Bool_tGetDrawBBox() const; Int_tGetManipType() const; TGLPhysicalShape*TGLPShapeRef::GetPShape() const; TGLOverlayElement::ERoleTGLOverlayElement::GetRole() const; TGLOverlayElement::EStateTGLOverlayElement::GetState() const; virtual Bool_tHandle(TGLRnrCtx& rnrCtx, TGLOvlSelectRecord& selRec, Event_t* event); virtual TClass*IsA() const; virtual Bool_tMouseEnter(TGLOvlSelectRecord& selRec); virtual voidMouseLeave(); virtual Bool_tTGLOverlayElement::MouseStillInside(TGLOvlSelectRecord& selRec); virtual voidTGLPShapeRef::PShapeModified(); virtual voidRender(TGLRnrCtx& rnrCtx); voidTGLOverlayElement::SetBinaryState(Bool_t s); voidSetDrawBBox(Bool_t bb); voidSetManipType(Int_t type); virtual voidSetPShape(TGLPhysicalShape* shape); voidTGLOverlayElement::SetRole(TGLOverlayElement::ERole r); voidTGLOverlayElement::SetState(TGLOverlayElement::EState s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidTGLOverlayElement::ProjectionMatrixPushIdentity(). private:. TGLManipSet(const TGLManipSet&); TGLManipSet&operator=(const TGLManipSet&). Data Members; public:. enum EManip { kTrans; kScale; kRotate; kEndType; };; enum TGLOverlayElement::ERole { kUser; kViewer; kAnnotation; kAll; };; enum TGLOverlayElement::EState { kInvisible; kDisabled; kActive; kAllVisible; };. protec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLManipSet.html:337,avail,available,337,root/html528/TGLManipSet.html,https://root.cern,https://root.cern/root/html528/TGLManipSet.html,3,['avail'],['available']
Availability,". TGLManipSet. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLManipSet. class TGLManipSet: public TGLOverlayElement, public TGLPShapeRef. Combine all available manipulators in a collection. At first I wanted to merge them back into TGLManip (to have a; single class) but then it seemed somehow messy.; Maybe next time. Function Members (Methods); public:. TGLManipSet(); virtual~TGLManipSet(); static TClass*Class(); TGLManip*GetCurrentManip() const; Bool_tGetDrawBBox() const; Int_tGetManipType() const; TGLPhysicalShape*TGLPShapeRef::GetPShape() const; TGLOverlayElement::ERoleTGLOverlayElement::GetRole() const; TGLOverlayElement::EStateTGLOverlayElement::GetState() const; virtual Bool_tHandle(TGLRnrCtx& rnrCtx, TGLOvlSelectRecord& selRec, Event_t* event); virtual TClass*IsA() const; virtual Bool_tMouseEnter(TGLOvlSelectRecord& selRec); virtual voidMouseLeave(); virtual Bool_tTGLOverlayElement::MouseStillInside(TGLOvlSelectRecord& selRec); virtual voidTGLPShapeRef::PShapeModified(); virtual voidRender(TGLRnrCtx& rnrCtx); voidTGLOverlayElement::SetBinaryState(Bool_t s); voidSetDrawBBox(Bool_t bb); voidSetManipType(Int_t type); virtual voidSetPShape(TGLPhysicalShape* shape); voidTGLOverlayElement::SetRole(TGLOverlayElement::ERole r); voidTGLOverlayElement::SetState(TGLOverlayElement::EState s); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidTGLOverlayElement::ProjectionMatrixPushIdentity(). private:. TGLManipSet(const TGLManipSet&); TGLManipSet&operator=(const TGLManipSet&). Data Members; public:. enum EManip { kTrans; kScale; kRotate; kEndType; };; enum TGLOverlayElement::ERole { kUser; kViewer; kAnnotation; kAll; };; enum TGLOverlayElement::EState { kInvisible; kDisabled; kActive; kAll",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLManipSet.html:337,avail,available,337,root/html534/TGLManipSet.html,https://root.cern,https://root.cern/root/html534/TGLManipSet.html,1,['avail'],['available']
Availability,". TGLManipSet. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLManipSet. class TGLManipSet: public TGLOverlayElement, public TGLPShapeRef. Combine all available manipulators in a collection. At first I wanted to merge them back into TGLManip (to have a; single class) but then it seemed somehow messy.; Maybe next time. Function Members (Methods); public:. virtual~TGLManipSet(); static TClass*Class(); TGLManip*GetCurrentManip() const; Bool_tGetDrawBBox() const; Int_tGetManipType() const; TGLPhysicalShape*TGLPShapeRef::GetPShape() const; TGLOverlayElement::ERoleTGLOverlayElement::GetRole() const; TGLOverlayElement::EStateTGLOverlayElement::GetState() const; virtual Bool_tHandle(TGLRnrCtx& rnrCtx, TGLOvlSelectRecord& selRec, Event_t* event); virtual TClass*IsA() const; virtual Bool_tMouseEnter(TGLOvlSelectRecord& selRec); virtual voidMouseLeave(); virtual Bool_tTGLOverlayElement::MouseStillInside(TGLOvlSelectRecord& selRec); virtual voidTGLPShapeRef::PShapeModified(); virtual voidRender(TGLRnrCtx& rnrCtx); voidTGLOverlayElement::SetBinaryState(Bool_t s); voidSetDrawBBox(Bool_t bb); voidSetManipType(Int_t type); virtual voidSetPShape(TGLPhysicalShape* shape); voidTGLOverlayElement::SetRole(TGLOverlayElement::ERole r); voidTGLOverlayElement::SetState(TGLOverlayElement::EState s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLManipSet(). protected:. voidTGLOverlayElement::ProjectionMatrixPushIdentity(). private:. TGLManipSet&operator=(const TGLManipSet&); TGLManipSet(const TGLManipSet&). Data Members; public:. static TGLOverlayElement::EStateTGLOverlayElement::kActive; static TGLOverlayElement::ERoleTGLOverlayElement::kAll; static TGLOverlayElement::EStateTGLOverlayElement::kAllVisible; st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLManipSet.html:337,avail,available,337,root/html602/TGLManipSet.html,https://root.cern,https://root.cern/root/html602/TGLManipSet.html,2,['avail'],['available']
Availability,". TGLObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLObject. class TGLObject: public TGLLogicalShape. Base-class for direct OpenGL renderers.; This allows classes to circumvent passing of TBuffer3D and; use user-provided OpenGL code.; By convention, if you want class TFoo : public TObject to have direct rendering; you should also provide TFooGL : public TGLObject and implement; abstract functions SetModel() and SetBBox().; TAttBBox can be used to facilitate calculation of bounding-boxes.; See TPointSet3D and TPointSet3DGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLObject(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLObject.html:857,avail,available,857,root/html528/TGLObject.html,https://root.cern,https://root.cern/root/html528/TGLObject.html,3,['avail'],['available']
Availability,". TGLObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLObject. class TGLObject: public TGLLogicalShape. Base-class for direct OpenGL renderers.; This allows classes to circumvent passing of TBuffer3D and; use user-provided OpenGL code.; By convention, if you want class TFoo : public TObject to have direct rendering; you should also provide TFooGL : public TGLObject and implement; abstract functions SetModel() and SetBBox().; TAttBBox can be used to facilitate calculation of bounding-boxes.; See TPointSet3D and TPointSet3DGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLObject(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLObject.html:857,avail,available,857,root/html534/TGLObject.html,https://root.cern,https://root.cern/root/html534/TGLObject.html,3,['avail'],['available']
Availability,". TGLOrthoCamera. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLOrthoCamera. class TGLOrthoCamera: public TGLCamera. TGLOrthoCamera. Orthographic projection camera. Currently limited to three types; defined at construction time - kXOY, kXOZ, kZOY - where this refers; to the viewport plane axis - e.g. kXOY has X axis horizontal, Y; vertical - i.e. looking down Z axis with Y vertical. The plane types restriction could easily be removed to supported; arbitary ortho projections along any axis/orientation with free; rotations about them. Function Members (Methods); public:. TGLOrthoCamera(); TGLOrthoCamera(TGLOrthoCamera::EType type, const TGLVector3& hAxis, const TGLVector3& vAxis); virtual~TGLOrthoCamera(); voidTObject::AbstractMethod(const char* method) const; Bool_tTGLCamera::AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tTGLCamera::AdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidConfigure(Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tDolly(Int_t delta, Bool_t mod1, Bool_t mod2); virtual voidTObject::Draw(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLOrthoCamera.html:545,down,down,545,root/html534/TGLOrthoCamera.html,https://root.cern,https://root.cern/root/html534/TGLOrthoCamera.html,1,['down'],['down']
Availability,". TGLOrthoCamera. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLOrthoCamera. class TGLOrthoCamera: public TGLCamera. TGLOrthoCamera. Orthographic projection camera. Currently limited to three types; defined at construction time - kXOY, kXOZ, kZOY - where this refers; to the viewport plane axis - e.g. kXOY has X axis horizontal, Y; vertical - i.e. looking down Z axis with Y vertical. The plane types restriction could easily be removed to supported; arbitary ortho projections along any axis/orientation with free; rotations about them. Function Members (Methods); public:. TGLOrthoCamera(TGLOrthoCamera::EType type, const TGLVector3& hAxis, const TGLVector3& vAxis); virtual~TGLOrthoCamera(); Bool_tTGLCamera::AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tTGLCamera::AdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidApply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; static TClass*Class(); virtual voidConfigure(Double_t zoom, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); virtual Bool_tDolly(Int_t delta, Bool_t mod1, Bool_t mod2); voidTGLCamera::DrawDebugAids() const; TGLVector3TGLCamera::EyeDirection() const; TGLVertex3TGLCamera::EyePoint() const; TGLVertex3TGLCamera::FrustumCenter() const; EOverlapTGLCamera::FrustumOverlap(const TGLBoundingBox& box) const; const TGLPlane&TGLCamera::FrustumPlane(TGLCamera::EFrustumPlane plane) const; const TGLMatrix&TGLCamera::GetCamBase() const; const TGLMatrix&TGLCamera::GetCamTrans() const; Double_t*TGLCamera::GetCenterVec(); Bool_tGetDollyToZoom() const; Bool_tGetEnableRotate() const; Bool_tTGLCamera::GetExternalCenter(); Double_tTGLCamera::GetFarClip() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLOrthoCamera.html:545,down,down,545,root/html528/TGLOrthoCamera.html,https://root.cern,https://root.cern/root/html528/TGLOrthoCamera.html,3,['down'],['down']
Availability,". TGLOrthoCamera. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLOrthoCamera. class TGLOrthoCamera: public TGLCamera. TGLOrthoCamera. Orthographic projection camera. Currently limited to three types; defined at construction time - kXOY, kXOZ, kZOY - where this refers; to the viewport plane axis - e.g. kXOY has X axis horizontal, Y; vertical - i.e. looking down Z axis with Y vertical. The plane types restriction could easily be removed to supported; arbitary ortho projections along any axis/orientation with free; rotations about them. Function Members (Methods); public:. virtual~TGLOrthoCamera(); voidTObject::AbstractMethod(const char* method) const; Bool_tTGLCamera::AdjustAndClampVal(Double_t& val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const; Double_tTGLCamera::AdjustDelta(Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidConfigure(Double_t zoom, Double_t dolly, Double_t[3] center, Double_t hRotate, Double_t vRotate); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tDolly(Int_t delta, Bool_t mod1, Bool_t mod2); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLOrthoCamera.html:545,down,down,545,root/html602/TGLOrthoCamera.html,https://root.cern,https://root.cern/root/html602/TGLOrthoCamera.html,2,['down'],['down']
Availability,". TGLOverlayElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLOverlayElement. class TGLOverlayElement. An overlay element. Supports drawing (Render) and event-handling. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLOverlayElement(); static TClass*Class(); TGLOverlayElement::ERoleGetRole() const; TGLOverlayElement::EStateGetState() const; virtual Bool_tHandle(TGLRnrCtx& rnrCtx, TGLOvlSelectRecord& selRec, Event_t* event); virtual TClass*IsA() const; virtual Bool_tMouseEnter(TGLOvlSelectRecord& selRec); virtual voidMouseLeave(); virtual Bool_tMouseStillInside(TGLOvlSelectRecord& selRec); virtual voidRender(TGLRnrCtx& rnrCtx); voidSetBinaryState(Bool_t s); voidSetRole(TGLOverlayElement::ERole r); voidSetState(TGLOverlayElement::EState s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLOverlayElement(TGLOverlayElement::ERole r = kUser, TGLOverlayElement::EState s = kActive). protected:. voidProjectionMatrixPushIdentity(). private:. TGLOverlayElement&operator=(const TGLOverlayElement&); TGLOverlayElement(const TGLOverlayElement&). Data Members; public:. static TGLOverlayElement::EStatekActive; static TGLOverlayElement::ERolekAll; static TGLOverlayElement::EStatekAllVisible; static TGLOverlayElement::ERolekAnnotation; static TGLOverlayElement::EStatekDisabled; static TGLOverlayElement::EStatekInvisible; static TGLOverlayElement::ERolekUser; static TGLOverlayElement::ERolekViewer. protected:. TGLOverlayElement::ERolefRole; TGLOverlayElement::EStatefState. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLOverlayElement.html:496,avail,available,496,root/html602/TGLOverlayElement.html,https://root.cern,https://root.cern/root/html602/TGLOverlayElement.html,2,['avail'],['available']
Availability,". TGLOverlayElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLOverlayElement. class TGLOverlayElement. An overlay element. Supports drawing (Render) and event-handling. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLOverlayElement(); static TClass*Class(); TGLOverlayElement::ERoleGetRole() const; TGLOverlayElement::EStateGetState() const; virtual Bool_tHandle(TGLRnrCtx& rnrCtx, TGLOvlSelectRecord& selRec, Event_t* event); virtual TClass*IsA() const; virtual Bool_tMouseEnter(TGLOvlSelectRecord& selRec); virtual voidMouseLeave(); virtual Bool_tMouseStillInside(TGLOvlSelectRecord& selRec); virtual voidRender(TGLRnrCtx& rnrCtx); voidSetBinaryState(Bool_t s); voidSetRole(TGLOverlayElement::ERole r); voidSetState(TGLOverlayElement::EState s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidProjectionMatrixPushIdentity(). private:. TGLOverlayElement&operator=(const TGLOverlayElement&). Data Members; public:. enum ERole { kUser; kViewer; kAnnotation; kAll; };; enum EState { kInvisible; kDisabled; kActive; kAllVisible; };. protected:. TGLOverlayElement::ERolefRole; TGLOverlayElement::EStatefState. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t MouseEnter(TGLOvlSelectRecord& selRec); Mouse has enetered this element.; Return TRUE if you want additional events. Bool_t MouseStillInside(TGLOvlSelectRecord& selRec); A new overlay hit is about to be processed.; By returning FALSE one can force mouse-leave (MouseLeave will be; called shortly).; If you return TRUE, Handle will be called soon.; Use this if your overlay object has som",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLOverlayElement.html:496,avail,available,496,root/html528/TGLOverlayElement.html,https://root.cern,https://root.cern/root/html528/TGLOverlayElement.html,3,['avail'],['available']
Availability,". TGLOverlayElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLOverlayElement. class TGLOverlayElement. An overlay element. Supports drawing (Render) and event-handling. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLOverlayElement(); static TClass*Class(); TGLOverlayElement::ERoleGetRole() const; TGLOverlayElement::EStateGetState() const; virtual Bool_tHandle(TGLRnrCtx& rnrCtx, TGLOvlSelectRecord& selRec, Event_t* event); virtual TClass*IsA() const; virtual Bool_tMouseEnter(TGLOvlSelectRecord& selRec); virtual voidMouseLeave(); virtual Bool_tMouseStillInside(TGLOvlSelectRecord& selRec); virtual voidRender(TGLRnrCtx& rnrCtx); voidSetBinaryState(Bool_t s); voidSetRole(TGLOverlayElement::ERole r); voidSetState(TGLOverlayElement::EState s); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidProjectionMatrixPushIdentity(). private:. TGLOverlayElement&operator=(const TGLOverlayElement&). Data Members; public:. enum ERole { kUser; kViewer; kAnnotation; kAll; };; enum EState { kInvisible; kDisabled; kActive; kAllVisible; };. protected:. TGLOverlayElement::ERolefRole; TGLOverlayElement::EStatefState. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t MouseEnter(TGLOvlSelectRecord& selRec); Mouse has enetered this element.; Return TRUE if you want additional events. Bool_t MouseStillInside(TGLOvlSelectRecord& selRec); A new overlay hit is about to be processed.; By returning FALSE one can force mouse-leave (MouseLeave will be; called shortly).; If you return TRUE, Handle will be called soon.; Use this if your ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLOverlayElement.html:496,avail,available,496,root/html534/TGLOverlayElement.html,https://root.cern,https://root.cern/root/html534/TGLOverlayElement.html,1,['avail'],['available']
Availability,". TGLPaintDevice. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLPaintDevice. class TGLPaintDevice. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPaintDevice(); static TClass*Class(); virtual voidExtractViewport(Int_t* vp) const; virtual const TGLContext*GetContext() const; virtual const TGLFormat*GetPixelFormat() const; virtual TClass*IsA() const; virtual Bool_tMakeCurrent(); TGLPaintDevice&operator=(const TGLPaintDevice&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidSwapBuffers(); TGLPaintDevice(); TGLPaintDevice(const TGLPaintDevice&). private:. virtual voidAddContext(TGLContext* ctx); virtual voidRemoveContext(TGLContext* ctx). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ExtractViewport(Int_t ctxInd, Int_t *vp); Off-screen device holds sizes for glViewport. Bool_t MakeCurrent(Int_t ctxInd); ]; Make the gl context current. virtual ~TGLPaintDevice(); {}. void SwapBuffers(). const TGLFormat * GetPixelFormat() const. const TGLContext * GetContext() const. void AddContext(TGLContext* ctx). void Remove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPaintDevice.html:493,avail,available,493,root/html602/TGLPaintDevice.html,https://root.cern,https://root.cern/root/html602/TGLPaintDevice.html,4,['avail'],['available']
Availability,". TGLPaintDevice. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLPaintDevice. class TGLPaintDevice. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPaintDevice(); static TClass*Class(); virtual voidExtractViewport(Int_t* vp) const; virtual const TGLContext*GetContext() const; virtual const TGLFormat*GetPixelFormat() const; virtual TClass*IsA() const; virtual Bool_tMakeCurrent(); TGLPaintDevice&operator=(const TGLPaintDevice&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidSwapBuffers(). private:. virtual voidAddContext(TGLContext* ctx); virtual voidRemoveContext(TGLContext* ctx). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ExtractViewport(Int_t ctxInd, Int_t *vp); Off-screen device holds sizes for glViewport. Bool_t MakeCurrent(Int_t ctxInd); ]; Make the gl context current. virtual ~TGLPaintDevice(); {}. void SwapBuffers(). const TGLFormat * GetPixelFormat() const. const TGLContext * GetContext() const. void AddContext(TGLContext* ctx). void RemoveContext(TGLContext* ctx). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyrig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLPaintDevice.html:493,avail,available,493,root/html528/TGLPaintDevice.html,https://root.cern,https://root.cern/root/html528/TGLPaintDevice.html,6,['avail'],['available']
Availability,". TGLPaintDevice. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TGLPaintDevice. class TGLPaintDevice. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPaintDevice(); static TClass*Class(); virtual voidExtractViewport(Int_t* vp) const; virtual const TGLContext*GetContext() const; virtual const TGLFormat*GetPixelFormat() const; virtual TClass*IsA() const; virtual Bool_tMakeCurrent(); TGLPaintDevice&operator=(const TGLPaintDevice&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidSwapBuffers(). private:. virtual voidAddContext(TGLContext* ctx); virtual voidRemoveContext(TGLContext* ctx). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ExtractViewport(Int_t ctxInd, Int_t *vp); Off-screen device holds sizes for glViewport. Bool_t MakeCurrent(Int_t ctxInd); ]; Make the gl context current. virtual ~TGLPaintDevice(); {}. void SwapBuffers(). const TGLFormat * GetPixelFormat() const. const TGLContext * GetContext() const. void AddContext(TGLContext* ctx). void RemoveContext(TGLContext* ctx). » Author: Valery Fine(fine@vxcern.cern.ch)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLPaintDevice.html:493,avail,available,493,root/html534/TGLPaintDevice.html,https://root.cern,https://root.cern/root/html534/TGLPaintDevice.html,2,['avail'],['available']
Availability,". TGLPlot3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlot3D. class TGLPlot3D: public TGLObject. Description of TGLPlot3D. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPlot3D(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::Qu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLPlot3D.html:450,avail,available,450,root/html530/TGLPlot3D.html,https://root.cern,https://root.cern/root/html530/TGLPlot3D.html,2,['avail'],['available']
Availability,". TGLPlot3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlot3D. class TGLPlot3D: public TGLObject. Description of TGLPlot3D. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPlot3D(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLPlot3D.html:450,avail,available,450,root/html534/TGLPlot3D.html,https://root.cern,https://root.cern/root/html534/TGLPlot3D.html,1,['avail'],['available']
Availability,". TGLPlot3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlot3D. class TGLPlot3D: public TGLObject. Description of TGLPlot3D. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPlot3D(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*CreatePlot(TObject* obj, const Option_t* opt, TVirtualPad* pad); static TGLPlot3D*CreatePlot(TObject* obj, const Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPlot3D.html:450,avail,available,450,root/html602/TGLPlot3D.html,https://root.cern,https://root.cern/root/html602/TGLPlot3D.html,2,['avail'],['available']
Availability,". TGLPlot3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlot3D. class TGLPlot3D: public TGLObject. Description of TGLPlot3D. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPlot3D(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLPlot3D.html:450,avail,available,450,root/html528/TGLPlot3D.html,https://root.cern,https://root.cern/root/html528/TGLPlot3D.html,1,['avail'],['available']
Availability,". TGLPlotPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlotPainter. class TGLPlotPainter: public TVirtualGLPainter. Base class for plot-painters that provide GL rendering of various; 2D and 3D histograms, functions and parametric surfaces. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLPlotPainter(); virtual voidAddOption(const TString& stringOption); static TClass*Class(); Bool_tCutAxisSelected() const; virtual voidDeInitGL() const; virtual voidDrawPlot() const; Bool_tGetDrawAxes(); virtual char*TVirtualGLPainter::GetPlotInfo(Int_t px, Int_t py); virtual Bool_tInitGeometry(); virtual voidInitGL() const; voidInvalidateSelection(); virtual TClass*IsA() const; TGLPlotPainter&operator=(const TGLPlotPainter&); TGLPlotPainter&operator=(TGLPlotPainter&&); virtual voidPaint(); virtual voidTVirtualGLPainter::Pan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&RefBackBox() const; voidSetDrawAxes(Bool_t s); voidSetDrawBackBox(Bool_t b); voidSetDrawFrontBox(Bool_t b); virtual voidSetFrameColor(const TColor* frameColor); voidSetPadColor(const TColor* color); voidSetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLPlotPainter(TGLPlotCamera* camera); TGLPlotPainter(const TGLPlotPainter&); TGLPlotPainter(TGLPlotPainter&&); TGLPlotPainter(TGL5DDataSet* data, TGLPlotCamera* camera, TGLPlotCoordinates* coord); TGLPlotPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord, B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPlotPainter.html:571,avail,available,571,root/html602/TGLPlotPainter.html,https://root.cern,https://root.cern/root/html602/TGLPlotPainter.html,2,['avail'],['available']
Availability,". TGLPlotPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlotPainter. class TGLPlotPainter: public TVirtualGLPainter. Base class for plot-painters that provide GL rendering of various; 2D and 3D histograms, functions and parametric surfaces. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLPlotPainter(); virtual voidAddOption(const TString& stringOption); static TClass*Class(); Bool_tCutAxisSelected() const; virtual voidDeInitGL() const; virtual voidDrawPlot() const; Bool_tGetDrawAxes(); virtual char*TVirtualGLPainter::GetPlotInfo(Int_t px, Int_t py); virtual Bool_tInitGeometry(); virtual voidInitGL() const; voidInvalidateSelection(); virtual TClass*IsA() const; TVirtualGLPainter&TVirtualGLPainter::operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidTVirtualGLPainter::Pan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&RefBackBox() const; voidSetDrawAxes(Bool_t s); voidSetDrawBackBox(Bool_t b); voidSetDrawFrontBox(Bool_t b); virtual voidSetFrameColor(const TColor* frameColor); voidSetPadColor(const TColor* color); voidSetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector& insp); virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. virtual voidClearBuffers() const; virtual voidDrawPaletteAxis() const; voidDrawSections() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; const TColor*GetPadColor() const; voidMoveSection(Int_t px, Int_t py); voidPrintPlot() const; voidRestoreModelview",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLPlotPainter.html:571,avail,available,571,root/html532/TGLPlotPainter.html,https://root.cern,https://root.cern/root/html532/TGLPlotPainter.html,1,['avail'],['available']
Availability,". TGLPlotPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlotPainter. class TGLPlotPainter: public TVirtualGLPainter. Base class for plot-painters that provide GL rendering of various; 2D and 3D histograms, functions and parametric surfaces. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLPlotPainter(); virtual voidAddOption(const TString& stringOption); static TClass*Class(); Bool_tCutAxisSelected() const; virtual voidDeInitGL() const; virtual voidDrawPlot() const; Bool_tGetDrawAxes(); virtual char*TVirtualGLPainter::GetPlotInfo(Int_t px, Int_t py); virtual Bool_tInitGeometry(); virtual voidInitGL() const; voidInvalidateSelection(); virtual TClass*IsA() const; TVirtualGLPainter&TVirtualGLPainter::operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidTVirtualGLPainter::Pan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&RefBackBox() const; voidSetDrawAxes(Bool_t s); voidSetDrawBackBox(Bool_t b); voidSetDrawFrontBox(Bool_t b); virtual voidSetFrameColor(const TColor* frameColor); voidSetPadColor(const TColor* color); voidSetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector&); virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. virtual voidClearBuffers() const; virtual voidDrawPaletteAxis() const; voidDrawSections() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; const TColor*GetPadColor() const; voidMoveSection(Int_t px, Int_t py); voidPrintPlot() const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLPlotPainter.html:571,avail,available,571,root/html534/TGLPlotPainter.html,https://root.cern,https://root.cern/root/html534/TGLPlotPainter.html,1,['avail'],['available']
Availability,". TGLPlotPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlotPainter. class TGLPlotPainter: public TVirtualGLPainter. Base class for plot-painters that provide GL rendering of various; 2D and 3D histograms, functions and parametric surfaces. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLPlotPainter(); virtual voidAddOption(const TString& stringOption); static TClass*Class(); Bool_tCutAxisSelected() const; virtual voidDeInitGL() const; virtual voidDrawPlot() const; virtual char*TVirtualGLPainter::GetPlotInfo(Int_t px, Int_t py); virtual Bool_tInitGeometry(); virtual voidInitGL() const; voidInvalidateSelection(); virtual TClass*IsA() const; TVirtualGLPainter&TVirtualGLPainter::operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidTVirtualGLPainter::Pan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&RefBackBox() const; virtual voidSetFrameColor(const TColor* frameColor); voidSetPadColor(const TColor* color); virtual voidShowMembers(TMemberInspector& insp); virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. virtual voidClearBuffers() const; virtual voidDrawPaletteAxis() const; voidDrawSections() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; const TColor*GetPadColor() const; voidMoveSection(Int_t px, Int_t py); voidPrintPlot() const; voidRestoreModelviewMatrix() const; voidRestoreProjectionMatrix() const; voidSaveModelviewMatrix() const; voidSaveProjectionMatrix() const. Data Members; public:. enum ESelectio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLPlotPainter.html:571,avail,available,571,root/html528/TGLPlotPainter.html,https://root.cern,https://root.cern/root/html528/TGLPlotPainter.html,1,['avail'],['available']
Availability,". TGLPlotPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLPlotPainter. class TGLPlotPainter: public TVirtualGLPainter. Base class for plot-painters that provide GL rendering of various; 2D and 3D histograms, functions and parametric surfaces. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLPlotPainter(); virtual voidAddOption(const TString& stringOption); static TClass*Class(); Bool_tCutAxisSelected() const; virtual voidDeInitGL() const; virtual voidDrawPlot() const; virtual char*TVirtualGLPainter::GetPlotInfo(Int_t px, Int_t py); virtual Bool_tInitGeometry(); virtual voidInitGL() const; voidInvalidateSelection(); virtual TClass*IsA() const; TVirtualGLPainter&TVirtualGLPainter::operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidTVirtualGLPainter::Pan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&RefBackBox() const; virtual voidSetFrameColor(const TColor* frameColor); voidSetPadColor(const TColor* color); voidSetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector& insp); virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. virtual voidClearBuffers() const; virtual voidDrawPaletteAxis() const; voidDrawSections() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; const TColor*GetPadColor() const; voidMoveSection(Int_t px, Int_t py); voidPrintPlot() const; voidRestoreModelviewMatrix() const; voidRestoreProjectionMatrix() const; voidSaveModelviewMatrix() const; voidSaveProjectionMatri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLPlotPainter.html:571,avail,available,571,root/html530/TGLPlotPainter.html,https://root.cern,https://root.cern/root/html530/TGLPlotPainter.html,1,['avail'],['available']
Availability,". TGLUtil. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLUtil. class TGLUtil. Wrapper class for various misc static functions - error checking,; draw helpers etc. Function Members (Methods); public:. virtual~TGLUtil(); static voidBeginAttLine(const TAttLine& aline, Char_t transp, Int_t pick_radius = 0, Bool_t selection = kFALSE); static voidBeginExtendPickRegion(Float_t scale); static Int_tCheckError(const char* loc); static TClass*Class(); static voidColor(const TGLColor& color); static voidColor3f(Float_t r, Float_t g, Float_t b); static voidColor3fv(const Float_t* rgb); static voidColor3ub(UChar_t r, UChar_t g, UChar_t b); static voidColor3ubv(const UChar_t* rgb); static voidColor4f(Float_t r, Float_t g, Float_t b, Float_t a); static voidColor4fv(const Float_t* rgba); static voidColor4ub(UChar_t r, UChar_t g, UChar_t b, UChar_t a); static voidColor4ubv(const UChar_t* rgba); static voidColorAlpha(const TGLColor& color, UChar_t alpha); static voidColorAlpha(const TGLColor& color, Float_t alpha); static voidColorAlpha(Color_t color_index, Float_t alpha = 1); static voidColorTransparency(Color_t color_index, Char_t transparency = 0); static voidDrawLine(const TGLLine3& line, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t* rgba); static voidDrawLine(const TGLVertex3& start, const TGLVector3& vector, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t* rgba); static voidDrawNumber(const TString& num, const TGLVertex3& pos, Bool_t center = kFALSE); static voidDrawReferenceMarker(const TGLCamera& camera, const TGLVertex3& pos, Float_t radius = 3, const UChar_t* rgba = 0); static voidDrawRing(const TGLVertex3& center, const TGLVector3& normal, Double_t radius, const UChar_t* rgba); static voidDrawSimpleAxes(const TGLCamera& camera, const TGLBoundingBox& bbox, Int_t axes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLUtil.html:316,error,error,316,root/html534/TGLUtil.html,https://root.cern,https://root.cern/root/html534/TGLUtil.html,1,['error'],['error']
Availability,". TGLUtil. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLUtil. class TGLUtil. Wrapper class for various misc static functions - error checking,; draw helpers etc. Function Members (Methods); public:. virtual~TGLUtil(); static voidBeginAttLine(const TAttLine& aline, Char_t transp, Int_t pick_radius = 0, Bool_t selection = kFALSE); static voidBeginExtendPickRegion(Float_t scale); static Int_tCheckError(const char* loc); static TClass*Class(); static voidColor(const TGLColor& color); static voidColor3f(Float_t r, Float_t g, Float_t b); static voidColor3fv(const Float_t* rgb); static voidColor3ub(UChar_t r, UChar_t g, UChar_t b); static voidColor3ubv(const UChar_t* rgb); static voidColor4f(Float_t r, Float_t g, Float_t b, Float_t a); static voidColor4fv(const Float_t* rgba); static voidColor4ub(UChar_t r, UChar_t g, UChar_t b, UChar_t a); static voidColor4ubv(const UChar_t* rgba); static voidColorAlpha(const TGLColor& color, UChar_t alpha); static voidColorAlpha(const TGLColor& color, Float_t alpha); static voidColorAlpha(Color_t color_index, Float_t alpha = 1); static voidColorTransparency(Color_t color_index, Char_t transparency = 0); static voidDrawLine(const TGLLine3& line, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t[4] rgba); static voidDrawLine(const TGLVertex3& start, const TGLVector3& vector, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t[4] rgba); static voidDrawNumber(const TString& num, const TGLVertex3& pos, Bool_t center = kFALSE); static voidDrawReferenceMarker(const TGLCamera& camera, const TGLVertex3& pos, Float_t radius = 3, const UChar_t* rgba = 0); static voidDrawRing(const TGLVertex3& center, const TGLVector3& normal, Double_t radius, const UChar_t* rgba); static voidDrawSimpleAxes(const TGLCamera& camera, const TGLBoundingBox& bbox, Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLUtil.html:316,error,error,316,root/html602/TGLUtil.html,https://root.cern,https://root.cern/root/html602/TGLUtil.html,2,['error'],['error']
Availability,". TGLUtil. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLUtil. class TGLUtil. Wrapper class for various misc static functions - error checking,; draw helpers etc. Function Members (Methods); public:. virtual~TGLUtil(); static voidBeginAttLine(const TAttLine& aline, Char_t transp, Int_t pick_radius = 0, Bool_t selection = kFALSE); static voidBeginExtendPickRegion(Float_t scale); static voidCheckError(const char* loc); static TClass*Class(); static voidColor(const TGLColor& color); static voidColor3f(Float_t r, Float_t g, Float_t b); static voidColor3fv(const Float_t* rgb); static voidColor3ub(UChar_t r, UChar_t g, UChar_t b); static voidColor3ubv(const UChar_t* rgb); static voidColor4f(Float_t r, Float_t g, Float_t b, Float_t a); static voidColor4fv(const Float_t* rgba); static voidColor4ub(UChar_t r, UChar_t g, UChar_t b, UChar_t a); static voidColor4ubv(const UChar_t* rgba); static voidColorAlpha(const TGLColor& color, UChar_t alpha); static voidColorAlpha(const TGLColor& color, Float_t alpha); static voidColorAlpha(Color_t color_index, Float_t alpha = 1); static voidColorTransparency(Color_t color_index, Char_t transparency = 0); static voidDrawLine(const TGLLine3& line, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t* rgba); static voidDrawLine(const TGLVertex3& start, const TGLVector3& vector, TGLUtil::ELineHeadShape head, Double_t size, const UChar_t* rgba); static voidDrawNumber(const TString& num, const TGLVertex3& pos, Bool_t center = kFALSE); static voidDrawReferenceMarker(const TGLCamera& camera, const TGLVertex3& pos, Float_t radius = 3, const UChar_t* rgba = 0); static voidDrawRing(const TGLVertex3& center, const TGLVector3& normal, Double_t radius, const UChar_t* rgba); static voidDrawSimpleAxes(const TGLCamera& camera, const TGLBoundingBox& bbox, Int_t axesT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLUtil.html:316,error,error,316,root/html528/TGLUtil.html,https://root.cern,https://root.cern/root/html528/TGLUtil.html,3,['error'],['error']
Availability,". TGLViewerBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLViewerBase. class TGLViewerBase: public TGLLockable. Base class for GL viewers. Provides a basic scene management and a; small set of control variables (camera, LOD, style, clip) that are; used by the scene classes. Renering wrappers are available but; minimal. There is no concept of GL-context here ... we just draw; into whatever is set from outside. Development notes:. Each viewer automatically creates a TGLRnrCtx and passes it down; all render functions. Function Members (Methods); public:. TGLViewerBase(); virtual~TGLViewerBase(); virtual voidAddOverlayElement(TGLOverlayElement* el); TGLSceneInfo*AddScene(TGLSceneBase* scene); virtual voidChanged(); static TClass*Class(); TGLClip*Clip() const; TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidDeleteOverlayAnnotations(); virtual voidDeleteOverlayElements(TGLOverlayElement::ERole r); Bool_tFindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tFindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tFindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*FindLogicalInScenes(TObject* id); TGLRnrCtx*GetRnrCtx() const; TGLSceneInfo*GetSceneInfo(TGLSceneBase* scene); virtual TClass*IsA() const; virtual Bool_tIsChanged() const; Bool_tTGLLockable::IsDrawOrSelectLock() const; Bool_tTGLLockable::IsLocked() const; virtual const char*LockIdStr() const; static const char*TGLLockable::LockName(TGLLockable::ELock lock); static Bool_tTGLLockable::LockValid(TGLLockable::ELock lock); Short_tLOD() const; virtual voidMergeSceneBBoxes(TGLBoundingBox& bbox); Float_tOLLineW() const; virtual voidPostRender(); virtual voidPostRenderOverlaySelection(); virtual voidPreRender(); virtual voidPreRenderOverlaySelection(); Bool_tTGLLockable:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLViewerBase.html:489,avail,available,489,root/html528/TGLViewerBase.html,https://root.cern,https://root.cern/root/html528/TGLViewerBase.html,8,"['avail', 'down']","['available', 'down']"
Availability,". TGLViewerBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GL; » TGLViewerBase. class TGLViewerBase: public TGLLockable. Base class for GL viewers. Provides a basic scene management and a; small set of control variables (camera, LOD, style, clip) that are; used by the scene classes. Renering wrappers are available but; minimal. There is no concept of GL-context here ... we just draw; into whatever is set from outside. Development notes:. Each viewer automatically creates a TGLRnrCtx and passes it down; all render functions. Function Members (Methods); public:. virtual~TGLViewerBase(); virtual voidAddOverlayElement(TGLOverlayElement* el); TGLSceneInfo*AddScene(TGLSceneBase* scene); virtual voidChanged(); static TClass*Class(); TGLClip*Clip() const; TGLLockable::ELockTGLLockable::CurrentLock() const; virtual voidDeleteOverlayAnnotations(); virtual voidDeleteOverlayElements(TGLOverlayElement::ERole r); Bool_tFindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tFindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tFindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*FindLogicalInScenes(TObject* id); TGLRnrCtx*GetRnrCtx() const; TGLSceneInfo*GetSceneInfo(TGLSceneBase* scene); virtual TClass*IsA() const; virtual Bool_tIsChanged() const; Bool_tTGLLockable::IsDrawOrSelectLock() const; Bool_tTGLLockable::IsLocked() const; virtual const char*LockIdStr() const; static const char*TGLLockable::LockName(TGLLockable::ELock lock); static Bool_tTGLLockable::LockValid(TGLLockable::ELock lock); Short_tLOD() const; virtual voidMergeSceneBBoxes(TGLBoundingBox& bbox); Float_tOLLineW() const; virtual voidPostRender(); virtual voidPostRenderOverlaySelection(); virtual voidPreRender(); virtual voidPreRenderOverlaySelection(); Bool_tTGLLockable::ReleaseLock(TGLL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLViewerBase.html:489,avail,available,489,root/html602/TGLViewerBase.html,https://root.cern,https://root.cern/root/html602/TGLViewerBase.html,4,"['avail', 'down']","['available', 'down']"
Availability,". TGLayoutHints. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLayoutHints. class TGLayoutHints: public TObject, public TRefCnt. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGLayoutHints(const TGLayoutHints& lh); TGLayoutHints(ULong_t hints = kLHintsNormal, Int_t padleft = 0, Int_t padright = 0, Int_t padtop = 0, Int_t padbottom = 0); virtual~TGLayoutHints(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLayoutHints.html:796,down,downward,796,root/html528/TGLayoutHints.html,https://root.cern,https://root.cern/root/html528/TGLayoutHints.html,4,['down'],['downward']
Availability,". TGLayoutHints. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLayoutHints. class TGLayoutHints: public TObject, public TRefCnt. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. virtual~TGLayoutHints(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::Draw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLayoutHints.html:796,down,downward,796,root/html602/TGLayoutHints.html,https://root.cern,https://root.cern/root/html602/TGLayoutHints.html,2,['down'],['downward']
Availability,". TGLayoutManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLayoutManager. class TGLayoutManager: public TObject. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLayoutManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLayoutManager.html:786,down,downward,786,root/html602/TGLayoutManager.html,https://root.cern,https://root.cern/root/html602/TGLayoutManager.html,2,['down'],['downward']
Availability,". TGLayoutManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLayoutManager. class TGLayoutManager: public TObject. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGLayoutManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLayoutManager.html:786,down,downward,786,root/html528/TGLayoutManager.html,https://root.cern,https://root.cern/root/html528/TGLayoutManager.html,4,['down'],['downward']
Availability,". TGLineStyleComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLineStyleComboBox. class TGLineStyleComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGLineStyleComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); ~TGLineStyleComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* meth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLineStyleComboBox.html:381,down,down,381,root/html528/TGLineStyleComboBox.html,https://root.cern,https://root.cern/root/html528/TGLineStyleComboBox.html,8,['down'],['down']
Availability,". TGLineStyleComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLineStyleComboBox. class TGLineStyleComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. virtual~TGLineStyleComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLineStyleComboBox.html:381,down,down,381,root/html602/TGLineStyleComboBox.html,https://root.cern,https://root.cern/root/html602/TGLineStyleComboBox.html,4,['down'],['down']
Availability,". TGLineWidthComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLineWidthComboBox. class TGLineWidthComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGLineWidthComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel(), Bool_t none = kFALSE); ~TGLineWidthComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::Chan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLineWidthComboBox.html:381,down,down,381,root/html528/TGLineWidthComboBox.html,https://root.cern,https://root.cern/root/html528/TGLineWidthComboBox.html,8,['down'],['down']
Availability,". TGLineWidthComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGLineWidthComboBox. class TGLineWidthComboBox: public TGComboBox. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. virtual~TGLineWidthComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGComboBox::AddEntry(TGString* s, Int_t id); virtual voidTGComboBox::AddEntry(const char* s, Int_t id); virtual voidTGComboBox::AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLineWidthComboBox.html:381,down,down,381,root/html602/TGLineWidthComboBox.html,https://root.cern,https://root.cern/root/html602/TGLineWidthComboBox.html,4,['down'],['down']
Availability,". TGListDetailsLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGListDetailsLayout. class TGListDetailsLayout: public TGTileLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGListDetailsLayout(TGCompositeFrame* main, Int_t sep = 0, UInt_t w = 0); ~TGListDetailsLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Dra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGListDetailsLayout.html:803,down,downward,803,root/html528/TGListDetailsLayout.html,https://root.cern,https://root.cern/root/html528/TGListDetailsLayout.html,4,['down'],['downward']
Availability,". TGListDetailsLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGListDetailsLayout. class TGListDetailsLayout: public TGTileLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. virtual~TGListDetailsLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMEN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGListDetailsLayout.html:803,down,downward,803,root/html602/TGListDetailsLayout.html,https://root.cern,https://root.cern/root/html602/TGListDetailsLayout.html,2,['down'],['downward']
Availability,". TGListLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGListLayout. class TGListLayout: public TGTileLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGListLayout(TGCompositeFrame* main, Int_t sep = 0); ~TGListLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::Dr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGListLayout.html:782,down,downward,782,root/html528/TGListLayout.html,https://root.cern,https://root.cern/root/html528/TGListLayout.html,4,['down'],['downward']
Availability,". TGListLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGListLayout. class TGListLayout: public TGTileLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. virtual~TGListLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGListLayout.html:782,down,downward,782,root/html602/TGListLayout.html,https://root.cern,https://root.cern/root/html602/TGListLayout.html,2,['down'],['downward']
Availability,". TGListTreeItem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGListTreeItem. class TGListTreeItem. TGListTree and TGListTreeItem. A list tree is a widget that can contain a number of items; arranged in a tree structure. The items are represented by small; folder icons that can be either open or closed. The TGListTree is user callable. The TGListTreeItem is a service; class of the list tree. A list tree can generate the following events:; kC_LISTTREE, kCT_ITEMCLICK, which button, location (y<<16|x).; kC_LISTTREE, kCT_ITEMDBLCLICK, which button, location (y<<16|x). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGListTreeItem(); virtual voidCheckAllChildren(Bool_t = kTRUE); virtual voidCheckChildren(TGListTreeItem*, Bool_t); virtual voidCheckItem(Bool_t = kTRUE); static TClass*Class(); virtual voidClearColor(); virtual Pixel_tGetActiveColor() const; virtual const TGPicture*GetCheckBoxPicture() const; virtual Color_tGetColor() const; TGListTreeItem*GetFirstChild() const; TGListTreeItem*GetLastChild() const; TGListTreeItem*GetNextSibling() const; TGListTreeItem*GetParent() const; virtual const TGPicture*GetPicture() const; virtual UInt_tGetPicWidth() const; TGListTreeItem*GetPrevSibling() const; virtual const char*GetText() const; virtual Int_tGetTextLength() const; virtual const char*GetTipText() const; virtual Int_tGetTipTextLength() const; virtual void*GetUserData() const; virtual voidHandleDrag(); virtual voidHandleDrop(); virtual Bool_tHandlesDragAndDrop() const; virtual Bool_tHasCheckBox() const; virtual Bool_tHasCheckedChild(Bool_t = kFALSE); virtual Bool_tHasColor() const; virtual Bool_tHasUnCheckedChild(Bool_t = kFALSE); virtual TClass*IsA() const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGListTreeItem.html:890,avail,available,890,root/html528/TGListTreeItem.html,https://root.cern,https://root.cern/root/html528/TGListTreeItem.html,6,['avail'],['available']
Availability,". TGMatrixLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMatrixLayout. class TGMatrixLayout: public TGLayoutManager. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGMatrixLayout(TGCompositeFrame* main, UInt_t r, UInt_t c, Int_t s = 0, Int_t h = 0); ~TGMatrixLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGMatrixLayout.html:791,down,downward,791,root/html528/TGMatrixLayout.html,https://root.cern,https://root.cern/root/html528/TGMatrixLayout.html,4,['down'],['downward']
Availability,". TGMatrixLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMatrixLayout. class TGMatrixLayout: public TGLayoutManager. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. virtual~TGMatrixLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGMatrixLayout.html:791,down,downward,791,root/html602/TGMatrixLayout.html,https://root.cern,https://root.cern/root/html602/TGMatrixLayout.html,2,['down'],['downward']
Availability,". TGMdiGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMdiGeometry. class TGMdiGeometry. TGMdiMainFrame. This file contains the TGMdiMainFrame class. Function Members (Methods); public:. TGMdiGeometry(); TGMdiGeometry(const TGMdiGeometry&); virtual~TGMdiGeometry(); static TClass*Class(); virtual TClass*IsA() const; TGMdiGeometry&operator=(const TGMdiGeometry&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. TGRectanglefClient; TGRectanglefDecoration; TGRectanglefIconclient, decoration and icon rectangles; Int_tfValueMaskMDI hints mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TGMdiGeometry(); { }. » Author: Bertrand Bellenot 20/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGMdiMainFrame.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGMdiGeometry.html:822,mask,mask,822,root/html528/TGMdiGeometry.html,https://root.cern,https://root.cern/root/html528/TGMdiGeometry.html,1,['mask'],['mask']
Availability,". TGMdiGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMdiGeometry. class TGMdiGeometry. TGMdiMainFrame. This file contains the TGMdiMainFrame class. Function Members (Methods); public:. TGMdiGeometry(); TGMdiGeometry(const TGMdiGeometry&); virtual~TGMdiGeometry(); static TClass*Class(); virtual TClass*IsA() const; TGMdiGeometry&operator=(const TGMdiGeometry&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. TGRectanglefClient; TGRectanglefDecoration; TGRectanglefIconclient, decoration and icon rectangles; Int_tfValueMaskMDI hints mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TGMdiGeometry(); { }. » Author: Bertrand Bellenot 20/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGMdiMainFrame.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGMdiGeometry.html:822,mask,mask,822,root/html530/TGMdiGeometry.html,https://root.cern,https://root.cern/root/html530/TGMdiGeometry.html,1,['mask'],['mask']
Availability,". TGMdiGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMdiGeometry. class TGMdiGeometry. TGMdiMainFrame. This file contains the TGMdiMainFrame class. Function Members (Methods); public:. TGMdiGeometry(); TGMdiGeometry(const TGMdiGeometry&); virtual~TGMdiGeometry(); static TClass*Class(); virtual TClass*IsA() const; TGMdiGeometry&operator=(const TGMdiGeometry&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. TGRectanglefClient; TGRectanglefDecoration; TGRectanglefIconclient, decoration and icon rectangles; Int_tfValueMaskMDI hints mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TGMdiGeometry(); { }. » Author: Bertrand Bellenot 20/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGMdiMainFrame.h 40531 2011-08-10 13:56:13Z bellenot $ » Last generated: 2011-11-03 20:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGMdiGeometry.html:822,mask,mask,822,root/html532/TGMdiGeometry.html,https://root.cern,https://root.cern/root/html532/TGMdiGeometry.html,1,['mask'],['mask']
Availability,". TGMdiGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMdiGeometry. class TGMdiGeometry. TGMdiMainFrame. This file contains the TGMdiMainFrame class. Function Members (Methods); public:. TGMdiGeometry(); TGMdiGeometry(const TGMdiGeometry&); virtual~TGMdiGeometry(); static TClass*Class(); virtual TClass*IsA() const; TGMdiGeometry&operator=(const TGMdiGeometry&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. TGRectanglefClient; TGRectanglefDecoration; TGRectanglefIconclient, decoration and icon rectangles; Int_tfValueMaskMDI hints mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TGMdiGeometry(); { }. » Author: Bertrand Bellenot 20/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-03-13 19:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGMdiGeometry.html:841,mask,mask,841,root/html534/TGMdiGeometry.html,https://root.cern,https://root.cern/root/html534/TGMdiGeometry.html,1,['mask'],['mask']
Availability,". TGMdiGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMdiGeometry. class TGMdiGeometry. TGMdiMainFrame. This file contains the TGMdiMainFrame class. Function Members (Methods); public:. virtual~TGMdiGeometry(); static TClass*Class(); virtual TClass*IsA() const; TGMdiGeometry&operator=(const TGMdiGeometry&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGMdiGeometry(); TGMdiGeometry(const TGMdiGeometry&). Data Members; public:. TGRectanglefClientclient, decoration and icon rectangles; TGRectanglefDecorationclient, decoration and icon rectangles; TGRectanglefIconclient, decoration and icon rectangles; Int_tfValueMaskMDI hints mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TGMdiGeometry(); { }. » Author: Bertrand Bellenot 20/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 15:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGMdiGeometry.html:928,mask,mask,928,root/html604/TGMdiGeometry.html,https://root.cern,https://root.cern/root/html604/TGMdiGeometry.html,1,['mask'],['mask']
Availability,". TGMdiGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGMdiGeometry. class TGMdiGeometry. TGMdiMainFrame. This file contains the TGMdiMainFrame class. Function Members (Methods); public:. virtual~TGMdiGeometry(); static TClass*Class(); virtual TClass*IsA() const; TGMdiGeometry&operator=(const TGMdiGeometry&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGMdiGeometry(); TGMdiGeometry(const TGMdiGeometry&). Data Members; public:. TGRectanglefClientclient, decoration and icon rectangles; TGRectanglefDecorationclient, decoration and icon rectangles; TGRectanglefIconclient, decoration and icon rectangles; Int_tfValueMaskMDI hints mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TGMdiGeometry(); { }. » Author: Bertrand Bellenot 20/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGMdiGeometry.html:928,mask,mask,928,root/html602/TGMdiGeometry.html,https://root.cern,https://root.cern/root/html602/TGMdiGeometry.html,1,['mask'],['mask']
Availability,". TGNumberEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGNumberEntry. class TGNumberEntry: public TGCompositeFrame, public TGWidget, public TGNumberFormat. TGNumberEntry, TGNumberEntryField and TGNumberFormat. TGNumberEntry is a number entry input widget with up/down buttons.; TGNumberEntryField is a number entry input widget.; TGNumberFormat contains enum types to specify the numeric format. The number entry widget is based on TGTextEntry but allows only; numerical input. The widget support numerous formats including; integers, hex numbers, real numbers, fixed fraction reals and; time/date formats. The widget also allows to restrict input values; to non-negative or positive numbers and to specify explicit limits. The following styles are supported:; kNESInteger: integer number; kNESRealOne: real number with one digit (no exponent); kNESRealTwo: real number with two digits (no exponent); kNESRealThree: real number with three digits (no exponent); kNESRealFour: real number with four digits (no exponent); kNESReal: arbitrary real number; kNESDegree: angle in degree:minutes:seconds format; kNESMinSec: time in minutes:seconds format; kNESHourMin: time in hour:minutes format; kNESHourMinSec: time in hour:minutes:seconds format; kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGNumberEntry.html:454,down,down,454,root/html528/TGNumberEntry.html,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html,6,['down'],['down']
Availability,". TGNumberEntryField. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGNumberEntryField. class TGNumberEntryField: public TGTextEntry, public TGNumberFormat. TGNumberEntry, TGNumberEntryField and TGNumberFormat. TGNumberEntry is a number entry input widget with up/down buttons.; TGNumberEntryField is a number entry input widget.; TGNumberFormat contains enum types to specify the numeric format. The number entry widget is based on TGTextEntry but allows only; numerical input. The widget support numerous formats including; integers, hex numbers, real numbers, fixed fraction reals and; time/date formats. The widget also allows to restrict input values; to non-negative or positive numbers and to specify explicit limits. The following styles are supported:; kNESInteger: integer number; kNESRealOne: real number with one digit (no exponent); kNESRealTwo: real number with two digits (no exponent); kNESRealThree: real number with three digits (no exponent); kNESRealFour: real number with four digits (no exponent); kNESReal: arbitrary real number; kNESDegree: angle in degree:minutes:seconds format; kNESMinSec: time in minutes:seconds format; kNESHourMin: time in hour:minutes format; kNESHourMinSec: time in hour:minutes:seconds format; kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small button",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGNumberEntryField.html:447,down,down,447,root/html528/TGNumberEntryField.html,https://root.cern,https://root.cern/root/html528/TGNumberEntryField.html,6,['down'],['down']
Availability,". TGNumberEntryLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGNumberEntryLayout. class TGNumberEntryLayout: public TGLayoutManager. TGNumberEntry, TGNumberEntryField and TGNumberFormat. TGNumberEntry is a number entry input widget with up/down buttons.; TGNumberEntryField is a number entry input widget.; TGNumberFormat contains enum types to specify the numeric format. The number entry widget is based on TGTextEntry but allows only; numerical input. The widget support numerous formats including; integers, hex numbers, real numbers, fixed fraction reals and; time/date formats. The widget also allows to restrict input values; to non-negative or positive numbers and to specify explicit limits. The following styles are supported:; kNESInteger: integer number; kNESRealOne: real number with one digit (no exponent); kNESRealTwo: real number with two digits (no exponent); kNESRealThree: real number with three digits (no exponent); kNESRealFour: real number with four digits (no exponent); kNESReal: arbitrary real number; kNESDegree: angle in degree:minutes:seconds format; kNESMinSec: time in minutes:seconds format; kNESHourMin: time in hour:minutes format; kNESHourMinSec: time in hour:minutes:seconds format; kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small buttons to increase an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGNumberEntryLayout.html:431,down,down,431,root/html528/TGNumberEntryLayout.html,https://root.cern,https://root.cern/root/html528/TGNumberEntryLayout.html,6,['down'],['down']
Availability,". TGNumberFormat. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGNumberFormat. class TGNumberFormat. TGNumberEntry, TGNumberEntryField and TGNumberFormat. TGNumberEntry is a number entry input widget with up/down buttons.; TGNumberEntryField is a number entry input widget.; TGNumberFormat contains enum types to specify the numeric format. The number entry widget is based on TGTextEntry but allows only; numerical input. The widget support numerous formats including; integers, hex numbers, real numbers, fixed fraction reals and; time/date formats. The widget also allows to restrict input values; to non-negative or positive numbers and to specify explicit limits. The following styles are supported:; kNESInteger: integer number; kNESRealOne: real number with one digit (no exponent); kNESRealTwo: real number with two digits (no exponent); kNESRealThree: real number with three digits (no exponent); kNESRealFour: real number with four digits (no exponent); kNESReal: arbitrary real number; kNESDegree: angle in degree:minutes:seconds format; kNESMinSec: time in minutes:seconds format; kNESHourMin: time in hour:minutes format; kNESHourMinSec: time in hour:minutes:seconds format; kNESDayMYear: date in day/month/year format; kNESMDayYear: date in month/day/year format; kNESHex: hex number. The following attributes can be specified:; kNEAAnyNumber: any number is allowed; kNEANonNegative: only non-negative numbers are allowed; kNEAPositive: only positive numbers are allowed. Explicit limits can be specified individually:; kNELNoLimits: no limits; kNELLimitMin: lower limit only; kNELLimitMax upper limit only; kNELLimitMinMax both lower and upper limits. TGNumberEntryField is a plain vanilla entry field, whereas; TGNumberEntry adds two small buttons to increase and decrease the; numerical value in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGNumberFormat.html:392,down,down,392,root/html528/TGNumberFormat.html,https://root.cern,https://root.cern/root/html528/TGNumberFormat.html,6,['down'],['down']
Availability,". TGPrintDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGPrintDialog. class TGPrintDialog: public TGTransientFrame. TGTextEditDialogs. This file defines several dialogs that are used by the TGTextEdit; widget via its associated context popup menu.; The following dialogs are available: TGSearchDialog, TGGotoDialog; and TGPrintDialog. Function Members (Methods); public:. TGPrintDialog(const TGWindow* p = 0, const TGWindow* main = 0, UInt_t w = 1, UInt_t h = 1, char** printerName = 0, char** printProg = 0, Int_t* ret_code = 0, UInt_t options = kVerticalFrame); virtual~TGPrintDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGPrintDialog.html:466,avail,available,466,root/html528/TGPrintDialog.html,https://root.cern,https://root.cern/root/html528/TGPrintDialog.html,4,['avail'],['available']
Availability,". TGPrintDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGPrintDialog. class TGPrintDialog: public TGTransientFrame. TGTextEditDialogs. This file defines several dialogs that are used by the TGTextEdit; widget via its associated context popup menu.; The following dialogs are available: TGSearchDialog, TGGotoDialog; and TGPrintDialog. Function Members (Methods); public:. virtual~TGPrintDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGPrintDialog.html:466,avail,available,466,root/html602/TGPrintDialog.html,https://root.cern,https://root.cern/root/html602/TGPrintDialog.html,2,['avail'],['available']
Availability,". TGProgressBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGProgressBar. class TGProgressBar: public TGFrame. TGProgressBar, TGHProgressBar and TGVProgressBar. The classes in this file implement progress bars. Progress bars can; be used to show progress of tasks taking more then a few seconds.; TGProgressBar is an abstract base class, use either TGHProgressBar; or TGVProgressBar. TGHProgressBar can in addition show the position; as text in the bar. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGProgressBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGProgressBar.html:775,avail,available,775,root/html528/TGProgressBar.html,https://root.cern,https://root.cern/root/html528/TGProgressBar.html,6,['avail'],['available']
Availability,". TGRowLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGRowLayout. class TGRowLayout: public TGVerticalLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGRowLayout(const TGRowLayout&); TGRowLayout(TGCompositeFrame* main, Int_t s = 0); ~TGRowLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGRowLayout.html:783,down,downward,783,root/html528/TGRowLayout.html,https://root.cern,https://root.cern/root/html528/TGRowLayout.html,4,['down'],['downward']
Availability,". TGRowLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGRowLayout. class TGRowLayout: public TGVerticalLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. virtual~TGRowLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGRowLayout.html:783,down,downward,783,root/html602/TGRowLayout.html,https://root.cern,https://root.cern/root/html602/TGRowLayout.html,2,['down'],['downward']
Availability,". TGSearchDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSearchDialog. class TGSearchDialog: public TGTransientFrame. TGTextEditDialogs. This file defines several dialogs that are used by the TGTextEdit; widget via its associated context popup menu.; The following dialogs are available: TGSearchDialog, TGGotoDialog; and TGPrintDialog. Function Members (Methods); public:. TGSearchDialog(const TGWindow* p = 0, const TGWindow* main = 0, UInt_t w = 1, UInt_t h = 1, TGSearchType* sstruct = 0, Int_t* ret_code = 0, UInt_t options = kVerticalFrame); virtual~TGSearchDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGSearchDialog.html:469,avail,available,469,root/html528/TGSearchDialog.html,https://root.cern,https://root.cern/root/html528/TGSearchDialog.html,4,['avail'],['available']
Availability,". TGSearchDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSearchDialog. class TGSearchDialog: public TGTransientFrame. TGTextEditDialogs. This file defines several dialogs that are used by the TGTextEdit; widget via its associated context popup menu.; The following dialogs are available: TGSearchDialog, TGGotoDialog; and TGPrintDialog. Function Members (Methods); public:. virtual~TGSearchDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGSearchDialog.html:469,avail,available,469,root/html602/TGSearchDialog.html,https://root.cern,https://root.cern/root/html602/TGSearchDialog.html,2,['avail'],['available']
Availability,". TGSearchType. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSearchType. class TGSearchType. TGTextEditDialogs. This file defines several dialogs that are used by the TGTextEdit; widget via its associated context popup menu.; The following dialogs are available: TGSearchDialog, TGGotoDialog; and TGPrintDialog. Function Members (Methods); public:. TGSearchType(); TGSearchType(const TGSearchType&); ~TGSearchType(); TGSearchType&operator=(const TGSearchType&). Data Members; public:. char*fBuffer; Bool_tfCaseSensitive; Bool_tfClose; Bool_tfDirection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGSearchType(); { fDirection = kTRUE; fCaseSensitive = kFALSE; fBuffer = 0; fClose = kTRUE; }. ~TGSearchType(); { if (fBuffer) delete [] fBuffer;}. » Author: Fons Rademakers 10/7/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGTextEditDialogs.h 25499 2008-09-22 19:54:46Z bellenot $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGSearchType.html:412,avail,available,412,root/html528/TGSearchType.html,https://root.cern,https://root.cern/root/html528/TGSearchType.html,1,['avail'],['available']
Availability,". TGSearchType. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSearchType. class TGSearchType. TGTextEditDialogs. This file defines several dialogs that are used by the TGTextEdit; widget via its associated context popup menu.; The following dialogs are available: TGSearchDialog, TGGotoDialog; and TGPrintDialog. Function Members (Methods); public:. TGSearchType(); TGSearchType(const TGSearchType&); ~TGSearchType(); TGSearchType&operator=(const TGSearchType&). Data Members; public:. char*fBuffer; Bool_tfCaseSensitive; Bool_tfClose; Bool_tfDirection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGSearchType(); { fDirection = kTRUE; fCaseSensitive = kFALSE; fBuffer = 0; fClose = kTRUE; }. ~TGSearchType(); { if (fBuffer) delete [] fBuffer;}. » Author: Fons Rademakers 10/7/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGSearchType.html:414,avail,available,414,root/html534/TGSearchType.html,https://root.cern,https://root.cern/root/html534/TGSearchType.html,1,['avail'],['available']
Availability,". TGSearchType. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSearchType. class TGSearchType. TGTextEditDialogs. This file defines several dialogs that are used by the TGTextEdit; widget via its associated context popup menu.; The following dialogs are available: TGSearchDialog, TGGotoDialog; and TGPrintDialog. Function Members (Methods); public:. TGSearchType(); TGSearchType(const TGSearchType&); ~TGSearchType(); TGSearchType&operator=(const TGSearchType&). Data Members; public:. char*fBuffer; Bool_tfCaseSensitive; Bool_tfClose; Bool_tfDirection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGSearchType(); { fDirection = kTRUE; fCaseSensitive = kFALSE; fBuffer = 0; fClose = kTRUE; }. ~TGSearchType(); { if (fBuffer) delete [] fBuffer;}. » Author: Fons Rademakers 10/7/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGTextEditDialogs.h 25499 2008-09-22 19:54:46Z bellenot $ » Last generated: 2011-07-04 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGSearchType.html:414,avail,available,414,root/html530/TGSearchType.html,https://root.cern,https://root.cern/root/html530/TGSearchType.html,1,['avail'],['available']
Availability,". TGSearchType. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSearchType. class TGSearchType. TGTextEditDialogs. This file defines several dialogs that are used by the TGTextEdit; widget via its associated context popup menu.; The following dialogs are available: TGSearchDialog, TGGotoDialog; and TGPrintDialog. Function Members (Methods); public:. TGSearchType(); TGSearchType(const TGSearchType&); ~TGSearchType(); TGSearchType&operator=(const TGSearchType&). Data Members; public:. char*fBuffer; Bool_tfCaseSensitive; Bool_tfClose; Bool_tfDirection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGSearchType(); { fDirection = kTRUE; fCaseSensitive = kFALSE; fBuffer = 0; fClose = kTRUE; }. ~TGSearchType(); { if (fBuffer) delete [] fBuffer;}. » Author: Fons Rademakers 10/7/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGTextEditDialogs.h 40451 2011-08-04 09:58:12Z bellenot $ » Last generated: 2011-11-03 20:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGSearchType.html:414,avail,available,414,root/html532/TGSearchType.html,https://root.cern,https://root.cern/root/html532/TGSearchType.html,1,['avail'],['available']
Availability,". TGSearchType. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSearchType. class TGSearchType. TGTextEditDialogs. This file defines several dialogs that are used by the TGTextEdit; widget via its associated context popup menu.; The following dialogs are available: TGSearchDialog, TGGotoDialog; and TGPrintDialog. Function Members (Methods); public:. ~TGSearchType(); TGSearchType&operator=(const TGSearchType&); TGSearchType(); TGSearchType(const TGSearchType&). Data Members; public:. char*fBuffer; Bool_tfCaseSensitive; Bool_tfClose; Bool_tfDirection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGSearchType(); { fDirection = kTRUE; fCaseSensitive = kFALSE; fBuffer = 0; fClose = kTRUE; }. ~TGSearchType(); { if (fBuffer) delete [] fBuffer;}. » Author: Fons Rademakers 10/7/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGSearchType.html:438,avail,available,438,root/html602/TGSearchType.html,https://root.cern,https://root.cern/root/html602/TGSearchType.html,1,['avail'],['available']
Availability,". TGSearchType. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSearchType. class TGSearchType. TGTextEditDialogs. This file defines several dialogs that are used by the TGTextEdit; widget via its associated context popup menu.; The following dialogs are available: TGSearchDialog, TGGotoDialog; and TGPrintDialog. Function Members (Methods); public:. ~TGSearchType(); TGSearchType&operator=(const TGSearchType&); TGSearchType(); TGSearchType(const TGSearchType&). Data Members; public:. char*fBuffer; Bool_tfCaseSensitive; Bool_tfClose; Bool_tfDirection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGSearchType(); { fDirection = kTRUE; fCaseSensitive = kFALSE; fBuffer = 0; fClose = kTRUE; }. ~TGSearchType(); { if (fBuffer) delete [] fBuffer;}. » Author: Fons Rademakers 10/7/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-09-08 17:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGSearchType.html:438,avail,available,438,root/html604/TGSearchType.html,https://root.cern,https://root.cern/root/html604/TGSearchType.html,1,['avail'],['available']
Availability,". TGSpeedo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSpeedo. class TGSpeedo: public TGFrame, public TGWidget. TGSpeedo. TGSpeedo is a widget looking like a speedometer, with a needle,; a counter and a small odometer window. /*. */; //. Three thresholds are configurable, with their glowing color; A peak mark can be enabled, allowing to keep track of the highest; value displayed. The mark can be reset by right-clicking on the; widget.; Two signals are available:; OdoClicked(): when user click on the small odometer window; LedClicked(): when user click on the small led near the counter. Function Members (Methods); public:. TGSpeedo(const TGWindow* p = 0, int id = -1); TGSpeedo(const TGWindow* p, Float_t smin, Float_t smax, const char* lbl1 = """", const char* lbl2 = """", const char* dsp1 = """", const char* dsp2 = """", int id = -1); virtual~TGSpeedo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBuild(); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGSpeedo.html:644,avail,available,644,root/html528/TGSpeedo.html,https://root.cern,https://root.cern/root/html528/TGSpeedo.html,4,['avail'],['available']
Availability,". TGSpeedo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSpeedo. class TGSpeedo: public TGFrame, public TGWidget. TGSpeedo. TGSpeedo is a widget looking like a speedometer, with a needle,; a counter and a small odometer window. /*. */; //. Three thresholds are configurable, with their glowing color; A peak mark can be enabled, allowing to keep track of the highest; value displayed. The mark can be reset by right-clicking on the; widget.; Two signals are available:; OdoClicked(): when user click on the small odometer window; LedClicked(): when user click on the small led near the counter. Function Members (Methods); public:. virtual~TGSpeedo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBuild(); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGSpeedo.html:644,avail,available,644,root/html602/TGSpeedo.html,https://root.cern,https://root.cern/root/html602/TGSpeedo.html,2,['avail'],['available']
Availability,". TGSplitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGSplitter. class TGSplitter: public TGFrame. TGSplitter, TGVSplitter and TGHSplitter. A splitter allows the frames left and right or above and below of; it to be resized. The frame to be resized must have the kFixedWidth; or kFixedHeight property set. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGSplitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGSplitter.html:630,avail,available,630,root/html528/TGSplitter.html,https://root.cern,https://root.cern/root/html528/TGSplitter.html,6,['avail'],['available']
Availability,". TGTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTable. class TGTable: public TGCompositeFrame, public TGWidget. TGTable. TGTable implements a table widget to display data in rows and; columns. The data is supplied by a TVirtualTableInterface. The table is a TGCanvas to make use of already available viewport; functionality and drawing optimizations. The top left cell in a table has coordinates (0,0). A TObjArray is used internally to ensure little overhead and fast; acces to cells. If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTable.html:484,avail,available,484,root/html602/TGTable.html,https://root.cern,https://root.cern/root/html602/TGTable.html,2,['avail'],['available']
Availability,". TGTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTable. class TGTable: public TGCompositeFrame, public TGWidget. TGTable; ; TGTable implements a table widget to display data in rows and ; columns. The data is supplied by a TVirtualTableInterface. . The table is a TGCanvas to make use of already available viewport ; functionality and drawing optimizations. . The top left cell in a table has coordinates (0,0) . A TObjArray is used internally to ensure little overhead and fast ; acces to cells. . If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate ; TVirtualTableInterface from the data that needs visualization and ; then creating the TGTable using this interface. . A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTable.html:489,avail,available,489,root/html528/TGTable.html,https://root.cern,https://root.cern/root/html528/TGTable.html,3,['avail'],['available']
Availability,". TGTileLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTileLayout. class TGTileLayout: public TGLayoutManager. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGTileLayout(TGCompositeFrame* main, Int_t sep = 0); ~TGTileLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTileLayout.html:785,down,downward,785,root/html528/TGTileLayout.html,https://root.cern,https://root.cern/root/html528/TGTileLayout.html,4,['down'],['downward']
Availability,". TGTileLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGTileLayout. class TGTileLayout: public TGLayoutManager. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. virtual~TGTileLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTileLayout.html:785,down,downward,785,root/html602/TGTileLayout.html,https://root.cern,https://root.cern/root/html602/TGTileLayout.html,2,['down'],['downward']
Availability,". TGUnknownWindowHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGUnknownWindowHandler. class TGUnknownWindowHandler: public TObject. TGWindow. ROOT GUI Window base class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGUnknownWindowHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGUnknownWindowHandler.html:497,avail,available,497,root/html528/TGUnknownWindowHandler.html,https://root.cern,https://root.cern/root/html528/TGUnknownWindowHandler.html,6,['avail'],['available']
Availability,". TGVerticalLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGVerticalLayout. class TGVerticalLayout: public TGLayoutManager. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGVerticalLayout(TGCompositeFrame* main); ~TGVerticalLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGVerticalLayout.html:797,down,downward,797,root/html528/TGVerticalLayout.html,https://root.cern,https://root.cern/root/html528/TGVerticalLayout.html,4,['down'],['downward']
Availability,". TGVerticalLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGVerticalLayout. class TGVerticalLayout: public TGLayoutManager. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. virtual~TGVerticalLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGVerticalLayout.html:797,down,downward,797,root/html602/TGVerticalLayout.html,https://root.cern,https://root.cern/root/html602/TGVerticalLayout.html,2,['down'],['downward']
Availability,". TGedFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedFrame. class TGedFrame: public TGCompositeFrame. TGedFrame. Base frame for implementing GUI - a service class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGedFrame(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidActivateBaseClassEditors(TClass* cl); virtual voidAddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGedFrame.html:491,avail,available,491,root/html528/TGedFrame.html,https://root.cern,https://root.cern/root/html528/TGedFrame.html,6,['avail'],['available']
Availability,". TGedMarkerPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedMarkerPopup. class TGedMarkerPopup: public TGedPopup. TGedMarkerSelect, TGedMarkerPopup. The TGedMarkerPopup is a popup containing buttons to; select marker style. The TGedMarkerSelect widget is a button showing selected marker; and a little down arrow. When clicked on the arrow the; TGedMarkerPopup pops up. Selecting a marker in this widget will generate the event:; kC_MARKERSEL, kMAR_SELCHANGED, widget id, style. and the signal:; MarkerSelected(Style_t marker). Function Members (Methods); public:. TGedMarkerPopup(const TGWindow* p, const TGWindow* m, Style_t markerStyle); virtual~TGedMarkerPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGedMarkerPopup.html:494,down,down,494,root/html528/TGedMarkerPopup.html,https://root.cern,https://root.cern/root/html528/TGedMarkerPopup.html,4,['down'],['down']
Availability,". TGedMarkerPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedMarkerPopup. class TGedMarkerPopup: public TGedPopup. TGedMarkerSelect, TGedMarkerPopup. The TGedMarkerPopup is a popup containing buttons to; select marker style. The TGedMarkerSelect widget is a button showing selected marker; and a little down arrow. When clicked on the arrow the; TGedMarkerPopup pops up. Selecting a marker in this widget will generate the event:; kC_MARKERSEL, kMAR_SELCHANGED, widget id, style. and the signal:; MarkerSelected(Style_t marker). Function Members (Methods); public:. virtual~TGedMarkerPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGedMarkerPopup.html:494,down,down,494,root/html602/TGedMarkerPopup.html,https://root.cern,https://root.cern/root/html602/TGedMarkerPopup.html,2,['down'],['down']
Availability,". TGedMarkerSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedMarkerSelect. class TGedMarkerSelect: public TGedSelect. TGedMarkerSelect, TGedMarkerPopup. The TGedMarkerPopup is a popup containing buttons to; select marker style. The TGedMarkerSelect widget is a button showing selected marker; and a little down arrow. When clicked on the arrow the; TGedMarkerPopup pops up. Selecting a marker in this widget will generate the event:; kC_MARKERSEL, kMAR_SELCHANGED, widget id, style. and the signal:; MarkerSelected(Style_t marker). Function Members (Methods); public:. TGedMarkerSelect(const TGWindow* p, Style_t markerStyle, Int_t id); virtual~TGedMarkerSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGedMarkerSelect.html:498,down,down,498,root/html528/TGedMarkerSelect.html,https://root.cern,https://root.cern/root/html528/TGedMarkerSelect.html,4,['down'],['down']
Availability,". TGedMarkerSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedMarkerSelect. class TGedMarkerSelect: public TGedSelect. TGedMarkerSelect, TGedMarkerPopup. The TGedMarkerPopup is a popup containing buttons to; select marker style. The TGedMarkerSelect widget is a button showing selected marker; and a little down arrow. When clicked on the arrow the; TGedMarkerPopup pops up. Selecting a marker in this widget will generate the event:; kC_MARKERSEL, kMAR_SELCHANGED, widget id, style. and the signal:; MarkerSelected(Style_t marker). Function Members (Methods); public:. virtual~TGedMarkerSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGedMarkerSelect.html:498,down,down,498,root/html602/TGedMarkerSelect.html,https://root.cern,https://root.cern/root/html602/TGedMarkerSelect.html,2,['down'],['down']
Availability,". TGedPatternFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPatternFrame. class TGedPatternFrame: public TGFrame. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedPatternFrame(const TGWindow* p, Style_t pattern, Int_t width = 40, Int_t height = 20); virtual~TGedPatternFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGedPatternFrame.html:710,down,down,710,root/html528/TGedPatternFrame.html,https://root.cern,https://root.cern/root/html528/TGedPatternFrame.html,4,['down'],['down']
Availability,". TGedPatternFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPatternFrame. class TGedPatternFrame: public TGFrame. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. virtual~TGedPatternFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGedPatternFrame.html:710,down,down,710,root/html602/TGedPatternFrame.html,https://root.cern,https://root.cern/root/html602/TGedPatternFrame.html,2,['down'],['down']
Availability,". TGedPatternPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPatternPopup. class TGedPatternPopup: public TGedPopup. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedPatternPopup(const TGWindow* p, const TGWindow* m, Style_t pattern); virtual~TGedPatternPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Clea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGedPatternPopup.html:712,down,down,712,root/html528/TGedPatternPopup.html,https://root.cern,https://root.cern/root/html528/TGedPatternPopup.html,4,['down'],['down']
Availability,". TGedPatternPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPatternPopup. class TGedPatternPopup: public TGedPopup. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. virtual~TGedPatternPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGedPatternPopup.html:712,down,down,712,root/html602/TGedPatternPopup.html,https://root.cern,https://root.cern/root/html602/TGedPatternPopup.html,2,['down'],['down']
Availability,". TGedPatternSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPatternSelect. class TGedPatternSelect: public TGedSelect. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedPatternSelect(const TGWindow* p, Style_t pattern, Int_t id); virtual~TGedPatternSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGedPatternSelect.html:716,down,down,716,root/html528/TGedPatternSelect.html,https://root.cern,https://root.cern/root/html528/TGedPatternSelect.html,4,['down'],['down']
Availability,". TGedPatternSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPatternSelect. class TGedPatternSelect: public TGedSelect. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. virtual~TGedPatternSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGedPatternSelect.html:716,down,down,716,root/html602/TGedPatternSelect.html,https://root.cern,https://root.cern/root/html602/TGedPatternSelect.html,2,['down'],['down']
Availability,". TGedPatternSelector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPatternSelector. class TGedPatternSelector: public TGCompositeFrame. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedPatternSelector(const TGWindow* p); virtual~TGedPatternSelector(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGedPatternSelector.html:728,down,down,728,root/html528/TGedPatternSelector.html,https://root.cern,https://root.cern/root/html528/TGedPatternSelector.html,4,['down'],['down']
Availability,". TGedPatternSelector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPatternSelector. class TGedPatternSelector: public TGCompositeFrame. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. virtual~TGedPatternSelector(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGedPatternSelector.html:728,down,down,728,root/html602/TGedPatternSelector.html,https://root.cern,https://root.cern/root/html602/TGedPatternSelector.html,2,['down'],['down']
Availability,". TGedPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPopup. class TGedPopup: public TGCompositeFrame. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedPopup(const TGWindow* p, const TGWindow* m, UInt_t w, UInt_t h, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); virtual~TGedPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGedPopup.html:698,down,down,698,root/html528/TGedPopup.html,https://root.cern,https://root.cern/root/html528/TGedPopup.html,4,['down'],['down']
Availability,". TGedPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPopup. class TGedPopup: public TGCompositeFrame. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. virtual~TGedPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGedPopup.html:698,down,down,698,root/html602/TGedPopup.html,https://root.cern,https://root.cern/root/html602/TGedPopup.html,2,['down'],['down']
Availability,". TGedSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedSelect. class TGedSelect: public TGCheckButton. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedSelect(const TGWindow* p, Int_t id); virtual~TGedSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGedSelect.html:698,down,down,698,root/html528/TGedSelect.html,https://root.cern,https://root.cern/root/html528/TGedSelect.html,4,['down'],['down']
Availability,". TGedSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedSelect. class TGedSelect: public TGCheckButton. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. virtual~TGedSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TObject::Clone(const char* n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGedSelect.html:698,down,down,698,root/html602/TGedSelect.html,https://root.cern,https://root.cern/root/html602/TGedSelect.html,2,['down'],['down']
Availability,". TGeoExtension. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoExtension. class TGeoExtension: public TObject. TGeoExtension - ABC for user objects attached to TGeoVolume or TGeoNode.; Provides interface for getting a reference (grab) and; releasing the extension object (release), allowing for; derived classes to implement reference counted sharing.; The user who should attach extensions to logical volumes; or nodes BEFORE applying misalignment information so that; these will be available to all copies. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoExtension.html:673,avail,available,673,root/html534/TGeoExtension.html,https://root.cern,https://root.cern/root/html534/TGeoExtension.html,6,['avail'],['available']
Availability,". TGeoGedFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoGedFrame. class TGeoGedFrame: public TGedFrame. TGeoGedFrame. Common base class for geombuilder editors. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoGedFrame(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoGedFrame.html:497,avail,available,497,root/html602/TGeoGedFrame.html,https://root.cern,https://root.cern/root/html602/TGeoGedFrame.html,2,['avail'],['available']
Availability,". TGeoGedFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoGedFrame. class TGeoGedFrame: public TGedFrame. TGeoGedFrame. Common base class for geombuilder editors. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGeoGedFrame(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoGedFrame.html:497,avail,available,497,root/html528/TGeoGedFrame.html,https://root.cern,https://root.cern/root/html528/TGeoGedFrame.html,4,['avail'],['available']
Availability,". TGeoNavigator::TGeoNavigator ; (; const TGeoNavigator & ; ). protecteddelete . ◆ TGeoNavigator() [2/3]. TGeoNavigator::TGeoNavigator ; (; ). global mode is caching enabled for parallel world safety calls ; Constructor. ; Definition at line 57 of file TGeoNavigator.cxx. ◆ TGeoNavigator() [3/3]. TGeoNavigator::TGeoNavigator ; (; TGeoManager * ; geom). Constructor. ; Definition at line 109 of file TGeoNavigator.cxx. ◆ ~TGeoNavigator(). TGeoNavigator::~TGeoNavigator ; (; ). override . Destructor. ; Definition at line 169 of file TGeoNavigator.cxx. Member Function Documentation. ◆ BuildCache(). void TGeoNavigator::BuildCache ; (; Bool_t ; dummy = kFALSE, . Bool_t ; nodeid = kFALSE . ). Builds the cache for physical nodes and global matrices. ; Definition at line 182 of file TGeoNavigator.cxx. ◆ cd(). Bool_t TGeoNavigator::cd ; (; const char * ; path = """"). Browse the tree of nodes starting from top node according to pathname. ; Changes the path accordingly. The path is changed to point to the top node in case of failure. ; Definition at line 210 of file TGeoNavigator.cxx. ◆ CdDown() [1/2]. void TGeoNavigator::CdDown ; (; Int_t ; index). Make a daughter of current node current. ; Can be called only with a valid daughter index (no check). Updates cache accordingly. ; Definition at line 313 of file TGeoNavigator.cxx. ◆ CdDown() [2/2]. void TGeoNavigator::CdDown ; (; TGeoNode * ; node). Make a daughter of current node current. ; Can be called only with a valid daughter node (no check). Updates cache accordingly. ; Definition at line 333 of file TGeoNavigator.cxx. ◆ CdNext(). void TGeoNavigator::CdNext ; (; ). Do a cd to the node found next by FindNextBoundary. ; Definition at line 405 of file TGeoNavigator.cxx. ◆ CdNode(). void TGeoNavigator::CdNode ; (; Int_t ; nodeid). Change current path to point to the node having this id. ; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons) ; Definition at line 301 of file TGeoNavigator.cxx. ◆ CdTop(). void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:23439,failure,failure,23439,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['failure'],['failure']
Availability,". TGeoRCExtension. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRCExtension. class TGeoRCExtension: public TGeoExtension. TGeoExtension - ABC for user objects attached to TGeoVolume or TGeoNode.; Provides interface for getting a reference (grab) and; releasing the extension object (release), allowing for; derived classes to implement reference counted sharing.; The user who should attach extensions to logical volumes; or nodes BEFORE applying misalignment information so that; these will be available to all copies. Function Members (Methods); public:. TGeoRCExtension(); TGeoRCExtension(TObject* obj); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoRCExtension.html:685,avail,available,685,root/html534/TGeoRCExtension.html,https://root.cern,https://root.cern/root/html534/TGeoRCExtension.html,1,['avail'],['available']
Availability,". TGeoRCExtension. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRCExtension. class TGeoRCExtension: public TGeoExtension. TGeoExtension - ABC for user objects attached to TGeoVolume or TGeoNode.; Provides interface for getting a reference (grab) and; releasing the extension object (release), allowing for; derived classes to implement reference counted sharing.; The user who should attach extensions to logical volumes; or nodes BEFORE applying misalignment information so that; these will be available to all copies. Function Members (Methods); public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoRCExtension.html:685,avail,available,685,root/html602/TGeoRCExtension.html,https://root.cern,https://root.cern/root/html602/TGeoRCExtension.html,2,['avail'],['available']
Availability,". TGeoSphere(Double_t rmin, Double_t rmax, Double_t theta1 = 0, Double_t theta2 = 180, Double_t phi1 = 0, Double_t phi2 = 360); Default constructor specifying minimum and maximum radius. TGeoSphere(const char* name, Double_t rmin, Double_t rmax, Double_t theta1 = 0, Double_t theta2 = 180, Double_t phi1 = 0, Double_t phi2 = 360); Default constructor specifying minimum and maximum radius. TGeoSphere(Double_t* param, Int_t nparam = 6); Default constructor specifying minimum and maximum radius; param[0] = Rmin; param[1] = Rmax; param[2] = theta1; param[3] = theta2; param[4] = phi1; param[5] = phi2. ~TGeoSphere(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the sphere; Double_t xmin, xmax, ymin, ymax, zmin, zmax;. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Int_t IsOnBoundary(const Double_t* point) const; Check if a point in local sphere coordinates is close to a boundary within; shape tolerance. Return values:; 0 - not close to boundary; 1 - close to Rmin boundary; 2 - close to Rmax boundary; 3,4 - close to phi1/phi2 boundary; 5,6 - close to theta1/theta2 boundary. Bool_t IsPointInside(const Double_t* point, Bool_t checkR = kTRUE, Bool_t checkTh = kTRUE, Bool_t checkPh = kTRUE) const; Check if a point is inside radius/theta/phi ranges for the spherical sector. Bool_t Contains(const Double_t* point) const; test if point is inside this sphere; check Rmin<=R<=Rmax. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the sphere; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoSphere.html:14446,toler,tolerance,14446,root/html534/TGeoSphere.html,https://root.cern,https://root.cern/root/html534/TGeoSphere.html,3,['toler'],['tolerance']
Availability,". TGraph2DErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraph2DErrors. class TGraph2DErrors: public TGraph2D. Graph 2D class with errors; A TGraph2DErrors is a TGraph2D with errors. It behaves like a TGraph2D and has; the same drawing options. The ""ERR"" drawing option allows to display the error bars. The; following example shows how to use it:. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Graph2DErrors example"",0,0,600,600);; Double_t P = 6.;; Int_t np = 200;. Double_t *rx=0, *ry=0, *rz=0;; Double_t *ex=0, *ey=0, *ez=0;. rx = new Double_t[np];; ry = new Double_t[np];; rz = new Double_t[np];; ex = new Double_t[np];; ey = new Double_t[np];; ez = new Double_t[np];. TRandom *r = new TRandom();. for (Int_t N=0; N<np;N++) {; rx[N] = 2*P*(r->Rndm(N))-P;; ry[N] = 2*P*(r->Rndm(N))-P;; rz[N] = rx[N]*rx[N]-ry[N]*ry[N];; rx[N] = 10.+rx[N];; ry[N] = 10.+ry[N];; rz[N] = 40.+rz[N];; ex[N] = r->Rndm(N);; ey[N] = r->Rndm(N);; ez[N] = 10*r->Rndm(N);; }. TGraph2DErrors *dte = new TGraph2DErrors(np, rx, ry, rz, ex, ey, ez);; dte->SetTitle(""TGraph2D with error bars: option \""ERR\"""");; dte->SetFillColor(29);; dte->SetMarkerSize(0.8);; dte->SetMarkerStyle(20);; dte->SetMarkerColor(kRed);; dte->SetLineColor(kBlue-3);; dte->SetLineWidth(2);; dte->Draw(""err p0"");; gPad->SetLogy(1);; return c;; }. Function Members (Methods); public:. TGraph2DErrors(); TGraph2DErrors(Int_t n); TGraph2DErrors(Int_t n, Double_t* x, Double_t* y, Double_t* z, Double_t* ex = 0, Double_t* ey = 0, Double_t* ez = 0, Option_t* option = """"); virtual~TGraph2DErrors(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGraph2D::Clear(Option_t* op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGraph2DErrors.html:324,error,errors,324,root/html530/TGraph2DErrors.html,https://root.cern,https://root.cern/root/html530/TGraph2DErrors.html,6,['error'],"['error', 'errors']"
Availability,". TGraph2DErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraph2DErrors. class TGraph2DErrors: public TGraph2D. Graph 2D class with errors; A TGraph2DErrors is a TGraph2D with errors. It behaves like a TGraph2D and has; the same drawing options. The ""ERR"" drawing option allows to display the error bars. The; following example shows how to use it:. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Graph2DErrors example"",0,0,600,600);; Double_t P = 6.;; Int_t np = 200;. Double_t *rx=0, *ry=0, *rz=0;; Double_t *ex=0, *ey=0, *ez=0;. rx = new Double_t[np];; ry = new Double_t[np];; rz = new Double_t[np];; ex = new Double_t[np];; ey = new Double_t[np];; ez = new Double_t[np];. TRandom *r = new TRandom();. for (Int_t N=0; N<np;N++) {; rx[N] = 2*P*(r->Rndm(N))-P;; ry[N] = 2*P*(r->Rndm(N))-P;; rz[N] = rx[N]*rx[N]-ry[N]*ry[N];; rx[N] = 10.+rx[N];; ry[N] = 10.+ry[N];; rz[N] = 40.+rz[N];; ex[N] = r->Rndm(N);; ey[N] = r->Rndm(N);; ez[N] = 10*r->Rndm(N);; }. TGraph2DErrors *dte = new TGraph2DErrors(np, rx, ry, rz, ex, ey, ez);; dte->SetTitle(""TGraph2D with error bars: option \""ERR\"""");; dte->SetFillColor(29);; dte->SetMarkerSize(0.8);; dte->SetMarkerStyle(20);; dte->SetMarkerColor(kRed);; dte->SetLineColor(kBlue-3);; dte->SetLineWidth(2);; dte->Draw(""err p0"");; gPad->SetLogy(1);; return c;; }. Function Members (Methods); public:. TGraph2DErrors(); TGraph2DErrors(Int_t n); TGraph2DErrors(const TGraph2DErrors&); TGraph2DErrors(Int_t n, Double_t* x, Double_t* y, Double_t* z, Double_t* ex = 0, Double_t* ey = 0, Double_t* ez = 0, Option_t* option = """"); virtual~TGraph2DErrors(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGraph2D::Browse(TBrowser*); static TClass*Class(); virtual const char*TObject::ClassName() const; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraph2DErrors.html:324,error,errors,324,root/html534/TGraph2DErrors.html,https://root.cern,https://root.cern/root/html534/TGraph2DErrors.html,3,['error'],"['error', 'errors']"
Availability,". TGraph2DErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraph2DErrors. class TGraph2DErrors: public TGraph2D. Graph 2D class with errors; A TGraph2DErrors is a TGraph2D with errors. It behaves like a TGraph2D and has; the same drawing options. The ""ERR"" drawing option allows to display the error bars. The; following example shows how to use it:. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Graph2DErrors example"",0,0,600,600);; Double_t P = 6.;; Int_t np = 200;. Double_t *rx=0, *ry=0, *rz=0;; Double_t *ex=0, *ey=0, *ez=0;. rx = new Double_t[np];; ry = new Double_t[np];; rz = new Double_t[np];; ex = new Double_t[np];; ey = new Double_t[np];; ez = new Double_t[np];. TRandom *r = new TRandom();. for (Int_t N=0; N<np;N++) {; rx[N] = 2*P*(r->Rndm(N))-P;; ry[N] = 2*P*(r->Rndm(N))-P;; rz[N] = rx[N]*rx[N]-ry[N]*ry[N];; rx[N] = 10.+rx[N];; ry[N] = 10.+ry[N];; rz[N] = 40.+rz[N];; ex[N] = r->Rndm(N);; ey[N] = r->Rndm(N);; ez[N] = 10*r->Rndm(N);; }. TGraph2DErrors *dte = new TGraph2DErrors(np, rx, ry, rz, ex, ey, ez);; dte->SetTitle(""TGraph2D with error bars: option \""ERR\"""");; dte->SetFillColor(29);; dte->SetMarkerSize(0.8);; dte->SetMarkerStyle(20);; dte->SetMarkerColor(kRed);; dte->SetLineColor(kBlue-3);; dte->SetLineWidth(2);; dte->Draw(""err p0"");; gPad->SetLogy(1);; return c;; }. Function Members (Methods); public:. virtual~TGraph2DErrors(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGraph2D::Browse(TBrowser*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGraph2D::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraph2DErrors.html:324,error,errors,324,root/html602/TGraph2DErrors.html,https://root.cern,https://root.cern/root/html602/TGraph2DErrors.html,6,['error'],"['error', 'errors']"
Availability,". TGraphAsymmErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphAsymmErrors. class TGraphAsymmErrors: public TGraph. TGraphAsymmErrors class; A TGraphAsymmErrors is a TGraph with assymetric error bars. The TGraphAsymmErrors painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with assymetric error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. TGraphAsymmErrors(); TGraphAsymmErrors(Int_t n); TGraphAsymmErrors(const TGraphAsymmErrors& gr); TGraphAsymmErrors(const TH1* h); TGraphAsymmErrors(const TH1* pass, const TH1* total, Option_t* option = """"); TGraphAsymmErrors(const TVectorF& vx, const TVectorF& vy, const TVectorF& vexl, const TVectorF& vexh, const TVectorF& veyl, const TVectorF& veyh); TGraphAsymmErrors(const TVectorD& vx, const TVectorD& vy, const TVectorD& vexl, const TVectorD& vexh, const TVectorD& veyl, const TVectorD& veyh); TGraphAsymmErrors(Int_t n, const Float_t* x, const Float_t* y, const Float_t* exl = 0, const Float_t* exh = 0, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphAsymmErrors.html:384,error,error,384,root/html534/TGraphAsymmErrors.html,https://root.cern,https://root.cern/root/html534/TGraphAsymmErrors.html,2,['error'],['error']
Availability,". TGraphAsymmErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphAsymmErrors. class TGraphAsymmErrors: public TGraph. TGraphAsymmErrors class; A TGraphAsymmErrors is a TGraph with assymetric error bars. The TGraphAsymmErrors painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with assymetric error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. virtual~TGraphAsymmErrors(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(TF1* f); virtual voidBayesDivide(const TH1* pass, const TH1* total, Option_t* opt = """"); virtual voidTGraph::Browse(TBrowser* b); virtual Double_tTGraph::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; static Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphAsymmErrors.html:384,error,error,384,root/html602/TGraphAsymmErrors.html,https://root.cern,https://root.cern/root/html602/TGraphAsymmErrors.html,4,['error'],['error']
Availability,". TGraphAsymmErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphAsymmErrors. class TGraphAsymmErrors: public TGraph. TGraphAsymmErrors class; A TGraphAsymmErrors is a TGraph with assymetric error bars. The TGraphAsymmErrors painting is permofed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with assymetric error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. TGraphAsymmErrors(); TGraphAsymmErrors(Int_t n); TGraphAsymmErrors(const TGraphAsymmErrors& gr); TGraphAsymmErrors(const TH1* h); TGraphAsymmErrors(const TH1* pass, const TH1* total, Option_t* option = """"); TGraphAsymmErrors(const TVectorF& vx, const TVectorF& vy, const TVectorF& vexl, const TVectorF& vexh, const TVectorF& veyl, const TVectorF& veyh); TGraphAsymmErrors(const TVectorD& vx, const TVectorD& vy, const TVectorD& vexl, const TVectorD& vexh, const TVectorD& veyl, const TVectorD& veyh); TGraphAsymmErrors(Int_t n, const Float_t* x, const Float_t* y, const Float_t* exl = 0, const Float_t* exh = 0, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphAsymmErrors.html:384,error,error,384,root/html528/TGraphAsymmErrors.html,https://root.cern,https://root.cern/root/html528/TGraphAsymmErrors.html,6,['error'],['error']
Availability,". TGraphBentErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphBentErrors. class TGraphBentErrors: public TGraph. TGraphBentErrors class; A TGraphBentErrors is a TGraph with bent, assymetric error bars. The TGraphBentErrors painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with bent error bars"",200,10,700,500);; Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. TGraphBentErrors(); TGraphBentErrors(Int_t n); TGraphBentErrors(const TGraphBentErrors& gr); TGraphBentErrors(Int_t n, const Float_t* x, const Float_t* y, const Float_t* exl = 0, const Float_t* exh = 0, const Float_t* eyl = 0, const Float_t* eyh = 0, const Float_t* exld = 0, const Float_t* exhd = 0, const Float_t* eyld = 0, const Float_t* eyhd = 0); TGraphBentErrors(Int_t n, const Double_t* x, const Double_t* y, const Double_t* exl = 0, const Double_t* exh = 0, const Double_t* eyl = 0, const D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphBentErrors.html:385,error,error,385,root/html534/TGraphBentErrors.html,https://root.cern,https://root.cern/root/html534/TGraphBentErrors.html,2,['error'],['error']
Availability,". TGraphBentErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphBentErrors. class TGraphBentErrors: public TGraph. TGraphBentErrors class; A TGraphBentErrors is a TGraph with bent, assymetric error bars. The TGraphBentErrors painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with bent error bars"",200,10,700,500);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. virtual~TGraphBentErrors(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(TF1* f); virtual voidTGraph::Browse(TBrowser* b); virtual Double_tTGraph::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphBentErrors.html:385,error,error,385,root/html602/TGraphBentErrors.html,https://root.cern,https://root.cern/root/html602/TGraphBentErrors.html,4,['error'],['error']
Availability,". TGraphBentErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphBentErrors. class TGraphBentErrors: public TGraph. TGraphBentErrors class; A TGraphBentErrors is a TGraph with bent, assymetric error bars. The TGraphBentErrors painting is permofed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with bent error bars"",200,10,700,500);; Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. TGraphBentErrors(); TGraphBentErrors(Int_t n); TGraphBentErrors(const TGraphBentErrors& gr); TGraphBentErrors(Int_t n, const Float_t* x, const Float_t* y, const Float_t* exl = 0, const Float_t* exh = 0, const Float_t* eyl = 0, const Float_t* eyh = 0, const Float_t* exld = 0, const Float_t* exhd = 0, const Float_t* eyld = 0, const Float_t* eyhd = 0); TGraphBentErrors(Int_t n, const Double_t* x, const Double_t* y, const Double_t* exl = 0, const Double_t* exh = 0, const Double_t* eyl = 0, const Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphBentErrors.html:385,error,error,385,root/html528/TGraphBentErrors.html,https://root.cern,https://root.cern/root/html528/TGraphBentErrors.html,6,['error'],['error']
Availability,". TGraphErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphErrors. class TGraphErrors: public TGraph. TGraphErrors class; A TGraphErrors is a TGraph with error bars. The TGraphErrors painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. TGraphErrors(); TGraphErrors(Int_t n); TGraphErrors(const TGraphErrors& gr); TGraphErrors(const TH1* h); TGraphErrors(const char* filename, const char* format = ""%lg %lg %lg %lg"", Option_t* option = """"); TGraphErrors(const TVectorF& vx, const TVectorF& vy, const TVectorF& vex, const TVectorF& vey); TGraphErrors(const TVectorD& vx, const TVectorD& vy, const TVectorD& vex, const TVectorD& vey); TGraphErrors(Int_t n, const Float_t* x, const Float_t* y, const Float_t* ex = 0, const Float_t* ey = 0); TGraphErrors(Int_t n, const Double_t* x, const Double_t* y, const Double_t* ex = 0, const Double_t* ey = 0); virtual~TGraphErrors(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(TF1* f); virtual voidTGraph::Browse(TBro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphErrors.html:348,error,error,348,root/html534/TGraphErrors.html,https://root.cern,https://root.cern/root/html534/TGraphErrors.html,2,['error'],['error']
Availability,". TGraphErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphErrors. class TGraphErrors: public TGraph. TGraphErrors class; A TGraphErrors is a TGraph with error bars. The TGraphErrors painting is performed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. virtual~TGraphErrors(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(TF1* f); virtual voidTGraph::Browse(TBrowser* b); static Int_tCalculateScanfFields(const char* fmt); virtual Double_tTGraph::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; static Bool_tTGraph::CompareArg(const TGraph* gr, Int_t left, Int_t right); static Bool_tTGraph::CompareRadius(const TGraph* gr, Int_t left, Int_t right); static Bool_tTGraph::CompareX(const TGraph* gr, Int_t left, Int_t right); st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphErrors.html:348,error,error,348,root/html602/TGraphErrors.html,https://root.cern,https://root.cern/root/html602/TGraphErrors.html,4,['error'],['error']
Availability,". TGraphErrors. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TGraphErrors. class TGraphErrors: public TGraph. TGraphErrors class; A TGraphErrors is a TGraph with error bars. The TGraphErrors painting is permofed thanks to the; TGraphPainter; class. All details about the various painting options are given in; this class. The picture below gives an example:. Picture; Source. {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; return c1;; } . Function Members (Methods); public:. TGraphErrors(); TGraphErrors(Int_t n); TGraphErrors(const TGraphErrors& gr); TGraphErrors(const TH1* h); TGraphErrors(const char* filename, const char* format = ""%lg %lg %lg %lg"", Option_t* option = """"); TGraphErrors(const TVectorF& vx, const TVectorF& vy, const TVectorF& vex, const TVectorF& vey); TGraphErrors(const TVectorD& vx, const TVectorD& vy, const TVectorD& vex, const TVectorD& vey); TGraphErrors(Int_t n, const Float_t* x, const Float_t* y, const Float_t* ex = 0, const Float_t* ey = 0); TGraphErrors(Int_t n, const Double_t* x, const Double_t* y, const Double_t* ex = 0, const Double_t* ey = 0); virtual~TGraphErrors(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidApply(TF1* f); virtual voidTGraph::Browse(TBrow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphErrors.html:348,error,error,348,root/html528/TGraphErrors.html,https://root.cern,https://root.cern/root/html528/TGraphErrors.html,6,['error'],['error']
Availability,". TGraphPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HISTPAINTER; » TGraphPainter. class TGraphPainter: public TVirtualGraphPainter. The graph painter class. Introduction; Graphs' plotting options; Exclusion graphs; Graphs with error bars. TGraphErrors; TGraphAsymmErrors; TGraphBentErrors. TGraphPolar options. Introduction; Graphs are drawn via the painter TGraphPainter class. This class; implement all the various techniques need to display the various kind of; graphs ie: TGraph, TGraphAsymmErrors,; TGraphBentErrors and TGraphErrors. To draw a graph ""g"" is enough to do:. g->Draw(""AL"");. The option ""AL"" in the Draw() method means that the axis; syetem should be define (option ""A"") and that the graph should; be drawn as a simple line (option ""L""). By default a graph is drawn; in the current pad in the current coordinates system. To define a suitable; coordinates system and drawn the axis the option ""A"" must be; specified. TGraphPainter offers many options to paint the various kind of graphs. The TGraphPainter class specializes in the drawing of graphs. It is; separated from the graph so that one can have graphs without the; graphics overhead, for example in a batch program. When a displayed graph is modified, there is not need to call the; Draw() method again; the image will be refreshed the next time the; pad will be updated.; A pad is updated after one of these three actions:. a carriage control on the ROOT command line,; a click inside the pad,; a call to TPad::Update. Graphs' plotting options; Graphs can be drawn with the following options:. ""A""; Axis are drawn around the graph. ""L""; A simple polyline between every points is drawn. ""F""; A fill area is drawn ('CF' draw a smooth fill area). ""C""; A smooth Curve is drawn. ""*""; A Star is plotted at each point. ""P""; Idem with the current",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphPainter.html:415,error,error,415,root/html528/TGraphPainter.html,https://root.cern,https://root.cern/root/html528/TGraphPainter.html,2,['error'],['error']
Availability,". TGraphPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HISTPAINTER; » TGraphPainter. class TGraphPainter: public TVirtualGraphPainter. The graph painter class. Introduction; Graphs' plotting options; Exclusion graphs; Graphs with error bars. TGraphErrors; TGraphAsymmErrors; TGraphBentErrors. TGraphPolar options. Introduction; Graphs are drawn via the painter TGraphPainter class. This class; implements techniques needed to display the various kind of; graphs i.e.: TGraph, TGraphErrors,; TGraphBentErrors and TGraphAsymmErrors. To draw a graph ""graph"" it's enough to do:. graph->Draw(""AL"");. The option ""AL"" in the Draw() method means:. The axis should be drawn (option ""A""),; The graph should be drawn as a simple line (option ""L""). By default a graph is drawn in the current pad in the current coordinate system.; To define a suitable coordinate system and draw the axis the option; ""A"" must be specified. TGraphPainter offers many options to paint the various kind of graphs. It is separated from the graph classes so that one can have graphs without the; graphics overhead, for example in a batch program. When a displayed graph is modified, there is no need to call; Draw() again; the image will be refreshed the next time the; pad will be updated.; A pad is updated after one of these three actions:. a carriage return on the ROOT command line,; a click inside the pad,; a call to TPad::Update. Graphs' plotting options; Graphs can be drawn with the following options:. ""A""; Axis are drawn around the graph. ""L""; A simple polyline is drawn. ""F""; A fill area is drawn ('CF' draw a smoothed fill area). ""C""; A smooth Curve is drawn. ""*""; A Star is plotted at each point. ""P""; The current marker is plotted at each point. ""B""; A Bar chart is drawn. ""1""; When a graph is drawn as a bar chart, this option makes ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraphPainter.html:415,error,error,415,root/html532/TGraphPainter.html,https://root.cern,https://root.cern/root/html532/TGraphPainter.html,4,['error'],['error']
Availability,". TGraphPolar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TGraphPolar. class TGraphPolar: public TGraphErrors. TGraphPolar : to draw a polar graph; TGraphPolar creates a polar graph (including error bars). A TGraphPolar is; a TGraphErrors represented in polar coordinates.; It uses the class TGraphPolargram to draw the polar axis. Example:. Picture; Source. {; TCanvas * CPol = new TCanvas(""CPol"",""TGraphPolar Example"",500,500);. Double_t theta[8];; Double_t radius[8];; Double_t etheta[8];; Double_t eradius[8];. for (int i=0; i<8; i++) {; theta[i] = (i+1)*(TMath::Pi()/4.);; radius[i] = (i+1)*0.05; ; etheta[i] = TMath::Pi()/8.;; eradius[i] = 0.05; ; }. TGraphPolar * grP1 = new TGraphPolar(8, theta, radius, etheta, eradius);; grP1->SetTitle(""TGraphPolar Example"");. grP1->SetMarkerStyle(20);; grP1->SetMarkerSize(2.);; grP1->SetMarkerColor(4);; grP1->SetLineColor(2);; grP1->SetLineWidth(3);; grP1->Draw(""PE"");. // Update, otherwise GetPolargram returns 0; CPol->Update();; grP1->GetPolargram()->SetToRadian();. return CPol;; } . Function Members (Methods); public:. TGraphPolar(); TGraphPolar(const TGraphPolar&); TGraphPolar(Int_t n, const Double_t* theta = 0, const Double_t* r = 0, const Double_t* etheta = 0, const Double_t* er = 0); virtual~TGraphPolar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGraphErrors::Apply(TF1* f); virtual voidTGraph::Browse(TBrowser* b); static Int_tTGraphErrors::CalculateScanfFields(const char* fmt); virtual Double_tTGraph::Chisquare(const TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Comp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphPolar.html:383,error,error,383,root/html534/TGraphPolar.html,https://root.cern,https://root.cern/root/html534/TGraphPolar.html,1,['error'],['error']
Availability,". TGraphPolar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TGraphPolar. class TGraphPolar: public TGraphErrors. TGraphPolar : to draw a polar graph; TGraphPolar creates a polar graph (including error bars). A TGraphPolar is; a TGraphErrors represented in polar coordinates.; It uses the class TGraphPolargram to draw the polar axis. Example:. Picture; Source. {; TCanvas * CPol = new TCanvas(""CPol"",""TGraphPolar Example"",500,500);. Double_t theta[8];; Double_t radius[8];; Double_t etheta[8];; Double_t eradius[8];. for (int i=0; i<8; i++) {; theta[i] = (i+1)*(TMath::Pi()/4.);; radius[i] = (i+1)*0.05;; etheta[i] = TMath::Pi()/8.;; eradius[i] = 0.05;; }. TGraphPolar * grP1 = new TGraphPolar(8, theta, radius, etheta, eradius);; grP1->SetTitle(""TGraphPolar Example"");. grP1->SetMarkerStyle(20);; grP1->SetMarkerSize(2.);; grP1->SetMarkerColor(4);; grP1->SetLineColor(2);; grP1->SetLineWidth(3);; grP1->Draw(""PE"");. // Update, otherwise GetPolargram returns 0; CPol->Update();; grP1->GetPolargram()->SetToRadian();. return CPol;; } . Function Members (Methods); public:. virtual~TGraphPolar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGraphErrors::Apply(TF1* f); virtual voidTGraph::Browse(TBrowser* b); static Int_tTGraphErrors::CalculateScanfFields(const char* fmt); virtual Double_tTGraph::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; static Bool_tTGraph::CompareArg(const TGraph* gr, Int_t left, Int_t right); static Bool_tTGraph::CompareRadius(const TGraph* gr, Int_t left, Int_t ri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphPolar.html:383,error,error,383,root/html602/TGraphPolar.html,https://root.cern,https://root.cern/root/html602/TGraphPolar.html,2,['error'],['error']
Availability,". TGraphPolar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TGraphPolar. class TGraphPolar: public TGraphErrors. TGraphPolar : to draw a polar graph; TGraphPolar creates a polar graph (including error bars). A TGraphPolar is; a TGraphErrors represented in polar coordinates.; It uses the class TGraphPolargram to draw the polar axis. Example:. Picture; Source. {; TCanvas * CPol = new TCanvas(""CPol"",""TGraphPolar Example"",500,500);. Double_t theta[8];; Double_t radius[8];; Double_t etheta[8];; Double_t eradius[8];; 	 ; for (int i=0; i<8; i++) {; theta[i] = (i+1)*(TMath::Pi()/4.);; radius[i] = (i+1)*0.05; ; etheta[i] = TMath::Pi()/8.;; eradius[i] = 0.05; ; }. TGraphPolar * grP1 = new TGraphPolar(8, theta, radius, etheta, eradius);; grP1->SetTitle(""TGraphPolar Example"");. grP1->SetMarkerStyle(20);; grP1->SetMarkerSize(2.);; grP1->SetMarkerColor(4);; grP1->SetLineColor(2);; grP1->SetLineWidth(3);; grP1->Draw(""PE"");. // Update, otherwise GetPolargram returns 0; CPol->Update();; grP1->GetPolargram()->SetToRadian();. return CPol;; } . Function Members (Methods); public:. TGraphPolar(); TGraphPolar(const TGraphPolar&); TGraphPolar(Int_t n, const Double_t* x = 0, const Double_t* y = 0, const Double_t* ex = 0, const Double_t* ey = 0); virtual~TGraphPolar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGraphErrors::Apply(TF1* f); virtual voidTGraph::Browse(TBrowser* b); static Int_tTGraphErrors::CalculateScanfFields(const char* fmt); virtual Double_tTGraph::Chisquare(const TF1* f1) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphPolar.html:383,error,error,383,root/html528/TGraphPolar.html,https://root.cern,https://root.cern/root/html528/TGraphPolar.html,3,['error'],['error']
Availability,". TGraphQQ. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TGraphQQ. class TGraphQQ: public TGraph. This class allows to draw quantile-quantile plots. Plots can be drawn for 2 datasets or for a dataset and a theoretical; distribution function. 2 datasets:; Quantile-quantile plots are used to determine whether 2 samples come from; the same distribution.; A qq-plot draws the quantiles of one dataset against the quantile of the; the other. The quantiles of the dataset with fewer entries are on Y axis,; with more entries - on X axis.; A straight line, going through 0.25 and 0.75 quantiles is also plotted; for reference. It represents a robust linear fit, not sensitive to the; extremes of the datasets.; If the datasets come from the same distribution, points of the plot should; fall approximately on the 45 degrees line. If they have the same; distribution function, but location or scale different parameters,; they should still fall on the straight line, but not the 45 degrees one.; The greater their departure from the straight line, the more evidence there; is, that the datasets come from different distributions.; The advantage of qq-plot is that it not only shows that the underlying; distributions are different, but, unlike the analytical methods, it also; gives information on the nature of this difference: heavier tails,; different location/scale, different shape, etc. Some examples of qqplots of 2 datasets:. /*. */. 1 dataset:; Quantile-quantile plots are used to determine if the dataset comes from the; specified theoretical distribution, such as normal.; A qq-plot draws quantiles of the dataset against quantiles of the specified; theoretical distribution.; (NOTE, that density, not CDF should be specified); A straight line, going through 0.25 and 0.75 quantiles can also be plotted; for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphQQ.html:826,robust,robust,826,root/html528/TGraphQQ.html,https://root.cern,https://root.cern/root/html528/TGraphQQ.html,6,['robust'],['robust']
Availability,". TGridJDL. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TGridJDL. class TGridJDL: public TObject. TGridJDL. Abstract base class to generate JDL files for job submission to the; Grid. Related classes are TGLiteJDL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGridJDL(); voidTObject::AbstractMethod(const char* method) const; TStringAddQuotes(const char* value); virtual voidAddToInputData(const char* value = 0, const char* description = 0); virtual voidAddToInputDataCollection(const char* value = 0, const char* description = 0); virtual voidAddToInputSandbox(const char* value = 0, const char* description = 0); virtual voidAddToOutputArchive(const char* value = 0, const char* description = 0); virtual voidAddToOutputSandbox(const char* value = 0, const char* description = 0); virtual voidAddToPackages(const char* name = ""AliRoot"", const char* version = ""default"", const char* type = ""VO_ALICE"", const char* description = 0); virtual voidAddToRequirements(const char* value = 0, const char* description = 0); voidAddToSet(const char* key, const char* value); voidAddToSetDescription(const char* key, const char* description); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = 0); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGridJDL.html:533,avail,available,533,root/html528/TGridJDL.html,https://root.cern,https://root.cern/root/html528/TGridJDL.html,4,['avail'],['available']
Availability,". TGridJDL. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TGridJDL. class TGridJDL: public TObject. TGridJDL. Abstract base class to generate JDL files for job submission to the; Grid. Related classes are TGLiteJDL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGridJDL(); voidTObject::AbstractMethod(const char* method) const; TStringAddQuotes(const char* value); virtual voidAddToInputData(const char* value = 0, const char* description = 0); virtual voidAddToInputDataCollection(const char* value = 0, const char* description = 0); virtual voidAddToInputSandbox(const char* value = 0, const char* description = 0); virtual voidAddToOutputArchive(const char* value = 0, const char* description = 0); virtual voidAddToOutputSandbox(const char* value = 0, const char* description = 0); virtual voidAddToPackages(const char* name = ""AliRoot"", const char* version = ""default"", const char* type = ""VO_ALICE"", const char* description = 0); virtual voidAddToRequirements(const char* value = 0, const char* description = 0); voidAddToSet(const char* key, const char* value); voidAddToSetDescription(const char* key, const char* description); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(const Option_t* = 0); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGridJDL.html:533,avail,available,533,root/html602/TGridJDL.html,https://root.cern,https://root.cern/root/html602/TGridJDL.html,2,['avail'],['available']
Availability,". TGridJob. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TGridJob. class TGridJob: public TObject. TGridJob. Abstract base class defining interface to a GRID job. Related classes are TGridJobStatus. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGridJob(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCancel(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGridJob.html:517,avail,available,517,root/html528/TGridJob.html,https://root.cern,https://root.cern/root/html528/TGridJob.html,6,['avail'],['available']
Availability,". TGridJobStatus. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TGridJobStatus. class TGridJobStatus: public TNamed. TGridJobStatus. Abstract base class containing the status of a Grid job. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGridJobStatus(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGridJobStatus.html:507,avail,available,507,root/html528/TGridJobStatus.html,https://root.cern,https://root.cern/root/html528/TGridJobStatus.html,6,['avail'],['available']
Availability,". TH1Editor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TH1Editor. class TH1Editor: public TGedFrame. TH1Editor; Editor for changing TH1 histogram attributes, rebinning & fitting.; For all possible draw options (there are a few which are not imple-; mentable in graphical user interface) see THistPainter::Paint in; root/histpainter/THistPainter.cxx. /*. */. /*. */. These changes can be made via the TH1Editor:; Style Tab:; 'Line' : change Line attributes (color, thickness); see TAttLineEditor; 'Fill' : change Fill attributes (color, pattern); see TAttFillEditor; 'Title' : TextEntry: set the title of the histogram; 'Histogram': change the draw options of the histogram; 'Plot' : Radiobutton: draw a 2D or 3D plot of the histogram; according to the Plot dimension there will be; different drawing possibilities (ComboBoxes/; CheckBoxes); 2d Plot:; 'Error' : ComboBox: add different error bars to the histogram; (no errors, simple, ..., see THistPainter::Paint; 'Add' : ComboBox: further things which can be added to the; histogram (None, simple/smooth line, fill area; 'Simple Drawing': CheckBox: draw a simple histogram without; errors (= ""HIST"" drawoption). In combination with; some other draw options an outer line is drawn on; top of the histogram; 'Show markers': CheckBox: draw a marker on to of each bin (=""P""; drawoption); 'Draw bar chart': CheckBox: draw a bar chart (=""B"" drawoption); change the Fill Color with Fill in the Style Tab; => will show Bar menue in the Style Tab; 'Bar option': CheckBox: draw a bar chart (=""BAR"" drawoption); => will show Bar menue in the Style Tab; 3d Plot:; 'Type' : ComboBox: set histogram type Lego-Plot or Surface; draw(Lego, Lego1.2, Surf, Surf1..5); see THistPainter::Paint; 'Coords' : ComboBox: set the coordinate system (Cartesian, ..; Spheric) see THistPainter:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1Editor.html:1072,error,error,1072,root/html528/TH1Editor.html,https://root.cern,https://root.cern/root/html528/TH1Editor.html,12,['error'],"['error', 'errors']"
Availability,". THistPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HISTPAINTER; » THistPainter. class THistPainter: public TVirtualHistPainter. The histogram painter class. Introduction; Histograms' plotting options. Options supported for 1D and 2D histograms; Options supported for 1D histograms; Options supported for 2D histograms; Options supported for 3D histograms; Options supported for histograms' stacks (THStack). Setting the Style; Setting line, fill, marker, and text attributes; Setting Tick marks on the histogram axis; Giving titles to the X, Y and Z axis; The option ""SAME"". Limitations. Superimposing two histograms with different scales in the same pad; Statistics Display; Fit Statistics; The error bars options; The bar chart option; The ""BAR"" and ""HBAR"" options; The SCATter plot option (default for 2D histograms); The ARRow option; The BOX option; The COLor option; The CANDLE option; The VIOLIN option; The TEXT and TEXTnn Option; The CONTour options. The LIST option. The LEGO options; The ""SURFace"" options; Cylindrical, Polar, Spherical and PseudoRapidity/Phi options; Base line for bar-charts and lego plots; TH2Poly Drawing; The SPEC option; Option ""Z"" : Adding the color palette on the right side of the pad; Setting the color palette; Drawing a sub-range of a 2-D histogram; the [cutg] option; Drawing options for 3D histograms; Drawing option for histograms' stacks; Drawing of 3D implicit functions; Associated functions drawing; Drawing using OpenGL. General information: plot types and supported options; TH3 as color boxes; TH3 as boxes (spheres); TH3 as iso-surface(s); TF3 (implicit function); Parametric surfaces; Interaction with the plots; Selectable parts; Rotation and zooming; Panning; Box cut; Plot specific interactions (dynamic slicing etc.); Surface with option ""GLSURF""; TF3; Box;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THistPainter.html:884,error,error,884,root/html534/THistPainter.html,https://root.cern,https://root.cern/root/html534/THistPainter.html,3,['error'],['error']
Availability,". THistPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HISTPAINTER; » THistPainter. class THistPainter: public TVirtualHistPainter. The histogram painter class. Introduction; Histograms' plotting options. Options supported for 1D and 2D histograms; Options supported for 1D histograms; Options supported for 2D histograms; Options supported for 3D histograms; Options supported for histograms' stacks (THStack). Setting the Style; Setting line, fill, marker, and text attributes; Setting Tick marks on the histogram axis; Giving titles to the X, Y and Z axis; The option ""SAME"". Limitations. Superimposing two histograms with different scales in the same pad; Statistics Display; Fit Statistics; The error bars options; The bar chart option; The ""BAR"" and ""HBAR"" options; The SCATter plot option (default for 2D histograms); The ARRow option; The BOX option; The COLor option; The TEXT and TEXTnn Option; The CONTour options. The LIST option. The LEGO options; The ""SURFace"" options; Cylindrical, Polar, Spherical and PseudoRapidity/Phi options; Base line for bar-charts and lego plots; TH2Poly Drawing; The SPEC option; Option ""Z"" : Adding the color palette on the right side of the pad; Setting the color palette; Drawing a sub-range of a 2-D histogram; the [cutg] option; Drawing options for 3D histograms; Drawing option for histograms' stacks; Drawing of 3D implicit functions; Associated functions drawing; Drawing using OpenGL. General information: plot types and supported options; TH3 as boxes (spheres); TH3 as iso-surface(s); TF3 (implicit function); Parametric surfaces; Interaction with the plots; Selectable parts; Rotation and zooming; Panning; Box cut; Plot specific interactions (dynamic slicing etc.); Surface with option ""GLSURF""; TF3; Box; Iso; Parametric plot. Introduction; Histograms are drawn ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:884,error,error,884,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,3,['error'],['error']
Availability,". THnBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnBase. class THnBase: public TNamed. Multidimensional histogram base. Defines common functionality and interfaces for THn, THnSparse. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THnBase(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const THnBase* h, Double_t c = 1.); voidAdd(const TH1* hist, Double_t c = 1.); voidAddBinContent(const Int_t* x, Double_t v = 1.); virtual voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidAddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); voidCalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidDivide(const THnBase* h); voidDivide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnBase.html:512,avail,available,512,root/html534/THnBase.html,https://root.cern,https://root.cern/root/html534/THnBase.html,3,['avail'],['available']
Availability,". THnSparseArrayChunk. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnSparseArrayChunk. class THnSparseArrayChunk: public TObject. THnSparseArrayChunk is used internally by THnSparse. THnSparse stores its (dynamic size) array of bin coordinates and their; contents (and possibly errors) in a TObjArray of THnSparseArrayChunk. Each; of the chunks holds an array of THnSparseCompactBinCoord and the content; (a TArray*), which is created outside (by the templated derived classes of; THnSparse) and passed in at construction time. Function Members (Methods); public:. THnSparseArrayChunk(); THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); virtual~THnSparseArrayChunk(); voidTObject::AbstractMethod(const char* method) const; voidAddBin(Int_t idx, const Char_t* idxbuf); voidAddBinContent(Int_t idx, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THnSparseArrayChunk.html:466,error,errors,466,root/html528/THnSparseArrayChunk.html,https://root.cern,https://root.cern/root/html528/THnSparseArrayChunk.html,8,['error'],['errors']
Availability,". THnSparseArrayChunk. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnSparseArrayChunk. class THnSparseArrayChunk: public TObject. THnSparseArrayChunk is used internally by THnSparse. THnSparse stores its (dynamic size) array of bin coordinates and their; contents (and possibly errors) in a TObjArray of THnSparseArrayChunk. Each; of the chunks holds an array of THnSparseCompactBinCoord and the content; (a TArray*), which is created outside (by the templated derived classes of; THnSparse) and passed in at construction time. Function Members (Methods); public:. virtual~THnSparseArrayChunk(); voidTObject::AbstractMethod(const char* method) const; voidAddBin(Int_t idx, const Char_t* idxbuf); voidAddBinContent(Int_t idx, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THnSparseArrayChunk.html:466,error,errors,466,root/html602/THnSparseArrayChunk.html,https://root.cern,https://root.cern/root/html602/THnSparseArrayChunk.html,2,['error'],['errors']
Availability,". TImagePlugin. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TImagePlugin. class TImagePlugin: public TObject. TImagePlugin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TImagePlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TImagePlugin.html:421,avail,available,421,root/html528/TImagePlugin.html,https://root.cern,https://root.cern/root/html528/TImagePlugin.html,1,['avail'],['available']
Availability,". TImagePlugin. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TImagePlugin. class TImagePlugin: public TObject. TImagePlugin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TImagePlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TImagePlugin.html:423,avail,available,423,root/html530/TImagePlugin.html,https://root.cern,https://root.cern/root/html530/TImagePlugin.html,5,['avail'],['available']
Availability,". TInterpreter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TInterpreter. class TInterpreter: public TNamed. TInterpreter. This class defines an abstract interface to a generic command line; interpreter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TInterpreter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIncludePath(const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tAutoLoad(const char* classname); virtual voidBaseClassInfo_Delete(BaseClassInfo_t*) const; virtual BaseClassInfo_t*BaseClassInfo_Factory(ClassInfo_t*) const; virtual const char*BaseClassInfo_FullName(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_Name(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*, int) const; virtual Long_tBaseClassInfo_Offset(BaseClassInfo_t*) const; virtual Long_tBaseClassInfo_Property(BaseClassInfo_t*) const; virtual Long_tBaseClassInfo_Tagnum(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_TmpltName(BaseClassInfo_t*) const; virtual voidTObject::Browse(TBrowser* b); virtual Long_tCalc(const char* line, TInterpreter::EErrorCode* error = 0); virtual voidCallFunc_Delete(void*) const; virtual voidCallFunc_Exec(CallFunc_t*, void*) const; virtual Double_tCallFunc_ExecDouble(CallFunc_t*, void*) const; virtual Long_tCallFunc_ExecInt(CallFunc_t*, void*) const; virtual Long64_tCallFunc_ExecInt64(CallFunc_t*, void*) const; virtual CallFunc_t*CallFunc_Factory() const; virtual CallFunc_t*CallFunc_FactoryCopy(CallFunc_t*) const; virtual MethodInfo_t*CallFunc_FactoryMethod(CallFunc_t*) const; virtual voidCallFunc_Init(CallFu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TInterpreter.html:525,avail,available,525,root/html534/TInterpreter.html,https://root.cern,https://root.cern/root/html534/TInterpreter.html,1,['avail'],['available']
Availability,". TInterpreter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TInterpreter. class TInterpreter: public TNamed. TInterpreter. This class defines an abstract interface to a generic command line; interpreter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TInterpreter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIncludePath(const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tAutoLoad(const char* classname); virtual voidBaseClassInfo_Delete(BaseClassInfo_t*) const; virtual BaseClassInfo_t*BaseClassInfo_Factory(ClassInfo_t*) const; virtual const char*BaseClassInfo_FullName(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_Name(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*, int) const; virtual Long_tBaseClassInfo_Offset(BaseClassInfo_t*) const; virtual Long_tBaseClassInfo_Property(BaseClassInfo_t*) const; virtual Long_tBaseClassInfo_Tagnum(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_TmpltName(BaseClassInfo_t*) const; virtual voidTObject::Browse(TBrowser* b); virtual Long_tCalc(const char* line, TInterpreter::EErrorCode* error = 0); virtual voidCallFunc_Delete(void*) const; virtual voidCallFunc_Exec(CallFunc_t*, void*) const; virtual Double_tCallFunc_ExecDouble(CallFunc_t*, void*) const; virtual Long_tCallFunc_ExecInt(CallFunc_t*, void*) const; virtual Long_tCallFunc_ExecInt64(CallFunc_t*, void*) const; virtual CallFunc_t*CallFunc_Factory() const; virtual CallFunc_t*CallFunc_FactoryCopy(CallFunc_t*) const; virtual MethodInfo_t*CallFunc_FactoryMethod(CallFunc_t*) const; virtual voidCallFunc_Init(CallFunc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TInterpreter.html:525,avail,available,525,root/html528/TInterpreter.html,https://root.cern,https://root.cern/root/html528/TInterpreter.html,3,['avail'],['available']
Availability,". TInterpreter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TInterpreter. class TInterpreter: public TNamed. TInterpreter. This class defines an abstract interface to a generic command line; interpreter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TInterpreter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIncludePath(const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tAutoLoad(const char* classname, Bool_t knowDictNotLoaded = kFALSE); virtual Int_tAutoLoad(const type_info& typeinfo, Bool_t knowDictNotLoaded = kFALSE); virtual Int_tAutoParse(const char* cls); virtual ClassInfo_t*BaseClassInfo_ClassInfo(BaseClassInfo_t*) const; virtual voidBaseClassInfo_Delete(BaseClassInfo_t*) const; virtual BaseClassInfo_t*BaseClassInfo_Factory(ClassInfo_t*) const; virtual BaseClassInfo_t*BaseClassInfo_Factory(ClassInfo_t*, ClassInfo_t*) const; virtual const char*BaseClassInfo_FullName(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_Name(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*, int) const; virtual Long_tBaseClassInfo_Offset(BaseClassInfo_t*, void* = 0, bool = true) const; virtual Long_tBaseClassInfo_Property(BaseClassInfo_t*) const; virtual Long_tBaseClassInfo_Tagnum(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_TmpltName(BaseClassInfo_t*) const; virtual voidTObject::Browse(TBrowser* b); virtual Long_tCalc(const char* line, TInterpreter::EErrorCode* error = 0); virtual voidCallFunc_Delete(CallFunc_t*) const; virtual voidCallFunc_Exec(CallFunc_t*, void*) const; virtual voidCallFunc_Exec(CallFunc_t*, void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TInterpreter.html:525,avail,available,525,root/html602/TInterpreter.html,https://root.cern,https://root.cern/root/html602/TInterpreter.html,2,['avail'],['available']
Availability,". TIterator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TIterator. class TIterator. TIterator. Iterator abstract base class. This base class provides the interface; for collection iterators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TIterator(); static TClass*Class(); virtual const TCollection*GetCollection() const; virtual Option_t*GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual Bool_toperator!=(const TIterator&) const; TObject*operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator&); Bool_toperator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TIterator(); TIterator(const TIterator&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t operator!=(const TIterator& ) const; Compare two iterator objects.; For backward compatibility reasons we have to provide this; default implementation. TObject * operator*() const; Return current object or nullptr.; For backward compatibility reasons we have to provide this; default implementation. TIterator(); { }. TIterator(const TIterator& ); { }. TIterator & operator=(const TIterator& ); { return *this; }. virtual ~TIterator(); { }. const TCollection * GetCollection() const. Option_t * GetOption() const; { return """"; }. TObject * Next(). void Reset(). TObject * operator()(); { return Next(); }. Bool_t operator==(const TIterator& other) const; { return !(*this != other); }. » Author: Fons Rademakers 13/08/95 » Copyright (C) 1995-2000, Ren",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TIterator.html:513,avail,available,513,root/html602/TIterator.html,https://root.cern,https://root.cern/root/html602/TIterator.html,2,['avail'],['available']
Availability,". TIterator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TIterator. class TIterator. TIterator. Iterator abstract base class. This base class provides the interface; for collection iterators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TIterator(); static TClass*Class(); virtual const TCollection*GetCollection() const; virtual Option_t*GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual Bool_toperator!=(const TIterator&) const; TObject*operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator&); Bool_toperator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t operator!=(const TIterator& ) const; Compare two iterator objects.; For backward compatibility reasons we have to provide this; default implementation. TObject * operator*() const; Return current object or nullptr.; For backward compatibility reasons we have to provide this; default implementation. TIterator & operator=(const TIterator& ); { return *this; }. virtual ~TIterator(); { }. const TCollection * GetCollection() const. Option_t * GetOption() const; { return """"; }. TObject * Next(). void Reset(). TObject * operator()(); { return Next(); }. Bool_t operator==(const TIterator& other) const; { return !(*this != other); }. » Author: Fons Rademakers 13/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-03-20 17:44; This page has been a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TIterator.html:513,avail,available,513,root/html534/TIterator.html,https://root.cern,https://root.cern/root/html534/TIterator.html,1,['avail'],['available']
Availability,". TIterator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TIterator. class TIterator. TIterator. Iterator abstract base class. This base class provides the interface; for collection iterators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TIterator(); static TClass*Class(); virtual const TCollection*GetCollection() const; virtual Option_t*GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual booloperator!=(const TIterator&) const; TObject*operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator&); virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool operator!=(const TIterator& ) const; Compare two iterator objects.; For backward compatibility reasons we have to provide this; default implementation. TObject * operator*() const; Return current object or nullptr.; For backward compatibility reasons we have to provide this; default implementation. TIterator & operator=(const TIterator& ); { return *this; }. virtual ~TIterator(); { }. const TCollection * GetCollection() const. Option_t * GetOption() const; { return """"; }. TObject * Next(). void Reset(). TObject * operator()(); { return Next(); }. » Author: Fons Rademakers 13/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: TIterator.h 23212 2008-04-14 15:30:20Z rdm $ » Last generated: 2010-09-23 20:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TIterator.html:513,avail,available,513,root/html528/TIterator.html,https://root.cern,https://root.cern/root/html528/TIterator.html,1,['avail'],['available']
Availability,". TIterator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TIterator. class TIterator. TIterator. Iterator abstract base class. This base class provides the interface; for collection iterators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TIterator(); static TClass*Class(); virtual const TCollection*GetCollection() const; virtual Option_t*GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual booloperator!=(const TIterator&) const; TObject*operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator&); virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool operator!=(const TIterator& ) const; Compare two iterator objects.; For backward compatibility reasons we have to provide this; default implementation. TObject * operator*() const; Return current object or nullptr.; For backward compatibility reasons we have to provide this; default implementation. TIterator & operator=(const TIterator& ); { return *this; }. virtual ~TIterator(); { }. const TCollection * GetCollection() const. Option_t * GetOption() const; { return """"; }. TObject * Next(). void Reset(). TObject * operator()(); { return Next(); }. » Author: Fons Rademakers 13/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: TIterator.h 23212 2008-04-14 15:30:20Z rdm $ » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TIterator.html:513,avail,available,513,root/html530/TIterator.html,https://root.cern,https://root.cern/root/html530/TIterator.html,1,['avail'],['available']
Availability,". TIterator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TIterator. class TIterator. TIterator. Iterator abstract base class. This base class provides the interface; for collection iterators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TIterator(); static TClass*Class(); virtual const TCollection*GetCollection() const; virtual Option_t*GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual booloperator!=(const TIterator&) const; TObject*operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator&); virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool operator!=(const TIterator& ) const; Compare two iterator objects.; For backward compatibility reasons we have to provide this; default implementation. TObject * operator*() const; Return current object or nullptr.; For backward compatibility reasons we have to provide this; default implementation. TIterator & operator=(const TIterator& ); { return *this; }. virtual ~TIterator(); { }. const TCollection * GetCollection() const. Option_t * GetOption() const; { return """"; }. TObject * Next(). void Reset(). TObject * operator()(); { return Next(); }. » Author: Fons Rademakers 13/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: TIterator.h 23212 2008-04-14 15:30:20Z rdm $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TIterator.html:513,avail,available,513,root/html532/TIterator.html,https://root.cern,https://root.cern/root/html532/TIterator.html,1,['avail'],['available']
Availability,". TKey. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TKey. class TKey: public TNamed. The TKey class includes functions to book space in a file,; to create I/O buffers, to fill these buffers,; to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must; be created. The key structure contains all the information to; uniquely identify a persistent object in a file.; fNbytes = Number of bytes for the compressed object+key; fObjlen = Length of uncompressed object; fDatime = Date/Time when the object was written; fKeylen = Number of bytes for the key structure; fCycle = Cycle number of the object; fSeekKey = Address of the object on file (points to fNbytes); This is a redundant information used to cross-check; the data base integrity.; fSeekPdir = Pointer to the directory supporting this object; fClassName = Object class name; fName = Name of the object; fTitle = Title of the object. In the 16 highest bits of fSeekPdir is encoded a pid offset. This; offset is to be added to the pid index stored in the TRef object; and the referenced TObject. The TKey class is used by ROOT to:; - to write an object in the current directory; - to write a new ntuple buffer. The structure of a file is shown in TFile::TFile.; The structure of a directory is shown in TDirectoryFile ctor.; The TKey class is used by the TBasket class.; See also TTree. Function Members (Methods); public:. TKey(); TKey(TDirectory* motherDir); TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKey.html:897,redundant,redundant,897,root/html528/TKey.html,https://root.cern,https://root.cern/root/html528/TKey.html,2,['redundant'],['redundant']
Availability,". TKey. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TKey. class TKey: public TNamed. The TKey class includes functions to book space in a file,; to create I/O buffers, to fill these buffers,; to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must; be created. The key structure contains all the information to; uniquely identify a persistent object in a file.; fNbytes = Number of bytes for the compressed object+key; fObjlen = Length of uncompressed object; fDatime = Date/Time when the object was written; fKeylen = Number of bytes for the key structure; fCycle = Cycle number of the object; fSeekKey = Address of the object on file (points to fNbytes); This is a redundant information used to cross-check; the data base integrity.; fSeekPdir = Pointer to the directory supporting this object; fClassName = Object class name; fName = Name of the object; fTitle = Title of the object. In the 16 highest bits of fSeekPdir is encoded a pid offset. This; offset is to be added to the pid index stored in the TRef object; and the referenced TObject. The TKey class is used by ROOT to:; - to write an object in the current directory; - to write a new ntuple buffer. The structure of a file is shown in TFile::TFile.; The structure of a directory is shown in TDirectoryFile ctor.; The TKey class is used by the TBasket class.; See also TTree. Function Members (Methods); public:. TKey(); TKey(TDirectory* motherDir); TKey(TDirectory* motherDir, const TKey& orig, UShort_t pidOffset); TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); TKey(const TString& name, const TStrin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TKey.html:897,redundant,redundant,897,root/html532/TKey.html,https://root.cern,https://root.cern/root/html532/TKey.html,2,['redundant'],['redundant']
Availability,". TKey. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TKey. class TKey: public TNamed. The TKey class includes functions to book space in a file,; to create I/O buffers, to fill these buffers,; to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must; be created. The key structure contains all the information to; uniquely identify a persistent object in a file.; fNbytes = Number of bytes for the compressed object+key; fObjlen = Length of uncompressed object; fDatime = Date/Time when the object was written; fKeylen = Number of bytes for the key structure; fCycle = Cycle number of the object; fSeekKey = Address of the object on file (points to fNbytes); This is a redundant information used to cross-check; the data base integrity.; fSeekPdir = Pointer to the directory supporting this object; fClassName = Object class name; fName = Name of the object; fTitle = Title of the object. In the 16 highest bits of fSeekPdir is encoded a pid offset. This; offset is to be added to the pid index stored in the TRef object; and the referenced TObject. The TKey class is used by ROOT to:; - to write an object in the current directory; - to write a new ntuple buffer. The structure of a file is shown in TFile::TFile.; The structure of a directory is shown in TDirectoryFile ctor.; The TKey class is used by the TBasket class.; See also TTree. Function Members (Methods); public:. virtual~TKey(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TKey.html:897,redundant,redundant,897,root/html602/TKey.html,https://root.cern,https://root.cern/root/html602/TKey.html,2,['redundant'],['redundant']
Availability,". TLimit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TLimit. class TLimit. TLimit. Class to compute 95% CL limits. adapted from the mclimit code from Tom Junk (CLs method); see http://root.cern.ch/root/doc/TomJunk.pdf; see http://cern.ch/thomasj/searchlimits/ecl.html; see: Tom Junk,NIM A434, p. 435-443, 1999. see also the following interesting references:; Alex Read, ""Presentation of search results: the CLs technique""; Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; http://www.iop.org/EJ/abstract/0954-3899/28/10/313. A nice article is also available in the CERN yellow report with the proceeding; of the 2000 CERN workshop on confidence intervals. Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)""; CERN 2000-005 (30 May 2000). see note about: ""Should I use TRolke, TFeldmanCousins, TLimit?""; in the TRolke class description. Function Members (Methods); public:. TLimit(); TLimit(const TLimit&); virtual~TLimit(); static TClass*Class(); static TConfidenceLevel*ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); virtual TClass*IsA() const; TLimit&operator=(const TLimit&); virtual voidShowMembers(TMemberInspector& insp); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLimit.html:748,avail,available,748,root/html528/TLimit.html,https://root.cern,https://root.cern/root/html528/TLimit.html,3,['avail'],['available']
Availability,". TLimit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TLimit. class TLimit. TLimit. Class to compute 95% CL limits. adapted from the mclimit code from Tom Junk (CLs method); see http://root.cern.ch/root/doc/TomJunk.pdf; see http://cern.ch/thomasj/searchlimits/ecl.html; see: Tom Junk,NIM A434, p. 435-443, 1999. see also the following interesting references:; Alex Read, ""Presentation of search results: the CLs technique""; Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; http://www.iop.org/EJ/abstract/0954-3899/28/10/313. A nice article is also available in the CERN yellow report with the proceeding; of the 2000 CERN workshop on confidence intervals. Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)""; CERN 2000-005 (30 May 2000). see note about: ""Should I use TRolke, TFeldmanCousins, TLimit?""; in the TRolke class description. Function Members (Methods); public:. TLimit(); TLimit(const TLimit&); virtual~TLimit(); static TClass*Class(); static TConfidenceLevel*ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); virtual TClass*IsA() const; TLimit&operator=(const TLimit&); virtual voidShowMembers(TMemberInspector&); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TLimit.html:748,avail,available,748,root/html534/TLimit.html,https://root.cern,https://root.cern/root/html534/TLimit.html,1,['avail'],['available']
Availability,". TLimit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TLimit. class TLimit. TLimit. Class to compute 95% CL limits. adapted from the mclimit code from Tom Junk (CLs method); see http://root.cern.ch/root/doc/TomJunk.pdf; see http://cern.ch/thomasj/searchlimits/ecl.html; see: Tom Junk,NIM A434, p. 435-443, 1999. see also the following interesting references:; Alex Read, ""Presentation of search results: the CLs technique""; Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; http://www.iop.org/EJ/abstract/0954-3899/28/10/313. A nice article is also available in the CERN yellow report with the proceeding; of the 2000 CERN workshop on confidence intervals. Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)""; CERN 2000-005 (30 May 2000). see note about: ""Should I use TRolke, TFeldmanCousins, TLimit?""; in the TRolke class description. Function Members (Methods); public:. virtual~TLimit(); static TClass*Class(); static TConfidenceLevel*ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); virtual TClass*IsA() const; TLimit&operator=(const TLimit&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLimit.html:748,avail,available,748,root/html602/TLimit.html,https://root.cern,https://root.cern/root/html602/TLimit.html,2,['avail'],['available']
Availability,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualMutex.h 25230 2008-08-25 15:22:04Z rdm $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLockGuard.html:376,avail,available,376,root/html528/TLockGuard.html,https://root.cern,https://root.cern/root/html528/TLockGuard.html,1,['avail'],['available']
Availability,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualMutex.h 25230 2008-08-25 15:22:04Z rdm $ » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TLockGuard.html:376,avail,available,376,root/html530/TLockGuard.html,https://root.cern,https://root.cern/root/html530/TLockGuard.html,1,['avail'],['available']
Availability,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualMutex.h 25230 2008-08-25 15:22:04Z rdm $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLockGuard.html:376,avail,available,376,root/html532/TLockGuard.html,https://root.cern,https://root.cern/root/html532/TLockGuard.html,1,['avail'],['available']
Availability,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TLockGuard.html:376,avail,available,376,root/html534/TLockGuard.html,https://root.cern,https://root.cern/root/html534/TLockGuard.html,1,['avail'],['available']
Availability,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. ~TLockGuard(); static TClass*Class(); TClass*IsA() const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TLockGuard(TVirtualMutex* mutex); Int_tUnLock(). private:. TLockGuard&operator=(const TLockGuard&); TLockGuard(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t UnLock(). TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 13:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLockGuard.html:376,avail,available,376,root/html602/TLockGuard.html,https://root.cern,https://root.cern/root/html602/TLockGuard.html,1,['avail'],['available']
Availability,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. ~TLockGuard(); static TClass*Class(); TClass*IsA() const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TLockGuard(TVirtualMutex* mutex); Int_tUnLock(). private:. TLockGuard&operator=(const TLockGuard&); TLockGuard(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t UnLock(). TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TLockGuard.html:376,avail,available,376,root/html604/TLockGuard.html,https://root.cern,https://root.cern/root/html604/TLockGuard.html,1,['avail'],['available']
Availability,". TMD5. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMD5. class TMD5. TMD5. This code implements the MD5 message-digest algorithm.; The algorithm is due to Ron Rivest. This code was; written by Colin Plumb in 1993, no copyright is claimed.; This code is in the public domain; do with it what you wish. Equivalent code is available from RSA Data Security, Inc.; This code has been tested against that, and is equivalent,; except that you don't need to include two pages of legalese; with every copy. To compute the message digest of a chunk of bytes, create an; TMD5 object, call Update() as needed on buffers full of bytes, and; then call Final(), which will, optionally, fill a supplied 16-byte; array with the digest. Function Members (Methods); public:. TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t* digest); voidFinal(); voidFinal(UChar_t* digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMD5.html:508,avail,available,508,root/html528/TMD5.html,https://root.cern,https://root.cern/root/html528/TMD5.html,3,['avail'],['available']
Availability,". TMD5. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMD5. class TMD5. TMD5. This code implements the MD5 message-digest algorithm.; The algorithm is due to Ron Rivest. This code was; written by Colin Plumb in 1993, no copyright is claimed.; This code is in the public domain; do with it what you wish. Equivalent code is available from RSA Data Security, Inc.; This code has been tested against that, and is equivalent,; except that you don't need to include two pages of legalese; with every copy. To compute the message digest of a chunk of bytes, create an; TMD5 object, call Update() as needed on buffers full of bytes, and; then call Final(), which will, optionally, fill a supplied 16-byte; array with the digest. Function Members (Methods); public:. TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t* digest); voidFinal(); voidFinal(UChar_t* digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer; Char_tfStr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMD5.html:508,avail,available,508,root/html534/TMD5.html,https://root.cern,https://root.cern/root/html534/TMD5.html,1,['avail'],['available']
Availability,". TMD5. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMD5. class TMD5. TMD5. This code implements the MD5 message-digest algorithm.; The algorithm is due to Ron Rivest. This code was; written by Colin Plumb in 1993, no copyright is claimed.; This code is in the public domain; do with it what you wish. Equivalent code is available from RSA Data Security, Inc.; This code has been tested against that, and is equivalent,; except that you don't need to include two pages of legalese; with every copy. To compute the message digest of a chunk of bytes, create an; TMD5 object, call Update() as needed on buffers full of bytes, and; then call Final(), which will, optionally, fill a supplied 16-byte; array with the digest. Function Members (Methods); public:. virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t[16] digest); voidFinal(); voidFinal(UChar_t[16] digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t[4] buf, const UChar_t[64] in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMD5.html:508,avail,available,508,root/html602/TMD5.html,https://root.cern,https://root.cern/root/html602/TMD5.html,2,['avail'],['available']
Availability,". TMVA::BinaryTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::BinaryTree. class TMVA::BinaryTree. BinaryTree. Base class for BinarySearch and Decision Trees. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~BinaryTree(); virtual void*AddXMLTo(void* parent) const; TMVA::BinaryTreeBinaryTree(); TMVA::BinaryTreeBinaryTree(const TMVA::BinaryTree&); static TClass*Class(); virtual const char*ClassName() const; UInt_tCountNodes(TMVA::Node* n = __null); virtual TMVA::Node*CreateNode(UInt_t size = 0) const; virtual TMVA::BinaryTree*CreateTree() const; TMVA::Node*GetLeftDaughter(TMVA::Node* n); UInt_tGetNNodes() const; TMVA::Node*GetRightDaughter(TMVA::Node* n); virtual TMVA::Node*GetRoot() const; UInt_tGetTotalTreeDepth() const; virtual TClass*IsA() const; TMVA::BinaryTree&operator=(const TMVA::BinaryTree&); virtual voidPrint(ostream& os) const; virtual voidRead(istream& istr, UInt_t tmva_Version_Code = 262656); virtual voidReadXML(void* node, UInt_t tmva_Version_Code = 262656); voidSetRoot(TMVA::Node* r); voidSetTotalTreeDepth(Int_t depth); voidSetTotalTreeDepth(TMVA::Node* n = __null); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidDeleteNode(TMVA::Node*); TMVA::MsgLogger&Log() const. Data Members; protected:. UInt_tfDepthmaximal depth in tree reached; UInt_tfNNodestotal number of nodes in the tree (counted); TMVA::Node*fRootthe root node of the tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BinaryTree(const TMVA::BinaryTree& ); constructor for a yet ""empty"" tree. Needs to be filled afterwards. ~BinaryT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__BinaryTree.html:479,avail,available,479,root/html602/TMVA__BinaryTree.html,https://root.cern,https://root.cern/root/html602/TMVA__BinaryTree.html,1,['avail'],['available']
Availability,". TMVA::BinaryTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::BinaryTree. class TMVA::BinaryTree. BinaryTree. Base class for BinarySearch and Decision Trees. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~BinaryTree(); virtual void*AddXMLTo(void* parent) const; static TClass*Class(); virtual const char*ClassName() const; UInt_tCountNodes(TMVA::Node* n = NULL); virtual TMVA::Node*CreateNode(UInt_t size = 0) const; virtual TMVA::BinaryTree*CreateTree() const; TMVA::Node*GetLeftDaughter(TMVA::Node* n); UInt_tGetNNodes() const; TMVA::Node*GetRightDaughter(TMVA::Node* n); virtual TMVA::Node*GetRoot() const; UInt_tGetTotalTreeDepth() const; virtual TClass*IsA() const; TMVA::BinaryTree&operator=(const TMVA::BinaryTree&); virtual voidPrint(ostream& os) const; virtual voidRead(istream& istr, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); virtual voidReadXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); voidSetRoot(TMVA::Node* r); voidSetTotalTreeDepth(Int_t depth); voidSetTotalTreeDepth(TMVA::Node* n = NULL); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidDeleteNode(TMVA::Node*); TMVA::MsgLogger&Log() const. Data Members; protected:. UInt_tfDepthmaximal depth in tree reached; UInt_tfNNodestotal number of nodes in the tree (counted); TMVA::Node*fRootthe root node of the tree; static TMVA::MsgLogger*fgLoggermessage logger, static to save resources . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~BinaryTree( void ); destructor (deletes the nodes and ""events"" if owned by the tree. void DeleteNode(TMVA::Node* ); protected, recurs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__BinaryTree.html:479,avail,available,479,root/html528/TMVA__BinaryTree.html,https://root.cern,https://root.cern/root/html528/TMVA__BinaryTree.html,3,['avail'],['available']
Availability,". TMVA::BinaryTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::BinaryTree. class TMVA::BinaryTree. BinaryTree. Base class for BinarySearch and Decision Trees. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~BinaryTree(); virtual void*AddXMLTo(void* parent) const; static TClass*Class(); virtual const char*ClassName() const; UInt_tCountNodes(TMVA::Node* n = NULL); virtual TMVA::Node*CreateNode(UInt_t size = 0) const; virtual TMVA::BinaryTree*CreateTree() const; TMVA::Node*GetLeftDaughter(TMVA::Node* n); UInt_tGetNNodes() const; TMVA::Node*GetRightDaughter(TMVA::Node* n); virtual TMVA::Node*GetRoot() const; UInt_tGetTotalTreeDepth() const; virtual TClass*IsA() const; TMVA::BinaryTree&operator=(const TMVA::BinaryTree&); virtual voidPrint(ostream& os) const; virtual voidRead(istream& istr, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); virtual voidReadXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); voidSetRoot(TMVA::Node* r); voidSetTotalTreeDepth(Int_t depth); voidSetTotalTreeDepth(TMVA::Node* n = NULL); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidDeleteNode(TMVA::Node*); TMVA::MsgLogger&Log() const. Data Members; protected:. UInt_tfDepthmaximal depth in tree reached; UInt_tfNNodestotal number of nodes in the tree (counted); TMVA::Node*fRootthe root node of the tree; static TMVA::MsgLogger*fgLoggermessage logger, static to save resources . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~BinaryTree( void ); destructor (deletes the nodes and ""events"" if owned by the tree. void DeleteNode(TMVA::Node* )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__BinaryTree.html:479,avail,available,479,root/html534/TMVA__BinaryTree.html,https://root.cern,https://root.cern/root/html534/TMVA__BinaryTree.html,1,['avail'],['available']
Availability,". TMVA::BinaryTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::BinaryTree. class TMVA::BinaryTree. BinaryTree. Base class for BinarySearch and Decision Trees. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~BinaryTree(); virtual void*AddXMLTo(void* parent) const; TMVA::BinaryTreeBinaryTree(); TMVA::BinaryTreeBinaryTree(const TMVA::BinaryTree&); static TClass*Class(); virtual const char*ClassName() const; UInt_tCountNodes(TMVA::Node* n = __null); virtual TMVA::Node*CreateNode(UInt_t size = 0) const; virtual TMVA::BinaryTree*CreateTree() const; TMVA::Node*GetLeftDaughter(TMVA::Node* n); UInt_tGetNNodes() const; TMVA::Node*GetRightDaughter(TMVA::Node* n); virtual TMVA::Node*GetRoot() const; UInt_tGetTotalTreeDepth() const; virtual TClass*IsA() const; TMVA::BinaryTree&operator=(const TMVA::BinaryTree&); virtual voidPrint(ostream& os) const; virtual voidRead(istream& istr, UInt_t tmva_Version_Code = 262657); virtual voidReadXML(void* node, UInt_t tmva_Version_Code = 262657); voidSetRoot(TMVA::Node* r); voidSetTotalTreeDepth(Int_t depth); voidSetTotalTreeDepth(TMVA::Node* n = __null); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidDeleteNode(TMVA::Node*); TMVA::MsgLogger&Log() const. Data Members; protected:. UInt_tfDepthmaximal depth in tree reached; UInt_tfNNodestotal number of nodes in the tree (counted); TMVA::Node*fRootthe root node of the tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BinaryTree(const TMVA::BinaryTree& ); constructor for a yet ""empty"" tree. Needs to be filled afterwards. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__BinaryTree.html:487,avail,available,487,root/html604/TMVA__BinaryTree.html,https://root.cern,https://root.cern/root/html604/TMVA__BinaryTree.html,1,['avail'],['available']
Availability,". TMVA::FitterBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::FitterBase. class TMVA::FitterBase: public TMVA::Configurable. FitterBase. Baseclass for TMVA fitters. Also defines generalised fitting interface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~FitterBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__FitterBase.html:530,avail,available,530,root/html602/TMVA__FitterBase.html,https://root.cern,https://root.cern/root/html602/TMVA__FitterBase.html,1,['avail'],['available']
Availability,". TMVA::FitterBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::FitterBase. class TMVA::FitterBase: public TMVA::Configurable. FitterBase. Baseclass for TMVA fitters. Also defines generalised fitting interface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~FitterBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__FitterBase.html:530,avail,available,530,root/html528/TMVA__FitterBase.html,https://root.cern,https://root.cern/root/html528/TMVA__FitterBase.html,4,['avail'],['available']
Availability,". TMVA::FitterBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::FitterBase. class TMVA::FitterBase: public TMVA::Configurable. FitterBase. Baseclass for TMVA fitters. Also defines generalised fitting interface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~FitterBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__FitterBase.html:538,avail,available,538,root/html604/TMVA__FitterBase.html,https://root.cern,https://root.cern/root/html604/TMVA__FitterBase.html,1,['avail'],['available']
Availability,". TMVA::IFitterTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IFitterTarget. class TMVA::IFitterTarget. IFitterTarget. Interface for a fitter 'target'. Defines interface to the estimator; function. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IFitterTarget(); static TClass*Class(); virtual Double_tEstimatorFunction(vector<Double_t>& parameters); TMVA::IFitterTargetIFitterTarget(); TMVA::IFitterTargetIFitterTarget(const TMVA::IFitterTarget&); virtual TClass*IsA() const; TMVA::IFitterTarget&operator=(const TMVA::IFitterTarget&); virtual voidProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IFitterTarget(); constructor. IFitterTarget(). virtual ~IFitterTarget(); {}. Double_t EstimatorFunction(vector<Double_t>& parameters). void ProgressNotifier(TString , TString ); function to notify the FitterTarget of the progress status of the fitter; sender : ""GA"", ""MC"", ...; progress : ""init"", ""iteration"", ""last"", ""stop"". {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__IFitterTarget.html:522,avail,available,522,root/html602/TMVA__IFitterTarget.html,https://root.cern,https://root.cern/root/html602/TMVA__IFitterTarget.html,1,['avail'],['available']
Availability,". TMVA::IFitterTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IFitterTarget. class TMVA::IFitterTarget. IFitterTarget. Interface for a fitter 'target'. Defines interface to the estimator; function. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IFitterTarget(); static TClass*Class(); virtual Double_tEstimatorFunction(vector<Double_t>& parameters); virtual TClass*IsA() const; TMVA::IFitterTarget&operator=(const TMVA::IFitterTarget&); virtual voidProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IFitterTarget(); {}. Double_t EstimatorFunction(vector<Double_t>& parameters). void ProgressNotifier(TString , TString ); function to notify the FitterTarget of the progress status of the fitter; sender : ""GA"", ""MC"", ...; progress : ""init"", ""iteration"", ""last"", ""stop"". {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: IFitterTarget.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__IFitterTarget.html:522,avail,available,522,root/html528/TMVA__IFitterTarget.html,https://root.cern,https://root.cern/root/html528/TMVA__IFitterTarget.html,1,['avail'],['available']
Availability,". TMVA::IFitterTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IFitterTarget. class TMVA::IFitterTarget. IFitterTarget. Interface for a fitter 'target'. Defines interface to the estimator; function. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IFitterTarget(); static TClass*Class(); virtual Double_tEstimatorFunction(vector<Double_t>& parameters); virtual TClass*IsA() const; TMVA::IFitterTarget&operator=(const TMVA::IFitterTarget&); virtual voidProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IFitterTarget(); {}. Double_t EstimatorFunction(vector<Double_t>& parameters). void ProgressNotifier(TString , TString ); function to notify the FitterTarget of the progress status of the fitter; sender : ""GA"", ""MC"", ...; progress : ""init"", ""iteration"", ""last"", ""stop"". {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: IFitterTarget.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__IFitterTarget.html:522,avail,available,522,root/html530/TMVA__IFitterTarget.html,https://root.cern,https://root.cern/root/html530/TMVA__IFitterTarget.html,1,['avail'],['available']
Availability,". TMVA::IFitterTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IFitterTarget. class TMVA::IFitterTarget. IFitterTarget. Interface for a fitter 'target'. Defines interface to the estimator; function. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IFitterTarget(); static TClass*Class(); virtual Double_tEstimatorFunction(vector<Double_t>& parameters); virtual TClass*IsA() const; TMVA::IFitterTarget&operator=(const TMVA::IFitterTarget&); virtual voidProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IFitterTarget(); {}. Double_t EstimatorFunction(vector<Double_t>& parameters). void ProgressNotifier(TString , TString ); function to notify the FitterTarget of the progress status of the fitter; sender : ""GA"", ""MC"", ...; progress : ""init"", ""iteration"", ""last"", ""stop"". {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: IFitterTarget.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__IFitterTarget.html:522,avail,available,522,root/html532/TMVA__IFitterTarget.html,https://root.cern,https://root.cern/root/html532/TMVA__IFitterTarget.html,1,['avail'],['available']
Availability,". TMVA::IFitterTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IFitterTarget. class TMVA::IFitterTarget. IFitterTarget. Interface for a fitter 'target'. Defines interface to the estimator; function. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IFitterTarget(); static TClass*Class(); virtual Double_tEstimatorFunction(vector<Double_t>& parameters); virtual TClass*IsA() const; TMVA::IFitterTarget&operator=(const TMVA::IFitterTarget&); virtual voidProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IFitterTarget(); {}. Double_t EstimatorFunction(vector<Double_t>& parameters). void ProgressNotifier(TString , TString ); function to notify the FitterTarget of the progress status of the fitter; sender : ""GA"", ""MC"", ...; progress : ""init"", ""iteration"", ""last"", ""stop"". {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__IFitterTarget.html:522,avail,available,522,root/html534/TMVA__IFitterTarget.html,https://root.cern,https://root.cern/root/html534/TMVA__IFitterTarget.html,1,['avail'],['available']
Availability,". TMVA::IFitterTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::IFitterTarget. class TMVA::IFitterTarget. IFitterTarget. Interface for a fitter 'target'. Defines interface to the estimator; function. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IFitterTarget(); static TClass*Class(); virtual Double_tEstimatorFunction(vector<Double_t>& parameters); TMVA::IFitterTargetIFitterTarget(); TMVA::IFitterTargetIFitterTarget(const TMVA::IFitterTarget&); virtual TClass*IsA() const; TMVA::IFitterTarget&operator=(const TMVA::IFitterTarget&); virtual voidProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IFitterTarget(); constructor. IFitterTarget(). virtual ~IFitterTarget(); {}. Double_t EstimatorFunction(vector<Double_t>& parameters). void ProgressNotifier(TString , TString ); function to notify the FitterTarget of the progress status of the fitter; sender : ""GA"", ""MC"", ...; progress : ""init"", ""iteration"", ""last"", ""stop"". {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__IFitterTarget.html:530,avail,available,530,root/html604/TMVA__IFitterTarget.html,https://root.cern,https://root.cern/root/html604/TMVA__IFitterTarget.html,1,['avail'],['available']
Availability,". TMVA::IMethod. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IMethod. class TMVA::IMethod. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IMethod(); static TClass*Class(); virtual const TMVA::Ranking*CreateRanking(); virtual voidDeclareOptions(); virtual Double_tGetMvaValue(Double_t* err = 0); virtual const char*GetName() const; virtual voidInit(); virtual TClass*IsA() const; virtual voidMakeClass(const TString& classFileName = TString("""")) const; virtual Bool_tMonitorBoost(TMVA::MethodBoost* boost); TMVA::IMethod&operator=(const TMVA::IMethod&); virtual voidPrintHelpMessage() const; virtual voidProcessOptions(); virtual voidReadWeightsFromStream(istream&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read weights from output stream. void WriteMonitoringHistosToFile( void ); write method specific monitoring histograms to target file. void MakeClass(const TString& classFileName = TString("""")) const; make ROOT-independent C++ class for classifier ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__IMethod.html:410,avail,available,410,root/html528/TMVA__IMethod.html,https://root.cern,https://root.cern/root/html528/TMVA__IMethod.html,1,['avail'],['available']
Availability,". TMVA::IMethod. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IMethod. class TMVA::IMethod. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IMethod(); static TClass*Class(); virtual const TMVA::Ranking*CreateRanking(); virtual voidDeclareOptions(); virtual Double_tGetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); virtual const char*GetName() const; virtual Bool_tHasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); TMVA::IMethodIMethod(); TMVA::IMethodIMethod(const TMVA::IMethod&); virtual voidInit(); virtual TClass*IsA() const; virtual voidMakeClass(const TString& classFileName = TString("""")) const; TMVA::IMethod&operator=(const TMVA::IMethod&); virtual voidPrintHelpMessage() const; virtual voidProcessOptions(); virtual voidReadWeightsFromStream(istream&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IMethod(); default constructur. {}. virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read weights",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__IMethod.html:410,avail,available,410,root/html602/TMVA__IMethod.html,https://root.cern,https://root.cern/root/html602/TMVA__IMethod.html,1,['avail'],['available']
Availability,". TMVA::IMethod. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IMethod. class TMVA::IMethod. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IMethod(); static TClass*Class(); virtual const TMVA::Ranking*CreateRanking(); virtual voidDeclareOptions(); virtual Double_tGetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); virtual const char*GetName() const; virtual Bool_tHasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); virtual voidInit(); virtual TClass*IsA() const; virtual voidMakeClass(const TString& classFileName = TString("""")) const; TMVA::IMethod&operator=(const TMVA::IMethod&); virtual voidPrintHelpMessage() const; virtual voidProcessOptions(); virtual voidReadWeightsFromStream(istream&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read weights from output stream. void WriteMonitoringHistosToFile( void ); write method specific monitoring histograms to targe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__IMethod.html:410,avail,available,410,root/html534/TMVA__IMethod.html,https://root.cern,https://root.cern/root/html534/TMVA__IMethod.html,1,['avail'],['available']
Availability,". TMVA::IMethod. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IMethod. class TMVA::IMethod. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IMethod(); static TClass*Class(); virtual const TMVA::Ranking*CreateRanking(); virtual voidDeclareOptions(); virtual Double_tGetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); virtual const char*GetName() const; virtual Bool_tHasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); virtual voidInit(); virtual TClass*IsA() const; virtual voidMakeClass(const TString& classFileName = TString("""")) const; virtual Bool_tMonitorBoost(TMVA::MethodBoost* boost); TMVA::IMethod&operator=(const TMVA::IMethod&); virtual voidPrintHelpMessage() const; virtual voidProcessOptions(); virtual voidReadWeightsFromStream(istream&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read weights from output stream. void WriteMonitoringHistosToFile( void ); write method spec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__IMethod.html:410,avail,available,410,root/html530/TMVA__IMethod.html,https://root.cern,https://root.cern/root/html530/TMVA__IMethod.html,2,['avail'],['available']
Availability,". TMVA::IMethod. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::IMethod. class TMVA::IMethod. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IMethod(); static TClass*Class(); virtual const TMVA::Ranking*CreateRanking(); virtual voidDeclareOptions(); virtual Double_tGetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); virtual const char*GetName() const; virtual Bool_tHasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); TMVA::IMethodIMethod(); TMVA::IMethodIMethod(const TMVA::IMethod&); virtual voidInit(); virtual TClass*IsA() const; virtual voidMakeClass(const TString& classFileName = TString("""")) const; TMVA::IMethod&operator=(const TMVA::IMethod&); virtual voidPrintHelpMessage() const; virtual voidProcessOptions(); virtual voidReadWeightsFromStream(istream&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IMethod(); default constructur. {}. virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__IMethod.html:418,avail,available,418,root/html604/TMVA__IMethod.html,https://root.cern,https://root.cern/root/html604/TMVA__IMethod.html,1,['avail'],['available']
Availability,". TMVA::MethodANNBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodANNBase. class TMVA::MethodANNBase: public TMVA::MethodBase. Base class for all TMVA methods using artificial neural networks. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodANNBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; Bool_tDebug() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodANNBase.html:519,avail,available,519,root/html602/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodANNBase.html,1,['avail'],['available']
Availability,". TMVA::MethodANNBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodANNBase. class TMVA::MethodANNBase: public TMVA::MethodBase. Base class for all TMVA methods using artificial neural networks. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodANNBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; Bool_tDebug() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Dr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodANNBase.html:519,avail,available,519,root/html528/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodANNBase.html,4,['avail'],['available']
Availability,". TMVA::MethodANNBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodANNBase. class TMVA::MethodANNBase: public TMVA::MethodBase. Base class for all TMVA methods using artificial neural networks. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodANNBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; Bool_tDebug() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodANNBase.html:527,avail,available,527,root/html604/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html,1,['avail'],['available']
Availability,". TMVA::MethodCFMlpANN_Utils. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodCFMlpANN_Utils. class TMVA::MethodCFMlpANN_Utils. Implementation of Clermond-Ferrand artificial neural network. Reference for the original FORTRAN version ""mlpl3.F"":; Authors : J. Proriol and contributions from ALEPH-Clermont-Ferrand; Team members; Copyright: Laboratoire Physique Corpusculaire; Universite de Blaise Pascal, IN2P3/CNRS. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCFMlpANN_Utils(); static TClass*Class(); virtual TClass*IsA() const; TMVA::MethodCFMlpANN_Utils&operator=(const TMVA::MethodCFMlpANN_Utils&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidArret(const char* mot); voidCollectVar(Int_t* nvar, Int_t* class__, Double_t* xpg); voidCout(Int_t*, Double_t* xxx); voidCout2(Int_t*, Double_t* yyy); virtual Int_tDataInterface(Double_t*, Double_t*, Int_t*, Int_t*, Int_t*, Int_t*, Double_t*, Int_t*, Int_t*); voidEn_arriere(Int_t* ievent); voidEn_avant(Int_t* ievent); voidEn_avant2(Int_t* ievent); voidEntree_new(Int_t*, char*, Int_t* ntrain, Int_t* ntest, Int_t* numlayer, Int_t* nodes, Int_t* numcycle, Int_t); Double_tFdecroi(Int_t* i__); voidFoncf(Int_t* i__, Double_t* u, Double_t* f); voidGraphNN(Int_t* ilearn, Double_t*, Double_t*, char*, Int_t); voidInl(); voidInnit(char* det, Double_t* tout2, Double_t* tin2, Int_t); voidLecev2(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidLeclearn(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidOut(Int_t* iii, Int_t* maxcycle); Double_tSen3a(); voidSetLogger(TMVA::MsgLogger* l); voidTestNN(); voidTrain_nn(Double_t* tin2, Double_t*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCFMlpANN_Utils.html:736,avail,available,736,root/html528/TMVA__MethodCFMlpANN_Utils.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN_Utils.html,3,['avail'],['available']
Availability,". TMVA::MethodCFMlpANN_Utils. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodCFMlpANN_Utils. class TMVA::MethodCFMlpANN_Utils. Implementation of Clermond-Ferrand artificial neural network. Reference for the original FORTRAN version ""mlpl3.F"":; Authors : J. Proriol and contributions from ALEPH-Clermont-Ferrand; Team members; Copyright: Laboratoire Physique Corpusculaire; Universite de Blaise Pascal, IN2P3/CNRS. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCFMlpANN_Utils(); static TClass*Class(); virtual TClass*IsA() const; TMVA::MethodCFMlpANN_Utils&operator=(const TMVA::MethodCFMlpANN_Utils&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidArret(const char* mot); voidCollectVar(Int_t* nvar, Int_t* class__, Double_t* xpg); voidCout(Int_t*, Double_t* xxx); voidCout2(Int_t*, Double_t* yyy); virtual Int_tDataInterface(Double_t*, Double_t*, Int_t*, Int_t*, Int_t*, Int_t*, Double_t*, Int_t*, Int_t*); voidEn_arriere(Int_t* ievent); voidEn_avant(Int_t* ievent); voidEn_avant2(Int_t* ievent); voidEntree_new(Int_t*, char*, Int_t* ntrain, Int_t* ntest, Int_t* numlayer, Int_t* nodes, Int_t* numcycle, Int_t); Double_tFdecroi(Int_t* i__); voidFoncf(Int_t* i__, Double_t* u, Double_t* f); voidGraphNN(Int_t* ilearn, Double_t*, Double_t*, char*, Int_t); voidInl(); voidInnit(char* det, Double_t* tout2, Double_t* tin2, Int_t); voidLecev2(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidLeclearn(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidOut(Int_t* iii, Int_t* maxcycle); Double_tSen3a(); voidSetLogger(TMVA::MsgLogger* l); voidTestNN(); voidTrain_nn(Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodCFMlpANN_Utils.html:736,avail,available,736,root/html534/TMVA__MethodCFMlpANN_Utils.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodCFMlpANN_Utils.html,1,['avail'],['available']
Availability,". TMVA::MethodCFMlpANN_Utils. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodCFMlpANN_Utils. class TMVA::MethodCFMlpANN_Utils. Implementation of Clermond-Ferrand artificial neural network. Reference for the original FORTRAN version ""mlpl3.F"":; Authors : J. Proriol and contributions from ALEPH-Clermont-Ferrand; Team members; Copyright: Laboratoire Physique Corpusculaire; Universite de Blaise Pascal, IN2P3/CNRS. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCFMlpANN_Utils(); static TClass*Class(); virtual TClass*IsA() const; TMVA::MethodCFMlpANN_UtilsMethodCFMlpANN_Utils(); TMVA::MethodCFMlpANN_UtilsMethodCFMlpANN_Utils(const TMVA::MethodCFMlpANN_Utils&); TMVA::MethodCFMlpANN_Utils&operator=(const TMVA::MethodCFMlpANN_Utils&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidArret(const char* mot); voidCollectVar(Int_t* nvar, Int_t* class__, Double_t* xpg); voidCout(Int_t*, Double_t* xxx); voidCout2(Int_t*, Double_t* yyy); virtual Int_tDataInterface(Double_t*, Double_t*, Int_t*, Int_t*, Int_t*, Int_t*, Double_t*, Int_t*, Int_t*); voidEn_arriere(Int_t* ievent); voidEn_avant(Int_t* ievent); voidEn_avant2(Int_t* ievent); voidEntree_new(Int_t*, char*, Int_t* ntrain, Int_t* ntest, Int_t* numlayer, Int_t* nodes, Int_t* numcycle, Int_t); Double_tFdecroi(Int_t* i__); voidFoncf(Int_t* i__, Double_t* u, Double_t* f); voidGraphNN(Int_t* ilearn, Double_t*, Double_t*, char*, Int_t); voidInl(); voidInnit(char* det, Double_t* tout2, Double_t* tin2, Int_t); voidLecev2(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidLeclearn(Int_t* ktest, Double_t* tou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodCFMlpANN_Utils.html:736,avail,available,736,root/html602/TMVA__MethodCFMlpANN_Utils.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodCFMlpANN_Utils.html,1,['avail'],['available']
Availability,". TMVA::MethodCFMlpANN_Utils. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodCFMlpANN_Utils. class TMVA::MethodCFMlpANN_Utils. Implementation of Clermond-Ferrand artificial neural network. Reference for the original FORTRAN version ""mlpl3.F"":; Authors : J. Proriol and contributions from ALEPH-Clermont-Ferrand; Team members; Copyright: Laboratoire Physique Corpusculaire; Universite de Blaise Pascal, IN2P3/CNRS. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCFMlpANN_Utils(); static TClass*Class(); virtual TClass*IsA() const; TMVA::MethodCFMlpANN_UtilsMethodCFMlpANN_Utils(); TMVA::MethodCFMlpANN_UtilsMethodCFMlpANN_Utils(const TMVA::MethodCFMlpANN_Utils&); TMVA::MethodCFMlpANN_Utils&operator=(const TMVA::MethodCFMlpANN_Utils&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidArret(const char* mot); voidCollectVar(Int_t* nvar, Int_t* class__, Double_t* xpg); voidCout(Int_t*, Double_t* xxx); voidCout2(Int_t*, Double_t* yyy); virtual Int_tDataInterface(Double_t*, Double_t*, Int_t*, Int_t*, Int_t*, Int_t*, Double_t*, Int_t*, Int_t*); voidEn_arriere(Int_t* ievent); voidEn_avant(Int_t* ievent); voidEn_avant2(Int_t* ievent); voidEntree_new(Int_t*, char*, Int_t* ntrain, Int_t* ntest, Int_t* numlayer, Int_t* nodes, Int_t* numcycle, Int_t); Double_tFdecroi(Int_t* i__); voidFoncf(Int_t* i__, Double_t* u, Double_t* f); voidGraphNN(Int_t* ilearn, Double_t*, Double_t*, char*, Int_t); voidInl(); voidInnit(char* det, Double_t* tout2, Double_t* tin2, Int_t); voidLecev2(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidLeclearn(Int_t* ktest, Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodCFMlpANN_Utils.html:744,avail,available,744,root/html604/TMVA__MethodCFMlpANN_Utils.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN_Utils.html,1,['avail'],['available']
Availability,". TMVA::MethodCompositeBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodCompositeBase. class TMVA::MethodCompositeBase: public TMVA::MethodBase. This class is virtual class meant to combine more than one classifier; together. The training of the classifiers is done by classes that are; derived from this one, while the saving and loading of weights file; and the evaluation is done here. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCompositeBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodCompositeBase.html:715,avail,available,715,root/html602/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodCompositeBase.html,1,['avail'],['available']
Availability,". TMVA::MethodCompositeBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodCompositeBase. class TMVA::MethodCompositeBase: public TMVA::MethodBase. This class is virtual class meant to combine more than one classifier; together. The training of the classifiers is done by classes that are; derived from this one, while the saving and loading of weights file; and the evaluation is done here. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCompositeBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::Dista",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCompositeBase.html:715,avail,available,715,root/html528/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCompositeBase.html,4,['avail'],['available']
Availability,". TMVA::MethodCompositeBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodCompositeBase. class TMVA::MethodCompositeBase: public TMVA::MethodBase. This class is virtual class meant to combine more than one classifier; together. The training of the classifiers is done by classes that are; derived from this one, while the saving and loading of weights file; and the evaluation is done here. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCompositeBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodCompositeBase.html:723,avail,available,723,root/html604/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodCompositeBase.html,1,['avail'],['available']
Availability,". TMVA::MinuitFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MinuitFitter. class TMVA::MinuitFitter: public TMVA::FitterBase, public TMVA::IFitterTarget. Fitter using MINUIT. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MinuitFitter(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEstimatorFunction(vector<Double_t>& pars); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MinuitFitter.html:499,avail,available,499,root/html528/TMVA__MinuitFitter.html,https://root.cern,https://root.cern/root/html528/TMVA__MinuitFitter.html,4,['avail'],['available']
Availability,". TMVA::Node. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Node. class TMVA::Node. Node for the BinarySearch or Decision Trees. For the binary search tree, it basically consists of the EVENT, and; pointers to the parent and daughters. In case of the Decision Tree, it specifies parent and daughters, as; well as ""which variable is used"" in the selection of this node,; including the respective cut value. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~Node(); virtual voidAddAttributesToNode(void* node) const; virtual voidAddContentToNode(stringstream& s) const; void*AddXMLTo(void* parent) const; static TClass*Class(); Int_tCountMeAndAllDaughters() const; virtual TMVA::Node*CreateNode() const; intGetCount(); UInt_tGetDepth() const; virtual TMVA::Node*GetLeft() const; virtual TMVA::Node*GetParent() const; virtual TMVA::BinaryTree*GetParentTree() const; charGetPos() const; virtual TMVA::Node*GetRight() const; virtual Bool_tGoesLeft(const TMVA::Event&) const; virtual Bool_tGoesRight(const TMVA::Event&) const; virtual TClass*IsA() const; TMVA::Node&operator=(const TMVA::Node&); virtual voidPrint(ostream& os) const; virtual voidPrintRec(ostream& os) const; virtual voidReadAttributes(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); virtual voidReadContent(stringstream& s); virtual Bool_tReadDataRecord(istream&, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); voidReadXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); voidSetDepth(UInt_t d); virtual voidSetLeft(TMVA::Node* l); virtual voidSetParent(TMVA::Node* p); virtual voidSetParentTree(TMVA::BinaryTree* t); voidSetPos(char s); virtual voidSetRight(TMVA::Node* r); virtual voidShowMembers(TMemberInsp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__Node.html:723,avail,available,723,root/html528/TMVA__Node.html,https://root.cern,https://root.cern/root/html528/TMVA__Node.html,4,['avail'],['available']
Availability,". TMVA::Node. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Node. class TMVA::Node. Node for the BinarySearch or Decision Trees. For the binary search tree, it basically consists of the EVENT, and; pointers to the parent and daughters. In case of the Decision Tree, it specifies parent and daughters, as; well as ""which variable is used"" in the selection of this node,; including the respective cut value. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~Node(); virtual voidAddAttributesToNode(void* node) const; virtual voidAddContentToNode(stringstream& s) const; void*AddXMLTo(void* parent) const; static TClass*Class(); Int_tCountMeAndAllDaughters() const; virtual TMVA::Node*CreateNode() const; intGetCount(); UInt_tGetDepth() const; virtual TMVA::Node*GetLeft() const; virtual TMVA::Node*GetParent() const; virtual TMVA::BinaryTree*GetParentTree() const; charGetPos() const; virtual TMVA::Node*GetRight() const; virtual Bool_tGoesLeft(const TMVA::Event&) const; virtual Bool_tGoesRight(const TMVA::Event&) const; virtual TClass*IsA() const; TMVA::NodeNode(); TMVA::NodeNode(const TMVA::Node& n); TMVA::NodeNode(TMVA::Node* p, char pos); TMVA::Node&operator=(const TMVA::Node&); virtual voidPrint(ostream& os) const; virtual voidPrintRec(ostream& os) const; virtual voidReadAttributes(void* node, UInt_t tmva_Version_Code = 262656); virtual voidReadContent(stringstream& s); virtual Bool_tReadDataRecord(istream&, UInt_t tmva_Version_Code = 262656); voidReadXML(void* node, UInt_t tmva_Version_Code = 262656); voidSetDepth(UInt_t d); virtual voidSetLeft(TMVA::Node* l); virtual voidSetParent(TMVA::Node* p); virtual voidSetParentTree(TMVA::BinaryTree* t); voidSetPos(char s); virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__Node.html:723,avail,available,723,root/html602/TMVA__Node.html,https://root.cern,https://root.cern/root/html602/TMVA__Node.html,1,['avail'],['available']
Availability,". TMVA::Node. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::Node. class TMVA::Node. Node for the BinarySearch or Decision Trees. For the binary search tree, it basically consists of the EVENT, and; pointers to the parent and daughters. In case of the Decision Tree, it specifies parent and daughters, as; well as ""which variable is used"" in the selection of this node,; including the respective cut value. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~Node(); virtual voidAddAttributesToNode(void* node) const; virtual voidAddContentToNode(stringstream& s) const; void*AddXMLTo(void* parent) const; static TClass*Class(); Int_tCountMeAndAllDaughters() const; virtual TMVA::Node*CreateNode() const; intGetCount(); UInt_tGetDepth() const; virtual TMVA::Node*GetLeft() const; virtual TMVA::Node*GetParent() const; virtual TMVA::BinaryTree*GetParentTree() const; charGetPos() const; virtual TMVA::Node*GetRight() const; virtual Bool_tGoesLeft(const TMVA::Event&) const; virtual Bool_tGoesRight(const TMVA::Event&) const; virtual TClass*IsA() const; TMVA::NodeNode(); TMVA::NodeNode(const TMVA::Node& n); TMVA::NodeNode(TMVA::Node* p, char pos); TMVA::Node&operator=(const TMVA::Node&); virtual voidPrint(ostream& os) const; virtual voidPrintRec(ostream& os) const; virtual voidReadAttributes(void* node, UInt_t tmva_Version_Code = 262657); virtual voidReadContent(stringstream& s); virtual Bool_tReadDataRecord(istream&, UInt_t tmva_Version_Code = 262657); voidReadXML(void* node, UInt_t tmva_Version_Code = 262657); voidSetDepth(UInt_t d); virtual voidSetLeft(TMVA::Node* l); virtual voidSetParent(TMVA::Node* p); virtual voidSetParentTree(TMVA::BinaryTree* t); voidSetPos(char s); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__Node.html:731,avail,available,731,root/html604/TMVA__Node.html,https://root.cern,https://root.cern/root/html604/TMVA__Node.html,1,['avail'],['available']
Availability,". TMVA::PDEFoamDecisionTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::PDEFoamDecisionTree. class TMVA::PDEFoamDecisionTree: public TMVA::PDEFoamDiscriminant. PDEFoamDecisionTree. This PDEFoam variant acts like a decision tree and stores in every; cell the discriminant. D = #events with given class / total number of events. as well as the statistical error on the discriminant. It therefore; acts as a discriminant estimator. The decision tree-like behaviour; is achieved by overriding PDEFoamDiscriminant::Explore() to use a; decision tree-like cell splitting algorithm (given a separation; type). This PDEFoam variant should be booked together with the; PDEFoamDecisionTreeDensity density estimator, which returns the; events in a cell without sampling. Function Members (Methods); public:. virtual~PDEFoamDecisionTree(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = NULL); virtual voidTObject::DrawClass() constMENU ; virtual TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoamDecisionTree.html:540,error,error,540,root/html530/TMVA__PDEFoamDecisionTree.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoamDecisionTree.html,3,['error'],['error']
Availability,". TMVA::PDEFoamDecisionTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::PDEFoamDecisionTree. class TMVA::PDEFoamDecisionTree: public TMVA::PDEFoamDiscriminant. PDEFoamDecisionTree. This PDEFoam variant acts like a decision tree and stores in every; cell the discriminant. D = #events with given class / total number of events. as well as the statistical error on the discriminant. It therefore; acts as a discriminant estimator. The decision tree-like behaviour; is achieved by overriding PDEFoamDiscriminant::Explore() to use a; decision tree-like cell splitting algorithm (given a separation; type). This PDEFoam variant should be booked together with the; PDEFoamDecisionTreeDensity density estimator, which returns the; events in a cell without sampling. Function Members (Methods); public:. virtual~PDEFoamDecisionTree(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDEFoamDecisionTree.html:540,error,error,540,root/html602/TMVA__PDEFoamDecisionTree.html,https://root.cern,https://root.cern/root/html602/TMVA__PDEFoamDecisionTree.html,1,['error'],['error']
Availability,". TMVA::PDEFoamDecisionTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoamDecisionTree. class TMVA::PDEFoamDecisionTree: public TMVA::PDEFoamDiscriminant. PDEFoamDecisionTree. This PDEFoam variant acts like a decision tree and stores in every; cell the discriminant. D = #events with given class / total number of events. as well as the statistical error on the discriminant. It therefore; acts as a discriminant estimator. The decision tree-like behaviour; is achieved by overriding PDEFoamDiscriminant::Explore() to use a; decision tree-like cell splitting algorithm (given a separation; type). This PDEFoam variant should be booked together with the; PDEFoamDecisionTreeDensity density estimator, which returns the; events in a cell without sampling. Function Members (Methods); public:. virtual~PDEFoamDecisionTree(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html:548,error,error,548,root/html604/TMVA__PDEFoamDecisionTree.html,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html,1,['error'],['error']
Availability,". TMVA::PDEFoamDiscriminant. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::PDEFoamDiscriminant. class TMVA::PDEFoamDiscriminant: public TMVA::PDEFoam. PDEFoamDiscriminant. This PDEFoam variant stores in every cell the discriminant. D = #events with given class / total number of events. as well as the statistical error on the discriminant. It therefore; acts as a discriminant estimator. It should be booked together; with the PDEFoamDiscriminantDensity density estimator, which; returns the discriminant density at a given phase space point; during the foam build-up. Function Members (Methods); public:. virtual~PDEFoamDiscriminant(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = NULL); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoamDiscriminant.html:497,error,error,497,root/html530/TMVA__PDEFoamDiscriminant.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoamDiscriminant.html,3,['error'],['error']
Availability,". TMVA::PDEFoamDiscriminant. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::PDEFoamDiscriminant. class TMVA::PDEFoamDiscriminant: public TMVA::PDEFoam. PDEFoamDiscriminant. This PDEFoam variant stores in every cell the discriminant. D = #events with given class / total number of events. as well as the statistical error on the discriminant. It therefore; acts as a discriminant estimator. It should be booked together; with the PDEFoamDiscriminantDensity density estimator, which; returns the discriminant density at a given phase space point; during the foam build-up. Function Members (Methods); public:. virtual~PDEFoamDiscriminant(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDEFoamDiscriminant.html:497,error,error,497,root/html602/TMVA__PDEFoamDiscriminant.html,https://root.cern,https://root.cern/root/html602/TMVA__PDEFoamDiscriminant.html,1,['error'],['error']
Availability,". TMVA::PDEFoamDiscriminant. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoamDiscriminant. class TMVA::PDEFoamDiscriminant: public TMVA::PDEFoam. PDEFoamDiscriminant. This PDEFoam variant stores in every cell the discriminant. D = #events with given class / total number of events. as well as the statistical error on the discriminant. It therefore; acts as a discriminant estimator. It should be booked together; with the PDEFoamDiscriminantDensity density estimator, which; returns the discriminant density at a given phase space point; during the foam build-up. Function Members (Methods); public:. virtual~PDEFoamDiscriminant(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html:505,error,error,505,root/html604/TMVA__PDEFoamDiscriminant.html,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html,1,['error'],['error']
Availability,". TMVA::PDEFoamKernelBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::PDEFoamKernelBase. class TMVA::PDEFoamKernelBase: public TObject. PDEFoamKernelBase. This class is the abstract kernel interface for PDEFoam. The; kernel can be used for manipulating (smearing) the cell values of a; PDEFoam, by passing it as an argument to; PDEFoam::GetCellValue(...). Derived classes must implement the Estimate() function to provide a; specific kernel behaviour. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~PDEFoamKernelBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Float_tEstimate(TMVA::PDEFoam*, vector<Float_t>&, TMVA::ECellValue); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoamKernelBase.html:772,avail,available,772,root/html530/TMVA__PDEFoamKernelBase.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoamKernelBase.html,4,['avail'],['available']
Availability,". TMVA::PDEFoamKernelBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoamKernelBase. class TMVA::PDEFoamKernelBase: public TObject. PDEFoamKernelBase. This class is the abstract kernel interface for PDEFoam. The; kernel can be used for manipulating (smearing) the cell values of a; PDEFoam, by passing it as an argument to; PDEFoam::GetCellValue(...). Derived classes must implement the Estimate() function to provide a; specific kernel behaviour. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~PDEFoamKernelBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Float_tEstimate(TMVA::PDEFoam*, vector<Float_t>&, TMVA::ECellValue); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__PDEFoamKernelBase.html:780,avail,available,780,root/html604/TMVA__PDEFoamKernelBase.html,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelBase.html,1,['avail'],['available']
Availability,". TMVA::PDEFoamTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::PDEFoamTarget. class TMVA::PDEFoamTarget: public TMVA::PDEFoam. PDEFoamTarget. This PDEFoam variant stores in every cell the average target; fTarget (see the Constructor) as well as the statistical error on; the target fTarget. It therefore acts as a target estimator. It; should be booked together with the PDEFoamTargetDensity density; estimator, which returns the target fTarget density at a given; phase space point during the foam build-up. Function Members (Methods); public:. virtual~PDEFoamTarget(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = NULL); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoamTarget.html:450,error,error,450,root/html530/TMVA__PDEFoamTarget.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoamTarget.html,3,['error'],['error']
Availability,". TMVA::PDEFoamTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::PDEFoamTarget. class TMVA::PDEFoamTarget: public TMVA::PDEFoam. PDEFoamTarget. This PDEFoam variant stores in every cell the average target; fTarget (see the Constructor) as well as the statistical error on; the target fTarget. It therefore acts as a target estimator. It; should be booked together with the PDEFoamTargetDensity density; estimator, which returns the target fTarget density at a given; phase space point during the foam build-up. Function Members (Methods); public:. virtual~PDEFoamTarget(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* erro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDEFoamTarget.html:450,error,error,450,root/html602/TMVA__PDEFoamTarget.html,https://root.cern,https://root.cern/root/html602/TMVA__PDEFoamTarget.html,1,['error'],['error']
Availability,". TMVA::PDEFoamTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoamTarget. class TMVA::PDEFoamTarget: public TMVA::PDEFoam. PDEFoamTarget. This PDEFoam variant stores in every cell the average target; fTarget (see the Constructor) as well as the statistical error on; the target fTarget. It therefore acts as a target estimator. It; should be booked together with the PDEFoamTargetDensity density; estimator, which returns the target fTarget density at a given; phase space point during the foam build-up. Function Members (Methods); public:. virtual~PDEFoamTarget(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__PDEFoamTarget.html:458,error,error,458,root/html604/TMVA__PDEFoamTarget.html,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamTarget.html,1,['error'],['error']
Availability,". TMVA::SeparationBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::SeparationBase. class TMVA::SeparationBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~SeparationBase(); static TClass*Class(); const TString&GetName(); Double_tGetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::SeparationBase&operator=(const TMVA::SeparationBase&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation; Double_tfPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system (making the best selection. virtual ~SeparationBase(); destructor. {}. Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Return the separation index (a measure for ""purity"" of the sample""). const TString& GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__SeparationBase.html:431,avail,available,431,root/html528/TMVA__SeparationBase.html,https://root.cern,https://root.cern/root/html528/TMVA__SeparationBase.html,3,['avail'],['available']
Availability,". TMVA::SeparationBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::SeparationBase. class TMVA::SeparationBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~SeparationBase(); static TClass*Class(); const TString&GetName(); virtual Double_tGetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::SeparationBase&operator=(const TMVA::SeparationBase&); TMVA::SeparationBaseSeparationBase(); TMVA::SeparationBaseSeparationBase(const TMVA::SeparationBase& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation; Double_tfPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SeparationBase(); default constructor. SeparationBase(const TMVA::SeparationBase& s); copy constructor. Double_t GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system (making the best selection. virtual ~SeparationBase(); destructor. {}. Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Return the separ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__SeparationBase.html:431,avail,available,431,root/html602/TMVA__SeparationBase.html,https://root.cern,https://root.cern/root/html602/TMVA__SeparationBase.html,1,['avail'],['available']
Availability,". TMVA::SeparationBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::SeparationBase. class TMVA::SeparationBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~SeparationBase(); static TClass*Class(); const TString&GetName(); virtual Double_tGetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::SeparationBase&operator=(const TMVA::SeparationBase&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation; Double_tfPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system (making the best selection. virtual ~SeparationBase(); destructor. {}. Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Return the separation index (a measure for ""purity"" of the sample""). const TString& GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Cop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__SeparationBase.html:431,avail,available,431,root/html534/TMVA__SeparationBase.html,https://root.cern,https://root.cern/root/html534/TMVA__SeparationBase.html,1,['avail'],['available']
Availability,". TMVA::SeparationBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::SeparationBase. class TMVA::SeparationBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~SeparationBase(); static TClass*Class(); const TString&GetName(); virtual Double_tGetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::SeparationBase&operator=(const TMVA::SeparationBase&); TMVA::SeparationBaseSeparationBase(); TMVA::SeparationBaseSeparationBase(const TMVA::SeparationBase& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation; Double_tfPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SeparationBase(); default constructor. SeparationBase(const TMVA::SeparationBase& s); copy constructor. Double_t GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system (making the best selection. virtual ~SeparationBase(); destructor. {}. Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Return t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__SeparationBase.html:439,avail,available,439,root/html604/TMVA__SeparationBase.html,https://root.cern,https://root.cern/root/html604/TMVA__SeparationBase.html,1,['avail'],['available']
Availability,". TMVA::TActivation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TActivation. class TMVA::TActivation. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TActivation(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivation&operator=(const TMVA::TActivation&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TActivationTActivation(); TMVA::TActivationTActivation(const TMVA::TActivation&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivation(); {}. virtual ~TActivation(); {}. Double_t Eval(Double_t arg); evaluate the activation function. Double_t EvalDerivative(Double_t arg); evaulate the derivative of the activation function. Double_t GetMin(); minimum of the range of activation function. Double_t GetMax(); maximum of the range of the activation function. TString GetExpression(); expression for activation function. void MakeFunction(ostream& fout, const TString& fncName); writer of function code. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 13:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__TActivation.html:422,avail,available,422,root/html602/TMVA__TActivation.html,https://root.cern,https://root.cern/root/html602/TMVA__TActivation.html,1,['avail'],['available']
Availability,". TMVA::TActivation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TActivation. class TMVA::TActivation. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TActivation(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivation&operator=(const TMVA::TActivation&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TActivation(); {}. Double_t Eval(Double_t arg); evaluate the activation function. Double_t EvalDerivative(Double_t arg); evaulate the derivative of the activation function. Double_t GetMin(); minimum of the range of activation function. Double_t GetMax(); maximum of the range of the activation function. TString GetExpression(); expression for activation function. void MakeFunction(ostream& fout, const TString& fncName); writer of function code. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TActivation.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__TActivation.html:422,avail,available,422,root/html528/TMVA__TActivation.html,https://root.cern,https://root.cern/root/html528/TMVA__TActivation.html,1,['avail'],['available']
Availability,". TMVA::TActivation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TActivation. class TMVA::TActivation. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TActivation(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivation&operator=(const TMVA::TActivation&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TActivation(); {}. Double_t Eval(Double_t arg); evaluate the activation function. Double_t EvalDerivative(Double_t arg); evaulate the derivative of the activation function. Double_t GetMin(); minimum of the range of activation function. Double_t GetMax(); maximum of the range of the activation function. TString GetExpression(); expression for activation function. void MakeFunction(ostream& fout, const TString& fncName); writer of function code. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TActivation.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__TActivation.html:422,avail,available,422,root/html530/TMVA__TActivation.html,https://root.cern,https://root.cern/root/html530/TMVA__TActivation.html,1,['avail'],['available']
Availability,". TMVA::TActivation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TActivation. class TMVA::TActivation. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TActivation(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivation&operator=(const TMVA::TActivation&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TActivation(); {}. Double_t Eval(Double_t arg); evaluate the activation function. Double_t EvalDerivative(Double_t arg); evaulate the derivative of the activation function. Double_t GetMin(); minimum of the range of activation function. Double_t GetMax(); maximum of the range of the activation function. TString GetExpression(); expression for activation function. void MakeFunction(ostream& fout, const TString& fncName); writer of function code. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TActivation.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__TActivation.html:422,avail,available,422,root/html532/TMVA__TActivation.html,https://root.cern,https://root.cern/root/html532/TMVA__TActivation.html,1,['avail'],['available']
Availability,". TMVA::TActivation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TActivation. class TMVA::TActivation. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TActivation(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivation&operator=(const TMVA::TActivation&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TActivation(); {}. Double_t Eval(Double_t arg); evaluate the activation function. Double_t EvalDerivative(Double_t arg); evaulate the derivative of the activation function. Double_t GetMin(); minimum of the range of activation function. Double_t GetMax(); maximum of the range of the activation function. TString GetExpression(); expression for activation function. void MakeFunction(ostream& fout, const TString& fncName); writer of function code. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__TActivation.html:422,avail,available,422,root/html534/TMVA__TActivation.html,https://root.cern,https://root.cern/root/html534/TMVA__TActivation.html,1,['avail'],['available']
Availability,". TMVA::TActivation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::TActivation. class TMVA::TActivation. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TActivation(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivation&operator=(const TMVA::TActivation&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TActivationTActivation(); TMVA::TActivationTActivation(const TMVA::TActivation&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivation(); {}. virtual ~TActivation(); {}. Double_t Eval(Double_t arg); evaluate the activation function. Double_t EvalDerivative(Double_t arg); evaulate the derivative of the activation function. Double_t GetMin(); minimum of the range of activation function. Double_t GetMax(); maximum of the range of the activation function. TString GetExpression(); expression for activation function. void MakeFunction(ostream& fout, const TString& fncName); writer of function code. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__TActivation.html:430,avail,available,430,root/html604/TMVA__TActivation.html,https://root.cern,https://root.cern/root/html604/TMVA__TActivation.html,1,['avail'],['available']
Availability,". TMVA::TNeuronInput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TNeuronInput. class TMVA::TNeuronInput. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TNeuronInput(); static TClass*Class(); virtual Double_tGetInput(const TMVA::TNeuron* neuron) const; virtual TStringGetName(); virtual TClass*IsA() const; TMVA::TNeuronInput&operator=(const TMVA::TNeuronInput&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TNeuronInputTNeuronInput(); TMVA::TNeuronInputTNeuronInput(const TMVA::TNeuronInput&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNeuronInput(); {}. virtual ~TNeuronInput(); {}. Double_t GetInput(const TMVA::TNeuron* neuron) const; calculate input value for neuron. TString GetName(); name of class. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 13:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__TNeuronInput.html:425,avail,available,425,root/html602/TMVA__TNeuronInput.html,https://root.cern,https://root.cern/root/html602/TMVA__TNeuronInput.html,1,['avail'],['available']
Availability,". TMVA::TNeuronInput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TNeuronInput. class TMVA::TNeuronInput. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TNeuronInput(); static TClass*Class(); virtual Double_tGetInput(const TMVA::TNeuron* neuron) const; virtual TStringGetName(); virtual TClass*IsA() const; TMVA::TNeuronInput&operator=(const TMVA::TNeuronInput&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TNeuronInput(); {}. Double_t GetInput(const TMVA::TNeuron* neuron) const; calculate input value for neuron. TString GetName(); name of class. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TNeuronInput.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__TNeuronInput.html:425,avail,available,425,root/html528/TMVA__TNeuronInput.html,https://root.cern,https://root.cern/root/html528/TMVA__TNeuronInput.html,1,['avail'],['available']
Availability,". TMVA::TNeuronInput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TNeuronInput. class TMVA::TNeuronInput. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TNeuronInput(); static TClass*Class(); virtual Double_tGetInput(const TMVA::TNeuron* neuron) const; virtual TStringGetName(); virtual TClass*IsA() const; TMVA::TNeuronInput&operator=(const TMVA::TNeuronInput&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TNeuronInput(); {}. Double_t GetInput(const TMVA::TNeuron* neuron) const; calculate input value for neuron. TString GetName(); name of class. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TNeuronInput.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__TNeuronInput.html:425,avail,available,425,root/html530/TMVA__TNeuronInput.html,https://root.cern,https://root.cern/root/html530/TMVA__TNeuronInput.html,1,['avail'],['available']
Availability,". TMVA::TNeuronInput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TNeuronInput. class TMVA::TNeuronInput. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TNeuronInput(); static TClass*Class(); virtual Double_tGetInput(const TMVA::TNeuron* neuron) const; virtual TStringGetName(); virtual TClass*IsA() const; TMVA::TNeuronInput&operator=(const TMVA::TNeuronInput&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TNeuronInput(); {}. Double_t GetInput(const TMVA::TNeuron* neuron) const; calculate input value for neuron. TString GetName(); name of class. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TNeuronInput.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__TNeuronInput.html:425,avail,available,425,root/html532/TMVA__TNeuronInput.html,https://root.cern,https://root.cern/root/html532/TMVA__TNeuronInput.html,1,['avail'],['available']
Availability,". TMVA::TNeuronInput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TNeuronInput. class TMVA::TNeuronInput. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TNeuronInput(); static TClass*Class(); virtual Double_tGetInput(const TMVA::TNeuron* neuron) const; virtual TStringGetName(); virtual TClass*IsA() const; TMVA::TNeuronInput&operator=(const TMVA::TNeuronInput&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TNeuronInput(); {}. Double_t GetInput(const TMVA::TNeuron* neuron) const; calculate input value for neuron. TString GetName(); name of class. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__TNeuronInput.html:425,avail,available,425,root/html534/TMVA__TNeuronInput.html,https://root.cern,https://root.cern/root/html534/TMVA__TNeuronInput.html,1,['avail'],['available']
Availability,". TMVA::TNeuronInput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::TNeuronInput. class TMVA::TNeuronInput. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TNeuronInput(); static TClass*Class(); virtual Double_tGetInput(const TMVA::TNeuron* neuron) const; virtual TStringGetName(); virtual TClass*IsA() const; TMVA::TNeuronInput&operator=(const TMVA::TNeuronInput&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TNeuronInputTNeuronInput(); TMVA::TNeuronInputTNeuronInput(const TMVA::TNeuronInput&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNeuronInput(); {}. virtual ~TNeuronInput(); {}. Double_t GetInput(const TMVA::TNeuron* neuron) const; calculate input value for neuron. TString GetName(); name of class. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__TNeuronInput.html:433,avail,available,433,root/html604/TMVA__TNeuronInput.html,https://root.cern,https://root.cern/root/html604/TMVA__TNeuronInput.html,1,['avail'],['available']
Availability,". TMVA::VariableTransformBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::VariableTransformBase. class TMVA::VariableTransformBase: public TObject. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VariableTransformBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__VariableTransformBase.html:468,avail,available,468,root/html530/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html530/TMVA__VariableTransformBase.html,4,['avail'],['available']
Availability,". TMVA::VariableTransformBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::VariableTransformBase. class TMVA::VariableTransformBase: public TObject. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VariableTransformBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__VariableTransformBase.html:468,avail,available,468,root/html528/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html528/TMVA__VariableTransformBase.html,1,['avail'],['available']
Availability,". TMVA::VariableTransformBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::VariableTransformBase. class TMVA::VariableTransformBase: public TObject. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VariableTransformBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__VariableTransformBase.html:476,avail,available,476,root/html604/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html,1,['avail'],['available']
Availability,". TMatrixTBase<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTBase<double>. class TMatrixTBase<double>: public TObject. Linear Algebra Package. The present package implements all the basic algorithms dealing; with vectors, matrices, matrix columns, rows, diagonals, etc.; In addition eigen-Vector analysis and several matrix decomposition; have been added (LU,QRH,Cholesky,Bunch-Kaufman and SVD) .; The decompositions are used in matrix inversion, equation solving. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Si",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTBase_double_.html:822,avail,available,822,root/html528/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTBase_double_.html,6,['avail'],['available']
Availability,". TMatrixTBase<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTBase<float>. class TMatrixTBase<float>: public TObject. Linear Algebra Package. The present package implements all the basic algorithms dealing; with vectors, matrices, matrix columns, rows, diagonals, etc.; In addition eigen-Vector analysis and several matrix decomposition; have been added (LU,QRH,Cholesky,Bunch-Kaufman and SVD) .; The decompositions are used in matrix inversion, equation solving. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTBase_float_.html:819,avail,available,819,root/html528/TMatrixTBase_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTBase_float_.html,6,['avail'],['available']
Availability,". TMatrixTLazy<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTLazy<double>. class TMatrixTLazy<double>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTLazy_double_.html:573,avail,available,573,root/html602/TMatrixTLazy_double_.html,https://root.cern,https://root.cern/root/html602/TMatrixTLazy_double_.html,2,['avail'],['available']
Availability,". TMatrixTLazy<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTLazy<double>. class TMatrixTLazy<double>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixTLazy<Double_t>, TMatrixDLazy. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTLazy_double_.html:663,avail,available,663,root/html528/TMatrixTLazy_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTLazy_double_.html,4,['avail'],['available']
Availability,". TMatrixTLazy<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTLazy<float>. class TMatrixTLazy<float>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTLazy_float_.html:570,avail,available,570,root/html602/TMatrixTLazy_float_.html,https://root.cern,https://root.cern/root/html602/TMatrixTLazy_float_.html,2,['avail'],['available']
Availability,". TMatrixTLazy<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTLazy<float>. class TMatrixTLazy<float>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixFLazy, TMatrixTLazy<Float_t>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMatrixTLazy_float_.html:659,avail,available,659,root/html534/TMatrixTLazy_float_.html,https://root.cern,https://root.cern/root/html534/TMatrixTLazy_float_.html,1,['avail'],['available']
Availability,". TMatrixTLazy<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTLazy<float>. class TMatrixTLazy<float>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixTLazy<Float_t>, TMatrixFLazy. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTLazy_float_.html:659,avail,available,659,root/html528/TMatrixTLazy_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTLazy_float_.html,3,['avail'],['available']
Availability,". TMatrixTSymLazy<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymLazy<double>. class TMatrixTSymLazy<double>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTSymLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTSymLazy_double_.html:582,avail,available,582,root/html602/TMatrixTSymLazy_double_.html,https://root.cern,https://root.cern/root/html602/TMatrixTSymLazy_double_.html,2,['avail'],['available']
Availability,". TMatrixTSymLazy<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymLazy<double>. class TMatrixTSymLazy<double>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixDSymLazy, TMatrixTSymLazy<Double_t>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTSymLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMatrixTSymLazy_double_.html:678,avail,available,678,root/html534/TMatrixTSymLazy_double_.html,https://root.cern,https://root.cern/root/html534/TMatrixTSymLazy_double_.html,1,['avail'],['available']
Availability,". TMatrixTSymLazy<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymLazy<double>. class TMatrixTSymLazy<double>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixTSymLazy<Double_t>, TMatrixDSymLazy. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTSymLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSymLazy_double_.html:678,avail,available,678,root/html528/TMatrixTSymLazy_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSymLazy_double_.html,3,['avail'],['available']
Availability,". TMatrixTSymLazy<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymLazy<float>. class TMatrixTSymLazy<float>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTSymLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTSymLazy_float_.html:579,avail,available,579,root/html602/TMatrixTSymLazy_float_.html,https://root.cern,https://root.cern/root/html602/TMatrixTSymLazy_float_.html,2,['avail'],['available']
Availability,". TMatrixTSymLazy<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymLazy<float>. class TMatrixTSymLazy<float>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixFSymLazy, TMatrixTSymLazy<Float_t>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTSymLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSymLazy_float_.html:674,avail,available,674,root/html528/TMatrixTSymLazy_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSymLazy_float_.html,2,['avail'],['available']
Availability,". TMatrixTSymLazy<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymLazy<float>. class TMatrixTSymLazy<float>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixTSymLazy<Float_t>, TMatrixFSymLazy. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTSymLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMatrixTSymLazy_float_.html:674,avail,available,674,root/html530/TMatrixTSymLazy_float_.html,https://root.cern,https://root.cern/root/html530/TMatrixTSymLazy_float_.html,2,['avail'],['available']
Availability,". TMemberInspector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMemberInspector. class TMemberInspector. TMemberInspector. Abstract base class for accessing the datamembers of a class.; Classes derived from this class can be given as argument to the; ShowMembers() methods of ROOT classes. This feature facilitates; the writing of class browsers and inspectors. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMemberInspector(); voidAddToParent(const char* name); static TClass*Class(); voidGenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); const char*GetParent() const; Ssiz_tGetParentLen() const; virtual voidInspect(TClass* cl, const char* parent, const char* name, const void* addr); voidInspectMember(TObject& obj, const char* name); voidInspectMember(TClass* cl, void* pobj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; TMemberInspector&operator=(const TMemberInspector&); voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMemberInspector.html:684,avail,available,684,root/html528/TMemberInspector.html,https://root.cern,https://root.cern/root/html528/TMemberInspector.html,3,['avail'],['available']
Availability,". TMemberInspector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMemberInspector. class TMemberInspector. TMemberInspector. Abstract base class for accessing the datamembers of a class.; Classes derived from this class can be given as argument to the; ShowMembers() methods of ROOT classes. This feature facilitates; the writing of class browsers and inspectors. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMemberInspector(); voidAddToParent(const char* name); static TClass*Class(); voidGenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); const char*GetParent() const; Ssiz_tGetParentLen() const; virtual voidInspect(TClass* cl, const char* parent, const char* name, const void* addr); voidInspectMember(TObject& obj, const char* name); voidInspectMember(TClass* cl, void* pobj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMemberInspector&operator=(const TMemberInspector&). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMemberInspector.html:684,avail,available,684,root/html534/TMemberInspector.html,https://root.cern,https://root.cern/root/html534/TMemberInspector.html,1,['avail'],['available']
Availability,". TMonaLisaText. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » NET; » MONALISA; » TMonaLisaText. class TMonaLisaText: public TNamed. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Function Members (Methods); public:. TMonaLisaText(const TMonaLisaText&); TMonaLisaText(const char* name, const char* text); virtual~TMonaLisaText(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaText.html:550,down,downloaded,550,root/html530/TMonaLisaText.html,https://root.cern,https://root.cern/root/html530/TMonaLisaText.html,4,['down'],"['download', 'downloaded']"
Availability,". TMonaLisaValue. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » NET; » MONALISA; » TMonaLisaValue. class TMonaLisaValue: public TNamed. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Function Members (Methods); public:. TMonaLisaValue(const char* name, Double_t value); virtual~TMonaLisaValue(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaValue.html:553,down,downloaded,553,root/html530/TMonaLisaValue.html,https://root.cern,https://root.cern/root/html530/TMonaLisaValue.html,4,['down'],"['download', 'downloaded']"
Availability,". TMonaLisaWriter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » MONALISA; » TMonaLisaWriter. class TMonaLisaWriter: public TVirtualMonitoringWriter. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_c-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Additions/modifications by Fabrizio Furano 10/04/2008; - The implementation of TFile throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; - Now TMonaLisaWriter keeps internally track of every activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; - Additionally, it's now finalized the infrastructure able to measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; - Now, the hook for the Close() func triggers sending of a packet; containing various information about the performance related to that; file only.; - Added support also for performance monitoring when writing. Function Members (Methods",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaWriter.html:598,down,downloaded,598,root/html530/TMonaLisaWriter.html,https://root.cern,https://root.cern/root/html530/TMonaLisaWriter.html,4,['down'],"['download', 'downloaded']"
Availability,". TMutexImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TMutexImp. class TMutexImp: public TObject. TMutexImp. This class provides an abstract interface to the OS dependent mutex; classes (TPosixMutex and TWin32Mutex). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMutexImp(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMutexImp.html:543,avail,available,543,root/html528/TMutexImp.html,https://root.cern,https://root.cern/root/html528/TMutexImp.html,6,['avail'],['available']
Availability,". TNDArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArray. class TNDArray: public TObject. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TNDArray(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNDArray.html:921,avail,available,921,root/html534/TNDArray.html,https://root.cern,https://root.cern/root/html534/TNDArray.html,3,['avail'],['available']
Availability,". TNewChainDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TNewChainDlg. class TNewChainDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. TNewChainDlg(const TGWindow* p = 0, const TGWindow* main = 0); virtual~TNewChainDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNewChainDlg.html:425,avail,available,425,root/html528/TNewChainDlg.html,https://root.cern,https://root.cern/root/html528/TNewChainDlg.html,4,['avail'],['available']
Availability,". TNewChainDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TNewChainDlg. class TNewChainDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. virtual~TNewChainDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNewChainDlg.html:425,avail,available,425,root/html602/TNewChainDlg.html,https://root.cern,https://root.cern/root/html602/TNewChainDlg.html,2,['avail'],['available']
Availability,". TNewQueryDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TNewQueryDlg. class TNewQueryDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. TNewQueryDlg(TSessionViewer* gui, Int_t Width, Int_t Height, TQueryDescription* query = 0, Bool_t editmode = kFALSE); virtual~TNewQueryDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBuild(TSessionViewer* gui); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNewQueryDlg.html:425,avail,available,425,root/html528/TNewQueryDlg.html,https://root.cern,https://root.cern/root/html528/TNewQueryDlg.html,4,['avail'],['available']
Availability,". TNewQueryDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TNewQueryDlg. class TNewQueryDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. virtual~TNewQueryDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBuild(TSessionViewer* gui); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNewQueryDlg.html:425,avail,available,425,root/html602/TNewQueryDlg.html,https://root.cern,https://root.cern/root/html602/TNewQueryDlg.html,2,['avail'],['available']
Availability,". TObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObject. class TObject. TObject. Mother of all ROOT objects. The TObject class provides default behaviour and protocol for all; objects in the ROOT system. It provides protocol for object I/O,; error handling, sorting, inspection, printing, drawing, etc.; Every object which inherits from TObject can be stored in the; ROOT collection classes.; TObject's bits can be used as flags, bits 0 - 13 and 24-31 are; reserved as global bits while bits 14 - 23 can be used in different; class hierarchies (watch out for overlaps). Function Members (Methods); public:. TObject(); TObject(const TObject& object); virtual~TObject(); voidAbstractMethod(const char* method) const; virtual voidAppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidCopy(TObject& object) const; virtual voidDelete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawClass() constMENU ; virtual TObject*DrawClone(Option_t* option = """") constMENU ; virtual voidDump() constMENU ; virtual voidError(const char* method, const char* msgfmt) const; virtual voidExecute(const char* method, const char* params, Int_t* error = 0); virtual voidExecute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual Option_t*GetDrawOption() const; static Long_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TObject.html:436,error,error,436,root/html528/TObject.html,https://root.cern,https://root.cern/root/html528/TObject.html,4,['error'],['error']
Availability,". TObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObject. class TObject. TObject. Mother of all ROOT objects. The TObject class provides default behaviour and protocol for all; objects in the ROOT system. It provides protocol for object I/O,; error handling, sorting, inspection, printing, drawing, etc.; Every object which inherits from TObject can be stored in the; ROOT collection classes.; TObject's bits can be used as flags, bits 0 - 13 and 24-31 are; reserved as global bits while bits 14 - 23 can be used in different; class hierarchies (watch out for overlaps). Function Members (Methods); public:. virtual~TObject(); voidAbstractMethod(const char* method) const; virtual voidAppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidCopy(TObject& object) const; virtual voidDelete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawClass() constMENU ; virtual TObject*DrawClone(Option_t* option = """") constMENU ; virtual voidDump() constMENU ; virtual voidError(const char* method, const char* msgfmt) const; virtual voidExecute(const char* method, const char* params, Int_t* error = 0); virtual voidExecute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual Option_t*GetDrawOption() const; static Long_tGetDtorOnly(); virtual const char*GetIconNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TObject.html:436,error,error,436,root/html602/TObject.html,https://root.cern,https://root.cern/root/html602/TObject.html,2,['error'],['error']
Availability,". TObjectRefSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectRefSpy. class TObjectRefSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. TObjectRefSpy(TObject*& obj, Bool_t fixMustCleanupBit = kTRUE); virtual~TObjectRefSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TObjectRefSpy.html:621,error,error,621,root/html528/TObjectRefSpy.html,https://root.cern,https://root.cern/root/html528/TObjectRefSpy.html,4,['error'],['error']
Availability,". TObjectRefSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectRefSpy. class TObjectRefSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. virtual~TObjectRefSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOpti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TObjectRefSpy.html:621,error,error,621,root/html602/TObjectRefSpy.html,https://root.cern,https://root.cern/root/html602/TObjectRefSpy.html,2,['error'],['error']
Availability,". TObjectSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectSpy. class TObjectSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. TObjectSpy(TObject* obj = 0, Bool_t fixMustCleanupBit = kTRUE); virtual~TObjectSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TObjectSpy.html:612,error,error,612,root/html528/TObjectSpy.html,https://root.cern,https://root.cern/root/html528/TObjectSpy.html,4,['error'],['error']
Availability,". TObjectSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectSpy. class TObjectSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. virtual~TObjectSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TObjectSpy.html:612,error,error,612,root/html602/TObjectSpy.html,https://root.cern,https://root.cern/root/html602/TObjectSpy.html,2,['error'],['error']
Availability,". TOracleServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » SQL; » ORACLE; » TOracleServer. class TOracleServer: public TSQLServer. TOracleServer. This class implements an OCCI interface to Oracle data bases.; It uses the instantclient10 software available from Oracle.; To install this client software do:; 1) Download Instant Client Packages (4 files) from:; http://www.oracle.com/technology/software/tech/oci/instantclient/index.html; 2) Unzip the files into instantclient10_2 (Mac OS X example here):; unzip instantclient-basic-macosx-10.2.0.4.zip; unzip instantclient-sqlplus-macosx-10.2.0.4.zip; unzip instantclient-sdk-macosx-10.2.0.4.zip; unzip instantclient-jdbc-macosx-10.2.0.4.zip; 3) Create two symbolic links for the files that have the version; appended:; ln -s libclntsh.dylib.10.1 libclntsh.dylib; ln -s libocci.dylib.10.1 libocci.dylib; 4) Add instantclient10_1 directory to your (DY)LD_LIBRARY_PATH; in your .profile:; export (DY)LD_LIBRARY_PATH=""<pathto>/instantclient10_2""; Use DY only on Mac OS X.; 5) If you also want to use the sqlplus command line app add also; export SQLPATH=""<pathto>/instantclient10_2""; 6) If you want to connect to a remote db server you will also need; to create a tnsname.ora file which describes the local_name for; the remote db servers (at CERN most public machines have this; file in /etc). If it is not in /etc create TNS_ADMIN:; export TNS_ADMIN=""<path-to-dir-containing-tnsname.ora>""; 7) Test it our with the sqlplus command line app:; sqlplus [username][/password]@<local_name>; or; sqlplus [username][/password]@//[hostname][:port][/database]. Function Members (Methods); public:. TOracleServer(const TOracleServer&); TOracleServer(const char* db, const char* uid, const char* pw); virtual~TOracleServer(); voidTObject::AbstractMethod(const char* method) const; virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TOracleServer.html:419,avail,available,419,root/html528/TOracleServer.html,https://root.cern,https://root.cern/root/html528/TOracleServer.html,1,['avail'],['available']
Availability,". TParallelCoordVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TParallelCoordVar. class TParallelCoordVar: public TNamed, public TAttLine, public TAttFill. Axes:. Class containing a variable for the TParallelCoord. Options can be defined each axis separatly using the right mouse click. These options can be applied to every axes using the editor. Axis width: If set to 0, the axis is simply a line. If higher, a color histogram is drawn on the axis.; Axis histogram height: If not 0, a usual bar histogram is drawn on the plot. The order in which the variables are drawn is essential to see the clusters. The axes can be dragged to change their position. A zoom is also available. The logarithm scale is also available by right clicking on the axis. Function Members (Methods); public:. TParallelCoordVar(); TParallelCoordVar(const TParallelCoordVar&); TParallelCoordVar(Double_t* val, const char* title, Int_t id, TParallelCoord* gram); virtual~TParallelCoordVar(); voidTObject::AbstractMethod(const char* method) const; voidAddRange()MENU ; voidAddRange(TParallelCoordRange* range); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteVariable()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TParallelCoordVar.html:866,avail,available,866,root/html530/TParallelCoordVar.html,https://root.cern,https://root.cern/root/html530/TParallelCoordVar.html,6,['avail'],['available']
Availability,". TParallelCoordVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TParallelCoordVar. class TParallelCoordVar: public TNamed, public TAttLine, public TAttFill. Axes:. Class containing a variable for the TParallelCoord. Options can be defined each axis separatly using the right mouse click. These options can be applied to every axes using the editor. Axis width: If set to 0, the axis is simply a line. If higher, a color histogram is drawn on the axis.; Axis histogram height: If not 0, a usual bar histogram is drawn on the plot. The order in which the variables are drawn is essential to see the clusters. The axes can be dragged to change their position. A zoom is also available. The logarithm scale is also available by right clicking on the axis. Function Members (Methods); public:. virtual~TParallelCoordVar(); voidTObject::AbstractMethod(const char* method) const; voidAddRange()MENU ; voidAddRange(TParallelCoordRange* range); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteVariable()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TParallelCoordVar.html:866,avail,available,866,root/html602/TParallelCoordVar.html,https://root.cern,https://root.cern/root/html602/TParallelCoordVar.html,4,['avail'],['available']
Availability,". TPaveStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TPaveStats. class TPaveStats: public TPaveText. The histogram statistics painter class; A PaveStats is a PaveText to draw histogram statistics and fit parameters. Statistics Display; Fit Statistics; Statistics box editing. Statistics Display; The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The ""mode"" has up to nine digits that can be set to on (1 or 2), off (0). mode = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters kKsSiourRmMen. k : kurtosis printed; K : kurtosi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPaveStats.html:771,error,error,771,root/html534/TPaveStats.html,https://root.cern,https://root.cern/root/html534/TPaveStats.html,12,['error'],['error']
Availability,". TPaveStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TPaveStats. class TPaveStats: public TPaveText. The histogram statistics painter class; A PaveStats is a PaveText to draw histogram statistics and fit parameters.; Statistics Display; The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The ""mode"" has up to nine digits that can be set to on(1 or 2), off(0). mode = iourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(000111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters; kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewnes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPaveStats.html:708,error,error,708,root/html528/TPaveStats.html,https://root.cern,https://root.cern/root/html528/TPaveStats.html,12,['error'],['error']
Availability,". TPoints3DABC. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TPoints3DABC. class TPoints3DABC: public TObject. The TPoints3DABC class; Abstract class to define Arrays of 3D points.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TPoints3DABC(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAdd(Float_t x, Float_t y, Float_t z); virtual Int_tAddLast(Float_t x, Float_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tDistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPoints3DABC.html:505,avail,available,505,root/html528/TPoints3DABC.html,https://root.cern,https://root.cern/root/html528/TPoints3DABC.html,6,['avail'],['available']
Availability,". TProfile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TProfile. class TProfile: public TH1D. Profile histograms are used to display the mean; value of Y and its error for each bin in X. The displayed error is by default the; standard error on the mean (i.e. the standard deviation divided by the sqrt(n) ); Profile histograms are in many cases an; elegant replacement of two-dimensional histograms : the inter-relation of two; measured quantities X and Y can always be visualized by a two-dimensional; histogram or scatter-plot; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for bin J. 2; H(J) = sum Y E(J) = sum Y; l(J) = sum l L(J) = sum l; h(J) = H(J)/L(J) mean of Y,; s(J) = sqrt(E(J)/L(J)- h(J)**2) standard deviation of Y (e.g. RMS); e(J) = s(J)/sqrt(L(J)) standard error on the mean. The displayed bin content for bin J of a TProfile is always h(J). The corresponding bin error is by default; e(J). In case the option ""s"" is used (in the constructor or by calling TProfile::BuildOptions); the displayed error is s(J). In the special case where s(J) is zero (eg, case of 1 entry only in one bin); the bin error e(J) is computed from the average of the s(J) for all bins if; the static function TProfile::Approximate has been called.; This simple/crude approximation was suggested in order to keep the bin; during a fit operation. But note that this approximation is not the default behaviour.; See also TProfile::BuildOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile.html:350,error,error,350,root/html534/TProfile.html,https://root.cern,https://root.cern/root/html534/TProfile.html,9,['error'],['error']
Availability,". TProofBenchRun. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFBENCH; » TProofBenchRun. class TProofBenchRun: public TObject. TProofBenchRun. Abstract base class for PROOF benchmark run. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TProofBenchRun(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofBenchRun.html:505,avail,available,505,root/html530/TProofBenchRun.html,https://root.cern,https://root.cern/root/html530/TProofBenchRun.html,5,['avail'],['available']
Availability,". TProofDraw. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TProofDraw. class TProofDraw: public TSelector. TProofDraw. Implement Tree drawing using PROOF. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TProofDraw(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofDraw.html:483,avail,available,483,root/html528/TProofDraw.html,https://root.cern,https://root.cern/root/html528/TProofDraw.html,6,['avail'],['available']
Availability,". TProofMonSender. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TProofMonSender. class TProofMonSender: public TNamed. TProofMonSender. Provides the interface for PROOF monitoring to different writers.; Allows to decouple the information sent from the backend. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TProofMonSender(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofMonSender.html:565,avail,available,565,root/html532/TProofMonSender.html,https://root.cern,https://root.cern/root/html532/TProofMonSender.html,2,['avail'],['available']
Availability,". TProofMonSender. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TProofMonSender. class TProofMonSender: public TNamed. TProofMonSender. Provides the interface for PROOF monitoring to different writers.; Allows to decouple the information sent from the backend. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TProofMonSender(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofMonSender.html:589,avail,available,589,root/html602/TProofMonSender.html,https://root.cern,https://root.cern/root/html602/TProofMonSender.html,2,['avail'],['available']
Availability,". TProofResources. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofResources. class TProofResources: public TObject. TProofResources. Abstract base class for PROOF resources.; The class contains common method declarations for derived classes; such as TProofResourcesStatic which reads and interprets static; config files, and returns master, submaster and worker information; using TProofNodeInfo objects. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TProofResources(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofResources.html:705,avail,available,705,root/html528/TProofResources.html,https://root.cern,https://root.cern/root/html528/TProofResources.html,1,['avail'],['available']
Availability,". TProofResources. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofResources. class TProofResources: public TObject. TProofResources. Abstract base class for PROOF resources.; The class contains common method declarations for derived classes; such as TProofResourcesStatic which reads and interprets static; config files, and returns master, submaster and worker information; using TProofNodeInfo objects. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TProofResources(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofResources.html:707,avail,available,707,root/html530/TProofResources.html,https://root.cern,https://root.cern/root/html530/TProofResources.html,5,['avail'],['available']
Availability,". TPythia8. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » PYTHIA8; » TPythia8. class TPythia8: public TGenerator. TPythia8. TPythia is an interface class to C++ version of Pythia 8.1; event generators, written by T.Sjostrand. The user is assumed to be familiar with the Pythia package.; This class includes only a basic interface to Pythia8. Because Pythia8 is; also written in C++, its functions/classes can be called directly from a; compiled C++ script.; To call Pythia functions not available in this interface a dictionary must; be generated.; see $ROOTSYS/tutorials/pythia/pythia8.C for an example of use from CINT. | |; | *------------------------------------------------------------------------------* |; | | | |; | | | |; | | PPP Y Y TTTTT H H III A Welcome to the Lund Monte Carlo! | |; | | P P Y Y T H H I A A This is PYTHIA version 8.100 | |; | | PPP Y T HHHHH I AAAAA Last date of change: 20 Oct 2007 | |; | | P Y T H H I A A | |; | | P Y T H H III A A Now is 27 Oct 2007 at 18:26:53 | |; | | | |; | | Main author: Torbjorn Sjostrand; CERN/PH, CH-1211 Geneva, Switzerland, | |; | | and Department of Theoretical Physics, Lund University, Lund, Sweden; | |; | | phone: + 41 - 22 - 767 82 27; e-mail: torbjorn@thep.lu.se | |; | | Author: Stephen Mrenna; Computing Division, Simulations Group, | |; | | Fermi National Accelerator Laboratory, MS 234, Batavia, IL 60510, USA; | |; | | phone: + 1 - 630 - 840 - 2556; e-mail: mrenna@fnal.gov | |; | | Author: Peter Skands; CERN/PH, CH-1211 Geneva, Switzerland, | |; | | and Theoretical Physics Department, | |; | | Fermi National Accelerator Laboratory, MS 106, Batavia, IL 60510, USA; | |; | | phone: + 41 - 22 - 767 24 59; e-mail: skands@fnal.gov | |; | | | |; | | The main program reference is the 'Brief Introduction to PYTHIA 8.1', | |; | | T. Sjostrand, S.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPythia8.html:670,avail,available,670,root/html528/TPythia8.html,https://root.cern,https://root.cern/root/html528/TPythia8.html,6,['avail'],['available']
Availability,". TQCommand. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQCommand. class TQCommand: public TList, public TQObject. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:843,down,downwards,843,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,2,['down'],['downwards']
Availability,". TQCommand. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQCommand. class TQCommand: public TList, public TQObject. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:819,down,downwards,819,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,4,['down'],['downwards']
Availability,". TQObject. ←; TXMLParser. ←; TSAXParser. Function documentation; TSAXParser(); Create SAX parser. ~TSAXParser(); TSAXParser desctructor. void OnStartDocument(); Emit a signal for OnStartDocument. void OnEndDocument(); Emit a signal for OnEndDocument. void OnStartElement(const char* name, const TList* attr); Emit a signal for OnStarElement, where name is the Element's name and; attribute is a TList of (TObjString*, TObjString *) TPair's.; The TPair's key is the attribute's name and value is the attribute's; value. void OnEndElement(const char* name); Emit a signal for OnEndElement, where name is the Element's name. void OnCharacters(const char* characters); Emit a signal for OnCharacters, where characters are the characters; outside of tags. void OnComment(const char* text); Emit a signal for OnComment, where text is the comment. void OnWarning(const char* text); Emit a signal for OnWarning, where text is the warning. Int_t OnError(const char* text); Emit a signal for OnError, where text is the error and it returns the; Parse Error Code, see TXMLParser. Int_t OnFatalError(const char* text); Emit a signal for OnFactalError, where text is the error and it; returns the Parse Error Code, see TXMLParser. void OnCdataBlock(const char* text, Int_t len); Emit a signal for OnCdataBlock. Int_t Parse(); This function parses the xml file, by initializing the parser and checks; whether the parse context is created or not, it will check as well; whether the document is well formated.; It returns the parse error code, see TXMLParser. Int_t ParseFile(const char* filename); It creates the parse context of the xml file, where the xml file name is; filename. If context is created sucessfully, it will call Parse(); It returns parse error code, see TXMLParser. Int_t ParseBuffer(const char* contents, Int_t len); It parse the contents, instead of a file.; It will return error if is attempted to parse a second file while; a parse is in progres.; It returns parse code error, see TXMLParser.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSAXParser.html:12602,error,error,12602,root/html602/TSAXParser.html,https://root.cern,https://root.cern/root/html602/TSAXParser.html,2,['error'],['error']
Availability,". TQRootApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » QTGSI; » TQRootApplication. class TQRootApplication: public QApplication. Function Members (Methods); public:. TQRootApplication(int& argc, char** argv, int poll = 0); ~TQRootApplication(); static TClass*Class(); voidExecute(); virtual TClass*IsA() const; voidQuit(); voidSetDebugOn(); voidSetWarningOn(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TQRootApplication(const TQRootApplication&); TQRootApplication&operator=(const TQRootApplication&). Data Members; public:. static Bool_tfgDebug; static Bool_tfgWarningdebug and warning flags. protected:. QTimer*fQTimerQt timer that poll the event loop of ROOT; TTimer*fRTimerRoot timer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQRootApplication(int& argc, char** argv, int poll = 0); Connect ROOT via Timer call back. ~TQRootApplication(); dtor. void Execute(); Call the inner loop of ROOT. void Quit(); Set a Qt-Specific error handler. TQRootApplication(const TQRootApplication& ). TQRootApplication& operator=(const TQRootApplication& ). void SetDebugOn(); { fgDebug=kTRUE; }. void SetWarningOn(); { fgWarning=kTRUE;}. » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQRootApplication.h 32344 2010-02-15 16:15:57Z bellenot $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQRootApplication.html:1249,error,error,1249,root/html528/TQRootApplication.html,https://root.cern,https://root.cern/root/html528/TQRootApplication.html,1,['error'],['error']
Availability,". TQRootApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » QTGSI; » TQRootApplication. class TQRootApplication: public QApplication. Function Members (Methods); public:. TQRootApplication(int& argc, char** argv, int poll = 0); ~TQRootApplication(); static TClass*Class(); voidExecute(); virtual TClass*IsA() const; voidQuit(); voidSetDebugOn(); voidSetWarningOn(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TQRootApplication(const TQRootApplication&); TQRootApplication&operator=(const TQRootApplication&). Data Members; public:. static Bool_tfgDebug; static Bool_tfgWarningdebug and warning flags. protected:. QTimer*fQTimerQt timer that poll the event loop of ROOT; TTimer*fRTimerRoot timer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQRootApplication(int& argc, char** argv, int poll = 0); Connect ROOT via Timer call back. ~TQRootApplication(); dtor. void Execute(); Call the inner loop of ROOT. void Quit(); Set a Qt-Specific error handler. TQRootApplication(const TQRootApplication& ). TQRootApplication& operator=(const TQRootApplication& ). void SetDebugOn(); { fgDebug=kTRUE; }. void SetWarningOn(); { fgWarning=kTRUE;}. » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQRootApplication.h 32344 2010-02-15 16:15:57Z bellenot $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQRootApplication.html:1249,error,error,1249,root/html532/TQRootApplication.html,https://root.cern,https://root.cern/root/html532/TQRootApplication.html,1,['error'],['error']
Availability,". TQRootApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » QTGSI; » TQRootApplication. class TQRootApplication: public QApplication. Function Members (Methods); public:. TQRootApplication(int& argc, char** argv, int poll = 0); ~TQRootApplication(); static TClass*Class(); voidExecute(); virtual TClass*IsA() const; voidQuit(); voidSetDebugOn(); voidSetWarningOn(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TQRootApplication(const TQRootApplication&); TQRootApplication&operator=(const TQRootApplication&). Data Members; public:. static Bool_tfgDebug; static Bool_tfgWarningdebug and warning flags. protected:. QTimer*fQTimerQt timer that poll the event loop of ROOT; TTimer*fRTimerRoot timer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQRootApplication(int& argc, char** argv, int poll = 0); Connect ROOT via Timer call back. ~TQRootApplication(); dtor. void Execute(); Call the inner loop of ROOT. void Quit(); Set a Qt-Specific error handler. TQRootApplication(const TQRootApplication& ). TQRootApplication& operator=(const TQRootApplication& ). void SetDebugOn(); { fgDebug=kTRUE; }. void SetWarningOn(); { fgWarning=kTRUE;}. » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id$ » Last generated: 2015-03-14 16:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQRootApplication.html:1268,error,error,1268,root/html534/TQRootApplication.html,https://root.cern,https://root.cern/root/html534/TQRootApplication.html,1,['error'],['error']
Availability,". TQUndoManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQUndoManager. class TQUndoManager: public TQCommand. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQUndoManager.html:842,down,downwards,842,root/html602/TQUndoManager.html,https://root.cern,https://root.cern/root/html602/TQUndoManager.html,2,['down'],['downwards']
Availability,". TQUndoManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQUndoManager. class TQUndoManager: public TQCommand. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQUndoManager.html:818,down,downwards,818,root/html528/TQUndoManager.html,https://root.cern,https://root.cern/root/html528/TQUndoManager.html,4,['down'],['downwards']
Availability,". TQpDataBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpDataBase. class TQpDataBase: public TObject. TQpDataBase. Data for the general QP formulation. The Data class stores the data defining the problem and provides; methods for performing the operations with this data required by; the interior-point algorithms. These operations include assembling; the linear systems (5) or (7), performing matrix-vector operations; with the data, calculating norms of the data, reading input into the; data structure from various sources, generating random problem; instances, and printing the data. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpDataBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidAmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidATransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQpDataBase.html:939,avail,available,939,root/html602/TQpDataBase.html,https://root.cern,https://root.cern/root/html602/TQpDataBase.html,2,['avail'],['available']
Availability,". TQpDataBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpDataBase. class TQpDataBase: public TObject. TQpDataBase. Data for the general QP formulation. The Data class stores the data defining the problem and provides; methods for performing the operations with this data required by; the interior-point algorithms. These operations include assembling; the linear systems (5) or (7), performing matrix-vector operations; with the data, calculating norms of the data, reading input into the; data structure from various sources, generating random problem; instances, and printing the data. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpDataBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidAmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidATransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpDataBase.html:915,avail,available,915,root/html528/TQpDataBase.html,https://root.cern,https://root.cern/root/html528/TQpDataBase.html,4,['avail'],['available']
Availability,". TQpLinSolverBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpLinSolverBase. class TQpLinSolverBase: public TObject. TQpLinSolverBase. Implementation of main solver for linear systems. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpLinSolverBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFactor(TQpDataBase* prob, TQpVar* vars); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQpLinSolverBase.html:536,avail,available,536,root/html602/TQpLinSolverBase.html,https://root.cern,https://root.cern/root/html602/TQpLinSolverBase.html,2,['avail'],['available']
Availability,". TQpLinSolverBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpLinSolverBase. class TQpLinSolverBase: public TObject. TQpLinSolverBase. Implementation of main solver for linear systems. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpLinSolverBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFactor(TQpDataBase* prob, TQpVar* vars); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpLinSolverBase.html:512,avail,available,512,root/html528/TQpLinSolverBase.html,https://root.cern,https://root.cern/root/html528/TQpLinSolverBase.html,4,['avail'],['available']
Availability,". TQpProbBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpProbBase. class TQpProbBase: public TObject. TQpProbBase. default general problem formulation:. minimize c' x + ( 1/2 ) x' * Q x ;; subject to A x = b ;; clo <= C x <= cup ;; xlo <= x <= xup ;. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpProbBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQpProbBase.html:602,avail,available,602,root/html602/TQpProbBase.html,https://root.cern,https://root.cern/root/html602/TQpProbBase.html,2,['avail'],['available']
Availability,". TQpProbBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpProbBase. class TQpProbBase: public TObject. TQpProbBase. default general problem formulation:. minimize c' x + ( 1/2 ) x' * Q x ;; subject to A x = b ;; clo <= C x <= cup ;; xlo <= x <= xup ;. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpProbBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpProbBase.html:578,avail,available,578,root/html528/TQpProbBase.html,https://root.cern,https://root.cern/root/html528/TQpProbBase.html,4,['avail'],['available']
Availability,". TQpSolverBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpSolverBase. class TQpSolverBase: public TObject. TSolverBase. The Solver class contains methods for monitoring and checking the; convergence status of the algorithm, methods to determine the step; length along a given direction, methods to define the starting point,; and the solve method that implements the interior-point algorithm. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpSolverBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tDataNorm(); virtual voidDefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual voidDefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual Int_tDefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tDoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQpSolverBase.html:745,avail,available,745,root/html602/TQpSolverBase.html,https://root.cern,https://root.cern/root/html602/TQpSolverBase.html,2,['avail'],['available']
Availability,". TQpSolverBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpSolverBase. class TQpSolverBase: public TObject. TSolverBase. The Solver class contains methods for monitoring and checking the; convergence status of the algorithm, methods to determine the step; length along a given direction, methods to define the starting point,; and the solve method that implements the interior-point algorithm. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpSolverBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tDataNorm(); virtual voidDefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual voidDefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual Int_tDefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tDoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpSolverBase.html:721,avail,available,721,root/html528/TQpSolverBase.html,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html,4,['avail'],['available']
Availability,". TRandom2. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TRandom2. class TRandom2: public TRandom. TRandom2. Random number generator class based on the maximally quidistributed combined; Tausworthe generator by L'Ecuyer. The period of the generator is 2**88 (about 10**26) and it uses only 3 words; for the state. For more information see:; P. L'Ecuyer, Mathematics of Computation, 65, 213 (1996); P. L'Ecuyer, Mathematics of Computation, 68, 225 (1999). The publication are available online at; http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme.ps; http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme2.ps. Function Members (Methods); public:. virtual~TRandom2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTRandom::Binomial(Int_t ntot, Double_t prob); virtual Double_tTRandom::BreitWigner(Double_t mean = 0, Double_t gamma = 1); virtual voidTObject::Browse(TBrowser* b); virtual voidTRandom::Circle(Double_t& x, Double_t& y, Double_t r); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRandom2.html:689,avail,available,689,root/html602/TRandom2.html,https://root.cern,https://root.cern/root/html602/TRandom2.html,2,['avail'],['available']
Availability,". TRandom2. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TRandom2. class TRandom2: public TRandom. TRandom2. Random number generator class based on the maximally quidistributed combined; Tausworthe generator by L'Ecuyer. The period of the generator is 2**88 (about 10**26) and it uses only 3 words; for the state. For more information see:; P. L'Ecuyer, Mathematics of Computation, 65, 213 (1996); P. L'Ecuyer, Mathematics of Computation, 68, 225 (1999). The publication are available online at; http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme.ps; http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme2.ps. Function Members (Methods); public:. TRandom2(UInt_t seed = 1); TRandom2(const TRandom2&); virtual~TRandom2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTRandom::Binomial(Int_t ntot, Double_t prob); virtual Double_tTRandom::BreitWigner(Double_t mean = 0, Double_t gamma = 1); virtual voidTObject::Browse(TBrowser* b); virtual voidTRandom::Circle(Double_t& x, Double_t& y, Double_t r); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRandom2.html:665,avail,available,665,root/html528/TRandom2.html,https://root.cern,https://root.cern/root/html528/TRandom2.html,4,['avail'],['available']
Availability,". TRobustEstimator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TRobustEstimator. class TRobustEstimator: public TObject. TRobustEstimator. Minimum Covariance Determinant Estimator - a Fast Algorithm; invented by Peter J.Rousseeuw and Katrien Van Dreissen; ""A Fast Algorithm for the Minimum covariance Determinant Estimator""; Technometrics, August 1999, Vol.41, NO.3. What are robust estimators?; ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recongize them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRobustEstimator.html:591,robust,robust,591,root/html602/TRobustEstimator.html,https://root.cern,https://root.cern/root/html602/TRobustEstimator.html,6,['robust'],"['robust', 'robustness']"
Availability,". TRobustEstimator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TRobustEstimator. class TRobustEstimator: public TObject. TRobustEstimator. Minimum Covariance Determinant Estimator - a Fast Algorithm; invented by Peter J.Rousseeuw and Katrien Van Dreissen; ""A Fast Algorithm for the Minimum covariance Determinant Estimator""; Technometrics, August 1999, Vol.41, NO.3. What are robust estimators?; ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recongize them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is ef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRobustEstimator.html:567,robust,robust,567,root/html528/TRobustEstimator.html,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html,12,['robust'],"['robust', 'robustness']"
Availability,". TRootAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » AUTH; » TRootAuth. class TRootAuth: public TVirtualAuth. TRootAuth. TVirtualAuth implementation based on the old client authentication; code. Function Members (Methods); public:. virtual~TRootAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options = """"); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode = -1); virtual TClass*IsA() const; virtual const char*Name(); TRootAuth&operator=(const TRootAuth&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TRootAuth(); TRootAuth(const TRootAuth&). Class Charts. Inheritance Chart:. TVirtualAuth. ←; TRootAuth. Function documentation; TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options = """"); Runs authentication on socket s.; Invoked when dynamic loading is needed.; Returns 1 on success, 0 on failure. Int_t ClientVersion(); Return client version;. void ErrorMsg(const char* where, Int_t ecode = -1); Print error string corresponding to ecode, prepending location. TRootAuth(); { }. virtual ~TRootAuth(); { }. const char * Name(); { return ""Root""; }. » Author: Gerardo Ganis 08/07/05 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRootAuth.html:1245,failure,failure,1245,root/html602/TRootAuth.html,https://root.cern,https://root.cern/root/html602/TRootAuth.html,2,"['error', 'failure']","['error', 'failure']"
Availability,". TRootAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » AUTH; » TRootAuth. class TRootAuth: public TVirtualAuth. TRootAuth. TVirtualAuth implementation based on the old client authentication; code. Function Members (Methods); public:. virtual~TRootAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options = """"); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode = -1); virtual TClass*IsA() const; virtual const char*Name(); TRootAuth&operator=(const TRootAuth&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TRootAuth(); TRootAuth(const TRootAuth&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options = """"); Runs authentication on socket s.; Invoked when dynamic loading is needed.; Returns 1 on success, 0 on failure. Int_t ClientVersion(); Return client version;. void ErrorMsg(const char* where, Int_t ecode = -1); Print error string corresponding to ecode, prepending location. TRootAuth(); { }. virtual ~TRootAuth(); { }. const char * Name(); { return ""Root""; }. » Author: Gerardo Ganis 08/07/05 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRootAuth.html:1226,failure,failure,1226,root/html604/TRootAuth.html,https://root.cern,https://root.cern/root/html604/TRootAuth.html,2,"['error', 'failure']","['error', 'failure']"
Availability,". TRootContextMenu. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TRootContextMenu. class TRootContextMenu: public TGPopupMenu, public TContextMenuImp. TRootContextMenu. This class provides an interface to context sensitive popup menus.; These menus pop up when the user hits the right mouse button, and; are destroyed when the menu pops downs.; The picture below shows a canvas with a pop-up menu. ; . The picture below shows a canvas with a pop-up menu and a dialog box. ; . Function Members (Methods); public:. virtual~TRootContextMenu(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGPopupMenu::Activate(Bool_t); virtual voidTGPopupMenu::Activate(TGMenuEntry* entry); virtual voidTGPopupMenu::Activated(Int_t id)SIGNAL ; virtual voidTGPopupMenu::AddEntry(TGHotString* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddEntry(const char* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTGPopupMenu::AddLabel(TGHotString* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddLabel(const char* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddPopup(TGHotString* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddPopup(const char* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddSeparator(TGMenuEntry* before = 0); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGPopupMenu::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRootContextMenu.html:545,down,downs,545,root/html602/TRootContextMenu.html,https://root.cern,https://root.cern/root/html602/TRootContextMenu.html,1,['down'],['downs']
Availability,". TRootContextMenu. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TRootContextMenu. class TRootContextMenu: public TGPopupMenu, public TContextMenuImp. TRootContextMenu. This class provides an interface to context sensitive popup menus.; These menus pop up when the user hits the right mouse button, and; are destroyed when the menu pops downs.; The picture below shows a canvas with a pop-up menu. ; . The picture below shows a canvas with a pop-up menu and a dialog box. ; . Function Members (Methods); public:. TRootContextMenu(TContextMenu* c = 0, const char* name = ""ROOT Context Menu""); virtual~TRootContextMenu(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGPopupMenu::Activate(Bool_t); virtual voidTGPopupMenu::Activate(TGMenuEntry* entry); virtual voidTGPopupMenu::Activated(Int_t id)SIGNAL ; virtual voidTGPopupMenu::AddEntry(TGHotString* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddEntry(const char* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTGPopupMenu::AddLabel(TGHotString* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddLabel(const char* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddPopup(TGHotString* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddPopup(const char* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddSeparator(TGMenuEntry* before = 0); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGPopupMenu::Associate(const TGWindow* w); stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRootContextMenu.html:521,down,downs,521,root/html528/TRootContextMenu.html,https://root.cern,https://root.cern/root/html528/TRootContextMenu.html,4,['down'],['downs']
Availability,". TRootContextMenu. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TRootContextMenu. class TRootContextMenu: public TGPopupMenu, public TContextMenuImp. TRootContextMenu. This class provides an interface to context sensitive popup menus.; These menus pop up when the user hits the right mouse button, and; are destroyed when the menu pops downs.; The picture below shows a canvas with a pop-up menu. ; . The picture below shows a canvas with a pop-up menu and a dialog box. ; . Function Members (Methods); public:. virtual~TRootContextMenu(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGPopupMenu::Activate(Bool_t); virtual voidTGPopupMenu::Activate(TGMenuEntry* entry); virtual voidTGPopupMenu::Activated(Int_t id)SIGNAL ; virtual voidTGPopupMenu::AddEntry(TGHotString* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddEntry(const char* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTGPopupMenu::AddLabel(TGHotString* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddLabel(const char* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddPopup(TGHotString* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddPopup(const char* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddSeparator(TGMenuEntry* before = 0); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGPopupMenu::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRootContextMenu.html:521,down,downs,521,root/html604/TRootContextMenu.html,https://root.cern,https://root.cern/root/html604/TRootContextMenu.html,1,['down'],['downs']
Availability,". TRootIOCtor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRootIOCtor. class TRootIOCtor. TRootIOCtor. Helper class used to mark a constructor to be used by ROOT instead; of the default constructor.; If rootcint sees in a class declaration of the class MyClass:; MyClass(TRootIOCtor*);; This constructor will be used instead of the default constructor. Also the pragma:; #pragma link C++ ioctortype MyMarker;; can be used to tell rootcint that a constuctor taking a MyMarker*; should be used whenever available. Function Members (Methods); public:. TRootIOCtor(); TRootIOCtor(const TRootIOCtor&); ~TRootIOCtor(); TRootIOCtor&operator=(const TRootIOCtor&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: Philippe Canal 15/03/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TRootIOCtor.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2010-10-29 07:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRootIOCtor.html:663,avail,available,663,root/html528/TRootIOCtor.html,https://root.cern,https://root.cern/root/html528/TRootIOCtor.html,1,['avail'],['available']
Availability,". TRootIOCtor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRootIOCtor. class TRootIOCtor. TRootIOCtor. Helper class used to mark a constructor to be used by ROOT instead; of the default constructor.; If rootcint sees in a class declaration of the class MyClass:; MyClass(TRootIOCtor*);; This constructor will be used instead of the default constructor. Also the pragma:; #pragma link C++ ioctortype MyMarker;; can be used to tell rootcint that a constuctor taking a MyMarker*; should be used whenever available. Function Members (Methods); public:. ~TRootIOCtor(); TRootIOCtor&operator=(const TRootIOCtor&); TRootIOCtor&operator=(TRootIOCtor&&); TRootIOCtor(); TRootIOCtor(const TRootIOCtor&); TRootIOCtor(TRootIOCtor&&). Class Charts. Inheritance Chart:. TRootIOCtor. Function documentation. » Author: Philippe Canal 15/03/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRootIOCtor.html:689,avail,available,689,root/html602/TRootIOCtor.html,https://root.cern,https://root.cern/root/html602/TRootIOCtor.html,1,['avail'],['available']
Availability,". TRootIOCtor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRootIOCtor. class TRootIOCtor. TRootIOCtor. Helper class used to mark a constructor to be used by ROOT instead; of the default constructor.; If rootcint sees in a class declaration of the class MyClass:; MyClass(TRootIOCtor*);; This constructor will be used instead of the default constructor. Also the pragma:; #pragma link C++ ioctortype MyMarker;; can be used to tell rootcint that a constuctor taking a MyMarker*; should be used whenever available. Function Members (Methods); public:. TRootIOCtor(); TRootIOCtor(const TRootIOCtor&); ~TRootIOCtor(); TRootIOCtor&operator=(const TRootIOCtor&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: Philippe Canal 15/03/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRootIOCtor.html:665,avail,available,665,root/html534/TRootIOCtor.html,https://root.cern,https://root.cern/root/html534/TRootIOCtor.html,1,['avail'],['available']
Availability,". TRootIOCtor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRootIOCtor. class TRootIOCtor. TRootIOCtor. Helper class used to mark a constructor to be used by ROOT instead; of the default constructor.; If rootcint sees in a class declaration of the class MyClass:; MyClass(TRootIOCtor*);; This constructor will be used instead of the default constructor. Also the pragma:; #pragma link C++ ioctortype MyMarker;; can be used to tell rootcint that a constuctor taking a MyMarker*; should be used whenever available. Function Members (Methods); public:. TRootIOCtor(); TRootIOCtor(const TRootIOCtor&); ~TRootIOCtor(); TRootIOCtor&operator=(const TRootIOCtor&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: Philippe Canal 15/03/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TRootIOCtor.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-07-04 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TRootIOCtor.html:665,avail,available,665,root/html530/TRootIOCtor.html,https://root.cern,https://root.cern/root/html530/TRootIOCtor.html,1,['avail'],['available']
Availability,". TRootIOCtor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRootIOCtor. class TRootIOCtor. TRootIOCtor. Helper class used to mark a constructor to be used by ROOT instead; of the default constructor.; If rootcint sees in a class declaration of the class MyClass:; MyClass(TRootIOCtor*);; This constructor will be used instead of the default constructor. Also the pragma:; #pragma link C++ ioctortype MyMarker;; can be used to tell rootcint that a constuctor taking a MyMarker*; should be used whenever available. Function Members (Methods); public:. TRootIOCtor(); TRootIOCtor(const TRootIOCtor&); ~TRootIOCtor(); TRootIOCtor&operator=(const TRootIOCtor&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: Philippe Canal 15/03/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TRootIOCtor.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRootIOCtor.html:665,avail,available,665,root/html532/TRootIOCtor.html,https://root.cern,https://root.cern/root/html532/TRootIOCtor.html,1,['avail'],['available']
Availability,". TRootIOCtor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRootIOCtor. class TRootIOCtor. TRootIOCtor. Helper class used to mark a constructor to be used by ROOT instead; of the default constructor.; If rootcint sees in a class declaration of the class MyClass:; MyClass(TRootIOCtor*);; This constructor will be used instead of the default constructor. Also the pragma:; #pragma link C++ ioctortype MyMarker;; can be used to tell rootcint that a constuctor taking a MyMarker*; should be used whenever available. Function Members (Methods); public:. ~TRootIOCtor(); TRootIOCtor&operator=(const TRootIOCtor&); TRootIOCtor&operator=(TRootIOCtor&&); TRootIOCtor(); TRootIOCtor(const TRootIOCtor&); TRootIOCtor(TRootIOCtor&&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: Philippe Canal 15/03/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRootIOCtor.html:665,avail,available,665,root/html604/TRootIOCtor.html,https://root.cern,https://root.cern/root/html604/TRootIOCtor.html,1,['avail'],['available']
Availability,". TSPlot. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SPLOT; » TSPlot. class TSPlot: public TObject. . Overview. A common method used in High Energy Physics to perform measurements is; the maximum Likelihood method, exploiting discriminating variables to; disentangle signal from background. The crucial point for such an; analysis to be reliable is to use an exhaustive list of sources of; events combined with an accurate description of all the Probability; Density Functions (PDF).; To assess the validity of the fit, a convincing quality check; is to explore further the data sample by examining the distributions of; control variables. A control variable can be obtained for instance by; removing one of the discriminating variables before performing again; the maximum Likelihood fit: this removed variable is a control; variable. The expected distribution of this control variable, for; signal, is to be compared to the one extracted, for signal, from the; data sample. In order to be able to do so, one must be able to unfold; from the distribution of the whole data sample.; The TSPlot method allows to reconstruct the distributions for; the control variable, independently for each of the various sources of; events, without making use of any a priori knowledge on this; variable. The aim is thus to use the knowledge available for the; discriminating variables to infer the behaviour of the individual; sources of events with respect to the control variable. TSPlot is optimal if the control variable is uncorrelated with the discriminating variables. A detail description of the formalism itself, called ; , is given in [1]. The method. The ; technique is developped in the above context of a maximum Likelihood method making use of discriminating variables.; One considers a data sampl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSPlot.html:541,reliab,reliable,541,root/html602/TSPlot.html,https://root.cern,https://root.cern/root/html602/TSPlot.html,2,['reliab'],['reliable']
Availability,". TSPlot. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SPLOT; » TSPlot. class TSPlot: public TObject. . Overview. A common method used in High Energy Physics to perform measurements is; the maximum Likelihood method, exploiting discriminating variables to; disentangle signal from background. The crucial point for such an; analysis to be reliable is to use an exhaustive list of sources of; events combined with an accurate description of all the Probability; Density Functions (PDF).; To assess the validity of the fit, a convincing quality check; is to explore further the data sample by examining the distributions of; control variables. A control variable can be obtained for instance by; removing one of the discriminating variables before performing again; the maximum Likelihood fit: this removed variable is a control; variable. The expected distribution of this control variable, for; signal, is to be compared to the one extracted, for signal, from the; data sample. In order to be able to do so, one must be able to unfold; from the distribution of the whole data sample.; The TSPlot method allows to reconstruct the distributions for; the control variable, independently for each of the various sources of; events, without making use of any a priori knowledge on this; variable. The aim is thus to use the knowledge available for the; discriminating variables to infer the behaviour of the individual; sources of events with respect to the control variable. TSPlot is optimal if the control variable is uncorrelated with the discriminating variables. A detail description of the formalism itself, called ; , is given in [1]. The method. The ; technique is developped in the above context of a maximum Likelihood method making use of discriminating variables.; One considers a data sample in which are merged se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSPlot.html:517,reliab,reliable,517,root/html528/TSPlot.html,https://root.cern,https://root.cern/root/html528/TSPlot.html,4,['reliab'],['reliable']
Availability,". TSQLResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLResult. class TSQLResult: public TObject. TSQLResult. Abstract base class defining interface to a SQL query result.; Objects of this class are created by TSQLServer methods. Related classes are TSQLServer and TSQLRow. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLResult.html:623,avail,available,623,root/html602/TSQLResult.html,https://root.cern,https://root.cern/root/html602/TSQLResult.html,2,['avail'],['available']
Availability,". TSQLResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLResult. class TSQLResult: public TObject. TSQLResult. Abstract base class defining interface to a SQL query result.; Objects of this class are created by TSQLServer methods. Related classes are TSQLServer and TSQLRow. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSQLResult.html:599,avail,available,599,root/html528/TSQLResult.html,https://root.cern,https://root.cern/root/html528/TSQLResult.html,4,['avail'],['available']
Availability,". TSQLRow. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLRow. class TSQLRow: public TObject. TSQLRow. Abstract base class defining interface to a row of a SQL query; result. Objects of this class are created by TSQLResult methods. Related classes are TSQLServer and TSQLResult. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLRow.html:623,avail,available,623,root/html602/TSQLRow.html,https://root.cern,https://root.cern/root/html602/TSQLRow.html,2,['avail'],['available']
Availability,". TSQLRow. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLRow. class TSQLRow: public TObject. TSQLRow. Abstract base class defining interface to a row of a SQL query; result. Objects of this class are created by TSQLResult methods. Related classes are TSQLServer and TSQLResult. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDraw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSQLRow.html:599,avail,available,599,root/html528/TSQLRow.html,https://root.cern,https://root.cern/root/html528/TSQLRow.html,4,['avail'],['available']
Availability,". TSQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLServer. class TSQLServer: public TObject. TSQLServer. Abstract base class defining interface to a SQL server. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; <dbms>://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main, ...; Depending on the <dbms> specified an appropriate plugin library; will be loaded which will provide the real interface. Related classes are TSQLResult and TSQLRow. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tDropDataBase(const char* dbname); virtual voidTObject::Dump() constMENU ; virtual voidEnableErrorOutput(Bool_t on = kTRUE); virtual voidTObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSQLServer.html:879,avail,available,879,root/html528/TSQLServer.html,https://root.cern,https://root.cern/root/html528/TSQLServer.html,3,['avail'],['available']
Availability,". TSVDUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TSVDUnfold. class TSVDUnfold: public TObject. SVD Approach to Data Unfolding. Reference: Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307]. TSVDUnfold implements the singular value decomposition based unfolding method (see reference). Currently, the unfolding of one-dimensional histograms is supported, with the same number of bins for the measured and the unfolded spectrum.; ; The unfolding procedure is based on singular value decomposition of the response matrix. The regularisation of the unfolding is implemented via a discrete minimum-curvature condition.; ; Monte Carlo inputs:; ; xini: true underlying spectrum (TH1D, n bins); bini: reconstructed spectrum (TH1D, n bins); Adet: response matrix (TH2D, nxn bins); ; Consider the unfolding of a measured spectrum bdat with covariance matrix Bcov (if not passed explicitly, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis.; ; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by; . TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; . where kreg determines the regularisation of the unfolding. In general, overregularisation (too small kreg) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large kreg) will lead to large fluctuation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSVDUnfold.html:1126,error,errors,1126,root/html534/TSVDUnfold.html,https://root.cern,https://root.cern/root/html534/TSVDUnfold.html,1,['error'],['errors']
Availability,". TSeqCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TSeqCollection. class TSeqCollection: public TCollection. TSeqCollection. Sequenceable collection abstract base class. TSeqCollection's have; an ordering relation, i.e. there is a first and last element. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSeqCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*At(Int_t idx) const; virtual TObject*Before(const TObject* obj) const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTCollection::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTCollection::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSeqCollection.html:611,avail,available,611,root/html602/TSeqCollection.html,https://root.cern,https://root.cern/root/html602/TSeqCollection.html,2,['avail'],['available']
Availability,". TSeqCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TSeqCollection. class TSeqCollection: public TCollection. TSeqCollection. Sequenceable collection abstract base class. TSeqCollection's have; an ordering relation, i.e. there is a first and last element. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSeqCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*At(Int_t idx) const; virtual TObject*Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTCollection::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTCollection::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSeqCollection.html:587,avail,available,587,root/html530/TSeqCollection.html,https://root.cern,https://root.cern/root/html530/TSeqCollection.html,3,['avail'],['available']
Availability,". TSeqCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TSeqCollection. class TSeqCollection: public TCollection. TSeqCollection. Sequenceable collection abstract base class. TSeqCollection's have; an ordering relation, i.e. there is a first and last element. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSeqCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*At(Int_t idx) const; virtual TObject*Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTCollection::Clear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTCollection::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSeqCollection.html:587,avail,available,587,root/html528/TSeqCollection.html,https://root.cern,https://root.cern/root/html528/TSeqCollection.html,1,['avail'],['available']
Availability,". TSpider. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TSpider. class TSpider: public TObject, public TAttFill, public TAttLine. Spider class; A spider view is a handy way to visualize a set of data stored in a TTree. It draws as; many polar axes as selected data members. For each of them, it draws on the axis; the position of the present event between the min and max of the data member.; Two modes are availables:. The spider view: With each points on the axes is drawn a polyline.; The segment view: For each data member is drawn an arc segment with the radius corresponding to the event. The spider plot is available from the treeviewer called by ""atree->StartViewer()"", or simply by calling its constructor and defining the variables to display. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""TSpider example"",200,10,700,700);; TFile *f = new TFile(""$(ROOTSYS)/tutorials/hsimple.root"");; if (!f || f->IsZombie()) {; printf(""Please run <ROOT location>/tutorials/hsimple.C before."");; return;; }; TNtuple* ntuple = (TNtuple*)f->Get(""ntuple"");; TString varexp = ""px:py:pz:random:sin(px):log(px/py):log(pz)"";; TString selectStr = ""px>0 && py>0 && pz>0"";; TString options = ""average"";; TSpider *spider = new TSpider(ntuple,varexp.Data(),selectStr.Data(),options.Data());; spider->Draw();; c1->ToggleEditor();; c1->Selected(c1,spider,1);; return c1;; }. Function Members (Methods); public:. virtual~TSpider(); voidTObject::AbstractMethod(const char* method) const; voidAddSuperposed(TSpider* sp); voidAddVariable(const char* varexp)MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpider.html:623,avail,availables,623,root/html602/TSpider.html,https://root.cern,https://root.cern/root/html602/TSpider.html,4,['avail'],"['available', 'availables']"
Availability,". TSpider. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TSpider. class TSpider: public TObject, public TAttFill, public TAttLine. Spider class; A spider view is a handy way to visualize a set of data stored in a TTree. It draws as; many polar axes as selected data members. For each of them, it draws on the axis; the position of the present event between the min and max of the data member.; Two modes are availables:. The spider view: With each points on the axes is drawn a polyline.; The segment view: For each data member is drawn an arc segment with the radius corresponding to the event. The spider plot is available from the treeviewer called by ""atree->StartViewer()"", or simply by calling its constructor and defining the variables to display. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""TSpider example"",200,10,700,700);; TFile *f = new TFile(""$(ROOTSYS)/tutorials/hsimple.root"");; if (!f || f->IsZombie()) {; printf(""Please run <ROOT location>/tutorials/hsimple.C before."");; return;; }; TNtuple* ntuple = f->Get(""ntuple"");; TString varexp = ""px:py:pz:random:sin(px):log(px/py):log(pz)"";; TString select = ""px>0 && py>0 && pz>0"";; TString options = ""average"";; TSpider *spider = new TSpider(ntuple,varexp.Data(),select.Data(),options.Data());; spider->Draw();; c1->ToggleEditor();; c1->Selected(c1,spider,1);; return c1;; }. Function Members (Methods); public:. TSpider(); TSpider(const TSpider&); TSpider(TTree* tree, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 0, Long64_t firstentry = 0); virtual~TSpider(); voidTObject::AbstractMethod(const char* method) const; voidAddSuperposed(TSpider* sp); voidAddVariable(const char* varexp)MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSpider.html:599,avail,availables,599,root/html530/TSpider.html,https://root.cern,https://root.cern/root/html530/TSpider.html,6,['avail'],"['available', 'availables']"
Availability,". TSpline. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TSpline. class TSpline: public TNamed, public TAttLine, public TAttFill, public TAttMarker. TSpline. Base class for spline implementation containing the Draw/Paint; methods. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSpline(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpline.html:574,avail,available,574,root/html602/TSpline.html,https://root.cern,https://root.cern/root/html602/TSpline.html,2,['avail'],['available']
Availability,". TSpline. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TSpline. class TSpline: public TNamed, public TAttLine, public TAttFill, public TAttMarker. TSpline. Base class for spline implementation containing the Draw/Paint; methods. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSpline(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpline.html:550,avail,available,550,root/html528/TSpline.html,https://root.cern,https://root.cern/root/html528/TSpline.html,4,['avail'],['available']
Availability,". TStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TStatistic. class TStatistic: public TObject. TStatistic. Statistical variable, defined by its mean, RMS and related errors.; Named, streamable, storable and mergeable. Function Members (Methods); public:. virtual~TStatistic(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t val, Double_t w = 1.); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetM2() const; Double_tGetMean() const; Double_tGetMeanErr() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStatistic.html:366,error,errors,366,root/html602/TStatistic.html,https://root.cern,https://root.cern/root/html602/TStatistic.html,1,['error'],['errors']
Availability,". TStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TStatistic. class TStatistic: public TObject. TStatistic. Statistical variable, defined by its mean, RMS and related errors.; Named, streamable, storable and mergeable. Function Members (Methods); public:. TStatistic(const char* name = """"); TStatistic(const TStatistic&); TStatistic(const char* name, Int_t n, const Double_t* val, const Double_t* w = 0); virtual~TStatistic(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t val, Double_t w = 1.); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStatistic.html:342,error,errors,342,root/html534/TStatistic.html,https://root.cern,https://root.cern/root/html534/TStatistic.html,1,['error'],['errors']
Availability,". TStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TStatistic. class TStatistic: public TObject. TStatistic. Statistical variable, defined by its mean, RMS and related errors.; Named, streamable, storable and mergeable. Function Members (Methods); public:. virtual~TStatistic(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t val, Double_t w = 1.); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetM2() const; Double_tGetMean() const; Double_tGetMeanErr() const; Long64_tGetN() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TStatistic.html:342,error,errors,342,root/html604/TStatistic.html,https://root.cern,https://root.cern/root/html604/TStatistic.html,1,['error'],['errors']
Availability,". TStatus. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TStatus. class TStatus: public TNamed. TStatus. This class holds the status of an ongoing operation and collects; error messages. It provides a Merge() operation allowing it to; be used in PROOF to monitor status in the slaves.; No messages indicates success. Function Members (Methods); public:. virtual~TStatus(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const char* mesg); voidAddInfo(const char* mesg); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStatus.html:388,error,error,388,root/html602/TStatus.html,https://root.cern,https://root.cern/root/html602/TStatus.html,2,['error'],['error']
Availability,". TStatus. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TStatus. class TStatus: public TNamed. TStatus. This class holds the status of an ongoing operation and collects; error messages. It provides a Merge() operation allowing it to; be used in PROOF to monitor status in the slaves.; No messages indicates success. Function Members (Methods); public:. TStatus(); TStatus(const TStatus&); virtual~TStatus(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const char* mesg); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStatus.html:364,error,error,364,root/html528/TStatus.html,https://root.cern,https://root.cern/root/html528/TStatus.html,3,['error'],['error']
Availability,". TStatus. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TStatus. class TStatus: public TNamed. TStatus. This class holds the status of an ongoing operation and collects; error messages. It provides a Merge() operation allowing it to; be used in PROOF to monitor status in the slaves.; No messages indicates success. Function Members (Methods); public:. TStatus(); virtual~TStatus(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const char* mesg); voidAddInfo(const char* mesg); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStatus.html:364,error,error,364,root/html534/TStatus.html,https://root.cern,https://root.cern/root/html534/TStatus.html,1,['error'],['error']
Availability,". TStdExceptionHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TStdExceptionHandler. class TStdExceptionHandler: public TSysEvtHandler. TSysEvtHandler. Abstract base class for handling system events. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TStdExceptionHandler(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; voidTSysEvtHandler::DeActivate(); virtual voidTSysEvtHandler::DeActivated()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStdExceptionHandler.html:550,avail,available,550,root/html602/TStdExceptionHandler.html,https://root.cern,https://root.cern/root/html602/TStdExceptionHandler.html,2,['avail'],['available']
Availability,". TStdExceptionHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TStdExceptionHandler. class TStdExceptionHandler: public TSysEvtHandler. TSysEvtHandler. Abstract base class for handling system events. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TStdExceptionHandler(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; voidTSysEvtHandler::DeActivate(); virtual voidTSysEvtHandler::DeActivated()SIGNAL ; virtual voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStdExceptionHandler.html:526,avail,available,526,root/html528/TStdExceptionHandler.html,https://root.cern,https://root.cern/root/html528/TStdExceptionHandler.html,4,['avail'],['available']
Availability,". TStyleManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TStyleManager. class TStyleManager: public TGMainFrame. TStyleManager. This class provides a Graphical User Interface to manage styles; in ROOT. It allows the user to edit styles, import / export; them to macros, apply a style on the selected object or on; all canvases, change gStyle. Activate the style manager by selecting Edit menu / Style...; in the canvas window. The Style Manager interface is composed of two parts:; - the top level interface that manages a list of styles;; - the style editor, which deals with the current style settings. /*. */. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStyleManager.html:880,avail,available,880,root/html602/TStyleManager.html,https://root.cern,https://root.cern/root/html602/TStyleManager.html,2,['avail'],['available']
Availability,". TStyleManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TStyleManager. class TStyleManager: public TGMainFrame. TStyleManager. This class provides a Graphical User Interface to manage styles; in ROOT. It allows the user to edit styles, import / export; them to macros, apply a style on the selected object or on; all canvases, change gStyle. Activate the style manager by selecting Edit menu / Style...; in the canvas window. The Style Manager interface is composed of two parts:; - the top level interface that manages a list of styles;; - the style editor, which deals with the current style settings. /*. */. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New... or the toolbar.; A c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyleManager.html:856,avail,available,856,root/html528/TStyleManager.html,https://root.cern,https://root.cern/root/html528/TStyleManager.html,4,['avail'],['available']
Availability,". TSysEvtHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TSysEvtHandler. class TSysEvtHandler: public TObject, public TQObject. TSysEvtHandler. Abstract base class for handling system events. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSysEvtHandler(); voidTObject::AbstractMethod(const char* method) const; voidActivate(); virtual voidActivated()SIGNAL ; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; voidDeActivate(); virtual voidDeActivated()SIGNAL ; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTQObject::Destro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSysEvtHandler.html:542,avail,available,542,root/html602/TSysEvtHandler.html,https://root.cern,https://root.cern/root/html602/TSysEvtHandler.html,2,['avail'],['available']
Availability,". TSysEvtHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TSysEvtHandler. class TSysEvtHandler: public TObject, public TQObject. TSysEvtHandler. Abstract base class for handling system events. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSysEvtHandler(); voidTObject::AbstractMethod(const char* method) const; voidActivate(); virtual voidActivated()SIGNAL ; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; voidDeActivate(); virtual voidDeActivated()SIGNAL ; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTQObject::Destroyed()SIGNAL ; Bool_tTQOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSysEvtHandler.html:518,avail,available,518,root/html528/TSysEvtHandler.html,https://root.cern,https://root.cern/root/html528/TSysEvtHandler.html,4,['avail'],['available']
Availability,". TTableRange. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TTableRange. class TTableRange. TGTable. TGTable implements a table widget to display data in rows and; columns. The data is supplied by a TVirtualTableInterface. The table is a TGCanvas to make use of already available viewport; functionality and drawing optimizations. The top left cell in a table has coordinates (0,0). A TObjArray is used internally to ensure little overhead and fast; acces to cells. If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTableRange.html:478,avail,available,478,root/html602/TTableRange.html,https://root.cern,https://root.cern/root/html602/TTableRange.html,2,['avail'],['available']
Availability,". TTableRange. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TTableRange. class TTableRange. TGTable; ; TGTable implements a table widget to display data in rows and ; columns. The data is supplied by a TVirtualTableInterface. . The table is a TGCanvas to make use of already available viewport ; functionality and drawing optimizations. . The top left cell in a table has coordinates (0,0) . A TObjArray is used internally to ensure little overhead and fast ; acces to cells. . If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate ; TVirtualTableInterface from the data that needs visualization and ; then creating the TGTable using this interface. . A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTableRange.html:459,avail,available,459,root/html528/TTableRange.html,https://root.cern,https://root.cern/root/html528/TTableRange.html,3,['avail'],['available']
Availability,". TThreadFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TThreadFactory. class TThreadFactory: public TNamed. TThreadFactory. This ABC is a factory for thread components. Depending on which; factory is active one gets either Posix or Win32 threads. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TThreadFactory(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual TConditionImp*CreateConditionImp(TMutexImp* m); virtual TMutexImp*CreateMutexImp(Bool_t recursive); virtual TThreadImp*CreateThreadImp(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TThreadFactory.html:601,avail,available,601,root/html602/TThreadFactory.html,https://root.cern,https://root.cern/root/html602/TThreadFactory.html,2,['avail'],['available']
Availability,". TThreadFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TThreadFactory. class TThreadFactory: public TNamed. TThreadFactory. This ABC is a factory for thread components. Depending on which; factory is active one gets either Posix or Win32 threads. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TThreadFactory(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual TConditionImp*CreateConditionImp(TMutexImp* m); virtual TMutexImp*CreateMutexImp(Bool_t recursive); virtual TThreadImp*CreateThreadImp(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TThreadFactory.html:577,avail,available,577,root/html528/TThreadFactory.html,https://root.cern,https://root.cern/root/html528/TThreadFactory.html,4,['avail'],['available']
Availability,". TThreadImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TThreadImp. class TThreadImp: public TObject. TThreadImp. This class implements threads. A thread is an execution environment; much lighter than a process. A single process can have multiple; threads. The actual work is done via the TThreadImp class (either; TPosixThread or TWin32Thread). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TThreadImp(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Int_tCancelPoint(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(void** main); virtual Int_tCleanUpPop(void** main, Int_t exe); virtual Int_tCleanUpPush(void** main, void* free, void* arg); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TThreadImp.html:695,avail,available,695,root/html602/TThreadImp.html,https://root.cern,https://root.cern/root/html602/TThreadImp.html,2,['avail'],['available']
Availability,". TThreadImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TThreadImp. class TThreadImp: public TObject. TThreadImp. This class implements threads. A thread is an execution environment; much lighter than a process. A single process can have multiple; threads. The actual work is done via the TThreadImp class (either; TPosixThread or TWin32Thread). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TThreadImp(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Int_tCancelPoint(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(void** main); virtual Int_tCleanUpPop(void** main, Int_t exe); virtual Int_tCleanUpPush(void** main, void* free, void* arg); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Int_tExit(void* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TThreadImp.html:671,avail,available,671,root/html528/TThreadImp.html,https://root.cern,https://root.cern/root/html528/TThreadImp.html,4,['avail'],['available']
Availability,". TTree * TProof::GetTreeHeader ; (; TDSet * ; tdset). virtual . Creates a tree header (a tree with nonexisting files) object for the DataSet. ; Reimplemented in TProofLite.; Definition at line 10042 of file TProof.cxx. ◆ GetUrl(). const char * TProof::GetUrl ; (; ). inline . Definition at line 911 of file TProof.h. ◆ GetUser(). const char * TProof::GetUser ; (; ); const. inline . Definition at line 906 of file TProof.h. ◆ GetWorkDir(). const char * TProof::GetWorkDir ; (; ); const. inline . Definition at line 908 of file TProof.h. ◆ GoAsynchronous(). void TProof::GoAsynchronous ; (; ). Send GOASYNC message to the master. ; Definition at line 6267 of file TProof.cxx. ◆ GoMoreParallel(). Int_t TProof::GoMoreParallel ; (; Int_t ; nWorkersToAdd). private . Add nWorkersToAdd workers to current list of workers. ; This function is works on the master only, and only when an analysis is ongoing. A message is sent back to the client when we go ""more"" parallel. Returns -1 on error, number of total (not added!) workers on success. ; Definition at line 7170 of file TProof.cxx. ◆ GoParallel(). Int_t TProof::GoParallel ; (; Int_t ; nodes, . Bool_t ; attach = kFALSE, . Bool_t ; random = kFALSE . ). private . Go in parallel mode with at most ""nodes"" slaves. ; Since the fSlaves list is sorted by slave performace the active list will contain first the most performant nodes. Returns the number of active slaves. If random is TRUE, and nodes is less than the number of available workers, a random selection is done. Returns -1 in case of error. ; Definition at line 7273 of file TProof.cxx. ◆ HandleInputMessage(). Int_t TProof::HandleInputMessage ; (; TSlave * ; sl, . TMessage * ; mess, . Bool_t ; deactonfail = kFALSE . ). private . Analyze the received message. ; Returns 0 on success (1 if this the last message from this socket), -1 if any failure occurs. ; Definition at line 3105 of file TProof.cxx. ◆ HandleLibIncPath(). void TProof::HandleLibIncPath ; (; const char * ; what, . Bool_t ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:107965,error,error,107965,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['error'],['error']
Availability,". TTreeFormula. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeFormula. class TTreeFormula: public ROOT::v5::TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidROOT::v5::TFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tROOT::v5::TFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeFormula.html:731,avail,available,731,root/html604/TTreeFormula.html,https://root.cern,https://root.cern/root/html604/TTreeFormula.html,1,['avail'],['available']
Availability,". TTreeFormula. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeFormula. class TTreeFormula: public TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidTFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tTFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeFormula.html:721,avail,available,721,root/html602/TTreeFormula.html,https://root.cern,https://root.cern/root/html602/TTreeFormula.html,1,['avail'],['available']
Availability,". TTreeFormula. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeFormula. class TTreeFormula: public TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. TTreeFormula(); TTreeFormula(const char* name, const char* formula, TTree* tree); virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidTFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tTFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeFormula.html:697,avail,available,697,root/html528/TTreeFormula.html,https://root.cern,https://root.cern/root/html528/TTreeFormula.html,4,['avail'],['available']
Availability,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeReader.html:349,robust,robust,349,root/html602/TTreeReader.html,https://root.cern,https://root.cern/root/html602/TTreeReader.html,2,['robust'],['robust']
Availability,". TUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfold. class TUnfold: public TObject. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. A short summary of the algorithm is given in the following:. the ""best"" x matching the measurement y within errors; is determined by minimizing the function; L1+L2+L3. where; L1 = (y-Ax)# Vyy^-1 (y-Ax); L2 = tau^2 (L(x-x0))# L(x-x0); L3 = lambda sum_i(y_i -(Ax)_i). [the notation # means that the matrix is transposed ]. The term L1 is familiar from a least-square minimisation; The term L2 defines the regularisation (smootheness condition on x),; where the parameter tau^2 gives the strength of teh regularisation; The term L3 is an optional area constraint with Lagrangian parameter; lambda, ensuring that that the normalisation of x is consistent with the; normalisation of y. The method can be applied to a very large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Input from measurement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation stre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfold.html:701,avail,available,701,root/html602/TUnfold.html,https://root.cern,https://root.cern/root/html602/TUnfold.html,4,"['avail', 'error']","['available', 'errors']"
Availability,". TUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfold. class TUnfold: public TObject. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. A short summary of the algorithm is given in the following:. the ""best"" x matching the measurement y within errors; is determined by minimizing the function; L1+L2+L3. where; L1 = (y-Ax)# Vyy^-1 (y-Ax); L2 = tau^2 (L(x-x0))# L(x-x0); L3 = lambda sum_i(y_i -(Ax)_i). [the notation # means that the matrix is transposed ]. The term L1 is familiar from a least-square minimisation; The term L2 defines the regularisation (smootheness condition on x),; where the parameter tau^2 gives the strength of teh regularisation; The term L3 is an optional area constraint with Lagrangian parameter; lambda, ensuring that that the normalisation of x is consistent with the; normalisation of y. The method can be applied to a very large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Input from measurement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfold.html:677,avail,available,677,root/html534/TUnfold.html,https://root.cern,https://root.cern/root/html534/TUnfold.html,2,"['avail', 'error']","['available', 'errors']"
Availability,". TUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfold. class TUnfold: public TObject. TUnfold solves the inverse problem. chi**2 = (y-Ax)# Vyy^-1 (y-Ax) + tau^2 (L(x-x0))# L(x-x0) + lambda sum_i(y_i -(Ax)_i). where # means that the matrix is transposed. Monte Carlo input. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y; A: migration matrix (dimension ny x nx); x: unknown underlying distribution (dimension nx). Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); x0: bias distribution. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. and chi**2 is minimized; (a) not constrained: minimisation is performed a function of x for fixed lambda=0; or; (b) constrained: minimisation is performed a function of x and lambda. This applies to a very large number of problems, where the measured; distribution y is a linear superposition of several Monte Carlo shapes; and the sum of these shapes gives the output distribution x. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documenta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfold.html:620,error,errors,620,root/html528/TUnfold.html,https://root.cern,https://root.cern/root/html528/TUnfold.html,3,['error'],['errors']
Availability,". TUnfoldBinning. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldBinning. class TUnfoldBinning: public TNamed. TUnfoldBinning. This class serves as a container of analysis bins; analysis bins are specified by defining the axes of a distribution.; It is also possible to have unconnected analysis bins without axis.; Multiple TUnfoldBinning objects may be arranged in a tree,; such that a full tree structure of histograms and bins is supported. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. Functionality. The class gives access to all analysis bins numbered in sequence.; Such a sequence of bins may be stored in a 1-dimension histogram.; Correlations between two TUnfoldBinning objects may be stored in; a 2-dimensional histogram. This type of ordering is required for; the TUnfold class. In addition, it is possible to have root histograms, using the; axes as defined with the distributions. Underflow/overflow bins; can be included or excluded when mapping bins on root histograms.; In addition, it is possible to collapse one of more axes when going; from a N-dimensional distribution to a root histogram. Function Members (Methods); public:. virtual~TUnfoldBinning(); voidTObject::AbstractMethod(const char* method) const; Bool_tAddAxis(const TAxis& axis, Bool_t includeUnderflow, Bool_t includeOverflow); Bool_tAddAxis(const char* name, Int_t nBins, const Double_t* binBorders, Bool_t hasUnderflow, Bool_t hasOverflow); Bool_tAddAxis(const char* name, Int_t nBins, Double_t xMin, Double_t xMax, Bool_t hasUnderflow, Bool_t hasOverflow); TUnfoldBinning*AddBinning(TUnfoldBinning* binning); TUnfoldBinning*AddBinning(const char* n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfoldBinning.html:813,avail,available,813,root/html602/TUnfoldBinning.html,https://root.cern,https://root.cern/root/html602/TUnfoldBinning.html,2,['avail'],['available']
Availability,". TUnfoldBinning. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldBinning. class TUnfoldBinning: public TNamed. TUnfoldBinning. This class serves as a container of analysis bins; analysis bins are specified by defining the axes of a distribution.; It is also possible to have unconnected analysis bins without axis.; Multiple TUnfoldBinning objects may be arranged in a tree,; such that a full tree structure of histograms and bins is supported. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. Functionality. The class gives access to all analysis bins numbered in sequence.; Such a sequence of bins may be stored in a 1-dimension histogram.; Correlations between two TUnfoldBinning objects may be stored in; a 2-dimensional histogram. This type of ordering is required for; the TUnfold class. In addition, it is possible to have root histograms, using the; axes as defined with the distributions. Underflow/overflow bins; can be included or excluded when mapping bins on root histograms.; In addition, it is possible to collapse one of more axes when going; from a N-dimensional distribution to a root histogram. Function Members (Methods); public:. TUnfoldBinning(const TUnfoldBinning&); TUnfoldBinning(const char* name = 0, Int_t nBins = 0, const char* binNames = 0); TUnfoldBinning(const TAxis& axis, Int_t includeUnderflow, Int_t includeOverflow); virtual~TUnfoldBinning(); voidTObject::AbstractMethod(const char* method) const; Bool_tAddAxis(const TAxis& axis, Bool_t includeUnderflow, Bool_t includeOverflow); Bool_tAddAxis(const char* name, Int_t nBins, const Double_t* binBorders, Bool_t hasUnderflow, Bool_t hasOverflow); Bool_tAddAxis(const char* name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldBinning.html:789,avail,available,789,root/html534/TUnfoldBinning.html,https://root.cern,https://root.cern/root/html534/TUnfoldBinning.html,1,['avail'],['available']
Availability,". TUnfoldDensity. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldDensity. class TUnfoldDensity: public TUnfoldSys. TUnfoldDensity : public TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. More details are described with the documentation of TUnfold. For most applications, it is best to use TUnfoldDensity; instead of using TUnfoldSys or TUnfold. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. As compared to TUnfold, TUndolfDensity adds the following functionality; * background subtraction (see documentation of TUnfoldSys); * error propagation (see documentation of TUnfoldSys); * regularisation schemes respecting the bin widths; * support for complex, multidimensional input distributions. Complex binning schemes are imposed on the measurements y and; on the result vector x with the help of the class TUnfoldBinning; The components of x or y are part of multi-dimensional distributions.; The bin widths along the relevant directions in these distributions; are used to calculate bin densities (number of events divided by bin width); or to calculate derivatives taking into account the proper distance of; adjacent bin centers. Complex binning schemes. in literature on unfolding, the ""standard"" test case is a; one-dimensional distribution without underflow or overflow bins.; The migration matrix is almost diagonal. This ""standard"" case is rarely realized for real problems. Often one has to deal with multi-dimensional input distributions.; In addition, there are underflow and overflow bins; or other backgrou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfoldDensity.html:830,avail,available,830,root/html602/TUnfoldDensity.html,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html,2,['avail'],['available']
Availability,". TUnfoldDensity. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldDensity. class TUnfoldDensity: public TUnfoldSys. TUnfoldDensity : public TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. More details are described with the documentation of TUnfold. For most applications, it is best to use TUnfoldDensity; instead of using TUnfoldSys or TUnfold. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. As compared to TUnfold, TUndolfDensity adds the following functionality; * background subtraction (see documentation of TUnfoldSys); * error propagation (see documentation of TUnfoldSys); * regularisation schemes respecting the bin widths; * support for complex, multidimensional input distributions. Complex binning schemes are imposed on the measurements y and; on the result vector x with the help of the class TUnfoldBinning; The components of x or y are part of multi-dimensional distributions.; The bin widths along the relevant directions in these distributions; are used to calculate bin densities (number of events divided by bin width); or to calculate derivatives taking into account the proper distance of; adjacent bin centers. Complex binning schemes. in literature on unfolding, the ""standard"" test case is a; one-dimensional distribution without underflow or overflow bins.; The migration matrix is almost diagonal. This ""standard"" case is rarely realized for real problems. Often one has to deal with multi-dimensional input distributions.; In addition, there are underflow and overflow bins; or other background bins, possibly determ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldDensity.html:806,avail,available,806,root/html534/TUnfoldDensity.html,https://root.cern,https://root.cern/root/html534/TUnfoldDensity.html,2,"['avail', 'error']","['available', 'error']"
Availability,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background erro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfoldSys.html:495,error,error,495,root/html602/TUnfoldSys.html,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html,10,"['avail', 'error']","['available', 'error', 'errors']"
Availability,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldSys.html:471,error,error,471,root/html534/TUnfoldSys.html,https://root.cern,https://root.cern/root/html534/TUnfoldSys.html,5,"['avail', 'error']","['available', 'error', 'errors']"
Availability,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. The following sources of systematic error are considered:; (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfoldSys.html:307,error,error,307,root/html528/TUnfoldSys.html,https://root.cern,https://root.cern/root/html528/TUnfoldSys.html,36,['error'],"['error', 'errors']"
Availability,". TUnuranBaseDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranBaseDist. class TUnuranBaseDist. TUnuranBaseDist, base class for Unuran distribution classees such as; TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TUnuranBaseDist(); static TClass*Class(); virtual TUnuranBaseDist*Clone() const; virtual TClass*IsA() const; TUnuranBaseDist&operator=(const TUnuranBaseDist&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TUnuranBaseDist(). Destructor (no operations). {}. TUnuranBaseDist * Clone() const. Abstract clone method for a deep copy of the derived classes. » Last changed: root/unuran:$Id: TUnuranBaseDist.h 21526 2007-12-20 10:42:41Z moneta $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnuranBaseDist.html:549,avail,available,549,root/html528/TUnuranBaseDist.html,https://root.cern,https://root.cern/root/html528/TUnuranBaseDist.html,1,['avail'],['available']
Availability,". TUnuranBaseDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranBaseDist. class TUnuranBaseDist. TUnuranBaseDist, base class for Unuran distribution classees such as; TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TUnuranBaseDist(); static TClass*Class(); virtual TUnuranBaseDist*Clone() const; virtual TClass*IsA() const; TUnuranBaseDist&operator=(const TUnuranBaseDist&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranBaseDist(); TUnuranBaseDist(const TUnuranBaseDist&). Class Charts. Inheritance Chart:. TUnuranBaseDist. ←. TUnuranContDist. TUnuranDiscrDist. TUnuranEmpDist. TUnuranMultiContDist. Function documentation; virtual ~TUnuranBaseDist(). Destructor (no operations). {}. TUnuranBaseDist * Clone() const. Abstract clone method for a deep copy of the derived classes. » Last changed: root/unuran:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnuranBaseDist.html:575,avail,available,575,root/html602/TUnuranBaseDist.html,https://root.cern,https://root.cern/root/html602/TUnuranBaseDist.html,1,['avail'],['available']
Availability,". TUnuranBaseDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranBaseDist. class TUnuranBaseDist. TUnuranBaseDist, base class for Unuran distribution classees such as; TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TUnuranBaseDist(); static TClass*Class(); virtual TUnuranBaseDist*Clone() const; virtual TClass*IsA() const; TUnuranBaseDist&operator=(const TUnuranBaseDist&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranBaseDist(); TUnuranBaseDist(const TUnuranBaseDist&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TUnuranBaseDist(). Destructor (no operations). {}. TUnuranBaseDist * Clone() const. Abstract clone method for a deep copy of the derived classes. » Last changed: root/unuran:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TUnuranBaseDist.html:551,avail,available,551,root/html604/TUnuranBaseDist.html,https://root.cern,https://root.cern/root/html604/TUnuranBaseDist.html,1,['avail'],['available']
Availability,". TUnuranBaseDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranBaseDist. class TUnuranBaseDist. TUnuranBaseDist, base class for Unuran distribution classees such as; TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TUnuranBaseDist(); static TClass*Class(); virtual TUnuranBaseDist*Clone() const; virtual TClass*IsA() const; TUnuranBaseDist&operator=(const TUnuranBaseDist&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TUnuranBaseDist(). Destructor (no operations). {}. TUnuranBaseDist * Clone() const. Abstract clone method for a deep copy of the derived classes. » Last changed: root/unuran:$Id: TUnuranBaseDist.h 21526 2007-12-20 10:42:41Z moneta $ » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TUnuranBaseDist.html:551,avail,available,551,root/html530/TUnuranBaseDist.html,https://root.cern,https://root.cern/root/html530/TUnuranBaseDist.html,1,['avail'],['available']
Availability,". TUnuranBaseDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranBaseDist. class TUnuranBaseDist. TUnuranBaseDist, base class for Unuran distribution classees such as; TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TUnuranBaseDist(); static TClass*Class(); virtual TUnuranBaseDist*Clone() const; virtual TClass*IsA() const; TUnuranBaseDist&operator=(const TUnuranBaseDist&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TUnuranBaseDist(). Destructor (no operations). {}. TUnuranBaseDist * Clone() const. Abstract clone method for a deep copy of the derived classes. » Last changed: root/unuran:$Id: TUnuranBaseDist.h 21526 2007-12-20 10:42:41Z moneta $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TUnuranBaseDist.html:551,avail,available,551,root/html532/TUnuranBaseDist.html,https://root.cern,https://root.cern/root/html532/TUnuranBaseDist.html,1,['avail'],['available']
Availability,". TUnuranBaseDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranBaseDist. class TUnuranBaseDist. TUnuranBaseDist, base class for Unuran distribution classees such as; TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TUnuranBaseDist(); static TClass*Class(); virtual TUnuranBaseDist*Clone() const; virtual TClass*IsA() const; TUnuranBaseDist&operator=(const TUnuranBaseDist&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TUnuranBaseDist(). Destructor (no operations). {}. TUnuranBaseDist * Clone() const. Abstract clone method for a deep copy of the derived classes. » Last changed: root/unuran:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnuranBaseDist.html:551,avail,available,551,root/html534/TUnuranBaseDist.html,https://root.cern,https://root.cern/root/html534/TUnuranBaseDist.html,1,['avail'],['available']
Availability,". TUploadDataSetDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TUploadDataSetDlg. class TUploadDataSetDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h); virtual~TUploadDataSetDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidAddFiles(const char* fileName); voidAddFiles(TList* fileList); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBrowseFiles(); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUploadDataSetDlg.html:414,avail,available,414,root/html528/TUploadDataSetDlg.html,https://root.cern,https://root.cern/root/html528/TUploadDataSetDlg.html,1,['avail'],['available']
Availability,". TUploadDataSetDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TUploadDataSetDlg. class TUploadDataSetDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h); virtual~TUploadDataSetDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidAddFiles(const char* fileName); voidAddFiles(TList* fileList); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBrowseFiles(); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TUploadDataSetDlg.html:416,avail,available,416,root/html530/TUploadDataSetDlg.html,https://root.cern,https://root.cern/root/html530/TUploadDataSetDlg.html,3,['avail'],['available']
Availability,". TUploadDataSetDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TUploadDataSetDlg. class TUploadDataSetDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. virtual~TUploadDataSetDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidAddFiles(const char* fileName); voidAddFiles(TList* fileList); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBrowseFiles(); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUploadDataSetDlg.html:464,avail,available,464,root/html602/TUploadDataSetDlg.html,https://root.cern,https://root.cern/root/html602/TUploadDataSetDlg.html,1,['avail'],['available']
Availability,". TUploadDataSetDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TUploadDataSetDlg. class TUploadDataSetDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. virtual~TUploadDataSetDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidAddFiles(const char* fileName); voidAddFiles(TList* fileList); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBrowseFiles(); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TUploadDataSetDlg.html:440,avail,available,440,root/html604/TUploadDataSetDlg.html,https://root.cern,https://root.cern/root/html604/TUploadDataSetDlg.html,1,['avail'],['available']
Availability,". TVectorT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<double>. class TVectorT<double>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<double>(); TVectorT<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>& action); TVectorT<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVectorT_double_.html:573,avail,available,573,root/html602/TVectorT_double_.html,https://root.cern,https://root.cern/root/html602/TVectorT_double_.html,2,['avail'],['available']
Availability,". TVectorT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<double>. class TVectorT<double>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. This class is also known as (typedefs to this class)TVectorD, TVectorT<Double_t>. Function Members (Methods); public:. TVectorT<double>(); TVectorT<double>(Int_t n); TVectorT<double>(const TVectorT<double>& another); TVectorT<double>(const TMatrixTRow_const<double>& mr); TVectorT<double>(const TMatrixTColumn_const<double>& mc); TVectorT<double>(const TMatrixTDiag_const<double>& md); TVectorT<double>(const TVectorT<float>& another); TVectorT<double>(Int_t lwb, Int_t upb); TVectorT<double>(Int_t n, const double* elements); TVectorT<double>(Int_t lwb, Int_t upb, const double* elements); virtual~TVectorT<double>(); TVectorT<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVectorT_double_.html:549,avail,available,549,root/html530/TVectorT_double_.html,https://root.cern,https://root.cern/root/html530/TVectorT_double_.html,2,['avail'],['available']
Availability,". TVectorT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<double>. class TVectorT<double>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. This class is also known as (typedefs to this class)TVectorT<Double_t>, TVectorD. Function Members (Methods); public:. TVectorT<double>(); TVectorT<double>(Int_t n); TVectorT<double>(const TVectorT<double>& another); TVectorT<double>(const TMatrixTRow_const<double>& mr); TVectorT<double>(const TMatrixTColumn_const<double>& mc); TVectorT<double>(const TMatrixTDiag_const<double>& md); TVectorT<double>(const TVectorT<float>& another); TVectorT<double>(Int_t lwb, Int_t upb); TVectorT<double>(Int_t n, const double* elements); TVectorT<double>(Int_t lwb, Int_t upb, const double* elements); virtual~TVectorT<double>(); TVectorT<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVectorT_double_.html:549,avail,available,549,root/html528/TVectorT_double_.html,https://root.cern,https://root.cern/root/html528/TVectorT_double_.html,2,['avail'],['available']
Availability,". TVectorT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<float>. class TVectorT<float>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<float>(); TVectorT<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVectorT_float_.html:570,avail,available,570,root/html602/TVectorT_float_.html,https://root.cern,https://root.cern/root/html602/TVectorT_float_.html,2,['avail'],['available']
Availability,". TVectorT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<float>. class TVectorT<float>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. This class is also known as (typedefs to this class)TVectorT<Float_t>, TVector, TVectorF. Function Members (Methods); public:. TVectorT<float>(); TVectorT<float>(Int_t n); TVectorT<float>(const TVectorT<float>& another); TVectorT<float>(const TMatrixTRow_const<float>& mr); TVectorT<float>(const TMatrixTColumn_const<float>& mc); TVectorT<float>(const TMatrixTDiag_const<float>& md); TVectorT<float>(const TVectorT<double>& another); TVectorT<float>(Int_t lwb, Int_t upb); TVectorT<float>(Int_t n, const float* elements); TVectorT<float>(Int_t lwb, Int_t upb, const float* elements); virtual~TVectorT<float>(); TVectorT<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVectorT_float_.html:546,avail,available,546,root/html534/TVectorT_float_.html,https://root.cern,https://root.cern/root/html534/TVectorT_float_.html,1,['avail'],['available']
Availability,". TVectorT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<float>. class TVectorT<float>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. This class is also known as (typedefs to this class)TVectorT<Float_t>, TVectorF, TVector. Function Members (Methods); public:. TVectorT<float>(); TVectorT<float>(Int_t n); TVectorT<float>(const TVectorT<float>& another); TVectorT<float>(const TMatrixTRow_const<float>& mr); TVectorT<float>(const TMatrixTColumn_const<float>& mc); TVectorT<float>(const TMatrixTDiag_const<float>& md); TVectorT<float>(const TVectorT<double>& another); TVectorT<float>(Int_t lwb, Int_t upb); TVectorT<float>(Int_t n, const float* elements); TVectorT<float>(Int_t lwb, Int_t upb, const float* elements); virtual~TVectorT<float>(); TVectorT<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVectorT_float_.html:546,avail,available,546,root/html528/TVectorT_float_.html,https://root.cern,https://root.cern/root/html528/TVectorT_float_.html,3,['avail'],['available']
Availability,". TView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TView. class TView: public TObject, public TAttLine. See TView3D; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TView(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdjustScales(TVirtualPad* pad = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); virtual voidTObject::Browse(TBrowser* b); virtual voidCentered(); virtual voidCentered3DImages(TVirtualPad* pad = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TView*CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TView.html:468,avail,available,468,root/html602/TView.html,https://root.cern,https://root.cern/root/html602/TView.html,2,['avail'],['available']
Availability,". TView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TView. class TView: public TObject, public TAttLine. See TView3D; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TView(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdjustScales(TVirtualPad* pad = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); virtual voidTObject::Browse(TBrowser* b); virtual voidCentered(); virtual voidCentered3DImages(TVirtualPad* pad = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TView*CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TView.html:444,avail,available,444,root/html528/TView.html,https://root.cern,https://root.cern/root/html528/TView.html,4,['avail'],['available']
Availability,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name(). » Author: G. Ganis 08/07/05 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Thu Sep 23 20:22:18 2010 » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualAuth.html:454,avail,available,454,root/html528/TVirtualAuth.html,https://root.cern,https://root.cern/root/html528/TVirtualAuth.html,1,['avail'],['available']
Availability,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualAuth(); TVirtualAuth(const TVirtualAuth&). Class Charts. Inheritance Chart:. TVirtualAuth. ←. TRootAuth. Function documentation; TVirtualAuth(); { }. virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name(). » Author: G. Ganis 08/07/05 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Tue Jun 30 15:32:34 2015 » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualAuth.html:480,avail,available,480,root/html602/TVirtualAuth.html,https://root.cern,https://root.cern/root/html602/TVirtualAuth.html,1,['avail'],['available']
Availability,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualAuth(); TVirtualAuth(const TVirtualAuth&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualAuth(); { }. virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name(). » Author: G. Ganis 08/07/05 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Tue Sep 8 17:49:45 2015 » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualAuth.html:456,avail,available,456,root/html604/TVirtualAuth.html,https://root.cern,https://root.cern/root/html604/TVirtualAuth.html,1,['avail'],['available']
Availability,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name(). » Author: G. Ganis 08/07/05 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Mon Jul 4 15:38:47 2011 » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualAuth.html:456,avail,available,456,root/html530/TVirtualAuth.html,https://root.cern,https://root.cern/root/html530/TVirtualAuth.html,1,['avail'],['available']
Availability,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name(). » Author: G. Ganis 08/07/05 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Thu Nov 3 20:24:07 2011 » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualAuth.html:456,avail,available,456,root/html532/TVirtualAuth.html,https://root.cern,https://root.cern/root/html532/TVirtualAuth.html,1,['avail'],['available']
Availability,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name(). » Author: G. Ganis 08/07/05 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Tue Sep 8 17:05:51 2015 » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualAuth.html:456,avail,available,456,root/html534/TVirtualAuth.html,https://root.cern,https://root.cern/root/html534/TVirtualAuth.html,1,['avail'],['available']
Availability,". TVirtualCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TVirtualCollectionProxy. class TVirtualCollectionProxy. TVirtualCollectionProxy. Virtual interface of a proxy object for a collection class; In particular this is used to implement splitting, emulation,; and TTreeFormula access to STL containers. This class is also known as (typedefs to this class)TCollectionProxyFactory::Proxy_t. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void*); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass(); virtual Int_tGetCollectionType(); virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement(); virtual Int_tGetProperties(); virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType(); virtual TClass*GetValueClass(); virtual TStreamerInfoActions::TActionSequence*Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualCollectionProxy.html:699,avail,available,699,root/html528/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html528/TVirtualCollectionProxy.html,1,['avail'],['available']
Availability,". TVirtualCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TVirtualCollectionProxy. class TVirtualCollectionProxy. TVirtualCollectionProxy. Virtual interface of a proxy object for a collection class; In particular this is used to implement splitting, emulation,; and TTreeFormula access to STL containers. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void*); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass() const; virtual Int_tGetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement() const; virtual Int_tGetProperties() const; virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType() const; virtual TClass*GetValueClass() const; virtual TStreamerInfoActions::TActionSequence*GetWriteMemberW",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualCollectionProxy.html:639,avail,available,639,root/html602/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TVirtualCollectionProxy.html,1,['avail'],['available']
Availability,". TVirtualCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TVirtualCollectionProxy. class TVirtualCollectionProxy. TVirtualCollectionProxy. Virtual interface of a proxy object for a collection class; In particular this is used to implement splitting, emulation,; and TTreeFormula access to STL containers. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void*); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass() const; virtual Int_tGetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement() const; virtual Int_tGetProperties() const; virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType() const; virtual TClass*GetValueClass() const; virtual TStreamerInfoActions::TActionSequence*GetWriteMemberWiseActions(); virtual Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualCollectionProxy.html:615,avail,available,615,root/html604/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html604/TVirtualCollectionProxy.html,1,['avail'],['available']
Availability,". TVirtualCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TVirtualCollectionProxy. class TVirtualCollectionProxy. TVirtualCollectionProxy. Virtual interface of a proxy object for a collection class; In particular this is used to implement splitting, emulation,; and TTreeFormula access to STL containers. This class is also known as (typedefs to this class)TCollectionProxyFactory::Proxy_t. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void*); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass() const; virtual Int_tGetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement() const; virtual Int_tGetProperties() const; virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType() const; virtual TClass*GetValueClass() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualCollectionProxy.html:701,avail,available,701,root/html534/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TVirtualCollectionProxy.html,1,['avail'],['available']
Availability,". TVirtualCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TVirtualCollectionProxy. class TVirtualCollectionProxy. TVirtualCollectionProxy. Virtual interface of a proxy object for a collection class; In particular this is used to implement splitting, emulation,; and TTreeFormula access to STL containers. This class is also known as (typedefs to this class)TCollectionProxyFactory::Proxy_t. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void*); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass(); virtual Int_tGetCollectionType(); virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement(); virtual Int_tGetProperties(); virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType(); virtual TClass*GetValueClass(); virtual TStreamerInfoActions::TActionSequence*G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualCollectionProxy.html:701,avail,available,701,root/html530/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html530/TVirtualCollectionProxy.html,2,['avail'],['available']
Availability,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualFFT.html:1145,redundant,redundant,1145,root/html602/TVirtualFFT.html,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html,2,['redundant'],['redundant']
Availability,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT11 in FFTW3 notation)- k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualFFT.html:1121,redundant,redundant,1121,root/html530/TVirtualFFT.html,https://root.cern,https://root.cern/root/html530/TVirtualFFT.html,3,['redundant'],['redundant']
Availability,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT10 in FFTW3 notation)- kind=1; DCT-III(REDFT01 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT10 in FFTW3 notation)- kind=5; DST-III(RODFT01 in FFTW3 notation)- kind=6; DST-IV (RODFT11 in FFTW3 notation)- k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualFFT.html:1121,redundant,redundant,1121,root/html528/TVirtualFFT.html,https://root.cern,https://root.cern/root/html528/TVirtualFFT.html,1,['redundant'],['redundant']
Availability,". TVirtualFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TVirtualFitter. class TVirtualFitter: public TNamed. Abstract Base Class for Fitting. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualFitter.html:493,avail,available,493,root/html604/TVirtualFitter.html,https://root.cern,https://root.cern/root/html604/TVirtualFitter.html,1,['avail'],['available']
Availability,". TVirtualFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TVirtualFitter. class TVirtualFitter: public TNamed. Abstract Base Class for Fitting. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualFitter.html:497,avail,available,497,root/html602/TVirtualFitter.html,https://root.cern,https://root.cern/root/html602/TVirtualFitter.html,1,['avail'],['available']
Availability,". TVirtualFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TVirtualFitter. class TVirtualFitter: public TNamed. Abstract Base Class for Fitting. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualFitter.html:473,avail,available,473,root/html528/TVirtualFitter.html,https://root.cern,https://root.cern/root/html528/TVirtualFitter.html,4,['avail'],['available']
Availability,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualGLManip(); TVirtualGLManip(const TVirtualGLManip&). Class Charts. Inheritance Chart:. TVirtualGLManip. ←. TGLManip; ←. TGLRotateManip. TGLScaleManip. TGLTransManip. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualGLManip.html:520,avail,available,520,root/html604/TVirtualGLManip.html,https://root.cern,https://root.cern/root/html604/TVirtualGLManip.html,2,['avail'],['available']
Availability,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualGLManip(); TVirtualGLManip(const TVirtualGLManip&). Class Charts. Inheritance Chart:. TVirtualGLManip. ←. TGLManip; ←. TGLRotateManip. TGLScaleManip. TGLTransManip. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualGLManip.html:520,avail,available,520,root/html602/TVirtualGLManip.html,https://root.cern,https://root.cern/root/html602/TVirtualGLManip.html,2,['avail'],['available']
Availability,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualGLManip.html:496,avail,available,496,root/html528/TVirtualGLManip.html,https://root.cern,https://root.cern/root/html528/TVirtualGLManip.html,2,['avail'],['available']
Availability,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualGLManip.html:496,avail,available,496,root/html530/TVirtualGLManip.html,https://root.cern,https://root.cern/root/html530/TVirtualGLManip.html,2,['avail'],['available']
Availability,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualGLManip.html:496,avail,available,496,root/html532/TVirtualGLManip.html,https://root.cern,https://root.cern/root/html532/TVirtualGLManip.html,2,['avail'],['available']
Availability,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualGLManip.html:496,avail,available,496,root/html534/TVirtualGLManip.html,https://root.cern,https://root.cern/root/html534/TVirtualGLManip.html,2,['avail'],['available']
Availability,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualGLPainter(); TVirtualGLPainter(const TVirtualGLPainter&). Class Charts. Inheritance Chart:. TVirtualGLPainter. ←. TGLPlotPainter; ←. TGLBoxPainter. TGLH2PolyPainter. TGLIsoPainter. TGLLegoPainter. TGLParametricPlot. TGLSurfacePainter. TGLTF3Painter. TGLTH3CompositionPainter. TGLVoxelPainter.  [more...]. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualGLPainter.html:526,avail,available,526,root/html602/TVirtualGLPainter.html,https://root.cern,https://root.cern/root/html602/TVirtualGLPainter.html,4,['avail'],['available']
Availability,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualGLPainter.html:502,avail,available,502,root/html528/TVirtualGLPainter.html,https://root.cern,https://root.cern/root/html528/TVirtualGLPainter.html,2,['avail'],['available']
Availability,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualGLPainter.html:502,avail,available,502,root/html530/TVirtualGLPainter.html,https://root.cern,https://root.cern/root/html530/TVirtualGLPainter.html,2,['avail'],['available']
Availability,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualGLPainter.html:502,avail,available,502,root/html532/TVirtualGLPainter.html,https://root.cern,https://root.cern/root/html532/TVirtualGLPainter.html,2,['avail'],['available']
Availability,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualGLPainter.html:502,avail,available,502,root/html534/TVirtualGLPainter.html,https://root.cern,https://root.cern/root/html534/TVirtualGLPainter.html,2,['avail'],['available']
Availability,". TVirtualGeoPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TVirtualGeoPainter. class TVirtualGeoPainter: public TObject. TVirtualGeoPainter. ABC for geometry painters. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGeoPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys); virtual TVirtualGeoTrack*AddTrack(Int_t id, Int_t pdgcode, TObject* particle); virtual voidAddTrackPoint(Double_t* point, Double_t* box, Bool_t reset = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidTObject::Browse(TBrowser* b); virtual voidCheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); virtual voidCheckBoundaryReference(Int_t icheck = -1); virtual voidCheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; virtual voidCheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = __null); virtual voidCheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.10000000000000001, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); virtual voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualGeoPainter.html:520,avail,available,520,root/html602/TVirtualGeoPainter.html,https://root.cern,https://root.cern/root/html602/TVirtualGeoPainter.html,2,['avail'],['available']
Availability,". TVirtualGeoPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TVirtualGeoPainter. class TVirtualGeoPainter: public TObject. TVirtualGeoPainter. ABC for geometry painters. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGeoPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys); virtual TVirtualGeoTrack*AddTrack(Int_t id, Int_t pdgcode, TObject* particle); virtual voidAddTrackPoint(Double_t* point, Double_t* box, Bool_t reset = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidTObject::Browse(TBrowser* b); virtual voidCheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); virtual voidCheckBoundaryReference(Int_t icheck = -1); virtual voidCheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; virtual voidCheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = NULL); virtual voidCheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual Int_tCountVisibleNodes(); virtual voidDefaultAngles(); virtual voidDefaultColors(); virtual voidTObject::Delete(Option_t* opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualGeoPainter.html:496,avail,available,496,root/html528/TVirtualGeoPainter.html,https://root.cern,https://root.cern/root/html528/TVirtualGeoPainter.html,1,['avail'],['available']
Availability,". TVirtualGeoPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TVirtualGeoPainter. class TVirtualGeoPainter: public TObject. TVirtualGeoPainter. ABC for geometry painters. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGeoPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys); virtual TVirtualGeoTrack*AddTrack(Int_t id, Int_t pdgcode, TObject* particle); virtual voidAddTrackPoint(Double_t* point, Double_t* box, Bool_t reset = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidTObject::Browse(TBrowser* b); virtual voidCheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); virtual voidCheckBoundaryReference(Int_t icheck = -1); virtual voidCheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; virtual voidCheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = NULL); virtual voidCheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); virtual voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual Int_tCountVisibleNodes(); virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualGeoPainter.html:496,avail,available,496,root/html530/TVirtualGeoPainter.html,https://root.cern,https://root.cern/root/html530/TVirtualGeoPainter.html,3,['avail'],['available']
Availability,". TVirtualGeoTrack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TVirtualGeoTrack. class TVirtualGeoTrack: public TObject, public TGeoAtt, public TAttLine, public TAttMarker. TVirtualGeoTrack - Base class for user-defined tracks attached to a geometry.; Tracks are 3D objects made of points and they store a; pointer to a TParticle. The geometry manager holds a list; of all tracks that will be deleted on destruction of; gGeoManager. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGeoTrack(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddDaughter(TVirtualGeoTrack* other); virtual TVirtualGeoTrack*AddDaughter(Int_t id, Int_t pdgcode, TObject* particle = 0); virtual voidAddPoint(Double_t x, Double_t y, Double_t z, Double_t t); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualGeoTrack.html:779,avail,available,779,root/html602/TVirtualGeoTrack.html,https://root.cern,https://root.cern/root/html602/TVirtualGeoTrack.html,2,['avail'],['available']
Availability,". TVirtualGeoTrack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TVirtualGeoTrack. class TVirtualGeoTrack: public TObject, public TGeoAtt, public TAttLine, public TAttMarker. TVirtualGeoTrack - Base class for user-defined tracks attached to a geometry.; Tracks are 3D objects made of points and they store a; pointer to a TParticle. The geometry manager holds a list; of all tracks that will be deleted on destruction of; gGeoManager. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGeoTrack(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddDaughter(TVirtualGeoTrack* other); virtual TVirtualGeoTrack*AddDaughter(Int_t id, Int_t pdgcode, TObject* particle = 0); virtual voidAddPoint(Double_t x, Double_t y, Double_t z, Double_t t); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualGeoTrack.html:755,avail,available,755,root/html528/TVirtualGeoTrack.html,https://root.cern,https://root.cern/root/html528/TVirtualGeoTrack.html,4,['avail'],['available']
Availability,". TVirtualGraphPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TVirtualGraphPainter. class TVirtualGraphPainter: public TObject. TVirtualGraphPainter is an abstract interface to a histogram painter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGraphPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanelHelper(TGraph* theGraph); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::Fin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualGraphPainter.html:549,avail,available,549,root/html602/TVirtualGraphPainter.html,https://root.cern,https://root.cern/root/html602/TVirtualGraphPainter.html,2,['avail'],['available']
Availability,". TVirtualGraphPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TVirtualGraphPainter. class TVirtualGraphPainter: public TObject. TVirtualGraphPainter is an abstract interface to a histogram painter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGraphPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanelHelper(TGraph* theGraph); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualGraphPainter.html:525,avail,available,525,root/html528/TVirtualGraphPainter.html,https://root.cern,https://root.cern/root/html528/TVirtualGraphPainter.html,4,['avail'],['available']
Availability,". TVirtualHistPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TVirtualHistPainter. class TVirtualHistPainter: public TObject. TVirtualHistPainter is an abstract interface to a histogram painter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualHistPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualHistPainter.html:545,avail,available,545,root/html602/TVirtualHistPainter.html,https://root.cern,https://root.cern/root/html602/TVirtualHistPainter.html,2,['avail'],['available']
Availability,". TVirtualHistPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TVirtualHistPainter. class TVirtualHistPainter: public TObject. TVirtualHistPainter is an abstract interface to a histogram painter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualHistPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualHistPainter.html:521,avail,available,521,root/html528/TVirtualHistPainter.html,https://root.cern,https://root.cern/root/html528/TVirtualHistPainter.html,4,['avail'],['available']
Availability,". TVirtualIndex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TVirtualIndex. class TVirtualIndex: public TNamed. Abstract interface for Tree Index. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualIndex.html:492,avail,available,492,root/html602/TVirtualIndex.html,https://root.cern,https://root.cern/root/html602/TVirtualIndex.html,2,['avail'],['available']
Availability,". TVirtualIndex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TVirtualIndex. class TVirtualIndex: public TNamed. Abstract interface for Tree Index. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualIndex.html:468,avail,available,468,root/html528/TVirtualIndex.html,https://root.cern,https://root.cern/root/html528/TVirtualIndex.html,4,['avail'],['available']
Availability,". TVirtualIsAProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualIsAProxy. class TVirtualIsAProxy. TClass. Virtual IsAProxy base class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIsAProxy(); virtual TClass*operator()(const void* obj); TVirtualIsAProxy&operator=(const TVirtualIsAProxy&); virtual voidSetClass(TClass* cl). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualIsAProxy(); { }. void SetClass(TClass* cl). TClass* operator()(const void* obj). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TVirtualIsAProxy.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualIsAProxy.html:438,avail,available,438,root/html528/TVirtualIsAProxy.html,https://root.cern,https://root.cern/root/html528/TVirtualIsAProxy.html,1,['avail'],['available']
Availability,". TVirtualIsAProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualIsAProxy. class TVirtualIsAProxy. TClass. Virtual IsAProxy base class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIsAProxy(); virtual TClass*operator()(const void* obj); TVirtualIsAProxy&operator=(const TVirtualIsAProxy&); virtual voidSetClass(TClass* cl); TVirtualIsAProxy(); TVirtualIsAProxy(const TVirtualIsAProxy&). Class Charts. Inheritance Chart:. TVirtualIsAProxy. ←. TIsAProxy. Function documentation; virtual ~TVirtualIsAProxy(); { }. void SetClass(TClass* cl). TClass* operator()(const void* obj). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualIsAProxy.html:464,avail,available,464,root/html602/TVirtualIsAProxy.html,https://root.cern,https://root.cern/root/html602/TVirtualIsAProxy.html,1,['avail'],['available']
Availability,". TVirtualIsAProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualIsAProxy. class TVirtualIsAProxy. TClass. Virtual IsAProxy base class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIsAProxy(); virtual TClass*operator()(const void* obj); TVirtualIsAProxy&operator=(const TVirtualIsAProxy&); virtual voidSetClass(TClass* cl). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualIsAProxy(); { }. void SetClass(TClass* cl). TClass* operator()(const void* obj). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualIsAProxy.html:440,avail,available,440,root/html534/TVirtualIsAProxy.html,https://root.cern,https://root.cern/root/html534/TVirtualIsAProxy.html,1,['avail'],['available']
Availability,". TVirtualIsAProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualIsAProxy. class TVirtualIsAProxy. TClass. Virtual IsAProxy base class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIsAProxy(); virtual TClass*operator()(const void* obj); TVirtualIsAProxy&operator=(const TVirtualIsAProxy&); virtual voidSetClass(TClass* cl). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualIsAProxy(); { }. void SetClass(TClass* cl). TClass* operator()(const void* obj). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TVirtualIsAProxy.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualIsAProxy.html:440,avail,available,440,root/html530/TVirtualIsAProxy.html,https://root.cern,https://root.cern/root/html530/TVirtualIsAProxy.html,1,['avail'],['available']
Availability,". TVirtualIsAProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualIsAProxy. class TVirtualIsAProxy. TClass. Virtual IsAProxy base class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIsAProxy(); virtual TClass*operator()(const void* obj); TVirtualIsAProxy&operator=(const TVirtualIsAProxy&); virtual voidSetClass(TClass* cl). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualIsAProxy(); { }. void SetClass(TClass* cl). TClass* operator()(const void* obj). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TVirtualIsAProxy.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualIsAProxy.html:440,avail,available,440,root/html532/TVirtualIsAProxy.html,https://root.cern,https://root.cern/root/html532/TVirtualIsAProxy.html,1,['avail'],['available']
Availability,". TVirtualIsAProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualIsAProxy. class TVirtualIsAProxy. TClass. Virtual IsAProxy base class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIsAProxy(); virtual TClass*operator()(const void* obj); TVirtualIsAProxy&operator=(const TVirtualIsAProxy&); virtual voidSetClass(TClass* cl); TVirtualIsAProxy(); TVirtualIsAProxy(const TVirtualIsAProxy&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualIsAProxy(); { }. void SetClass(TClass* cl). TClass* operator()(const void* obj). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualIsAProxy.html:440,avail,available,440,root/html604/TVirtualIsAProxy.html,https://root.cern,https://root.cern/root/html604/TVirtualIsAProxy.html,1,['avail'],['available']
Availability,". TVirtualMC. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMC. class TVirtualMC: public TNamed. Virtual MC provides a virtual interface to Monte Carlo.; It enables the user to build a virtual Monte Carlo application; independent of any actual underlying Monte Carlo implementation itself. A user will have to implement a class derived from the abstract; Monte Carlo application class, and provide functions like; ConstructGeometry(), BeginEvent(), FinishEvent(), ... .; The concrete Monte Carlo (Geant3, Geant4) is selected at run time -; when processing a ROOT macro where the concrete Monte Carlo is instantiated. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMC(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildPhysics(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; virtual Int_tCurrentEvent() const; virtual Int_tCurrentMaterial(Float_t& a, Float_t& z, Float_t& dens, Float_t& radl, Float_t& absl) const; virtual Int_tCurrentMedium() const; virtual Int_tCurrentVolID(Int_t& copyNo) const; virtual const char*CurrentVolName() const; virtual Int_tCurrentVolOffID(Int_t off, Int_t& copyNo) const; virtual const char*CurrentVolOffName(Int_t off) const; virtual const char*CurrentVolPath(); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMC.html:973,avail,available,973,root/html602/TVirtualMC.html,https://root.cern,https://root.cern/root/html602/TVirtualMC.html,2,['avail'],['available']
Availability,". TVirtualMC. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMC. class TVirtualMC: public TNamed. Virtual MC provides a virtual interface to Monte Carlo.; It enables the user to build a virtual Monte Carlo application; independent of any actual underlying Monte Carlo implementation itself. A user will have to implement a class derived from the abstract; Monte Carlo application class, and provide functions like; ConstructGeometry(), BeginEvent(), FinishEvent(), ... .; The concrete Monte Carlo (Geant3, Geant4) is selected at run time -; when processing a ROOT macro where the concrete Monte Carlo is instantiated. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMC(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildPhysics(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; virtual Int_tCurrentEvent() const; virtual Int_tCurrentMaterial(Float_t& a, Float_t& z, Float_t& dens, Float_t& radl, Float_t& absl) const; virtual Int_tCurrentMedium() const; virtual Int_tCurrentVolID(Int_t& copyNo) const; virtual const char*CurrentVolName() const; virtual Int_tCurrentVolOffID(Int_t off, Int_t& copyNo) const; virtual const char*CurrentVolOffName(Int_t off) const; virtual const char*CurrentVolPath(); virtual Bool_tDefineIon(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualMC.html:949,avail,available,949,root/html530/TVirtualMC.html,https://root.cern,https://root.cern/root/html530/TVirtualMC.html,3,['avail'],['available']
Availability,". TVirtualMC. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMC. class TVirtualMC: public TNamed. Virtual MC provides a virtual interface to Monte Carlo.; It enables the user to build a virtual Monte Carlo application; independent of any actual underlying Monte Carlo implementation itself. A user will have to implement a class derived from the abstract; Monte Carlo application class, and provide functions like; ConstructGeometry(), BeginEvent(), FinishEvent(), ... .; The concrete Monte Carlo (Geant3, Geant4) is selected at run time -; when processing a ROOT macro where the concrete Monte Carlo is instantiated. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMC(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildPhysics(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; virtual Int_tCurrentEvent() const; virtual Int_tCurrentMaterial(Float_t& a, Float_t& z, Float_t& dens, Float_t& radl, Float_t& absl) const; virtual Int_tCurrentMedium() const; virtual Int_tCurrentVolID(Int_t& copyNo) const; virtual const char*CurrentVolName() const; virtual Int_tCurrentVolOffID(Int_t off, Int_t& copyNo) const; virtual const char*CurrentVolOffName(Int_t off) const; virtual const char*CurrentVolPath(); virtual voidDefaultRange()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMC.html:949,avail,available,949,root/html528/TVirtualMC.html,https://root.cern,https://root.cern/root/html528/TVirtualMC.html,1,['avail'],['available']
Availability,". TVirtualMCApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMCApplication. class TVirtualMCApplication: public TNamed. Interface to a user Monte Carlo application. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCApplication(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIons(); virtual voidAddParticles(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginEvent(); virtual voidBeginPrimary(); virtual voidBeginWorkerRun() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TVirtualMCApplication*CloneForWorker() const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConstructGeometry(); virtual voidConstructOpGeometry(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMCApplication.html:531,avail,available,531,root/html602/TVirtualMCApplication.html,https://root.cern,https://root.cern/root/html602/TVirtualMCApplication.html,2,['avail'],['available']
Availability,". TVirtualMCApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMCApplication. class TVirtualMCApplication: public TNamed. Interface to a user Monte Carlo application. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCApplication(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIons(); virtual voidAddParticles(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginEvent(); virtual voidBeginPrimary(); virtual voidBeginWorkerRun() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TVirtualMCApplication*CloneForWorker() const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConstructGeometry(); virtual voidConstructOpGeometry(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualMCApplication.html:507,avail,available,507,root/html534/TVirtualMCApplication.html,https://root.cern,https://root.cern/root/html534/TVirtualMCApplication.html,1,['avail'],['available']
Availability,". TVirtualMCApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMCApplication. class TVirtualMCApplication: public TNamed. Interface to a user Monte Carlo application. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCApplication(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIons(); virtual voidAddParticles(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginEvent(); virtual voidBeginPrimary(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConstructGeometry(); virtual voidConstructOpGeometry(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidField(const Double_t* x, Double_t* b) const; virtual voidTNamed::FillBuffer(char*& buffer)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMCApplication.html:507,avail,available,507,root/html528/TVirtualMCApplication.html,https://root.cern,https://root.cern/root/html528/TVirtualMCApplication.html,3,['avail'],['available']
Availability,". TVirtualMCDecayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » EG; » TVirtualMCDecayer. class TVirtualMCDecayer: public TObject. Abstract base class for particle decays.; Clients are the transport code and the primary particle generators; This is an abstract base class !. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCDecayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecay(Int_t idpart, TLorentzVector* p); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMCDecayer.html:618,avail,available,618,root/html602/TVirtualMCDecayer.html,https://root.cern,https://root.cern/root/html602/TVirtualMCDecayer.html,2,['avail'],['available']
Availability,". TVirtualMCDecayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » EG; » TVirtualMCDecayer. class TVirtualMCDecayer: public TObject. Abstract base class for particle decays.; Clients are the transport code and the primary particle generators; This is an abstract base class !. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCDecayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecay(Int_t idpart, TLorentzVector* p); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMCDecayer.html:594,avail,available,594,root/html528/TVirtualMCDecayer.html,https://root.cern,https://root.cern/root/html528/TVirtualMCDecayer.html,4,['avail'],['available']
Availability,". TVirtualMCGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMCGeometry. class TVirtualMCGeometry: public TNamed. Virtual MCGeometry provides a virtual interface to Monte Carlo; geometry construction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCGeometry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMCGeometry.html:564,avail,available,564,root/html602/TVirtualMCGeometry.html,https://root.cern,https://root.cern/root/html602/TVirtualMCGeometry.html,2,['avail'],['available']
Availability,". TVirtualMCGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMCGeometry. class TVirtualMCGeometry: public TNamed. Virtual MCGeometry provides a virtual interface to Monte Carlo; geometry construction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCGeometry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMCGeometry.html:540,avail,available,540,root/html528/TVirtualMCGeometry.html,https://root.cern,https://root.cern/root/html528/TVirtualMCGeometry.html,4,['avail'],['available']
Availability,". TVirtualMCStack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMCStack. class TVirtualMCStack: public TObject. Interface to a user defined particles stack. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCStack(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetCurrentParentTrackNumber() const; virtual TParticle*GetCurrentTrack() const; virtual Int_tGetCurrentTrackNumber() const; virtual Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMCStack.html:514,avail,available,514,root/html602/TVirtualMCStack.html,https://root.cern,https://root.cern/root/html602/TVirtualMCStack.html,2,['avail'],['available']
Availability,". TVirtualMCStack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMCStack. class TVirtualMCStack: public TObject. Interface to a user defined particles stack. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCStack(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetCurrentParentTrackNumber() const; virtual TParticle*GetCurrentTrack() const; virtual Int_tGetCurrentTrackNumber() const; virtual Option_t*TObject::GetDrawOption",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMCStack.html:490,avail,available,490,root/html528/TVirtualMCStack.html,https://root.cern,https://root.cern/root/html528/TVirtualMCStack.html,4,['avail'],['available']
Availability,". TVirtualMutex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualMutex. class TVirtualMutex: public TObject. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMutex(); voidTObject::AbstractMethod(const char* method) const; Int_tAcquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMutex.html:425,avail,available,425,root/html602/TVirtualMutex.html,https://root.cern,https://root.cern/root/html602/TVirtualMutex.html,4,['avail'],['available']
Availability,". TVirtualMutex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualMutex. class TVirtualMutex: public TObject. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMutex(); voidTObject::AbstractMethod(const char* method) const; Int_tAcquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMutex.html:401,avail,available,401,root/html528/TVirtualMutex.html,https://root.cern,https://root.cern/root/html528/TVirtualMutex.html,8,['avail'],['available']
Availability,". TVirtualPS. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPS. class TVirtualPS: public TNamed, public TAttLine, public TAttFill, public TAttMarker, public TAttText. TVirtualPS is an abstract interface to a Postscript, PDF and SVG drivers. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPS(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualPS.html:592,avail,available,592,root/html602/TVirtualPS.html,https://root.cern,https://root.cern/root/html602/TVirtualPS.html,2,['avail'],['available']
Availability,". TVirtualPS. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPS. class TVirtualPS: public TNamed, public TAttLine, public TAttFill, public TAttMarker, public TAttText. TVirtualPS is an abstract interface to a Postscript, PDF and SVG drivers. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPS(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualPS.html:568,avail,available,568,root/html528/TVirtualPS.html,https://root.cern,https://root.cern/root/html528/TVirtualPS.html,4,['avail'],['available']
Availability,". TVirtualPad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPad. class TVirtualPad: public TObject, public TAttLine, public TAttFill, public TAttPad, public TQObject. TVirtualPad is an abstract base class for the Pad and Canvas classes. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPad(); virtual voidAbsCoordinates(Bool_t set); virtual Double_tAbsPixeltoX(Int_t px); virtual Double_tAbsPixeltoY(Int_t py); voidTObject::AbstractMethod(const char* method) const; virtual voidAddExec(const char* name, const char* command); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual TLegend*BuildLegend(Double_t x1 = 0.5, Double_t y1 = 0.67000000000000004, Double_t x2 = 0.88, Double_t y2 = 0.88, const char* title = """"); virtual TVirtualPad*cd(Int_t subpadnumber = 0); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual voidCloseToolTip(TObject* tip); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualPad.html:589,avail,available,589,root/html602/TVirtualPad.html,https://root.cern,https://root.cern/root/html602/TVirtualPad.html,2,['avail'],['available']
Availability,". TVirtualPad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPad. class TVirtualPad: public TObject, public TAttLine, public TAttFill, public TAttPad, public TQObject. TVirtualPad is an abstract base class for the Pad and Canvas classes. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPad(); virtual voidAbsCoordinates(Bool_t set); virtual Double_tAbsPixeltoX(Int_t px); virtual Double_tAbsPixeltoY(Int_t py); voidTObject::AbstractMethod(const char* method) const; virtual voidAddExec(const char* name, const char* command); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual TLegend*BuildLegend(Double_t x1 = 0.5, Double_t y1 = 0.67, Double_t x2 = 0.88, Double_t y2 = 0.88, const char* title = """"); virtual TVirtualPad*cd(Int_t subpadnumber = 0); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual voidCloseToolTip(TObject* tip); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualPad.html:565,avail,available,565,root/html534/TVirtualPad.html,https://root.cern,https://root.cern/root/html534/TVirtualPad.html,1,['avail'],['available']
Availability,". TVirtualPad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPad. class TVirtualPad: public TObject, public TAttLine, public TAttFill, public TAttPad, public TQObject. TVirtualPad is an abstract base class for the Pad and Canvas classes. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPad(); virtual voidAbsCoordinates(Bool_t set); virtual Double_tAbsPixeltoX(Int_t px); virtual Double_tAbsPixeltoY(Int_t py); voidTObject::AbstractMethod(const char* method) const; virtual voidAddExec(const char* name, const char* command); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual TVirtualPad*cd(Int_t subpadnumber = 0); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual voidCloseToolTip(TObject* tip); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualPad.html:565,avail,available,565,root/html528/TVirtualPad.html,https://root.cern,https://root.cern/root/html528/TVirtualPad.html,3,['avail'],['available']
Availability,". TVirtualPadEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPadEditor. class TVirtualPadEditor. TVirtualPadEditor. Abstract base class used by ROOT graphics editor. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPadEditor(); virtual voidBuild(); static TClass*Class(); virtual voidDeleteEditors(); virtual voidDrawLine(Double_t, Double_t, Double_t, Double_t); virtual voidDrawLineNDC(Double_t, Double_t, Double_t, Double_t); virtual voidDrawText(Double_t, Double_t, const char*); virtual voidDrawTextNDC(Double_t, Double_t, const char*); virtual voidFillAttributes(Int_t, Int_t); virtual TCanvas*GetCanvas() const; static const char*GetEditorName(); static TVirtualPadEditor*GetPadEditor(Bool_t load = kTRUE); virtual voidHide(); static voidHideEditor(); virtual TClass*IsA() const; virtual Bool_tIsGlobal() const; virtual voidLineAttributes(Int_t, Int_t, Int_t); static TVirtualPadEditor*LoadEditor(); virtual voidMarkerAttributes(Int_t, Int_t, Float_t); TVirtualPadEditor&operator=(const TVirtualPadEditor&); virtual voidSetGlobal(Bool_t); static voidSetPadEditorName(const char* name); virtual voidShow(); static voidShowEditor(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); static voidTerminate(); virtual voidTextAttributes(Int_t, Float_t, Int_t, Int_t, Float_t); TVirtualPadEditor(); TVirtualPadEditor(const TVirtualPadEditor&); static voidUpdateFillAttributes(Int_t col, Int_t sty); static voidUpdateLineAttributes(Int_t col, Int_t sty, Int_t width); static voidUpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); static v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualPadEditor.html:523,avail,available,523,root/html602/TVirtualPadEditor.html,https://root.cern,https://root.cern/root/html602/TVirtualPadEditor.html,2,['avail'],['available']
Availability,". TVirtualPadEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPadEditor. class TVirtualPadEditor. TVirtualPadEditor. Abstract base class used by ROOT graphics editor. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPadEditor(); virtual voidBuild(); static TClass*Class(); virtual voidDeleteEditors(); virtual voidDrawLine(Double_t, Double_t, Double_t, Double_t); virtual voidDrawLineNDC(Double_t, Double_t, Double_t, Double_t); virtual voidDrawText(Double_t, Double_t, const char*); virtual voidDrawTextNDC(Double_t, Double_t, const char*); virtual voidFillAttributes(Int_t, Int_t); virtual TCanvas*GetCanvas() const; static const char*GetEditorName(); static TVirtualPadEditor*GetPadEditor(Bool_t load = kTRUE); virtual voidHide(); static voidHideEditor(); virtual TClass*IsA() const; virtual Bool_tIsGlobal() const; virtual voidLineAttributes(Int_t, Int_t, Int_t); static TVirtualPadEditor*LoadEditor(); virtual voidMarkerAttributes(Int_t, Int_t, Float_t); TVirtualPadEditor&operator=(const TVirtualPadEditor&); virtual voidSetGlobal(Bool_t); static voidSetPadEditorName(const char* name); virtual voidShow(); static voidShowEditor(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); static voidTerminate(); virtual voidTextAttributes(Int_t, Float_t, Int_t, Int_t, Float_t); static voidUpdateFillAttributes(Int_t col, Int_t sty); static voidUpdateLineAttributes(Int_t col, Int_t sty, Int_t width); static voidUpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); static voidUpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize). Data Members; protected:. sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualPadEditor.html:499,avail,available,499,root/html528/TVirtualPadEditor.html,https://root.cern,https://root.cern/root/html528/TVirtualPadEditor.html,3,['avail'],['available']
Availability,". TVirtualPadEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPadEditor. class TVirtualPadEditor. TVirtualPadEditor. Abstract base class used by ROOT graphics editor. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPadEditor(); virtual voidBuild(); static TClass*Class(); virtual voidDeleteEditors(); virtual voidDrawLine(Double_t, Double_t, Double_t, Double_t); virtual voidDrawLineNDC(Double_t, Double_t, Double_t, Double_t); virtual voidDrawText(Double_t, Double_t, const char*); virtual voidDrawTextNDC(Double_t, Double_t, const char*); virtual voidFillAttributes(Int_t, Int_t); virtual TCanvas*GetCanvas() const; static const char*GetEditorName(); static TVirtualPadEditor*GetPadEditor(Bool_t load = kTRUE); virtual voidHide(); static voidHideEditor(); virtual TClass*IsA() const; virtual Bool_tIsGlobal() const; virtual voidLineAttributes(Int_t, Int_t, Int_t); static TVirtualPadEditor*LoadEditor(); virtual voidMarkerAttributes(Int_t, Int_t, Float_t); TVirtualPadEditor&operator=(const TVirtualPadEditor&); virtual voidSetGlobal(Bool_t); static voidSetPadEditorName(const char* name); virtual voidShow(); static voidShowEditor(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); static voidTerminate(); virtual voidTextAttributes(Int_t, Float_t, Int_t, Int_t, Float_t); static voidUpdateFillAttributes(Int_t col, Int_t sty); static voidUpdateLineAttributes(Int_t col, Int_t sty, Int_t width); static voidUpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); static voidUpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize). Data Membe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualPadEditor.html:499,avail,available,499,root/html534/TVirtualPadEditor.html,https://root.cern,https://root.cern/root/html534/TVirtualPadEditor.html,1,['avail'],['available']
Availability,". TVirtualPadPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPadPainter. class TVirtualPadPainter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPadPainter(); static TClass*Class(); virtual voidClearDrawable(); virtual voidCopyDrawable(Int_t device, Int_t px, Int_t py); virtual Int_tCreateDrawable(UInt_t w, UInt_t h); virtual voidDestroyDrawable(); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); virtual voidDrawFillArea(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawFillArea(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidDrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); virtual voidDrawPixels(const unsigned char* pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t enableAlphaBlending); virtual voidDrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); virtual voidDrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); virtual voidDrawText(Double_t x, Double_t y, const wchar_t* text, TVirtualPadPainter::ETextMode mode); virtual voidDrawTextNDC(Double_t u, Double_t v, const char* text, TVirtualPadPainter::ETextMode mode); virtual voidDrawTextNDC(Double_t u, Double_t v, const wchar_t* text, TVirt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualPadPainter.html:457,avail,available,457,root/html602/TVirtualPadPainter.html,https://root.cern,https://root.cern/root/html602/TVirtualPadPainter.html,2,['avail'],['available']
Availability,". TVirtualPadPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPadPainter. class TVirtualPadPainter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPadPainter(); static TClass*Class(); virtual voidClearDrawable(); virtual voidCopyDrawable(Int_t device, Int_t px, Int_t py); virtual Int_tCreateDrawable(UInt_t w, UInt_t h); virtual voidDestroyDrawable(); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); virtual voidDrawFillArea(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawFillArea(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidDrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); virtual voidDrawPixels(const unsigned char* pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t alphaBlending); virtual voidDrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); virtual voidDrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); virtual voidDrawText(Double_t x, Double_t y, const wchar_t* text, TVirtualPadPainter::ETextMode mode); virtual voidDrawTextNDC(Double_t u, Double_t v, const char* text, TVirtualPadPainter::ETextMode mode); virtual voidDrawTextNDC(Double_t u, Double_t v, const wchar_t* text, TVirtualPadPainter::ETextMode mode)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualPadPainter.html:433,avail,available,433,root/html534/TVirtualPadPainter.html,https://root.cern,https://root.cern/root/html534/TVirtualPadPainter.html,1,['avail'],['available']
Availability,". TVirtualPadPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPadPainter. class TVirtualPadPainter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPadPainter(); static TClass*Class(); virtual voidClearDrawable(); virtual voidCopyDrawable(Int_t device, Int_t px, Int_t py); virtual Int_tCreateDrawable(UInt_t w, UInt_t h); virtual voidDestroyDrawable(); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); virtual voidDrawFillArea(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawFillArea(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidDrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); virtual voidDrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); virtual voidDrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); virtual voidDrawTextNDC(Double_t u, Double_t v, const char* text, TVirtualPadPainter::ETextMode mode); virtual Color_tGetFillColor() const; virtual Style_tGetFillStyle() const; virtual Color_tGetLineColor() const; virtual Style_tGetLineStyle() const; virtual Width_tGetLineWidth() const; virtual Short_tGetTextAlign() const; virtual Float_tGetTextAngle() const; virtual Color_tGetTextColor() const; virtual Font_tGetTextFont() const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualPadPainter.html:433,avail,available,433,root/html528/TVirtualPadPainter.html,https://root.cern,https://root.cern/root/html528/TVirtualPadPainter.html,3,['avail'],['available']
Availability,". TVirtualPerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPerfStats. class TVirtualPerfStats: public TObject. TVirtualPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TVirtualPerfStats*&CurrentPerfStats(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualPerfStats.html:578,avail,available,578,root/html602/TVirtualPerfStats.html,https://root.cern,https://root.cern/root/html602/TVirtualPerfStats.html,2,['avail'],['available']
Availability,". TVirtualPerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPerfStats. class TVirtualPerfStats: public TObject. TVirtualPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TVirtualPerfStats*&CurrentPerfStats(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualPerfStats.html:554,avail,available,554,root/html534/TVirtualPerfStats.html,https://root.cern,https://root.cern/root/html534/TVirtualPerfStats.html,1,['avail'],['available']
Availability,". TVirtualPerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPerfStats. class TVirtualPerfStats: public TObject. TVirtualPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualPerfStats.html:554,avail,available,554,root/html528/TVirtualPerfStats.html,https://root.cern,https://root.cern/root/html528/TVirtualPerfStats.html,3,['avail'],['available']
Availability,". TVirtualProofPlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TVirtualProofPlayer. class TVirtualProofPlayer: public TObject, public TQObject. TVirtualProofPlayer. Abstract interface for the PROOF player.; See the concrete implementations under 'proofplayer' for details. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualProofPlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddEventsProcessed(Long64_t ev); virtual voidAddInput(TObject* inp); virtual voidAddOutput(TList* out); virtual Int_tAddOutputObject(TObject* obj); virtual voidAddQueryResult(TQueryResult* q); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidClearInput(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualProofPlayer.html:574,avail,available,574,root/html528/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html528/TVirtualProofPlayer.html,1,['avail'],['available']
Availability,". TVirtualProofPlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TVirtualProofPlayer. class TVirtualProofPlayer: public TObject, public TQObject. TVirtualProofPlayer. Abstract interface for the PROOF player.; See the concrete implementations under 'proofplayer' for details. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualProofPlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddEventsProcessed(Long64_t ev); virtual voidAddInput(TObject* inp); virtual voidAddOutput(TList* out); virtual Int_tAddOutputObject(TObject* obj); virtual voidAddQueryResult(TQueryResult* q); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidClearInput(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualProofPlayer.html:576,avail,available,576,root/html530/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html530/TVirtualProofPlayer.html,3,['avail'],['available']
Availability,". TVirtualProofPlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TVirtualProofPlayer. class TVirtualProofPlayer: public TObject, public TQObject. TVirtualProofPlayer. Abstract interface for the PROOF player.; See the concrete implementations under 'proofplayer' for details. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualProofPlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddEventsProcessed(Long64_t ev); virtual voidAddInput(TObject* inp); virtual voidAddOutput(TList* out); virtual Int_tAddOutputObject(TObject* obj); virtual voidAddQueryResult(TQueryResult* q); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidClearInput(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualProofPlayer.html:624,avail,available,624,root/html602/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html602/TVirtualProofPlayer.html,1,['avail'],['available']
Availability,". TVirtualProofPlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TVirtualProofPlayer. class TVirtualProofPlayer: public TObject, public TQObject. TVirtualProofPlayer. Abstract interface for the PROOF player.; See the concrete implementations under 'proofplayer' for details. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualProofPlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddEventsProcessed(Long64_t ev); virtual voidAddInput(TObject* inp); virtual voidAddOutput(TList* out); virtual Int_tAddOutputObject(TObject* obj); virtual voidAddQueryResult(TQueryResult* q); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidClearInput(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualProofPlayer.html:600,avail,available,600,root/html604/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html604/TVirtualProofPlayer.html,1,['avail'],['available']
Availability,". TVirtualStreamerInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualStreamerInfo. class TVirtualStreamerInfo: public TNamed. TVirtualStreamerInfo Abstract Interface class. Abstract Interface describing Streamer information for one class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualStreamerInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuild(); virtual voidBuildCheck(TFile* file = 0); virtual voidBuildEmulated(TFile* file); virtual Bool_tBuildFor(const TClass* cl); virtual voidBuildOld(); virtual voidCallShowMembers(const void* obj, TMemberInspector& insp, Bool_t isTransient) const; static Bool_tCanDelete(); static Bool_tCanOptimize(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t*); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Bool_tCompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete, TFile* file); virtual voidCompile(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualStreamerInfo.html:591,avail,available,591,root/html602/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html602/TVirtualStreamerInfo.html,2,['avail'],['available']
Availability,". TVirtualStreamerInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualStreamerInfo. class TVirtualStreamerInfo: public TNamed. TVirtualStreamerInfo Abstract Interface class. Abstract Interface describing Streamer information for one class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualStreamerInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuild(); virtual voidBuildCheck(); virtual voidBuildEmulated(TFile* file); virtual Bool_tBuildFor(const TClass* cl); virtual voidBuildOld(); virtual voidCallShowMembers(void* obj, TMemberInspector& insp) const; static Bool_tCanDelete(); static Bool_tCanOptimize(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t*); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Bool_tCompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete); virtual voidCompile(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualStreamerInfo.html:567,avail,available,567,root/html528/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html528/TVirtualStreamerInfo.html,3,['avail'],['available']
Availability,". TVirtualStreamerInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualStreamerInfo. class TVirtualStreamerInfo: public TNamed. TVirtualStreamerInfo Abstract Interface class. Abstract Interface describing Streamer information for one class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualStreamerInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuild(); virtual voidBuildCheck(TFile* file = 0); virtual voidBuildEmulated(TFile* file); virtual Bool_tBuildFor(const TClass* cl); virtual voidBuildOld(); virtual voidCallShowMembers(void* obj, TMemberInspector& insp) const; static Bool_tCanDelete(); static Bool_tCanOptimize(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t*); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Bool_tCompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete, TFile* file); virtual voidCompile(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualStreamerInfo.html:567,avail,available,567,root/html534/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html534/TVirtualStreamerInfo.html,1,['avail'],['available']
Availability,". TVirtualTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualTableInterface. class TVirtualTableInterface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualTableInterface(); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TVirtualTableInterface&operator=(const TVirtualTableInterface&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualTableInterface(); {;}. Double_t GetValue(UInt_t row, UInt_t column). const char * GetValueAsString(UInt_t row, UInt_t column). const char * GetRowHeader(UInt_t row). const char * GetColumnHeader(UInt_t column). UInt_t GetNRows(). UInt_t GetNColumns(). » Author: Roel Aaij 21/07/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: Thu Sep 23 20:22:29 2010 » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualTableInterface.html:419,avail,available,419,root/html528/TVirtualTableInterface.html,https://root.cern,https://root.cern/root/html528/TVirtualTableInterface.html,1,['avail'],['available']
Availability,". TVirtualTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualTableInterface. class TVirtualTableInterface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualTableInterface(); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TVirtualTableInterface&operator=(const TVirtualTableInterface&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualTableInterface(); TVirtualTableInterface(const TVirtualTableInterface&). Class Charts. Inheritance Chart:. TVirtualTableInterface. ←. TGSimpleTableInterface. TTreeTableInterface. Function documentation; TVirtualTableInterface(); {;}. virtual ~TVirtualTableInterface(); {;}. Double_t GetValue(UInt_t row, UInt_t column). const char * GetValueAsString(UInt_t row, UInt_t column). const char * GetRowHeader(UInt_t row). const char * GetColumnHeader(UInt_t column). UInt_t GetNRows(). UInt_t GetNColumns(). » Author: Roel Aaij 21/07/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: Tue Jun 30 15:32:41 2015 » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualTableInterface.html:445,avail,available,445,root/html602/TVirtualTableInterface.html,https://root.cern,https://root.cern/root/html602/TVirtualTableInterface.html,1,['avail'],['available']
Availability,". TVirtualTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualTableInterface. class TVirtualTableInterface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualTableInterface(); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TVirtualTableInterface&operator=(const TVirtualTableInterface&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualTableInterface(); TVirtualTableInterface(const TVirtualTableInterface&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualTableInterface(); {;}. virtual ~TVirtualTableInterface(); {;}. Double_t GetValue(UInt_t row, UInt_t column). const char * GetValueAsString(UInt_t row, UInt_t column). const char * GetRowHeader(UInt_t row). const char * GetColumnHeader(UInt_t column). UInt_t GetNRows(). UInt_t GetNColumns(). » Author: Roel Aaij 21/07/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: Tue Sep 8 17:49:49 2015 » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualTableInterface.html:421,avail,available,421,root/html604/TVirtualTableInterface.html,https://root.cern,https://root.cern/root/html604/TVirtualTableInterface.html,1,['avail'],['available']
Availability,". TVirtualTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualTableInterface. class TVirtualTableInterface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualTableInterface(); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TVirtualTableInterface&operator=(const TVirtualTableInterface&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualTableInterface(); {;}. Double_t GetValue(UInt_t row, UInt_t column). const char * GetValueAsString(UInt_t row, UInt_t column). const char * GetRowHeader(UInt_t row). const char * GetColumnHeader(UInt_t column). UInt_t GetNRows(). UInt_t GetNColumns(). » Author: Roel Aaij 21/07/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: Mon Jul 4 15:38:58 2011 » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualTableInterface.html:421,avail,available,421,root/html530/TVirtualTableInterface.html,https://root.cern,https://root.cern/root/html530/TVirtualTableInterface.html,1,['avail'],['available']
Availability,". TVirtualTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualTableInterface. class TVirtualTableInterface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualTableInterface(); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TVirtualTableInterface&operator=(const TVirtualTableInterface&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualTableInterface(); {;}. Double_t GetValue(UInt_t row, UInt_t column). const char * GetValueAsString(UInt_t row, UInt_t column). const char * GetRowHeader(UInt_t row). const char * GetColumnHeader(UInt_t column). UInt_t GetNRows(). UInt_t GetNColumns(). » Author: Roel Aaij 21/07/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: Thu Nov 3 20:24:17 2011 » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualTableInterface.html:421,avail,available,421,root/html532/TVirtualTableInterface.html,https://root.cern,https://root.cern/root/html532/TVirtualTableInterface.html,1,['avail'],['available']
Availability,". TVirtualTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualTableInterface. class TVirtualTableInterface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualTableInterface(); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TVirtualTableInterface&operator=(const TVirtualTableInterface&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualTableInterface(); {;}. Double_t GetValue(UInt_t row, UInt_t column). const char * GetValueAsString(UInt_t row, UInt_t column). const char * GetRowHeader(UInt_t row). const char * GetColumnHeader(UInt_t column). UInt_t GetNRows(). UInt_t GetNColumns(). » Author: Roel Aaij 21/07/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: Tue Sep 8 17:05:53 2015 » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualTableInterface.html:421,avail,available,421,root/html534/TVirtualTableInterface.html,https://root.cern,https://root.cern/root/html534/TVirtualTableInterface.html,1,['avail'],['available']
Availability,". TVirtualTreePlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TVirtualTreePlayer. class TVirtualTreePlayer: public TObject. TVirtualTreePlayer. Abstract base class defining the interface for the plugins that; implement Draw, Scan, Process, MakeProxy, etc. for a TTree object.; See the individual documentations in TTree. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualTreePlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual TVirtualIndex*BuildIndex(const TTree* T, const char* majorname, const char* minorname); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Long64_tDrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Long64_tDrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Dump() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualTreePlayer.html:670,avail,available,670,root/html602/TVirtualTreePlayer.html,https://root.cern,https://root.cern/root/html602/TVirtualTreePlayer.html,2,['avail'],['available']
Availability,". TVirtualTreePlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TVirtualTreePlayer. class TVirtualTreePlayer: public TObject. TVirtualTreePlayer. Abstract base class defining the interface for the plugins that; implement Draw, Scan, Process, MakeProxy, etc. for a TTree object.; See the individual documentations in TTree. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualTreePlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual TVirtualIndex*BuildIndex(const TTree* T, const char* majorname, const char* minorname); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Long64_tDrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Long64_tDrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Dump() constMENU ; virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualTreePlayer.html:646,avail,available,646,root/html528/TVirtualTreePlayer.html,https://root.cern,https://root.cern/root/html528/TVirtualTreePlayer.html,4,['avail'],['available']
Availability,". TVolumeView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TVolumeView. class TVolumeView: public TObjectSet, public TAtt3D. TVolumeView. TVolumeView class is a special kind of TDataSet with one extra; pointer to wrap any TObject onto TDataSet object. BE CAREFUL !!!; One has to use it carefully no control over that extra object; is performed. This means: the object m_Obj data-member points to can; be destroyed with no this kbject notifying.; There is no tool /protection to check whether m_Obj is till alive.; It is one's code responsilitiy. Function Members (Methods); public:. virtual~TVolumeView(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TDataSet* dataset); virtual voidAdd(TVolumeView* node); virtual voidAdd(TShape* shape, Bool_t IsMaster = kFALSE); virtual voidTDataSet::AddAt(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual TVolume*AddNode(TVolume* node); virtual TObject*TObjectSet::AddObject(TObject* obj, Bool_t makeOwner = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); TDataSet*TDataSet::At(Int_t idx) const; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObjectSet::Delete(Option_t* opt = """"); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTObjectSet::DoOwner(Bool_t done = kTRUE); virtual voidDraw(Option_t* depth = ""3"")MENU ; virtual voidTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVolumeView.html:718,alive,alive,718,root/html602/TVolumeView.html,https://root.cern,https://root.cern/root/html602/TVolumeView.html,2,['alive'],['alive']
Availability,". TVolumeView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TVolumeView. class TVolumeView: public TObjectSet, public TAtt3D. TVolumeView. TVolumeView class is a special kind of TDataSet with one extra; pointer to wrap any TObject onto TDataSet object. BE CAREFUL !!!; One has to use it carefully no control over that extra object; is performed. This means: the object m_Obj data-member points to can; be destroyed with no this kbject notifying.; There is no tool /protection to check whether m_Obj is till alive.; It is one's code responsilitiy. Function Members (Methods); public:. TVolumeView(); TVolumeView(TVolumeView* viewNode, TVolumePosition* nodePosition = 0); TVolumeView(TVolumeView* viewNode, TVolumeView* topNode); TVolumeView(TVolume* thisNode, TVolumePosition* nodePosition); TVolumeView(TVolumeView* viewNode, const Char_t* NodeName1, const Char_t* NodeName2 = 0); TVolumeView(TVolumeView* viewNode, const TVolumeView* node1, const TVolumeView* node2); TVolumeView(TVolume& pattern, Int_t maxDepLevel = 0, const TVolumePosition* nodePosition = 0, TDataSet::EDataSetPass iopt = kMarked, TVolumeView* root = 0); TVolumeView(Double_t* translate, Double_t* rotate, UInt_t positionId, TVolume* thisNode, const Char_t* thisNodePath, const Char_t* matrixName = 0, Int_t matrixType = 0); virtual~TVolumeView(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TDataSet* dataset); virtual voidAdd(TVolumeView* node); virtual voidAdd(TShape* shape, Bool_t IsMaster = kFALSE); virtual voidTDataSet::AddAt(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual TVolume*AddNode(TVolume* node); virtual TObject*TObjectSet::AddObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVolumeView.html:694,alive,alive,694,root/html528/TVolumeView.html,https://root.cern,https://root.cern/root/html528/TVolumeView.html,4,['alive'],['alive']
Availability,". TXHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFX; » TXHandler. class TXHandler. TXHandler. Handler of asynchronous events for xproofd sockets.; Classes needing this should inherit from this and overload the; relevant methods. Function Members (Methods); public:. virtual~TXHandler(); static TClass*Class(); virtual Bool_tHandleError(const void* in = 0); virtual Bool_tHandleInput(const void* in = 0); virtual TClass*IsA() const; TXHandler&operator=(const TXHandler&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TXHandler(); TXHandler(const TXHandler&). Class Charts. Inheritance Chart:. TXHandler. ←. TXProofMgr. TXProofServ. TXSlave. Function documentation; Bool_t HandleInput(const void* in = 0); Handler of asynchronous input events. Bool_t HandleError(const void* in = 0); Handler of asynchronous error events. TXHandler(); { }. virtual ~TXHandler(); { }. » Author: G. Ganis Mar 2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXHandler.html:1124,error,error,1124,root/html604/TXHandler.html,https://root.cern,https://root.cern/root/html604/TXHandler.html,1,['error'],['error']
Availability,". TXHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFX; » TXHandler. class TXHandler. TXHandler. Handler of asynchronous events for xproofd sockets.; Classes needing this should inherit from this and overload the; relevant methods. Function Members (Methods); public:. virtual~TXHandler(); static TClass*Class(); virtual Bool_tHandleError(const void* in = 0); virtual Bool_tHandleInput(const void* in = 0); virtual TClass*IsA() const; TXHandler&operator=(const TXHandler&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TXHandler(); TXHandler(const TXHandler&). Class Charts. Inheritance Chart:. TXHandler. ←. TXProofMgr. TXProofServ. TXSlave. Function documentation; Bool_t HandleInput(const void* in = 0); Handler of asynchronous input events. Bool_t HandleError(const void* in = 0); Handler of asynchronous error events. TXHandler(); { }. virtual ~TXHandler(); { }. » Author: G. Ganis Mar 2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXHandler.html:1124,error,error,1124,root/html602/TXHandler.html,https://root.cern,https://root.cern/root/html602/TXHandler.html,1,['error'],['error']
Availability,". TXHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFX; » TXHandler. class TXHandler. TXHandler. Handler of asynchronous events for xproofd sockets.; Classes needing this should inherit from this and overload the; relevant methods. Function Members (Methods); public:. TXHandler(); TXHandler(const TXHandler&); virtual~TXHandler(); static TClass*Class(); virtual Bool_tHandleError(const void* in = 0); virtual Bool_tHandleInput(const void* in = 0); virtual TClass*IsA() const; TXHandler&operator=(const TXHandler&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t HandleInput(const void* in = 0); Handler of asynchronous input events. Bool_t HandleError(const void* in = 0); Handler of asynchronous error events. TXHandler(); { }. virtual ~TXHandler(); { }. » Author: G. Ganis Mar 2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXHandler.h 30815 2009-10-20 13:49:22Z rdm $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXHandler.html:1055,error,error,1055,root/html528/TXHandler.html,https://root.cern,https://root.cern/root/html528/TXHandler.html,1,['error'],['error']
Availability,". TXHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFX; » TXHandler. class TXHandler. TXHandler. Handler of asynchronous events for xproofd sockets.; Classes needing this should inherit from this and overload the; relevant methods. Function Members (Methods); public:. TXHandler(); TXHandler(const TXHandler&); virtual~TXHandler(); static TClass*Class(); virtual Bool_tHandleError(const void* in = 0); virtual Bool_tHandleInput(const void* in = 0); virtual TClass*IsA() const; TXHandler&operator=(const TXHandler&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t HandleInput(const void* in = 0); Handler of asynchronous input events. Bool_t HandleError(const void* in = 0); Handler of asynchronous error events. TXHandler(); { }. virtual ~TXHandler(); { }. » Author: G. Ganis Mar 2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXHandler.h 30815 2009-10-20 13:49:22Z rdm $ » Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXHandler.html:1055,error,error,1055,root/html530/TXHandler.html,https://root.cern,https://root.cern/root/html530/TXHandler.html,1,['error'],['error']
Availability,". TXHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFX; » TXHandler. class TXHandler. TXHandler. Handler of asynchronous events for xproofd sockets.; Classes needing this should inherit from this and overload the; relevant methods. Function Members (Methods); public:. TXHandler(); TXHandler(const TXHandler&); virtual~TXHandler(); static TClass*Class(); virtual Bool_tHandleError(const void* in = 0); virtual Bool_tHandleInput(const void* in = 0); virtual TClass*IsA() const; TXHandler&operator=(const TXHandler&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t HandleInput(const void* in = 0); Handler of asynchronous input events. Bool_t HandleError(const void* in = 0); Handler of asynchronous error events. TXHandler(); { }. virtual ~TXHandler(); { }. » Author: G. Ganis Mar 2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXHandler.h 30815 2009-10-20 13:49:22Z rdm $ » Last generated: 2011-12-02 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXHandler.html:1055,error,error,1055,root/html532/TXHandler.html,https://root.cern,https://root.cern/root/html532/TXHandler.html,1,['error'],['error']
Availability,". TXHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFX; » TXHandler. class TXHandler. TXHandler. Handler of asynchronous events for xproofd sockets.; Classes needing this should inherit from this and overload the; relevant methods. Function Members (Methods); public:. TXHandler(); TXHandler(const TXHandler&); virtual~TXHandler(); static TClass*Class(); virtual Bool_tHandleError(const void* in = 0); virtual Bool_tHandleInput(const void* in = 0); virtual TClass*IsA() const; TXHandler&operator=(const TXHandler&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t HandleInput(const void* in = 0); Handler of asynchronous input events. Bool_t HandleError(const void* in = 0); Handler of asynchronous error events. TXHandler(); { }. virtual ~TXHandler(); { }. » Author: G. Ganis Mar 2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-03-15 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXHandler.html:1074,error,error,1074,root/html534/TXHandler.html,https://root.cern,https://root.cern/root/html534/TXHandler.html,1,['error'],['error']
Availability,". TXMLParser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XMLPARSER; » TXMLParser. class TXMLParser: public TObject, public TQObject. TXMLParser. TXMLParser is an abstract class which interfaces with Libxml2.; Libxml2 is the XML C parser and toolkit developed for the Gnome; project. The libxml library provides two interfaces to the parser, a DOM; style tree interface and a SAX style event based interface. TXMLParser is parent class of TSAXParser and TDOMParser, which are; a SAX interface and DOM interface of libxml. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TXMLParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXMLParser.html:857,avail,available,857,root/html602/TXMLParser.html,https://root.cern,https://root.cern/root/html602/TXMLParser.html,2,['avail'],['available']
Availability,". TXMLParser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XMLPARSER; » TXMLParser. class TXMLParser: public TObject, public TQObject. TXMLParser. TXMLParser is an abstract class which interfaces with Libxml2.; Libxml2 is the XML C parser and toolkit developed for the Gnome; project. The libxml library provides two interfaces to the parser, a DOM; style tree interface and a SAX style event based interface. TXMLParser is parent class of TSAXParser and TDOMParser, which are; a SAX interface and DOM interface of libxml. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TXMLParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLParser.html:833,avail,available,833,root/html528/TXMLParser.html,https://root.cern,https://root.cern/root/html528/TXMLParser.html,4,['avail'],['available']
Availability,". TXNetFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NETX; » TXNetFile. class TXNetFile: public TNetFile. TXNetFile. Authors: Alvise Dorigo, Fabrizio Furano; INFN Padova, 2003; Interfaced to the standalone client (XrdClient): G. Ganis, CERN. TXNetFile is an extension of TNetFile able to deal with new xrootd; server. Its new features are:; - Automatic server kind recognition (xrootd load balancer, xrootd; data server, old rootd); - Backward compatibility with old rootd server (acts as an old; TNetFile); - Fault tolerance for read/write operations (read/write timeouts; and retry); - Internal connection timeout (tunable indipendently from the OS; one) handled by threads; - handling of redirections from server; - Single TCP physical channel for multiple TXNetFile's instances; inside the same application; So, each TXNetFile object client must send messages containing; its ID (streamid). The server, of course, will respond with; messages containing the client's ID, in order to make the client; able to recognize its message by matching its streamid with that; one contained in the server's response.; - Tunable log verbosity level (0 = nothing, 3 = dump read/write; buffers too!); - Many parameters configurable via TEnv facility (see SetParm(); methods). Function Members (Methods); public:. virtual~TXNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetFile.html:722,toler,tolerance,722,root/html602/TXNetFile.html,https://root.cern,https://root.cern/root/html602/TXNetFile.html,1,['toler'],['tolerance']
Availability,". TXNetFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NETX; » TXNetFile. class TXNetFile: public TNetFile. TXNetFile. Authors: Alvise Dorigo, Fabrizio Furano; INFN Padova, 2003; Interfaced to the standalone client (XrdClient): G. Ganis, CERN. TXNetFile is an extension of TNetFile able to deal with new xrootd; server. Its new features are:; - Automatic server kind recognition (xrootd load balancer, xrootd; data server, old rootd); - Backward compatibility with old rootd server (acts as an old; TNetFile); - Fault tolerance for read/write operations (read/write timeouts; and retry); - Internal connection timeout (tunable indipendently from the OS; one) handled by threads; - handling of redirections from server; - Single TCP physical channel for multiple TXNetFile's instances; inside the same application; So, each TXNetFile object client must send messages containing; its ID (streamid). The server, of course, will respond with; messages containing the client's ID, in order to make the client; able to recognize its message by matching its streamid with that; one contained in the server's response.; - Tunable log verbosity level (0 = nothing, 3 = dump read/write; buffers too!); - Many parameters configurable via TEnv facility (see SetParm(); methods). Function Members (Methods); public:. TXNetFile(); TXNetFile(const char* url, Option_t* option = """", const char* fTitle = """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE, const char* logicalurl = 0); virtual~TXNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:698,toler,tolerance,698,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,4,['toler'],['tolerance']
Availability,". TXNetFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NETX; » TXNetFile. class TXNetFile: public TNetFile. TXNetFile. Authors: Alvise Dorigo, Fabrizio Furano; INFN Padova, 2003; Interfaced to the standalone client (XrdClient): G. Ganis, CERN. TXNetFile is an extension of TNetFile able to deal with new xrootd; server. Its new features are:; - Automatic server kind recognition (xrootd load balancer, xrootd; data server, old rootd); - Backward compatibility with old rootd server (acts as an old; TNetFile); - Fault tolerance for read/write operations (read/write timeouts; and retry); - Internal connection timeout (tunable indipendently from the OS; one) handled by threads; - handling of redirections from server; - Single TCP physical channel for multiple TXNetFile's instances; inside the same application; So, each TXNetFile object client must send messages containing; its ID (streamid). The server, of course, will respond with; messages containing the client's ID, in order to make the client; able to recognize its message by matching its streamid with that; one contained in the server's response.; - Tunable log verbosity level (0 = nothing, 3 = dump read/write; buffers too!); - Many parameters configurable via TEnv facility (see SetParm(); methods). Function Members (Methods); public:. virtual~TXNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXNetFile.html:698,toler,tolerance,698,root/html604/TXNetFile.html,https://root.cern,https://root.cern/root/html604/TXNetFile.html,1,['toler'],['tolerance']
Availability,". The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effects, by changing global; ROOT state via, e.g. gSystem calls, etc. However, in specific cases; this might be useful, e.g. adding a library search path, adding a specific; dependency, check on some OS or ROOT capability or downloading; of the plugin. void AddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); Add plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified base. TPluginHandler * FindHandler(const char* base, const char* uri = 0); Returns the handler if there exists a handler for the specified URI.; The uri can be 0 in which case the first matching plugin handler; will be returned. Returns 0 in case handler is not found. void Print(Option_t* opt = """") const; Print list of registered plugin handlers. If option is ""a"" print; also the ctor's that will be used. Int_t WritePluginMacros(const char* dir, const char* plugin = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPluginManager.html:10687,down,downloading,10687,root/html528/TPluginManager.html,https://root.cern,https://root.cern/root/html528/TPluginManager.html,6,['down'],['downloading']
Availability,". The TProcessID with number pidf is read from this file. ; If the object is not already entered in the gROOT list, it is added. ; Definition at line 1951 of file TFile.cxx. ◆ ReadStreamerInfo(). void TFile::ReadStreamerInfo ; (; ). virtual . Read the list of StreamerInfo from this file. ; The key with name holding the list of TStreamerInfo objects is read. The corresponding TClass objects are updated. Note that this function is not called if the static member fgReadInfo is false. (see TFile::SetReadStreamerInfo) ; Definition at line 3605 of file TFile.cxx. ◆ Recover(). Int_t TFile::Recover ; (; ). virtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the sys",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:89148,recover,recover,89148,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['recover'],['recover']
Availability,". The most common change, namely where to find; 2791/// header files, will be available through the function; 2792/// TSystem::SetIncludePath().; 2793/// A good default will be provided so that a typical user session should be at; 2794/// most:; 2795/// ~~~ {.cpp}; 2796/// root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; 2797/// -I$HOME/mypackage/include"");; 2798/// root[2] .x myfunc.C++(10,20);; 2799/// ~~~; 2800/// The user may sometimes try to compile a script before it has loaded all the; 2801/// needed shared libraries. In this case we want to be helpful and output a; 2802/// list of the unresolved symbols. So if the loading of the created shared; 2803/// library fails, we will try to build a executable that contains the; 2804/// script. The linker should then output a list of missing symbols.; 2805///; 2806/// To support this we provide a TSystem::SetMakeExe() function, that sets the; 2807/// directive telling how to create an executable. The loader will need; 2808/// to be informed of all the libraries available. The information about; 2809/// the libraries that has been loaded by .L and TSystem::Load() is accessible; 2810/// to the script compiler. However, the information about; 2811/// the libraries that have been selected at link time by the application; 2812/// builder (like the root libraries for root.exe) are not available and need; 2813/// to be explicitly listed in fLinkedLibs (either by default or by a call to; 2814/// TSystem::SetLinkedLibs()).; 2815///; 2816/// To simplify customization we could also add to the .rootrc support for the; 2817/// variables; 2818/// ~~~ {.cpp}; 2819/// Unix.*.Root.IncludePath: -I$ROOTSYS/include; 2820/// WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; 2821///; 2822/// Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; 2823/// WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; 2824/// ~~~; 2825/// And also support for MakeSharedLibs() and MakeExe().; 2826///; 2827/// (the ... have to be replaced by the ac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:92586,avail,available,92586,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['avail'],['available']
Availability,". This function calls the RLoopManager::Run method on the fLoopManager data member of the input argument. It is intended for internal use only. ; Definition at line 38 of file RInterface.cxx. ◆ TTreeAsFlatMatrix(). template<typename BufType , typename... ColTypes, std::size_t... Idx> . void ROOT::Internal::RDF::TTreeAsFlatMatrix ; (; std::index_sequence< Idx... > ; , . TTree & ; tree, . std::vector< BufType > & ; matrix, . std::vector< std::string > & ; columns . ). Definition at line 40 of file PyROOTHelpers.hxx. ◆ TTreeAsFlatMatrixHelper(). template<typename BufType , typename... ColTypes> . void ROOT::Internal::RDF::TTreeAsFlatMatrixHelper ; (; TTree & ; tree, . std::vector< BufType > & ; matrix, . std::vector< std::string > & ; columns . ). Definition at line 58 of file PyROOTHelpers.hxx. ◆ TypeID2TypeName(). std::string ROOT::Internal::RDF::TypeID2TypeName ; (; const std::type_info & ; id). Returns the name of a type starting from its type_info An empty string is returned in case of failure References and pointers are not supported since those cannot be stored in columns. ; Note that this function will take a lock and may be a potential source of contention in multithreaded execution. ; Definition at line 119 of file RDFUtils.cxx. ◆ TypeName2ROOTTypeName(). char ROOT::Internal::RDF::TypeName2ROOTTypeName ; (; const std::string & ; b). Convert type name (e.g. ; ""Float_t"") to ROOT type code (e.g. 'F') – see TBranch documentation. Return a space ' ' in case no match was found. ; Definition at line 259 of file RDFUtils.cxx. ◆ TypeName2TypeID(). const std::type_info & ROOT::Internal::RDF::TypeName2TypeID ; (; const std::string & ; name). Return the type_info associated to a name. ; If the association fails, an exception is thrown. References and pointers are not supported since those cannot be stored in columns. ; Definition at line 62 of file RDFUtils.cxx. ◆ Union(). template<typename T > . std::vector< T > ROOT::Internal::RDF::Union ; (; const std::vector< T > & ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1RDF.html:42056,failure,failure,42056,doc/master/namespaceROOT_1_1Internal_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1RDF.html,1,['failure'],['failure']
Availability,". To change the file name use File menu / Save As... or corresponding SaveAs button on the toolbar.; Text Selection; You can move the cursor by simply clicking on the desired location with the left mouse button. To highlight some text, press the mouse and drag the mouse while holding the left button pressed. To select a word, double-click on it; to select the text line - triple-click on it; to select all do quadruple-click.; Cut, Copy, Paste; After selecting some text, you can cut or copy it to the clipboard. A subsequent paste operation will insert the contents of the clipboard at the current cursor location.; Text Search; The editor uses a standard Search dialog. You can specify a forward or backward search direction starting from the current cursor location according to the selection made of a case sensitive mode or not. The last search can be repeated by pressing F3.; Text Font; You can change the text font by selecting Edit menu / Set Font. The Font Dialog pops up and shows the Name, Style, and Size of any available font. The selected font sample is shown in the preview area.; Executing Macros; You can execute the currently loaded macro in the editor by selecting Tools menu / Execute Macro; by clicking on the corresponding toolbar button, or by using Ctrl+F5 accelerator keys. This is identical to the command "".x macro.C"" in the root prompt command line.; Compiling Macros; The currently loaded macro can be compiled with ACLiC if you select Tools menu / Compile Macro; by clicking on the corresponding toolbar button, or by using Ctrl+F7 accelerator keys. This is identical to the command "".L macro.C++"" in the root prompt command line.; Interrupting a Running Macro; You can interrupt a running macro by selecting the Tools menu / Interrupt; by clicking on the corresponding toolbar button, or by using Shift+F5 accelerator keys.; Interface to CINT Interpreter; Any command entered in the Command combo box will be passed to the CINT interpreter. This combo box will keep t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEditor.html:2340,avail,available,2340,doc/master/classTGTextEditor.html,https://root.cern,https://root.cern/doc/master/classTGTextEditor.html,1,['avail'],['available']
Availability,". UInt_t TSocket::GetBytesRecv ; (; ); const. inline . Definition at line 120 of file TSocket.h. ◆ GetBytesSent(). UInt_t TSocket::GetBytesSent ; (; ); const. inline . Definition at line 119 of file TSocket.h. ◆ GetClientProtocol(). Int_t TSocket::GetClientProtocol ; (; ). static . Static method returning supported client protocol. ; Definition at line 1469 of file TSocket.cxx. ◆ GetCompressionAlgorithm(). Int_t TSocket::GetCompressionAlgorithm ; (; ); const. inline . Definition at line 175 of file TSocket.h. ◆ GetCompressionLevel(). Int_t TSocket::GetCompressionLevel ; (; ); const. inline . Definition at line 181 of file TSocket.h. ◆ GetCompressionSettings(). Int_t TSocket::GetCompressionSettings ; (; ); const. inline . Definition at line 187 of file TSocket.h. ◆ GetDescriptor(). virtual Int_t TSocket::GetDescriptor ; (; ); const. inlinevirtual . Reimplemented in TPSocket.; Definition at line 112 of file TSocket.h. ◆ GetErrorCode(). Int_t TSocket::GetErrorCode ; (; ); const. Returns error code. ; Meaning depends on context where it is called. If no error condition returns 0 else a value < 0. For example see TServerSocket ctor. ; Definition at line 1035 of file TSocket.cxx. ◆ GetInetAddress(). TInetAddress TSocket::GetInetAddress ; (; ); const. inline . Definition at line 113 of file TSocket.h. ◆ GetLastUsage(). TTimeStamp TSocket::GetLastUsage ; (; ). inline . Definition at line 129 of file TSocket.h. ◆ GetLocalInetAddress(). TInetAddress TSocket::GetLocalInetAddress ; (; ). virtual . Return internet address of local host to which the socket is bound. ; In case of error TInetAddress::IsValid() returns kFALSE. ; Reimplemented in TPSocket, and TServerSocket.; Definition at line 409 of file TSocket.cxx. ◆ GetLocalPort(). Int_t TSocket::GetLocalPort ; (; ). virtual . Return the local port # to which the socket is bound. ; In case of error return -1. ; Reimplemented in TServerSocket.; Definition at line 423 of file TSocket.cxx. ◆ GetOption() [1/2]. Option_t * TSocket::G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:27484,error,error,27484,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,1,['error'],['error']
Availability,". UInt_t ; h . ). virtual . Draws rectangle outlines of [x,y] [x+w,y] [x+w,y+h] [x,y+h]. ; GC components in use: function, plane-mask, line-width, line-style, cap-style, join-style, fill-style, subwindow-mode, clip-x-origin, clip-y-origin, clip-mask. GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, tile-stipple-y-origin, dash-offset, dash-list. (see also the GCValues_t structure) ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1913 of file TVirtualX.cxx. ◆ DrawSegments(). void TVirtualX::DrawSegments ; (; Drawable_t ; id, . GContext_t ; gc, . Segment_t * ; seg, . Int_t ; nseg . ). virtual . Draws multiple line segments. ; Each line is specified by a pair of points.; Parameters. [in]idDrawable identifier ; [in]gcgraphics context ; [in]*segspecifies an array of segments ; [in]nsegspecifies the number of segments in the array. GC components in use: function, plane-mask, line-width, line-style, cap-style, join-style, fill-style, subwindow-mode, clip-x-origin, clip-y-origin, clip-mask.; GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, tile-stipple-y-origin, dash-offset, and dash-list. (see also the GCValues_t structure) ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1935 of file TVirtualX.cxx. ◆ DrawString(). void TVirtualX::DrawString ; (; Drawable_t ; id, . GContext_t ; gc, . Int_t ; x, . Int_t ; y, . const char * ; s, . Int_t ; len . ). virtual . Each character image, as defined by the font in the GC, is treated as an additional mask for a fill operation on the drawable. ; Parameters. [in]idthe drawable ; [in]gcthe GC ; [in]x,ycoordinates, which are relative to the origin of the specified drawable and define the origin of the first character ; [in]sthe character string ; [in]lenthe number of characters in the string argument. GC components in use: function, plane-mask, fill-style, font, subwindow-mod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:74696,mask,mask,74696,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,2,['mask'],['mask']
Availability,". Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSocket.html:19251,error,error,19251,root/html530/TSocket.html,https://root.cern,https://root.cern/root/html530/TSocket.html,9,['error'],['error']
Availability,". Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionLevel(Int_t level = 1); Set the message compression level. Can be between 0 and 9 with 0; being no compression and 9 maximum compression. In general the default; level of 1 is the best compromise between achieved compression and; cpu time. Compression will only happen when the message is > 256 bytes. Bool_t Authenticate(const char* user); Authenticated the socket with specified user. TSocket * CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server. url: [[proto][p][auth]://][user@]host[:port][/service][?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSocket.html:18974,error,error,18974,root/html528/TSocket.html,https://root.cern,https://root.cern/root/html528/TSocket.html,1,['error'],['error']
Availability,". Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4236 of file RooAbsReal.cxx. ◆ chi2FitTo() [4/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataSet & ; xydata, . const RooLinkedList & ; cmdList . ). virtual . Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ; The y values can either be the event weights, or can be another column designated by the YVar() argument. The y value must have errors defined for the \( \chi^2 \) to be well defined. Options to control construction of the chi-square . YVar(RooRealVar& yvar) Designate given column in dataset as Y value . Integrate(bool flag) Integrate function over range specified by X errors rather than take value at bin center. Options to control flow of fit procedure . InitialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit ste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:75871,error,errors,75871,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['error'],['errors']
Availability,". Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4312 of file RooAbsReal.cxx. ◆ chi2FitTo() [4/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataSet & ; xydata, . const RooLinkedList & ; cmdList . ). virtual . Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ; The y values can either be the event weights, or can be another column designated by the YVar() argument. The y value must have errors defined for the \( \chi^2 \) to be well defined. Options to control construction of the chi-square . YVar(RooRealVar& yvar) Designate given column in dataset as Y value . Integrate(bool flag) Integrate function over range specified by X errors rather than take value at bin center. Options to control flow of fit procedure . InitialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit ste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:77139,error,errors,77139,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['error'],['errors']
Availability,". We use NULL to mean not set, so we don't want to fill; with empty RooArgSets. void Print(Option_t* option = """") const; print contents of Model on the default print stream; It can be changed using RooPrintable. void SetWS(RooWorkspace& ws); set a workspace that owns all the necessary components for the analysis. RooWorkspace * GetWS() const; get from TRef. void SetSnapshot(const RooArgSet& set); save snaphot in the workspace; and use values passed with the set. const RooArgSet * GetSnapshot() const; Load the snapshot from ws and return the corresponding set with the snapshot values.; User must delete returned RooArgSet. void LoadSnapshot() const; load the snapshot from ws if it exists. void DefineSetInWS(const char* name, const RooArgSet& set); helper functions to avoid code duplication. void ImportPdfInWS(const RooAbsPdf& pdf); internal function to import Pdf in WS. void ImportDataInWS(RooAbsData& data); internal function to import data in WS. Bool_t SetHasOnlyParameters(const RooArgSet& set, const char* errorMsgPrefix = 0). ModelConfig(RooWorkspace* ws = 0). ModelConfig(const char* name, RooWorkspace* ws = 0). ModelConfig(const char* name, const char* title, RooWorkspace* ws = 0). ModelConfig * Clone(const char* name = """") const; clone. void SetWorkspace(RooWorkspace& ws); alias for SetWS(...). { SetWS(ws); }. void SetProtoData(RooAbsData& data); Set the proto DataSet, add to the the workspace if not already there. SetProtoData(const char* name). void SetPdf(const RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. SetPdf(const char* name). void SetPriorPdf(const RooAbsPdf& pdf); Set the Prior Pdf, add to the the workspace if not already there. SetPriorPdf(const char* name). void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. void SetParametersOfInterest(const RooArgSet& set). SetParameters(const char* argList). void SetParametersOfInterest(const char* argList). void SetNuisanceParameters(const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__ModelConfig.html:9931,error,errorMsgPrefix,9931,root/html534/RooStats__ModelConfig.html,https://root.cern,https://root.cern/root/html534/RooStats__ModelConfig.html,3,['error'],['errorMsgPrefix']
Availability,". WindowAttributes_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » WindowAttributes_t. class WindowAttributes_t. GuiTypes. Types used by the GUI classes. Function Members (Methods); public:. WindowAttributes_t(); WindowAttributes_t(const WindowAttributes_t&); ~WindowAttributes_t(); WindowAttributes_t&operator=(const WindowAttributes_t&). Data Members; public:. Long_tfAllEventMasksset of events all people have interest in; ULong_tfBackingPixelvalue to be used when restoring planes; ULong_tfBackingPlanesplanes to be preserved if possible; Int_tfBackingStorekNotUseful, kWhenMapped, kAlways; Int_tfBitGravityone of bit gravity values; Int_tfBorderWidthborder width of window; Int_tfClasskInputOutput, kInputOnly; Colormap_tfColormapcolor map to be associated with window; Int_tfDepthdepth of window; Long_tfDoNotPropagateMaskset of events that should not propagate; Int_tfHeightwidth and height of window; Bool_tfMapInstalledboolean, is color map currently installed; Int_tfMapStatekIsUnmapped, kIsUnviewable, kIsViewable; Bool_tfOverrideRedirectboolean value for override-redirect; Window_tfRootroot of screen containing window; Bool_tfSaveUnderboolean, should bits under be saved?; void*fScreenback pointer to correct screen; void*fVisualthe associated visual structure; Int_tfWidth; Int_tfWinGravityone of the window gravity values; Int_tfX; Int_tfYlocation of window; Long_tfYourEventMaskmy event mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Last changed: Thu Sep 23 20:22:46 2010 » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/WindowAttributes_t.html:1564,mask,mask,1564,root/html528/WindowAttributes_t.html,https://root.cern,https://root.cern/root/html528/WindowAttributes_t.html,1,['mask'],['mask']
Availability,". WindowAttributes_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » WindowAttributes_t. class WindowAttributes_t. GuiTypes. Types used by the GUI classes. Function Members (Methods); public:. WindowAttributes_t(); WindowAttributes_t(const WindowAttributes_t&); ~WindowAttributes_t(); WindowAttributes_t&operator=(const WindowAttributes_t&). Data Members; public:. Long_tfAllEventMasksset of events all people have interest in; ULong_tfBackingPixelvalue to be used when restoring planes; ULong_tfBackingPlanesplanes to be preserved if possible; Int_tfBackingStorekNotUseful, kWhenMapped, kAlways; Int_tfBitGravityone of bit gravity values; Int_tfBorderWidthborder width of window; Int_tfClasskInputOutput, kInputOnly; Colormap_tfColormapcolor map to be associated with window; Int_tfDepthdepth of window; Long_tfDoNotPropagateMaskset of events that should not propagate; Int_tfHeightwidth and height of window; Bool_tfMapInstalledboolean, is color map currently installed; Int_tfMapStatekIsUnmapped, kIsUnviewable, kIsViewable; Bool_tfOverrideRedirectboolean value for override-redirect; Window_tfRootroot of screen containing window; Bool_tfSaveUnderboolean, should bits under be saved?; void*fScreenback pointer to correct screen; void*fVisualthe associated visual structure; Int_tfWidth; Int_tfWinGravityone of the window gravity values; Int_tfX; Int_tfYlocation of window; Long_tfYourEventMaskmy event mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Last changed: Mon Jul 4 15:39:15 2011 » Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/WindowAttributes_t.html:1566,mask,mask,1566,root/html530/WindowAttributes_t.html,https://root.cern,https://root.cern/root/html530/WindowAttributes_t.html,1,['mask'],['mask']
Availability,". WindowAttributes_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » WindowAttributes_t. class WindowAttributes_t. GuiTypes. Types used by the GUI classes. Function Members (Methods); public:. WindowAttributes_t(); WindowAttributes_t(const WindowAttributes_t&); ~WindowAttributes_t(); WindowAttributes_t&operator=(const WindowAttributes_t&). Data Members; public:. Long_tfAllEventMasksset of events all people have interest in; ULong_tfBackingPixelvalue to be used when restoring planes; ULong_tfBackingPlanesplanes to be preserved if possible; Int_tfBackingStorekNotUseful, kWhenMapped, kAlways; Int_tfBitGravityone of bit gravity values; Int_tfBorderWidthborder width of window; Int_tfClasskInputOutput, kInputOnly; Colormap_tfColormapcolor map to be associated with window; Int_tfDepthdepth of window; Long_tfDoNotPropagateMaskset of events that should not propagate; Int_tfHeightwidth and height of window; Bool_tfMapInstalledboolean, is color map currently installed; Int_tfMapStatekIsUnmapped, kIsUnviewable, kIsViewable; Bool_tfOverrideRedirectboolean value for override-redirect; Window_tfRootroot of screen containing window; Bool_tfSaveUnderboolean, should bits under be saved?; void*fScreenback pointer to correct screen; void*fVisualthe associated visual structure; Int_tfWidth; Int_tfWinGravityone of the window gravity values; Int_tfX; Int_tfYlocation of window; Long_tfYourEventMaskmy event mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Last changed: Thu Nov 3 20:24:28 2011 » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/WindowAttributes_t.html:1566,mask,mask,1566,root/html532/WindowAttributes_t.html,https://root.cern,https://root.cern/root/html532/WindowAttributes_t.html,1,['mask'],['mask']
Availability,". WindowAttributes_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » WindowAttributes_t. class WindowAttributes_t. GuiTypes. Types used by the GUI classes. Function Members (Methods); public:. WindowAttributes_t(); WindowAttributes_t(const WindowAttributes_t&); ~WindowAttributes_t(); WindowAttributes_t&operator=(const WindowAttributes_t&). Data Members; public:. Long_tfAllEventMasksset of events all people have interest in; ULong_tfBackingPixelvalue to be used when restoring planes; ULong_tfBackingPlanesplanes to be preserved if possible; Int_tfBackingStorekNotUseful, kWhenMapped, kAlways; Int_tfBitGravityone of bit gravity values; Int_tfBorderWidthborder width of window; Int_tfClasskInputOutput, kInputOnly; Colormap_tfColormapcolor map to be associated with window; Int_tfDepthdepth of window; Long_tfDoNotPropagateMaskset of events that should not propagate; Int_tfHeightwidth and height of window; Bool_tfMapInstalledboolean, is color map currently installed; Int_tfMapStatekIsUnmapped, kIsUnviewable, kIsViewable; Bool_tfOverrideRedirectboolean value for override-redirect; Window_tfRootroot of screen containing window; Bool_tfSaveUnderboolean, should bits under be saved?; void*fScreenback pointer to correct screen; void*fVisualthe associated visual structure; Int_tfWidth; Int_tfWinGravityone of the window gravity values; Int_tfX; Int_tfYlocation of window; Long_tfYourEventMaskmy event mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Last changed: Tue Sep 8 17:05:59 2015 » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/WindowAttributes_t.html:1566,mask,mask,1566,root/html534/WindowAttributes_t.html,https://root.cern,https://root.cern/root/html534/WindowAttributes_t.html,1,['mask'],['mask']
Availability,". XMLNodePointer_t AllocateNode(int namelen, XMLNodePointer_t parent); Allocates new xml node with specified namelength. XMLAttrPointer_t AllocateAttr(int namelen, int valuelen, XMLNodePointer_t xmlnode); Allocate new attribute with specified name length and value length. XMLNsPointer_t FindNs(XMLNodePointer_t xmlnode, const char* nsname); define if namespace of that name exists for xmlnode. void TruncateNsExtension(XMLNodePointer_t xmlnode); removes namespace extension of nodename. void UnpackSpecialCharacters(char* target, const char* source, int srclen); unpack special symbols, used in xml syntax to code characters; these symbols: '<' - &lt, '>' - &gt, '&' - &amp, '""' - &quot. void OutputValue(char* value, TXMLOutputStream* out); output value to output stream; if symbols '<' '&' '>' '""' appears in the string, they; will be encoded to appropriate xml symbols: &lt, &amp, &gt, &quot. void SaveNode(XMLNodePointer_t xmlnode, TXMLOutputStream* out, Int_t layout, Int_t level); stream data of xmlnode to output. XMLNodePointer_t ReadNode(XMLNodePointer_t xmlparent, TXMLInputStream* inp, Int_t& resvalue); Tries to construct xml node from input stream. Node should be; child of xmlparent node or it can be closing tag of xmlparent.; resvalue <= 0 if error; resvalue == 1 if this is endnode of parent; resvalue == 2 if this is child. void DisplayError(Int_t error, Int_t linenumber); Displays xml parsing error. TXMLEngine(). void SetSkipComments(bool on = kTRUE); { fSkipComments = on; }. Bool_t GetSkipComments() const; { return fSkipComments; }. Bool_t ValidateDocument(XMLDocPointer_t , Bool_t = kFALSE); { return kFALSE; }. » Author: Sergey Linev 10.05.2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/xml:$Id: TXMLEngine.h 38266 2011-03-01 18:46:08Z rdm $ » Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXMLEngine.html:17612,error,error,17612,root/html530/TXMLEngine.html,https://root.cern,https://root.cern/root/html530/TXMLEngine.html,3,['error'],['error']
Availability,". XMLNodePointer_t AllocateNode(int namelen, XMLNodePointer_t parent); Allocates new xml node with specified namelength. XMLAttrPointer_t AllocateAttr(int namelen, int valuelen, XMLNodePointer_t xmlnode); Allocate new attribute with specified name length and value length. XMLNsPointer_t FindNs(XMLNodePointer_t xmlnode, const char* nsname); define if namespace of that name exists for xmlnode. void TruncateNsExtension(XMLNodePointer_t xmlnode); removes namespace extension of nodename. void UnpackSpecialCharacters(char* target, const char* source, int srclen); unpack special symbols, used in xml syntax to code characters; these symbols: '<' - &lt, '>' - &gt, '&' - &amp, '""' - &quot. void OutputValue(char* value, TXMLOutputStream* out); output value to output stream; if symbols '<' '&' '>' '""' appears in the string, they; will be encoded to appropriate xml symbols: &lt, &amp, &gt, &quot. void SaveNode(XMLNodePointer_t xmlnode, TXMLOutputStream* out, Int_t layout, Int_t level); stream data of xmlnode to output. XMLNodePointer_t ReadNode(XMLNodePointer_t xmlparent, TXMLInputStream* inp, Int_t& resvalue); Tries to construct xml node from input stream. Node should be; child of xmlparent node or it can be closing tag of xmlparent.; resvalue <= 0 if error; resvalue == 1 if this is endnode of parent; resvalue == 2 if this is child. void DisplayError(Int_t error, Int_t linenumber); Displays xml parsing error. TXMLEngine(). void SetSkipComments(bool on = kTRUE); { fSkipComments = on; }. Bool_t GetSkipComments() const; { return fSkipComments; }. Bool_t ValidateDocument(XMLDocPointer_t , Bool_t = kFALSE); { return kFALSE; }. » Author: Sergey Linev 10.05.2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/xml:$Id: TXMLEngine.h 38266 2011-03-01 18:46:08Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXMLEngine.html:17612,error,error,17612,root/html532/TXMLEngine.html,https://root.cern,https://root.cern/root/html532/TXMLEngine.html,3,['error'],['error']
Availability,". bool ; verbose = false, . bool ; autoBinned = true, . const char * ; binnedTag = """", . bool ; expectedData = false, . bool ; extended = false . ); const. Generate a new dataset containing the specified variables with events sampled from our distribution. ; Parameters. [in]whatVarsGenerate a dataset with the variables (and categories) in this set. Any variables of this PDF that are not in whatVars will use their current values and be treated as fixed parameters. ; [in]nEventsGenerate the specified number of events or else try to use expectedEvents() if nEvents <= 0 (default). ; [in]verboseShow which generator strategies are being used. ; [in]autoBinnedIf original distribution is binned, return bin centers and randomise weights instead of generating single events. ; [in]binnedTag; [in]expectedDataCall setExpectedData on the genContext. ; [in]extendedRandomise number of events generated according to Poisson(nEvents). Only useful if PDF is extended. . ReturnsNew dataset. Returns zero in case of an error. The caller takes ownership of the returned dataset. ; Definition at line 1385 of file RooAbsPdf.cxx. ◆ generate() [4/6]. RooFit::OwningPtr< RooDataSet > RooAbsPdf::generate ; (; const RooArgSet & ; whatVars, . Int_t ; nEvents, . const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {} . ). inline . See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&) ; Parameters. [in]whatVarsSet of observables to generate for each event according to this model. ; [in]nEventsHow many events to generate ; arg1,arg2,arg3,arg4,arg5Optional command arguments. . Definition at line 57 of file RooAbsPdf.h. ◆ generate() [5/6]. RooFit::OwningPtr< RooDataSet > RooAbsPdf::generate ; (; RooAbsPdf::GenSpec & ; spec); const. Generate according to GenSpec obtained from prepareMultiGen(). ; If many identical gene",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:119183,error,error,119183,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['error'],['error']
Availability,". char * TSystem::GetServiceByPort ; (; int ; port). virtual . Get name of internet service. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 2327 of file TSystem.cxx. ◆ GetSockName(). TInetAddress TSystem::GetSockName ; (; int ; sock). virtual . Get Internet Protocol (IP) address of host and port #. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 2309 of file TSystem.cxx. ◆ GetSockOpt(). int TSystem::GetSockOpt ; (; int ; sock, . int ; kind, . int * ; val . ). virtual . Get socket option. ; Reimplemented in TWinNTSystem, and TUnixSystem.; Definition at line 2445 of file TSystem.cxx. ◆ GetSoExt(). const char * TSystem::GetSoExt ; (; ); const. virtual . Get the shared library extension. ; Definition at line 4013 of file TSystem.cxx. ◆ GetSysInfo(). int TSystem::GetSysInfo ; (; SysInfo_t * ; info); const. virtual . Returns static system info, like OS type, CPU type, number of CPUs RAM size, etc into the SysInfo_t structure. ; Returns -1 in case of error, 0 otherwise. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 2458 of file TSystem.cxx. ◆ GetUid(). Int_t TSystem::GetUid ; (; const char * ; user = nullptr). virtual . Returns the user's id. If user = 0, returns current user's id. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1562 of file TSystem.cxx. ◆ GetUserInfo() [1/2]. UserGroup_t * TSystem::GetUserInfo ; (; const char * ; user = nullptr). virtual . Returns all user info in the UserGroup_t structure. ; If user = 0, returns current user's id info. The returned structure must be deleted by the user. In case of error 0 is returned. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1612 of file TSystem.cxx. ◆ GetUserInfo() [2/2]. UserGroup_t * TSystem::GetUserInfo ; (; Int_t ; uid). virtual . Returns all user info in the UserGroup_t structure. ; The returned structure must be deleted by the user. In case of error 0 is returned. ; Reimplemented in TUnixSystem, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:67760,error,error,67760,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['error'],['error']
Availability,". class TGSlider: public TGFrame, public TGWidget. TGSlider, TGVSlider and TGHSlider. Slider widgets allow easy selection of a range.; Sliders can be either horizontal or vertical oriented and there is; a choice of two different slider types and three different types; of tick marks. TGSlider is an abstract base class. Use the concrete TGVSlider and; TGHSlider. Dragging the slider will generate the event:; kC_VSLIDER, kSL_POS, slider id, position (for vertical slider); kC_HSLIDER, kSL_POS, slider id, position (for horizontal slider). Pressing the mouse will generate the event:; kC_VSLIDER, kSL_PRESS, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_PRESS, slider id, 0 (for horizontal slider). Releasing the mouse will generate the event:; kC_VSLIDER, kSL_RELEASE, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_RELEASE, slider id, 0 (for horizontal slider). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGSlider(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); virtual voidChangeSliderPic(const char* name); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGSlider.html:1257,avail,available,1257,root/html528/TGSlider.html,https://root.cern,https://root.cern/root/html528/TGSlider.html,6,['avail'],['available']
Availability,". class TParallelCoord: public TNamed. Parallel Coordinates class. The multidimensional system of Parallel coordinates is a common way of studying high-dimensional geometry and visualizing multivariate problems. It has first been proposed by A. Inselberg in 1981. To show a set of points in an n-dimensional space, a backdrop is drawn consisting of n parallel lines. A point in n-dimensional space is represented as a polyline with vertices on the parallel axes; the position of the vertex on the i-th axis corresponds to the i-th coordinate of the point. This tool comes with a rather large gui in the editor. It is necessary to use this editor in order to explore a data set, as explained below.; Reduce cluttering:. The main issue for parallel coordinates is the very high cluttering of the output when dealing with large data set. Two techniques have been implemented to bypass that so far:. Draw doted lines instead of plain lines with an adjustable dots spacing. A slider to adjust the dots spacing is available in the editor.; Sort the entries to display with a ""weight cut"". On each axis is drawn a histogram describing the distribution of the data on the corresponding variable. The ""weight"" of an entry is the sum of the bin content of each bin the entry is going through. An entry going through the histograms peaks will have a big weight wether an entry going randomly through the histograms will have a rather small weight. Setting a cut on this weight allows to draw only the most representative entries. A slider set the cut is also available in the gui. Selections:. Selections of specific entries can be defined over the data se using parallel coordinates. With that representation, a selection is an ensemble of ranges defined on the axes. Ranges defined on the same axis are conjugated with OR (an entry must be in one or the other ranges to be selected). Ranges on different axes are are conjugated with AND (an entry must be in all the ranges to be selected). Several selections ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TParallelCoord.html:1277,avail,available,1277,root/html530/TParallelCoord.html,https://root.cern,https://root.cern/root/html530/TParallelCoord.html,5,['avail'],['available']
Availability,". const char * ; title, . Int_t ; nbins, . const Double_t * ; xbins . ). protected . Constructor for variable bin size histograms using an input array of type double. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsnumber of bins ; [in]xbinsarray of low-edges for each bin. This is an array of type double and size nbins+1 . Definition at line 741 of file TH1.cxx. ◆ ~TH1(). TH1::~TH1 ; (; ). override . Histogram default destructor. ; Definition at line 643 of file TH1.cxx. Member Function Documentation. ◆ Add() [1/3]. Bool_t TH1::Add ; (; const TH1 * ; h1, . const TH1 * ; h2, . Double_t ; c1 = 1, . Double_t ; c2 = 1 . ). virtual . Replace contents of this histogram by the addition of h1 and h2. ; this = c1*h1 + c2*h2 if errors are defined (see TH1::Sumw2), errors are also recalculated; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this if not already set.; Note also that adding histogram with labels is not supported, histogram will be added merging them by bin number independently of the labels. For adding histogram ith labels one should use TH1::Merge; SPECIAL CASE (Average/Efficiency histograms) For histograms representing averages or efficiencies, one should compute the average of the two histograms and not the sum. One can mark a histogram to be an average histogram by setting its bit kIsAverage with myhist.SetBit(TH1::kIsAverage); Note that the two histograms must have their kIsAverage bit set; IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Add; IMPORTANT NOTE2: You should be careful about the statistics of the returned histogram, whose statistics may be binned or unbinned, depending on whether c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:74356,error,errors,74356,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,2,['error'],['errors']
Availability,. const std::string & ROOT::Math::MinimizerOptions::DefaultMinimizerAlgo ; (; ). static . Definition at line 85 of file MinimizerOptions.cxx. ◆ DefaultMinimizerType(). const std::string & ROOT::Math::MinimizerOptions::DefaultMinimizerType ; (; ). static . Definition at line 100 of file MinimizerOptions.cxx. ◆ DefaultPrecision(). double ROOT::Math::MinimizerOptions::DefaultPrecision ; (; ). static . Definition at line 93 of file MinimizerOptions.cxx. ◆ DefaultPrintLevel(). int ROOT::Math::MinimizerOptions::DefaultPrintLevel ; (; ). static . Definition at line 97 of file MinimizerOptions.cxx. ◆ DefaultStrategy(). int ROOT::Math::MinimizerOptions::DefaultStrategy ; (; ). static . Definition at line 96 of file MinimizerOptions.cxx. ◆ DefaultTolerance(). double ROOT::Math::MinimizerOptions::DefaultTolerance ; (; ). static . Definition at line 92 of file MinimizerOptions.cxx. ◆ ErrorDef(). double ROOT::Math::MinimizerOptions::ErrorDef ; (; ); const. inline . error definition ; Definition at line 192 of file MinimizerOptions.h. ◆ ExtraOptions(). const IOptions * ROOT::Math::MinimizerOptions::ExtraOptions ; (; ); const. inline . return extra options (NULL pointer if they are not present) ; Definition at line 195 of file MinimizerOptions.h. ◆ FindDefault(). IOptions * ROOT::Math::MinimizerOptions::FindDefault ; (; const char * ; name). static . Find an extra options and return a nullptr if it is not existing. ; Same as above but it will not create a new one ; Definition at line 239 of file MinimizerOptions.cxx. ◆ MaxFunctionCalls(). unsigned int ROOT::Math::MinimizerOptions::MaxFunctionCalls ; (; ); const. inline . max number of function calls ; Definition at line 177 of file MinimizerOptions.h. ◆ MaxIterations(). unsigned int ROOT::Math::MinimizerOptions::MaxIterations ; (; ); const. inline . max iterations ; Definition at line 180 of file MinimizerOptions.h. ◆ MinimizerAlgorithm(). const std::string & ROOT::Math::MinimizerOptions::MinimizerAlgorithm ; (; ); const. inline .,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimizerOptions.html:7534,error,error,7534,doc/master/classROOT_1_1Math_1_1MinimizerOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimizerOptions.html,1,['error'],['error']
Availability,". const std::string & ; variationName . ). private . Return the RVariationsWithReaders object that handles the specified variation of the specified column, or null. ; Definition at line 166 of file RDFColumnRegister.cxx. ◆ GenerateColumnNames(). std::vector< std::string_view > ROOT::Internal::RDF::RColumnRegister::GenerateColumnNames ; (; ); const. Return the list of the names of the defined columns (Defines + Aliases). ; Definition at line 310 of file RDFColumnRegister.cxx. ◆ GetDefine(). RDFDetail::RDefineBase * ROOT::Internal::RDF::RColumnRegister::GetDefine ; (; std::string_view ; colName); const. Return the RDefine for the requested column name, or nullptr. ; Definition at line 51 of file RDFColumnRegister.cxx. ◆ GetReader(). RDFDetail::RColumnReaderBase * ROOT::Internal::RDF::RColumnRegister::GetReader ; (; unsigned int ; slot, . const std::string & ; colName, . const std::string & ; variationName, . const std::type_info & ; requestedType . ). Return a RDefineReader or a RVariationReader, or nullptr if not available. ; If requestedType does not match the actual type of the Define or Variation, an exception is thrown. ; Definition at line 258 of file RDFColumnRegister.cxx. ◆ GetReaderUnchecked(). RDFDetail::RColumnReaderBase * ROOT::Internal::RDF::RColumnRegister::GetReaderUnchecked ; (; unsigned int ; slot, . const std::string & ; colName, . const std::string & ; variationName . ). Return a RDefineReader or a RVariationReader, or nullptr if not available. ; No type checking is done on the requested reader. ; Definition at line 287 of file RDFColumnRegister.cxx. ◆ GetVariationDeps() [1/2]. std::vector< std::string > ROOT::Internal::RDF::RColumnRegister::GetVariationDeps ; (; const std::string & ; column); const. Get the names of all variations that directly or indirectly affect a given column. ; This list includes variations applied to the column as well as variations applied to other columns on which the value of this column depends (typically via a Define expr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html:8809,avail,available,8809,doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html,1,['avail'],['available']
Availability,". double GlobalCC(unsigned int ivar) const. return global correlation coefficient for variable i; This is a number between zero and one which gives; the correlation between the i-th parameter and that linear combination of all; other parameters which is most strongly correlated with i.; Minimizer must overload method if implemented. bool GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0). minos error for variable i, return false if Minos failed or not supported; and the lower and upper errors are returned in errLow and errUp; An extra flag specifies if only the lower (option=-1) or the upper (option=+1) error calculation is run; (This feature is not yet implemented). bool Hesse(). perform a full calculation of the Hessian matrix for error calculation. bool Scan(unsigned int ivar, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj). find the contour points (xi, xj) of the function for parameter ivar and jvar around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names); return an empty string if variable is not found. int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fOptions.PrintLevel(); }. un",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__Minimizer.html:10986,error,error,10986,root/html534/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__Minimizer.html,3,['error'],['error']
Availability,". double MinValue() const; return minimum function value. const double * X() const; return pointer to X values at the minimum. double Edm() const; return expected distance reached from the minimum (re-implement if minimizer provides it. { return -1; }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return NULL; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NIterations() const; number of iterations to reach the minimum. { return NCalls(); }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total; (re-implement if minimizer supports bounded parameters). { return NDim(); }. bool ProvidesError() const; minimizer provides error and error matrix. { return false; }. const double * Errors() const; return errors at the minimum. { return NULL; }. double CovMatrix(unsigned int ivar, unsigned int jvar) const; return covariance matrices element for variables ivar,jvar; if the variable is fixed the return value is zero; The ordering of the variables is the same as in the parameter and errors vectors. bool GetCovMatrix(double* covMat) const. Fill the passed array with the covariance matrix elements; if the variable is fixed or const the value is zero.; The array will be filled as cov[i *ndim + j]; The ordering of the variables is the same as in errors and parameter value.; This is different from the direct interface of Minuit2 or TMinuit where the; values were obtained only to variable parameters. bool GetHessianMatrix(double* hMat) const. Fill the passed array with the Hessian matrix elements; The Hessian matrix is the matrix of the second derivatives; and is the inverse of the covariance matrix; If the variable is fixed or const the values for that variables are zero.; The array wil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__Minimizer.html:8544,error,errors,8544,root/html534/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__Minimizer.html,3,['error'],['errors']
Availability,". double RooAbsReal::PlotOpt::addToWgtOther = 1.0. Definition at line 483 of file RooAbsReal.h. ◆ addToWgtSelf. double RooAbsReal::PlotOpt::addToWgtSelf = 1.0. Definition at line 482 of file RooAbsReal.h. ◆ binProjData. bool RooAbsReal::PlotOpt::binProjData = false. Definition at line 468 of file RooAbsReal.h. ◆ curveInvisible. bool RooAbsReal::PlotOpt::curveInvisible = false. Definition at line 479 of file RooAbsReal.h. ◆ curveName. const char* RooAbsReal::PlotOpt::curveName = nullptr. Definition at line 480 of file RooAbsReal.h. ◆ curveNameSuffix. const char* RooAbsReal::PlotOpt::curveNameSuffix = """". Definition at line 486 of file RooAbsReal.h. ◆ doeeval. bool RooAbsReal::PlotOpt::doeeval = false. Definition at line 489 of file RooAbsReal.h. ◆ drawOptions. Option_t* RooAbsReal::PlotOpt::drawOptions = ""L"". Definition at line 464 of file RooAbsReal.h. ◆ eeval. double RooAbsReal::PlotOpt::eeval = 0.0. Definition at line 488 of file RooAbsReal.h. ◆ errorFR. const RooFitResult* RooAbsReal::PlotOpt::errorFR = nullptr. Definition at line 491 of file RooAbsReal.h. ◆ interleave. RooFit::MPSplit RooAbsReal::PlotOpt::interleave = RooFit::Interleave. Definition at line 485 of file RooAbsReal.h. ◆ normRangeName. const char* RooAbsReal::PlotOpt::normRangeName = nullptr. Definition at line 473 of file RooAbsReal.h. ◆ numCPU. Int_t RooAbsReal::PlotOpt::numCPU = 1. Definition at line 484 of file RooAbsReal.h. ◆ numee. Int_t RooAbsReal::PlotOpt::numee = 10. Definition at line 487 of file RooAbsReal.h. ◆ postRangeFracScale. bool RooAbsReal::PlotOpt::postRangeFracScale = false. Definition at line 476 of file RooAbsReal.h. ◆ precision. double RooAbsReal::PlotOpt::precision = 1e-3. Definition at line 470 of file RooAbsReal.h. ◆ progress. bool RooAbsReal::PlotOpt::progress = false. Definition at line 490 of file RooAbsReal.h. ◆ projData. const RooAbsData* RooAbsReal::PlotOpt::projData = nullptr. Definition at line 467 of file RooAbsReal.h. ◆ projDataSet. const RooArgSet* RooAbsReal::Pl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structRooAbsReal_1_1PlotOpt.html:2448,error,errorFR,2448,doc/master/structRooAbsReal_1_1PlotOpt.html,https://root.cern,https://root.cern/doc/master/structRooAbsReal_1_1PlotOpt.html,1,['error'],['errorFR']
Availability,". double ; xErrorFrac = 1.0, . double ; scaleFactor = 1.0 . ). Add a bin to this histogram with the specified integer bin contents and using an error bar calculated with Poisson statistics. ; The bin width is used to set the relative scale of bins with different widths. ; Definition at line 426 of file RooHist.cxx. ◆ addBinWithError(). void RooHist::addBinWithError ; (; Axis_t ; binCenter, . double ; n, . double ; elow, . double ; ehigh, . double ; binWidth = 0, . double ; xErrorFrac = 1.0, . bool ; correctForBinWidth = true, . double ; scaleFactor = 1.0 . ). Add a bin to this histogram with the specified bin contents and error. ; The bin width is used to set the relative scale of bins with different widths. ; Definition at line 477 of file RooHist.cxx. ◆ addBinWithXYError(). void RooHist::addBinWithXYError ; (; Axis_t ; binCenter, . double ; n, . double ; exlow, . double ; exhigh, . double ; eylow, . double ; eyhigh, . double ; scaleFactor = 1.0 . ). Add a bin to this histogram with the specified bin contents and error. ; The bin width is used to set the relative scale of bins with different widths. ; Definition at line 498 of file RooHist.cxx. ◆ addEfficiencyBin(). void RooHist::addEfficiencyBin ; (; Axis_t ; binCenter, . Int_t ; n1, . Int_t ; n2, . double ; binWidth = 0, . double ; xErrorFrac = 1.0, . double ; scaleFactor = 1.0 . ). Add a bin to this histogram with the value n1/(n1+n2) using an error bar calculated with Binomial statistics. ; Definition at line 557 of file RooHist.cxx. ◆ addEfficiencyBinWithError(). void RooHist::addEfficiencyBinWithError ; (; Axis_t ; binCenter, . double ; n1, . double ; n2, . double ; en1, . double ; en2, . double ; binWidth = 0, . double ; xErrorFrac = 1.0, . double ; scaleFactor = 1.0 . ). Add a bin to this histogram with the value n1/(n1+n2) using an error bar calculated with Binomial statistics. ; Definition at line 579 of file RooHist.cxx. ◆ addPoint(). void RooHist::addPoint ; (; Axis_t ; binCenter, . double ; y, . double ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHist.html:49416,error,error,49416,doc/master/classRooHist.html,https://root.cern,https://root.cern/doc/master/classRooHist.html,1,['error'],['error']
Availability,". enum ECloneMethod { kDefault; kSortBasketsByBranch; kSortBasketsByOffset; kSortBasketsByEntry; };; enum EClonerOptions { kNone; kNoWarnings; };. private:. UInt_t*fBasketBranchNum[fMaxBaskets] Index of the branch(es) of the basket.; Long64_t*fBasketEntry[fMaxBaskets] list of basket start entries.; UInt_t*fBasketIndex[fMaxBaskets] ordered list of basket indices to be written.; UInt_t*fBasketNum[fMaxBaskets] index of the basket within the branch.; Long64_t*fBasketSeek[fMaxBaskets] list of basket position to be read.; UInt_tfCloneMethodIndicates which cloning method was selected.; TObjArrayfFromBranches; TTree*fFromTree; Bool_tfIsValid; UInt_tfMaxBaskets; Option_t*fMethod; Bool_tfNeedConversionTrue if the fast merge is not possible but a slow merge might possible.; UInt_tfOptions; UShort_tfPidOffsetOffset to be added to the copied key/basket.; TObjArrayfToBranches; Long64_tfToStartEntriesNumber of entries in the target tree before any addition.; TTree*fToTree; TStringfWarningMsgText of the error message lead to an 'invalid' state. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCloner(TTree* from, TTree* to, Option_t* method, UInt_t options = kNone). virtual ~TTreeCloner(). void CloseOutWriteBaskets(). UInt_t CollectBranches(TBranch* from, TBranch* to). UInt_t CollectBranches(TObjArray* from, TObjArray* to). UInt_t CollectBranches(). void CollectBaskets(). void CopyMemoryBaskets(). void CopyStreamerInfos(). void CopyProcessIds(). const char * GetWarning() const; { return fWarningMsg; }. Bool_t Exec(). Bool_t IsValid(); { return fIsValid; }. Bool_t NeedConversion(); { return fNeedConversion; }. void SortBaskets(). void WriteBaskets(). » Author: Philippe Canal 07/11/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TTreeCloner.h 29413 2009-07-09 14:10:29Z pcanal $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regard",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCloner.html:2038,error,error,2038,root/html528/TTreeCloner.html,https://root.cern,https://root.cern/root/html528/TTreeCloner.html,1,['error'],['error']
Availability,". enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPyROOTApplication(const char* acn, Int_t* argc, char** argv, Bool_t bLoadLibs = kTRUE); Create a TApplication derived for use with interactive ROOT from python. A; set of standard, often used libs is loaded if bLoadLibs is true (default). Bool_t CreatePyROOTApplication(Bool_t bLoadLibs = kTRUE); Create a TPyROOTApplication. Returns false if gApplication is not null. Bool_t InitROOTGlobals(); Setup the basic ROOT globals gBenchmark, gStyle, gProgname, if not already; set. Always returns true. Bool_t InitCINTMessageCallback(); Install CINT message callback which will turn CINT error message into; python exceptions. Always returns true. Bool_t InitROOTMessageCallback(); Install ROOT message handler which will turn ROOT error message into; python exceptions. Always returns true. virtual ~TPyROOTApplication(); { }. » Last changed: Thu Sep 23 19:55:51 2010 » Last generated: 2010-09-23 19:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/PyROOT__TPyROOTApplication.html:13624,error,error,13624,root/html528/PyROOT__TPyROOTApplication.html,https://root.cern,https://root.cern/root/html528/PyROOT__TPyROOTApplication.html,2,['error'],['error']
Availability,". enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPyROOTApplication(const char* acn, Int_t* argc, char** argv, Bool_t bLoadLibs = kTRUE); Create a TApplication derived for use with interactive ROOT from python. A; set of standard, often used libs is loaded if bLoadLibs is true (default). Bool_t CreatePyROOTApplication(Bool_t bLoadLibs = kTRUE); Create a TPyROOTApplication. Returns false if gApplication is not null. Bool_t InitROOTGlobals(); Setup the basic ROOT globals gBenchmark, gStyle, gProgname, if not already; set. Always returns true. Bool_t InitCINTMessageCallback(); Install CINT message callback which will turn CINT error message into; python exceptions. Always returns true. Bool_t InitROOTMessageCallback(); Install ROOT message handler which will turn ROOT error message into; python exceptions. Always returns true. virtual ~TPyROOTApplication(); { }. » Last changed: Tue Mar 17 20:53:08 2015 » Last generated: 2015-03-17 20:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/PyROOT__TPyROOTApplication.html:13794,error,error,13794,root/html534/PyROOT__TPyROOTApplication.html,https://root.cern,https://root.cern/root/html534/PyROOT__TPyROOTApplication.html,2,['error'],['error']
Availability,. enum TSelectorDraw::[unnamed] { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortAbort status; Int_tTSelectorDraw::fAction! Action type; Bool_tTSelectorDraw::fCleanElisttrue if original Tree elist must be saved; TEvePointSelectorConsumer*fConsumer; Long64_tTSelectorDraw::fCurrentSubEntryCurrent subentry when fSelectMultiple is true. Used to fill TEntryListArray; Int_tTSelectorDraw::fDimensionDimension of the current expression; Long64_tTSelectorDraw::fDraw! Last entry loop number when object was drawn; Int_tTSelectorDraw::fForceReadForce Read flag; TListfInput; TList*TSelector::fInputList of objects available during processing; TTreeFormulaManager*TSelectorDraw::fManagerPointer to the formula manager; Int_tTSelectorDraw::fMultiplicityIndicator of the variability of the size of entries; Int_t*TSelectorDraw::fNbins![fDimension] Number of bins per dimension; Int_tTSelectorDraw::fNfill! Total number of histogram fills; Bool_tTSelectorDraw::fObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObject!Current object if processing object (vs. TTree); Long64_tTSelectorDraw::fOldEstimatevalue of Tree fEstimate when selector is called; TH1*TSelectorDraw::fOldHistogram! Pointer to previously used histogram; TStringTSelector::fOptionOption given to TTree::Process; TSelectorList*TSelector::fOutput!List of objects created during processing; TTreeFormula*TSelectorDraw::fSelectPointer to selection formula; Bool_tTSelectorDraw::fSelectMultipletrue if selection has a variable index; Long64_tTSelectorDraw::fSelectedRowsNumber of selected entries; TStringfSelection; Long64_tTSelector::fStatusSelector status; TStringfSubIdExp; Int_tfSubIdN,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEvePointSelector.html:9310,avail,available,9310,root/html534/TEvePointSelector.html,https://root.cern,https://root.cern/root/html534/TEvePointSelector.html,1,['avail'],['available']
Availability,. enum TSelectorDraw::[unnamed] { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tTSelectorDraw::fAction! Action type; Bool_tTSelectorDraw::fCleanElisttrue if original Tree elist must be saved; TEvePointSelectorConsumer*fConsumer; Long64_tTSelectorDraw::fCurrentSubEntryCurrent subentry when fSelectMultiple is true. Used to fill TEntryListArray; Int_tTSelectorDraw::fDimensionDimension of the current expression; Long64_tTSelectorDraw::fDraw! Last entry loop number when object was drawn; Int_tTSelectorDraw::fForceReadForce Read flag; TListfInput; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*TSelectorDraw::fManagerPointer to the formula manager; Int_tTSelectorDraw::fMultiplicityIndicator of the variability of the size of entries; Int_t*TSelectorDraw::fNbins![fDimension] Number of bins per dimension; Int_tTSelectorDraw::fNfill! Total number of histogram fills; Bool_tTSelectorDraw::fObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); Long64_tTSelectorDraw::fOldEstimatevalue of Tree fEstimate when selector is called; TH1*TSelectorDraw::fOldHistogram! Pointer to previously used histogram; TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TTreeFormula*TSelectorDraw::fSelectPointer to selection formula; Bool_tTSelectorDraw::fSelectMultipletrue if selection has a variable index; Long64_tTSelectorDraw::fSelectedRowsNumber of selected entries; TStringfSelection; Long64_tTSelector::fStatusselector status; TStringfSubIdExp; Int_tfSubIdNum,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEvePointSelector.html:9244,avail,available,9244,root/html532/TEvePointSelector.html,https://root.cern,https://root.cern/root/html532/TEvePointSelector.html,1,['avail'],['available']
Availability,". gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(000111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters; kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the paint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:16062,error,error,16062,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,24,['error'],['error']
Availability,". gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the paint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPaveStats.html:2016,error,error,2016,root/html534/TPaveStats.html,https://root.cern,https://root.cern/root/html534/TPaveStats.html,12,['error'],['error']
Availability,". if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the taget axes will be; kept, but only bins inside the selected range will be filled. Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProjectionX("" "",firstybin,lastybin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProjectionX("" "",firstybin,lastybin,""[-cutg]"");; It is possible to apply several cuts:; myhist->ProjectionX("" "",firstybin,lastybin,[cutg1,cutg2]"");. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. NOTE that the X axis attributes of the TH2 are copied to the X axis of the projection. TH1D * ProjectionY(const char* name = ""_py"", Int_t firstxbin = 0, Int_t lastxbin = -1, Option_t* option = """") const; Project a 2-D histogram into a 1-D histogram along Y*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the channels along the X axis; ranging from firstxbin to lastxbin included.; By default, all bins including under- and overflow are included.; The number of entries in the projection is estimated from the; number of effective entries for all the cells included in the projection. To exclude the underflow bins in X, use firstxbin=1;; to exclude the underflow bins in X, use lastxbin=nx. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the taget a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH2.html:48586,error,error,48586,root/html528/TH2.html,https://root.cern,https://root.cern/root/html528/TH2.html,3,['error'],['error']
Availability,". if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the taget axes will be; kept, but only bins inside the selected range will be filled. Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProjectionY("" "",firstxbin,lastxbin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProjectionY("" "",firstxbin,lastxbin,""[-cutg]"");; It is possible to apply several cuts:; myhist->ProjectionY("" "",firstxbin,lastxbin,[cutg1,cutg2]"");. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. NOTE that the Y axis attributes of the TH2 are copied to the X axis of the projection. void PutStats(Double_t* stats); Replace current statistics with the values in array stats. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetShowProjectionX(Int_t nbins); When the mouse is moved in a pad containing a 2-d view of this histogram; a second canvas shows the projection along X corresponding to the; mouse position along Y.; To stop the generation of the projections, delete the canvas; containing the projection. void SetShowProjectionY(Int_t nbins); When the mouse is moved in a pad containing a 2-d view of this histogram; a second canvas shows the projection along Y corresponding to the; mouse position along X.; To stop the generation of the projections, delete the canvas; containing the projection. TH1 * ShowBackground(Int_t niter = 20, Option_t* option = ""sa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH2.html:50410,error,error,50410,root/html528/TH2.html,https://root.cern,https://root.cern/root/html528/TH2.html,3,['error'],['error']
Availability,". inline . Definition at line 81 of file TMapFile.h. ◆ operator new() [2/2]. void * TMapFile::operator new ; (; size_t ; sz, . void * ; vp . ). inline . Definition at line 83 of file TMapFile.h. ◆ operator new[]() [1/2]. void * TMapFile::operator new[] ; (; size_t ; sz). inline . Definition at line 82 of file TMapFile.h. ◆ operator new[]() [2/2]. void * TMapFile::operator new[] ; (; size_t ; sz, . void * ; vp . ). inline . Definition at line 84 of file TMapFile.h. ◆ operator=(). TMapFile & TMapFile::operator= ; (; const TMapFile & ; rhs). protecteddelete . ◆ OrgAddress(). void * TMapFile::OrgAddress ; (; void * ; addr); const. inline . Definition at line 102 of file TMapFile.h. ◆ Print(). void TMapFile::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print some info about the mapped file. ; Reimplemented from TObject.; Definition at line 1040 of file TMapFile.cxx. ◆ ReleaseSemaphore(). Int_t TMapFile::ReleaseSemaphore ; (; ). protected . Release semaphore. Returns 0 if OK, -1 on error. ; Definition at line 947 of file TMapFile.cxx. ◆ Remove() [1/4]. TObject * TMapFile::Remove ; (; const char * ; name). inline . Definition at line 110 of file TMapFile.h. ◆ Remove() [2/4]. TObject * TMapFile::Remove ; (; const char * ; name, . Bool_t ; lock . ). protected . Remove object by name from shared memory. ; Returns pointer to removed object if successful, 0 otherwise. ; Definition at line 738 of file TMapFile.cxx. ◆ Remove() [3/4]. TObject * TMapFile::Remove ; (; TObject * ; obj). inline . Definition at line 109 of file TMapFile.h. ◆ Remove() [4/4]. TObject * TMapFile::Remove ; (; TObject * ; obj, . Bool_t ; lock . ). protected . Remove object from shared memory. ; Returns pointer to removed object if successful, 0 otherwise. ; Definition at line 699 of file TMapFile.cxx. ◆ RemoveAll(). void TMapFile::RemoveAll ; (; ). Remove all objects from shared memory. ; Definition at line 775 of file TMapFile.cxx. ◆ SetMapAddress(). void TMapFile::SetMapAddress ; (; Long",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMapFile.html:27293,error,error,27293,doc/master/classTMapFile.html,https://root.cern,https://root.cern/doc/master/classTMapFile.html,1,['error'],['error']
Availability,". inline . Get B histo mean. ; Definition at line 59 of file HybridPlot.h. ◆ GetBrms(). double RooStats::HybridPlot::GetBrms ; (; ). inline . Get B histo RMS. ; Definition at line 62 of file HybridPlot.h. ◆ GetCanvas(). TVirtualPad * RooStats::HybridPlot::GetCanvas ; (; ). inline . Get the pad (or canvas) where it has been drawn. ; Definition at line 95 of file HybridPlot.h. ◆ GetHistoCenter(). double HybridPlot::GetHistoCenter ; (; TH1 * ; histo_orig, . double ; n_rms = 1, . bool ; display_result = false . ). Get the center of the histo. ; Perform 2 times a gaussian fit to fetch the center of the histo.; To get the second fit range get an interval that tries to keep into account the skewness of the distribution. ; Definition at line 238 of file HybridPlot.cxx. ◆ GetHistoPvals(). double * HybridPlot::GetHistoPvals ; (; TH1 * ; histo, . double ; percentage . ). Get the ""effective sigmas"" of the histo, call delete [] res to release memory. ; We let an horizontal bar go down and we stop when we have the integral equal to the desired one. ; Definition at line 301 of file HybridPlot.cxx. ◆ GetMedian(). double HybridPlot::GetMedian ; (; TH1 * ; histo). Get the median of an histogram. ; Definition at line 353 of file HybridPlot.cxx. ◆ GetSBCenter(). double RooStats::HybridPlot::GetSBCenter ; (; double ; n_sigmas = 1, . bool ; display = false . ). inline . Get SB histo center. ; Definition at line 80 of file HybridPlot.h. ◆ GetSBhisto(). TH1F * RooStats::HybridPlot::GetSBhisto ; (; ). inline . Get B histo. ; Definition at line 92 of file HybridPlot.h. ◆ GetSBIntExtremes(). double * RooStats::HybridPlot::GetSBIntExtremes ; (; double ; frac). inline . Get SB histo integration extremes to obtain the requested area fraction call delete [] res to release memory. ; Definition at line 88 of file HybridPlot.h. ◆ GetSBmean(). double RooStats::HybridPlot::GetSBmean ; (; ). inline . Get SB histo mean. ; Definition at line 77 of file HybridPlot.h. ◆ GetSBrms(). double RooStats::HybridPl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HybridPlot.html:16835,down,down,16835,doc/master/classRooStats_1_1HybridPlot.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HybridPlot.html,1,['down'],['down']
Availability,". master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; GCValues_t Struct Reference. ; Graphics context structure. ; Definition at line 224 of file GuiTypes.h. Public Member Functions;  GCValues_t ();  . Public Attributes; Int_t fArcMode;  kArcChord, kArcPieSlice ;  ; ULong_t fBackground;  background pixel ;  ; Int_t fCapStyle;  kCapNotLast, kCapButt, kCapRound, kCapProjecting ;  ; Pixmap_t fClipMask;  bitmap clipping; other calls for rects ;  ; Int_t fClipXOrigin;  origin for clipping ;  ; Int_t fClipYOrigin;  ; Char_t fDashes [8];  dash pattern list (dash length per byte) ;  ; Int_t fDashLen;  number of dashes in fDashes ;  ; Int_t fDashOffset;  patterned/dashed line information ;  ; Int_t fFillRule;  kEvenOddRule, kWindingRule ;  ; Int_t fFillStyle;  kFillSolid, kFillTiled, kFillStippled, kFillOpaeueStippled ;  ; FontH_t fFont;  default text font for text operations ;  ; ULong_t fForeground;  foreground pixel ;  ; EGraphicsFunction fFunction;  logical operation ;  ; Bool_t fGraphicsExposures;  boolean, should exposures be generated ;  ; Int_t fJoinStyle;  kJoinMiter, kJoinRound, kJoinBevel ;  ; Int_t fLineStyle;  kLineSolid, kLineOnOffDash, kLineDoubleDash ;  ; Int_t fLineWidth;  line width ;  ; Mask_t fMask;  bit mask specifying which fields are valid ;  ; ULong_t fPlaneMask;  plane mask ;  ; Pixmap_t fStipple;  stipple 1 plane pixmap for stippling ;  ; Int_t fSubwindowMode;  kClipByChildren, kIncludeInferiors ;  ; Pixmap_t fTile;  tile pixmap for tiling operations ;  ; Int_t fTsXOrigin;  offset for tile or stipple operations ;  ; Int_t fTsYOrigin;  . #include <GuiTypes.h>; Constructor & Destructor Documentation. ◆ GCValues_t(). GCValues_t::GCValues_t ; (; ). inline . Definition at line 253 of file GuiTypes.h. Member Data Documentation. ◆ fArcMode. Int_t GCValues_t::fArcMode. kArcChord, kArcPieSlice ; Definition at line 237 of file GuiTypes.h. ◆ fBackgroun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structGCValues__t.html:1392,mask,mask,1392,doc/master/structGCValues__t.html,https://root.cern,https://root.cern/doc/master/structGCValues__t.html,2,['mask'],['mask']
Availability,". master. Reference Guide ; .  . Loading...; Searching...; No Matches. exec1.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Echo object at mouse position. ; Example of macro called when a pad is redrawn one must create a TExec object in the following way gPad->AddExec(""ex1"", "".x exec1.C"");; gPad#define gPadDefinition TVirtualPad.h:308; this macro prints the bin number and the bin content when one clicks on the histogram contour of any histogram in a pad; ; ; void exec1(); {; if (!gPad) {; Error(""exec1"", ""gPad is null, you are not supposed to run this macro"");; return;; }; ; Int_t event = gPad->GetEvent();; int px = gPad->GetEventX();; TObject *select = gPad->GetSelected();; ; if (select && select->InheritsFrom(TH1::Class())) {; TH1 *h = (TH1*)select;; Float_t xx = gPad->AbsPixeltoX(px);; Float_t x = gPad->PadtoX(xx);; Int_t binx = h->GetXaxis()->FindBin(x);; printf(""event=%d, hist:%s, bin=%d, content=%f\n"", event, h->GetName(), binx, h->GetBinContent(binx));; }; }; ; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TAxis::FindBinvirtual Int_t FindBin(Double_t x)Find bin number corresponding to abscissa x.Definition TAxis.cxx:293; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::Classstatic TClass * Class(); TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; xDouble_t x[n]Definition legend1.C:17; AuthorsRene Brun, Sergey Linev ; Definition in file exec1.C. tutorialshistexec1.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/exec1_8C.html:1285,error,error,1285,doc/master/exec1_8C.html,https://root.cern,https://root.cern/doc/master/exec1_8C.html,1,['error'],['error']
Availability,". non-static methods for retrieving options ; absolute tolerance ; Definition at line 61 of file IntegratorOptions.h. ◆ ClearExtra(). void ROOT::Math::BaseIntegratorOptions::ClearExtra ; (; ). protected . Definition at line 161 of file IntegratorOptions.cxx. ◆ ExtraOptions(). IOptions * ROOT::Math::BaseIntegratorOptions::ExtraOptions ; (; ); const. inline . return extra options ; Definition at line 71 of file IntegratorOptions.h. ◆ Integrator(). virtual std::string ROOT::Math::BaseIntegratorOptions::Integrator ; (; ); const. pure virtual . name of 1D integrator ; Implemented in ROOT::Math::IntegratorOneDimOptions, and ROOT::Math::IntegratorMultiDimOptions. ◆ operator=(). BaseIntegratorOptions & ROOT::Math::BaseIntegratorOptions::operator= ; (; const BaseIntegratorOptions & ; opt). assignment operators ; Definition at line 137 of file IntegratorOptions.cxx. ◆ RelTolerance(). double ROOT::Math::BaseIntegratorOptions::RelTolerance ; (; ); const. inline . absolute tolerance ; Definition at line 64 of file IntegratorOptions.h. ◆ SetAbsTolerance(). void ROOT::Math::BaseIntegratorOptions::SetAbsTolerance ; (; double ; tol). inline . non-static methods for setting options ; set the abs tolerance ; Definition at line 77 of file IntegratorOptions.h. ◆ SetExtraOptions(). void ROOT::Math::BaseIntegratorOptions::SetExtraOptions ; (; const IOptions & ; opt). set extra options (in this case pointer is cloned) ; Definition at line 167 of file IntegratorOptions.cxx. ◆ SetRelTolerance(). void ROOT::Math::BaseIntegratorOptions::SetRelTolerance ; (; double ; tol). inline . set the relative tolerance ; Definition at line 80 of file IntegratorOptions.h. ◆ SetWKSize(). void ROOT::Math::BaseIntegratorOptions::SetWKSize ; (; unsigned int ; size). inline . set workspace size ; Definition at line 83 of file IntegratorOptions.h. ◆ WKSize(). unsigned int ROOT::Math::BaseIntegratorOptions::WKSize ; (; ); const. inline . size of the workspace ; Definition at line 67 of file IntegratorOptions.h. M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html:4016,toler,tolerance,4016,doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html,1,['toler'],['tolerance']
Availability,". of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag . Definition at line 1353 of file TGeoManager.cxx. ◆ operator=(). TGeoManager & TGeoManager::operator= ; (; const TGeoManager & ; ). protecteddelete . ◆ OptimizeVoxels(). void TGeoManager::OptimizeVoxels ; (; const char * ; filename = ""tgeovox.C""). Optimize voxelization type for all volumes. Save best choice in a macro. ; Definition at line 2484 of file TGeoManager.cxx. ◆ Parse(). Int_t TGeoManager::Parse ; (; const char * ; expr, . TString & ; expr1, . TString & ; expr2, . TString & ; expr3 . ). static . Parse a string boolean expression and do a syntax check. ; Find top level boolean operator and returns its type. Fill the two substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expression; 2 : difference (subtraction) - represented as '-' in expression; 3 : intersection - represented as '*' in expression. Parentheses should be used to avoid ambiguities. For instance :; A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C) eliminate not needed parentheses . Definition at line 2540 of file TGeoManager.cxx. ◆ PopDummy(). void TGeoManager::PopDummy ; (; Int_t ; ipop = 9999). inline . Definition at line 597 of file TGeoManager.h. ◆ PopPath() [1/2]. Bool_t TGeoManager::PopPath ; (; ). inline . Definition at line 592 of file TGeoManager.h. ◆ PopPath() [2/2]. Bool_t TGeoManager::PopPath ; (; Int_t ; index). inline . Definition at line 593 of file TGeoManager.h. ◆ PopPoint() [1/2]. Bool_t TGeoManager::PopPoint ; (; ). inline . Definition at line 595 of file TGeoManager.h. ◆ PopPoint() [2/2]. Bool_t TGeoManager::PopPoint ; (; Int_t ; index). inline . Definition at line 596 of file TGeoManager.h. ◆ PrintOverlaps(). void TGeoManager::PrintOverlaps ; (; ); const. Prin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:127017,error,error,127017,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['error'],['error']
Availability,. p-value for the alternate hypothesis (small number means disfavoured) ; Definition at line 129 of file HypoTestResult.h. ◆ fAlternatePValueError. double RooStats::HypoTestResult::fAlternatePValueError. mutableprotected . error of p-value for the alternate hypothesis (small number means disfavoured) ; Definition at line 131 of file HypoTestResult.h. ◆ fBackgroundIsAlt. bool RooStats::HypoTestResult::fBackgroundIsAlt. protected . Definition at line 140 of file HypoTestResult.h. ◆ fFitInfo. std::unique_ptr<RooDataSet> RooStats::HypoTestResult::fFitInfo. protected . Definition at line 138 of file HypoTestResult.h. ◆ fNullDetailedOutput. std::unique_ptr<RooDataSet> RooStats::HypoTestResult::fNullDetailedOutput. protected . Definition at line 136 of file HypoTestResult.h. ◆ fNullDistr. std::unique_ptr<SamplingDistribution> RooStats::HypoTestResult::fNullDistr. protected . Definition at line 134 of file HypoTestResult.h. ◆ fNullPValue. double RooStats::HypoTestResult::fNullPValue. mutableprotected . p-value for the null hypothesis (small number means disfavoured) ; Definition at line 128 of file HypoTestResult.h. ◆ fNullPValueError. double RooStats::HypoTestResult::fNullPValueError. mutableprotected . error of p-value for the null hypothesis (small number means disfavoured) ; Definition at line 130 of file HypoTestResult.h. ◆ fPValueIsRightTail. bool RooStats::HypoTestResult::fPValueIsRightTail. protected . Definition at line 139 of file HypoTestResult.h. ◆ fTestStatisticData. double RooStats::HypoTestResult::fTestStatisticData. protected . result of the test statistic evaluated on data ; Definition at line 132 of file HypoTestResult.h. Libraries for RooStats::HypoTestResult:. [legend]; The documentation for this class was generated from the following files:; roofit/roostats/inc/RooStats/HypoTestResult.h; roofit/roostats/src/HypoTestResult.cxx. RooStatsHypoTestResult. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:54 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HypoTestResult.html:28400,error,error,28400,doc/master/classRooStats_1_1HypoTestResult.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HypoTestResult.html,1,['error'],['error']
Availability,". private . Default canvas top Y position. ; Definition at line 91 of file TStyle.h. ◆ fCanvasPreferGL. Bool_t TStyle::fCanvasPreferGL. private . If true, rendering in canvas is with GL. ; Definition at line 84 of file TStyle.h. ◆ fCapLinePS. Int_t TStyle::fCapLinePS. private . Determines the appearance of line caps on PostScript, PDF and SVG. ; Definition at line 137 of file TStyle.h. ◆ fColorModelPS. Int_t TStyle::fColorModelPS. private . PostScript color model: 0 = RGB, 1 = CMYK. ; Definition at line 37 of file TStyle.h. ◆ fDateX. Float_t TStyle::fDateX. private . X position of the date in the canvas (in NDC) ; Definition at line 53 of file TStyle.h. ◆ fDateY. Float_t TStyle::fDateY. private . Y position of the date in the canvas (in NDC) ; Definition at line 54 of file TStyle.h. ◆ fDrawBorder. Int_t TStyle::fDrawBorder. private . Flag to draw border(=1) or not (0) ; Definition at line 38 of file TStyle.h. ◆ fEndErrorSize. Float_t TStyle::fEndErrorSize. private . Size of lines at the end of error bars. ; Definition at line 55 of file TStyle.h. ◆ fErrorX. Float_t TStyle::fErrorX. private . Per cent of bin width for errors along X. ; Definition at line 56 of file TStyle.h. ◆ fFitFormat. TString TStyle::fFitFormat. private . Printing format for fit parameters. ; Definition at line 133 of file TStyle.h. ◆ fFrameBorderMode. Int_t TStyle::fFrameBorderMode. private . Pad frame border mode. ; Definition at line 76 of file TStyle.h. ◆ fFrameBorderSize. Width_t TStyle::fFrameBorderSize. private . Pad frame border size. ; Definition at line 75 of file TStyle.h. ◆ fFrameFillColor. Color_t TStyle::fFrameFillColor. private . Pad frame fill color. ; Definition at line 70 of file TStyle.h. ◆ fFrameFillStyle. Style_t TStyle::fFrameFillStyle. private . Pad frame fill style. ; Definition at line 72 of file TStyle.h. ◆ fFrameLineColor. Color_t TStyle::fFrameLineColor. private . Pad frame line color. ; Definition at line 71 of file TStyle.h. ◆ fFrameLineStyle. Style_t TStyle::fFrameL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStyle.html:97612,error,error,97612,doc/master/classTStyle.html,https://root.cern,https://root.cern/doc/master/classTStyle.html,1,['error'],['error']
Availability,". private:. voidInitTreePruningMetaData(TMVA::DecisionTreeNode* n); TMVA::MsgLogger&Log() const; voidOptimize(TMVA::DecisionTree* dt, Double_t weights). Data Members; private:. TMVA::MsgLogger*fLogger! output stream to save logging information; Int_tfOptimalK! the optimal index of the prune sequence; vector<TMVA::DecisionTreeNode*,allocator<TMVA::DecisionTreeNode*> >fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Double_t>fPruneStrengthList! map of alpha -> pruning index; vector<Double_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::SeparationBase*fQualityIndexTool! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CostComplexityPruneTool( SeparationBase* qualityIndex ); the constructor for the cost complexity prunig. ~CostComplexityPruneTool(); the destructor for the cost complexity prunig. CalculatePruningInfo(TMVA::DecisionTree* dt, const vector<TMVA::Event*,allocator<TMVA::Event*> >* testEvents = NULL, Bool_t isAutomatic = kFALSE). void InitTreePruningMetaData(TMVA::DecisionTreeNode* n); initialise ""meta data"" for the pruning, like the ""costcomplexity"", the; critical alpha, the minimal alpha down the tree, etc... for each node!!. void Optimize(TMVA::DecisionTree* dt, Double_t weights); after the critical alpha values (at which the corresponding nodes would; be pruned away) had been established in the ""InitMetaData"" we need now:; automatic pruning:; find the value of ""alpha"" for which the test sample gives minimal error,; on the tree with all nodes pruned that have alpha_critital < alpha,; fixed parameter pruning. CostComplexityPruneTool( SeparationBase* qualityIndex = NULL ). » Last changed: Fri Nov 26 14:26:56 2010 » Last generated: 2010-11-26 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__CostComplexityPruneTool.html:2134,down,down,2134,root/html528/TMVA__CostComplexityPruneTool.html,https://root.cern,https://root.cern/root/html528/TMVA__CostComplexityPruneTool.html,2,"['down', 'error']","['down', 'error']"
Availability,". protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications; static Long64_tTProofServ::fgLastEntryLast entry before exception; static TStringTProofServ::fgLastMsgMessage about status before exception. private:. TProofServLiteInterruptHandler*fInterruptHandler; TStringfSockPathunix socket path; Bool_tfTerminatedtrue if Terminate() has been already called. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofServLite(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TProofServLite(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. void Terminate(Int_t status); Terminate the proof server. void HandleFork(TMessage* mess); Cloning itself via fork. Int_t SetupOnFork(const char* ord); Finalize the server setup afetr forking.; Return 0 on success, -1 on error. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-03-14 16:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServLite.html:17846,error,error,17846,root/html534/TProofServLite.html,https://root.cern,https://root.cern/root/html534/TProofServLite.html,5,"['alive', 'error']","['alive', 'error']"
Availability,". read table configurations as special table ; Definition at line 1054 of file TSQLFile.cxx. ◆ ReadFree(). void TSQLFile::ReadFree ; (; ). inlinefinalvirtual . Read the FREE linked list. ; Every file has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented from TFile.; Definition at line 239 of file TSQLFile.h. ◆ ReadSpecialObject(). TObject * TSQLFile::ReadSpecialObject ; (; Long64_t ; keyid, . TObject * ; obj = nullptr . ). protected . Read data of special kind of objects. ; Definition at line 851 of file TSQLFile.cxx. ◆ ReadSQLClassInfos(). void TSQLFile::ReadSQLClassInfos ; (; ). protected . Read all class infos from IdsTable. ; Definition at line 1911 of file TSQLFile.cxx. ◆ Recover(). Int_t TSQLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is importa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:84582,recover,recovered,84582,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['recover'],['recovered']
Availability,". virtual void TH1::SetBinErrorOption ; (; EBinErrorOpt ; type). inlinevirtual . Definition at line 381 of file TH1.h. ◆ SetBins() [1/6]. void TH1::SetBins ; (; Int_t ; nx, . const Double_t * ; xBins . ). virtual . Redefine x axis parameters with variable bin sizes. ; The X axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange xBins is supposed to be of length nx+1 ; Reimplemented in TProfile, TProfile2D, and TProfile3D.; Definition at line 8794 of file TH1.cxx. ◆ SetBins() [2/6]. void TH1::SetBins ; (; Int_t ; nx, . const Double_t * ; xBins, . Int_t ; ny, . const Double_t * ; yBins . ). virtual . Redefine x and y axis parameters with variable bin sizes. ; The X and Y axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1 ; Reimplemented in TProfile2D, TProfile, and TProfile3D.; Definition at line 8848 of file TH1.cxx. ◆ SetBins() [3/6]. void TH1::SetBins ; (; Int_t ; nx, . const Double_t * ; xBins, . Int_t ; ny, . const Double_t * ; yBins, . Int_t ; nz, . const Double_t * ; zBins . ). virtual . Redefine x, y and z axis parameters with variable bin sizes. ; The X, Y and Z axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1, zBins is supposed to be of length nz+1 ; Reimplemented in TProfile3D, TProfile, and TProfile2D.; Definition at line 8905 of file TH1.cxx. ◆ SetBins() [4/6]. void TH1::SetBins ; (; Int_t ; nx, . Double_t ; xmin, . Double_t ; xmax . ). virtual . Redefine x axis parameters.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:205741,error,errors,205741,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,2,['error'],['errors']
Availability,". void BuildOld(); rebuild the TStreamerInfo structure. void Clear(Option_t* ); If opt cointains 'built', reset this StreamerInfo as if Build or BuildOld; was never called on it (usefull to force their re-running). void CallShowMembers(const void* obj, TMemberInspector& insp, Bool_t isTransient) const; Emulated a call ShowMembers() on the obj of this class type, passing insp and parent. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; If newname is specified, this will be the name of the new object. Bool_t CompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete, TFile* file); Return True if the current StreamerInfo in cl or info is equivalent to this TStreamerInfo.; 'Equivalent' means the same number of persistent data member which the same actual C++ type and; the same name.; if 'warn' is true, Warning message are printed to explicit the differences.; if 'complete' is false, stop at the first error, otherwise continue until all members have been checked. void ComputeSize(); Compute total size of all persistent elements of the class. void ForceWriteInfo(TFile* file, Bool_t force = kFALSE); -- Recursively mark streamer infos for writing to a file. Will force this TStreamerInfo to the file and also; all the dependencies. If argument force > 0 the loop on class dependencies is forced. This function is called when streaming a class that contains; a null pointer. In this case, the TStreamerInfo for the class; with the null pointer must be written to the file and also all; the TStreamerInfo of all the classes referenced by the class. --; We must be given a file to write to. TClass * GetActualClass(const void* obj) const; Assuming that obj points to (the part of) an object that is of the; type described by this streamerInfo, return the actual type of the; object (i.e. the type described by this streamerInfo is a base class; of the actual type of the object.; This routine should only be call",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStreamerInfo.html:23635,error,error,23635,root/html602/TStreamerInfo.html,https://root.cern,https://root.cern/root/html602/TStreamerInfo.html,2,['error'],['error']
Availability,". void DoBinOffset(); Slot connected to the OffSetNumberEntry which is related to the; OffSetSlider changes the origin of the histogram inbetween a binwidth. void DoApply(); Slot connected to the Apply button of the Binning tab. void DoCancel(); Slot connected to the Cancel button of the Binning tab. TString GetHistTypeLabel(); Returns the selected histogram type (HIST, LEGO1-2, SURF1-5). TString GetHistCoordsLabel(); Return the selected coordinate system of the histogram (POL,CYL,SPH,PSR). TString GetHistErrorLabel(); Return the selected error type (E,E1-5). TString GetHistAddLabel(); Return the selected shape of the histogram (C, L, LF2). TGComboBox* BuildHistTypeComboBox(TGFrame* parent, Int_t id); Create histogram type combo box. TGComboBox* BuildHistCoordsComboBox(TGFrame* parent, Int_t id); Create coordinate system type combo box. TGComboBox* BuildHistErrorComboBox(TGFrame* parent, Int_t id); Create error type combo box. TGComboBox* BuildHistAddComboBox(TGFrame* parent, Int_t id); Create Line/Bar combo box. TGComboBox* BuildPercentComboBox(TGFrame* parent, Int_t id); Create Percentage combo box for bar option. void ChangeErrorCombo(Int_t i); Change the error combo box entry. void PaintBox3D(Float_t* p1, Float_t* p2, Float_t* p3, Float_t* p4); Paint a 3D box. Int_t* Dividers(Int_t n); Return an array of dividers of n (without the trivial divider n).; The number of dividers is saved in the first entry. void RecursiveRemove(TObject* obj); If the contained histogram obj is deleted we must set its pointer to zero. TH1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: Carsten Hof 16/08/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-06-02 16:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TH1Editor.html:33367,error,error,33367,root/html604/TH1Editor.html,https://root.cern,https://root.cern/root/html604/TH1Editor.html,1,['error'],['error']
Availability,". void DoBinOffset(); Slot connected to the OffSetNumberEntry which is related to the; OffSetSlider changes the origin of the histogram inbetween a binwidth. void DoApply(); Slot connected to the Apply button of the Binning tab. void DoCancel(); Slot connected to the Cancel button of the Binning tab. TString GetHistTypeLabel(); Returns the selected histogram type (HIST, LEGO1-2, SURF1-5). TString GetHistCoordsLabel(); Return the selected coordinate system of the histogram (POL,CYL,SPH,PSR). TString GetHistErrorLabel(); Return the selected error type (E,E1-5). TString GetHistAddLabel(); Return the selected shape of the histogram (C, L, LF2). TGComboBox* BuildHistTypeComboBox(TGFrame* parent, Int_t id); Create histogram type combo box. TGComboBox* BuildHistCoordsComboBox(TGFrame* parent, Int_t id); Create coordinate system type combo box. TGComboBox* BuildHistErrorComboBox(TGFrame* parent, Int_t id); Create error type combo box. TGComboBox* BuildHistAddComboBox(TGFrame* parent, Int_t id); Create Line/Bar combo box. TGComboBox* BuildPercentComboBox(TGFrame* parent, Int_t id); Create Percentage combo box for bar option. void ChangeErrorCombo(Int_t i); Change the error combo box entry. void PaintBox3D(Float_t* p1, Float_t* p2, Float_t* p3, Float_t* p4); Paint a 3D box. Int_t* Dividers(Int_t n); Return an array of dividers of n (without the trivial divider n).; The number of dividers is saved in the first entry. void RecursiveRemove(TObject* obj); If the contained histogram obj is deleted we must set its pointer to zero. TH1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: Carsten Hof 16/08/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-06-30 15:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1Editor.html:33367,error,error,33367,root/html602/TH1Editor.html,https://root.cern,https://root.cern/root/html602/TH1Editor.html,1,['error'],['error']
Availability,". void Fill(Double_t data); Fills data member with User input data event for the unbinned option. Double_t operator()(const Double_t* x, const Double_t* p = 0) const; The class's unary function: returns the kernel density estimate. Double_t operator()(Double_t x) const; The class's unary function: returns the kernel density estimate. Double_t GetMean() const; return the mean of the data. Double_t GetSigma() const; return the standard deviation of the data. Double_t GetRAMISE() const; Returns the Root Asymptotic Mean Integrated Squared Error according to Silverman's rule of thumb with assumed Gaussian density. void SetBinCentreData(Double_t xmin, Double_t xmax); Returns the bins' centres from the data for using with the binned option. void SetBinCountData(); Returns the bins' count from the data for using with the binned option. void Draw(Option_t* option = """"); Draws either the KDE functions or its errors; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.95); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKDE.html:15213,error,errors,15213,root/html528/TKDE.html,https://root.cern,https://root.cern/root/html528/TKDE.html,8,['error'],['errors']
Availability,. void ROOT::Math::MinimizerOptions::SetDefaultPrintLevel ; (; int ; level). static . Set the default Print Level. ; Possible levels are from 0 (minimal printing) to 3 (maximum printing) ; Definition at line 75 of file MinimizerOptions.cxx. ◆ SetDefaultStrategy(). void ROOT::Math::MinimizerOptions::SetDefaultStrategy ; (; int ; strat). static . Set the default strategy. ; The strategy is a parameter used only by Minuit and Minuit2. Possible values are:; strat = 0 : rough approximation of Hessian using the gradient. Avoid computing the full Hessian matrix; strat = 1 (default and recommended one) - Use Hessian approximation but compute full Hessian at the end of minimization if needed.; strat = 2 Perform several full Hessian computations during the minimization. Slower and not always working better than strat=1. . Definition at line 71 of file MinimizerOptions.cxx. ◆ SetDefaultTolerance(). void ROOT::Math::MinimizerOptions::SetDefaultTolerance ; (; double ; tol). static . Set the Minimization tolerance. ; The Default value for Minuit and Minuit2 is 0.01 ; Definition at line 55 of file MinimizerOptions.cxx. ◆ SetErrorDef(). void ROOT::Math::MinimizerOptions::SetErrorDef ; (; double ; err). inline . set error def ; Definition at line 228 of file MinimizerOptions.h. ◆ SetExtraOptions(). void ROOT::Math::MinimizerOptions::SetExtraOptions ; (; const IOptions & ; opt). set extra options (in this case pointer is cloned) ; Definition at line 210 of file MinimizerOptions.cxx. ◆ SetMaxFunctionCalls(). void ROOT::Math::MinimizerOptions::SetMaxFunctionCalls ; (; unsigned int ; maxfcn). inline . set maximum of function calls ; Definition at line 213 of file MinimizerOptions.h. ◆ SetMaxIterations(). void ROOT::Math::MinimizerOptions::SetMaxIterations ; (; unsigned int ; maxiter). inline . set maximum iterations (one iteration can have many function calls) ; Definition at line 216 of file MinimizerOptions.h. ◆ SetMinimizerAlgorithm(). void ROOT::Math::MinimizerOptions::SetMinimizerA,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimizerOptions.html:15163,toler,tolerance,15163,doc/master/classROOT_1_1Math_1_1MinimizerOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimizerOptions.html,1,['toler'],['tolerance']
Availability,". void Run(Bool_t retrn = kFALSE); Main server eventloop. void SendLogFile(Int_t status = 0, Int_t start = -1, Int_t end = -1); Send log file to master.; If start > -1 send only bytes in the range from start to end,; if end <= start send everything from start. void SendStatistics(); Send statistics of slave server to master or client. void SendParallel(Bool_t async = kFALSE); Send number of parallel nodes to master or client. Int_t UnloadPackage(const char* package); Removes link to package in working directory,; removes entry from include path,; removes entry from enabled package list,; does not currently remove entry from interpreter include path.; Returns -1 in case of error, 0 otherwise. Int_t UnloadPackages(); Unloads all enabled packages. Returns -1 in case of error, 0 otherwise. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on failure. Int_t SetupCommon(); Common part (between TProofServ and TXProofServ) of the setup phase.; Return 0 on success, -1 on error. void Terminate(Int_t status); Terminate the proof server. Bool_t UnlinkDataDir(const char* path); Scan recursively the datadir and unlink it if empty; Return kTRUE if it can be unlinked, kFALSE otherwise. Bool_t IsActive(); Static function that returns kTRUE in case we are a PROOF server. TProofServ * This(); Static function returning pointer to global object gProofServ.; Mainly for use via CINT, where the gProofServ symbol might be; deleted from the symbol table. Int_t OldAuthSetup(TString& wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TProofQueryResult * MakeQueryResult(Long64_t nentries, const char* opt, TList* inl, Long64_t first, TDSet* dset, const char* selec, TObject* elist); Create a TProofQueryResult instance for this query. void SetQueryRunning(TProofQueryResult* pq); Set query in running state. void HandleArchive(TMessage* mess, TString* slb = 0); Handle archive request. TMap * GetDataSetNodeMap(TFileColl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:25320,error,error,25320,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,3,['error'],['error']
Availability,". void Run(Bool_t retrn = kFALSE); Main server eventloop. void SendLogFile(Int_t status = 0, Int_t start = -1, Int_t end = -1); Send log file to master.; If start > -1 send only bytes in the range from start to end,; if end <= start send everything from start. void SendStatistics(); Send statistics of slave server to master or client. void SendParallel(Bool_t async = kFALSE); Send number of parallel nodes to master or client. Int_t UnloadPackage(const char* package); Removes link to package in working directory,; removes entry from include path,; removes entry from enabled package list,; does not currently remove entry from interpreter include path.; Returns -1 in case of error, 0 otherwise. Int_t UnloadPackages(); Unloads all enabled packages. Returns -1 in case of error, 0 otherwise. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on failure. Int_t SetupCommon(); Common part (between TProofServ and TXProofServ) of the setup phase.; Return 0 on success, -1 on error. void Terminate(Int_t status); Terminate the proof server. Bool_t UnlinkDataDir(const char* path); Scan recursively the datadir and unlink it if empty; Return kTRUE if it can be unlinked, kFALSE otherwise. Bool_t IsActive(); Static function that returns kTRUE in case we are a PROOF server. TProofServ * This(); Static function returning pointer to global object gProofServ.; Mainly for use via CINT, where the gProofServ symbol might be; deleted from the symbol table. Int_t OldAuthSetup(TString& wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TProofQueryResult * MakeQueryResult(Long64_t nentries, const char* opt, TList* inl, Long64_t first, TDSet* dset, const char* selec, TObject* elist); Create a TProofQueryResult instance for this query. void SetQueryRunning(TProofQueryResult* pq); Set query in running state. void HandleArchive(TMessage* mess, TString* slb = 0); Handle archive request. void HandleProcess(TMessage* mess,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:24363,error,error,24363,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,3,['error'],['error']
Availability,". void TFTP::chmod ; (; const char * ; file, . Int_t ; mode . ); const. inline . Definition at line 120 of file TFTP.h. ◆ Class(). static TClass * TFTP::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TFTP::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TFTP::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 125 of file TFTP.h. ◆ Close(). Int_t TFTP::Close ; (; ). Close ftp connection. ; Returns 0 in case of success and -1 in case of failure. ; Definition at line 884 of file TFTP.cxx. ◆ DeclFileName(). static const char * TFTP::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 125 of file TFTP.h. ◆ DeleteDirectory(). Int_t TFTP::DeleteDirectory ; (; const char * ; dir); const. Delete a remote directory. ; Anonymous users may not delete directories. Returns 0 in case of success and -1 in case of failure. ; Definition at line 702 of file TFTP.cxx. ◆ DeleteFile(). Int_t TFTP::DeleteFile ; (; const char * ; file); const. Delete a remote file. ; Anonymous users may not delete files. Returns 0 in case of success and -1 in case of failure. ; Definition at line 821 of file TFTP.cxx. ◆ FreeDirectory(). void TFTP::FreeDirectory ; (; Bool_t ; print = kFALSE). Free a remotely open directory via rootd. ; Definition at line 956 of file TFTP.cxx. ◆ get(). void TFTP::get ; (; const char * ; file, . const char * ; localName = nullptr . ). inline . Definition at line 112 of file TFTP.h. ◆ GetBlockSize(). Int_t TFTP::GetBlockSize ; (; ); const. inline . Definition at line 80 of file TFTP.h. ◆ GetDirEntry(). const char * TFTP::GetDirEntry ; (; Bool_t ; print = kFALSE). Get directory entry via rootd. ; Returns 0 in case no more entries or in case of error. ; Definition at line 988 of file TFTP.cxx. ◆ GetFile(). Long64_t TFTP::GetFile ; (; const char * ; file, . const char * ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFTP.html:17064,failure,failure,17064,doc/master/classTFTP.html,https://root.cern,https://root.cern/doc/master/classTFTP.html,1,['failure'],['failure']
Availability,". void TFileCollection::SetList ; (; THashList * ; list). inline . Definition at line 71 of file TFileCollection.h. ◆ Sort(). void TFileCollection::Sort ; (; Bool_t ; useindex = kFALSE). Sort the collection. ; Definition at line 688 of file TFileCollection.cxx. ◆ Streamer(). void TFileCollection::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TFileCollection::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 108 of file TFileCollection.h. ◆ Update(). Int_t TFileCollection::Update ; (; Long64_t ; avgsize = -1). Update accumulated information about the elements of the collection (e.g. ; fTotalSize). If 'avgsize' > 0, use an average file size of 'avgsize' bytes when the size info is not available. Also updates the meta data information by summarizing the meta data of the contained objects. Return -1 in case of any failure, 0 if the total size is exact, 1 if incomplete, 2 if complete but (at least partially) estimated. ; Definition at line 312 of file TFileCollection.cxx. Member Data Documentation. ◆ fDefaultTree. TString TFileCollection::fDefaultTree. private . Definition at line 45 of file TFileCollection.h. ◆ fList. THashList* TFileCollection::fList. private . Definition at line 42 of file TFileCollection.h. ◆ fMetaDataList. TList* TFileCollection::fMetaDataList. private . Definition at line 43 of file TFileCollection.h. ◆ fNCorruptFiles. Long64_t TFileCollection::fNCorruptFiles. private . Definition at line 50 of file TFileCollection.h. ◆ fNFiles. Long64_t TFileCollection::fNFiles. private . Definition at line 47 of file TFileCollection.h. ◆ fNStagedFiles. Long64_t TFileCollection::fNStagedFiles. private . Definition at line 49 of file TFileCollection.h. ◆ fTotalSize. Long64_t TFileCollection::fTotalSize. private . Definition at line 46 of file TFileCollection.h. Libraries for TFileCollection:. [legend]; The documentation for this ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCollection.html:25638,failure,failure,25638,doc/master/classTFileCollection.html,https://root.cern,https://root.cern/doc/master/classTFileCollection.html,1,['failure'],['failure']
Availability,. void TGScrollBarElement::SetEnabled ; (; Bool_t ; on = kTRUE). virtual . Enable/Disable scroll bar button chaging the state. ; Definition at line 149 of file TGScrollBar.cxx. ◆ SetState(). void TGScrollBarElement::SetState ; (; Int_t ; state). virtual . Change state of scrollbar element (either up or down). ; Definition at line 127 of file TGScrollBar.cxx. ◆ Streamer(). void TGScrollBarElement::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGFrame. ◆ StreamerNVirtual(). void TGScrollBarElement::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 57 of file TGScrollBar.h. Member Data Documentation. ◆ fBgndColor. Pixel_t TGScrollBarElement::fBgndColor. protected . background color ; Definition at line 40 of file TGScrollBar.h. ◆ fHighColor. Pixel_t TGScrollBarElement::fHighColor. protected . highlight color ; Definition at line 41 of file TGScrollBar.h. ◆ fPic. const TGPicture* TGScrollBarElement::fPic. protected . picture in scrollbar element ; Definition at line 37 of file TGScrollBar.h. ◆ fPicD. const TGPicture* TGScrollBarElement::fPicD. protected . picture for disabled state of scrollbar element ; Definition at line 39 of file TGScrollBar.h. ◆ fPicN. const TGPicture* TGScrollBarElement::fPicN. protected . picture for normal state of scrollbar element ; Definition at line 38 of file TGScrollBar.h. ◆ fState. Int_t TGScrollBarElement::fState. protected . state of scrollbar element (button up or down) ; Definition at line 36 of file TGScrollBar.h. ◆ fStyle. Int_t TGScrollBarElement::fStyle. protected . modern or classic style ; Definition at line 42 of file TGScrollBar.h. Libraries for TGScrollBarElement:. [legend]; The documentation for this class was generated from the following files:; gui/gui/inc/TGScrollBar.h; gui/gui/src/TGScrollBar.cxx. TGScrollBarElement. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:34 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGScrollBarElement.html:31670,down,down,31670,doc/master/classTGScrollBarElement.html,https://root.cern,https://root.cern/doc/master/classTGScrollBarElement.html,1,['down'],['down']
Availability,". void TMinuit::mnmatu ; (; Int_t ; kode). virtual . Prints the covariance matrix v when KODE=1. ; always prints the global correlations, and calculates and prints the individual correlation coefficients ; Definition at line 4968 of file TMinuit.cxx. ◆ mnmigr(). void TMinuit::mnmigr ; (; ). virtual . Performs a local function minimization. ; Performs a local function minimization using basically the method of Davidon-Fletcher-Powell as modified by Fletcher; ref. – Fletcher, Comp.J. 13,317 (1970) ""switching method"" ; Definition at line 5048 of file TMinuit.cxx. ◆ mnmnos(). void TMinuit::mnmnos ; (; ). virtual . Performs a MINOS error analysis. ; Performs a MINOS error analysis on those parameters for which it is requested on the MINOS command by calling MNMNOT for each parameter requested. ; Definition at line 5388 of file TMinuit.cxx. ◆ mnmnot(). void TMinuit::mnmnot ; (; Int_t ; ilax, . Int_t ; ilax2, . Double_t & ; val2pl, . Double_t & ; val2mi . ). virtual . Performs a MINOS error analysis on one parameter. ; The parameter ILAX is varied, and the minimum of the function with respect to the other parameters is followed until it crosses the value FMIN+UP. ; Definition at line 5463 of file TMinuit.cxx. ◆ mnparm(). void TMinuit::mnparm ; (; Int_t ; k1, . TString ; cnamj, . Double_t ; uk, . Double_t ; wk, . Double_t ; a, . Double_t ; b, . Int_t & ; ierflg . ). virtual . Implements one parameter definition. ; Called from MNPARS and user-callable Implements one parameter definition, that is:; K (external) parameter number; CNAMK parameter name; UK starting value; WK starting step size or uncertainty; A, B lower and upper physical parameter limits and sets up (updates) the parameter lists. Output:; IERFLG=0 if no problems; >0 if MNPARM unable to implement definition . Definition at line 5665 of file TMinuit.cxx. ◆ mnpars(). void TMinuit::mnpars ; (; TString & ; crdbuf, . Int_t & ; icondn . ). virtual . Implements one parameter definition. ; Called from MNREAD and user-ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:56889,error,error,56889,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['error'],['error']
Availability,". void TUnixSystem::Openlog ; (; const char * ; name, . Int_t ; options, . ELogFacility ; facility . ). overridevirtual . Open connection to system log daemon. ; For the use of the options and facility see the Unix openlog man page. ; Reimplemented from TSystem.; Definition at line 2616 of file TUnixSystem.cxx. ◆ OpenPipe(). FILE * TUnixSystem::OpenPipe ; (; const char * ; shellcmd, . const char * ; mode . ). overridevirtual . Open a pipe. ; Reimplemented from TSystem.; Definition at line 2163 of file TUnixSystem.cxx. ◆ PrependPathName(). const char * TUnixSystem::PrependPathName ; (; const char * ; dir, . TString & ; name . ). overridevirtual . Concatenate a directory and a file name. ; Reimplemented from TSystem.; Definition at line 1552 of file TUnixSystem.cxx. ◆ RecvBuf(). int TUnixSystem::RecvBuf ; (; int ; sock, . void * ; buf, . int ; length . ). overridevirtual . Receive a buffer headed by a length indicator. ; Length is the size of the buffer. Returns the number of bytes received in buf or -1 in case of error. ; Reimplemented from TSystem.; Definition at line 3316 of file TUnixSystem.cxx. ◆ RecvRaw(). int TUnixSystem::RecvRaw ; (; int ; sock, . void * ; buf, . int ; length, . int ; opt . ). overridevirtual . Receive exactly length bytes into buffer. ; Use opt to receive out-of-band data or to have a peek at what is in the buffer (see TSocket). Buffer must be able to store at least length bytes. Returns the number of bytes received (can be 0 if other side of connection was closed) or -1 in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3 in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Reimplemented from TSystem.; Definition at line 3368 of file TUnixSystem.cxx. ◆ RedirectOutput(). Int_t TUnixSystem::RedirectOutput ; (; const char * ; file, . const char * ; mode = ""a"", . RedirectHandle_t * ; h = nullptr . ). overridevirtual . Redire",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:61432,error,error,61432,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['error'],['error']
Availability,". we found what we are looking for ... }. const char * GetPathStatic() const; Returns the full path of the directory. E.g. file:/dir1/dir2.; The returned path will be re-used by the next call to GetPath(). const char * GetPath() const; Returns the full path of the directory. E.g. file:/dir1/dir2.; The returned path will be re-used by the next call to GetPath(). void FillFullPath(TString& buf) const; recursive method to fill full path for directory. TDirectory * mkdir(const char* name, const char* title = """"); Create a sub-directory and return a pointer to the created directory.; Returns 0 in case of error.; Returns 0 if a directory with the same name already exists.; Note that the directory name may be of the form ""a/b/c"" to create a hierarchy of directories.; In this case, the function returns the pointer to the ""a"" directory if the operation is successful. For example the step to the steps to create first a/b/c and then a/b/d without receiving; and errors are:; TFile * file = new TFile(""afile"",""RECREATE"");; file->mkdir(""a"");; file->cd(""a"");; gDirectory->mkdir(""b"");; gDirectory->cd(""b"");; gDirectory->mkdir(""d"");. void ls(Option_t* option = """") const; List Directory contents. Indentation is used to identify the directory tree; Subdirectories are listed first, then objects in memory. The option can has the following format:; [<regexp>]; The <regexp> will be used to match the name of the objects.; By default memory and disk objects are listed. void Paint(Option_t* option = """"); Paint all objects in the directory. void Print(Option_t* option = """") const; Print all objects in the directory. void pwd() const; Print the path of the directory. void RecursiveRemove(TObject* obj); Recursively remove object from a Directory. TObject * Remove(TObject* ); Remove an object from the in-memory list. void rmdir(const char* name); Removes subdirectory from the directory; When directory is deleted, all keys in all subdirectories will be; read first and deleted from file (if exists); E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDirectory.html:19123,error,errors,19123,root/html534/TDirectory.html,https://root.cern,https://root.cern/root/html534/TDirectory.html,3,['error'],['errors']
Availability,". where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative3(const ROOT::Math::IGenFunction& f, double x, double h). Third Derivative calculation passing function and step-size. void SetFunction(const ROOT::Math::IGenFunction& f); Set function for derivative calculation (copy the function if option has been enabled in the constructor). \@param f Function to be differentiated. void SetStepSize(double h); Set step size for derivative calculation. \@param h step size for calculation. { fStepSize = h; }. » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__RichardsonDerivator.html:6566,error,error,6566,root/html602/ROOT__Math__RichardsonDerivator.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__RichardsonDerivator.html,6,['error'],['error']
Availability,". where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative3(const ROOT::Math::IGenFunction& f, double x, double h). Third Derivative calculation passing function and step-size. void SetFunction(const ROOT::Math::IGenFunction& f); Set function for derivative calculation (copy the function if option has been enabled in the constructor). \@param f Function to be differentiated. void SetStepSize(double h); Set step size for derivative calculation. \@param h step size for calculation. { fStepSize = h; }. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__RichardsonDerivator.html:6566,error,error,6566,root/html534/ROOT__Math__RichardsonDerivator.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__RichardsonDerivator.html,6,['error'],['error']
Availability,". where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative3(const ROOT::Math::IGenFunction& f, double x, double h). Third Derivative calculation passing function and step-size. void SetFunction(const ROOT::Math::IGenFunction& f); Set function for derivative calculation (copy the function if option has been enabled in the constructor). \@param f Function to be differentiated. void SetStepSize(double h); Set step size for derivative calculation. \@param h step size for calculation. { fStepSize = h; }. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__RichardsonDerivator.html:6566,error,error,6566,root/html604/ROOT__Math__RichardsonDerivator.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__RichardsonDerivator.html,6,['error'],['error']
Availability,". with neg. and pos. weights in node and don't boost them; Bool_tfPruneBeforeBoostflag to prune before boosting; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; TStringfPruneMethodSprune method option String; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreeschoose a random subset of possible cut variables at each node during training; Bool_tfRenormByClassindividually re-normalize each event class to the original size after boosting; map<TMVA::Event*,std::vector<double> >fResidualsindividual event residuals for gradient boost; Double_tfSampleFractionfraction of events used for bagged grad boost; Double_tfSampleSizeFractionrelative size of bagged event sample to original sample size; TMVA::SeparationBase*fSepTypethe separation used in node splitting; TStringfSepTypeSthe separation (option string) used in node splitting; Double_tfShrinkagelearning rate for gradient boost;; vector<TMVA::Event*>fSubSamplesubsample for bagged grad boost; Double_tfSumOfWeightssum of all event weights; Bool_tfTrainWithNegWeightsyes there are negative event weights and we don't ignore them; Double_tfTransitionPointbreak-down point for gradient regression; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for node splitting; Bool_tfUseFisherCutsuse multivariate splits using the Fisher criterium; UInt_tfUseNTrainEventsnumber of randomly picked training events used in randomised (and bagged) trees; UInt_tfUseNvarsthe number of variables used in the randomised tree splitting; Bool_tfUsePoissonNvarsuse ""fUseNvars"" not as fixed number but as mean of a possion distr. in each split; Bool_tfUseWeightedTreesuse average classification from the trees, or have the individual trees trees in the forest weighted (e.g. log(boostweight) from AdaBoost; Bool_tfUseYesNoLeafuse sig or bkg classification in leave nodes or sig/bkg; vector<TMVA::Event*>fValidationSamplethe ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodBDT.html:24150,down,down,24150,root/html530/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodBDT.html,2,['down'],['down']
Availability,". ◆ ClearDataSetCache(). void TProofLite::ClearDataSetCache ; (; const char * ; dataset = 0). overridevirtual . Clear the content of the dataset cache, if any (matching 'dataset', if defined). ; Reimplemented from TProof.; Definition at line 2282 of file TProofLite.cxx. ◆ CopyMacroToCache(). Int_t TProofLite::CopyMacroToCache ; (; const char * ; macro, . Int_t ; headerRequired = 0, . TSelector ** ; selector = 0, . Int_t ; opt = 0, . TList * ; wrks = 0 . ). protected . Copy a macro, and its possible associated .h[h] file, to the cache directory, from where the workers can get the file. ; If headerRequired is 1, return -1 in case the header is not found. If headerRequired is 0, try to copy header too. If headerRequired is -1, don't look for header, only copy macro. If the selector pionter is not 0, consider the macro to be a selector and try to load the selector and set it to the pointer. The mask 'opt' is an or of ESendFileOpt: kCpBin (0x8) Retrieve from the cache the binaries associated with the file kCp (0x10) Retrieve the files from the cache Return -1 in case of error, 0 otherwise. ; Definition at line 1593 of file TProofLite.cxx. ◆ CreateSandbox(). Int_t TProofLite::CreateSandbox ; (; ). private . Create the sandbox for this session. ; Definition at line 880 of file TProofLite.cxx. ◆ DeclFileName(). static const char * TProofLite::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 170 of file TProofLite.h. ◆ DrawSelect(). Long64_t TProofLite::DrawSelect ; (; TDSet * ; dset, . const char * ; varexp, . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0 . ). overridevirtual . Execute the specified drawing action on a data set (TDSet). ; Event- or Entry-lists should be set in the data set object using TDSet::SetEntryList. Returns -1 in case of error or number of selected events otherwise. ; Reimplemented from TProof.; Definition at line 1053 of f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:49892,mask,mask,49892,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,2,"['error', 'mask']","['error', 'mask']"
Availability,". ◆ GetSearchJson(). std::string ROOT::RGeomDescription::GetSearchJson ; (; ); const. inline . Definition at line 384 of file RGeomData.hxx. ◆ GetTopVisible(). bool ROOT::RGeomDescription::GetTopVisible ; (; ); const. inline . Returns draw options, used for JSROOT TGeoPainter. ; Definition at line 334 of file RGeomData.hxx. ◆ GetUsedNSegments(). int RGeomDescription::GetUsedNSegments ; (; int ; min = 20). private . Returns really used number of cylindrical segments. ; Definition at line 922 of file RGeomData.cxx. ◆ GetVisLevel(). int ROOT::RGeomDescription::GetVisLevel ; (; ); const. inline . Returns maximal visible level. ; Definition at line 329 of file RGeomData.hxx. ◆ GetVolume(). TGeoVolume * RGeomDescription::GetVolume ; (; int ; nodeid). private . Get volume for specified nodeid If specific volume was configured, it will be returned for nodeid==0. ; Definition at line 583 of file RGeomData.cxx. ◆ HasDrawData(). bool RGeomDescription::HasDrawData ; (; ); const. Check if there is draw data available. ; Definition at line 1331 of file RGeomData.cxx. ◆ IsBuild(). bool ROOT::RGeomDescription::IsBuild ; (; ); const. inline . Definition at line 371 of file RGeomData.hxx. ◆ IsBuildShapes(). int ROOT::RGeomDescription::IsBuildShapes ; (; ); const. inline . Returns true if binary 3D model build already by C++ server (default) ; Definition at line 339 of file RGeomData.hxx. ◆ IsPhysNodeVisible(). int RGeomDescription::IsPhysNodeVisible ; (; const std::vector< int > & ; stack). private . Check if there special settings for specified physical node returns -1 if nothing is found. ; Definition at line 2043 of file RGeomData.cxx. ◆ IsPreferredOffline(). bool ROOT::RGeomDescription::IsPreferredOffline ; (; ); const. inline . Is offline operations preferred. ; After get full description, client can do most operations without extra requests ; Definition at line 361 of file RGeomData.hxx. ◆ IsPrincipalEndNode(). bool RGeomDescription::IsPrincipalEndNode ; (; int ; nodeid). return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html:17533,avail,available,17533,doc/v632/classROOT_1_1RGeomDescription.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html,1,['avail'],['available']
Availability,. ◆ GetTestInterval(). template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::GetTestInterval ; (; ); const. inline . Definition at line 150 of file DLMinimizers.h. ◆ GetTrainingError(). template<typename Architecture_t > . Scalar_t TMVA::DNN::TDLGradientDescent< Architecture_t >::GetTrainingError ; (; ); const. inline . Definition at line 148 of file DLMinimizers.h. ◆ HasConverged() [1/2]. template<typename Architecture_t > . bool TMVA::DNN::TDLGradientDescent< Architecture_t >::HasConverged. Increases the minimization step counter by the test error evaluation period and uses the current internal value of the test error to determine if the minimization has converged. ; Definition at line 276 of file DLMinimizers.h. ◆ HasConverged() [2/2]. template<typename Architecture_t > . bool TMVA::DNN::TDLGradientDescent< Architecture_t >::HasConverged ; (; Scalar_t ; testError). Increases the minimization step counter by the test error evaluation period and uses the provided test error value to determine if the minimization has converged. ; Definition at line 290 of file DLMinimizers.h. ◆ Reset(). template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::Reset ; (; ). inline . Reset minimizer object to default state. ; Definition at line 89 of file DLMinimizers.h. ◆ SetBatchSize(). template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::SetBatchSize ; (; Scalar_t ; rate). inline . Definition at line 156 of file DLMinimizers.h. ◆ SetConvergenceSteps(). template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::SetConvergenceSteps ; (; size_t ; steps). inline . Setters. ; Definition at line 153 of file DLMinimizers.h. ◆ SetLearningRate(). template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::SetLearningRate ; (; Scalar_t ; rate). inline . Definition at line 155 of file DLMinimizers.h. ◆ SetTestInterval(). t,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html:6578,error,error,6578,doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,2,['error'],['error']
Availability,". ◆ SetDisplay(). void TSystem::SetDisplay ; (; ). virtual . Set DISPLAY environment variable based on utmp entry. Only for UNIX. ; Reimplemented in TUnixSystem.; Definition at line 235 of file TSystem.cxx. ◆ SetDynamicPath(). void TSystem::SetDynamicPath ; (; const char * ; pathname). virtual . Set the dynamic path to a new value. ; If the value of 'path' is zero, the dynamic path is reset to its default value. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1806 of file TSystem.cxx. ◆ Setenv(). void TSystem::Setenv ; (; const char * ; name, . const char * ; value . ). virtual . Set environment variable. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1649 of file TSystem.cxx. ◆ SetErrorStr(). void TSystem::SetErrorStr ; (; const char * ; errstr). Set the system error string. ; This string will be used by GetError(). To be used in case one does not want or can use the system error string (e.g. because error is generated by a third party POSIX like library that does not use standard errno). ; Definition at line 245 of file TSystem.cxx. ◆ SetFlagsDebug(). void TSystem::SetFlagsDebug ; (; const char * ; flags). virtual . FlagsDebug should contain the options to pass to the C++ compiler in order to compile the library in debug mode. ; Definition at line 4056 of file TSystem.cxx. ◆ SetFlagsOpt(). void TSystem::SetFlagsOpt ; (; const char * ; flags). virtual . FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in optimized mode. ; Definition at line 4065 of file TSystem.cxx. ◆ SetFPEMask(). Int_t TSystem::SetFPEMask ; (; Int_t ; mask = kDefaultMask). virtual . Set which conditions trigger a floating point exception. ; Return the previous set of conditions. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 642 of file TSystem.cxx. ◆ SetIncludePath(). void TSystem::SetIncludePath ; (; const char * ; includePath). virtual . IncludePath should contain the list of comp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:84862,error,error,84862,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['error'],['error']
Availability,". ◆ TLinearMinimizer() [2/2]. TLinearMinimizer::TLinearMinimizer ; (; const char * ; type). Constructor from a char * (used by PM) ; Definition at line 82 of file TLinearMinimizer.cxx. ◆ ~TLinearMinimizer(). TLinearMinimizer::~TLinearMinimizer ; (; ). override . Destructor (no operations) ; Definition at line 100 of file TLinearMinimizer.cxx. Member Function Documentation. ◆ Class(). static TClass * TLinearMinimizer::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TLinearMinimizer::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TLinearMinimizer::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 126 of file TLinearMinimizer.h. ◆ CovMatrix(). double TLinearMinimizer::CovMatrix ; (; unsigned int ; i, . unsigned int ; j . ); const. inlineoverridevirtual . return covariance matrices elements if the variable is fixed the matrix is zero The ordering of the variables is the same as in errors ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 95 of file TLinearMinimizer.h. ◆ CovMatrixStatus(). int TLinearMinimizer::CovMatrixStatus ; (; ); const. inlineoverridevirtual . return covariance matrix status ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 100 of file TLinearMinimizer.h. ◆ DeclFileName(). static const char * TLinearMinimizer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 126 of file TLinearMinimizer.h. ◆ Edm(). double TLinearMinimizer::Edm ; (; ); const. inlineoverridevirtual . return expected distance reached from the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 66 of file TLinearMinimizer.h. ◆ Errors(). const double * TLinearMinimizer::Errors ; (; ); const. inlineoverridevirtual . return errors at the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 89 of file TLinearMinimiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLinearMinimizer.html:12663,error,errors,12663,doc/master/classTLinearMinimizer.html,https://root.cern,https://root.cern/doc/master/classTLinearMinimizer.html,1,['error'],['errors']
Availability,". ◆ writeToStream(). void RooRealVar::writeToStream ; (; std::ostream & ; os, . bool ; compact . ); const. overridevirtual . Write object contents to given stream. ; Reimplemented from RooAbsRealLValue.; Definition at line 700 of file RooRealVar.cxx. Member Data Documentation. ◆ _altNonSharedBinning. std::unordered_map<std::string,std::unique_ptr<RooAbsBinning> > RooRealVar::_altNonSharedBinning. protected . ! Non-shareable alternative binnings ; Definition at line 157 of file RooRealVar.h. ◆ _asymErrHi. double RooRealVar::_asymErrHi. protected . High side of asymmetric error associated with current value. ; Definition at line 155 of file RooRealVar.h. ◆ _asymErrLo. double RooRealVar::_asymErrLo. protected . Low side of asymmetric error associated with current value. ; Definition at line 154 of file RooRealVar.h. ◆ _binning. std::unique_ptr<RooAbsBinning> RooRealVar::_binning. protected . Definition at line 156 of file RooRealVar.h. ◆ _error. double RooRealVar::_error. protected . Symmetric error associated with current value. ; Definition at line 153 of file RooRealVar.h. ◆ _printScientific. bool RooRealVar::_printScientific. staticprotected . Definition at line 139 of file RooRealVar.h. ◆ _printSigDigits. Int_t RooRealVar::_printSigDigits. staticprotected . Definition at line 140 of file RooRealVar.h. ◆ _sharedProp. std::shared_ptr<RooRealVarSharedProperties> RooRealVar::_sharedProp. protected . ! Shared binnings associated with this instance ; Definition at line 169 of file RooRealVar.h. ◆ _valueResetCounter. std::size_t RooRealVar::_valueResetCounter = 0. protected . ! How many times the value of this variable was reset ; Definition at line 171 of file RooRealVar.h. Libraries for RooRealVar:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooRealVar.h; roofit/roofitcore/src/RooRealVar.cxx. RooRealVar. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:07 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:93260,error,error,93260,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['error'],['error']
Availability,"."");; 2154 t.ReplaceAll(""#aa"",""\\mbox{\\aa}"");; 2155 t.ReplaceAll(""#AA"",""\\mbox{\\AA}"");; 2156 ; 2157 t.ReplaceAll(""#omicron"",""o"");; 2158 t.ReplaceAll(""#Alpha"",""A"");; 2159 t.ReplaceAll(""#Beta"",""B"");; 2160 t.ReplaceAll(""#Epsilon"",""E"");; 2161 t.ReplaceAll(""#Zeta"",""Z"");; 2162 t.ReplaceAll(""#Eta"",""H"");; 2163 t.ReplaceAll(""#Iota"",""I"");; 2164 t.ReplaceAll(""#Kappa"",""K"");; 2165 t.ReplaceAll(""#Mu"",""M"");; 2166 t.ReplaceAll(""#Nu"",""N"");; 2167 t.ReplaceAll(""#Omicron"",""O"");; 2168 t.ReplaceAll(""#Rho"",""P"");; 2169 t.ReplaceAll(""#Tau"",""T"");; 2170 t.ReplaceAll(""#Chi"",""X"");; 2171 t.ReplaceAll(""#varomega"",""\\varpi"");; 2172 ; 2173 t.ReplaceAll(""#varUpsilon"",""?"");; 2174 t.ReplaceAll(""#corner"",""?"");; 2175 t.ReplaceAll(""#ltbar"",""?"");; 2176 t.ReplaceAll(""#bottombar"",""?"");; 2177 t.ReplaceAll(""#notsubset"",""?"");; 2178 t.ReplaceAll(""#arcbottom"",""?"");; 2179 t.ReplaceAll(""#cbar"",""?"");; 2180 t.ReplaceAll(""#arctop"",""?"");; 2181 t.ReplaceAll(""#topbar"",""?"");; 2182 t.ReplaceAll(""#arcbar"",""?"");; 2183 t.ReplaceAll(""#downleftarrow"",""?"");; 2184 t.ReplaceAll(""#splitline"",""\\genfrac{}{}{0pt}{}"");; 2185 ; 2186 t.ReplaceAll(""#"",""\\"");; 2187 t.ReplaceAll(""%"",""\\%"");; 2188 }; 2189 gVirtualPS->Text(x,y,t.Data());; 2190 } else {; 2191 Bool_t saveb = gPad->IsBatch();; 2192 gPad->SetBatch(kTRUE);; 2193 if (!PaintLatex1( x, y, angle, size, text1)) {; 2194 if (saveps) gVirtualPS = saveps;; 2195 return;; 2196 }; 2197 gPad->SetBatch(saveb);; 2198 }; 2199 gVirtualPS = nullptr;; 2200 }; 2201 ; 2202 if (!gPad->IsBatch()) PaintLatex1( x, y, angle, size, text1);; 2203 if (saveps) gVirtualPS = saveps;; 2204}; 2205 ; 2206////////////////////////////////////////////////////////////////////////////////; 2207/// Drawing function; 2208 ; 2209Int_t TLatex::PaintLatex1(Double_t x, Double_t y, Double_t angle, Double_t size, const Char_t *text1); 2210{; 2211 if (!gPad) return 0;; 2212 TString newText = text1;; 2213 if( newText.Length() == 0) return 0;; 2214 newText.ReplaceAll(""#hbox"",""#mbox"");; 2215 ; 2216 fError = nullptr;; 2217 if (C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLatex_8cxx_source.html:79566,down,downleftarrow,79566,doc/master/TLatex_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html,1,['down'],['downleftarrow']
Availability,".) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Private Attributes; Arrays used to store the packed inputs; TObjArray fSignal;  Packed input signal. ;  ; TObjArray fBackground;  Packed input background. ;  ; TObjArray fCandidates;  Packed input candidates (data) ;  ; TObjArray fErrorOnSignal;  Packed error sources for signal. ;  ; TObjArray fErrorOnBackground;  Packed error sources for background. ;  ; TObjArray fIds;  Packed IDs for the different error sources. ;  . TObjArray fDummyTA;  Dummy objects the class will use and delete. ;  ; TObjArray fDummyIds;  Array of dummy object (used for bookeeping) ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TObject; static TClass * Class (); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLimitDataSource.html:9595,error,error,9595,doc/master/classTLimitDataSource.html,https://root.cern,https://root.cern/doc/master/classTLimitDataSource.html,1,['error'],['error']
Availability,".); Performs the operation: this = this*c*f1; if errors are defined, errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after THnSparse::Multiply. void Divide(const THnSparse* h); Divide this histogram by h; this = this/(h); Note that if h has Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content. void Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. Bool_t CheckConsistency(const THnSparse* h, const char* tag) const; Consistency check on (some of) the parameters of two histograms (for operations). void SetBinEdges(Int_t idim, const Double_t* bins); Set the axis # of bins and bin limits on dimension idim. void SetBinContent(const Int_t* x, Double_t v); Set content of bin with coordinates ""coord"" to ""v"". void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError(const Int_t* x, Double_t e); Set error of bin with coordinates ""coord"" to ""e"", enable errors if needed. void SetBinError(Long64_t bin, Double_t e); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void Sumw2(); Enable calculation of errors. THnSparse* Rebin(Int_t group) const; Combine the content of ""group"" neighboring bins into; a new bin and return the resulting THnSparse.; For group=2 and a 3 dimensional h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THnSparse.html:23156,error,errors,23156,root/html528/THnSparse.html,https://root.cern,https://root.cern/root/html528/THnSparse.html,3,['error'],['errors']
Availability,"., 4., target: 0., 0.1, 0.2, 0.3, 0.4 . Definition at line 859 of file RAxis.hxx. ◆ EColumnType. enum class ROOT::Experimental::EColumnType. strong . EnumeratorkUnknown ; kIndex64 ; kIndex32 ; kSwitch ; kByte ; kChar ; kBit ; kReal64 ; kReal32 ; kReal16 ; kInt64 ; kUInt64 ; kInt32 ; kUInt32 ; kInt16 ; kUInt16 ; kInt8 ; kUInt8 ; kSplitIndex64 ; kSplitIndex32 ; kSplitReal64 ; kSplitReal32 ; kSplitInt64 ; kSplitUInt64 ; kSplitInt32 ; kSplitUInt32 ; kSplitInt16 ; kSplitUInt16 ; kMax . Definition at line 43 of file RColumnModel.hxx. ◆ EIOFeatures. enum class ROOT::Experimental::EIOFeatures. strong . EnumeratorkGenerateOffsetMap ; kSupported . Definition at line 52 of file TIOFeatures.hxx. ◆ EIOUnsupportedFeatures. enum class ROOT::Experimental::EIOUnsupportedFeatures. strong . EnumeratorkUnsupported . Definition at line 61 of file TIOFeatures.hxx. ◆ ELogLevel. enum class ROOT::Experimental::ELogLevel : unsigned char. strong . Kinds of diagnostics. . EnumeratorkUnset ; kFatal An error which causes further processing to be unreliable. . kError An error. . kWarning Warnings about likely unexpected behavior. . kInfo Informational messages; used for instance for tracing. . kDebug Debug information; only useful for developers; can have added verbosity up to 255-kDebug. . Definition at line 36 of file RLogger.hxx. ◆ ENTupleInfo. enum class ROOT::Experimental::ENTupleInfo. strong . Listing of the different options that can be printed by RNTupleReader::GetInfo() . EnumeratorkSummary ; kStorageDetails ; kMetrics . Definition at line 43 of file RNTupleReader.hxx. ◆ ENTupleInspectorHist. enum class ROOT::Experimental::ENTupleInspectorHist. strong . EnumeratorkCount ; kNElems ; kCompressedSize ; kUncompressedSize . Definition at line 43 of file RNTupleInspector.hxx. ◆ ENTupleInspectorPrintFormat. enum class ROOT::Experimental::ENTupleInspectorPrintFormat. strong . EnumeratorkTable ; kCSV . Definition at line 42 of file RNTupleInspector.hxx. ◆ ENTupleStructure. enum ROOT::Experimental:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html:40630,error,error,40630,doc/v632/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html,1,['error'],['error']
Availability,"..........; // 1) :; TF1NormSum *fnorm_exp_cb = new TF1NormSum(f_cb, f_exp, nsig, nbkg);; // 4) :; ; TF1 *f_sum = new TF1(""fsum"", *fnorm_exp_cb, -5., 5., fnorm_exp_cb->GetNpar());; ; // III.:; f_sum->SetParameters(fnorm_exp_cb->GetParameters().data());; f_sum->SetParName(1, ""NBackground"");; f_sum->SetParName(0, ""NSignal"");; for (int i = 2; i < f_sum->GetNpar(); ++i); f_sum->SetParName(i, fnorm_exp_cb->GetParName(i));; ; // GENERATE HISTOGRAM TO FIT ..............................................................; TStopwatch w;; w.Start();; TH1D *h_sum = new TH1D(""h_ExpCB"", ""Exponential Bkg + CrystalBall function"", nBins, -5., 5.);; h_sum->FillRandom(""fsum"", nEvents);; printf(""Time to generate %d events: "", nEvents);; w.Print();; ; // need to scale histogram with width since we are fitting a density; h_sum->Sumw2();; h_sum->Scale(1., ""width"");; ; // fit - use Minuit2 if available; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; new TCanvas(""Fit"", ""Fit"", 800, 1000);; // do a least-square fit of the spectrum; auto result = h_sum->Fit(""fsum"", ""SQ"");; result->Print();; h_sum->Draw();; printf(""Time to fit using ROOT TF1Normsum: "");; w.Print();; ; // test if parameters are fine; std::vector<double> pref = {nsig, nbkg, signal_mean};; for (unsigned int i = 0; i < pref.size(); ++i) {; if (!TMath::AreEqualAbs(pref[i], f_sum->GetParameter(i), f_sum->GetParError(i) * 10.)); Error(""testFitNormSum"", ""Difference found in fitted %s - difference is %g sigma"", f_sum->GetParName(i),; (f_sum->GetParameter(i) - pref[i]) / f_sum->GetParError(i));; }; ; gStyle->SetOptStat(0);; // add parameters; auto t1 = new TLatex(; -2.5, 300000, TString::Format(""%s = %8.0f #pm %4.0f"", ""NSignal"", f_sum->GetParameter(0), f_sum->GetParError(0)));; auto t2 = new TLatex(; -2.5, 270000, TString::Format(""%s = %8.0f #pm %4.0f"", ""Nbackgr"", f_sum->GetParameter(1), f_sum->GetParError(1)));; t1->Draw();; t2->Draw();; }; MinimizerOptions.h; TCanvas.h; Errorvoid Error(const char *location, const char *msg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/fitNormSum_8C.html:2857,avail,available,2857,doc/master/fitNormSum_8C.html,https://root.cern,https://root.cern/doc/master/fitNormSum_8C.html,1,['avail'],['available']
Availability,"...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Private Member Functions |; Static Private Member Functions |; List of all members ; TSVDUnfold Class ReferenceHistogram Library. ; SVD Approach to Data Unfolding. ; Reference: Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] ; TSVDUnfold implements the singular value decomposition based unfolding method (see reference). Currently, the unfolding of one-dimensional histograms is supported, with the same number of bins for the measured and the unfolded spectrum. ; The unfolding procedure is based on singular value decomposition of the response matrix. The regularisation of the unfolding is implemented via a discrete minimum-curvature condition. ; Monte Carlo inputs: . xini: true underlying spectrum (TH1D, n bins) . bini: reconstructed spectrum (TH1D, n bins) . Adet: response matrix (TH2D, nxn bins) . Consider the unfolding of a measured spectrum bdat with covariance matrix Bcov (if not passed explicitly, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis. ; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TSVDUnfoldSVD Approach to Data Unfolding.Definition TSVDUnfold.h:46; TSVDUnfold::UnfoldTH1D * Unfold(Int_t kreg)Perform the unfolding with regularisation parameter kreg.Definition TSVDUnfold.cxx:237; where kreg determ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSVDUnfold.html:1169,error,errors,1169,doc/master/classTSVDUnfold.html,https://root.cern,https://root.cern/doc/master/classTSVDUnfold.html,1,['error'],['errors']
Availability,"...;  ; class  MnHesse;  API class for calculating the numerical covariance matrix (== 2x Inverse Hessian == 2x Inverse 2nd derivative); can be used by the user or Minuit itself. More...;  ; class  MnLineSearch;  Implements a 1-dimensional minimization along a given direction (i.e. More...;  ; class  MnMachinePrecision;  Sets the relative floating point (double) arithmetic precision. More...;  ; class  MnMigrad;  API class for minimization using Variable Metric technology (""MIGRAD""); allows for user interaction: set/change parameters, do minimization, change parameters, re-do minimization etc.; also used by MnMinos and MnContours;. More...;  ; class  MnMinimize;  API class for minimization using Variable Metric technology (""MIGRAD""); allows for user interaction: set/change parameters, do minimization, change parameters, re-do minimization etc.; also used by MnMinos and MnContours;. More...;  ; class  MnMinos;  API class for Minos Error analysis (asymmetric errors); minimization has to be done before and Minimum must be valid; possibility to ask only for one side of the Minos Error;. More...;  ; class  MnParabola;  This class defines a parabola of the form a*x*x + b*x + c. More...;  ; class  MnParabolaFactory;  ; class  MnParabolaPoint;  A point of a parabola. More...;  ; class  MnParameterScan;  Scans the values of FCN as a function of one Parameter and retains the best function and Parameter values found. More...;  ; class  MnParStr;  ; class  MnPlot;  MnPlot produces a text-screen graphical output of (x,y) points, e.g. More...;  ; class  MnPosDef;  Force the covariance matrix to be positive defined by adding extra terms in the diagonal. More...;  ; class  MnPrint;  ; class  MnRefCountedPointer;  ; class  MnReferenceCounter;  ; class  MnScan;  API class for minimization using a scan method to find the minimum; allows for user interaction: set/change parameters, do minimization, change parameters, re-do minimization etc.;. More...;  ; class  MnSeedGenerator;  concret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html:7636,error,errors,7636,doc/master/namespaceROOT_1_1Minuit2.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html,2,['error'],['errors']
Availability,"...</A>; TGHtmlAnchor*fAnchorStartMost recent <a href=...>; ColorStruct_t*fApColor[32]Information about all colors; Pixel_tTGFrame::fBackgroundframe background color; ColorStruct_t*fBgColorBackground color of the HTML document; TImage*fBgImageBackground image; Int_tTGFrame::fBorderWidthframe border width; TGViewFrame*TGView::fCanvasframe containing the text; TGClient*TGObject::fClientConnection to display server; Atom_tTGView::fClipboardclipboard property; Long_tfColorUsedbit N is 1 if color N is in use. Only; TStringTGWidget::fCommandcommand to be executed; Cursor_tfCursorCurrent cursor for window, or None.; Int_tTGFrame::fDNDStateEDNDFlags; intfDirtyBottomBottom right corner of region to redraw; intfDirtyLeft; intfDirtyRight; intfDirtyTopTop left corner of region to redraw. These; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; intfExitingTrue if the widget is being destroyed; intfExportSelectionTrue if the selection is automatically; TGRectangleTGView::fExposedRegionexposed area ; SHtmlExtensions_t*fExtsPointer to user extension data; TGFrameElement*TGFrame::fFEpointer to frame element; ColorStruct_t*fFgColorColor of normal text. apColor[0]; TGHtmlBlock*fFirstBlockList of all TGHtmlBlock tokens; TGHtmlInput*fFirstInputFirst <INPUT> element; intfFlagsVarious flags; see below for definitions.; charfFontValid[9]If bit N%8 of work N/8 of this field is 0; TGHtmlInput*fFormElemLastMost recent <input>, <textarea> or <select>; TGHtmlInput*fFormElemStartMost recent <textarea> or <select>; intfFormPaddingAmount to pad form elements by; TGHtmlForm*fFormStartMost recent <form>; intfGcNextToFree; intfHasFramesTRUE if we can do frames for this page; intfHasScriptTRUE if we can do scripts for this page; UInt_tTGFrame::fHeightframe height; ColorStruct_t*fHighlightBgColorPtrColor for drawing traversal highlight; ColorStruct_t*fHighlightColorPtrColor for drawing traversal highlight.; intfHighlightWidthWidth in pixels ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGHtml.html:24534,mask,mask,24534,root/html528/TGHtml.html,https://root.cern,https://root.cern/root/html528/TGHtml.html,4,['mask'],['mask']
Availability,"..Definition TH1.cxx:826; . The option nostackb allows to draw the histograms next to each other as bar charts:; {; auto cst0 = new TCanvas(""cst0"",""cst0"",600,400);; auto hs = new THStack(""hs"",""Stacked 1D histograms: option #font[82]{\""nostackb\""}"");; ; auto h1 = new TH1F(""h1"",""h1"",10,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs->Add(h1);; ; auto h2 = new TH1F(""h2"",""h2"",10,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs->Add(h2);; ; auto h3 = new TH1F(""h3"",""h3"",10,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs->Add(h3);; ; hs->Draw(""nostackb"");; hs->GetXaxis()->SetNdivisions(-10);; cst0->SetGridx();; }; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519. If at least one of the histograms in the stack has errors, the whole stack is visualized by default with error bars. To visualize it without errors the option HIST should be used.; {; auto cst1 = new TCanvas(""cst1"",""cst1"",700,400);; cst1->Divide(2,1);; ; auto hst11 = new TH1F(""hst11"", """", 20, -10, 10);; hst11->Sumw2();; hst11->FillRandom(""gaus"", 1000);; hst11->SetFillColor(kViolet);; hst11->SetLineColor(kViolet);; ; auto hst12 = new TH1F(""hst12"", """", 20, -10, 10);; hst12->FillRandom(""gaus"", 500);; hst12->SetFillColor(kBlue);; hst12->SetLineColor(kBlue);; ; THStack st1(""st1"", ""st1"");; st1.Add(hst11);; st1.Add(hst12);; ; cst1->cd(1); st1.Draw();; cst1->cd(2); st1.Draw(""hist"");; }; kViolet@ kVioletDefinition Rtypes.h:67. Drawing of 3D implicit functions; 3D implicit functions (TF3) can be drawn as iso-surfaces. The implicit function f(x,y,z) = 0 is drawn in cartesian coordinates. In the following example the options ""FB"" and ""BB"" suppress the ""Front Box"" and ""Back Box"" around the plot.; {; auto c2 = new TCanvas(""c2"",""c2"",600,400);; auto f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:121474,error,errors,121474,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['error'],['errors']
Availability,"./(n-1)) * std::exp(-alpha*alpha/2.);; 136 intpow = C - A /(n-1.) * std::pow(B-z,-n+1) ;; 137 }; 138 else {; 139 // for n=1 the primitive of 1/x is log(x); 140 intpow = -A * std::log( n / abs_alpha ) + A * std::log( B -z );; 141 }; 142 intgaus = sqrtpiover2*(1.+ROOT::Math::erf(abs_alpha*oneoversqrt2));; 143 }; 144 else; 145 {; 146 intgaus = ROOT::Math::gaussian_cdf_c(z, 1);; 147 intgaus *= sqrt2pi;; 148 intpow = 0; ; 149 }; 150 return sigma * (intgaus + intpow);; 151 }; 152 ; 153 ; 154 double exponential_cdf_c(double x, double lambda, double x0); 155 {; 156 if ((x-x0) < 0) return 1.0;; 157 else return std::exp(- lambda * (x-x0));; 158 }; 159 ; 160 ; 161 double exponential_cdf(double x, double lambda, double x0); 162 {; 163 if ((x-x0) < 0) return 0.0;; 164 else // use expm1 function to avoid errors at small x; 165 return - ROOT::Math::expm1( - lambda * (x-x0) ) ;; 166 }; 167 ; 168 ; 169 double fdistribution_cdf_c(double x, double n, double m, double x0); 170 {; 171 // f distribution is defined only for both n and m > 0; 172 if (n < 0 || m < 0) return std::numeric_limits<double>::quiet_NaN();; 173 ; 174 double z = m/(m + n*(x-x0));; 175 // fox z->1 and large a and b IB looses precision use complement function; 176 if (z > 0.9 && n > 1 && m > 1) return 1.- fdistribution_cdf(x,n,m,x0);; 177 ; 178 // for the complement use the fact that IB(x,a,b) = 1. - IB(1-x,b,a); 179 return ROOT::Math::inc_beta(m/(m + n*(x-x0)), .5*m, .5*n);; 180 }; 181 ; 182 ; 183 double fdistribution_cdf(double x, double n, double m, double x0); 184 {; 185 // f distribution is defined only for both n and m > 0; 186 if (n < 0 || m < 0); 187 return std::numeric_limits<double>::quiet_NaN();; 188 ; 189 double z = n*(x-x0)/(m + n*(x-x0));; 190 // fox z->1 and large a and b IB looses precision use complement function; 191 if (z > 0.9 && n > 1 && m > 1); 192 return 1. - fdistribution_cdf_c(x,n,m,x0);; 193 ; 194 return ROOT::Math::inc_beta(z, .5*n, .5*m);; 195 }; 196 ; 197 ; 198 double gamma_cdf_c(double x,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ProbFuncMathCore_8cxx_source.html:5296,error,errors,5296,doc/master/ProbFuncMathCore_8cxx_source.html,https://root.cern,https://root.cern/doc/master/ProbFuncMathCore_8cxx_source.html,1,['error'],['errors']
Availability,".0, 1.0);; RooAddPdf model(""model"", ""model"", RooArgList(g1, g2), frac);; ; // Generate 1000 events; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; ; // Construct unbinned likelihood of model w.r.t. data; std::unique_ptr<RooAbsReal> nll{model.createNLL(*data)};; ; // I n t e r a c t i v e m i n i m i z a t i o n , e r r o r a n a l y s i s; // -------------------------------------------------------------------------------; ; // Create MINUIT interface object; RooMinimizer m(*nll);; ; // Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(true);; ; // Call MIGRAD to minimize the likelihood; m.migrad();; ; // Print values of all parameters, that reflect values (and error estimates); // that are back propagated from MINUIT; std::unique_ptr<RooArgSet>{model.getParameters(x)}->Print(""s"");; ; // Disable verbose logging; m.setVerbose(false);; ; // Run HESSE to calculate errors from d2L/dp2; m.hesse();; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // Run MINOS on sigma_g2 parameter only; m.minos(sigma_g2);; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // S a v i n g r e s u l t s , c o n t o u r p l o t s; // ---------------------------------------------------------; ; // Save a snapshot of the fit result. This object contains the initial; // fit parameters, the final fit parameters, the complete correlation; // matrix, the EDM, the minimized FCN , the last MINUIT status code and; // the number of times the RooFit function object has indicated evaluation; // problems (e.g. zero probabilities during likelihood evaluation); std::unique_ptr<RooFitResult> fitResult{m.save()};; ; // Make contour plot of mx vs sx at 1,2,3 sigma; RooPlot *frame = m.contour(frac, sigma_g2, 1, 2, 3);; frame->SetTitle(""Minuit contour plot"");; ; // Print the fit result snapshot; fitResult-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf601__intminuit_8C.html:2071,error,error,2071,doc/master/rf601__intminuit_8C.html,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html,2,['error'],['error']
Availability,".0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 6339 ; 6340 std::vector<Double_t> xline, yline;; 6341 option0 = option1 = option2 = option3 = option4 = optionE = optionEX0 = optionI0 = 0;; 6342 if (Hoption.Error >= 40) {Hoption.Error -=40; option0 = 1;}; 6343 if (Int_t(Hoption.Error/10) == 2) {optionEX0 = 1; Hoption.Error -= 10;}; 6344 if (Hoption.Error == 31) {optionEX0 = 1; Hoption.Error = 1;}; 6345 if (Hoption.Error == 11) option1 = 1;; 6346 if (Hoption.Error == 12) option2 = 1;; 6347 if (Hoption.Error == 13) option3 = 1;; 6348 if (Hoption.Error == 14) {option4 = 1; option3 = 1;}; 6349 if (Hoption.Error == 15) {optionI0 = 1; option3 = 1;}; 6350 if (Hoption.Error == 16) {optionI0 = 1; option4 = 1; option3 = 1;}; 6351 if (option2+option3 == 0) optionE = 1;; 6352 if (Hoption.Error == 0) optionE = 0;; 6353 if (fXaxis->GetXbins()->fN) fixbin = 0;; 6354 else fixbin = 1;; 6355 ; 6356 offset = fH->GetBarOffset();; 6357 width = fH->GetBarWidth();; 6358 ; 6359 errormarker = TAttMarker::GetMarkerStyleBase(fH->GetMarkerStyle());; 6360 if (optionEX0) {; 6361 xerror = 0;; 6362 } else {; 6363 xerror = gStyle->GetErrorX();; 6364 }; 6365 symbolsize = fH->GetMarkerSize();; 6366 if (errormarker == 1) symbolsize = 0.01;; 6367 sbasex = sbasey = symbolsize*kBASEMARKER;; 6368 if (errormarker >= 20 && errormarker <= 49) {; 6369 sbasex *= cxx[errormarker-20];; 6370 sbasey *= cyy[errormarker-20];; 6371 }; 6372 // set the graphics attributes; 6373 ; 6374 fH->TAttLine::Modify();; 6375 fH->TAttFill::Modify();; 6376 fH->TAttMarker::Modify();; 6377 ; 6378 // set the first and last bin; 6379 ; 6380 Double_t factor = Hparam.factor;; 6381 first = Hparam.xfirst;; 6382 last = Hparam.xlast;; 6383 npoints = last - first +1;; 6384 xmin = gPad->GetUxmin();; 6385 xmax = gPad->GetUxmax();; 6386 ymin = gPad->GetUymin();; 6387 ymax = gPad->GetUymax();; 6388 ; 6389 ; 6390 if (option3) {; 6391 xline.resize(2*npoints);; 6392 yline.resize(2*npoints);; 6393 if ((npoints > 0) && (xline.empty() || yline.empty())) {;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:234097,error,errormarker,234097,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,2,['error'],['errormarker']
Availability,.00176094 43680.2 2; : 887 Minimum Test error found - save the configuration ; : 887 | 5.55202 8.05484 0.0201465 0.00184145 43703.7 0; : 888 Minimum Test error found - save the configuration ; : 888 | 5.4009 7.86368 0.0201494 0.00184759 43711.4 0; : 889 | 5.09006 7.93881 0.0200766 0.00176618 43691 1; : 890 | 5.16257 8.05551 0.0200625 0.00176866 43730.7 2; : 891 Minimum Test error found - save the configuration ; : 891 | 5.07326 7.82028 0.0201532 0.0018382 43680.1 0; : 892 | 5.14088 7.89491 0.0200852 0.00179174 43731.4 1; : 893 Minimum Test error found - save the configuration ; : 893 | 5.13302 7.67646 0.0201541 0.00183919 43680.3 0; : 894 | 5.44229 7.83993 0.0200562 0.00176505 43736.9 1; : 895 | 5.40474 8.2327 0.0200223 0.00176151 43809.8 2; : 896 Minimum Test error found - save the configuration ; : 896 | 5.30823 7.62628 0.0201123 0.00182273 43740.8 0; : 897 | 6.20081 8.04326 0.0200652 0.00176931 43725.7 1; : 898 | 5.99101 8.0649 0.0200274 0.00175928 43792 2; : 899 Minimum Test error found - save the configuration ; : 899 | 5.1416 7.3348 0.0201215 0.00182199 43717.1 0; : 900 | 4.88699 7.46821 0.0200416 0.0017612 43762.6 1; : 901 Minimum Test error found - save the configuration ; : 901 | 4.92918 7.2702 0.0200754 0.00181642 43814.2 0; : 902 Minimum Test error found - save the configuration ; : 902 | 5.04871 7.17895 0.0200791 0.00180807 43785.1 0; : 903 | 4.88551 7.21813 0.0200213 0.00174992 43784.3 1; : 904 | 4.98683 7.44507 0.0200553 0.00174858 43699.9 2; : 905 | 4.82992 7.45009 0.0202406 0.00175807 43284.1 3; : 906 | 4.86112 7.78644 0.0202162 0.00175457 43333 4; : 907 Minimum Test error found - save the configuration ; : 907 | 4.76534 7.04169 0.0202678 0.00183052 43390.4 0; : 908 | 4.77659 7.36078 0.0201903 0.00174867 43380.2 1; : 909 | 5.40526 9.09975 0.0204121 0.00175613 42881.7 2; : 910 | 5.23108 7.3695 0.0200572 0.0017555 43711.7 3; : 911 | 4.9718 7.21676 0.0200739 0.00175828 43678.5 4; : 912 Minimum Test error found - save the configuration ; : 912 | 4.64478 ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:105928,error,error,105928,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.0017954 42924.1 1; : 970 | 3.39152 4.92875 0.0207012 0.00184125 42417.9 2; : 971 | 3.38481 4.91243 0.0205923 0.00181714 42609.4 3; : 972 | 3.49443 4.93416 0.0204303 0.00180084 42942.7 4; : 973 | 3.50169 4.88411 0.0201535 0.00176496 43505.4 5; : 974 | 3.70493 4.95915 0.0200555 0.00176513 43738.9 6; : 975 Minimum Test error found - save the configuration ; : 975 | 3.52504 4.65912 0.0202218 0.00185299 43552 0; : 976 | 3.7346 5.23443 0.0200603 0.00176255 43721.2 1; : 977 | 3.73856 4.9727 0.0200443 0.00176151 43757 2; : 978 | 3.60727 4.99113 0.0200479 0.00175633 43736 3; : 979 | 3.40672 4.84357 0.0200357 0.00175685 43766.5 4; : 980 | 3.44899 4.83288 0.0200548 0.0017499 43704.2 5; : 981 | 3.46445 4.72048 0.0203135 0.00176046 43119.7 6; : 982 Minimum Test error found - save the configuration ; : 982 | 3.46604 4.64127 0.0202116 0.00183381 43530.8 0; : 983 Minimum Test error found - save the configuration ; : 983 | 3.37896 4.59559 0.0201715 0.00182642 43608.5 0; : 984 Minimum Test error found - save the configuration ; : 984 | 3.36213 4.34126 0.0202597 0.00185498 43467.1 0; : 985 | 3.39032 4.51659 0.0201503 0.00185184 43719.5 1; : 986 | 3.5234 4.95577 0.0201762 0.0017578 43434.8 2; : 987 | 3.50466 4.60061 0.0201538 0.00175522 43481.6 3; : 988 | 3.61316 4.68965 0.0201071 0.00176 43603.6 4; : 989 | 3.88349 5.24185 0.0200475 0.00175499 43733.8 5; : 990 | 4.0647 4.52576 0.020036 0.00175545 43762.3 6; : 991 | 3.77396 5.32769 0.0200783 0.00175786 43667.1 7; : 992 | 3.45322 4.61211 0.0200841 0.00175232 43640 8; : 993 | 3.32586 4.54016 0.0200585 0.00176018 43719.9 9; : 994 | 3.54317 4.65875 0.0201539 0.00181263 43617.4 10; : 995 | 3.38008 5.03795 0.0206532 0.00179392 42419.4 11; : 996 | 3.40103 4.41295 0.0204644 0.00176564 42783.5 12; : 997 | 3.23461 4.8031 0.0203306 0.00176616 43093.1 13; : 998 | 3.41797 4.46788 0.0203618 0.00175568 42996.7 14; : 999 Minimum Test error found - save the configuration ; : 999 | 3.31412 4.14973 0.0202938 0.00187677 43438 0; : 1000 | 3.20867 4.17264 0.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:112138,error,error,112138,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.00182919 43743 0; : 792 | 11.3858 15.3308 0.0200358 0.001762 43778.5 1; : 793 Minimum Test error found - save the configuration ; : 793 | 11.148 14.9168 0.0201055 0.00182242 43756.2 0; : 794 Minimum Test error found - save the configuration ; : 794 | 10.9366 14.9107 0.0201153 0.00182387 43736.3 0; : 795 | 11.1392 14.953 0.020041 0.00176266 43767.6 1; : 796 | 11.1019 15.4101 0.0200549 0.00175791 43723.2 2; : 797 | 11.12 15.292 0.0200628 0.00175972 43708.5 3; : 798 | 10.8935 14.9786 0.0200585 0.0017545 43706.3 4; : 799 Minimum Test error found - save the configuration ; : 799 | 10.7942 14.6749 0.0201633 0.00182171 43616.6 0; : 800 Minimum Test error found - save the configuration ; : 800 | 10.3317 14.1583 0.0201165 0.00182126 43727.2 0; : 801 | 10.3503 14.2866 0.0200523 0.00175781 43729 1; : 802 | 10.3453 15.2815 0.0200406 0.00175563 43751.8 2; : 803 | 10.2123 14.6873 0.0200478 0.00175638 43736.3 3; : 804 | 10.1133 14.2109 0.0201368 0.00176313 43540.5 4; : 805 Minimum Test error found - save the configuration ; : 805 | 10.3447 13.9911 0.0201319 0.00182751 43705.3 0; : 806 | 10.3558 15.0191 0.0200537 0.00175652 43722.7 1; : 807 Minimum Test error found - save the configuration ; : 807 | 9.87362 13.4104 0.0202002 0.0018848 43679 0; : 808 | 9.75883 13.5009 0.0202529 0.00175832 43255.9 1; : 809 | 9.54989 13.8103 0.0201225 0.00175709 43560.3 2; : 810 Minimum Test error found - save the configuration ; : 810 | 9.43647 13.1509 0.0201534 0.00182442 43646.8 0; : 811 | 9.40272 13.8504 0.0200559 0.00175676 43717.9 1; : 812 Minimum Test error found - save the configuration ; : 812 | 9.42328 13.0239 0.0202708 0.00183859 43402.3 0; : 813 | 9.26754 13.347 0.0200488 0.00175838 43738.7 1; : 814 | 9.30693 13.2737 0.0200298 0.0017551 43776.4 2; : 815 | 9.2453 13.4411 0.0200383 0.0017608 43769.8 3; : 816 Minimum Test error found - save the configuration ; : 816 | 8.97729 12.8621 0.0200894 0.00181862 43785.8 0; : 817 | 9.05512 13.256 0.0200147 0.0017603 43825 1; : 818 Minimum Test error ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:98739,error,error,98739,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.1 0; : 635 Minimum Test error found - save the configuration ; : 635 | 77.3887 55.223 0.020166 0.00184577 43667.6 0; : 636 Minimum Test error found - save the configuration ; : 636 | 76.4488 55.0573 0.020202 0.00188181 43667.6 0; : 637 Minimum Test error found - save the configuration ; : 637 | 75.4894 54.0711 0.0202555 0.00186268 43495.3 0; : 638 Minimum Test error found - save the configuration ; : 638 | 74.5839 53.0373 0.0201113 0.00181775 43731.4 0; : 639 Minimum Test error found - save the configuration ; : 639 | 73.497 52.6629 0.0200838 0.00181639 43793.9 0; : 640 Minimum Test error found - save the configuration ; : 640 | 72.4195 52.0402 0.0201153 0.00181887 43724.4 0; : 641 | 71.5077 52.3492 0.0200565 0.00175616 43715 1; : 642 Minimum Test error found - save the configuration ; : 642 | 70.8829 51.1798 0.0201079 0.00181215 43725.9 0; : 643 Minimum Test error found - save the configuration ; : 643 | 69.8143 50.8726 0.0201142 0.00180555 43695.1 0; : 644 Minimum Test error found - save the configuration ; : 644 | 68.806 50.1244 0.0201666 0.00186273 43706.7 0; : 645 Minimum Test error found - save the configuration ; : 645 | 67.8562 49.8828 0.0202418 0.00183622 43465.2 0; : 646 Minimum Test error found - save the configuration ; : 646 | 67.0733 49.0958 0.0205161 0.00187288 42911 0; : 647 Minimum Test error found - save the configuration ; : 647 | 66.0907 48.4839 0.0203074 0.00181472 43260.4 0; : 648 Minimum Test error found - save the configuration ; : 648 | 65.1425 47.9895 0.0205925 0.00181541 42605 0; : 649 Minimum Test error found - save the configuration ; : 649 | 64.2291 47.827 0.0205836 0.00185514 42715.8 0; : 650 Minimum Test error found - save the configuration ; : 650 | 63.5181 47.2461 0.0203914 0.00184161 43127.1 0; : 651 Minimum Test error found - save the configuration ; : 651 | 62.641 46.7417 0.020143 0.00182812 43680.3 0; : 652 Minimum Test error found - save the configuration ; : 652 | 61.875 46.3421 0.0201124 0.00182035 43734.8 0; : 653 Minimum T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:83497,error,error,83497,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.1 2; : 1018 | 3.2792 3.85661 0.0202747 0.00181943 43348.2 3; : 1019 | 3.37748 4.22044 0.0208054 0.00183497 42170.8 4; : 1020 | 3.48034 4.07947 0.020447 0.00177824 42852.4 5; : 1021 | 3.50059 4.11275 0.020219 0.00176964 43361.9 6; : 1022 | 3.15174 3.86168 0.0203283 0.00176093 43086.3 7; : 1023 | 3.4694 4.52782 0.0204007 0.00179059 42987.4 8; : 1024 Minimum Test error found - save the configuration ; : 1024 | 3.57333 3.68346 0.0207199 0.00186469 42428.5 0; : 1025 | 3.1448 3.86932 0.020257 0.0018083 43363.6 1; : 1026 | 3.14966 3.71614 0.0204412 0.00177219 42851.8 2; : 1027 Minimum Test error found - save the configuration ; : 1027 | 3.06278 3.47888 0.0204485 0.00186251 43043.1 0; : 1028 | 3.22518 4.06346 0.0201016 0.00179042 43689.3 1; : 1029 | 3.47015 5.10048 0.0212551 0.0017691 41055.1 2; : 1030 | 3.28552 3.92634 0.0200717 0.0017618 43692.2 3; : 1031 | 3.09879 3.64842 0.0200603 0.0017557 43704.9 4; : 1032 | 3.23242 4.45782 0.0201318 0.0017893 43614.6 5; : 1033 Minimum Test error found - save the configuration ; : 1033 | 3.57665 3.43738 0.0206178 0.00193324 42816.1 0; : 1034 | 3.26951 3.4755 0.0201231 0.00175901 43563.3 1; : 1035 | 3.0748 4.32816 0.0202002 0.00180771 43496 2; : 1036 | 3.05868 3.88772 0.0202082 0.00176323 43372.3 3; : 1037 | 3.11243 3.8552 0.0200473 0.00176925 43768.4 4; : 1038 | 2.97479 4.01382 0.020048 0.00176307 43752 5; : 1039 | 3.15714 3.85081 0.0200388 0.00176348 43774.8 6; : 1040 | 2.97124 3.72013 0.0200295 0.00176294 43795.8 7; : 1041 | 2.92938 3.63611 0.020078 0.00179099 43746.9 8; : 1042 | 3.04184 3.72584 0.0202124 0.00176555 43367.8 9; : 1043 | 3.24904 3.46339 0.0200395 0.00176046 43765.9 10; : 1044 | 3.08383 3.85222 0.0200574 0.0017582 43717.6 11; : 1045 | 3.00904 3.46043 0.0200555 0.00175872 43723.6 12; : 1046 Minimum Test error found - save the configuration ; : 1046 | 2.89922 3.28968 0.0204754 0.00188349 43029.5 0; : 1047 | 3.06628 3.80261 0.0206565 0.00177157 42361.9 1; : 1048 | 3.0482 4.21427 0.0203272 0.00175981 43086.2 2; : 1049 | 3.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:115357,error,error,115357,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.2 0; : 634 Minimum Test error found - save the configuration ; : 634 | 78.6493 55.4759 0.0202109 0.00182609 43514.1 0; : 635 Minimum Test error found - save the configuration ; : 635 | 77.3887 55.223 0.020166 0.00184577 43667.6 0; : 636 Minimum Test error found - save the configuration ; : 636 | 76.4488 55.0573 0.020202 0.00188181 43667.6 0; : 637 Minimum Test error found - save the configuration ; : 637 | 75.4894 54.0711 0.0202555 0.00186268 43495.3 0; : 638 Minimum Test error found - save the configuration ; : 638 | 74.5839 53.0373 0.0201113 0.00181775 43731.4 0; : 639 Minimum Test error found - save the configuration ; : 639 | 73.497 52.6629 0.0200838 0.00181639 43793.9 0; : 640 Minimum Test error found - save the configuration ; : 640 | 72.4195 52.0402 0.0201153 0.00181887 43724.4 0; : 641 | 71.5077 52.3492 0.0200565 0.00175616 43715 1; : 642 Minimum Test error found - save the configuration ; : 642 | 70.8829 51.1798 0.0201079 0.00181215 43725.9 0; : 643 Minimum Test error found - save the configuration ; : 643 | 69.8143 50.8726 0.0201142 0.00180555 43695.1 0; : 644 Minimum Test error found - save the configuration ; : 644 | 68.806 50.1244 0.0201666 0.00186273 43706.7 0; : 645 Minimum Test error found - save the configuration ; : 645 | 67.8562 49.8828 0.0202418 0.00183622 43465.2 0; : 646 Minimum Test error found - save the configuration ; : 646 | 67.0733 49.0958 0.0205161 0.00187288 42911 0; : 647 Minimum Test error found - save the configuration ; : 647 | 66.0907 48.4839 0.0203074 0.00181472 43260.4 0; : 648 Minimum Test error found - save the configuration ; : 648 | 65.1425 47.9895 0.0205925 0.00181541 42605 0; : 649 Minimum Test error found - save the configuration ; : 649 | 64.2291 47.827 0.0205836 0.00185514 42715.8 0; : 650 Minimum Test error found - save the configuration ; : 650 | 63.5181 47.2461 0.0203914 0.00184161 43127.1 0; : 651 Minimum Test error found - save the configuration ; : 651 | 62.641 46.7417 0.020143 0.00182812 43680.3 0; : 652 Minimum ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:83383,error,error,83383,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.2 5; : 1012 | 3.24301 4.1309 0.0202482 0.00178612 43332 6; : 1013 | 3.47685 4.13785 0.0205714 0.00178247 42578.3 7; : 1014 | 3.38367 4.59532 0.0203076 0.00178189 43183.2 8; : 1015 Minimum Test error found - save the configuration ; : 1015 | 3.15343 3.81668 0.0204522 0.00185272 43011.9 0; : 1016 | 2.99441 4.01707 0.0202697 0.00183758 43402.5 1; : 1017 | 3.3956 4.54944 0.0201133 0.00176644 43604.1 2; : 1018 | 3.2792 3.85661 0.0202747 0.00181943 43348.2 3; : 1019 | 3.37748 4.22044 0.0208054 0.00183497 42170.8 4; : 1020 | 3.48034 4.07947 0.020447 0.00177824 42852.4 5; : 1021 | 3.50059 4.11275 0.020219 0.00176964 43361.9 6; : 1022 | 3.15174 3.86168 0.0203283 0.00176093 43086.3 7; : 1023 | 3.4694 4.52782 0.0204007 0.00179059 42987.4 8; : 1024 Minimum Test error found - save the configuration ; : 1024 | 3.57333 3.68346 0.0207199 0.00186469 42428.5 0; : 1025 | 3.1448 3.86932 0.020257 0.0018083 43363.6 1; : 1026 | 3.14966 3.71614 0.0204412 0.00177219 42851.8 2; : 1027 Minimum Test error found - save the configuration ; : 1027 | 3.06278 3.47888 0.0204485 0.00186251 43043.1 0; : 1028 | 3.22518 4.06346 0.0201016 0.00179042 43689.3 1; : 1029 | 3.47015 5.10048 0.0212551 0.0017691 41055.1 2; : 1030 | 3.28552 3.92634 0.0200717 0.0017618 43692.2 3; : 1031 | 3.09879 3.64842 0.0200603 0.0017557 43704.9 4; : 1032 | 3.23242 4.45782 0.0201318 0.0017893 43614.6 5; : 1033 Minimum Test error found - save the configuration ; : 1033 | 3.57665 3.43738 0.0206178 0.00193324 42816.1 0; : 1034 | 3.26951 3.4755 0.0201231 0.00175901 43563.3 1; : 1035 | 3.0748 4.32816 0.0202002 0.00180771 43496 2; : 1036 | 3.05868 3.88772 0.0202082 0.00176323 43372.3 3; : 1037 | 3.11243 3.8552 0.0200473 0.00176925 43768.4 4; : 1038 | 2.97479 4.01382 0.020048 0.00176307 43752 5; : 1039 | 3.15714 3.85081 0.0200388 0.00176348 43774.8 6; : 1040 | 2.97124 3.72013 0.0200295 0.00176294 43795.8 7; : 1041 | 2.92938 3.63611 0.020078 0.00179099 43746.9 8; : 1042 | 3.04184 3.72584 0.0202124 0.00176555 43367.8 9; : 1043 | 3.24904,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:114960,error,error,114960,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,".2 Drawing a Profile without Error Bars; To draw a profile histogram and not show the error bars use the “HIST” option in the TProfile::Draw method. This will draw the outline of the TProfile.; 3.17.3 Create a Profile from a 2D Histogram; You can make a profile from a histogram using the methods TH2::ProfileX and TH2::ProfileY.; 3.17.4 Create a Histogram from a Profile; To create a regular histogram from a profile histogram, use the method TProfile::ProjectionX .This example instantiates a TH1D object by copying the TH1D piece of TProfile.; TH1D *sum = myProfile.ProjectionX();; You can do the same with a 2D profile using the method TProfile2D::ProjectionXY .; 3.17.5 Generating a Profile from a TTree; The 'prof' and 'profs' options in the TTree::Draw method generate a profile histogram ( TProfile ), given a two dimensional expression in the tree, or a TProfile2D given a three dimensional expression. See “Trees”. Note that you can specify 'prof' or 'profs' : 'prof' generates a TProfile with error on the mean, 'profs' generates a TProfile with error on the spread.; 3.17.6 2D Profiles; The class for a 2D Profile is called TProfile2D . It is in many cases an elegant replacement of a three-dimensional histogram. The relationship of three measured quantities X, Y and Z can be visualized by a three-dimensional histogram or scatter-plot; its representation is not particularly satisfactory, except for sparse data. If Z is an unknown (but single-valued) function of (X,Y), it can be displayed with a TProfile2D with better precision than by a scatter-plot. A TProfile2D displays the mean value of Z and its RMS for each cell in X, Y. The following shows the cumulated contents (capital letters) and the values displayed (small letters) of the elements for cell i,j.; When you fill a profile histogram with TProfile2D.Fill(x,y,z):. E[i,j] contains for each bin i,j the sum of the z values for this bin; L[i,j] contains the number of entries in the bin j; e[j] or s[j] will be the resulting",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:131730,error,error,131730,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['error'],['error']
Availability,".4 */; 4282 case 504:; 4283 return ""Gateway Time-out""; /* RFC2616 Section 10.5.5 */; 4284 case 505:; 4285 return ""HTTP Version not supported""; /* RFC2616 Section 10.5.6 */; 4286 case 506:; 4287 return ""Variant Also Negotiates""; /* RFC 2295, Section 8.1 */; 4288 case 507:; 4289 return ""Insufficient Storage""; /* RFC2518 Section 10.6, RFC4918; 4290 * Section 11.5 */; 4291 case 508:; 4292 return ""Loop Detected""; /* RFC5842 Section 7.1 */; 4293 ; 4294 case 510:; 4295 return ""Not Extended""; /* RFC 2774, Section 7 */; 4296 case 511:; 4297 return ""Network Authentication Required""; /* RFC 6585, Section 6 */; 4298 ; 4299 /* Other status codes, not shown in the IANA HTTP status code; 4300 * assignment.; 4301 * E.g., ""de facto"" standards due to common use, ... */; 4302 case 418:; 4303 return ""I am a teapot""; /* RFC2324 Section 2.3.2 */; 4304 case 419:; 4305 return ""Authentication Timeout""; /* common use */; 4306 case 420:; 4307 return ""Enhance Your Calm""; /* common use */; 4308 case 440:; 4309 return ""Login Timeout""; /* common use */; 4310 case 509:; 4311 return ""Bandwidth Limit Exceeded""; /* common use */; 4312 ; 4313 default:; 4314 /* This error code is unknown. This should not happen. */; 4315 if (conn) {; 4316 mg_cry_internal(conn,; 4317 ""Unknown HTTP response code: %u"",; 4318 response_code);; 4319 }; 4320 ; 4321 /* Return at least a category according to RFC 2616 Section 10. */; 4322 if (response_code >= 100 && response_code < 200) {; 4323 /* Unknown informational status code */; 4324 return ""Information"";; 4325 }; 4326 if (response_code >= 200 && response_code < 300) {; 4327 /* Unknown success code */; 4328 return ""Success"";; 4329 }; 4330 if (response_code >= 300 && response_code < 400) {; 4331 /* Unknown redirection code */; 4332 return ""Redirection"";; 4333 }; 4334 if (response_code >= 400 && response_code < 500) {; 4335 /* Unknown request error code */; 4336 return ""Client Error"";; 4337 }; 4338 if (response_code >= 500 && response_code < 600) {; 4339 /* Unknown server er",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:128817,error,error,128817,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,".4 */; 4283 case 504:; 4284 return ""Gateway Time-out""; /* RFC2616 Section 10.5.5 */; 4285 case 505:; 4286 return ""HTTP Version not supported""; /* RFC2616 Section 10.5.6 */; 4287 case 506:; 4288 return ""Variant Also Negotiates""; /* RFC 2295, Section 8.1 */; 4289 case 507:; 4290 return ""Insufficient Storage""; /* RFC2518 Section 10.6, RFC4918; 4291 * Section 11.5 */; 4292 case 508:; 4293 return ""Loop Detected""; /* RFC5842 Section 7.1 */; 4294 ; 4295 case 510:; 4296 return ""Not Extended""; /* RFC 2774, Section 7 */; 4297 case 511:; 4298 return ""Network Authentication Required""; /* RFC 6585, Section 6 */; 4299 ; 4300 /* Other status codes, not shown in the IANA HTTP status code; 4301 * assignment.; 4302 * E.g., ""de facto"" standards due to common use, ... */; 4303 case 418:; 4304 return ""I am a teapot""; /* RFC2324 Section 2.3.2 */; 4305 case 419:; 4306 return ""Authentication Timeout""; /* common use */; 4307 case 420:; 4308 return ""Enhance Your Calm""; /* common use */; 4309 case 440:; 4310 return ""Login Timeout""; /* common use */; 4311 case 509:; 4312 return ""Bandwidth Limit Exceeded""; /* common use */; 4313 ; 4314 default:; 4315 /* This error code is unknown. This should not happen. */; 4316 if (conn) {; 4317 mg_cry_internal(conn,; 4318 ""Unknown HTTP response code: %u"",; 4319 response_code);; 4320 }; 4321 ; 4322 /* Return at least a category according to RFC 2616 Section 10. */; 4323 if (response_code >= 100 && response_code < 200) {; 4324 /* Unknown informational status code */; 4325 return ""Information"";; 4326 }; 4327 if (response_code >= 200 && response_code < 300) {; 4328 /* Unknown success code */; 4329 return ""Success"";; 4330 }; 4331 if (response_code >= 300 && response_code < 400) {; 4332 /* Unknown redirection code */; 4333 return ""Redirection"";; 4334 }; 4335 if (response_code >= 400 && response_code < 500) {; 4336 /* Unknown request error code */; 4337 return ""Client Error"";; 4338 }; 4339 if (response_code >= 500 && response_code < 600) {; 4340 /* Unknown server er",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:128849,error,error,128849,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,.4 0; : 639 Minimum Test error found - save the configuration ; : 639 | 73.497 52.6629 0.0200838 0.00181639 43793.9 0; : 640 Minimum Test error found - save the configuration ; : 640 | 72.4195 52.0402 0.0201153 0.00181887 43724.4 0; : 641 | 71.5077 52.3492 0.0200565 0.00175616 43715 1; : 642 Minimum Test error found - save the configuration ; : 642 | 70.8829 51.1798 0.0201079 0.00181215 43725.9 0; : 643 Minimum Test error found - save the configuration ; : 643 | 69.8143 50.8726 0.0201142 0.00180555 43695.1 0; : 644 Minimum Test error found - save the configuration ; : 644 | 68.806 50.1244 0.0201666 0.00186273 43706.7 0; : 645 Minimum Test error found - save the configuration ; : 645 | 67.8562 49.8828 0.0202418 0.00183622 43465.2 0; : 646 Minimum Test error found - save the configuration ; : 646 | 67.0733 49.0958 0.0205161 0.00187288 42911 0; : 647 Minimum Test error found - save the configuration ; : 647 | 66.0907 48.4839 0.0203074 0.00181472 43260.4 0; : 648 Minimum Test error found - save the configuration ; : 648 | 65.1425 47.9895 0.0205925 0.00181541 42605 0; : 649 Minimum Test error found - save the configuration ; : 649 | 64.2291 47.827 0.0205836 0.00185514 42715.8 0; : 650 Minimum Test error found - save the configuration ; : 650 | 63.5181 47.2461 0.0203914 0.00184161 43127.1 0; : 651 Minimum Test error found - save the configuration ; : 651 | 62.641 46.7417 0.020143 0.00182812 43680.3 0; : 652 Minimum Test error found - save the configuration ; : 652 | 61.875 46.3421 0.0201124 0.00182035 43734.8 0; : 653 Minimum Test error found - save the configuration ; : 653 | 61.1155 45.9892 0.0201549 0.00182806 43651.9 0; : 654 | 60.3955 46.5097 0.0201006 0.00177795 43661.9 1; : 655 Minimum Test error found - save the configuration ; : 655 | 59.5776 45.1172 0.0204622 0.00186914 43026.9 0; : 656 Minimum Test error found - save the configuration ; : 656 | 58.5813 44.6814 0.020214 0.00181641 43484.1 0; : 657 Minimum Test error found - save the configuration ; : 657 | 58.10,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:83950,error,error,83950,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.4 1; : 673 Minimum Test error found - save the configuration ; : 673 | 47.0153 38.3207 0.0201285 0.00181671 43687.7 0; : 674 Minimum Test error found - save the configuration ; : 674 | 46.5986 38.0788 0.0201224 0.00182147 43713.7 0; : 675 Minimum Test error found - save the configuration ; : 675 | 45.6663 37.2199 0.020138 0.00182969 43696.1 0; : 676 Minimum Test error found - save the configuration ; : 676 | 44.8146 36.9047 0.0201419 0.00182761 43681.7 0; : 677 | 44.1854 37.155 0.0200983 0.0017637 43633.4 1; : 678 Minimum Test error found - save the configuration ; : 678 | 43.7163 36.54 0.0202108 0.00183597 43537.9 0; : 679 Minimum Test error found - save the configuration ; : 679 | 43.1003 36.3421 0.0201203 0.00181258 43697.4 0; : 680 Minimum Test error found - save the configuration ; : 680 | 42.8206 35.8087 0.0201316 0.00181818 43683.7 0; : 681 Minimum Test error found - save the configuration ; : 681 | 42.0593 35.186 0.0205402 0.00185408 42812.5 0; : 682 Minimum Test error found - save the configuration ; : 682 | 41.3592 34.9319 0.0201181 0.00182063 43721.9 0; : 683 | 40.8775 34.9951 0.020058 0.00175108 43699.3 1; : 684 Minimum Test error found - save the configuration ; : 684 | 40.654 34.3931 0.0201589 0.00183818 43666.4 0; : 685 Minimum Test error found - save the configuration ; : 685 | 40.0613 33.8904 0.0201577 0.00183348 43658.1 0; : 686 | 39.3281 34.3645 0.0200576 0.00176772 43739.9 1; : 687 | 38.8187 34.1117 0.0201676 0.00177122 43486.9 2; : 688 Minimum Test error found - save the configuration ; : 688 | 38.3466 33.422 0.0201552 0.00185044 43704.5 0; : 689 Minimum Test error found - save the configuration ; : 689 | 37.998 33.2339 0.0201139 0.00182328 43738.2 0; : 690 Minimum Test error found - save the configuration ; : 690 | 37.3126 32.8977 0.0200976 0.0018112 43748.3 0; : 691 Minimum Test error found - save the configuration ; : 691 | 36.956 32.4497 0.0202163 0.00185879 43578.8 0; : 692 | 36.3494 32.5119 0.0203375 0.00178876 43129.6 1; : 693 Minimum Te,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:87576,error,error,87576,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.5 0; : 606 Minimum Test error found - save the configuration ; : 606 | 112.65 73.8117 0.0200987 0.00180944 43741.5 0; : 607 Minimum Test error found - save the configuration ; : 607 | 110.993 73.1273 0.0200934 0.00180455 43742.6 0; : 608 Minimum Test error found - save the configuration ; : 608 | 109.653 72.3206 0.0201066 0.00180567 43713.6 0; : 609 Minimum Test error found - save the configuration ; : 609 | 108.357 71.632 0.0200983 0.00180999 43743.9 0; : 610 Minimum Test error found - save the configuration ; : 610 | 106.875 70.7773 0.0201154 0.00182046 43728 0; : 611 | 105.742 70.7984 0.0200525 0.00175765 43728.1 1; : 612 Minimum Test error found - save the configuration ; : 612 | 104.268 69.338 0.0202166 0.00183521 43522.3 0; : 613 Minimum Test error found - save the configuration ; : 613 | 102.858 68.9009 0.0202348 0.00182917 43464.9 0; : 614 Minimum Test error found - save the configuration ; : 614 | 101.983 68.108 0.0201318 0.00182452 43698.5 0; : 615 Minimum Test error found - save the configuration ; : 615 | 100.329 67.3723 0.0201441 0.00182383 43667.6 0; : 616 Minimum Test error found - save the configuration ; : 616 | 99.0728 66.9343 0.0201375 0.00182665 43689.9 0; : 617 Minimum Test error found - save the configuration ; : 617 | 97.8374 65.9501 0.0201618 0.00184005 43664 0; : 618 Minimum Test error found - save the configuration ; : 618 | 96.3739 65.107 0.0201565 0.0018204 43629.8 0; : 619 Minimum Test error found - save the configuration ; : 619 | 95.4431 64.9258 0.0202106 0.00183339 43532.2 0; : 620 Minimum Test error found - save the configuration ; : 620 | 94.1902 64.0162 0.020412 0.0018551 43110.6 0; : 621 Minimum Test error found - save the configuration ; : 621 | 92.9103 63.3038 0.0201905 0.00182603 43562.4 0; : 622 Minimum Test error found - save the configuration ; : 622 | 91.6075 63.2578 0.0201995 0.00184553 43587.4 0; : 623 Minimum Test error found - save the configuration ; : 623 | 90.7693 62.0703 0.0202228 0.00181118 43450.9 0; : 624 Minimum,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:80441,error,error,80441,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,".5*(dfmax1+dfmax2);; 1603 Double_t z = dfmax*factnm;; 1604 ; 1605 prb = TMath::KolmogorovProb(z);; 1606 ; 1607 Double_t prb1 = 0, prb2 = 0;; 1608 // option N to combine normalization makes sense if both afunc1 and afunc2 are false; 1609 if (opt.Contains(""N"") && !(afunc1 || afunc2 ) ) {; 1610 // Combine probabilities for shape and normalization; 1611 prb1 = prb;; 1612 Double_t d12 = esum1-esum2;; 1613 Double_t chi2 = d12*d12/(esum1+esum2);; 1614 prb2 = TMath::Prob(chi2,1);; 1615 // see Eadie et al., section 11.6.2; 1616 if (prb > 0 && prb2 > 0) prb = prb*prb2*(1-TMath::Log(prb*prb2));; 1617 else prb = 0;; 1618 }; 1619 ; 1620 // debug printout; 1621 if (opt.Contains(""D"")) {; 1622 printf("" Kolmo Prob h1 = %s, sum1=%g\n"",h1->GetName(),sum1);; 1623 printf("" Kolmo Prob h2 = %s, sum2=%g\n"",h2->GetName(),sum2);; 1624 printf("" Kolmo Probabil = %f, Max Dist = %g\n"",prb,dfmax);; 1625 if (opt.Contains(""N"")); 1626 printf("" Kolmo Probabil = %f for shape alone, =%f for normalisation alone\n"",prb1,prb2);; 1627 }; 1628 // This numerical error condition should never occur:; 1629 if (TMath::Abs(rsum1-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h1=%s\n"",h1->GetName());; 1630 if (TMath::Abs(rsum2-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h2=%s\n"",h2->GetName());; 1631 ; 1632 if(opt.Contains(""M"")) return dfmax; // return average of max distance; 1633 ; 1634 return prb;; 1635}; 1636 ; 1637 ; 1638////////////////////////////////////////////////////////////////////////////////; 1639/// Rebin only the X axis; 1640/// see Rebin2D; 1641 ; 1642TH2 *TH2::RebinX(Int_t ngroup, const char *newname); 1643{; 1644 return Rebin2D(ngroup, 1, newname);; 1645}; 1646 ; 1647 ; 1648////////////////////////////////////////////////////////////////////////////////; 1649/// Rebin only the Y axis; 1650/// see Rebin2D; 1651 ; 1652TH2 *TH2::RebinY(Int_t ngroup, const char *newname); 1653{; 1654 return Rebin2D(1, ngroup, newname);; 1655}; 1656 ; 1657/////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:65210,error,error,65210,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['error'],['error']
Availability,".5,; UseBaggedBoost=True,; BaggedSampleFraction=0.5,; SeparationType=""GiniIndex"",; nCuts=20,; ); ; ; #### Booking Deep Neural Network; ; # Here we book the DNN of TMVA. See the example TMVA_Higgs_Classification.C for a detailed description of the; # options; ; if useTMVADNN:; layoutString = ROOT.TString(; ""DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR""; ); ; # Training strategies; # one can catenate several training strings with different parameters (e.g. learning rates or regularizations; # parameters) The training string must be concatenated with the `|` delimiter; trainingString1 = ROOT.TString(; ""LearningRate=1e-3,Momentum=0.9,Repetitions=1,""; ""ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,""; ""WeightDecay=1e-4,Regularization=None,""; ""Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.""; ) # + ""|"" + trainingString2 + ...; trainingString1 += "",MaxEpochs="" + str(max_epochs); ; # Build now the full DNN Option string; dnnMethodName = ""TMVA_DNN_CPU""; ; # use GPU if available; dnnOptions = ""CPU""; if hasGPU :; dnnOptions = ""GPU""; dnnMethodName = ""TMVA_DNN_GPU""; ; factory.BookMethod(; loader,; TMVA.Types.kDL,; dnnMethodName,; H=False,; V=True,; ErrorStrategy=""CROSSENTROPY"",; VarTransform=None,; WeightInitialization=""XAVIER"",; Layout=layoutString,; TrainingStrategy=trainingString1,; Architecture=dnnOptions; ); ; ; ### Book Convolutional Neural Network in TMVA; ; # For building a CNN one needs to define; ; # - Input Layout : number of channels (in this case = 1) | image height | image width; # - Batch Layout : batch size | number of channels | image size = (height*width); ; # Then one add Convolutional layers and MaxPool layers.; ; # - For Convolutional layer the option string has to be:; # - CONV | number of units | filter height | filter width | stride height | stride width | padding height | paddig; # width | activation function; ; # - note in this case we are using a filer 3x3 and padding=1 and stride=1 so we get the output dimen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:10591,avail,available,10591,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['avail'],['available']
Availability,.6 1; : 733 Minimum Test error found - save the configuration ; : 733 | 21.6244 23.3245 0.0201038 0.00181384 43739.9 0; : 734 | 21.7205 24.0895 0.02004 0.0017539 43749.1 1; : 735 Minimum Test error found - save the configuration ; : 735 | 21.2911 23.0542 0.0200889 0.00181051 43767.5 0; : 736 Minimum Test error found - save the configuration ; : 736 | 20.9485 22.9069 0.0201996 0.00182864 43547 0; : 737 Minimum Test error found - save the configuration ; : 737 | 20.4393 22.6213 0.0200735 0.00180745 43797.2 0; : 738 Minimum Test error found - save the configuration ; : 738 | 20.2862 22.4457 0.0201199 0.00181602 43706.6 0; : 739 Minimum Test error found - save the configuration ; : 739 | 20.1208 22.4048 0.0200963 0.00181207 43753.7 0; : 740 Minimum Test error found - save the configuration ; : 740 | 19.913 22.3841 0.0200932 0.00181057 43757.3 0; : 741 Minimum Test error found - save the configuration ; : 741 | 19.6956 22.1693 0.0200949 0.00182186 43780.3 0; : 742 Minimum Test error found - save the configuration ; : 742 | 19.5563 22.0339 0.0201148 0.00182382 43737.3 0; : 743 Minimum Test error found - save the configuration ; : 743 | 19.2633 21.9202 0.0201113 0.00181809 43732 0; : 744 Minimum Test error found - save the configuration ; : 744 | 18.9779 21.4146 0.0200848 0.00181658 43791.8 0; : 745 | 19.0558 21.8309 0.0200351 0.00176335 43783.5 1; : 746 Minimum Test error found - save the configuration ; : 746 | 18.8292 21.203 0.0201069 0.00182679 43763.3 0; : 747 Minimum Test error found - save the configuration ; : 747 | 18.4234 20.9247 0.0201054 0.00181179 43731.2 0; : 748 Minimum Test error found - save the configuration ; : 748 | 18.2054 20.8597 0.0200854 0.00181067 43776.4 0; : 749 Minimum Test error found - save the configuration ; : 749 | 17.9119 20.8249 0.0200825 0.00181515 43794.1 0; : 750 | 17.7295 20.9077 0.0200909 0.00176261 43648.3 1; : 751 Minimum Test error found - save the configuration ; : 751 | 17.6646 20.1562 0.02009 0.00181812 43783 0; : 752 Minimum T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:93160,error,error,93160,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.9 0; : 563 Minimum Test error found - save the configuration ; : 563 | 188.987 113.393 0.0203794 0.00207901 43715 0; : 564 Minimum Test error found - save the configuration ; : 564 | 186.85 112.339 0.0201831 0.00181479 43553.4 0; : 565 Minimum Test error found - save the configuration ; : 565 | 185.071 111.259 0.0203048 0.00182605 43292.9 0; : 566 Minimum Test error found - save the configuration ; : 566 | 182.616 110.112 0.0201778 0.00183613 43616.5 0; : 567 Minimum Test error found - save the configuration ; : 567 | 180.473 109.26 0.0202561 0.00182678 43409.1 0; : 568 Minimum Test error found - save the configuration ; : 568 | 178.451 108.059 0.0201373 0.00182611 43689.1 0; : 569 Minimum Test error found - save the configuration ; : 569 | 176.264 106.78 0.0201111 0.00181323 43721.1 0; : 570 Minimum Test error found - save the configuration ; : 570 | 174.355 105.885 0.0201445 0.00181905 43655.2 0; : 571 | 172.647 106.784 0.0200848 0.0017791 43702.2 1; : 572 Minimum Test error found - save the configuration ; : 572 | 170.589 104.683 0.020165 0.00182763 43626.8 0; : 573 Minimum Test error found - save the configuration ; : 573 | 168.468 102.528 0.0201413 0.00182619 43679.9 0; : 574 Minimum Test error found - save the configuration ; : 574 | 166.622 102.085 0.0201407 0.00181861 43663.2 0; : 575 Minimum Test error found - save the configuration ; : 575 | 164.293 100.588 0.0203765 0.00182671 43127.2 0; : 576 Minimum Test error found - save the configuration ; : 576 | 162.136 99.7953 0.0201485 0.00182291 43654.8 0; : 577 Minimum Test error found - save the configuration ; : 577 | 160.429 98.8873 0.0202404 0.00182125 43433.1 0; : 578 Minimum Test error found - save the configuration ; : 578 | 158.663 98.2522 0.020118 0.00181189 43701.3 0; : 579 Minimum Test error found - save the configuration ; : 579 | 156.666 96.9925 0.0201133 0.00181082 43710 0; : 580 Minimum Test error found - save the configuration ; : 580 | 154.635 96.1367 0.0201142 0.00181294 43712.9 0; : 581 Minim,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:75630,error,error,75630,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.9 0; : 679 Minimum Test error found - save the configuration ; : 679 | 43.1003 36.3421 0.0201203 0.00181258 43697.4 0; : 680 Minimum Test error found - save the configuration ; : 680 | 42.8206 35.8087 0.0201316 0.00181818 43683.7 0; : 681 Minimum Test error found - save the configuration ; : 681 | 42.0593 35.186 0.0205402 0.00185408 42812.5 0; : 682 Minimum Test error found - save the configuration ; : 682 | 41.3592 34.9319 0.0201181 0.00182063 43721.9 0; : 683 | 40.8775 34.9951 0.020058 0.00175108 43699.3 1; : 684 Minimum Test error found - save the configuration ; : 684 | 40.654 34.3931 0.0201589 0.00183818 43666.4 0; : 685 Minimum Test error found - save the configuration ; : 685 | 40.0613 33.8904 0.0201577 0.00183348 43658.1 0; : 686 | 39.3281 34.3645 0.0200576 0.00176772 43739.9 1; : 687 | 38.8187 34.1117 0.0201676 0.00177122 43486.9 2; : 688 Minimum Test error found - save the configuration ; : 688 | 38.3466 33.422 0.0201552 0.00185044 43704.5 0; : 689 Minimum Test error found - save the configuration ; : 689 | 37.998 33.2339 0.0201139 0.00182328 43738.2 0; : 690 Minimum Test error found - save the configuration ; : 690 | 37.3126 32.8977 0.0200976 0.0018112 43748.3 0; : 691 Minimum Test error found - save the configuration ; : 691 | 36.956 32.4497 0.0202163 0.00185879 43578.8 0; : 692 | 36.3494 32.5119 0.0203375 0.00178876 43129.6 1; : 693 Minimum Test error found - save the configuration ; : 693 | 35.9446 31.7942 0.0202985 0.00181447 43280.7 0; : 694 | 35.3125 31.8389 0.0201438 0.00175333 43500.7 1; : 695 Minimum Test error found - save the configuration ; : 695 | 34.8867 31.3734 0.0201347 0.00182018 43681.2 0; : 696 Minimum Test error found - save the configuration ; : 696 | 34.4357 31.1348 0.0201081 0.00181563 43733.9 0; : 697 Minimum Test error found - save the configuration ; : 697 | 34.0416 30.9812 0.0205543 0.00184744 42765.1 0; : 698 Minimum Test error found - save the configuration ; : 698 | 33.7716 30.3897 0.0201321 0.00181458 43673.9 0; : 699 | 33.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:88197,error,error,88197,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.9 0; : 734 | 21.7205 24.0895 0.02004 0.0017539 43749.1 1; : 735 Minimum Test error found - save the configuration ; : 735 | 21.2911 23.0542 0.0200889 0.00181051 43767.5 0; : 736 Minimum Test error found - save the configuration ; : 736 | 20.9485 22.9069 0.0201996 0.00182864 43547 0; : 737 Minimum Test error found - save the configuration ; : 737 | 20.4393 22.6213 0.0200735 0.00180745 43797.2 0; : 738 Minimum Test error found - save the configuration ; : 738 | 20.2862 22.4457 0.0201199 0.00181602 43706.6 0; : 739 Minimum Test error found - save the configuration ; : 739 | 20.1208 22.4048 0.0200963 0.00181207 43753.7 0; : 740 Minimum Test error found - save the configuration ; : 740 | 19.913 22.3841 0.0200932 0.00181057 43757.3 0; : 741 Minimum Test error found - save the configuration ; : 741 | 19.6956 22.1693 0.0200949 0.00182186 43780.3 0; : 742 Minimum Test error found - save the configuration ; : 742 | 19.5563 22.0339 0.0201148 0.00182382 43737.3 0; : 743 Minimum Test error found - save the configuration ; : 743 | 19.2633 21.9202 0.0201113 0.00181809 43732 0; : 744 Minimum Test error found - save the configuration ; : 744 | 18.9779 21.4146 0.0200848 0.00181658 43791.8 0; : 745 | 19.0558 21.8309 0.0200351 0.00176335 43783.5 1; : 746 Minimum Test error found - save the configuration ; : 746 | 18.8292 21.203 0.0201069 0.00182679 43763.3 0; : 747 Minimum Test error found - save the configuration ; : 747 | 18.4234 20.9247 0.0201054 0.00181179 43731.2 0; : 748 Minimum Test error found - save the configuration ; : 748 | 18.2054 20.8597 0.0200854 0.00181067 43776.4 0; : 749 Minimum Test error found - save the configuration ; : 749 | 17.9119 20.8249 0.0200825 0.00181515 43794.1 0; : 750 | 17.7295 20.9077 0.0200909 0.00176261 43648.3 1; : 751 Minimum Test error found - save the configuration ; : 751 | 17.6646 20.1562 0.02009 0.00181812 43783 0; : 752 Minimum Test error found - save the configuration ; : 752 | 17.2045 20.1301 0.0200899 0.00181385 43773 0; : 753 Minimum Tes,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:93274,error,error,93274,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.9 1; : 687 | 38.8187 34.1117 0.0201676 0.00177122 43486.9 2; : 688 Minimum Test error found - save the configuration ; : 688 | 38.3466 33.422 0.0201552 0.00185044 43704.5 0; : 689 Minimum Test error found - save the configuration ; : 689 | 37.998 33.2339 0.0201139 0.00182328 43738.2 0; : 690 Minimum Test error found - save the configuration ; : 690 | 37.3126 32.8977 0.0200976 0.0018112 43748.3 0; : 691 Minimum Test error found - save the configuration ; : 691 | 36.956 32.4497 0.0202163 0.00185879 43578.8 0; : 692 | 36.3494 32.5119 0.0203375 0.00178876 43129.6 1; : 693 Minimum Test error found - save the configuration ; : 693 | 35.9446 31.7942 0.0202985 0.00181447 43280.7 0; : 694 | 35.3125 31.8389 0.0201438 0.00175333 43500.7 1; : 695 Minimum Test error found - save the configuration ; : 695 | 34.8867 31.3734 0.0201347 0.00182018 43681.2 0; : 696 Minimum Test error found - save the configuration ; : 696 | 34.4357 31.1348 0.0201081 0.00181563 43733.9 0; : 697 Minimum Test error found - save the configuration ; : 697 | 34.0416 30.9812 0.0205543 0.00184744 42765.1 0; : 698 Minimum Test error found - save the configuration ; : 698 | 33.7716 30.3897 0.0201321 0.00181458 43673.9 0; : 699 | 33.1269 30.7769 0.0201928 0.00175872 43397.8 1; : 700 Minimum Test error found - save the configuration ; : 700 | 32.8076 30.1388 0.0201025 0.00181993 43757.5 0; : 701 | 32.6014 30.2991 0.0200398 0.0017563 43755.4 1; : 702 | 32.0925 30.8793 0.0200419 0.00175584 43749.1 2; : 703 Minimum Test error found - save the configuration ; : 703 | 31.9128 29.3224 0.0202722 0.00182152 43358.7 0; : 704 Minimum Test error found - save the configuration ; : 704 | 31.2876 29.167 0.0201013 0.00181585 43750.6 0; : 705 Minimum Test error found - save the configuration ; : 705 | 30.8198 28.9852 0.0201048 0.0018126 43734.4 0; : 706 Minimum Test error found - save the configuration ; : 706 | 30.3399 28.5636 0.0203047 0.00182247 43284.8 0; : 707 | 29.8899 28.5807 0.0200458 0.00176314 43757.3 1; : 708 | 29.64,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:88990,error,error,88990,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,".998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; ... (remaining 14 messages suppressed); ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=-3.35967 cHl3=-9.58704 cHq3=-6.27461; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.154263 cHl3=2.95902 cHq3=-2.78828; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=59.1285, denominator=wrap_pdf_Int[pTV]=200921; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Erro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:14434,recover,recover,14434,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Availability,".; 156 ; 157void TLeaf::Browse(TBrowser* b); 158{; 159 if (strchr(GetName(), '.')) {; 160 fBranch->GetTree()->Draw(GetName(), """", b ? b->GetDrawOption() : """");; 161 } else {; 162 if ((fBranch->GetListOfLeaves()->GetEntries() > 1) ||; 163 (strcmp(fBranch->GetName(), GetName()) != 0)) {; 164 TString name(fBranch->GetName());; 165 if (!name.EndsWith(""."")) name += ""."";; 166 name += GetName();; 167 fBranch->GetTree()->Draw(name, """", b ? b->GetDrawOption() : """");; 168 } else {; 169 fBranch->GetTree()->Draw(GetName(), """", b ? b->GetDrawOption() : """");; 170 }; 171 }; 172 if (gPad) {; 173 gPad->Update();; 174 }; 175}; 176 ; 177////////////////////////////////////////////////////////////////////////////////; 178/// Pack leaf elements in Basket output buffer.; 179 ; 180void TLeaf::FillBasket(TBuffer &); 181{; 182}; 183 ; 184////////////////////////////////////////////////////////////////////////////////; 185/// If the class supports it, generate an offset array base.; 186///; 187/// This class only returns `nullptr` on error.; 188Int_t *TLeaf::GenerateOffsetArrayBase(Int_t base, Int_t events) const; 189{; 190 // In order to avoid a virtual call, we assume ROOT developers will override; 191 // the default GenerateOffsetArray for cases where this function does not apply.; 192 ; 193 Int_t *retval = new Int_t[events];; 194 if (R__unlikely(!retval || !fLeafCount)) {; 195 delete [] retval;; 196 return nullptr;; 197 }; 198 ; 199 Long64_t orig_entry = std::max(fBranch->GetReadEntry(), 0LL); // -1 indicates to start at the beginning; 200 const std::vector<Int_t> *countValues = fLeafCount->GetLeafCountValues(orig_entry, events);; 201 ; 202 if (!countValues || ((Int_t)countValues->size()) < events) {; 203 Error(""GenerateOffsetArrayBase"", ""The leaf %s could not retrieve enough entries from its branch count (%s), ask for %d and got %ld"",; 204 GetName(), fLeafCount->GetName(), events, (long)(countValues ? countValues->size() : -1));; 205 delete [] retval;; 206 return nullptr;; 207 }; 208 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLeaf_8cxx_source.html:5526,error,error,5526,doc/master/TLeaf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLeaf_8cxx_source.html,1,['error'],['error']
Availability,".; 1669/// Id is file system type (machine dependend, see statfs()); 1670/// Bsize is block size of file system; 1671/// Blocks is total number of blocks in file system; 1672/// Bfree is number of free blocks in file system; 1673/// The function returns 0 in case of success and 1 if the file system could; 1674/// not be stat'ed.; 1675 ; 1676int TUnixSystem::GetFsInfo(const char *path, Long_t *id, Long_t *bsize,; 1677 Long_t *blocks, Long_t *bfree); 1678{; 1679 return UnixFSstat(path, id, bsize, blocks, bfree);; 1680}; 1681 ; 1682////////////////////////////////////////////////////////////////////////////////; 1683/// Create a link from file1 to file2. Returns 0 when successful,; 1684/// -1 in case of failure.; 1685 ; 1686int TUnixSystem::Link(const char *from, const char *to); 1687{; 1688 return ::link(from, to);; 1689}; 1690 ; 1691////////////////////////////////////////////////////////////////////////////////; 1692/// Create a symlink from file1 to file2. Returns 0 when successful,; 1693/// -1 in case of failure.; 1694 ; 1695int TUnixSystem::Symlink(const char *from, const char *to); 1696{; 1697#if defined(R__AIX); 1698 return ::symlink((char*)from, (char*)to);; 1699#else; 1700 return ::symlink(from, to);; 1701#endif; 1702}; 1703 ; 1704////////////////////////////////////////////////////////////////////////////////; 1705/// Unlink, i.e. remove, a file or directory. Returns 0 when successful,; 1706/// -1 in case of failure.; 1707 ; 1708int TUnixSystem::Unlink(const char *name); 1709{; 1710 TSystem *helper = FindHelper(name);; 1711 if (helper); 1712 return helper->Unlink(name);; 1713 ; 1714#if defined(R__SEEK64); 1715 struct stat64 finfo;; 1716 if (lstat64(name, &finfo) < 0); 1717#else; 1718 struct stat finfo;; 1719 if (lstat(name, &finfo) < 0); 1720#endif; 1721 return -1;; 1722 ; 1723 if (S_ISDIR(finfo.st_mode)); 1724 return ::rmdir(name);; 1725 else; 1726 return ::unlink(name);; 1727}; 1728 ; 1729//---- expand the metacharacters as in the shell --------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:52250,failure,failure,52250,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['failure'],['failure']
Availability,".; 633Int_t TGeoManager::AddRegion(TGeoRegion *region); 634{; 635 Int_t size = fRegions->GetEntriesFast();; 636 fRegions->Add(region);; 637 return size;; 638}; 639 ; 640////////////////////////////////////////////////////////////////////////////////; 641/// Add a user-defined property. Returns true if added, false if existing.; 642 ; 643Bool_t TGeoManager::AddProperty(const char *property, Double_t value); 644{; 645 auto pos = fProperties.insert(ConstPropMap_t::value_type(property, value));; 646 if (!pos.second) {; 647 Warning(""AddProperty"", ""Property \""%s\"" already exists with value %g"", property, (pos.first)->second);; 648 return false;; 649 }; 650 return true;; 651}; 652 ; 653////////////////////////////////////////////////////////////////////////////////; 654/// Get a user-defined property; 655 ; 656Double_t TGeoManager::GetProperty(const char *property, Bool_t *error) const; 657{; 658 auto pos = fProperties.find(property);; 659 if (pos == fProperties.end()) {; 660 if (error); 661 *error = kTRUE;; 662 return 0.;; 663 }; 664 if (error); 665 *error = kFALSE;; 666 return pos->second;; 667}; 668 ; 669////////////////////////////////////////////////////////////////////////////////; 670/// Get a user-defined property from a given index; 671 ; 672Double_t TGeoManager::GetProperty(size_t i, TString &name, Bool_t *error) const; 673{; 674 // This is a quite inefficient way to access map elements, but needed for the GDML writer to; 675 if (i >= fProperties.size()) {; 676 if (error); 677 *error = kTRUE;; 678 return 0.;; 679 }; 680 size_t pos = 0;; 681 auto it = fProperties.begin();; 682 while (pos < i) {; 683 ++it;; 684 ++pos;; 685 }; 686 if (error); 687 *error = kFALSE;; 688 name = (*it).first;; 689 return (*it).second;; 690}; 691 ; 692////////////////////////////////////////////////////////////////////////////////; 693/// Add a matrix to the list. Returns index of the matrix in list.; 694 ; 695Int_t TGeoManager::AddTransformation(const TGeoMatrix *matrix); 696{; 697 retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:25170,error,error,25170,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,2,['error'],['error']
Availability,".; 6495/// The algorithm makes a copy of the histogram, then loops on all bins; 6496/// of the old histogram to fill the extended histogram.; 6497/// Takes into account errors (Sumw2) if any.; 6498/// The algorithm works for 1-d, 2-D and 3-D histograms.; 6499/// The axis must be extendable before invoking this function.; 6500/// Ex:; 6501///; 6502/// ~~~ {.cpp}; 6503/// h->GetXaxis()->SetCanExtend(kTRUE);; 6504/// ~~~; 6505 ; 6506void TH1::ExtendAxis(Double_t x, TAxis *axis); 6507{; 6508 if (!axis->CanExtend()) return;; 6509 if (TMath::IsNaN(x)) { // x may be a NaN; 6510 SetCanExtend(kNoAxis);; 6511 return;; 6512 }; 6513 ; 6514 if (axis->GetXmin() >= axis->GetXmax()) return;; 6515 if (axis->GetNbins() <= 0) return;; 6516 ; 6517 Double_t xmin, xmax;; 6518 if (!FindNewAxisLimits(axis, x, xmin, xmax)); 6519 return;; 6520 ; 6521 //save a copy of this histogram; 6522 TH1 *hold = (TH1*)IsA()->New();; 6523 hold->SetDirectory(nullptr);; 6524 Copy(*hold);; 6525 //set new axis limits; 6526 axis->SetLimits(xmin,xmax);; 6527 ; 6528 ; 6529 //now loop on all bins and refill; 6530 Int_t errors = GetSumw2N();; 6531 ; 6532 Reset(""ICE""); //reset only Integral, contents and Errors; 6533 ; 6534 int iaxis = 0;; 6535 if (axis == &fXaxis) iaxis = 1;; 6536 if (axis == &fYaxis) iaxis = 2;; 6537 if (axis == &fZaxis) iaxis = 3;; 6538 bool firstw = kTRUE;; 6539 Int_t binx,biny, binz = 0;; 6540 Int_t ix = 0,iy = 0,iz = 0;; 6541 Double_t bx,by,bz;; 6542 Int_t ncells = hold->GetNcells();; 6543 for (Int_t bin = 0; bin < ncells; ++bin) {; 6544 hold->GetBinXYZ(bin,binx,biny,binz);; 6545 bx = hold->GetXaxis()->GetBinCenter(binx);; 6546 ix = fXaxis.FindFixBin(bx);; 6547 if (fDimension > 1) {; 6548 by = hold->GetYaxis()->GetBinCenter(biny);; 6549 iy = fYaxis.FindFixBin(by);; 6550 if (fDimension > 2) {; 6551 bz = hold->GetZaxis()->GetBinCenter(binz);; 6552 iz = fZaxis.FindFixBin(bz);; 6553 }; 6554 }; 6555 // exclude underflow/overflow; 6556 double content = hold->RetrieveBinContent(bin);; 6557 if (conte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:257520,error,errors,257520,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,".; Definition at line 1454 of file TGraphMultiErrors.cxx. ◆ GetErrorY() [2/2]. Double_t TGraphMultiErrors::GetErrorY ; (; Int_t ; i, . Int_t ; e . ); const. virtual . Get error e on y coordinate for point i. ; In case of asymmetric errors the mean of the square sum is returned ; Definition at line 1468 of file TGraphMultiErrors.cxx. ◆ GetErrorYhigh() [1/2]. Double_t TGraphMultiErrors::GetErrorYhigh ; (; Int_t ; i); const. overridevirtual . Get high error on y coordinate for point i. ; The multiple errors of the dimensions are summed according to fSumErrorsMode. ; Reimplemented from TGraph.; Definition at line 1530 of file TGraphMultiErrors.cxx. ◆ GetErrorYhigh() [2/2]. Double_t TGraphMultiErrors::GetErrorYhigh ; (; Int_t ; i, . Int_t ; e . ); const. virtual . Get high error e on y coordinate for point i. ; Definition at line 1566 of file TGraphMultiErrors.cxx. ◆ GetErrorYlow() [1/2]. Double_t TGraphMultiErrors::GetErrorYlow ; (; Int_t ; i); const. overridevirtual . Get low error on y coordinate for point i. ; The multiple errors of the dimensions are summed according to fSumErrorsMode. ; Reimplemented from TGraph.; Definition at line 1504 of file TGraphMultiErrors.cxx. ◆ GetErrorYlow() [2/2]. Double_t TGraphMultiErrors::GetErrorYlow ; (; Int_t ; i, . Int_t ; e . ); const. virtual . Get low error e on y coordinate for point i. ; Definition at line 1555 of file TGraphMultiErrors.cxx. ◆ GetEXhigh(). Double_t * TGraphMultiErrors::GetEXhigh ; (; ); const. inlineoverridevirtual . Reimplemented from TGraph.; Definition at line 142 of file TGraphMultiErrors.h. ◆ GetEXlow(). Double_t * TGraphMultiErrors::GetEXlow ; (; ); const. inlineoverridevirtual . Reimplemented from TGraph.; Definition at line 141 of file TGraphMultiErrors.h. ◆ GetEYhigh() [1/2]. Double_t * TGraphMultiErrors::GetEYhigh ; (; ); const. overridevirtual . Get all high errors on y coordinates as an array summed according to fSumErrorsMode. ; Reimplemented from TGraph.; Definition at line 1588 of file TGraphMul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphMultiErrors.html:63860,error,error,63860,doc/master/classTGraphMultiErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphMultiErrors.html,1,['error'],['error']
Availability,".; Definition at line 370 of file RooAbsReal.h. ◆ isSelectedComp(). bool RooAbsReal::isSelectedComp ; (; ); const. If true, the current pdf is a selected component (for use in plotting) ; Definition at line 2956 of file RooAbsReal.cxx. ◆ isValid(). bool RooAbsReal::isValid ; (; ); const. inlineoverrideprotectedvirtual . Check if current value is valid. ; Reimplemented from RooAbsArg.; Reimplemented in RooRealIntegral.; Definition at line 445 of file RooAbsReal.h. ◆ isValidReal(). virtual bool RooAbsReal::isValidReal ; (; double ; , . bool ; printError = false . ); const. inlineprotectedvirtual . Interface function to check if given value is a valid value for this object. Returns true unless overridden. ; Reimplemented in RooAbsRealLValue, RooRealIntegral, RooFormulaVar, and RooGenericPdf.; Definition at line 447 of file RooAbsReal.h. ◆ logEvalError() [1/2]. void RooAbsReal::logEvalError ; (; const char * ; message, . const char * ; serverValueString = nullptr . ); const. Log evaluation error message. ; Evaluation errors may be routed through a different protocol than generic RooFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:119941,error,error,119941,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['error'],['error']
Availability,".; Definition at line 377 of file RooAbsReal.h. ◆ isSelectedComp(). bool RooAbsReal::isSelectedComp ; (; ); const. If true, the current pdf is a selected component (for use in plotting) ; Definition at line 3041 of file RooAbsReal.cxx. ◆ isValid(). bool RooAbsReal::isValid ; (; ); const. inlineoverrideprotectedvirtual . Check if current value is valid. ; Reimplemented from RooAbsArg.; Reimplemented in RooRealIntegral.; Definition at line 452 of file RooAbsReal.h. ◆ isValidReal(). virtual bool RooAbsReal::isValidReal ; (; double ; , . bool ; printError = false . ); const. inlineprotectedvirtual . Interface function to check if given value is a valid value for this object. Returns true unless overridden. ; Reimplemented in RooAbsRealLValue, RooRealIntegral, RooFormulaVar, and RooGenericPdf.; Definition at line 454 of file RooAbsReal.h. ◆ logEvalError() [1/2]. void RooAbsReal::logEvalError ; (; const char * ; message, . const char * ; serverValueString = nullptr . ); const. Log evaluation error message. ; Evaluation errors may be routed through a different protocol than generic RooFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:121271,error,error,121271,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['error'],['error']
Availability,".; Definition at line 8848 of file TH1.cxx. ◆ SetBins() [3/6]. void TH1::SetBins ; (; Int_t ; nx, . const Double_t * ; xBins, . Int_t ; ny, . const Double_t * ; yBins, . Int_t ; nz, . const Double_t * ; zBins . ). virtual . Redefine x, y and z axis parameters with variable bin sizes. ; The X, Y and Z axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1, zBins is supposed to be of length nz+1 ; Reimplemented in TProfile3D, TProfile, and TProfile2D.; Definition at line 8905 of file TH1.cxx. ◆ SetBins() [4/6]. void TH1::SetBins ; (; Int_t ; nx, . Double_t ; xmin, . Double_t ; xmax . ). virtual . Redefine x axis parameters. ; The X axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange ; Reimplemented in TProfile, TProfile2D, and TProfile3D.; Definition at line 8767 of file TH1.cxx. ◆ SetBins() [5/6]. void TH1::SetBins ; (; Int_t ; nx, . Double_t ; xmin, . Double_t ; xmax, . Int_t ; ny, . Double_t ; ymin, . Double_t ; ymax . ). virtual . Redefine x and y axis parameters. ; The X and Y axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange ; Reimplemented in TProfile2D, TProfile, and TProfile3D.; Definition at line 8820 of file TH1.cxx. ◆ SetBins() [6/6]. void TH1::SetBins ; (; Int_t ; nx, . Double_t ; xmin, . Double_t ; xmax, . Int_t ; ny, . Double_t ; ymin, . Double_t ; ymax, . Int_t ; nz, . Double_t ; zmin, . Double_t ; zmax . ). virtual . Redefine x, y and z axis parameters. ; The X, Y and Z axis parameters are modified. The bins content array is resized if errors (Sumw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:206931,error,errors,206931,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,2,['error'],['errors']
Availability,".; Example:; void atest() {; TH1F *h1 = new TH1F(""h1"",""h1"",110,-110,0);; TH1F *h2 = new TH1F(""h2"",""h2"",220,0,110);; TH1F *h3 = new TH1F(""h3"",""h3"",330,-55,55);; TRandom r;; for (Int_t i=0;i<10000;i++) {; h1->Fill(r.Gaus(-55,10));; h2->Fill(r.Gaus(55,10));; h3->Fill(r.Gaus(0,10));; }. TList *list = new TList;; list->Add(h1);; list->Add(h2);; list->Add(h3);; TH1F *h = (TH1F*)h1->Clone(""h"");; h->Reset();; h.Merge(list);; h->Draw();; }. void Multiply(TF1* h1, Double_t c1 = 1); Performs the operation: this = this*c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Multiply(const TH1* h1); -*-*-*-*-*-*-*-*-*Multiply this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this*h1. If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this histogram by multiplication of h1 by h2*-*. this = (c1*h1)*(c2*h2). If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Paint(Option_t* option = """"); -*-*-*-*-*-*-*Control routine to paint any kind of histogram",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:93082,error,errors,93082,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,9,"['avail', 'error']","['available', 'errors']"
Availability,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:10839,error,error,10839,root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,15,['error'],['error']
Availability,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2010-09-23 19:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:10905,error,error,10905,root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,15,['error'],['error']
Availability,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:10907,error,error,10907,root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,15,['error'],['error']
Availability,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:10907,error,error,10907,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,15,['error'],['error']
Availability,".; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); Add 'incpath' to the inc path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t RemoveDynamicPath(const char* libpath, Bool_t onClient = kFALSE); Remove 'libpath' from the lib path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t RemoveIncludePath(const char* incpath, Bool_t onClient = kFALSE); Remove 'incpath' from the inc path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. void HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Handle lib, inc search paths modification request. TList * GetListOfPackages(); Get from the master the list of names of the packages available. TList * GetListOfEnabledPackages(); Get from the master the list of names of the packages enabled. void PrintProgress(Long64_t total, Long64_t processed, Float_t procTime = -1., Long64_t bytesread = -1); Print a progress bar on stderr. Used in batch mode. void Progress(Long64_t total, Long64_t processed); Get query progress information. Connect a slot to this signal; to track progress. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Get query progress information. Connect a slot to this signal; to track progress. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Get query progress information. Connect a slot to this signal; to track progress. void Feedback(TList* objs); Get list of feedback objects. Connect a slot to this sign",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:69561,avail,available,69561,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,3,['avail'],['available']
Availability,".; TH1::GetEntries() - returns the number of entries.; TH1::GetAsymmetry(TH1 *h2,Double_t c2,Double_tdc2). returns an histogram containing the asymmetry of this histogram with h2, where the asymmetry is defined as:. Asymmetry = (h1 - h2)/(h1 + h2); //where h1 = this. It works for 1D , 2D , etc. histograms. The parameter c2 is an optional argument that gives a relative weight between the two histograms, and dc 2 is the error on this weight. This is useful, for example, when forming an asymmetry between two histograms from two different data sets that need to be normalized to each other in some way. The function calculates the errors assuming Poisson statistics on h1 and h2 (that is, dh=sqrt(h)). In the next example we assume that h1 and h2 are already filled:. h3 = h1->GetAsymmetry(h2);. Then h3 is created and filled with the asymmetry between h1 and h2 ; h1 and h2 are left intact.; Note that the user’s responsibility is to manage the created histograms.; TH1::Reset() - resets the bin contents and errors of a histogram. 3.13 Important note on returned statistics (GetMean, GetStdDev, etc.); By default, histogram statistics are computed at fill time using the unbinned data used to update the bin content. This means the values returned by GetMean, GetStdDev, etc., are those of the dataset used to fill the histogram, not those of the binned content of the histogram itself, unless one of the axes has been zoomed. (See the documentation on TH1::GetStats().) This is useful if you want to keep track of the mean and standard deviation of the dataset you are visualizing with the histogram, but it can lead to some unintuitive results.; For example, suppose you have a histogram with one bin between 0 and 100, then you fill it with a Gaussian dataset with mean 20 and standard deviation 2:; TH1F * h = new TH1F(""h"", ""h"", 1, 0, 100);; for(int i=0; i<10000; i++) h->Fill(gRandom->Gaus(20, 2));; Right now, h->GetMean() will return 20 and h->GetStdDev() will return 2; ROOT calculated the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:118055,error,errors,118055,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['error'],['errors']
Availability,".; The default (full) range can be denoted with Range("""") / NormRange("""").; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) only plotting range ''; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) p.d.f. curve is normalized using explicit choice of ranges 'fit_nll_model_modelData'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) p.d.f was fitted in a subrange and no explicit Range() and NormRange() was specified. Plotting / normalising in fit range. To override, do one of the following; - Clear the automatic fit range attribute: <pdf>.removeStringAttribute(""fitrange"");; - Explicitly specify the plotting range: Range(""<rangeName>"").; - Explicitly specify where to compute the normalisation: NormRange(""<rangeName>"").; The default (full) range can be denoted with Range("""") / NormRange("""").; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) only plotting range 'fit_nll_model_modelData'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) p.d.f. curve is normalized using explicit choice of ranges 'fit_nll_model_modelData'; result of fit on all data ; ; RooFitResult: minimized FCN value: 25939.4, estimated distance to minimum: 3.77183e-06; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; f 5.0441e-01 +/- 6.32e-03; mx -2.1605e-02 +/- 1.77e-02; ; result of fit in in signal region (note increased error on signal fraction); ; RooFitResult: minimized FCN value: 10339.5, estimated distance to minimum: 0.000279216; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; f 4.8979e-01 +/- 1.62e-02; mx -2.1518e-02 +/- 1.79e-02; ; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf203_ranges.C. tutorialsroofitrf203_ranges.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf203__ranges_8C.html:8178,error,error,8178,doc/master/rf203__ranges_8C.html,https://root.cern,https://root.cern/doc/master/rf203__ranges_8C.html,1,['error'],['error']
Availability,".; This is particularly important if you fit the histogram after TH1::Divide. void Divide(const TH1* h1); -*-*-*-*-*-*-*-*-*Divide this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this/h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; See the other TH1::Divide that gives the possibility to optionaly; compute Binomial errors. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Scale. void Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this histogram by the division of h1 by h2*-*-*. this = c1*h1/(c2*h2). if errors are defined (see TH1::Sumw2), errors are also recalculated; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. Please note also that in the binomial case errors are calculated using standard; binomial statistics, which means when b1 = b2, the error is zero.; If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; error for the case b1=b2. void Draw(Option_t* option = """"); -*-*-*-*-*-*-*-*-*Draw this histogram with options*-*-*-*-*-*-*-*-*-*-*-*. Histograms are drawn via th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:58529,error,errors,58529,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,4,['error'],['errors']
Availability,".; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Create biuned dataset; # -----------------------------------------; ; d = model.generate({x}, 10000); dh = d.binnedClone(); ; # Construct a chi^2 of the data and the model.; # When a p.d.f. is used in a chi^2 fit, probability density scaled; # by the number of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf602__chi2fit_8py.html:2214,error,error,2214,doc/master/rf602__chi2fit_8py.html,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html,1,['error'],['error']
Availability,".C:8; For example: gStyle->SetOptStat(11);; displays only the name of histogram and the number of entries, whereas: gStyle->SetOptStat(1101);; displays the name of histogram, mean value and RMS.; WARNING 1: never do: gStyle->SetOptStat(0001111);; but instead do: gStyle->SetOptStat(1111);; because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions gStyle->SetOptStat(1);; is taken as: gStyle->SetOptStat(1111); To print only the name of the histogram do: gStyle->SetOptStat(1000000001);; NOTE that in case of 2D histograms, when selecting only underflow (10000) or overflow (100000), the statistics box will show all combinations of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters kKsSiourRmMen k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed; R#define R(a, b, c, d, e, f, g, h, i)Definition RSha256.hxx:110; For example, to print only name of histogram and number of entries do: gStyle->SetOptStat(""ne"");; To print only the name of the histogram do: gStyle->SetOptStat(""n"");; The default value is: gStyle->SetOptStat(""nemr"");; When a histogram is painted, a TPaveStats object is created and added to the list of functions of the histogram. If a TPaveStats object already exists in the histogram list of functions, the existing object is just updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using h->FindObject(""stats""). In the command line it is enough to do: Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); h#define h(i)Definition RSha256",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPaveStats.html:2948,error,error,2948,doc/master/classTPaveStats.html,https://root.cern,https://root.cern/doc/master/classTPaveStats.html,4,['error'],['error']
Availability,".Definition DataRange.h:35; ROOT::Fit::DataRange::AddRangevoid AddRange(unsigned int icoord, double xmin, double xmax)add a range [xmin,xmax] for the new coordinate icoord Adding a range does not delete existing one,...Definition DataRange.cxx:94; ROOT::Fit::DataRange::Sizeunsigned int Size(unsigned int icoord=0) constreturn range size for coordinate icoord (starts from zero) Size == 0 indicates no range is present [-...Definition DataRange.h:71; ROOT::Fit::DataRange::GetRangevoid GetRange(unsigned int irange, unsigned int icoord, double &xmin, double &xmax) constget the i-th range for given coordinate.Definition DataRange.h:104; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(bool on=true)set Minos errors computation to be performed after fittingDefinition FitConfig.h:229; ROOT::Fit::FitConfig::SetNormErrorsvoid SetNormErrors(bool on=true)set the option to normalize the error on the result according to chi2/ndfDefinition FitConfig.h:223; ROOT::Fit::FitConfig::NormalizeErrorsbool NormalizeErrors() constflag to check if resulting errors are be normalized according to chi2/ndfDefinition FitConfig.h:202; ROOT::Fit::FitConfig::SetMinimizerOptionsvoid SetMinimizerOptions(const ROOT::Math::MinimizerOptions &minopt)set all the minimizer options using class MinimizerOptionsDefinition FitConfig.cxx:257; ROOT::Fit::FitConfig::SetWeightCorrectionvoid SetWeightCorrection(bool on=true)apply the weight correction for error matrix computationDefinition FitConfig.h:232; ROOT::Fit::FitConfig::SetParabErrorsvoid SetParabErrors(bool on=true)set parabolic errorsDefinition FitConfig.h:226; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer pack",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitImpl_8cxx_source.html:46023,error,errors,46023,doc/master/HFitImpl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitImpl_8cxx_source.html,1,['error'],['errors']
Availability,".Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TMarker::Printvoid Print(Option_t *option="""") const overrideDump this marker with its attributes.Definition TMarker.cxx:339; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf601_intminuitDefinition rf601_intminuit.py:1; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sigma_g2=3.995, ; prevFCN = 2660.194127 frac=0.5812, sigma_g2=3.889, ; prevFCN = 2660.146969 frac=0.5429, sigma_g2=3.941, ; prevFCN = 2659.83839 frac=0.5459, ; prevFCN = 2659.836693 frac=0.5398, ; prevFCN = 2659.841351 frac=0.5429, sigma_g2=3.946, ; prevFCN = 2659.835035 sigma_g2=3.936, ; prevFCN = 2659.842919 frac=0.5497, sig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf601__intminuit_8C.html:6062,error,error,6062,doc/master/rf601__intminuit_8C.html,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html,3,"['avail', 'error']","['available', 'error']"
Availability,".Definition TMath.h:686; TMath::ACosHDouble_t ACosH(Double_t)Returns the nonnegative area hyperbolic cosine of x.Definition TMath.cxx:81; TMath::BesselK0Double_t BesselK0(Double_t x)Modified Bessel function I_0(x)Definition TMath.cxx:1460; TMath::BesselY0Double_t BesselY0(Double_t x)Bessel function J1(x) for any real x.Definition TMath.cxx:1705; TMath::BetaCfDouble_t BetaCf(Double_t x, Double_t a, Double_t b)Continued fraction evaluation by modified Lentz's method used in calculation of incomplete Beta funct...Definition TMath.cxx:2020; TMath::ErfInverseDouble_t ErfInverse(Double_t x)Returns the inverse error function.Definition TMath.cxx:208; TMath::LaplaceDistDouble_t LaplaceDist(Double_t x, Double_t alpha=0, Double_t beta=1)Computes the probability density function of Laplace distribution at point x, with location parameter...Definition TMath.cxx:2364; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::ErfcDouble_t Erfc(Double_t x)Computes the complementary error function erfc(x).Definition TMath.cxx:199; TMath::VavilovIDouble_t VavilovI(Double_t x, Double_t kappa, Double_t beta2)Returns the value of the Vavilov cumulative distribution function (lower tail integral of the probabi...Definition TMath.cxx:2815; TMath::BetaDouble_t Beta(Double_t p, Double_t q)Calculates Beta-function Gamma(p)*Gamma(q)/Gamma(p+q).Definition TMath.cxx:2011; TMath::PoissonDouble_t Poisson(Double_t x, Double_t par)Computes the Poisson distribution function for (x,par).Definition TMath.cxx:587; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::BesselJ0Double_t BesselJ0(Double_t x)Modified Bessel function K_1(x)Definition TMath.cxx:1634; TMath::GammaDouble_t Gamma(Double_t z)Computation of gamma(z) for all z.Definition TMath.cxx:353; TMath::MinShort_t Min(Short_t a, Short_t b)Retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:125515,error,error,125515,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['error'],['error']
Availability,".Definition TObjArray.cxx:694; TObjArray::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TObjArray.cxx:415; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::operator=TObject & operator=(const TObject &rhs)TObject assignment operator.Definition TObject.h:296; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoElement_8cxx_source.html:78086,error,error,78086,doc/master/TGeoElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html,1,['error'],['error']
Availability,".Definition TSpectrumFit.cxx:1859. Definition at line 1859 of file TSpectrumFit.cxx. ◆ GetAmplitudes(). Double_t * TSpectrumFit::GetAmplitudes ; (; ); const. inline . Definition at line 116 of file TSpectrumFit.h. ◆ GetAmplitudesErrors(). Double_t * TSpectrumFit::GetAmplitudesErrors ; (; ); const. inline . Definition at line 117 of file TSpectrumFit.h. ◆ GetAreas(). Double_t * TSpectrumFit::GetAreas ; (; ); const. inline . Definition at line 118 of file TSpectrumFit.h. ◆ GetAreasErrors(). Double_t * TSpectrumFit::GetAreasErrors ; (; ); const. inline . Definition at line 119 of file TSpectrumFit.h. ◆ GetBackgroundParameters(). void TSpectrumFit::GetBackgroundParameters ; (; Double_t & ; a0, . Double_t & ; a0Err, . Double_t & ; a1, . Double_t & ; a1Err, . Double_t & ; a2, . Double_t & ; a2Err . ). This function gets the background parameters and their errors. . a0 - gets the fitted value of a0 parameter; a0Err - gets error value of a0 parameter; a1 - gets the fitted value of a1 parameter; a1Err - gets error value of a1 parameter; a2 - gets the fitted value of a2 parameter; a2Err - gets error value of a2 parameter . Definition at line 2742 of file TSpectrumFit.cxx. ◆ GetChi(). Double_t TSpectrumFit::GetChi ; (; ); const. inline . Definition at line 121 of file TSpectrumFit.h. ◆ GetPositions(). Double_t * TSpectrumFit::GetPositions ; (; ); const. inline . Definition at line 122 of file TSpectrumFit.h. ◆ GetPositionsErrors(). Double_t * TSpectrumFit::GetPositionsErrors ; (; ); const. inline . Definition at line 123 of file TSpectrumFit.h. ◆ GetSigma(). void TSpectrumFit::GetSigma ; (; Double_t & ; sigma, . Double_t & ; sigmaErr . ). This function gets the sigma parameter and its error. . sigma - gets the fitted value of sigma parameter; sigmaErr - gets error value of sigma parameter . Definition at line 2727 of file TSpectrumFit.cxx. ◆ GetTailParameters(). void TSpectrumFit::GetTailParameters ; (; Double_t & ; t, . Double_t & ; tErr, . Double_t & ; b, . Double_t & ; bErr,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumFit.html:42699,error,error,42699,doc/master/classTSpectrumFit.html,https://root.cern,https://root.cern/doc/master/classTSpectrumFit.html,3,['error'],['error']
Availability,".Gaus();; }; for (i=fraction; i<npoints; i++){; //the bad part of the sample; x[i]=r.Uniform(-1, 1);; e[i]=1;; y[i] = 1 + 2*x[i] + 3*x[i]*x[i] + 4*x[i]*x[i]*x[i] + r.Landau(10, 5);; }; ; TGraphErrors *grr = new TGraphErrors(npoints, x, y, nullptr, e);; grr->SetMinimum(-30);; grr->SetMaximum(80);; TF1 *ffit1 = new TF1(""ffit1"", ""pol3"", -5, 5);; TF1 *ffit2 = new TF1(""ffit2"", ""pol3"", -5, 5);; ffit1->SetLineColor(kBlue);; ffit2->SetLineColor(kRed);; TCanvas *myc = new TCanvas(""myc"", ""Linear and robust linear fitting"");; myc->SetGrid();; grr->Draw(""ap"");; //first, let's try to see the result sof ordinary least-squares fit:; printf(""Ordinary least squares:\n"");; grr->Fit(ffit1);; //the fitted function doesn't really follow the pattern of the data; //and the coefficients are far from the real ones; ; printf(""Resistant Least trimmed squares fit:\n"");; //Now let's try the resistant regression; //The option ""rob=0.75"" means that we want to use robust fitting and; //we know that at least 75% of data is good points (at least 50% of points; //should be good to use this algorithm). If you don't specify any number; //and just use ""rob"" for the option, default value of (npoints+nparameters+1)/2; //will be taken; grr->Fit(ffit2, ""+rob=0.75"");; //; TLegend *leg = new TLegend(0.6, 0.8, 0.89, 0.89);; leg->AddEntry(ffit1, ""Ordinary least squares"", ""l"");; leg->AddEntry(ffit2, ""LTS regression"", ""l"");; leg->Draw();; ; delete [] x;; delete [] y;; delete [] e;; ; }; e#define e(i)Definition RSha256.hxx:103; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; TF1.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TGraphErrors.h; TLegend.h; TRandom.h; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasTh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/fitLinearRobust_8C.html:2568,robust,robust,2568,doc/master/fitLinearRobust_8C.html,https://root.cern,https://root.cern/doc/master/fitLinearRobust_8C.html,1,['robust'],['robust']
Availability,".Gaus(-55,10));; h2->Fill(r.Gaus(55,10));; h3->Fill(r.Gaus(0,10));; }. TList *list = new TList;; list->Add(h1);; list->Add(h2);; list->Add(h3);; TH1F *h = (TH1F*)h1->Clone(""h"");; h->Reset();; h->Merge(list);; h->Draw();; }. Bool_t Multiply(TF1* h1, Double_t c1 = 1); Performs the operation: this = this*c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. The function return kFALSE if the Multiply operation failed. Bool_t Multiply(const TH1* h1); Multiply this histogram by h1. this = this*h1. If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. The function return kFALSE if the Multiply operation failed. Bool_t Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2. this = (c1*h1)*(c2*h2). If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. The function return kFALSE if the Multiply operation failed. void Paint(Option_t* option = """"); Control routine to paint any kind of histograms. This function is automatically called by TCanvas::Update.; (see TH1::Draw for the list",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:101425,error,errors,101425,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['error'],['errors']
Availability,".GetName())<< ""determined event sample size to select test sample from=""<<useForTesting<<Endl;; 1255 ; 1256 ; 1257 ; 1258 // associate undefined events; 1259 if( splitMode == ""ALTERNATE"" ){; 1260 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""split 'ALTERNATE'"" << Endl;; 1261 Int_t nTraining = availableTraining;; 1262 for( EventVector::iterator it = eventVectorUndefined.begin(), itEnd = eventVectorUndefined.end(); it != itEnd; ){; 1263 ++nTraining;; 1264 if( nTraining <= requestedTraining ){; 1265 eventVectorTraining.insert( eventVectorTraining.end(), (*it) );; 1266 ++it;; 1267 }; 1268 if( it != itEnd ){; 1269 eventVectorTesting.insert( eventVectorTesting.end(), (*it) );; 1270 ++it;; 1271 }; 1272 }; 1273 } else {; 1274 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""split '"" << splitMode << ""'"" << Endl;; 1275 ; 1276 // test if enough events are available; 1277 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""availableundefined : "" << availableUndefined << Endl;; 1278 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""useForTraining : "" << useForTraining << Endl;; 1279 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""useForTesting : "" << useForTesting << Endl;; 1280 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""availableTraining : "" << availableTraining << Endl;; 1281 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""availableTesting : "" << availableTesting << Endl;; 1282 ; 1283 if( availableUndefined<(useForTraining-availableTraining) ||; 1284 availableUndefined<(useForTesting -availableTesting ) ||; 1285 availableUndefined<(useForTraining+useForTesting-availableTraining-availableTesting ) ){; 1286 Log() << kFATAL << Form(""Dataset[%s] : "",dsi.GetName())<< ""More events requested than available!"" << Endl;; 1287 }; 1288 ; 1289 // select the events; 1290 if (useForTraining>availableTraining){; 1291 eventVectorTraining.insert( eventVectorTraining.end() , eventVectorUndefined.begin(), eventVectorUndef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:55750,avail,availableundefined,55750,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,2,['avail'],"['availableUndefined', 'availableundefined']"
Availability,".GetNrows());; 428 ; 429 if (!TGraph::CtorAllocate()); 430 return;; 431 ; 432 if (!CtorAllocate()); 433 return;; 434 ; 435 Int_t itvXL = tvX.GetLwb();; 436 Int_t itvYL = tvY.GetLwb();; 437 Int_t itvExLL = tvExL.GetLwb();; 438 Int_t itvExHL = tvExH.GetLwb();; 439 Int_t itvEyLL = tvEyL.GetLwb();; 440 Int_t itvEyHL = tvEyH.GetLwb();; 441 ; 442 for (Int_t i = 0; i < fNpoints; i++) {; 443 fX[i] = tvX(itvXL + i);; 444 fY[i] = tvY(itvYL + i);; 445 fExL[i] = tvExL(itvExLL + i);; 446 fExH[i] = tvExH(itvExHL + i);; 447 fEyL[0][i] = tvEyL(itvEyLL + i);; 448 fEyH[0][i] = tvEyH(itvEyHL + i);; 449 }; 450 ; 451 CalcYErrorsSum();; 452}; 453 ; 454////////////////////////////////////////////////////////////////////////////////; 455/// Constructor with six vectors of doubles in input and a single y error dimension.; 456/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 457/// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; 458/// and the errors from vectors `tvExL`, `tvExH` and `tvEyL`, `tvEyH`.; 459/// The number of points in the graph is the minimum of number of points; 460/// in `tvX` and `tvY`.; 461 ; 462TGraphMultiErrors::TGraphMultiErrors(const TVectorD &tvX, const TVectorD &tvY, const TVectorD &tvExL,; 463 const TVectorD &tvExH, const TVectorD &tvEyL, const TVectorD &tvEyH, Int_t m); 464 : fNYErrors(1), fSumErrorsMode(m); 465{; 466 fNpoints = TMath::Min(tvX.GetNrows(), tvY.GetNrows());; 467 ; 468 if (!TGraph::CtorAllocate()); 469 return;; 470 ; 471 if (!CtorAllocate()); 472 return;; 473 ; 474 Int_t itvXL = tvX.GetLwb();; 475 Int_t itvYL = tvY.GetLwb();; 476 Int_t itvExLL = tvExL.GetLwb();; 477 Int_t itvExHL = tvExH.GetLwb();; 478 Int_t itvEyLL = tvEyL.GetLwb();; 479 Int_t itvEyHL = tvEyH.GetLwb();; 480 ; 481 for (Int_t i = 0; i < fNpoints; i++) {; 482 fX[i] = tvX(i + itvXL);; 483 fY[i] = tvY(i + itvYL);; 484 fExL[i] = tvExL(i + itvExLL);; 485 fExH[i] = tvExH(i + itvExHL);; 486 fEyL[0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:16753,error,errors,16753,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,".M.Antia, 2nd edition""; if the argument params is null, the current function parameters are used, otherwise the parameters in params are used.; the argument eps may be specified to control the step size (precision). the step size is taken as eps*(xmax-xmin). the default value (0.001) should be good enough for the vast majority of functions. Give a smaller value if your function has many changes of the second derivative in the function range.; Getting the error via TF1::DerivativeError: (total error = roundoff error + interpolation error) the estimate of the roundoff error is taken as follows: ; \[; err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; \]. where k is the double precision, ai are coefficients used in central difference formulas interpolation error is decreased by making the step size h smaller.; AuthorAnna Kreshuk ; Definition at line 1243 of file TF1.cxx. ◆ DerivativeError(). Double_t TF1::DerivativeError ; (; ). static . Static function returning the error of the last call to the of Derivative's functions. ; Definition at line 1277 of file TF1.cxx. ◆ DistancetoPrimitive(). Int_t TF1::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Compute distance from point px,py to a function. ; Compute the closest distance of approach from point px,py to this function. The distance is computed in pixels units.; Note that px is called with a negative value when the TF1 is in TGraph or TH1 list of functions. In this case there is no point looking at the histogram axis. ; Reimplemented from TObject.; Reimplemented in TF2, and TF3.; Definition at line 1293 of file TF1.cxx. ◆ DoCreateHistogram(). TH1 * TF1::DoCreateHistogram ; (; Double_t ; xmin, . Double_t ; xmax, . Bool_t ; recreate = kFALSE . ). protectedvirtual . Create histogram with bin content equal to function value computed at the bin center This histogram will be used to paint the function A re-creation is forced and a new histogram is done if recreate=true. ; Definition at line",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:66361,error,error,66361,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['error'],['error']
Availability,".]/pathfile?readaheadsz=100000""; e. set the cache remove policy; ""root://server1:port1[,server2:port2,...]/pathfile?rmpolicy=1""; f. set the max number of redirections; ""root://server1:port1[,server2:port2,...]/pathfile?mxredir=2""; (multiple options can be set concurrently). ~TXNetFile(); Destructor. void FormUrl(TUrl uut, TString& uu); Form url for rootd socket. Int_t ParseOptions(const char* opts, Int_t& cachesz, Int_t& readaheadsz, Int_t& rmpolicy, Int_t& mxredir, Int_t& rastrategy, Int_t& readtrimblksz); Parse input options for cache parameters. void CreateXClient(const char* url, Option_t* option, Int_t netopt, Bool_t parallelopen); The real creation work is done here. Int_t GetRootdProtocol(TSocket* s); Find out the remote rootd protocol version.; Returns -1 in case of error. Bool_t Open(Option_t* option, Bool_t parallelopen); The real creation work is done here. Bool_t ReadBuffer(char* buf, Int_t len); Override TNetFile::ReadBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Pass through to TNetFile implementation which will call back eventually; to our ReadBuffer with 2 arguments to deal with xrootd errors. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Implementation dealing with the xrootd server.; Returns kTRUE in case of errors.; This is the same as TXNetFile::ReadBuffer but using the async; call from xrootd. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReadBuffer; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure.; Note: This is the overloading made in TXNetFile. If ReadBuffers; is supported by xrootd it will try to get the whole list from one single; call avoiding the latency of multiple calls. Bool_t WriteBuffer(const char* buffer, Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetFile.html:28607,error,errors,28607,root/html602/TXNetFile.html,https://root.cern,https://root.cern/root/html602/TXNetFile.html,2,['error'],['errors']
Availability,".]/pathfile?readaheadsz=100000""; e. set the cache remove policy; ""root://server1:port1[,server2:port2,...]/pathfile?rmpolicy=1""; f. set the max number of redirections; ""root://server1:port1[,server2:port2,...]/pathfile?mxredir=2""; (multiple options can be set concurrently). ~TXNetFile(); Destructor. void FormUrl(TUrl uut, TString& uu); Form url for rootd socket. Int_t ParseOptions(const char* opts, Int_t& cachesz, Int_t& readaheadsz, Int_t& rmpolicy, Int_t& mxredir, Int_t& rastrategy, Int_t& readtrimblksz); Parse input options for cache parameters. void CreateXClient(const char* url, Option_t* option, Int_t netopt, Bool_t parallelopen); The real creation work is done here. Int_t GetRootdProtocol(TSocket* s); Find out the remote rootd protocol version.; Returns -1 in case of error. Bool_t Open(Option_t* option, Bool_t parallelopen); The real creation work is done here. Bool_t ReadBuffer(char* buf, Int_t len); Override TNetFile::ReadBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Pass through to TNetFile implementation which will call back eventually; to our ReadBuffer with 2 arguments to deal with xrootd errors. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Implementation dealing with the xrootd server.; Returns kTRUE in case of errors.; This is the same as TXNetFile::ReadBuffer but using the async; call from xrootd. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure.; Note: This is the overloading made in TXNetFile, If ReadBuffers; is supported by xrootd it will try to gt the whole list from one single; call avoiding the latency of multiple calls. Bool_t WriteBuffer(const char* buffer, Int_t B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:26595,error,errors,26595,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,4,['error'],['errors']
Availability,".ch/alice/event_1.zip#3"". This function is normally only called via TFile::Open(). ; Definition at line 121 of file TArchiveFile.cxx. ◆ OpenArchive(). virtual Int_t TArchiveFile::OpenArchive ; (; ). pure virtual . Implemented in TZIPFile. ◆ operator=(). TArchiveFile & TArchiveFile::operator= ; (; const TArchiveFile & ; ). privatedelete . Not implemented because TArchiveFile can not be copied. . ◆ ParseUrl(). Bool_t TArchiveFile::ParseUrl ; (; const char * ; url, . TString & ; archive, . TString & ; member, . TString & ; type . ). staticprotected . Try to determine if url contains an anchor specifying an archive member. ; Returns kFALSE in case of an error. ; Definition at line 149 of file TArchiveFile.cxx. ◆ SetCurrentMember(). virtual Int_t TArchiveFile::SetCurrentMember ; (; ). pure virtual . Implemented in TZIPFile. ◆ SetMember() [1/2]. Int_t TArchiveFile::SetMember ; (; const char * ; member). virtual . Explicitely make the specified member the current member. ; Returns -1 in case of error, 0 otherwise. ; Definition at line 88 of file TArchiveFile.cxx. ◆ SetMember() [2/2]. Int_t TArchiveFile::SetMember ; (; Int_t ; idx). virtual . Explicitely make the member with the specified index the current member. ; Returns -1 in case of error, 0 otherwise. ; Definition at line 100 of file TArchiveFile.cxx. ◆ Streamer(). void TArchiveFile::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TZIPFile. ◆ StreamerNVirtual(). void TArchiveFile::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 61 of file TArchiveFile.h. Member Data Documentation. ◆ fArchiveName. TString TArchiveFile::fArchiveName. protected . Archive file name. ; Definition at line 31 of file TArchiveFile.h. ◆ fCurMember. TArchiveMember* TArchiveFile::fCurMember. protected . Current archive member. ; Definition at line 36 of file TArchiveFile.h. ◆ fFile. TFile* TArchiveFile::fFile. protect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTArchiveFile.html:16271,error,error,16271,doc/master/classTArchiveFile.html,https://root.cern,https://root.cern/doc/master/classTArchiveFile.html,1,['error'],['error']
Availability,".cpp}; 222 Font number TTF Names PostScript/PDF Names; 223 1 : ""Free Serif Italic"" ""Times-Italic""; 224 2 : ""Free Serif Bold"" ""Times-Bold""; 225 3 : ""Free Serif Bold Italic"" ""Times-BoldItalic""; 226 4 : ""Tex Gyre Regular"" ""Helvetica""; 227 5 : ""Tex Gyre Italic"" ""Helvetica-Oblique""; 228 6 : ""Tex Gyre Bold"" ""Helvetica-Bold""; 229 7 : ""Tex Gyre Bold Italic"" ""Helvetica-BoldOblique""; 230 8 : ""Free Mono"" ""Courier""; 231 9 : ""Free Mono Oblique"" ""Courier-Oblique""; 232 10 : ""Free Mono Bold"" ""Courier-Bold""; 233 11 : ""Free Mono Bold Oblique"" ""Courier-BoldOblique""; 234 12 : ""Symbol"" ""Symbol""; 235 13 : ""Free Serif"" ""Times-Roman""; 236 14 : ""Wingdings"" ""ZapfDingbats""; 237~~~; 238 ; 239The PostScript and PDF backends use the original PostScript-defined 13 fonts' styles; 240forming four type families (Courier, Helvetica, Times, Symbol) as listed in the; 241""Core Font Set"" section of [this page](https://en.wikipedia.org/wiki/PostScript_fonts).; 242These fonts are always available and do not need to be loaded in the PS or PDF files; 243allowing to keep the files' sizes small.; 244 ; 245On screen, text is rendered using free TTF fonts similar to the PDF ones. The corresponding; 246font files are coming with the ROOT distribution in `$ROOTSYS/fonts/Free*`.; 247 ; 248Begin_Macro; 249fonts.C; 250End_Macro; 251*/; 252 ; 253////////////////////////////////////////////////////////////////////////////////; 254/// AttText default constructor.; 255///; 256/// Default text attributes are taken from the current style.; 257 ; 258TAttText::TAttText(); 259{; 260 if (!gStyle) {; 261 ResetAttText();; 262 return;; 263 }; 264 fTextAlign = gStyle->GetTextAlign();; 265 fTextAngle = gStyle->GetTextAngle();; 266 fTextColor = gStyle->GetTextColor();; 267 fTextFont = gStyle->GetTextFont();; 268 fTextSize = gStyle->GetTextSize();; 269}; 270 ; 271////////////////////////////////////////////////////////////////////////////////; 272/// AttText normal constructor.; 273///; 274/// Text attributes are taken from the argum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TAttText_8cxx_source.html:8365,avail,available,8365,doc/master/TAttText_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html,1,['avail'],['available']
Availability,".cxx. ◆ AssignDtd(). void TXMLEngine::AssignDtd ; (; XMLDocPointer_t ; xmldoc, . const char * ; dtdname, . const char * ; rootname . ). assigns dtd filename to document ; Definition at line 1274 of file TXMLEngine.cxx. ◆ Class(). static TClass * TXMLEngine::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TXMLEngine::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TXMLEngine::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 108 of file TXMLEngine.h. ◆ CleanNode(). void TXMLEngine::CleanNode ; (; XMLNodePointer_t ; xmlnode). remove all children node from xmlnode ; Definition at line 1235 of file TXMLEngine.cxx. ◆ DeclFileName(). static const char * TXMLEngine::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 108 of file TXMLEngine.h. ◆ DisplayError(). void TXMLEngine::DisplayError ; (; Int_t ; error, . Int_t ; linenumber . ). protected . Displays xml parsing error. ; Definition at line 2223 of file TXMLEngine.cxx. ◆ DocGetRootElement(). XMLNodePointer_t TXMLEngine::DocGetRootElement ; (; XMLDocPointer_t ; xmldoc). returns root node of document ; Definition at line 1339 of file TXMLEngine.cxx. ◆ DocSetRootElement(). void TXMLEngine::DocSetRootElement ; (; XMLDocPointer_t ; xmldoc, . XMLNodePointer_t ; xmlnode . ). set main (root) node for document ; Definition at line 1326 of file TXMLEngine.cxx. ◆ FindNs(). XMLNsPointer_t TXMLEngine::FindNs ; (; XMLNodePointer_t ; xmlnode, . const char * ; nsname . ). protected . define if namespace of that name exists for xmlnode ; Definition at line 1562 of file TXMLEngine.cxx. ◆ FreeAllAttr(). void TXMLEngine::FreeAllAttr ; (; XMLNodePointer_t ; xmlnode). Free all attributes of the node. ; Definition at line 647 of file TXMLEngine.cxx. ◆ FreeAttr(). void TXMLEngine::FreeAttr ; (; XMLNodePointer_t ; xmlnode, . const char ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLEngine.html:24052,error,error,24052,doc/master/classTXMLEngine.html,https://root.cern,https://root.cern/doc/master/classTXMLEngine.html,1,['error'],['error']
Availability,".cxx. ◆ BinData() [4/7]. ROOT::Fit::BinData::BinData ; (; unsigned int ; n, . const double * ; dataX, . const double * ; val, . const double * ; ex, . const double * ; eval . ). constructors using external data ; constructor from external data for 1D with errors on coordinate and value ; Definition at line 73 of file BinData.cxx. ◆ BinData() [5/7]. ROOT::Fit::BinData::BinData ; (; unsigned int ; n, . const double * ; dataX, . const double * ; dataY, . const double * ; val, . const double * ; ex, . const double * ; ey, . const double * ; eval . ). constructor from external data for 2D with errors on coordinate and value ; Definition at line 111 of file BinData.cxx. ◆ BinData() [6/7]. ROOT::Fit::BinData::BinData ; (; unsigned int ; n, . const double * ; dataX, . const double * ; dataY, . const double * ; dataZ, . const double * ; val, . const double * ; ex, . const double * ; ey, . const double * ; ez, . const double * ; eval . ). constructor from external data for 3D with errors on coordinate and value ; Definition at line 149 of file BinData.cxx. ◆ ~BinData(). ROOT::Fit::BinData::~BinData ; (; ). override . destructor ; Definition at line 188 of file BinData.cxx. ◆ BinData() [7/7]. ROOT::Fit::BinData::BinData ; (; const BinData & ; rhs). copy constructors ; Definition at line 221 of file BinData.cxx. Member Function Documentation. ◆ Add() [1/8]. void ROOT::Fit::BinData::Add ; (; const double * ; x, . double ; val . ). add multi-dim coordinate data with only value ; Definition at line 504 of file BinData.cxx. ◆ Add() [2/8]. void ROOT::Fit::BinData::Add ; (; const double * ; x, . double ; val, . const double * ; ex, . double ; elval, . double ; ehval . ). add multi-dim coordinate data with both error in coordinates and value ; Definition at line 577 of file BinData.cxx. ◆ Add() [3/8]. void ROOT::Fit::BinData::Add ; (; const double * ; x, . double ; val, . const double * ; ex, . double ; eval . ). add multi-dim coordinate data with both error in coordinates and value ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html:16654,error,errors,16654,doc/master/classROOT_1_1Fit_1_1BinData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html,1,['error'],['errors']
Availability,".cxx. ◆ SetBinContent() [1/3]. void TH2Poly::SetBinContent ; (; Int_t ; bin, . Double_t ; content . ). overridevirtual . Sets the contents of the input bin to the input content Negative values between -1 and -9 are for the overflows and the sea. ; Reimplemented from TH2.; Definition at line 1407 of file TH2Poly.cxx. ◆ SetBinContent() [2/3]. void TH2Poly::SetBinContent ; (; Int_t ; , . Int_t ; , . Double_t ;  . ). inlineoverrideprotectedvirtual . NOT IMPLEMENTED for TH2Poly. ; Reimplemented from TH2.; Definition at line 149 of file TH2Poly.h. ◆ SetBinContent() [3/3]. void TH2Poly::SetBinContent ; (; Int_t ; , . Int_t ; , . Int_t ; , . Double_t ;  . ). inlineoverrideprotectedvirtual . NOT IMPLEMENTED for TH2Poly. ; Reimplemented from TH2.; Definition at line 150 of file TH2Poly.h. ◆ SetBinContentChanged(). void TH2Poly::SetBinContentChanged ; (; Bool_t ; flag). inline . Definition at line 122 of file TH2Poly.h. ◆ SetBinError() [1/3]. void TH2Poly::SetBinError ; (; Int_t ; bin, . Double_t ; error . ). overridevirtual . Set the bin Error. ; Re-implementation for TH2Poly given the different bin indexing in the stored squared error array. See also notes in TH1::SetBinError; Bins are in range [1:nbins] and for bin < 0 in the range [-9:-1] the errors is set for the overflow bins ; Reimplemented from TH1.; Definition at line 893 of file TH2Poly.cxx. ◆ SetBinError() [2/3]. void TH2Poly::SetBinError ; (; Int_t ; , . Int_t ; , . Double_t ;  . ). inlineoverrideprotectedvirtual . NOT IMPLEMENTED for TH2Poly. ; Reimplemented from TH1.; Definition at line 151 of file TH2Poly.h. ◆ SetBinError() [3/3]. void TH2Poly::SetBinError ; (; Int_t ; , . Int_t ; , . Int_t ; , . Double_t ;  . ). inlineoverrideprotectedvirtual . NOT IMPLEMENTED for TH2Poly. ; Reimplemented from TH1.; Definition at line 152 of file TH2Poly.h. ◆ SetFloat(). void TH2Poly::SetFloat ; (; Bool_t ; flag = true). When set to kTRUE, allows the histogram to expand if a bin outside the limits is added. ; Definition at line ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2Poly.html:85895,error,error,85895,doc/master/classTH2Poly.html,https://root.cern,https://root.cern/doc/master/classTH2Poly.html,1,['error'],['error']
Availability,".cxx. ◆ SetCovariance(). bool ROOT::Math::Minimizer::SetCovariance ; (; std::span< const double > ; cov, . unsigned int ; nrow . ). virtual . set initial covariance matrix ; set initial values for covariance/error matrix The covariance matrix must be provided in compressed form (row-major ordered upper traingular part) ; Reimplemented in ROOT::Minuit2::Minuit2Minimizer.; Definition at line 25 of file Minimizer.cxx. ◆ SetCovarianceDiag(). bool ROOT::Math::Minimizer::SetCovarianceDiag ; (; std::span< const double > ; d2, . unsigned int ; n . ). virtual . set initial second derivatives ; Reimplemented in ROOT::Minuit2::Minuit2Minimizer.; Definition at line 15 of file Minimizer.cxx. ◆ SetDefaultOptions(). void ROOT::Math::Minimizer::SetDefaultOptions ; (; ). inline . reset the default options (defined in MinimizerOptions) ; Definition at line 361 of file Minimizer.h. ◆ SetErrorDef(). void ROOT::Math::Minimizer::SetErrorDef ; (; double ; up). inline . set scale for calculating the errors ; Definition at line 347 of file Minimizer.h. ◆ SetExtraOptions(). void ROOT::Math::Minimizer::SetExtraOptions ; (; const IOptions & ; extraOptions). inline . set only the extra options ; Definition at line 358 of file Minimizer.h. ◆ SetFixedVariable(). bool ROOT::Math::Minimizer::SetFixedVariable ; (; unsigned int ; ivar, . const std::string & ; name, . double ; val . ). virtual . set a new fixed variable (override if minimizer supports them ) ; Reimplemented in ROOT::Math::GeneticMinimizer, TFumiliMinimizer, ROOT::Math::BasicMinimizer, TLinearMinimizer, TMinuitMinimizer, and ROOT::Minuit2::Minuit2Minimizer.; Definition at line 44 of file Minimizer.cxx. ◆ SetFunction(). virtual void ROOT::Math::Minimizer::SetFunction ; (; const ROOT::Math::IMultiGenFunction & ; func). pure virtual . set the function to minimize ; Implemented in TFumiliMinimizer, ROOT::Math::GeneticMinimizer, ROOT::Math::BasicMinimizer, ROOT::Math::GSLMinimizer, ROOT::Math::GSLNLSMinimizer, TLinearMinimizer, TMinuitMinimi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html:27772,error,errors,27772,doc/master/classROOT_1_1Math_1_1Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html,1,['error'],['errors']
Availability,".cxx. ◆ mnpsdf(). void TMinuit::mnpsdf ; (; ). virtual . Calculates the eigenvalues of v to see if positive-def. ; if not, adds constant along diagonal to make positive. ; Definition at line 6494 of file TMinuit.cxx. ◆ mnrazz(). void TMinuit::mnrazz ; (; Double_t ; ynew, . Double_t * ; pnew, . Double_t * ; y, . Int_t & ; jh, . Int_t & ; jl . ). virtual . Called only by MNSIMP (and MNIMPR) to add a new point. ; and remove an old one from the current simplex, and get the estimated distance to minimum. ; Definition at line 6568 of file TMinuit.cxx. ◆ mnrn15(). void TMinuit::mnrn15 ; (; Double_t & ; val, . Int_t & ; inseed . ). virtual . This is a super-portable random number generator. ; It should not overflow on any 32-bit machine. The cycle is only ~10**9, so use with care! Note especially that VAL must not be undefined on input.; Set Default Starting Seed ; Definition at line 6619 of file TMinuit.cxx. ◆ mnrset(). void TMinuit::mnrset ; (; Int_t ; iopt). virtual . Resets function value and errors to UNDEFINED. . If IOPT=1,; If IOPT=0, sets only MINOS errors to undefined Called from MNCLER and whenever problem changes, for example after SET LIMITS, SET PARAM, CALL FCN 6 . Definition at line 6661 of file TMinuit.cxx. ◆ mnsave(). void TMinuit::mnsave ; (; ). virtual . Writes current parameter values and step sizes onto file ISYSSA. ; in format which can be reread by Minuit for restarting. The covariance matrix is also output if it exists. ; Definition at line 6695 of file TMinuit.cxx. ◆ mnscan(). void TMinuit::mnscan ; (; ). virtual . Scans the values of FCN as a function of one parameter. ; and plots the resulting values as a curve using MNPLOT. It may be called to scan one parameter or all parameters. retains the best function and parameter values found. ; Definition at line 6708 of file TMinuit.cxx. ◆ mnseek(). void TMinuit::mnseek ; (; ). virtual . Performs a rough (but global) minimization by monte carlo search. ; Each time a new minimum is found, the search area is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:62522,error,errors,62522,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['error'],['errors']
Availability,".cxx:249; namechar name[80]Definition TGX11.cxx:110; TGeoElement.h; STP_temperaturestatic const Double_t STP_temperatureDefinition TGeoMaterial.h:31; STP_pressurestatic const Double_t STP_pressureDefinition TGeoMaterial.h:32; TList.h; TNamed.h; TAttFillFill Area Attributes class.Definition TAttFill.h:19; TAttFill::fFillStyleStyle_t fFillStyleFill area style.Definition TAttFill.h:23; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TGDMLMatrixThis class is used in the process of reading and writing the GDML ""matrix"" tag.Definition TGDMLMatrix.h:33; TGeoElementTableTable of elements.Definition TGeoElement.h:398; TGeoElementBase class for chemical elements.Definition TGeoElement.h:36; TGeoExtensionABC for user objects attached to TGeoVolume or TGeoNode.Definition TGeoExtension.h:17; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMaterial::GetConstPropertyDouble_t GetConstProperty(const char *property, Bool_t *error=nullptr) constDefinition TGeoMaterial.cxx:392; TGeoMaterial::GetIntLenvirtual Double_t GetIntLen() constDefinition TGeoMaterial.h:110; TGeoMaterial::SetDensityvirtual void SetDensity(Double_t density)Definition TGeoMaterial.h:137; TGeoMaterial::SetZvirtual void SetZ(Double_t z)Definition TGeoMaterial.h:132; TGeoMaterial::SetUserExtensionvoid SetUserExtension(TGeoExtension *ext)Connect user-defined extension to the material.Definition TGeoMaterial.cxx:346; TGeoMaterial::GetUserExtensionTGeoExtension * GetUserExtension() constDefinition TGeoMaterial.h:118; TGeoMaterial::GetFWExtensionTGeoExtension * GetFWExtension() constDefinition TGeoMaterial.h:119; TGeoMaterial::GetCerenkovPropertiesvirtual TObject * GetCerenkovProperties() constDefinition TGeoMaterial.h:112; TGeoMaterial::fStateEGeoMaterialState fStateDefinition TGeoMaterial.h:48; TGeoMaterial::SetCerenkovPropertiesvirtual void SetCerenkovProperties(TObject *cerenkov)Definition TGeoMaterial.h:143; TGeoMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoMaterial_8h_source.html:13852,error,error,13852,doc/master/TGeoMaterial_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8h_source.html,1,['error'],['error']
Availability,".cxx:588; TGraphAsymmErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphAsymmErrors.cxx:1061; TGraphAsymmErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh)Set ex and ey values for point pointed by the mouse.Definition TGraphAsymmErrors.cxx:1299; TGraphAsymmErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on X.Definition TGraphAsymmErrors.cxx:1151; TGraphAsymmErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphAsymmErrors.h:32; TGraphAsymmErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphAsymmErrors.cxx:1033; TGraphAsymmErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t exl=0., Double_t exh=0., Double_t eyl=0., Double_t eyh=0.)Add a point with asymmetric errorbars to the graph.Definition TGraphAsymmErrors.cxx:451; TGraphAsymmErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphAsymmErrors.cxx:977; TGraphAsymmErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exl)Set EXlow for point i.Definition TGraphAsymmErrors.cxx:1348; TGraphAsymmErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Double_t eyh)Set EYhigh for point i.Definition TGraphAsymmErrors.cxx:1390; TGraphAsymmErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphAsymmErrors.cxx:1241; TGraphAsymmErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphAsymmErrors.cxx:508; TGraphAsymmErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:9351,error,errorbars,9351,doc/master/TGraphAsymmErrors_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html,1,['error'],['errorbars']
Availability,".d.f evaluates to NaN @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.186765 cHl3=8.8591 cHq3=-0.971282; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-6.32705, denominator=wrap_pdf_Int[pTV]=46316; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.218731 cHl3=0.37397 cHq3=-2.08166; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.22694 cHl3=-7.04051 cHq3=0.54016; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-2.21831, denominator=wrap_pdf_Int[pTV]=89722.5; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.44258 cHl3=4.96668 cHq3=0.0273884; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:11548,recover,recover,11548,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Availability,".d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.22694 cHl3=-7.04051 cHq3=0.54016; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-2.21831, denominator=wrap_pdf_Int[pTV]=89722.5; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.44258 cHl3=4.96668 cHq3=0.0273884; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denomi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:12765,recover,recover,12765,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Availability,".dask.org/en/stable/)):; 718 ; 719~~~{.py}; 720import ROOT; 721from dask.distributed import Client; 722 ; 723# Point RDataFrame calls to the Dask specific RDataFrame; 724RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; 725 ; 726# In a Python script the Dask client needs to be initalized in a context; 727# Jupyter notebooks / Python session don't need this; 728if __name__ == ""__main__"":; 729 # With an already setup cluster that exposes a Dask scheduler endpoint; 730 client = Client(""dask_scheduler.domain.com:8786""); 731 ; 732 # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; 733 df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); 734 # Proceed as usual; 735 df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); 736~~~; 737 ; 738If an instance of [distributed.Client](http://distributed.dask.org/en/stable/api.html#distributed.Client) is not; 739provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine; 740using all cores available.; 741 ; 742### Choosing the number of distributed tasks; 743 ; 744A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending; 745tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but; 746generically tries to infer how many cores are available in the cluster through the connection object. The number of; 747tasks will be equal to the inferred number of cores. There are cases where the connection object of the chosen backend; 748doesn't have information about the actual resources of the cluster. An example of this is when using Dask to connect to; 749a batch system. The client object created at the beginning of the application does not automatically know how many cores; 750will be available during distributed execution, since the jobs are submitted to the batch system after the creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:42732,avail,available,42732,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['avail'],['available']
Availability,".dask.org/en/stable/)):; 758 ; 759~~~{.py}; 760import ROOT; 761from dask.distributed import Client; 762 ; 763# Point RDataFrame calls to the Dask specific RDataFrame; 764RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; 765 ; 766# In a Python script the Dask client needs to be initalized in a context; 767# Jupyter notebooks / Python session don't need this; 768if __name__ == ""__main__"":; 769 # With an already setup cluster that exposes a Dask scheduler endpoint; 770 client = Client(""dask_scheduler.domain.com:8786""); 771 ; 772 # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; 773 df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); 774 # Proceed as usual; 775 df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); 776~~~; 777 ; 778If an instance of [distributed.Client](http://distributed.dask.org/en/stable/api.html#distributed.Client) is not; 779provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine; 780using all cores available.; 781 ; 782### Choosing the number of distributed tasks; 783 ; 784A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending; 785tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but; 786generically tries to infer how many cores are available in the cluster through the connection object. The number of; 787tasks will be equal to the inferred number of cores. There are cases where the connection object of the chosen backend; 788doesn't have information about the actual resources of the cluster. An example of this is when using Dask to connect to; 789a batch system. The client object created at the beginning of the application does not automatically know how many cores; 790will be available during distributed execution, since the jobs are submitted to the batch system after the creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:44372,avail,available,44372,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['avail'],['available']
Availability,".e. whether the entry is available. ; Definition at line 225 of file TTreeReader.h. ◆ SetEntryBase(). TTreeReader::EEntryStatus TTreeReader::SetEntryBase ; (; Long64_t ; entry, . bool ; local . ). protected . Load an entry into the tree, return the status of the read. ; For chains, entry is the global (i.e. not tree-local) entry number, unless local is true, in which case entry specifies the entry number within the current tree. This is needed for instance for TSelector::Process(). ; Definition at line 630 of file TTreeReader.cxx. ◆ SetLocalEntry(). EEntryStatus TTreeReader::SetLocalEntry ; (; Long64_t ; entry). inline . Set the next local tree entry. ; If a TEntryList is set, this function is equivalent to SetEntry().; Parameters. entryEntry number of the TChain's current TTree. This is the entry number passed for instance by TSelector::Process(entry), i.e. within TSelector::Process() always use SetLocalEntry() and not SetEntry()! . Returnsthe entry's read status, i.e. whether the entry is available. ; Definition at line 235 of file TTreeReader.h. ◆ SetProxies(). bool TTreeReader::SetProxies ; (; ). protected . Tell readers we now have a tree. ; fValues gets insertions during this loop (when parametrized arrays are read), invalidating iterators. Use old-school counting instead. ; Definition at line 376 of file TTreeReader.cxx. ◆ SetTree() [1/3]. void TTreeReader::SetTree ; (; const char * ; keyname, . TDirectory * ; dir, . TEntryList * ; entryList = nullptr . ). Set (or update) the which tree to read from, passing the name of a tree in a directory. ; Parameters. keyname- name of the tree in dir ; dir- the TDirectory to load keyname from (or gDirectory if nullptr) ; entryList- the TEntryList to attach to the TTreeReader. . Definition at line 846 of file TTreeReader.cxx. ◆ SetTree() [2/3]. void TTreeReader::SetTree ; (; const char * ; keyname, . TEntryList * ; entryList = nullptr . ). inline . Definition at line 198 of file TTreeReader.h. ◆ SetTree() [3/3]. void TTre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:33498,avail,available,33498,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,1,['avail'],['available']
Availability,".findModule(moduleName);; 3602 // We should never be able to build a module without having it in the; 3603 // modulemap. Still, let's print a warning that we at least tell the; 3604 // user that this could lead to problems.; 3605 if (!module) {; 3606 ROOT::TMetaUtils::Warning(nullptr,; 3607 ""Couldn't find module %s in the available modulemaps. This""; 3608 ""prevents us from correctly diagnosing wrongly built modules.\n"",; 3609 moduleName.c_str());; 3610 }; 3611 }; 3612 ; 3613 // A dictionary module could build implicitly a set of implicit modules.; 3614 // For example, the Core module builds libc.pcm and std.pcm implicitly.; 3615 // Those modules do not require I/O information and it is okay to build; 3616 // them as part of another module.; 3617 // However, we can build a module which requires I/O implictly which is; 3618 // an error because rootcling is not able to generate the corresponding; 3619 // dictionary.; 3620 // If we build a I/O requiring module implicitly we should display; 3621 // an error unless -mSystemByproducts or -mByproduct were specified.; 3622 bool isByproductModule = false;; 3623 if (module) {; 3624 // -mSystemByproducts allows implicit building of any system module.; 3625 if (module->IsSystem && gOptSystemModuleByproducts) {; 3626 isByproductModule = true;; 3627 }; 3628 // -mByproduct lists concrete module names that are allowed.; 3629 if (std::find(gOptModuleByproducts.begin(), gOptModuleByproducts.end(), moduleName) !=; 3630 gOptModuleByproducts.end()) {; 3631 isByproductModule = true;; 3632 }; 3633 }; 3634 if (!isByproductModule); 3635 fChild->HandleDiagnostic(DiagLevel, Info);; 3636 ; 3637 if (ID == remark_module_build && !isByproductModule) {; 3638 ROOT::TMetaUtils::Error(nullptr,; 3639 ""Building module '%s' implicitly. If '%s' requires a \n""; 3640 ""dictionary please specify build dependency: '%s' depends on '%s'.\n""; 3641 ""Otherwise, specify '-mByproduct %s' to disable this diagnostic.\n"",; 3642 moduleName.c_str(), moduleName.c_str(), gO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:144682,error,error,144682,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['error'],['error']
Availability,".g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general assymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to all other free parameters, and FCNBase::up() is the return value of the error definition specified by the user (default = 1.).; The algorithm for finding the positive and negative \(\mbox{MINOS}\) errors for parameter \(\mbox{n}\) consists of varying parameter \(\mbox{n}\), each time minimizing \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 1}\) variable parameters, to find numerically the two values of parameter \(\mbox{n}\) for which the minimum of \(\mbox{FCN}\) takes on the values \(\displaystyle F_{\mathrm{min}} + \mbox{up}\), where \(\displaystyle F_{\mathrm{min}}\) is the minimum of \(\mbox{FCN}\) with respect to all \(\mbox{npar}\) parameters. In order to make the procedure as fast as possible, \(\mbox{MINOS}\) uses the error matrix to predict the values of all parameters at the various sub-minima which it will have to find in the course of the calculation, and in the limit that the problem is near",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:23569,error,error,23569,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['error'],['error']
Availability,".h""; #include ""TList.h""; ; #include <vector>; #include <map>; #include <iostream>; ; double gauss2D(double *x, double *par) {; double z1 = double((x[0]-par[1])/par[2]);; double z2 = double((x[1]-par[3])/par[4]);; return par[0]*exp(-0.5*(z1*z1+z2*z2));; }; double my2Dfunc(double *x, double *par) {; double *p1 = &par[0];; double *p2 = &par[5];; return gauss2D(x,p1) + gauss2D(x,p2);; }; ; ; ; // data need to be globals to be visible by fcn; ; std::vector<std::pair<double, double> > coords;; std::vector<double > values;; std::vector<double > errors;; ; void myFcn(int & /*nPar*/, double * /*grad*/ , double &fval, double *p, int /*iflag */ ); {; int n = coords.size();; double chi2 = 0;; double tmp,x[2];; for (int i = 0; i <n; ++i ) {; x[0] = coords[i].first;; x[1] = coords[i].second;; tmp = ( values[i] - my2Dfunc(x,p))/errors[i];; chi2 += tmp*tmp;; }; fval = chi2;; }; TRandom3 rndm;; void FillHisto(TH2D * h, int n, double * p) {; ; ; const double mx1 = p[1];; const double my1 = p[3];; const double sx1 = p[2];; const double sy1 = p[4];; const double mx2 = p[6];; const double my2 = p[8];; const double sx2 = p[7];; const double sy2 = p[9];; //const double w1 = p[0]*sx1*sy1/(p[5]*sx2*sy2);; const double w1 = 0.5;; ; double x, y;; for (int i = 0; i < n; ++i) {; // generate randoms with larger Gaussians; rndm.Rannor(x,y);; ; double r = rndm.Rndm(1);; if (r < w1) {; x = x*sx1 + mx1;; y = y*sy1 + my1;; }; else {; x = x*sx2 + mx2;; y = y*sy2 + my2;; }; h->Fill(x,y);; ; }; }; ; ; ; ; int TwoHistoFit2D(bool global = true) {; ; // create two histograms; ; int nbx1 = 50;; int nby1 = 50;; int nbx2 = 50;; int nby2 = 50;; double xlow1 = 0.;; double ylow1 = 0.;; double xup1 = 10.;; double yup1 = 10.;; double xlow2 = 5.;; double ylow2 = 5.;; double xup2 = 20.;; double yup2 = 20.;; ; TH2D * h1 = new TH2D(""h1"",""core"",nbx1,xlow1,xup1,nby1,ylow1,yup1);; TH2D * h2 = new TH2D(""h2"",""tails"",nbx2,xlow2,xup2,nby2,ylow2,yup2);; ; double iniParams[10] = { 100, 6., 2., 7., 3, 100, 12., 3., 11., 2. };; /",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TwoHistoFit2D_8C.html:2618,error,errors,2618,doc/master/TwoHistoFit2D_8C.html,https://root.cern,https://root.cern/doc/master/TwoHistoFit2D_8C.html,1,['error'],['errors']
Availability,".h. ◆ BroadcastFile() [1/2]. Int_t TProof::BroadcastFile ; (; const char * ; file, . Int_t ; opt, . const char * ; rfile, . TList * ; wrks . ). private . Broadcast file to all workers in the specified list. ; Returns the number of workers the buffer was sent to. Returns -1 in case of error. ; Definition at line 2610 of file TProof.cxx. ◆ BroadcastFile() [2/2]. Int_t TProof::BroadcastFile ; (; const char * ; file, . Int_t ; opt, . const char * ; rfile = 0, . ESlaves ; list = kAllUnique . ). private . Broadcast file to all workers in the specified list. ; Returns the number of workers the buffer was sent to. Returns -1 in case of error. ; Definition at line 2639 of file TProof.cxx. ◆ BroadcastGroupPriority() [1/2]. Int_t TProof::BroadcastGroupPriority ; (; const char * ; grp, . Int_t ; priority, . ESlaves ; list = kAllUnique . ). private . Broadcast the group priority to all workers in the specified list. ; Returns the number of workers the message was successfully sent to. Returns -1 in case of error. ; Definition at line 2451 of file TProof.cxx. ◆ BroadcastGroupPriority() [2/2]. Int_t TProof::BroadcastGroupPriority ; (; const char * ; grp, . Int_t ; priority, . TList * ; workers . ). private . Broadcast the group priority to all workers in the specified list. ; Returns the number of workers the message was successfully sent to. Returns -1 in case of error. ; Definition at line 2424 of file TProof.cxx. ◆ BroadcastObject() [1/2]. Int_t TProof::BroadcastObject ; (; const TObject * ; obj, . Int_t ; kind, . TList * ; slaves . ). private . Broadcast an object to all slaves in the specified list. ; Use kind to set the TMEssage what field. Returns the number of slaves the message was sent to. Returns -1 in case of error. ; Definition at line 2543 of file TProof.cxx. ◆ BroadcastObject() [2/2]. Int_t TProof::BroadcastObject ; (; const TObject * ; obj, . Int_t ; kind = kMESS_OBJECT, . ESlaves ; list = kActive . ). private . Broadcast an object to all slaves in the specified lis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:69428,error,error,69428,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['error'],['error']
Availability,".h. ◆ GetMethodCall(). TMethodCall * TMinuit::GetMethodCall ; (; ); const. inline . Definition at line 193 of file TMinuit.h. ◆ GetNumFixedPars(). Int_t TMinuit::GetNumFixedPars ; (; ); const. virtual . returns the number of currently fixed parameters ; Definition at line 855 of file TMinuit.cxx. ◆ GetNumFreePars(). Int_t TMinuit::GetNumFreePars ; (; ); const. virtual . returns the number of currently free parameters ; Definition at line 863 of file TMinuit.cxx. ◆ GetNumPars(). Int_t TMinuit::GetNumPars ; (; ); const. virtual . returns the total number of parameters that have been defined as fixed or free. ; The constant parameters are not counted. ; Definition at line 872 of file TMinuit.cxx. ◆ GetObjectFit(). TObject * TMinuit::GetObjectFit ; (; ); const. inline . Definition at line 194 of file TMinuit.h. ◆ GetParameter(). Int_t TMinuit::GetParameter ; (; Int_t ; parNo, . Double_t & ; currentValue, . Double_t & ; currentError . ); const. virtual . return parameter value and error ; Definition at line 841 of file TMinuit.cxx. ◆ GetPlot(). virtual TObject * TMinuit::GetPlot ; (; ); const. inlinevirtual . Definition at line 200 of file TMinuit.h. ◆ GetStatus(). Int_t TMinuit::GetStatus ; (; ); const. inline . Definition at line 201 of file TMinuit.h. ◆ IsA(). TClass * TMinuit::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 268 of file TMinuit.h. ◆ Migrad(). Int_t TMinuit::Migrad ; (; ). virtual . invokes the MIGRAD minimizer ; Definition at line 880 of file TMinuit.cxx. ◆ mnamin(). void TMinuit::mnamin ; (; ). virtual . Initialize AMIN. ; Called from many places. Initializes the value of AMIN by calling the user function. Prints out the function value and parameter values if Print Flag value is high enough. ; Definition at line 972 of file TMinuit.cxx. ◆ mnbins(). void TMinuit::mnbins ; (; Double_t ; a1, . Double_t ; a2, . Int_t ; naa, . Double_t & ; bl, . Double_t & ; bh, . Int_t & ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:43024,error,error,43024,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['error'],['error']
Availability,".h. ◆ fAyInit. Double_t TSpectrum2Fit::fAyInit. protected . initial value of background ay parameter(backgroud is estimated as a0+ax*x+ay*y) ; Definition at line 92 of file TSpectrum2Fit.h. ◆ fBxCalc. Double_t TSpectrum2Fit::fBxCalc. protected . calculated value of b parameter for 1D ridges in x direction ; Definition at line 81 of file TSpectrum2Fit.h. ◆ fBxErr. Double_t TSpectrum2Fit::fBxErr. protected . error value of b parameter for 1D ridges in x direction ; Definition at line 82 of file TSpectrum2Fit.h. ◆ fBxInit. Double_t TSpectrum2Fit::fBxInit. protected . initial value of b parameter for 1D ridges in x direction (slope), for details see html manual and references ; Definition at line 80 of file TSpectrum2Fit.h. ◆ fByCalc. Double_t TSpectrum2Fit::fByCalc. protected . calculated value of b parameter for 1D ridges in y direction ; Definition at line 84 of file TSpectrum2Fit.h. ◆ fByErr. Double_t TSpectrum2Fit::fByErr. protected . error value of b parameter for 1D ridges in y direction ; Definition at line 85 of file TSpectrum2Fit.h. ◆ fByInit. Double_t TSpectrum2Fit::fByInit. protected . initial value of b parameter for 1D ridges in y direction (slope), for details see html manual and references ; Definition at line 83 of file TSpectrum2Fit.h. ◆ fChi. Double_t TSpectrum2Fit::fChi. protected . here the fitting functions return resulting chi square ; Definition at line 29 of file TSpectrum2Fit.h. ◆ fFitTaylor. Int_t TSpectrum2Fit::fFitTaylor. protected . order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. ; Definition at line 27 of file TSpectrum2Fit.h. ◆ fFixA0. Bool_t TSpectrum2Fit::fFixA0. protected . logical value of a0 parameter, which allows to fix the parameter (not to fit). ; Definition at line 113 of file TSpectrum2Fit.h. ◆ fFixAmp. Bool_t* TSpectrum2Fit::fFixAmp. protected . [fNPeaks] array of logical values which allow to fix appropriate amplitudes of 2D peaks (not fit). How",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:82080,error,error,82080,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['error'],['error']
Availability,".h:23; TCanvas::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet current canvas & pad.Definition TCanvas.cxx:719; TF11-Dim function classDefinition TF1.h:233; TF1::SetNpxvirtual void SetNpx(Int_t npx=100)Set the number of points used to draw the function.Definition TF1.cxx:3433; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::Evalvirtual Double_t Eval(Double_t x, Double_t y=0, Double_t z=0, Double_t t=0) constEvaluate this function.Definition TF1.cxx:1439; TF2A 2-Dim function with parameters.Definition TF2.h:29; TF2::GetRandom2virtual void GetRandom2(Double_t &xrandom, Double_t &yrandom, TRandom *rng=nullptr)Return 2 random numbers following this function shape.Definition TF2.cxx:547; TF2::SetNpyvirtual void SetNpy(Int_t npy=100)Set the number of points used to draw the function.Definition TF2.cxx:927; TF2::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF2.cxx:259; TGraph2DErrorsGraph 2D class with errors.Definition TGraph2DErrors.h:26; TGraph2DErrors::SetPointvoid SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) overrideSet x, y and z values for point number i.Definition TGraph2DErrors.cxx:404; TGraph2DGraphics object made of three arrays X, Y and Z with the same number of points each.Definition TGraph2D.h:41; TGraph2D::GetYDouble_t * GetY() constDefinition TGraph2D.h:124; TGraph2D::GetXDouble_t * GetX() constDefinition TGraph2D.h:123; TGraph2D::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""")Fits this graph with function with name fname Predefined functions such as gaus, expo and poln are au...Definition TGraph2D.cxx:815; TGraph2D::SetNamevoid SetName(const char *name) overrideChanges the name of this 2D graph.Definition TGraph2D.cxx:1641; TGraph2D::SetNpyvoid SetNpy(Int_t npx=40)Sets the number of bins along Y used to draw the function.Definition TGraph2D.cxx:1691; TGraph2D::SetTitlevoid SetTitle(const char *ti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ConfidenceIntervals_8C.html:5782,error,errors,5782,doc/master/ConfidenceIntervals_8C.html,https://root.cern,https://root.cern/doc/master/ConfidenceIntervals_8C.html,2,['error'],['errors']
Availability,".h:37; Long_tlong Long_tDefinition RtypesCore.h:54; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; templateClassImp#define templateClassImp(name)Definition Rtypes.h:427; kPlus@ kPlusDefinition TAttMarker.h:53; TBuffer.h; operator<=Bool_t operator<=(const TDatime &d1, const TDatime &d2)Definition TDatime.h:108; operator>Bool_t operator>(const TDatime &d1, const TDatime &d2)Definition TDatime.h:110; operator!=Bool_t operator!=(const TDatime &d1, const TDatime &d2)Definition TDatime.h:104; operator>=Bool_t operator>=(const TDatime &d1, const TDatime &d2)Definition TDatime.h:112; operator<Bool_t operator<(const TDatime &d1, const TDatime &d2)Definition TDatime.h:106; TDecompLU.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; targetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMatrixT_8cxx_source.html:125173,error,error,125173,doc/master/TMatrixT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html,1,['error'],['error']
Availability,".h:39; TApplication::ExitOnExceptionEExitOnException ExitOnException(EExitOnException opt=kExit)Set the exit on exception option.Definition TApplication.cxx:614; TApplication::KeyPressedvirtual void KeyPressed(Int_t key)Emit signal when console keyboard key was pressed.Definition TApplication.cxx:1949; TApplication::ProcessLinevirtual Longptr_t ProcessLine(const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr)Process a single command line, either a C++ statement or an interpreter command starting with a ""....Definition TApplication.cxx:1565; TApplication::fgApplicationsstatic TList * fgApplicationsDefinition TApplication.h:82; TApplication::Closestatic void Close(TApplication *app)Static function used to close a remote application.Definition TApplication.cxx:2070; TApplication::HandleTermInputvirtual Bool_t HandleTermInput()Definition TApplication.h:116; TApplication::IsRunningBool_t IsRunning() constDefinition TApplication.h:152; TApplication::SetEchoModevirtual void SetEchoMode(Bool_t mode)Set console echo mode:Definition TApplication.cxx:1968; TApplication::InputFilesTObjArray * InputFiles() constDefinition TApplication.h:146; TApplication::Helpvirtual void Help(const char *line)The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxy...Definition TApplication.cxx:1208; TApplication::LineProcessedvirtual void LineProcessed(const char *line)Emit signal when a line has been processed.Definition TApplication.cxx:1941; TApplication::ClearInputFilesvoid ClearInputFiles()Clear list containing macro files passed as program arguments.Definition TApplication.cxx:318; TApplication::fAppImpTApplicationImp * fAppImpDefinition TApplication.h:60; TApplication::TApplicationTApplication(const TApplication &)=delete; TApplication::EExitOnExceptionEExitOnExceptionDefinition TApplication.h:51; TApplication::kDontExit@ kDontExitDefinition TApplication.h:52; TApplication::kAbort@ kAbortDefinition TApplication.h:54; TApplication::kExit@",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8h_source.html:11184,echo,echo,11184,doc/master/TApplication_8h_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html,1,['echo'],['echo']
Availability,".h; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; TAxis::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn center of bin.Definition TAxis.cxx:478; TAxis::GetXmaxDouble_t GetXmax() constDefinition TAxis.h:140; TAxis::GetXminDouble_t GetXmin() constDefinition TAxis.h:139; TCanvasThe Canvas class.Definition TCanvas.h:23; TComplexDefinition TComplex.h:29; TComplex::RhoDouble_t Rho() constDefinition TComplex.h:48; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SetContourvirtual void SetContour(Int_t nlevels, const Double_t *levels=nullptr)Set the number and values of contour levels.Definition TH1.cxx:8483; TH1::SetBinsvirtual void SetBins(Int_t nx, Double_t xmin, Double_t xmax)Redefine x axis parameters.Definition TH1.cxx:8767; TH1::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TH1.cxx:8990; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2F::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH2.cxx:3972; TH2::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH2.cxx:393; TStyle::SetPadGridXvoid SetPadGridX(Bool_t gridx)Definition TStyle.h:362; TStyle::SetPadGridYvoid SetPadGridY(Bool_t gridy)Definition TStyle.h:363; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; AuthorLuigi Bardelli barde.nosp@m.lli@.nosp@m.fi.in.nosp@m.fn.i.nosp@m.t ; Definition in file mandelbrot.C. tutorialsgraphicsmandelbrot.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/mandelbrot_8C.html:4628,error,errors,4628,doc/master/mandelbrot_8C.html,https://root.cern,https://root.cern/doc/master/mandelbrot_8C.html,1,['error'],['errors']
Availability,.h;  ► matrix;  main.cpp;  ► polarcoord;  main.cpp;  ► smatrix;  matrix_op_vec.h;  matrix_util.h;  testKalman.cxx;  testOperations.cxx;  TestTimer.h;  tsc.h;  ► include;  ► Vc;  ► avx;  casts.h;  const.h;  const_data.h;  debug.h;  helperimpl.h;  intrinsics.h;  limits.h;  macros.h;  mask.h;  math.h;  shuffle.h;  sorthelper.h;  types.h;  undomacros.h;  vector.h;  vectorhelper.h;  writemaskedvector.h;  ► common;  aliasingentryhelper.h;  bitscanintrinsics.h;  deinterleave.h;  exponential.h;  fix_clang_emmintrin.h;  iif.h;  interleavedmemory.h;  logarithm.h;  macros.h;  memory.h;  memorybase.h;  memoryfwd.h;  operand.h;  operators.h;  storage.h;  support.h;  trigonometric.h;  types.h;  undomacros.h;  vectortuple.h;  windows_fix_intrin.h;  ► internal;  namespace.h;  ► scalar;  helperimpl.h;  limits.h;  macros.h;  mask.h;  math.h;  types.h;  undomacros.h;  vector.h;  writemaskedvector.h;  ► sse;  casts.h;  const.h;  const_data.h;  debug.h;  helperimpl.h;  intrinsics.h;  limits.h;  macros.h;  mask.h;  math.h;  shuffle.h;  types.h;  undomacros.h;  vector.h;  vectorhelper.h;  cpuid.h;  global.h;  support.h;  vector.h;  version.h;  ► src;  avx_sorthelper.cpp;  const.cpp;  cpuid.cpp;  support.cpp;  trigonometric.cpp;  ► tests;  arithmetics.cpp;  casts.cpp;  const.h;  convert-sincos-reference.cpp;  deinterleave.cpp;  expandandmerge.cpp;  gather.cpp;  implicit_type_conversion.cpp;  implicit_type_conversion_failures.cpp;  linkTest0.cpp;  linkTest1.cpp;  linkTestLib0.cpp;  linkTestLib1.cpp;  linkTestLib2.cpp;  linkTestLib3.cpp;  load.cpp;  mask.cpp;  math.cpp;  memory.cpp;  scalaraccess.cpp;  scatter.cpp;  sse_blend.cpp;  stlcontainer.cpp;  store.cpp;  supportfunctions.cpp;  swizzles.cpp;  ulp.h;  unittest.h;  utils.cpp;  vectormemoryhelper.h;  makeTest.py;  ► vdt;  ► include;  ► vdt;  asin.h;  atan.h;  atan2.h;  cos.h;  exp.h;  inv.h;  log.h;  sin.h;  sincos.h;  sqrt.h;  tan.h;  vdtcore_common.h;  vdtMath.h;  ► tests;  stressVdt.cxx;  ► misc;  ► memstat;  ► inc;  LinkDef.h;  TMemSt,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:58921,mask,mask,58921,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['mask'],['mask']
Availability,".hxx:100; UShort_tunsigned short UShort_tDefinition RtypesCore.h:40; Int_tint Int_tDefinition RtypesCore.h:45; kMaxIntconstexpr Int_t kMaxIntDefinition RtypesCore.h:105; Version_tshort Version_tDefinition RtypesCore.h:65; Long_tlong Long_tDefinition RtypesCore.h:54; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; TBufferFile.h; TBufferText.h; TClassEdit.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; TFile.h; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h offsetDefinition TGWin32VirtualXProxy.cxx:245; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:206484,error,error,206484,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['error'],['error']
Availability,".hxx>. Inheritance diagram for ROOT::RDataFrame:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ ColumnNames_t. using ROOT::RDataFrame::ColumnNames_t = ROOT::RDF::ColumnNames_t. Definition at line 43 of file RDataFrame.hxx. Constructor & Destructor Documentation. ◆ RDataFrame() [1/10]. ROOT::RDataFrame::RDataFrame ; (; std::string_view ; treeName, . std::string_view ; fileNameGlob, . const ColumnNames_t & ; defaultColumns = {} . ). Build the dataframe. ; Parameters. [in]treeNameName of the tree contained in the directory ; [in]filenameglobTDirectory where the tree is stored, e.g. a TFile. ; [in]defaultColumnsCollection of default columns. The filename glob supports the same type of expressions as TChain::Add(), and it is passed as-is to TChain's constructor.; The default columns are looked at in case no column is specified in the booking of actions or transformations. See alsoROOT::RDF::RInterface for the documentation of the methods available. ; Definition at line 1591 of file RDataFrame.cxx. ◆ RDataFrame() [2/10]. ROOT::RDataFrame::RDataFrame ; (; std::string_view ; datasetName, . const std::vector< std::string > & ; fileNameGlobs, . const ColumnNames_t & ; defaultColumns = {} . ). Build the dataframe. ; Parameters. [in]treeNameName of the tree contained in the directory ; [in]fileglobsCollection of file names of filename globs ; [in]defaultColumnsCollection of default columns. The filename globs support the same type of expressions as TChain::Add(), and each glob is passed as-is to TChain's constructor.; The default columns are looked at in case no column is specified in the booking of actions or transformations. See alsoROOT::RDF::RInterface for the documentation of the methods available. ; Definition at line 1615 of file RDataFrame.cxx. ◆ RDataFrame() [3/10]. ROOT::RDataFrame::RDataFrame ; (; std::string_view ; treename, . std::initializer_list< std::string > ; filenames, . const C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:106992,avail,available,106992,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['avail'],['available']
Availability,".hxx>. Inheritance diagram for ROOT::RDataFrame:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ ColumnNames_t. using ROOT::RDataFrame::ColumnNames_t = ROOT::RDF::ColumnNames_t. Definition at line 43 of file RDataFrame.hxx. Constructor & Destructor Documentation. ◆ RDataFrame() [1/10]. ROOT::RDataFrame::RDataFrame ; (; std::string_view ; treeName, . std::string_view ; fileNameGlob, . const ColumnNames_t & ; defaultColumns = {} . ). Build the dataframe. ; Parameters. [in]treeNameName of the tree contained in the directory ; [in]filenameglobTDirectory where the tree is stored, e.g. a TFile. ; [in]defaultColumnsCollection of default columns. The filename glob supports the same type of expressions as TChain::Add(), and it is passed as-is to TChain's constructor.; The default columns are looked at in case no column is specified in the booking of actions or transformations. See alsoROOT::RDF::RInterface for the documentation of the methods available. ; Definition at line 1768 of file RDataFrame.cxx. ◆ RDataFrame() [2/10]. ROOT::RDataFrame::RDataFrame ; (; std::string_view ; datasetName, . const std::vector< std::string > & ; fileNameGlobs, . const ColumnNames_t & ; defaultColumns = {} . ). Build the dataframe. ; Parameters. [in]treeNameName of the tree contained in the directory ; [in]fileglobsCollection of file names of filename globs ; [in]defaultColumnsCollection of default columns. The filename globs support the same type of expressions as TChain::Add(), and each glob is passed as-is to TChain's constructor.; The default columns are looked at in case no column is specified in the booking of actions or transformations. See alsoROOT::RDF::RInterface for the documentation of the methods available. ; Definition at line 1792 of file RDataFrame.cxx. ◆ RDataFrame() [3/10]. ROOT::RDataFrame::RDataFrame ; (; std::string_view ; treename, . std::initializer_list< std::string > ; filenames, . const C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:114359,avail,available,114359,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['avail'],['available']
Availability,".mm. ◆ ChangeProperty(). void TGCocoa::ChangeProperty ; (; Window_t ; id, . Atom_t ; property, . Atom_t ; type, . UChar_t * ; data, . Int_t ; len . ). overridevirtual . Alters the property for the specified window and causes the X server to generate a PropertyNotify event on that window. ; Parameters. [in]idthe window whose property you want to change ; [in]propertyspecifies the property name ; [in]typethe type of the property; the X server does not interpret the type but simply passes it back to an application that might ask about the window properties ; [in]datathe property data ; [in]lenthe length of the specified data format . Reimplemented from TVirtualX.; Definition at line 3816 of file TGCocoa.mm. ◆ ChangeWindowAttributes(). void TGCocoa::ChangeWindowAttributes ; (; Window_t ; id, . SetWindowAttributes_t * ; attr . ). overridevirtual . Changes the attributes of the specified window ""id"" according the values provided in ""attr"". ; The mask data member of ""attr"" specifies which window attributes are defined in the attributes argument. This mask is the bitwise inclusive OR of the valid attribute mask bits; if it is zero, the attributes are ignored. ; Reimplemented from TVirtualX.; Definition at line 1006 of file TGCocoa.mm. ◆ CheckEvent(). Bool_t TGCocoa::CheckEvent ; (; Window_t ; id, . EGEventType ; type, . Event_t & ; ev . ). overridevirtual . Check if there is for window ""id"" an event of type ""type"". ; If there is it fills in the event structure and return true. If no such event return false. ; Reimplemented from TVirtualX.; Definition at line 3547 of file TGCocoa.mm. ◆ Class(). static TClass * TGCocoa::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGCocoa::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGCocoa::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 476 of file TGCocoa.h. ◆ ClearArea(). void TGCocoa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:56188,mask,mask,56188,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['mask'],['mask']
Availability,".py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'LIKELIHOOD AND MINIMIZATION' RooFit tutorial macro #601 ; Interactive minimization with MINUIT. ; ; import ROOT; ; ; # Setup pdf and likelihood; # -----------------------------------------------; ; # Observable; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # Model (intentional strong correlations); mean = ROOT.RooRealVar(""mean"", ""mean of g1 and g2"", 0); sigma_g1 = ROOT.RooRealVar(""sigma_g1"", ""width of g1"", 3); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, mean, sigma_g1); ; sigma_g2 = ROOT.RooRealVar(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0); g2 = ROOT.RooGaussian(""g2"", ""g2"", x, mean, sigma_g2); ; frac = ROOT.RooRealVar(""frac"", ""frac"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Construct unbinned likelihood of model w.r.t. data; nll = model.createNLL(data); ; # Interactive minimization, error analysis; # -------------------------------------------------------------------------------; ; # Create MINUIT interface object; m = ROOT.RooMinimizer(nll); ; # Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(True); ; # Call MIGRAD to minimize the likelihood; m.migrad(); ; # Print values of all parameters, reflect values (and error estimates); # that are back propagated from MINUIT; model.getParameters({x}).Print(""s""); ; # Disable verbose logging; m.setVerbose(False); ; # Run HESSE to calculate errors from d2L/dp2; m.hesse(); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Run MINOS on sigma_g2 parameter only; m.minos({sigma_g2}); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Saving results, contour plots; # ---------------------------------------------------------; ; # Save a snapshot of the fit result. ROOT.This object contains the initi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf601__intminuit_8py.html:1121,error,error,1121,doc/master/rf601__intminuit_8py.html,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html,1,['error'],['error']
Availability,".reset();; 801 // DeleteLink(lnk);; 802 } else {; 803 lnk->Prev()->fNext = next;; 804 lnk->Next()->fPrev = lnk->fPrev;; 805 // DeleteLink(lnk);; 806 }; 807 fSize--;; 808 fCache.reset();; 809 Changed();; 810 } else; 811 ob->RecursiveRemove(obj);; 812 }; 813 lnk = next;; 814 }; 815}; 816 ; 817////////////////////////////////////////////////////////////////////////////////; 818/// Remove object from the list.; 819 ; 820TObject *TList::Remove(TObject *obj); 821{; 822 R__COLLECTION_WRITE_GUARD();; 823 ; 824 if (!obj) return nullptr;; 825 ; 826 Int_t idx;; 827 TObjLink *lnk = FindLink(obj, idx);; 828 ; 829 if (!lnk) return nullptr;; 830 ; 831 // return object found, which may be (pointer wise) different than the; 832 // input object (depending on what IsEqual() is doing); 833 ; 834 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 835 ; 836 TObject *ob = lnk->GetObject();; 837 lnk->SetObject(nullptr);; 838 if (lnk == fFirst.get()) {; 839 fFirst = lnk->fNext;; 840 // lnk is still alive as we have either fLast; 841 // or the 'new' fFirst->fPrev pointing to it.; 842 if (lnk == fLast.get()) {; 843 fLast.reset();; 844 fFirst.reset();; 845 } else; 846 fFirst->fPrev.reset();; 847 //DeleteLink(lnk);; 848 } else if (lnk == fLast.get()) {; 849 fLast = lnk->fPrev.lock();; 850 fLast->fNext.reset();; 851 //DeleteLink(lnk);; 852 } else {; 853 lnk->Next()->fPrev = lnk->fPrev;; 854 lnk->Prev()->fNext = lnk->fNext;; 855 //DeleteLink(lnk);; 856 }; 857 fSize--;; 858 fCache.reset();; 859 Changed();; 860 ; 861 return ob;; 862}; 863 ; 864////////////////////////////////////////////////////////////////////////////////; 865/// Remove object link (and therefore the object it contains); 866/// from the list.; 867 ; 868TObject *TList::Remove(TObjLink *lnk); 869{; 870 R__COLLECTION_WRITE_GUARD();; 871 ; 872 if (!lnk) return nullptr;; 873 ; 874 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 875 ; 876 TObject *obj = lnk->GetObject();; 877 lnk->SetObject(nullptr);; 878 if (lnk == fFirst.get()) {; 87",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:25564,alive,alive,25564,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,1,['alive'],['alive']
Availability,".root"",""recreate"");; TTree *T = new TTree(""T"",""title"");; T->Fill(); // Loop; file = T->GetCurrentFile(); // To get the pointer to the current file; file->Write();; file->Close();. NoteThis method is never called if the input file is a TMemFile or derivate. ; Definition at line 2749 of file TTree.cxx. ◆ CheckBranchAddressType(). Int_t TTree::CheckBranchAddressType ; (; TBranch * ; branch, . TClass * ; ptrClass, . EDataType ; datatype, . bool ; isptr . ). protectedvirtual . Check whether or not the address described by the last 3 parameters matches the content of the branch. ; If a Data Model Evolution conversion is involved, reset the fInfo of the branch. The return values are:; kMissingBranch (-5) : Missing branch; kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; kMatch (0) : perfect match; kMatchConversion (1) : match with (I/O) conversion; kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; kMakeClass (3) : MakeClass mode so we can not check.; kVoidPtr (4) : void* passed so no check was made.; kNoCheck (5) : Underlying TBranch not yet available so no check was made. In addition this can be multiplexed with the two bits:; kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode. This bits can be masked out by using kDecomposedObjMask . Definition at line 2867 of file TTree.cxx. ◆ Class(). static TClass * TTree::Class ; (; ). static . ReturnsTClass describing this class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:102024,error,error,102024,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['error'],['error']
Availability,".size() ?; 2514 fr.covarianceMatrix() :; 2515 fr.reducedCovarianceMatrix(paramList)) ;; 2516 ; 2517 for (std::size_t ivar=0 ; ivar<paramList.size() ; ivar++) {; 2518 ; 2519 auto& rrv = static_cast<RooRealVar&>(paramList[ivar]);; 2520 ; 2521 double cenVal = rrv.getVal() ;; 2522 double errVal = sqrt(V(ivar,ivar)) ;; 2523 ; 2524 // Make Plus variation; 2525 rrv.setVal(cenVal+errVal) ;; 2526 plusVar.push_back(getVal(nset)) ;; 2527 ; 2528 // Make Minus variation; 2529 rrv.setVal(cenVal-errVal) ;; 2530 minusVar.push_back(getVal(nset)) ;; 2531 ; 2532 rrv.setVal(cenVal) ;; 2533 }; 2534 ; 2535 // Re-evaluate this RooAbsReal with the central parameters just to be; 2536 // extra-safe that a call to `getPropagatedError()` doesn't change any state.; 2537 // It should not be necessary because thanks to the dirty flag propagation; 2538 // the RooAbsReal is re-evaluated anyway the next time getVal() is called.; 2539 // Still there are imaginable corner cases where it would not be triggered,; 2540 // for example if the user changes the RooFit operation more after the error; 2541 // propagation.; 2542 getVal(nset);; 2543 ; 2544 TMatrixDSym C(paramList.size()) ;; 2545 std::vector<double> errVec(paramList.size()) ;; 2546 for (std::size_t i=0 ; i<paramList.size() ; i++) {; 2547 errVec[i] = std::sqrt(V(i,i)) ;; 2548 for (std::size_t j=i ; j<paramList.size() ; j++) {; 2549 C(i,j) = V(i,j) / std::sqrt(V(i,i)*V(j,j));; 2550 C(j,i) = C(i,j) ;; 2551 }; 2552 }; 2553 ; 2554 // Make std::vector of variations; 2555 TVectorD F(plusVar.size()) ;; 2556 for (std::size_t j=0 ; j<plusVar.size() ; j++) {; 2557 F[j] = (plusVar[j]-minusVar[j]) * 0.5;; 2558 }; 2559 ; 2560 // Calculate error in linear approximation from variations and correlation coefficient; 2561 double sum = F*(C*F) ;; 2562 ; 2563 return sqrt(sum) ;; 2564}; 2565 ; 2566 ; 2567 ; 2568////////////////////////////////////////////////////////////////////////////////; 2569/// Plot function or PDF on frame with support for visualization of the un",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:111527,error,error,111527,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['error']
Availability,".so, .sl, .dl and then .a (for AIX). ; Reimplemented from TSystem.; Definition at line 4761 of file TUnixSystem.cxx. ◆ FindFile(). const char * TUnixSystem::FindFile ; (; const char * ; search, . TString & ; wfil, . EAccessMode ; mode = kFileExists . ). overridevirtual . Find location of file ""wfil"" in a search path. ; The search path is specified as a : separated list of directories. Return value is pointing to wfile for compatibility with Which(const char*,const char*,EAccessMode) version. ; Reimplemented from TSystem.; Definition at line 1927 of file TUnixSystem.cxx. ◆ FreeDirectory(). void TUnixSystem::FreeDirectory ; (; void * ; dirp). overridevirtual . Close a Unix file system directory. ; Reimplemented from TSystem.; Definition at line 1404 of file TUnixSystem.cxx. ◆ GetCpuInfo(). int TUnixSystem::GetCpuInfo ; (; CpuInfo_t * ; info, . Int_t ; sampleTime = 1000 . ); const. overridevirtual . Returns cpu load average and load info into the CpuInfo_t structure. ; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the interval over which the CPU load will be measured, in ms (default 1000). ; Reimplemented from TSystem.; Definition at line 5344 of file TUnixSystem.cxx. ◆ GetCryptoRandom(). Int_t TUnixSystem::GetCryptoRandom ; (; void * ; buf, . Int_t ; len . ). overridevirtual . Return cryptographic random number Fill provided buffer with random values Returns number of bytes written to buffer or -1 in case of error. ; Reimplemented from TSystem.; Definition at line 740 of file TUnixSystem.cxx. ◆ GetDirEntry(). const char * TUnixSystem::GetDirEntry ; (; void * ; dirp). overridevirtual . Get next Unix file system directory entry. Returns 0 if no more entries. ; Reimplemented from TSystem.; Definition at line 1419 of file TUnixSystem.cxx. ◆ GetDynamicPath(). const char * TUnixSystem::GetDynamicPath ; (; ). overridevirtual . Return the dynamic path (used to find shared libraries). ; Reimplemented from TSystem.; Definition at line 4738 of file TUnixSystem.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:48165,error,error,48165,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['error'],['error']
Availability,"/ (c1sq * c1sq);; 2938 }; 2939 }; 2940 ResetStats();; 2941 return kTRUE;; 2942}; 2943 ; 2944////////////////////////////////////////////////////////////////////////////////; 2945/// Replace contents of this histogram by the division of h1 by h2.; 2946///; 2947/// `this = c1*h1/(c2*h2)`; 2948///; 2949/// If errors are defined (see TH1::Sumw2), errors are also recalculated; 2950/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 2951/// if not already set.; 2952/// The resulting errors are calculated assuming uncorrelated histograms.; 2953/// However, if option =""B"" is specified, Binomial errors are computed.; 2954/// In this case c1 and c2 do not make real sense and they are ignored.; 2955///; 2956/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2957/// you should call Sumw2 before making this operation.; 2958/// This is particularly important if you fit the histogram after TH1::Divide; 2959///; 2960/// Please note also that in the binomial case errors are calculated using standard; 2961/// binomial statistics, which means when b1 = b2, the error is zero.; 2962/// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; 2963/// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; 2964/// error for the case b1=b2.; 2965///; 2966/// The function return kFALSE if the divide operation failed; 2967 ; 2968Bool_t TH1::Divide(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2, Option_t *option); 2969{; 2970 ; 2971 TString opt = option;; 2972 opt.ToLower();; 2973 Bool_t binomial = kFALSE;; 2974 if (opt.Contains(""b"")) binomial = kTRUE;; 2975 if (!h1 || !h2) {; 2976 Error(""Divide"", ""At least one of the input histograms passed does not exist (NULL)."");; 2977 return kFALSE;; 2978 }; 2979 ; 2980 // delete buffer if it is there since it will become invalid; 2981 if (fBuffer) BufferEmpty(1);; 2982 ; 2983 if (LoggedInconsistency(""Divide"", ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:117329,error,errors,117329,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"/ call, or the class is interpreted and we will call the default; 5333 // constructor that way, or no default constructor is available and; 5334 // we fail.; 5335 {; 5336 TClass__GetCallingNewRAII callingNew(defConstructor);; 5337 p = gCling->ClassInfo_New(GetClassInfo(),nElements, arena);; 5338 }; 5339 if (!p) {; 5340 Error(""NewArray with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5341 }; 5342 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5343 // There is no dictionary at all, so this is an emulated; 5344 // class; however we do have the services of a collection proxy,; 5345 // so this is an emulated STL class.; 5346 {; 5347 TClass__GetCallingNewRAII callingNew(defConstructor);; 5348 p = fCollectionProxy->NewObjectArray(nElements, arena);; 5349 }; 5350 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5351 // There is no dictionary at all and we do not have; 5352 // the services of a collection proxy available, so; 5353 // use the streamer info to approximate calling a; 5354 // constructor (basically we just make sure that the; 5355 // pointer data members are null, unless they are marked; 5356 // as preallocated with the ""->"" comment, in which case; 5357 // we default-construct an object to point at).; 5358 ; 5359 // ???BUG??? ???WHY???; 5360 // Do not register any TObject's that we create; 5361 // as a result of creating this object.; 5362 Bool_t statsave = GetObjectStat();; 5363 if(statsave) {; 5364 SetObjectStat(kFALSE);; 5365 }; 5366 ; 5367 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5368 if (!sinfo) {; 5369 Error(""NewArray with placement"", ""Cannot construct class '%s' version %d at address %p, no streamer info available!"", GetName(), fClassVersion, arena);; 5370 return nullptr;; 5371 }; 5372 ; 5373 {; 5374 TClass__GetCallingNewRAII callingNew(defConstructor);; 5375 p = { sinfo->NewArray(nElements, arena), sinfo };; 5376 }; 5377 ; 5378 // ???BUG???; 5379 // Allow TObject's",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:204796,avail,available,204796,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['avail'],['available']
Availability,"/ call, or the class is interpreted and we will call the default; 5400 // constructor that way, or no default constructor is available and; 5401 // we fail.; 5402 {; 5403 TClass__GetCallingNewRAII callingNew(defConstructor);; 5404 p = gCling->ClassInfo_New(GetClassInfo(),nElements, arena);; 5405 }; 5406 if (!p) {; 5407 Error(""NewArray with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5408 }; 5409 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5410 // There is no dictionary at all, so this is an emulated; 5411 // class; however we do have the services of a collection proxy,; 5412 // so this is an emulated STL class.; 5413 {; 5414 TClass__GetCallingNewRAII callingNew(defConstructor);; 5415 p = fCollectionProxy->NewObjectArray(nElements, arena);; 5416 }; 5417 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5418 // There is no dictionary at all and we do not have; 5419 // the services of a collection proxy available, so; 5420 // use the streamer info to approximate calling a; 5421 // constructor (basically we just make sure that the; 5422 // pointer data members are null, unless they are marked; 5423 // as preallocated with the ""->"" comment, in which case; 5424 // we default-construct an object to point at).; 5425 ; 5426 // ???BUG??? ???WHY???; 5427 // Do not register any TObject's that we create; 5428 // as a result of creating this object.; 5429 Bool_t statsave = GetObjectStat();; 5430 if(statsave) {; 5431 SetObjectStat(kFALSE);; 5432 }; 5433 ; 5434 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5435 if (!sinfo) {; 5436 Error(""NewArray with placement"", ""Cannot construct class '%s' version %d at address %p, no streamer info available!"", GetName(), fClassVersion, arena);; 5437 return nullptr;; 5438 }; 5439 ; 5440 {; 5441 TClass__GetCallingNewRAII callingNew(defConstructor);; 5442 p = { sinfo->NewArray(nElements, arena), sinfo };; 5443 }; 5444 ; 5445 // ???BUG???; 5446 // Allow TObject's",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:207547,avail,available,207547,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['avail'],['available']
Availability,"/ debug printout; 865 if (opt.Contains(""D"")) {; 866 printf("" Kolmogorov Probability = %g, Max Dist = %g\n"",prob,rdmax);; 867 }; 868 if(opt.Contains(""M"")) return rdmax;; 869 else return prob;; 870}; 871 ; 872 ; 873////////////////////////////////////////////////////////////////////////////////; 874/// Computation of Voigt function (normalised).; 875/// Voigt is a convolution of the two functions:; 876/// \f[; 877/// gauss(xx) = \frac{1}{(\sqrt{2\pi} sigma)} e^{\frac{xx^{2}}{(2 sigma{^2})}}; 878/// \f]; 879/// and; 880/// \f[; 881/// lorentz(xx) = \frac{ \frac{1}{\pi} \frac{lg}{2} }{ (xx^{2} + \frac{lg^{2}}{4}) }; 882/// \f]; 883/// \.; 884///; 885/// The Voigt function is known to be the real part of Faddeeva function also; 886/// called complex error function [2].; 887///; 888/// The algorithm was developed by J. Humlicek [1].; 889/// This code is based on fortran code presented by R. J. Wells [2].; 890/// Translated and adapted by Miha D. Puc; 891///; 892/// To calculate the Faddeeva function with relative error less than 10^(-r).; 893/// r can be set by the user subject to the constraints 2 <= r <= 5.; 894///; 895/// - [1] J. Humlicek, JQSRT, 21, 437 (1982).; 896/// - [2] [R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its Derivatives"" JQSRT 62 (1999), pp 29-48.](http://www-atm.physics.ox.ac.uk/user/wells/voigt.html); 897 ; 898Double_t TMath::Voigt(Double_t xx, Double_t sigma, Double_t lg, Int_t r); 899{; 900 if ((sigma < 0 || lg < 0) || (sigma==0 && lg==0)) {; 901 return 0; // Not meant to be for those who want to be thinner than 0; 902 }; 903 ; 904 if (sigma == 0) {; 905 return lg * 0.159154943 / (xx*xx + lg*lg /4); //pure Lorentz; 906 }; 907 ; 908 if (lg == 0) { //pure gauss; 909 return 0.39894228 / sigma * TMath::Exp(-xx*xx / (2*sigma*sigma));; 910 }; 911 ; 912 Double_t x, y, k;; 913 x = xx / sigma / 1.41421356;; 914 y = lg / 2 / sigma / 1.41421356;; 915 ; 916 Double_t r0, r1;; 917 ; 918 if (r < 2) r = 2;; 919 if (r > 5) r = 5;; 920 ; 921 r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:29474,error,error,29474,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['error'],['error']
Availability,"/ don't duplicate the horizontal line; 6538 if (Hoption.Hist != 2) {; 6539 if (yi1<ymax && yi1>ymin) {; 6540 if (xi1 < xi3 - s2x) gPad->PaintLine(xi1,yi1,xi3 - s2x,yi2);; 6541 if (xi3 + s2x < xi2) gPad->PaintLine(xi3 + s2x,yi1,xi2,yi2);; 6542 }; 6543 }; 6544 }; 6545 if (optionE && !drawmarker && (ey1 != 0 || ey2 !=0)) {; 6546 if ((yi3 < yi1) && (yi3 < ymax)) gPad->PaintLine(xi3,yi3,xi4,TMath::Min(yi1,ymax));; 6547 if ((yi1 < yi4) && (yi4 > ymin)) gPad->PaintLine(xi3,TMath::Max(yi1,ymin),xi4,yi4);; 6548 // don't duplicate the horizontal line; 6549 if (Hoption.Hist != 2) {; 6550 if (yi1<ymax && yi1>ymin) {; 6551 if (xi1 < xi3) gPad->PaintLine(xi1,yi1,xi3,yi2);; 6552 if (xi3 < xi2) gPad->PaintLine(xi3,yi1,xi2,yi2);; 6553 }; 6554 }; 6555 }; 6556 ; 6557 // draw line at the end of the error bars; 6558 ; 6559 if (option1 && drawmarker) {; 6560 ; 6561 if (yi3 < yi1-s2y && yi3 < ymax && yi3 > ymin) gPad->PaintLine(xi3 - bxsize, yi3 , xi3 + bxsize, yi3);; 6562 if (yi4 > yi1+s2y && yi4 < ymax && yi4 > ymin) gPad->PaintLine(xi3 - bxsize, yi4 , xi3 + bxsize, yi4);; 6563 if (yi1 <= ymax && yi1 >= ymin) {; 6564 if (xi1 < xi3-s2x) gPad->PaintLine(xi1 , yi1 - bysize, xi1 , yi1 + bysize);; 6565 if (xi2 > xi3+s2x) gPad->PaintLine(xi2 , yi1 - bysize, xi2 , yi1 + bysize);; 6566 }; 6567 }; 6568 ; 6569 // draw the marker; 6570 ; 6571 if (drawmarker) gPad->PaintPolyMarker(1, &xi3, &yi1);; 6572 ; 6573L30:; 6574 if (fixbin) xp += Hparam.xbinsize;; 6575 else {; 6576 if (k < last) {; 6577 delta = fH->GetBinWidth(k+1);; 6578 xp = fH->GetBinLowEdge(k+1) + 0.5*delta;; 6579 }; 6580 }; 6581 } //end of for loop; 6582 ; 6583 // draw the filled area; 6584 ; 6585 if (option3) {; 6586 TGraph graph;; 6587 graph.SetLineStyle(fH->GetLineStyle());; 6588 graph.SetLineColor(fH->GetLineColor());; 6589 graph.SetLineWidth(fH->GetLineWidth());; 6590 graph.SetFillStyle(fH->GetFillStyle());; 6591 graph.SetFillColor(fH->GetFillColor());; 6592 Int_t logx = gPad->GetLogx();; 6593 Int_t logy = gPad->GetLogy();; 6594 gP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:240602,error,error,240602,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['error'],['error']
Availability,"/ error handling; 322/// `start` defines the start symbol defined in PyRun_String (Py_eval_input,; 323/// Py_single_input, Py_file_input); 324 ; 325void PyMethodBase::PyRunString(TString code, TString errorMessage, int start) {; 326 //std::cout << ""Run: >> "" << code << std::endl;; 327 fPyReturn = PyRun_String(code, start, fGlobalNS, fLocalNS);; 328 if (!fPyReturn) {; 329 Log() << kWARNING << ""Failed to run python code: "" << code << Endl;; 330 Log() << kWARNING << ""Python error message:"" << Endl;; 331 PyErr_Print();; 332 Log() << kFATAL << errorMessage << Endl;; 333 }; 334}; 335 ; 336///////////////////////////////////////////////////////////////////////////////; 337/// Execute Python code from string; 338///; 339/// \param[in] code Python code as string; 340/// \param[in] globalNS Global Namespace for Python Session; 341/// \param[in] localNS Local Namespace for Python Session; 342///; 343/// Overloaded static Helper function to run python code; 344/// from string and throw runtime error if the Python session; 345/// is unable to execute the code; 346 ; 347void PyMethodBase::PyRunString(TString code, PyObject *globalNS, PyObject *localNS){; 348 PyObject *fPyReturn = PyRun_String(code, Py_single_input, globalNS, localNS);; 349 if (!fPyReturn) {; 350 std::cout<<""\nPython error message:\n"";; 351 PyErr_Print();; 352 throw std::runtime_error(""\nFailed to run python code: ""+code);; 353 }; 354}; 355 ; 356///////////////////////////////////////////////////////////////////////////////; 357/// Returns `const char*` from Python string in PyObject; 358///; 359/// \param[in] string Python String object; 360/// \return String representation in `const char*`; 361 ; 362const char* PyMethodBase::PyStringAsString(PyObject* string){; 363 PyObject* encodedString = PyUnicode_AsUTF8String(string);; 364 const char* cstring = PyBytes_AsString(encodedString);; 365 return cstring;; 366}; 367 ; 368//////////////////////////////////////////////////////////////////////////////////; 369/// \brie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/PyMethodBase_8cxx_source.html:11955,error,error,11955,doc/master/PyMethodBase_8cxx_source.html,https://root.cern,https://root.cern/doc/master/PyMethodBase_8cxx_source.html,1,['error'],['error']
Availability,"/ file size.; 4599///; 4600/// \note This method calls `TTree::ChangeFile` when the tree reaches a size; 4601/// greater than `TTree::fgMaxTreeSize`. This doesn't happen if the tree is; 4602/// attached to a `TMemFile` or derivate.; 4603 ; 4604Int_t TTree::Fill(); 4605{; 4606 Int_t nbytes = 0;; 4607 Int_t nwrite = 0;; 4608 Int_t nerror = 0;; 4609 Int_t nbranches = fBranches.GetEntriesFast();; 4610 ; 4611 // Case of one single super branch. Automatically update; 4612 // all the branch addresses if a new object was created.; 4613 if (nbranches == 1); 4614 ((TBranch *)fBranches.UncheckedAt(0))->UpdateAddress();; 4615 ; 4616 if (fBranchRef); 4617 fBranchRef->Clear();; 4618 ; 4619#ifdef R__USE_IMT; 4620 const auto useIMT = ROOT::IsImplicitMTEnabled() && fIMTEnabled;; 4621 ROOT::Internal::TBranchIMTHelper imtHelper;; 4622 if (useIMT) {; 4623 fIMTFlush = true;; 4624 fIMTZipBytes.store(0);; 4625 fIMTTotBytes.store(0);; 4626 }; 4627#endif; 4628 ; 4629 for (Int_t i = 0; i < nbranches; ++i) {; 4630 // Loop over all branches, filling and accumulating bytes written and error counts.; 4631 TBranch *branch = (TBranch *)fBranches.UncheckedAt(i);; 4632 ; 4633 if (branch->TestBit(kDoNotProcess)); 4634 continue;; 4635 ; 4636#ifndef R__USE_IMT; 4637 nwrite = branch->FillImpl(nullptr);; 4638#else; 4639 nwrite = branch->FillImpl(useIMT ? &imtHelper : nullptr);; 4640#endif; 4641 if (nwrite < 0) {; 4642 if (nerror < 2) {; 4643 Error(""Fill"", ""Failed filling branch:%s.%s, nbytes=%d, entry=%lld\n""; 4644 "" This error is symptomatic of a Tree created as a memory-resident Tree\n""; 4645 "" Instead of doing:\n""; 4646 "" TTree *T = new TTree(...)\n""; 4647 "" TFile *f = new TFile(...)\n""; 4648 "" you should do:\n""; 4649 "" TFile *f = new TFile(...)\n""; 4650 "" TTree *T = new TTree(...)\n\n"",; 4651 GetName(), branch->GetName(), nwrite, fEntries + 1);; 4652 } else {; 4653 Error(""Fill"", ""Failed filling branch:%s.%s, nbytes=%d, entry=%lld"", GetName(), branch->GetName(), nwrite,; 4654 fEntries + 1);; 4655 }; 4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:187965,error,error,187965,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['error'],['error']
Availability,"/ histogram does not belong to any directory.; 8932///; 8933/// Note that the directory is not a real property of the histogram and; 8934/// it will not be copied when the histogram is copied or cloned.; 8935/// If the user wants to have the copied (cloned) histogram in the same; 8936/// directory, he needs to set again the directory using SetDirectory to the; 8937/// copied histograms; 8938 ; 8939void TH1::SetDirectory(TDirectory *dir); 8940{; 8941 if (fDirectory == dir) return;; 8942 if (fDirectory) fDirectory->Remove(this);; 8943 fDirectory = dir;; 8944 if (fDirectory) {; 8945 fFunctions->UseRWLock();; 8946 fDirectory->Append(this);; 8947 }; 8948}; 8949 ; 8950////////////////////////////////////////////////////////////////////////////////; 8951/// Replace bin errors by values in array error.; 8952 ; 8953void TH1::SetError(const Double_t *error); 8954{; 8955 for (Int_t i = 0; i < fNcells; ++i) SetBinError(i, error[i]);; 8956}; 8957 ; 8958////////////////////////////////////////////////////////////////////////////////; 8959/// Change the name of this histogram; 8960///; 8961 ; 8962void TH1::SetName(const char *name); 8963{; 8964 // Histograms are named objects in a THashList.; 8965 // We must update the hashlist if we change the name; 8966 // We protect this operation; 8967 R__LOCKGUARD(gROOTMutex);; 8968 if (fDirectory) fDirectory->Remove(this);; 8969 fName = name;; 8970 if (fDirectory) fDirectory->Append(this);; 8971}; 8972 ; 8973////////////////////////////////////////////////////////////////////////////////; 8974/// Change the name and title of this histogram; 8975 ; 8976void TH1::SetNameTitle(const char *name, const char *title); 8977{; 8978 // Histograms are named objects in a THashList.; 8979 // We must update the hashlist if we change the name; 8980 SetName(name);; 8981 SetTitle(title);; 8982}; 8983 ; 8984////////////////////////////////////////////////////////////////////////////////; 8985/// Set statistics option on/off.; 8986///; 8987/// By default, the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:349627,error,error,349627,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,2,['error'],['error']
Availability,"/ setup; 614 if (!Initialize()); 615 return kFALSE;; 616 ; 617 PyGILRAII gilRaii;; 618 ; 619 // direct pointer comparison of type member; 620 return CPyCppyy::Overload_CheckExact(pyobject);; 621}; 622 ; 623////////////////////////////////////////////////////////////////////////////////; 624/// Extract the object pointer held by the CPPInstance pyobject.; 625 ; 626void *TPython::CPPInstance_AsVoidPtr(PyObject *pyobject); 627{; 628 // setup; 629 if (!Initialize()); 630 return 0;; 631 ; 632 PyGILRAII gilRaii;; 633 ; 634 // get held object (may be null); 635 return CPyCppyy::Instance_AsVoidPtr(pyobject);; 636}; 637 ; 638////////////////////////////////////////////////////////////////////////////////; 639/// Bind the addr to a python object of class defined by classname.; 640 ; 641PyObject *TPython::CPPInstance_FromVoidPtr(void *addr, const char *classname, Bool_t python_owns); 642{; 643 // setup; 644 if (!Initialize()); 645 return 0;; 646 ; 647 PyGILRAII gilRaii;; 648 ; 649 // perform cast (the call will check TClass and addr, and set python errors); 650 // give ownership, for ref-counting, to the python side, if so requested; 651 return CPyCppyy::Instance_FromVoidPtr(addr, classname, python_owns);; 652}; API.h; PyBytes_Check#define PyBytes_CheckDefinition CPyCppyy.h:61; PyObject_object PyObjectDefinition PyMethodBase.h:43; Riostream.h; Bool_tbool Bool_tDefinition RtypesCore.h:63; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TClassRef.h; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPython_8cxx_source.html:21242,error,errors,21242,doc/master/TPython_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html,1,['error'],['errors']
Availability,"/ the function to be used in `while (reader.Next()) { ... }`; 216 bool Next() {; 217 return SetEntry(GetCurrentEntry() + 1) == kEntryValid;; 218 }; 219 ; 220 /// Set the next entry (or index of the TEntryList if that is set).; 221 ///; 222 /// \param entry If not TEntryList is set, the entry is a global entry (i.e.; 223 /// not the entry number local to the chain's current tree).; 224 /// \returns the `entry`'s read status, i.e. whether the entry is available.; 225 EEntryStatus SetEntry(Long64_t entry) { return SetEntryBase(entry, false); }; 226 ; 227 /// Set the next local tree entry. If a TEntryList is set, this function is; 228 /// equivalent to `SetEntry()`.; 229 ///; 230 /// \param entry Entry number of the TChain's current TTree. This is the; 231 /// entry number passed for instance by `TSelector::Process(entry)`, i.e.; 232 /// within `TSelector::Process()` always use `SetLocalEntry()` and not; 233 /// `SetEntry()`!; 234 /// \return the `entry`'s read status, i.e. whether the entry is available.; 235 EEntryStatus SetLocalEntry(Long64_t entry) { return SetEntryBase(entry, true); }; 236 ; 237 EEntryStatus SetEntriesRange(Long64_t beginEntry, Long64_t endEntry);; 238 ; 239 /// Get the begin and end entry numbers; 240 ///; 241 /// \return a pair contained the begin and end entry numbers.; 242 std::pair<Long64_t, Long64_t> GetEntriesRange() const { return std::make_pair(fBeginEntry, fEndEntry); }; 243 ; 244 /// Restart a Next() loop from entry 0 (of TEntryList index 0 of fEntryList is set).; 245 void Restart();; 246 ; 247 ///\}; 248 ; 249 EEntryStatus GetEntryStatus() const { return fEntryStatus; }; 250 ; 251 Long64_t GetEntries() const;; 252 Long64_t GetEntries(bool force);; 253 ; 254 /// Returns the index of the current entry being read.; 255 ///; 256 /// If `IsChain()`, the returned index corresponds to the global entry number; 257 /// (i.e. not the entry number local to the chain's current tree).; 258 /// If `fEntryList`, the returned index corresponds to an in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReader_8h_source.html:9208,avail,available,9208,doc/master/TTreeReader_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html,1,['avail'],['available']
Availability,"/"");; 1845 if (s) {; 1846 comment = 0;; 1847 s += 2;; 1848 ; 1849 while (s && (*s == ' ' || *s == '\t')) s++; // strip-off leading blanks; 1850 if (!*s) continue;; 1851 if (!strncmp(s, ""//"", 2)) continue;; 1852 if (!strncmp(s, ""/*"", 2)) {; 1853 comment = 1;; 1854 goto again;; 1855 }; 1856 }; 1857 }; 1858 if (!comment && *s == '{') tempfile = 1;; 1859 if (!comment) break;; 1860 }; 1861 macro.close();; 1862 ; 1863 if (!execute) {; 1864 TString exname = exnam;; 1865 if (!tempfile) {; 1866 // We have a script that does NOT contain an unnamed macro,; 1867 // so we can call the script compiler on it.; 1868 exname += aclicMode;; 1869 }; 1870 exname += arguments;; 1871 exname += io;; 1872 ; 1873 TString tempbuf;; 1874 if (tempfile) {; 1875 tempbuf.Form("".x %s"", exname.Data());; 1876 } else {; 1877 tempbuf.Form("".X%s %s"", keep ? ""k"" : "" "", exname.Data());; 1878 }; 1879 retval = gInterpreter->ProcessLineSynch(tempbuf,(TInterpreter::EErrorCode*)error);; 1880 }; 1881 ; 1882 delete [] exnam;; 1883 return retval;; 1884}; 1885 ; 1886////////////////////////////////////////////////////////////////////////////////; 1887/// Main application eventloop. Calls system dependent eventloop via gSystem.; 1888 ; 1889void TApplication::Run(Bool_t retrn); 1890{; 1891 SetReturnFromRun(retrn);; 1892 ; 1893 fIsRunning = kTRUE;; 1894 ; 1895 gSystem->Run();; 1896 fIsRunning = kFALSE;; 1897}; 1898 ; 1899////////////////////////////////////////////////////////////////////////////////; 1900/// Set the command to be executed after the system has been idle for; 1901/// idleTimeInSec seconds. Normally called via TROOT::Idle(...).; 1902 ; 1903void TApplication::SetIdleTimer(UInt_t idleTimeInSec, const char *command); 1904{; 1905 if (fIdleTimer) RemoveIdleTimer();; 1906 fIdleCommand = command;; 1907 fIdleTimer = new TIdleTimer(idleTimeInSec*1000);; 1908 gSystem->AddTimer(fIdleTimer);; 1909}; 1910 ; 1911////////////////////////////////////////////////////////////////////////////////; 1912/// Remove idle time",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:71985,error,error,71985,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['error'],['error']
Availability,"/(n1+n2); using an error bar calculated with Binomial statistics. void addEfficiencyBinWithError(Axis_t binCenter, Double_t n1, Double_t n2, Double_t en1, Double_t en2, Double_t binWidth = 0, Double_t xErrorFrac = 1., Double_t scaleFactor = 1.); Add a bin to this histogram with the value n1/(n1+n2); using an error bar calculated with Binomial statistics. ~RooHist(); Destructor. Bool_t hasIdenticalBinning(const RooHist& other) const; Return kTRUE if binning of this RooHist is identical to that of 'other'. Bool_t isIdentical(const RooHist& other, Double_t tol = 9.9999999999999995E-7) const; Return kTRUE if contents of this RooHIst is identical within given; relative tolerance to that of 'other'. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this histogram to the specified output stream. Standard: number of entries; Shape: error CL and maximum value; Verbose: print our bin contents and errors. void printName(ostream& os) const; Print name of RooHist. void printTitle(ostream& os) const; Print title of RooHist. void printClassName(ostream& os) const; Print class name of RooHist. RooHist* makeResidHist(const RooCurve& curve, bool normalize = false, bool useAverage = false) const; Create and return RooHist containing residuals w.r.t to given curve.; If normalize is true, the residuals are normalized by the histogram; errors creating a RooHist with pull values. RooHist(). void Print(Option_t* options = 0) const; Printing interface. Double_t getNominalBinWidth() const; { return _nominalBinWidth; }. void setRawEntries(Double_t n); { _rawEntries = n ; }. RooHist* makePullHist(const RooCurve& curve, bool useAverage = false) const; {return makeResidHist(curve,true,useAverage); }. » Last changed: Tue Jun 30 14:33:25 2015 » Last generated: 2015-06-30 14:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHist.html:26552,error,errors,26552,root/html602/RooHist.html,https://root.cern,https://root.cern/root/html602/RooHist.html,1,['error'],['errors']
Availability,"/* Time (since system start) when the request; 2479 * was received */; 2480 int64_t num_bytes_sent; /* Total bytes sent to client */; 2481 int64_t content_len; /* How many bytes of content can be read; 2482 * !is_chunked: Content-Length header value; 2483 * or -1 (until connection closed,; 2484 * not allowed for a request); 2485 * is_chunked: >= 0, appended gradually; 2486 */; 2487 int64_t consumed_content; /* How many bytes of content have been read */; 2488 int is_chunked; /* Transfer-Encoding is chunked:; 2489 * 0 = not chunked,; 2490 * 1 = chunked, not yet, or some data read,; 2491 * 2 = chunked, has error,; 2492 * 3 = chunked, all data read except trailer,; 2493 * 4 = chunked, all data read; 2494 */; 2495 char *buf; /* Buffer for received data */; 2496 char *path_info; /* PATH_INFO part of the URL */; 2497 ; 2498 int must_close; /* 1 if connection must be closed */; 2499 int accept_gzip; /* 1 if gzip encoding is accepted */; 2500 int in_error_handler; /* 1 if in handler for user defined error; 2501 * pages */; 2502#if defined(USE_WEBSOCKET); 2503 int in_websocket_handling; /* 1 if in read_websocket */; 2504#endif; 2505#if defined(USE_ZLIB) && defined(USE_WEBSOCKET) \; 2506 && defined(MG_EXPERIMENTAL_INTERFACES); 2507 /* Parameters for websocket data compression according to rfc7692 */; 2508 int websocket_deflate_server_max_windows_bits;; 2509 int websocket_deflate_client_max_windows_bits;; 2510 int websocket_deflate_server_no_context_takeover;; 2511 int websocket_deflate_client_no_context_takeover;; 2512 int websocket_deflate_initialized;; 2513 int websocket_deflate_flush;; 2514 z_stream websocket_deflate_state;; 2515 z_stream websocket_inflate_state;; 2516#endif; 2517 int handled_requests; /* Number of requests handled by this connection; 2518 */; 2519 int buf_size; /* Buffer size */; 2520 int request_len; /* Size of the request + headers in a buffer */; 2521 int data_len; /* Total size of data in a buffer */; 2522 int status_code; /* HTTP reply status code, e.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:78042,error,error,78042,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"/* Time (since system start) when the request; 2480 * was received */; 2481 int64_t num_bytes_sent; /* Total bytes sent to client */; 2482 int64_t content_len; /* How many bytes of content can be read; 2483 * !is_chunked: Content-Length header value; 2484 * or -1 (until connection closed,; 2485 * not allowed for a request); 2486 * is_chunked: >= 0, appended gradually; 2487 */; 2488 int64_t consumed_content; /* How many bytes of content have been read */; 2489 int is_chunked; /* Transfer-Encoding is chunked:; 2490 * 0 = not chunked,; 2491 * 1 = chunked, not yet, or some data read,; 2492 * 2 = chunked, has error,; 2493 * 3 = chunked, all data read except trailer,; 2494 * 4 = chunked, all data read; 2495 */; 2496 char *buf; /* Buffer for received data */; 2497 char *path_info; /* PATH_INFO part of the URL */; 2498 ; 2499 int must_close; /* 1 if connection must be closed */; 2500 int accept_gzip; /* 1 if gzip encoding is accepted */; 2501 int in_error_handler; /* 1 if in handler for user defined error; 2502 * pages */; 2503#if defined(USE_WEBSOCKET); 2504 int in_websocket_handling; /* 1 if in read_websocket */; 2505#endif; 2506#if defined(USE_ZLIB) && defined(USE_WEBSOCKET) \; 2507 && defined(MG_EXPERIMENTAL_INTERFACES); 2508 /* Parameters for websocket data compression according to rfc7692 */; 2509 int websocket_deflate_server_max_windows_bits;; 2510 int websocket_deflate_client_max_windows_bits;; 2511 int websocket_deflate_server_no_context_takeover;; 2512 int websocket_deflate_client_no_context_takeover;; 2513 int websocket_deflate_initialized;; 2514 int websocket_deflate_flush;; 2515 z_stream websocket_deflate_state;; 2516 z_stream websocket_inflate_state;; 2517#endif; 2518 int handled_requests; /* Number of requests handled by this connection; 2519 */; 2520 int buf_size; /* Buffer size */; 2521 int request_len; /* Size of the request + headers in a buffer */; 2522 int data_len; /* Total size of data in a buffer */; 2523 int status_code; /* HTTP reply status code, e.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:78074,error,error,78074,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"/*; ; */. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this object in the current pad. void Dump() const; Dump contents of object on stdout.; Using the information in the object dictionary (class TClass); each data member is interpreted.; If a data member is a pointer, the pointer value is printed. The following output is the Dump of a TArrow object:; fAngle 0 Arrow opening angle (degrees); fArrowSize 0.2 Arrow Size; fOption.*fData; fX1 0.1 X of 1st point; fY1 0.15 Y of 1st point; fX2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style. void Execute(const char* method, const char* params, Int_t* error = 0); Execute method on this object with the given parameter string, e.g.; ""3.14,1,\""text\"""". void Execute(TMethod* method, TObjArray* params, Int_t* error = 0); Execute method on this object with parameters stored in the TObjArray.; The TObjArray should contain an argv vector like:. argv[0] ... argv[n] = the list of TObjString parameters. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to an event at (px,py). This method; must be overridden if an object can react to graphics events. TObject * FindObject(const char* name) const; Must be redefined in derived classes.; This function is typycally used with TCollections, but can also be used; to find an object by name inside this object. TObject * FindObject(const TObject* obj) const; Must be redefined in derived classes.; This function is typycally used with TCollections, but can also be used; to find an object inside this object. Option_t * GetDrawOption() const; Get option used by the graphics system to draw this object.; Note that before calling object.GetDrawOption(), you must; have called object.Draw(..) before in the current pad. const char * GetName() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TObject.html:8674,error,error,8674,root/html528/TObject.html,https://root.cern,https://root.cern/root/html528/TObject.html,6,['error'],['error']
Availability,"// (now without limits!); FunctionMinimum min3 = migrad();. // output; std::cout<<""minimum3: ""<<min3<<std::endl;; }. {; // demonstrate MINOS error analysis. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create MINOS error factory; MnMinos minos(theFCN, min);. {; // 1-sigma MINOS errors; std::pair<double,double> e0 = minos(0);; std::pair<double,double> e1 = minos(1);; std::pair<double,double> e2 = minos(2);. // output; std::cout<<""1-sigma minos errors: ""<<std::endl;; std::cout<<""par0: ""; <<min.userState().value(""mean"")<<"" ""; <<e0.first<<"" ""<<e0.second<<std::endl;; std::cout<<""par1: ""; <<min.userState().value(1)<<"" ""; <<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""<<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""; <<e2.second<<std::endl;; }. {; // 2-sigma MINOS errors; theFCN.setErrorDef(4.);; std::pair<double,double> e0 = minos(0);; std::pair<double,double> e1 = minos(1);; std::pair<double,double> e2 = minos(2);. // output; std::cout<<""2-sigma minos errors: ""<<std::endl;; std::cout<<""par0: ""; <<min.userState().value(""mean""); <<"" ""<<e0.first<<"" ""<<e0.second<<std::endl;; std::cout<<""par1: ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""<<e2.second<<std::endl;; }; }. {; // demonstrate how to use the CONTOURs. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create contours factory with FCN and minimum; MnContours contours(theFCN, min);. // 70% confidence level for 2 parameters contour; // around the minimum; theFCN.setErrorDef(2.41",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:86920,error,errors,86920,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['error'],['errors']
Availability,"// Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFitResult.h; RooGlobalFunc.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TLegend.h; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:5361,recover,recovery,5361,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,1,['recover'],['recovery']
Availability,"// Increment bin content by 1.; 2956/// Passing an out-of-range bin leads to undefined behavior; 2957 ; 2958void TH2C::AddBinContent(Int_t bin); 2959{; 2960 if (fArray[bin] < 127) fArray[bin]++;; 2961}; 2962 ; 2963 ; 2964////////////////////////////////////////////////////////////////////////////////; 2965/// Increment bin content by w.; 2966/// \warning The value of w is cast to `Int_t` before being added.; 2967/// Passing an out-of-range bin leads to undefined behavior; 2968 ; 2969void TH2C::AddBinContent(Int_t bin, Double_t w); 2970{; 2971 Int_t newval = fArray[bin] + Int_t(w);; 2972 if (newval > -128 && newval < 128) {fArray[bin] = Char_t(newval); return;}; 2973 if (newval < -127) fArray[bin] = -127;; 2974 if (newval > 127) fArray[bin] = 127;; 2975}; 2976 ; 2977 ; 2978////////////////////////////////////////////////////////////////////////////////; 2979/// Copy.; 2980 ; 2981void TH2C::Copy(TObject &newth2) const; 2982{; 2983 TH2::Copy(newth2);; 2984}; 2985 ; 2986 ; 2987////////////////////////////////////////////////////////////////////////////////; 2988/// Reset this histogram: contents, errors, etc.; 2989 ; 2990void TH2C::Reset(Option_t *option); 2991{; 2992 TH2::Reset(option);; 2993 TArrayC::Reset();; 2994}; 2995 ; 2996 ; 2997////////////////////////////////////////////////////////////////////////////////; 2998/// Set total number of bins including under/overflow; 2999/// Reallocate bin contents array; 3000 ; 3001void TH2C::SetBinsLength(Int_t n); 3002{; 3003 if (n < 0) n = (fXaxis.GetNbins()+2)*(fYaxis.GetNbins()+2);; 3004 fNcells = n;; 3005 TArrayC::Set(n);; 3006}; 3007 ; 3008 ; 3009////////////////////////////////////////////////////////////////////////////////; 3010/// Stream an object of class TH2C.; 3011 ; 3012void TH2C::Streamer(TBuffer &R__b); 3013{; 3014 if (R__b.IsReading()) {; 3015 UInt_t R__s, R__c;; 3016 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 3017 if (R__v > 2) {; 3018 R__b.ReadClassBuffer(TH2C::Class(), this, R__v, R__s, R__c);; 3019 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:120038,error,errors,120038,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['error'],['errors']
Availability,"// Reallocate bin contents array; 1728 ; 1729void TProfile::SetBinsLength(Int_t n); 1730{; 1731 TH1D::SetBinsLength(n);; 1732 TProfileHelper::BuildArray(this);; 1733}; 1734 ; 1735////////////////////////////////////////////////////////////////////////////////; 1736/// Set the buffer size in units of 8 bytes (double).; 1737 ; 1738void TProfile::SetBuffer(Int_t buffersize, Option_t *); 1739{; 1740 if (fBuffer) {; 1741 BufferEmpty();; 1742 delete [] fBuffer;; 1743 fBuffer = nullptr;; 1744 }; 1745 if (buffersize <= 0) {; 1746 fBufferSize = 0;; 1747 return;; 1748 }; 1749 if (buffersize < 100) buffersize = 100;; 1750 fBufferSize = 1 + 3*buffersize;; 1751 fBuffer = new Double_t[fBufferSize];; 1752 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1753}; 1754 ; 1755////////////////////////////////////////////////////////////////////////////////; 1756/// Set option to compute profile errors.; 1757///; 1758/// The computation of the bin errors is based on the parameter option:; 1759///; 1760/// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; 1761/// i.e. the standard error of the bin contents.; 1762/// Note that if TProfile::Approximate() is called, an approximation is used when; 1763/// the spread in Y is 0 and the number of bin entries is > 0; 1764/// -'s' The bin errors are the standard deviations of the Y bin values; 1765/// Note that if TProfile::Approximate() is called, an approximation is used when; 1766/// the spread in Y is 0 and the number of bin entries is > 0; 1767/// -'i' Errors are as in default case (standard errors of the bin contents); 1768/// The only difference is for the case when the spread in Y is zero.; 1769/// In this case for N > 0 the error is 1./SQRT(12.*N); 1770/// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1771/// W is the sum in the bin of the weights of the profile.; 1772/// This option is for combining measurements y +/- dy,; 1773/// and the profile is filled with values y a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:63839,error,errors,63839,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,3,['error'],"['error', 'errors']"
Availability,"// This is needed to compute the correct statistical quantities; 2037/// of a profile filled with weights; 2038///; 2039/// This function is automatically called when the histogram is created; 2040/// if the static function TH1::SetDefaultSumw2 has been called before.; 2041/// If flag is false the structure is deleted; 2042 ; 2043void TProfile2D::Sumw2(Bool_t flag); 2044{; 2045 TProfileHelper::Sumw2(this, flag);; 2046}; a#define a(i)Definition RSha256.hxx:99; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; THLimitsFinder.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TMath.h; TProfile2D.h; TProfileHelper.h; EErrorTypeEErrorTypeDefinition TProfile.h:28; kERRORSPREAD@ kERRORSPREADDefinition TProfile.h:28; kERRORSPREADG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:75337,error,error,75337,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,1,['error'],['error']
Availability,"// Use THnIter instead.; 895 ; 896ROOT::Internal::THnBaseBinIter* THnSparse::CreateIter(Bool_t respectAxisRange) const; 897{; 898 return new THnSparseBinIter(respectAxisRange, this);; 899}; 900 ; 901////////////////////////////////////////////////////////////////////////////////; 902/// Set content of bin with index ""bin"" to ""v""; 903 ; 904void THnSparse::SetBinContent(Long64_t bin, Double_t v); 905{; 906 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 907 chunk->fContent->SetAt(v, bin % fChunkSize);; 908 ++fEntries;; 909}; 910 ; 911////////////////////////////////////////////////////////////////////////////////; 912/// Set error of bin with index ""bin"" to ""e"", enable errors if needed; 913 ; 914void THnSparse::SetBinError2(Long64_t bin, Double_t e2); 915{; 916 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 917 if (!chunk->fSumw2 ) {; 918 // if fSumw2 is zero GetCalculateErrors should return false; 919 if (GetCalculateErrors()) {; 920 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 921 }; 922 Sumw2(); // enable error calculation; 923 }; 924 ; 925 chunk->fSumw2->SetAt(e2, bin % fChunkSize);; 926}; 927 ; 928////////////////////////////////////////////////////////////////////////////////; 929/// Add ""e"" to error of bin with index ""bin"", enable errors if needed; 930 ; 931void THnSparse::AddBinError2(Long64_t bin, Double_t e2); 932{; 933 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 934 if (!chunk->fSumw2 ) {; 935 // if fSumw2 is zero GetCalculateErrors should return false; 936 if (GetCalculateErrors()) {; 937 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 938 }; 939 Sumw2(); // enable error calculation; 940 }; 941 ; 942 (*chunk->fSumw2)[bin % fChunkSize] += e2;; 943}; 944 ; 945////////////////////////////////////////////////////////////////////////////////; 946/// Enable calculation of errors; 947 ; 948void THnSparse::Sumw2(); 949{; 950 if (GetCalculateErrors()) return;; 951 ; 952 fTsumw2 = 0.;; 953 TIter iChunk(&fB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:34099,error,error,34099,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,9,['error'],"['error', 'errors']"
Availability,"// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); 198/// (i.e the errors are the standard error on the bin content of the profile); 199/// - 's' Errors are the standard deviation of Y, S(Y); 200/// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); 201/// The only difference is only when the standard deviation in Y is zero.; 202/// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; 203/// 1./SQRT(12*N).; 204/// This approximation assumes that the Y values are integer (e.g. ADC counts); 205/// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; 206/// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); 207/// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; 208/// W is obtained as from TProfile::GetBinEntries(ibin); 209/// This errors corresponds to the standard deviation of weighted mean where each; 210/// measurement Y is uncorrelated and has an error sigma, which is expressed in the; 211/// weight used to fill the Profile: w = 1/sigma^2; 212/// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); 213///; 214/// In the case of Profile filled weights and with TProfile::Sumw2() called,; 215/// STD(Y) is the standard deviation of the weighted sample Y and N is in this case the; 216/// number of effective entries (TProfile::GetBinEffectiveEntries(ibin) ); 217///; 218/// If a bin has N data points all with the same value Y (especially; 219/// possible when dealing with integers), the spread in Y for that bin; 220/// is zero, and the uncertainty assigned is also zero, and the bin is; 221/// ignored in making subsequent fits.; 222/// To avoid this problem one can use an approximation for the standard deviation S(Y),; 223/// by using the average of all the S(Y) of the other Profile bins. To use this approximation; 224/// one must call before TProfile::Approximate; 22",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:9462,error,errors,9462,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,3,['error'],"['error', 'errors']"
Availability,"// considerable advantage in speed.; 1201/// When using the linear fitting it is also possible to perform a robust fitting with the; 1202/// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; 1203/// See the tutorial `fitLinearRobust.C`.; 1204///; 1205/// ### Notes on TGraph/TGraphErrors Fitting:; 1206///; 1207/// 1. By using the ""effective variance"" method a simple linear regression; 1208/// becomes a non-linear case, which takes several iterations; 1209/// instead of 0 as in the linear case.; 1210/// 2. The effective variance technique assumes that there is no correlation; 1211/// between the x and y coordinate.; 1212/// 3. The standard chi2 (least square) method without error in the coordinates (x) can; 1213/// be forced by using option ""EX0""; 1214/// 4. The linear fitter doesn't take into account the errors in x. When fitting a; 1215/// TGraphErrors with a linear functions the errors in x will not be considered.; 1216/// If errors in x are important, use option ""F"" for linear function fitting.; 1217/// 5. When fitting a TGraph (i.e. no errors associated with each point),; 1218/// a correction is applied to the errors on the parameters with the following; 1219/// formula:; 1220/// `parameter_error *= sqrt(chisquare/(ndf-1))`; 1221///; 1222/// ### General Fitting documentation; 1223///; 1224/// See in TH1::Fit for the documentation of; 1225/// - [Fit Result](\ref HFitRes); 1226/// - [Fit Status](\ref HFitStatus); 1227/// - [Fit Statistics Box](\ref HFitStatBox); 1228/// - [Fitting in a Range](\ref HFitRange); 1229/// - [Setting Initial Conditions](\ref HFitInitial); 1230 ; 1231TFitResultPtr TGraph::Fit(TF1 *f1, Option_t *option, Option_t *goption, Axis_t rxmin, Axis_t rxmax); 1232{; 1233 Foption_t fitOption;; 1234 ROOT::Fit::FitOptionsMake(ROOT::Fit::EFitObjectType::kGraph, option, fitOption);; 1235 // create range and minimizer options with default values; 1236 ROOT::Fit::DataRange range(rxmin, rxmax);; 1237 ROOT::Math::MinimizerOptio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:43704,error,errors,43704,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['error'],['errors']
Availability,"// correct dimensions:; 4338/// Sumw2 just makes sure the errors will be computed properly; 4339/// when we form sums and ratios below.; 4340 ; 4341TH1 *TH1::GetAsymmetry(TH1* h2, Double_t c2, Double_t dc2); 4342{; 4343 TH1 *h1 = this;; 4344 TString name = TString::Format(""Asymmetry_%s-%s"",h1->GetName(),h2->GetName() );; 4345 TH1 *asym = (TH1*)Clone(name);; 4346 ; 4347 // set also the title; 4348 TString title = TString::Format(""(%s - %s)/(%s+%s)"",h1->GetName(),h2->GetName(),h1->GetName(),h2->GetName() );; 4349 asym->SetTitle(title);; 4350 ; 4351 asym->Sumw2();; 4352 Bool_t addStatus = TH1::AddDirectoryStatus();; 4353 TH1::AddDirectory(kFALSE);; 4354 TH1 *top = (TH1*)asym->Clone();; 4355 TH1 *bottom = (TH1*)asym->Clone();; 4356 TH1::AddDirectory(addStatus);; 4357 ; 4358 // form the top and bottom of the asymmetry, and then divide:; 4359 top->Add(h1,h2,1,-c2);; 4360 bottom->Add(h1,h2,1,c2);; 4361 asym->Divide(top,bottom);; 4362 ; 4363 Int_t xmax = asym->GetNbinsX();; 4364 Int_t ymax = asym->GetNbinsY();; 4365 Int_t zmax = asym->GetNbinsZ();; 4366 ; 4367 if (h1->fBuffer) h1->BufferEmpty(1);; 4368 if (h2->fBuffer) h2->BufferEmpty(1);; 4369 if (bottom->fBuffer) bottom->BufferEmpty(1);; 4370 ; 4371 // now loop over bins to calculate the correct errors; 4372 // the reason this error calculation looks complex is because of c2; 4373 for(Int_t i=1; i<= xmax; i++){; 4374 for(Int_t j=1; j<= ymax; j++){; 4375 for(Int_t k=1; k<= zmax; k++){; 4376 Int_t bin = GetBin(i, j, k);; 4377 // here some bin contents are written into variables to make the error; 4378 // calculation a little more legible:; 4379 Double_t a = h1->RetrieveBinContent(bin);; 4380 Double_t b = h2->RetrieveBinContent(bin);; 4381 Double_t bot = bottom->RetrieveBinContent(bin);; 4382 ; 4383 // make sure there are some events, if not, then the errors are set = 0; 4384 // automatically.; 4385 //if(bot < 1){} was changed to the next line from recommendation of Jason Seely (28 Nov 2005); 4386 if(bot < 1e-6){}; 4387 else{",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:180654,error,errors,180654,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,4,['error'],"['error', 'errors']"
Availability,"// fill the data now; 867 next = grList;; 868 while ((gr = (TGraph*) next())) {; 869 DoFillData( dv, gr, type, func);; 870 }; 871 ; 872#ifdef DEBUG; 873 std::cout << ""TGraphFitInterface::FillData MultiGraph FitData size is "" << dv.Size() << std::endl;; 874#endif; 875 ; 876}; 877 ; 878void FillData ( BinData & dv, const TGraph2D * gr, TF1 * func ) {; 879 // fill the data vector from a TGraph2D. Pass also the TF1 function which is; 880 // needed in case to exclude points rejected by the function; 881 // in case of a pure TGraph; 882 assert(gr != nullptr);; 883 ; 884 // get fit option; 885 DataOptions & fitOpt = dv.Opt();; 886 BinData::ErrorType type = GetDataType(gr,fitOpt);; 887 // adjust option according to type; 888 fitOpt.fErrors1 = (type == BinData::kNoError);; 889 fitOpt.fCoordErrors = (type == BinData::kCoordError);; 890 fitOpt.fAsymErrors = false; // a TGraph2D with asymmetric errors does not exist; 891 ; 892 int nPoints = gr->GetN();; 893 double *gx = gr->GetX();; 894 double *gy = gr->GetY();; 895 double *gz = gr->GetZ();; 896 ; 897 // if all errors are zero set option of using errors to 1; 898 if ( gr->GetEZ() == nullptr) fitOpt.fErrors1 = true;; 899 ; 900 double x[2];; 901 double ex[2];; 902 ; 903 // look at data range; 904 const DataRange & range = dv.Range();; 905 bool useRangeX = ( range.Size(0) > 0);; 906 bool useRangeY = ( range.Size(1) > 0);; 907 double xmin = 0;; 908 double xmax = 0;; 909 double ymin = 0;; 910 double ymax = 0;; 911 range.GetRange(xmin,xmax,ymin,ymax);; 912 ; 913 dv.Initialize(nPoints,2, type);; 914 ; 915 for ( int i = 0; i < nPoints; ++i) {; 916 ; 917 x[0] = gx[i];; 918 x[1] = gy[i];; 919 ; 920 //if (fitOpt.fUseRange && HFitInterface::IsPointOutOfRange(func, x) ) continue;; 921 if (useRangeX && ( x[0] < xmin || x[0] > xmax) ) continue;; 922 if (useRangeY && ( x[1] < ymin || x[1] > ymax) ) continue;; 923 ; 924 // need to evaluate function to know about rejected points; 925 // hugly but no other solutions; 926 if (func) {; 927 TF1::Rej",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitInterface_8cxx_source.html:29136,error,errors,29136,doc/master/HFitInterface_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitInterface_8cxx_source.html,3,['error'],['errors']
Availability,"// we can not use it.; 3591 if (gApplication && gApplication->GetApplicationImp()) {; 3592 while (gROOT->IsLineProcessing() && !gApplication) {; 3593 Warning(""Calc"", ""waiting for cling thread to free"");; 3594 gSystem->Sleep(500);; 3595 }; 3596 gROOT->SetLineIsProcessing();; 3597 }; 3598#endif // R__WIN32; 3599 R__LOCKGUARD_CLING(gInterpreterMutex);; 3600 if (error) {; 3601 *error = TInterpreter::kNoError;; 3602 }; 3603 cling::Value valRef;; 3604 cling::Interpreter::CompilationResult cr = cling::Interpreter::kFailure;; 3605 try {; 3606 cr = fInterpreter->evaluate(line, valRef);; 3607 }; 3608 catch (cling::InterpreterException& ex); 3609 {; 3610 Error(""Calc"", ""%s.\n%s"", ex.what(), ""Evaluation of your expression was aborted."");; 3611 ex.diagnose();; 3612 cr = cling::Interpreter::kFailure;; 3613 }; 3614 ; 3615 if (cr != cling::Interpreter::kSuccess) {; 3616 // Failure in compilation.; 3617 if (error) {; 3618 // Note: Yes these codes are weird.; 3619 *error = TInterpreter::kRecoverable;; 3620 }; 3621 return 0L;; 3622 }; 3623 if (!valRef.isValid()) {; 3624 // Failure at runtime.; 3625 if (error) {; 3626 // Note: Yes these codes are weird.; 3627 *error = TInterpreter::kDangerous;; 3628 }; 3629 return 0L;; 3630 }; 3631 ; 3632 if (valRef.isVoid()) {; 3633 return 0;; 3634 }; 3635 ; 3636 RegisterTemporary(valRef);; 3637#ifdef R__WIN32; 3638 if (gApplication && gApplication->GetApplicationImp()) {; 3639 gROOT->SetLineHasBeenProcessed();; 3640 }; 3641#endif // R__WIN32; 3642 return valRef.castAs<Longptr_t>();; 3643}; 3644 ; 3645////////////////////////////////////////////////////////////////////////////////; 3646/// Set a getline function to call when input is needed.; 3647 ; 3648void TCling::SetGetline(const char * (*getlineFunc)(const char* prompt),; 3649 void (*histaddFunc)(const char* line)); 3650{; 3651 // If cling offers a replacement for G__pause(), it would need to; 3652 // also offer a way to customize at least the history recording.; 3653 ; 3654#if defined(R__MUST_REVIS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:140586,error,error,140586,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['error'],['error']
Availability,"/// For the fit to be meaningful, the function must be self-normalized.; 9679///; 9680/// i.e. It must have the same integral regardless of the parameter; 9681/// settings. Otherwise the fit will effectively just maximize the; 9682/// area.; 9683///; 9684/// It is mandatory to have a normalization variable; 9685/// which is fixed for the fit. e.g.; 9686/// ~~~ {.cpp}; 9687/// TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; 9688/// f1->SetParameters(1, 3.1, 0.01);; 9689/// f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; 9690/// data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");; 9691/// ~~~; 9692/// 1, 2 and 3 Dimensional fits are supported. See also TTree::Fit; 9693///; 9694/// Return status:; 9695///; 9696/// - The function return the status of the fit in the following form; 9697/// fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; 9698/// - The fitResult is 0 is the fit is OK.; 9699/// - The fitResult is negative in case of an error not connected with the fit.; 9700/// - The number of entries used in the fit can be obtained via mytree.GetSelectedRows();; 9701/// - If the number of selected entries is null the function returns -1; 9702 ; 9703Int_t TTree::UnbinnedFit(const char* funcname, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); 9704{; 9705 GetPlayer();; 9706 if (fPlayer) {; 9707 return fPlayer->UnbinnedFit(funcname, varexp, selection, option, nentries, firstentry);; 9708 }; 9709 return -1;; 9710}; 9711 ; 9712////////////////////////////////////////////////////////////////////////////////; 9713/// Replace current attributes by current style.; 9714 ; 9715void TTree::UseCurrentStyle(); 9716{; 9717 if (gStyle->IsReading()) {; 9718 SetFillColor(gStyle->GetHistFillColor());; 9719 SetFillStyle(gStyle->GetHistFillStyle());; 9720 SetLineColor(gStyle->GetHistLineColor());; 9721 SetLineStyle(gStyle->GetHistLineStyle());; 9722 SetLineWidth(gStyle->GetH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:372377,error,error,372377,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['error'],['error']
Availability,"/// Passing an out-of-range bin leads to undefined behavior; 3485 ; 3486void TH2I::AddBinContent(Int_t bin); 3487{; 3488 if (fArray[bin] < INT_MAX) fArray[bin]++;; 3489}; 3490 ; 3491 ; 3492////////////////////////////////////////////////////////////////////////////////; 3493/// Increment bin content by w.; 3494/// \warning The value of w is cast to `Long64_t` before being added.; 3495/// Passing an out-of-range bin leads to undefined behavior; 3496 ; 3497void TH2I::AddBinContent(Int_t bin, Double_t w); 3498{; 3499 Long64_t newval = fArray[bin] + Long64_t(w);; 3500 if (newval > -INT_MAX && newval < INT_MAX) {fArray[bin] = Int_t(newval); return;}; 3501 if (newval < -INT_MAX) fArray[bin] = -INT_MAX;; 3502 if (newval > INT_MAX) fArray[bin] = INT_MAX;; 3503}; 3504 ; 3505 ; 3506////////////////////////////////////////////////////////////////////////////////; 3507/// Copy.; 3508 ; 3509void TH2I::Copy(TObject &newth2) const; 3510{; 3511 TH2::Copy(newth2);; 3512}; 3513 ; 3514 ; 3515////////////////////////////////////////////////////////////////////////////////; 3516/// Reset this histogram: contents, errors, etc.; 3517 ; 3518void TH2I::Reset(Option_t *option); 3519{; 3520 TH2::Reset(option);; 3521 TArrayI::Reset();; 3522}; 3523 ; 3524 ; 3525////////////////////////////////////////////////////////////////////////////////; 3526/// Set total number of bins including under/overflow; 3527/// Reallocate bin contents array; 3528 ; 3529void TH2I::SetBinsLength(Int_t n); 3530{; 3531 if (n < 0) n = (fXaxis.GetNbins()+2)*(fYaxis.GetNbins()+2);; 3532 fNcells = n;; 3533 TArrayI::Set(n);; 3534}; 3535 ; 3536 ; 3537////////////////////////////////////////////////////////////////////////////////; 3538/// Operator =; 3539 ; 3540TH2I& TH2I::operator=(const TH2I &h2i); 3541{; 3542 if (this != &h2i); 3543 h2i.TH2I::Copy(*this);; 3544 return *this;; 3545}; 3546 ; 3547 ; 3548////////////////////////////////////////////////////////////////////////////////; 3549/// Operator *; 3550 ; 3551TH2I opera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:135408,error,errors,135408,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['error'],['errors']
Availability,"/// is not destroyed in the process and will still retain (shared) ownership of; 201/// the original results.; 202///; 203/// Example usage:; 204/// ~~~{.cpp}; 205/// auto df = ROOT::RDataFrame(10).Define(""x"", [] { return 1; });; 206/// auto h = df.Vary(""x"", [](){return ROOT::RVecI{-1, 2};}, {}, 2).Histo1D<int>(""x"");; 207/// auto hs = ROOT::RDF::Experimental::VariationsFor(h);; 208/// std::unique_ptr<RMergeableVariations<T>> m = ROOT::Detail::RDF::GetMergeableValue(hs);; 209/// ~~~; 210template <typename T>; 211std::unique_ptr<RMergeableVariations<T>> GetMergeableValue(ROOT::RDF::Experimental::RResultMap<T> &rmap); 212{; 213 rmap.RunEventLoopIfNeeded();; 214 ; 215 std::unique_ptr<RMergeableVariationsBase> mVariationsBase;; 216 if (rmap.fVariedAction != nullptr) {; 217 auto mValueBase = rmap.fVariedAction->GetMergeableValue();; 218 mVariationsBase.reset(static_cast<RMergeableVariationsBase *>(mValueBase.release())); // downcast unique_ptr; 219 } else {; 220 mVariationsBase = std::unique_ptr<RMergeableVariationsBase>({}, {});; 221 }; 222 mVariationsBase->AddNominal(rmap.fNominalAction->GetMergeableValue());; 223 ; 224 return std::make_unique<RMergeableVariations<T>>(std::move(*mVariationsBase));; 225}; 226} // namespace RDF; 227} // namespace Detail; 228} // namespace ROOT; 229 ; 230#endif; RActionBase.hxx; RLoopManager.hxx; RMergeableValue.hxx; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Utils.hxx; ROOT::Detail::RDF::RLoopManagerThe head node of a RDF computation graph.Definition RLoopManager.hxx:114; ROOT::Detail::RDF::RMergeableVariationsBaseA container for variation names and variation results.Definition RMergeableValue.hxx:569; ROOT::RDF::Experimental::RResultMapDefinition RResultMap.hxx:98; ROOT::RDF::Experimental::RResultMap::const_iteratortypename decltype(fMap)::const_iterator const_iteratorDefinition RResultMap.hxx:144; ROOT::RDF::Experimental::RResultMap::operator[]T & operator[](const std:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultMap_8hxx_source.html:8790,down,downcast,8790,doc/master/RResultMap_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultMap_8hxx_source.html,1,['down'],['downcast']
Availability,"//////////////// ;  ; static TString GetSysIncludePath ();  [static utility function]///////////////////////////// ;  ; static Bool_t IsDirectory (const char fileName[]);  [static utility function]///////////////////////////// ;  ; static TSeqCollection * NewListOfFilesInPath (const char path[]);  [static utility function]///////////////////////////// ;  ; static void NoMsg (Int_t errorLevel);  [static utility function]///////////////////////////// ;  ; static Bool_t PathIsSpecifiedInFileName (const TString &fileName);  [static utility function]///////////////////////////// ;  . Private Member Functions;  TTabCom (const TTabCom &)=delete;  ; Int_t Complete (const TRegexp &re, const TSeqCollection *pListOfCandidates, const char appendage[], std::ostream &out, TString::ECaseCompare cmp=TString::kExact);  [private] ;  ; void CopyMatch (char *dest, int dest_len, const char *localName, const char *appendage=nullptr, const char *fullName=nullptr) const;  [private] ;  ; EContext_t DetermineContext () const;  [private] ;  ; TString DeterminePath (const TString &fileName, const char defaultPath[]) const;  [private] ;  ; TString ExtendPath (const char originalPath[], TString newBase) const;  [private] ;  ; void InitPatterns ();  [private] ;  ; TClass * MakeClassFromClassName (const char className[]) const;  [private] (does some specific error handling that makes the function unsuitable for general use.) returns a new'd TClass given the name of a class. ;  ; TClass * MakeClassFromVarName (const char varName[], EContext_t &context, int iter=0);  [private] (does some specific error handling that makes the function unsuitable for general use.) returns a new'd TClass given the name of a variable. ;  ; TTabCom & operator= (const TTabCom &)=delete;  ; int ParseReverse (const char *var_str, int start);  Returns the place in the string where to put the \0, starting the search from ""start"". ;  ; void SetPattern (EContext_t handle, const char regexp[]);  [private] ;  ; TClass * TryMakeC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTabCom.html:5403,error,error,5403,doc/master/classTTabCom.html,https://root.cern,https://root.cern/doc/master/classTTabCom.html,1,['error'],['error']
Availability,"/////////////////// ;  . Private Member Functions;  TTabCom (const TTabCom &)=delete;  ; Int_t Complete (const TRegexp &re, const TSeqCollection *pListOfCandidates, const char appendage[], std::ostream &out, TString::ECaseCompare cmp=TString::kExact);  [private] ;  ; void CopyMatch (char *dest, int dest_len, const char *localName, const char *appendage=nullptr, const char *fullName=nullptr) const;  [private] ;  ; EContext_t DetermineContext () const;  [private] ;  ; TString DeterminePath (const TString &fileName, const char defaultPath[]) const;  [private] ;  ; TString ExtendPath (const char originalPath[], TString newBase) const;  [private] ;  ; void InitPatterns ();  [private] ;  ; TClass * MakeClassFromClassName (const char className[]) const;  [private] (does some specific error handling that makes the function unsuitable for general use.) returns a new'd TClass given the name of a class. ;  ; TClass * MakeClassFromVarName (const char varName[], EContext_t &context, int iter=0);  [private] (does some specific error handling that makes the function unsuitable for general use.) returns a new'd TClass given the name of a variable. ;  ; TTabCom & operator= (const TTabCom &)=delete;  ; int ParseReverse (const char *var_str, int start);  Returns the place in the string where to put the \0, starting the search from ""start"". ;  ; void SetPattern (EContext_t handle, const char regexp[]);  [private] ;  ; TClass * TryMakeClassFromClassName (const char className[]) const;  Same as above but does not print the error message. ;  . Private Attributes; char * fBuf;  ; Int_t fLastIter;  ; Pattern_t fPat [kNUM_PAT][1024];  ; TSeqCollection * fpClasses;  ; TSeqCollection * fpDirectives;  ; TSeqCollection * fpEnvVars;  ; TSeqCollection * fpFiles;  ; TSeqCollection * fpGlobals;  ; int * fpLoc;  ; TSeqCollection * fpPragmas;  ; ULong64_t fPrevInterpMarker;  ; TSeqCollection * fpSysIncFiles;  ; TSeqCollection * fpUsers;  ; const char * fRegExp [kNUM_PAT];  ; Bool_t fVarIsPointer;  . #",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTabCom.html:5644,error,error,5644,doc/master/classTTabCom.html,https://root.cern,https://root.cern/doc/master/classTTabCom.html,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; 1338/// Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; 1339/// for a 2-D histogram. Calculates also the integral error using error propagation; 1340/// from the bin errors assuming that all the bins are uncorrelated.; 1341/// By default the integral is computed as the sum of bin contents in the range.; 1342/// if option ""width"" is specified, the integral is the sum of; 1343/// the bin contents multiplied by the bin width in x and in y.; 1344 ; 1345Double_t TH2::IntegralAndError(Int_t firstxbin, Int_t lastxbin, Int_t firstybin, Int_t lastybin, Double_t & error, Option_t *option) const; 1346{; 1347 return DoIntegral(firstxbin,lastxbin,firstybin,lastybin,-1,0,error,option,kTRUE);; 1348}; 1349 ; 1350////////////////////////////////////////////////////////////////////////////////; 1351///illegal for a TH2; 1352 ; 1353Double_t TH2::Interpolate(Double_t) const; 1354{; 1355 Error(""Interpolate"",""This function must be called with 2 arguments for a TH2"");; 1356 return 0;; 1357}; 1358 ; 1359////////////////////////////////////////////////////////////////////////////////; 1360/// Given a point P(x,y), Interpolate approximates the value via bilinear; 1361/// interpolation based on the four nearest bin centers; 1362/// see Wikipedia, Bilinear Interpolation; 1363/// Andy Mastbaum 10/8/2008; 1364/// vaguely based on R.Raja 6-Sep-2008; 1365 ; 1366 Double_t TH2::Interpolate(Double_t x, Double_t y) const; 1367{; 1368 Double_t f=0;; 1369 Double_t x1=0,x2=0,y1=0,y2=0;; 1370 Double_t dx,dy;; 1371 Int_t bin_x = fXaxis.FindFixBin(x);; 1372 Int_t bin_y = fYaxis.FindFixBin(y);; 1373 if(bin_x<1 || bin_x>GetNbinsX() || bin_y<1 || bin_y>GetNbinsY()) {; 1374 Error(""Interpolate"",""Cannot interpolate outside histogram domain."");; 1375 return 0;; 1376 }; 1377 Int_t quadrant = 0; // CCW from UR 1,2,3,4; 1378 // which quadrant of the bin (bin_P) are we in?; 1379 dx = fXaxis.GetBinUpEdg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:54738,error,error,54738,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; 2398/// Get x axis of the function.; 2399 ; 2400TAxis *TF1::GetXaxis() const; 2401{; 2402 TH1 *h = GetHistogram();; 2403 if (!h) return nullptr;; 2404 return h->GetXaxis();; 2405}; 2406 ; 2407 ; 2408////////////////////////////////////////////////////////////////////////////////; 2409/// Get y axis of the function.; 2410 ; 2411TAxis *TF1::GetYaxis() const; 2412{; 2413 TH1 *h = GetHistogram();; 2414 if (!h) return nullptr;; 2415 return h->GetYaxis();; 2416}; 2417 ; 2418 ; 2419////////////////////////////////////////////////////////////////////////////////; 2420/// Get z axis of the function. (In case this object is a TF2 or TF3); 2421 ; 2422TAxis *TF1::GetZaxis() const; 2423{; 2424 TH1 *h = GetHistogram();; 2425 if (!h) return nullptr;; 2426 return h->GetZaxis();; 2427}; 2428 ; 2429 ; 2430 ; 2431////////////////////////////////////////////////////////////////////////////////; 2432/// Compute the gradient (derivative) wrt a parameter ipar; 2433///; 2434/// \param ipar index of parameter for which the derivative is computed; 2435/// \param x point, where the derivative is computed; 2436/// \param eps - if the errors of parameters have been computed, the step used in; 2437/// numerical differentiation is eps*parameter_error.; 2438///; 2439/// if the errors have not been computed, step=eps is used; 2440/// default value of eps = 0.01; 2441/// Method is the same as in Derivative() function; 2442///; 2443/// If a parameter is fixed, the gradient on this parameter = 0; 2444 ; 2445Double_t TF1::GradientPar(Int_t ipar, const Double_t *x, Double_t eps); 2446{; 2447 return GradientParTempl<Double_t>(ipar, x, eps);; 2448}; 2449 ; 2450////////////////////////////////////////////////////////////////////////////////; 2451/// Compute the gradient wrt parameters; 2452/// If the TF1 object is based on a formula expression (TFormula); 2453/// and TFormula::GenerateGradientPar() has been successfully called",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:89051,error,errors,89051,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['error'],['errors']
Availability,"///////////////////////////////////////////////////////////////////////////////; 238/// Use this function in case of a fatal error. It will abort the program.; 239 ; 240/// @warning Fatal() *will* not abort the program if `gErrorIgnoreLevel > kFatal`; 241/// - but for all reasonable settings it *will* abort.; 242// So let's be reasonable wrt Coverity:; 243// coverity[+kill]; 244void Fatal(const char *location, const char *fmt, ...); 245{; 246 std::va_list ap;; 247 va_start(ap, fmt);; 248 ErrorHandler(kFatal, location, fmt, ap);; 249 va_end(ap);; 250}; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gErrorAbortLevelInt_t gErrorAbortLevelDefinition TError.cxx:32; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35; Errorvoid Error(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Breakvoid Break(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:207; GetErrorHandlerErrorHandlerFunc_t GetErrorHandler()Returns the current error handler function.Definition TError.cxx:100; Infovoid Info(const char *location, const char *fmt,...)Use this function for informational messages.Definition TError.cxx:218; gErrorHandlerstatic ErrorHandlerFunc_t gErrorHandlerDefinition TError.cxx:38; SysErrorvoid SysError(const char *location, const char *fmt,...)Use this function in case a system (OS or GUI) related error occurred.Definition TError.cxx:196; GetErrorSystemMsgHandlerRefstatic ROOT::Internal::ErrorSystemMsgHandlerFunc_t & GetErrorSystemMsgHandlerRef()Definition TError.cxx:41; AbstractMethodvoid AbstractMethod(const char *method)This function can be used in abstract base classes in case one does not want to make the class a ""rea...Definition TError.cxx:159; ErrorHandlervoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8cxx_source.html:8884,error,error,8884,doc/master/TError_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////////////////////////////////////////////////////////; 990/// Issue error message. Use ""location"" to specify the method where the; 991/// error occurred. Accepts standard printf formatting arguments.; 992 ; 993void TObject::Error(const char *location, const char *va_(fmt), ...) const; 994{; 995 va_list ap;; 996 va_start(ap, va_(fmt));; 997 DoError(kError, location, va_(fmt), ap);; 998 va_end(ap);; 999 if (TROOT::Initialized()); 1000 gROOT->Message(1002, this);; 1001}; 1002 ; 1003////////////////////////////////////////////////////////////////////////////////; 1004/// Issue system error message. Use ""location"" to specify the method where; 1005/// the system error occurred. Accepts standard printf formatting arguments.; 1006 ; 1007void TObject::SysError(const char *location, const char *va_(fmt), ...) const; 1008{; 1009 va_list ap;; 1010 va_start(ap, va_(fmt));; 1011 DoError(kSysError, location, va_(fmt), ap);; 1012 va_end(ap);; 1013 if (TROOT::Initialized()); 1014 gROOT->Message(1003, this);; 1015}; 1016 ; 1017////////////////////////////////////////////////////////////////////////////////; 1018/// Issue fatal error message. Use ""location"" to specify the method where the; 1019/// fatal error occurred. Accepts standard printf formatting arguments.; 1020 ; 1021void TObject::Fatal(const char *location, const char *va_(fmt), ...) const; 1022{; 1023 va_list ap;; 1024 va_start(ap, va_(fmt));; 1025 DoError(kFatal, location, va_(fmt), ap);; 1026 va_end(ap);; 1027 if (TROOT::Initialized()); 1028 gROOT->Message(1004, this);; 1029}; 1030 ; 1031////////////////////////////////////////////////////////////////////////////////; 1032/// Use this method to implement an ""abstract"" method that you don't; 1033/// want to leave purely abstract.; 1034 ; 1035void TObject::AbstractMethod(const char *method) const; 1036{; 1037 Warning(method, ""this method must be overridden!"");; 1038}; 1039 ; 1040///////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:37616,error,error,37616,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,1,['error'],['error']
Availability,"/////////////////////////////////////////////////////////////////////////////; 1500/// Return a user configured or systemwide directory to create; 1501/// temporary files in.; 1502 ; 1503const char *TUnixSystem::TempDirectory() const; 1504{; 1505 const char *dir = gSystem->Getenv(""TMPDIR"");; 1506 if (!dir || gSystem->AccessPathName(dir, kWritePermission)); 1507 dir = ""/tmp"";; 1508 ; 1509 return dir;; 1510}; 1511 ; 1512////////////////////////////////////////////////////////////////////////////////; 1513/// Create a secure temporary file by appending a unique; 1514/// 6 letter string to base. The file will be created in; 1515/// a standard (system) directory or in the directory; 1516/// provided in dir. Optionally one can provide suffix; 1517/// append to the final name - like extension "".txt"" or "".html"".; 1518/// The full filename is returned in base; 1519/// and a filepointer is returned for safely writing to the file; 1520/// (this avoids certain security problems). Returns 0 in case; 1521/// of error.; 1522 ; 1523FILE *TUnixSystem::TempFileName(TString &base, const char *dir, const char *suffix); 1524{; 1525 char *b = ConcatFileName(dir ? dir : TempDirectory(), base);; 1526 base = b;; 1527 base += ""XXXXXX"";; 1528 const bool hasSuffix = suffix && *suffix;; 1529 if (hasSuffix); 1530 base.Append(suffix);; 1531 delete [] b;; 1532 ; 1533 char *arg = StrDup(base);; 1534 int fd = hasSuffix ? mkstemps(arg, strlen(suffix)) : mkstemp(arg);; 1535 base = arg;; 1536 delete [] arg;; 1537 ; 1538 if (fd == -1) {; 1539 SysError(""TempFileName"", ""%s"", base.Data());; 1540 return nullptr;; 1541 } else {; 1542 FILE *fp = fdopen(fd, ""w+"");; 1543 if (!fp); 1544 SysError(""TempFileName"", ""converting filedescriptor (%d)"", fd);; 1545 return fp;; 1546 }; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Concatenate a directory and a file name.; 1551 ; 1552const char *TUnixSystem::PrependPathName(const char *dir, TString& name); 1553{; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:46514,error,error,46514,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['error'],['error']
Availability,"/////////////////////////////////////////////////////////////////////////////; 8985/// Set statistics option on/off.; 8986///; 8987/// By default, the statistics box is drawn.; 8988/// The paint options can be selected via gStyle->SetOptStat.; 8989/// This function sets/resets the kNoStats bit in the histogram object.; 8990/// It has priority over the Style option.; 8991 ; 8992void TH1::SetStats(Bool_t stats); 8993{; 8994 ResetBit(kNoStats);; 8995 if (!stats) {; 8996 SetBit(kNoStats);; 8997 //remove the ""stats"" object from the list of functions; 8998 if (fFunctions) {; 8999 TObject *obj = fFunctions->FindObject(""stats"");; 9000 if (obj) {; 9001 fFunctions->Remove(obj);; 9002 delete obj;; 9003 }; 9004 }; 9005 }; 9006}; 9007 ; 9008////////////////////////////////////////////////////////////////////////////////; 9009/// Create structure to store sum of squares of weights.; 9010///; 9011/// if histogram is already filled, the sum of squares of weights; 9012/// is filled with the existing bin contents; 9013///; 9014/// The error per bin will be computed as sqrt(sum of squares of weight); 9015/// for each bin.; 9016///; 9017/// This function is automatically called when the histogram is created; 9018/// if the static function TH1::SetDefaultSumw2 has been called before.; 9019/// If flag = false the structure containing the sum of the square of weights; 9020/// is rest and it will be empty, but it is not deleted (i.e. GetSumw2()->fN = 0); 9021 ; 9022void TH1::Sumw2(Bool_t flag); 9023{; 9024 if (!flag) {; 9025 // clear the array if existing - do nothing otherwise; 9026 if (fSumw2.fN > 0 ) fSumw2.Set(0);; 9027 return;; 9028 }; 9029 ; 9030 if (fSumw2.fN == fNcells) {; 9031 if (!fgDefaultSumw2 ); 9032 Warning(""Sumw2"",""Sum of squares of weights structure already created"");; 9033 return;; 9034 }; 9035 ; 9036 fSumw2.Set(fNcells);; 9037 ; 9038 // empty the buffer; 9039 if (fBuffer) BufferEmpty();; 9040 ; 9041 if (fEntries > 0); 9042 for (Int_t i = 0; i < fNcells; ++i); 9043 fSumw2.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:351656,error,error,351656,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['error']
Availability,"///////////////////////////////////////////////////////////////////////////; 668/// It returns the error along Y at point `i`. For TGraphErrors this method is; 669/// the same as GetErrorY.; 670 ; 671Double_t TGraphErrors::GetErrorYlow(Int_t i) const; 672{; 673 if (i < 0 || i >= fNpoints) return -1;; 674 if (fEY) return fEY[i];; 675 return -1;; 676}; 677 ; 678////////////////////////////////////////////////////////////////////////////////; 679/// Adds all graphs with errors from the collection to this graph.; 680/// Returns the total number of points in the result or -1 in case of an error.; 681 ; 682Int_t TGraphErrors::Merge(TCollection* li); 683{; 684 TIter next(li);; 685 while (TObject* o = next()) {; 686 TGraph *g = dynamic_cast<TGraph*>(o);; 687 if (!g) {; 688 Error(""Merge"",; 689 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 690 return -1;; 691 }; 692 int n0 = GetN();; 693 int n1 = n0+g->GetN();; 694 Set(n1);; 695 Double_t * x = g->GetX();; 696 Double_t * y = g->GetY();; 697 Double_t * ex = g->GetEX();; 698 Double_t * ey = g->GetEY();; 699 for (Int_t i = 0 ; i < g->GetN(); i++) {; 700 SetPoint(n0+i, x[i], y[i]);; 701 if (ex) fEX[n0+i] = ex[i];; 702 if (ey) fEY[n0+i] = ey[i];; 703 }; 704 }; 705 return GetN();; 706}; 707 ; 708////////////////////////////////////////////////////////////////////////////////; 709/// Print graph and errors values.; 710 ; 711void TGraphErrors::Print(Option_t *) const; 712{; 713 for (Int_t i = 0; i < fNpoints; i++) {; 714 printf(""x[%d]=%g, y[%d]=%g, ex[%d]=%g, ey[%d]=%g\n"", i, fX[i], i, fY[i], i, fEX[i], i, fEY[i]);; 715 }; 716}; 717 ; 718 ; 719////////////////////////////////////////////////////////////////////////////////; 720/// Save primitive as a C++ statement(s) on output stream out; 721 ; 722void TGraphErrors::SavePrimitive(std::ostream &out, Option_t *option /*= """"*/); 723{; 724 out << "" "" << std::endl;; 725 static Int_t frameNumber = 1000;; 726 frameNumber++;; 727 ; 728 auto fXName = SaveArra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:22656,error,errors,22656,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['errors']
Availability,"/////////////////////////////////////////////////////////////////////////; 17// //; 18// TSelector //; 19// //; 20// A utility class for Trees selections. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24 ; 25#include ""TObject.h""; 26#include ""TString.h""; 27#include ""TSelectorList.h""; 28 ; 29class TTree;; 30 ; 31class TSelector : public TObject {; 32 ; 33public:; 34 enum EAbort { kContinue, kAbortProcess, kAbortFile };; 35 ; 36protected:; 37 Long64_t fStatus; ///< Selector status; 38 EAbort fAbort; ///< Abort status; 39 TString fOption; ///< Option given to TTree::Process; 40 TObject *fObject; ///<! Current object if processing object (vs. TTree); 41 TList *fInput; ///< List of objects available during processing; 42 TSelectorList *fOutput; ///<! List of objects created during processing; 43 ; 44private:; 45 TSelector(const TSelector&); // not implemented; 46 TSelector& operator=(const TSelector&); // not implemented; 47 ; 48public:; 49 TSelector();; 50 ~TSelector() override;; 51 ; 52 virtual int Version() const { return 0; }; 53 virtual void Init(TTree *) { }; 54 virtual void Begin(TTree *) { }; 55 virtual void SlaveBegin(TTree *) { }; 56 bool Notify() override { return true; }; 57 const char *GetOption() const override { return fOption.Data(); }; 58 virtual Long64_t GetStatus() const { return fStatus; }; 59 virtual Int_t GetEntry(Long64_t /*entry*/, Int_t /*getall*/ = 0) { return 0; }; 60 virtual bool ProcessCut(Long64_t /*entry*/);; 61 virtual void ProcessFill(Long64_t /*entry*/);; 62 virtual bool Process(Long64_t /*entry*/);; 63 virtual void ImportOutput(TList *output);; 64 virtual void SetOption(const char *option) { fOption = option; }; 65 virtual void SetObject(TObject *obj) { fObject = obj; }; 66 virtual void SetInputList(TList *input) { fInput = input; }; 67 virtual void SetStatus(Long64_t status) { fStatus = status; }; 68 virtual TList *GetInputList() const { return fInput; }; 69 virtual TList *GetOutputList()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8h_source.html:1424,avail,available,1424,doc/master/TSelector_8h_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8h_source.html,1,['avail'],['available']
Availability,"////////////////////////////////////////////////////////////////////////; 636/// Scan parameter ipar between value of xmin and xmax; 637/// A array for x and y points should be provided; 638 ; 639bool FitResult::Scan(unsigned int ipar, unsigned int &npoints, double *pntsx, double *pntsy, double xmin, double xmax); 640{; 641 if (!pntsx || !pntsy || !npoints); 642 return false;; 643 ; 644 if (!fMinimizer) {; 645 MATH_ERROR_MSG(""FitResult::Scan"", ""Minimizer is not available - cannot Scan"");; 646 return false;; 647 }; 648 ; 649 return fMinimizer->Scan(ipar, npoints, pntsx, pntsy, xmin, xmax);; 650}; 651 ; 652////////////////////////////////////////////////////////////////////////////////; 653/// Create a 2D contour around the minimum for the parameter ipar and jpar; 654/// if a minimum does not exist or is invalid it will return false; 655/// A array for x and y points should be provided; 656/// Pass optionally the confidence level, default is 0.683; 657/// it is assumed that ErrorDef() defines the right error definition; 658/// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level; 659 ; 660bool FitResult::Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel); 661{; 662 if (!pntsx || !pntsy || !npoints); 663 return false;; 664 ; 665 if (!fMinimizer) {; 666 MATH_ERROR_MSG(""FitResult::Contour"", ""Minimizer is not available - cannot produce Contour"");; 667 return false;; 668 }; 669 ; 670 // get error level used for fitting; 671 double upScale = fMinimizer->ErrorDef();; 672 ; 673 double upVal = TMath::ChisquareQuantile(confLevel, 2); // 2 is number of parameter we do the contour; 674 ; 675 // set required error definition in minimizer; 676 fMinimizer->SetErrorDef(upScale * upVal);; 677 ; 678 bool ret = fMinimizer->Contour(ipar, jpar, npoints, pntsx, pntsy);; 679 ; 680 // restore the error level used for fitting; 681 fMinimizer->SetErrorDef(upScale);; 682 ; 683 return ret;; 68",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8cxx_source.html:24362,error,error,24362,doc/master/FitResult_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////; 740/// Return the content of the filled bin number ""idx"".; 741/// If coord is non-null, it will contain the bin's coordinates for each axis; 742/// that correspond to the bin.; 743 ; 744Double_t THnSparse::GetBinContent(Long64_t idx, Int_t* coord /* = 0 */) const; 745{; 746 if (idx >= 0) {; 747 THnSparseArrayChunk* chunk = GetChunk(idx / fChunkSize);; 748 idx %= fChunkSize;; 749 if (chunk && chunk->fContent->GetSize() > idx) {; 750 if (coord) {; 751 THnSparseCompactBinCoord* cc = GetCompactCoord();; 752 Int_t sizeCompact = cc->GetBufferSize();; 753 cc->SetCoordFromBuffer(chunk->fCoordinates + idx * sizeCompact,; 754 coord);; 755 ; 756 }; 757 return chunk->fContent->GetAt(idx);; 758 }; 759 }; 760 if (coord); 761 memset(coord, -1, sizeof(Int_t) * fNdimensions);; 762 return 0.;; 763}; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Get square of the error of bin addressed by linidx as; 767/// \f$\sum weight^{2}\f$; 768/// If errors are not enabled (via Sumw2() or CalculateErrors()); 769/// return contents.; 770 ; 771Double_t THnSparse::GetBinError2(Long64_t linidx) const {; 772 if (!GetCalculateErrors()); 773 return GetBinContent(linidx);; 774 ; 775 if (linidx < 0) return 0.;; 776 THnSparseArrayChunk* chunk = GetChunk(linidx / fChunkSize);; 777 linidx %= fChunkSize;; 778 if (!chunk || chunk->fContent->GetSize() < linidx); 779 return 0.;; 780 ; 781 return chunk->fSumw2->GetAt(linidx);; 782}; 783 ; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Return the index for fCurrentBinIndex.; 787/// If it doesn't exist then return -1, or allocate a new bin if allocate is set; 788 ; 789Long64_t THnSparse::GetBinIndexForCurrentBin(Bool_t allocate); 790{; 791 THnSparseCompactBinCoord* cc = GetCompactCoord();; 792 ULong64_t hash = cc->GetHash();; 793 if (fBinContent.GetSize() && !fBins.GetSize()); 794 FillExMap(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:28780,error,error,28780,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"////////////////////////////////////////////////////////////////////////; 91/// Assignment operator.; 92/// if needed copy the TFitResult object and delete previous one if existing; 93 ; 94TFitResultPtr & TFitResultPtr::operator=(const TFitResultPtr& rhs); 95{; 96 if ( &rhs == this) return *this; // self assignment; 97 fStatus = rhs.fStatus;; 98 fPointer = rhs.fPointer; ; 99 // if ( fPointer ) delete fPointer;; 100 // fPointer = 0;; 101 // if (rhs.fPointer != 0) fPointer = new TFitResult(*rhs);; 102 return *this;; 103}; 104 ; 105////////////////////////////////////////////////////////////////////////////////; 106/// Print the TFitResultPtr by printing its TFitResult.; 107 ; 108std::string cling::printValue(const TFitResultPtr* val) {; 109 if (TFitResult* fr = val->Get()); 110 return printValue(fr);; 111 return ""<nullptr TFitResult>"";; 112}; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TFitResultPtr.h; TFitResult.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointe...Definition TFitResultPtr.h:32; TFitResultPtr::~TFitResultPtrvirtual ~TFitResultPtr()Destructor.Definition TFitResultPtr.cxx:55; TFitResultPtr::GetTFitResult * Get() constReturn contained pointer.Definition TFitResultPtr.cxx:86; TFitResultPtr::fPointerstd::shared_ptr< TFitResult > fPointer! Smart Pointer to TFitResult classDefinition TFitResultPtr.h:58; TFitResultPtr::fStatusint fStatusfit status codeDefinition TFitResultPtr.h:57; TFitResultPtr::operator*TFitResult & operator*() constImplement the de-reference operator to make the class acts as a pointer to a TFitResult assert in cas...Definition TFitResultPtr.cxx:63; TFitResultPtr::operator->TFitResult * operator->() constImplement the -> operator to make th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFitResultPtr_8cxx_source.html:4230,error,error,4230,doc/master/TFitResultPtr_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFitResultPtr_8cxx_source.html,1,['error'],['error']
Availability,"///////////////////////////////////////////////////////////////////////; 298/// Default destructor.; 299 ; 300TLegend::~TLegend(); 301{; 302 if (fPrimitives); 303 fPrimitives->Delete();; 304 delete fPrimitives;; 305 fPrimitives = nullptr;; 306}; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Add a new entry to this legend. ""obj"" is the object to be represented.; 310/// ""label"" is the text you wish to associate with obj in the legend.; 311/// If ""label"" is null or empty, the title of the object will be used.; 312///; 313/// Options are:; 314///; 315/// - L: draw line associated with TAttLine if obj inherits from TAttLine; 316/// - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; 317/// - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; 318/// - E: draw vertical error bar if option ""L"" is also specified; 319 ; 320TLegendEntry *TLegend::AddEntry(const TObject *obj, const char *label, Option_t *option); 321{; 322 const char *lab = label;; 323 ; 324 if (obj && (!label || strlen(label)==0)) lab = obj->GetTitle();; 325 TLegendEntry *newentry = new TLegendEntry( obj, lab, option );; 326 if ( !fPrimitives ) fPrimitives = new TList;; 327 fPrimitives->Add(newentry);; 328 return newentry;; 329}; 330 ; 331////////////////////////////////////////////////////////////////////////////////; 332/// Add a new entry to this legend. ""name"" is the name of an object in the pad to; 333/// be represented label is the text you wish to associate with obj in the legend; 334/// if label is null or empty, the title of the object will be used.; 335///; 336/// Options are:; 337///; 338/// - L: draw line associated with TAttLine if obj inherits from TAttLine; 339/// - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; 340/// - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; 341/// - E: draw vertical error bar if option ""L"" is also specified; 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLegend_8cxx_source.html:11431,error,error,11431,doc/master/TLegend_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////////////////////////////////////////////////; 149/// Almost the same as TClass::GetMethodWithPrototype().; 150 ; 151TMethod *GetMethodWithPrototype(TClass *cl, const char *method,; 152 const char *proto, Int_t &nargs); 153{; 154 nargs = 0;; 155 ; 156 if (!gInterpreter || cl == nullptr) return nullptr;; 157 ; 158 TMethod *m = cl->GetMethodWithPrototype(method,proto);; 159 if (m) nargs = m->GetNargs();; 160 return m;; 161}; 162 ; 163////////////////////////////////////////////////////////////////////////////////; 164/// Almost the same as TClass::GetMethod().; 165 ; 166static TMethod *GetMethod(TClass *cl, const char *method, const char *params); 167{; 168 if (!gInterpreter || cl == nullptr) return nullptr;; 169 return cl->GetMethod(method,params);; 170}; 171 ; 172}; 173 ; 174////////////////////////////////////////////////////////////////////////////////; 175/// Checking of consistency of sender/receiver methods/arguments.; 176/// Returns -1 on error, otherwise number or arguments of signal function.; 177/// Static method.; 178 ; 179Int_t TQObject::CheckConnectArgs(TQObject *sender,; 180 TClass *sender_class, const char *signal,; 181 TClass *receiver_class, const char *slot); 182{; 183 auto len = strlen(signal)+1;; 184 char *signal_method = new char[len];; 185 if (signal_method) strlcpy(signal_method, signal, len);; 186 ; 187 char *signal_proto;; 188 char *tmp;; 189 ; 190 if ((signal_proto = strchr(signal_method,'('))) {; 191 // substitute first '(' symbol with '\0'; 192 *signal_proto++ = '\0';; 193 // substitute last ')' symbol with '\0'; 194 if ((tmp = strrchr(signal_proto,')'))) *tmp = '\0';; 195 }; 196 ; 197 if (!signal_proto) signal_proto = (char*)""""; // avoid zero strings; 198 ; 199 // if delegation object TQObjSender is used get the real sender class; 200 if (sender && sender_class == TQObjSender::Class()) {; 201 sender_class = TClass::GetClass(sender->GetSenderClassName());; 202 if (!sender_class) {; 203 ::Error(""TQObject::CheckConnec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8cxx_source.html:5757,error,error,5757,doc/master/TQObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////////////////////////////////////////////////; 3074/// Reset the interpreter internal state in case a previous action was not correctly; 3075/// terminated.; 3076 ; 3077void TCling::ClearFileBusy(); 3078{; 3079 // No-op there is not equivalent state (to be cleared) in Cling.; 3080}; 3081 ; 3082////////////////////////////////////////////////////////////////////////////////; 3083/// Delete existing temporary values.; 3084 ; 3085void TCling::ClearStack(); 3086{; 3087 // No-op for cling due to cling::Value.; 3088}; 3089 ; 3090////////////////////////////////////////////////////////////////////////////////; 3091/// Declare code to the interpreter, without any of the interpreter actions; 3092/// that could trigger a re-interpretation of the code. I.e. make cling; 3093/// behave like a compiler: no dynamic lookup, no input wrapping for; 3094/// subsequent execution, no automatic provision of declarations but just a; 3095/// plain `#include`.; 3096/// Returns true on success, false on failure.; 3097 ; 3098bool TCling::Declare(const char* code); 3099{; 3100 R__LOCKGUARD_CLING(gInterpreterMutex);; 3101 ; 3102 SuspendAutoLoadingRAII autoLoadOff(this);; 3103 SuspendAutoParsing autoParseRaii(this);; 3104 ; 3105 bool oldDynLookup = fInterpreter->isDynamicLookupEnabled();; 3106 fInterpreter->enableDynamicLookup(false);; 3107 bool oldRawInput = fInterpreter->isRawInputEnabled();; 3108 fInterpreter->enableRawInput(true);; 3109 ; 3110 Bool_t ret = LoadText(code);; 3111 ; 3112 fInterpreter->enableRawInput(oldRawInput);; 3113 fInterpreter->enableDynamicLookup(oldDynLookup);; 3114 return ret;; 3115}; 3116 ; 3117////////////////////////////////////////////////////////////////////////////////; 3118/// It calls a ""fantom"" method to synchronize user keyboard input; 3119/// and ROOT prompt line.; 3120 ; 3121void TCling::EndOfLineAction(); 3122{; 3123 ProcessLineSynch(fantomline);; 3124}; 3125 ; 3126// This static function is a hop of TCling::IsLibraryLoaded, which i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:119635,failure,failure,119635,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['failure'],['failure']
Availability,"//////////////////////////////////////////////////////////////////////; 5313/// Double the number of bins for axis.; 5314/// Refill histogram.; 5315/// This function is called by TAxis::FindBin(const char *label); 5316 ; 5317void TH1::LabelsInflate(Option_t *ax); 5318{; 5319 Int_t iaxis = AxisChoice(ax);; 5320 TAxis *axis = nullptr;; 5321 if (iaxis == 1) axis = GetXaxis();; 5322 if (iaxis == 2) axis = GetYaxis();; 5323 if (iaxis == 3) axis = GetZaxis();; 5324 if (!axis) return;; 5325 ; 5326 TH1 *hold = (TH1*)IsA()->New();; 5327 hold->SetDirectory(nullptr);; 5328 Copy(*hold);; 5329 hold->ResetBit(kMustCleanup);; 5330 ; 5331 Bool_t timedisp = axis->GetTimeDisplay();; 5332 Int_t nbins = axis->GetNbins();; 5333 Double_t xmin = axis->GetXmin();; 5334 Double_t xmax = axis->GetXmax();; 5335 xmax = xmin + 2*(xmax-xmin);; 5336 axis->SetRange(0,0);; 5337 // double the bins and recompute ncells; 5338 axis->Set(2*nbins,xmin,xmax);; 5339 SetBinsLength(-1);; 5340 Int_t errors = fSumw2.fN;; 5341 if (errors) fSumw2.Set(fNcells);; 5342 axis->SetTimeDisplay(timedisp);; 5343 ; 5344 Reset(""ICE""); // reset content and error; 5345 ; 5346 //now loop on all bins and refill; 5347 Double_t oldEntries = fEntries;; 5348 Int_t bin,ibin,binx,biny,binz;; 5349 for (ibin =0; ibin < hold->fNcells; ibin++) {; 5350 // get the binx,y,z values . The x-y-z (axis) bin values will stay the same between new-old after the expanding; 5351 hold->GetBinXYZ(ibin,binx,biny,binz);; 5352 bin = GetBin(binx,biny,binz);; 5353 ; 5354 // underflow and overflow will be cleaned up because their meaning has been altered; 5355 if (hold->IsBinUnderflow(ibin,iaxis) || hold->IsBinOverflow(ibin,iaxis)) {; 5356 continue;; 5357 }; 5358 else {; 5359 AddBinContent(bin, hold->RetrieveBinContent(ibin));; 5360 if (errors) fSumw2.fArray[bin] += hold->fSumw2.fArray[ibin];; 5361 }; 5362 }; 5363 fEntries = oldEntries;; 5364 delete hold;; 5365}; 5366 ; 5367////////////////////////////////////////////////////////////////////////////////; 536",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:214644,error,errors,214644,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"/////////////////////////////////////////////////////////////////////; 1714/// Read a buffer from the file at the offset 'pos' in the file.; 1715///; 1716/// Returns kTRUE in case of failure.; 1717/// Compared to ReadBuffer(char*, Int_t), this routine does _not_; 1718/// change the cursor on the physical file representation (fD); 1719/// if the data is in this TFile's cache.; 1720 ; 1721Bool_t TFile::ReadBuffer(char *buf, Long64_t pos, Int_t len); 1722{; 1723 if (IsOpen()) {; 1724 ; 1725 SetOffset(pos);; 1726 ; 1727 Int_t st;; 1728 Double_t start = 0;; 1729 if (gPerfStats) start = TTimeStamp();; 1730 ; 1731 if ((st = ReadBufferViaCache(buf, len))) {; 1732 if (st == 2); 1733 return kTRUE;; 1734 return kFALSE;; 1735 }; 1736 ; 1737 Seek(pos);; 1738 ssize_t siz;; 1739 ; 1740 while ((siz = SysRead(fD, buf, len)) < 0 && GetErrno() == EINTR); 1741 ResetErrno();; 1742 ; 1743 if (siz < 0) {; 1744 SysError(""ReadBuffer"", ""error reading from file %s"", GetName());; 1745 return kTRUE;; 1746 }; 1747 if (siz != len) {; 1748 Error(""ReadBuffer"", ""error reading all requested bytes from file %s, got %ld of %d"",; 1749 GetName(), (Long_t)siz, len);; 1750 return kTRUE;; 1751 }; 1752 fBytesRead += siz;; 1753 fgBytesRead += siz;; 1754 fReadCalls++;; 1755 fgReadCalls++;; 1756 ; 1757 if (gMonitoringWriter); 1758 gMonitoringWriter->SendFileReadProgress(this);; 1759 if (gPerfStats) {; 1760 gPerfStats->FileReadEvent(this, len, start);; 1761 }; 1762 return kFALSE;; 1763 }; 1764 return kTRUE;; 1765}; 1766 ; 1767////////////////////////////////////////////////////////////////////////////////; 1768/// Read a buffer from the file. This is the basic low level read operation.; 1769/// Returns kTRUE in case of failure.; 1770 ; 1771Bool_t TFile::ReadBuffer(char *buf, Int_t len); 1772{; 1773 if (IsOpen()) {; 1774 ; 1775 Int_t st;; 1776 if ((st = ReadBufferViaCache(buf, len))) {; 1777 if (st == 2); 1778 return kTRUE;; 1779 return kFALSE;; 1780 }; 1781 ; 1782 ssize_t siz;; 1783 Double_t start = 0;; 1784 ; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:63540,error,error,63540,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,['error'],['error']
Availability,/////////////////////////////////////////////////////////////////////; 215/// This function is called by Graph2DFitChisquare.; 216/// It returns the error along Y at point i.; 217 ; 218Double_t TGraph2DErrors::GetErrorY(Int_t i) const; 219{; 220 if (i < 0 || i >= fNpoints) return -1;; 221 if (fEY) return fEY[i];; 222 return -1;; 223}; 224 ; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// This function is called by Graph2DFitChisquare.; 228/// It returns the error along Z at point i.; 229 ; 230Double_t TGraph2DErrors::GetErrorZ(Int_t i) const; 231{; 232 if (i < 0 || i >= fNpoints) return -1;; 233 if (fEZ) return fEZ[i];; 234 return -1;; 235}; 236 ; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// Returns the X maximum with errors.; 240 ; 241Double_t TGraph2DErrors::GetXmaxE() const; 242{; 243 Double_t v = fX[0]+fEX[0];; 244 for (Int_t i=1; i<fNpoints; i++) if (fX[i]+fEX[i]>v) v=fX[i]+fEX[i];; 245 return v;; 246}; 247 ; 248 ; 249////////////////////////////////////////////////////////////////////////////////; 250/// Returns the X minimum with errors.; 251 ; 252Double_t TGraph2DErrors::GetXminE() const; 253{; 254 Double_t v = fX[0]-fEX[0];; 255 for (Int_t i=1; i<fNpoints; i++) if (fX[i]-fEX[i]<v) v=fX[i]-fEX[i];; 256 return v;; 257}; 258 ; 259 ; 260////////////////////////////////////////////////////////////////////////////////; 261/// Returns the Y maximum with errors.; 262 ; 263Double_t TGraph2DErrors::GetYmaxE() const; 264{; 265 Double_t v = fY[0]+fEY[0];; 266 for (Int_t i=1; i<fNpoints; i++) if (fY[i]+fEY[i]>v) v=fY[i]+fEY[i];; 267 return v;; 268}; 269 ; 270 ; 271////////////////////////////////////////////////////////////////////////////////; 272/// Returns the Y minimum with errors.; 273 ; 274Double_t TGraph2DErrors::GetYminE() const; 275{; 276 Double_t v = fY[0]-fEY[0];; 277 for (Int_t i=1; i<fNpoints; i++) if (fY[i]-fEY[i]<v) v=fY[i]-fEY[i];; 278 return v;; 279}; 2,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:7311,error,errors,7311,doc/master/TGraph2DErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html,1,['error'],['errors']
Availability,"/////////////////////////////////////////////////////////////////////; 361/// Execute method on this object with the given parameter string, e.g.; 362/// ""3.14,1,\""text\"""".; 363 ; 364void TObject::Execute(const char *method, const char *params, Int_t *error); 365{; 366 if (!IsA()) return;; 367 ; 368 Bool_t must_cleanup = TestBit(kMustCleanup);; 369 ; 370 gInterpreter->Execute(this, IsA(), method, params, error);; 371 ; 372 if (gPad && must_cleanup) gPad->Modified();; 373}; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// Execute method on this object with parameters stored in the TObjArray.; 377/// The TObjArray should contain an argv vector like:; 378/// ~~~ {.cpp}; 379/// argv[0] ... argv[n] = the list of TObjString parameters; 380/// ~~~; 381 ; 382void TObject::Execute(TMethod *method, TObjArray *params, Int_t *error); 383{; 384 if (!IsA()) return;; 385 ; 386 Bool_t must_cleanup = TestBit(kMustCleanup);; 387 ; 388 gInterpreter->Execute(this, IsA(), method, params, error);; 389 ; 390 if (gPad && must_cleanup) gPad->Modified();; 391}; 392 ; 393 ; 394////////////////////////////////////////////////////////////////////////////////; 395/// Execute action corresponding to an event at (px,py). This method; 396/// must be overridden if an object can react to graphics events.; 397 ; 398void TObject::ExecuteEvent(Int_t, Int_t, Int_t); 399{; 400 // AbstractMethod(""ExecuteEvent"");; 401}; 402 ; 403////////////////////////////////////////////////////////////////////////////////; 404/// Must be redefined in derived classes.; 405/// This function is typically used with TCollections, but can also be used; 406/// to find an object by name inside this object.; 407 ; 408TObject *TObject::FindObject(const char *) const; 409{; 410 return nullptr;; 411}; 412 ; 413////////////////////////////////////////////////////////////////////////////////; 414/// Must be redefined in derived classes.; 415/// This function is typically used with TColl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:13361,error,error,13361,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,2,['error'],['error']
Availability,"/////////////////////////////////////////////////////////////////////; 62/// Releases the resources associated to a file opened with davix; 63int VfsRdOnlyClose(sqlite3_file *pFile); 64{; 65 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 66 // We can't use delete because the storage for p is managed by sqlite; 67 p->~VfsRootFile();; 68 return SQLITE_OK;; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////; 72/// Issues a byte range request for a chunk to the raw file; 73int VfsRdOnlyRead(sqlite3_file *pFile, void *zBuf, int count, sqlite_int64 offset); 74{; 75 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 76 auto nbytes = p->fRawFile->ReadAt(zBuf, count, offset);; 77 return (nbytes != static_cast<unsigned int>(count)) ? SQLITE_IOERR : SQLITE_OK;; 78}; 79 ; 80////////////////////////////////////////////////////////////////////////////; 81/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 82int VfsRdOnlyWrite(sqlite3_file * /*pFile*/, const void * /*zBuf*/, int /*iAmt*/, sqlite_int64 /*iOfst*/); 83{; 84 return SQLITE_OPEN_READONLY;; 85}; 86 ; 87////////////////////////////////////////////////////////////////////////////; 88/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 89int VfsRdOnlyTruncate(sqlite3_file * /*pFile*/, sqlite_int64 /*size*/); 90{; 91 return SQLITE_OPEN_READONLY;; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////; 95/// As the database is read-only, syncing data to disc is a no-op and always succeeds; 96int VfsRdOnlySync(sqlite3_file * /*pFile*/, int /*flags*/); 97{; 98 return SQLITE_OK;; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinterpret_cast<VfsRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSqliteDS_8cxx_source.html:3970,error,error,3970,doc/master/RSqliteDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////; 1594/// Sets pointer to data array provided by user.; 1595/// Necessary if SetFCN is not called.; 1596///; 1597/// - numpoints: number of experimental points; 1598/// - vecsize: size of data point vector + 2; 1599/// (for N-dimensional fit vecsize=N+2); 1600/// - exdata: data array with following format; 1601///; 1602/// - exdata[0] = ExpValue_0 - experimental data value number 0; 1603/// - exdata[1] = ExpSigma_0 - error of value number 0; 1604/// - exdata[2] = X_0[0]; 1605/// - exdata[3] = X_0[1]; 1606///; 1607/// - exdata[vecsize-1] = X_0[vecsize-3]; 1608/// - exdata[vecsize] = ExpValue_1; 1609/// - exdata[vecsize+1] = ExpSigma_1; 1610/// - exdata[vecsize+2] = X_1[0]; 1611///; 1612/// - exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1); 1613///; 1614/// - exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]; 1615 ; 1616void TFumili::SetData(Double_t *exdata,Int_t numpoints,Int_t vecsize){; 1617 if(exdata){; 1618 fNED1 = numpoints;; 1619 fNED2 = vecsize;; 1620 fEXDA = exdata;; 1621 }; 1622}; 1623 ; 1624 ; 1625////////////////////////////////////////////////////////////////////////////////; 1626/// ret fit method (chisquare or log-likelihood); 1627 ; 1628void TFumili::SetFitMethod(const char *name); 1629{; 1630 if (!strcmp(name,""H1FitChisquare"")) SetFCN(H1FitChisquareFumili);; 1631 if (!strcmp(name,""H1FitLikelihood"")) SetFCN(H1FitLikelihoodFumili);; 1632 if (!strcmp(name,""GraphFitChisquare"")) SetFCN(GraphFitChisquareFumili);; 1633}; 1634 ; 1635////////////////////////////////////////////////////////////////////////////////; 1636/// Sets for parameter number ipar initial parameter value,; 1637/// name parname, initial error verr and limits vlow and vhigh; 1638/// - If vlow = vhigh but not equal to zero, parameter will be fixed.; 1639/// - If vlow = vhigh = 0, parameter is released and its limits are discarded; 1640 ; 1641Int_t TFumili::SetParameter(Int_t ipar,const char *parname,Double_t va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:45625,error,error,45625,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////; 931/// Project this profile3D into a 3-D histogram along X,Y,Z.; 932///; 933/// The projection is always of the type TH3D.; 934///; 935/// - if option ""E"" is specified, the errors are computed. (default); 936/// - if option ""B"" is specified, the content of bin of the returned histogram; 937/// will be equal to the GetBinEntries(bin) of the profile,; 938/// - if option ""C=E"" the bin contents of the projection are set to the; 939/// bin errors of the profile; 940/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 941/// to be equal to the errors of the profile.; 942/// Option ""E"" is defined as the default one in the header file.; 943/// - if option """" is specified the histogram errors are simply the sqrt of its content; 944/// - if option ""B"" is specified, the content of bin of the returned histogram; 945/// will be equal to the GetBinEntries(bin) of the profile,; 946/// - if option ""C=E"" the bin contents of the projection are set to the; 947/// bin errors of the profile; 948/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 949/// product of the bin content of the profile and the entries.; 950/// With this option the returned histogram will be equivalent to the one obtained by; 951/// filling directly a TH2D using the 3-rd value as a weight.; 952/// This option makes sense only for profile filled with all weights =1.; 953/// When the profile is weighted (filled with weights different than 1) the; 954/// bin error of the projected histogram (obtained using this option ""W"") cannot be; 955/// correctly computed from the information stored in the profile. In that case the; 956/// obtained histogram contains as bin error square the weighted sum of the square of the; 957/// profiled observable (TProfile2D::fSumw2[bin] ); 958///; 959/// Note that the axis range is not considered when doing the projection; 960 ; 961TH3D *TProf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:33594,error,errors,33594,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,2,['error'],['errors']
Availability,"///////////////////////////////////////////////////////////////////; 6588/// Multiply this histogram by a constant c1.; 6589///; 6590/// `this = c1*this`; 6591///; 6592/// Note that both contents and errors (if any) are scaled.; 6593/// This function uses the services of TH1::Add; 6594///; 6595/// IMPORTANT NOTE: Sumw2() is called automatically when scaling.; 6596/// If you are not interested in the histogram statistics you can call; 6597/// Sumw2(kFALSE) or use the option ""nosw2""; 6598///; 6599/// One can scale a histogram such that the bins integral is equal to; 6600/// the normalization parameter via TH1::Scale(Double_t norm), where norm; 6601/// is the desired normalization divided by the integral of the histogram.; 6602///; 6603/// If option contains ""width"" the bin contents and errors are divided; 6604/// by the bin width.; 6605 ; 6606void TH1::Scale(Double_t c1, Option_t *option); 6607{; 6608 ; 6609 TString opt = option; opt.ToLower();; 6610 // store bin errors when scaling since cannot anymore be computed as sqrt(N); 6611 if (!opt.Contains(""nosw2"") && GetSumw2N() == 0) Sumw2();; 6612 if (opt.Contains(""width"")) Add(this, this, c1, -1);; 6613 else {; 6614 if (fBuffer) BufferEmpty(1);; 6615 for(Int_t i = 0; i < fNcells; ++i) UpdateBinContent(i, c1 * RetrieveBinContent(i));; 6616 if (fSumw2.fN) for(Int_t i = 0; i < fNcells; ++i) fSumw2.fArray[i] *= (c1 * c1); // update errors; 6617 // update global histograms statistics; 6618 Double_t s[kNstat] = {0};; 6619 GetStats(s);; 6620 for (Int_t i=0 ; i < kNstat; i++) {; 6621 if (i == 1) s[i] = c1*c1*s[i];; 6622 else s[i] = c1*s[i];; 6623 }; 6624 PutStats(s);; 6625 SetMinimum(); SetMaximum(); // minimum and maximum value will be recalculated the next time; 6626 }; 6627 ; 6628 // if contours set, must also scale contours; 6629 Int_t ncontours = GetContour();; 6630 if (ncontours == 0) return;; 6631 Double_t* levels = fContour.GetArray();; 6632 for (Int_t i = 0; i < ncontours; ++i) levels[i] *= c1;; 6633}; 6634 ; 6635///////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:260343,error,errors,260343,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"//////////////////////////////////////////////////////////////////; 1046/// histogramming utility; 1047 ; 1048TString TMVA::Tools::GetYTitleWithUnit( const TH1& h, const TString& unit, Bool_t normalised ); 1049{; 1050 TString retval = ( normalised ? ""(1/N) "" : """" );; 1051 retval += TString::Format( ""dN_{ }/^{ }%.3g %s"", h.GetXaxis()->GetBinWidth(1), unit.Data() );; 1052 return retval;; 1053}; 1054 ; 1055////////////////////////////////////////////////////////////////////////////////; 1056/// writes a float value with the available precision to a stream; 1057 ; 1058void TMVA::Tools::WriteFloatArbitraryPrecision( Float_t val, ostream& os ); 1059{; 1060 os << val << "" :: "";; 1061 void * c = &val;; 1062 for (int i=0; i<4; i++) {; 1063 Int_t ic = *((char*)c+i)-'\0';; 1064 if (ic<0) ic+=256;; 1065 os << ic << "" "";; 1066 }; 1067 os << "":: "";; 1068}; 1069 ; 1070////////////////////////////////////////////////////////////////////////////////; 1071/// reads a float value with the available precision from a stream; 1072 ; 1073void TMVA::Tools::ReadFloatArbitraryPrecision( Float_t& val, istream& is ); 1074{; 1075 Float_t a = 0;; 1076 is >> a;; 1077 TString dn;; 1078 is >> dn;; 1079 Int_t c[4];; 1080 void * ap = &a;; 1081 for (int i=0; i<4; i++) {; 1082 is >> c[i];; 1083 *((char*)ap+i) = '\0'+c[i];; 1084 }; 1085 is >> dn;; 1086 val = a;; 1087}; 1088 ; 1089// XML file reading/writing helper functions; 1090 ; 1091////////////////////////////////////////////////////////////////////////////////; 1092/// add attribute from xml; 1093 ; 1094Bool_t TMVA::Tools::HasAttr( void* node, const char* attrname ); 1095{; 1096 return xmlengine().HasAttr(node, attrname);; 1097}; 1098 ; 1099////////////////////////////////////////////////////////////////////////////////; 1100/// add attribute from xml; 1101 ; 1102void TMVA::Tools::ReadAttr( void* node, const char* attrname, TString& value ); 1103{; 1104 if (!HasAttr(node, attrname)) {; 1105 const char * nodename = xmlengine().GetNodeName(node);; 11",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:36538,avail,available,36538,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,2,['avail'],['available']
Availability,"/////////////////////////////////////////////////////////////////; 200/// Apply a function to all data points \f$ y = f(x,y) \f$.; 201///; 202/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 203/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$.; 204///; 205/// Special treatment has to be applied for the functions where the; 206/// role of ""up"" and ""down"" is reversed.; 207///; 208/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 209 ; 210void TGraphBentErrors::Apply(TF1 *f); 211{; 212 Double_t x,y,exl,exh,eyl,eyh,eyl_new,eyh_new,fxy;; 213 ; 214 if (fHistogram) {; 215 delete fHistogram;; 216 fHistogram = nullptr;; 217 }; 218 for (Int_t i = 0; i < GetN(); i++) {; 219 GetPoint(i, x, y);; 220 exl = GetErrorXlow(i);; 221 exh = GetErrorXhigh(i);; 222 eyl = GetErrorYlow(i);; 223 eyh = GetErrorYhigh(i);; 224 ; 225 fxy = f->Eval(x, y);; 226 SetPoint(i, x, fxy);; 227 ; 228 // in the case of the functions like y-> -1*y the roles of the; 229 // upper and lower error bars is reversed; 230 if (f->Eval(x,y-eyl) < f->Eval(x,y+eyh)) {; 231 eyl_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 232 eyh_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 233 } else {; 234 eyh_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 235 eyl_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 236 }; 237 ; 238 //error on x doesn't change; 239 SetPointError(i,exl,exh,eyl_new,eyh_new);; 240 }; 241 if (gPad) gPad->Modified();; 242}; 243 ; 244 ; 245////////////////////////////////////////////////////////////////////////////////; 246/// Compute range.; 247 ; 248void TGraphBentErrors::ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const; 249{; 250 TGraph::ComputeRange(xmin,ymin,xmax,ymax);; 251 ; 252 for (Int_t i=0;i<fNpoints;i++) {; 253 if (fX[i] -fEXlow[i] < xmin) {; 254 if (gPad && gPad->GetLogx()) {; 255 if (fEXlow[i] < fX[i]) xmin = fX[i]-fEXlow[i];; 256 else xmin = TMath::Min(xmin,fX[i]/3);; 257 } else {; 258 xmin = fX[i]-fEXlow[i];; 259 }; 260 }; 261 if (fX[i] +fEXh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:7672,error,error,7672,doc/master/TGraphBentErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html,2,['error'],['error']
Availability,"/////////////////////////////////////////////////////////////////; 7455/// Let the interpreter issue a generic error, and set its error state.; 7456 ; 7457void TCling::GenericError(const char* error) const; 7458{; 7459#if defined(R__MUST_REVISIT); 7460#if R__MUST_REVISIT(6,2); 7461 Warning(""GenericError"",""Interface not available yet."");; 7462#endif; 7463#endif; 7464}; 7465 ; 7466////////////////////////////////////////////////////////////////////////////////; 7467/// This routines used to return the address of the internal wrapper; 7468/// function (of the interpreter) that was used to call *all* the; 7469/// interpreted functions that were bytecode compiled (no longer; 7470/// interpreted line by line). In Cling, there is no such; 7471/// wrapper function.; 7472/// In practice this routines was use to decipher whether the; 7473/// pointer returns by InterfaceMethod could be used to uniquely; 7474/// represent the function. In Cling if the function is in a; 7475/// useable state (its compiled version is available), this is; 7476/// always the case.; 7477/// See TClass::GetMethod.; 7478 ; 7479Long_t TCling::GetExecByteCode() const; 7480{; 7481 return 0;; 7482}; 7483 ; 7484////////////////////////////////////////////////////////////////////////////////; 7485/// Interface to cling function; 7486 ; 7487int TCling::GetSecurityError() const; 7488{; 7489#if defined(R__MUST_REVISIT); 7490#if R__MUST_REVISIT(6,2); 7491 Warning(""GetSecurityError"", ""Interface not available yet."");; 7492#endif; 7493#endif; 7494 return 0;; 7495}; 7496 ; 7497////////////////////////////////////////////////////////////////////////////////; 7498/// Load a source file or library called path into the interpreter.; 7499 ; 7500int TCling::LoadFile(const char* path) const; 7501{; 7502 // Modifying the interpreter state needs locking.; 7503 R__LOCKGUARD(gInterpreterMutex);; 7504 cling::Interpreter::CompilationResult compRes;; 7505 HandleInterpreterException(GetMetaProcessorImpl(), TString::Format("".L %s"",",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:291887,avail,available,291887,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avail'],['available']
Availability,"////////////////////////////////////////////////////////////////; 24 ; 25#include ""TApplication.h""; 26#include ""TString.h""; 27 ; 28class TFileHandler;; 29 ; 30 ; 31class TRint : public TApplication {; 32 ; 33private:; 34 Int_t fNcmd; // command history number; 35 TString fDefaultPrompt; // default prompt: ""root [%d] ""; 36 TString fNonContinuePrompt; // default prompt before continue prompt was set; 37 char fPrompt[64]; // interpreter prompt; 38 Bool_t fInterrupt; // if true macro execution will be stopped; 39 Int_t fCaughtSignal; // TRint just caught a signal; 40 TFileHandler *fInputHandler; // terminal input handler; 41 Bool_t fBackslashContinue{};// whether the last line ended with '\'; 42 ; 43 TRint(const TRint&) = delete;; 44 TRint& operator=(const TRint&) = delete;; 45 ; 46 void ExecLogon();; 47 Longptr_t ProcessRemote(const char *line, Int_t *error = nullptr) override;; 48 Longptr_t ProcessLineNr(const char* filestem, const char *line, Int_t *error = nullptr);; 49 ; 50public:; 51 TRint(const char *appClassName, Int_t *argc, char **argv, void *options = nullptr, Int_t numOptions = 0,; 52 Bool_t noLogo = kFALSE, Bool_t exitOnUnknownArgs = kFALSE);; 53 virtual ~TRint();; 54 virtual char *GetPrompt();; 55 virtual const char *SetPrompt(const char *newPrompt);; 56 void SetEchoMode(Bool_t mode) override;; 57 void HandleException(Int_t sig) override;; 58 Bool_t HandleTermInput() override;; 59 virtual void PrintLogo(Bool_t lite = kFALSE);; 60 void Run(Bool_t retrn = kFALSE) override;; 61 virtual void Terminate(int status) override;; 62 void Interrupt() { fInterrupt = kTRUE; }; 63 Int_t TabCompletionHook(char *buf, int *pLoc, std::ostream& out) override;; 64 ; 65 TFileHandler *GetInputHandler() { return fInputHandler; }; 66 ; 67 ClassDefOverride(TRint,0); //ROOT Interactive Application Interface; 68};; 69 ; 70#endif; Int_tint Int_tDefinition RtypesCore.h:45; Longptr_tlong Longptr_tDefinition RtypesCore.h:75; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8h_source.html:1783,error,error,1783,doc/master/TRint_8h_source.html,https://root.cern,https://root.cern/doc/master/TRint_8h_source.html,2,['error'],['error']
Availability,"///////////////////////////////////////////////////////////////; 472/// Set zero values for point arrays in the range `[begin, end]`; 473 ; 474void TGraphBentErrors::FillZero(Int_t begin, Int_t end,; 475 Bool_t from_ctor); 476{; 477 if (!from_ctor) {; 478 TGraph::FillZero(begin, end, from_ctor);; 479 }; 480 Int_t n = (end - begin)*sizeof(Double_t);; 481 memset(fEXlow + begin, 0, n);; 482 memset(fEXhigh + begin, 0, n);; 483 memset(fEYlow + begin, 0, n);; 484 memset(fEYhigh + begin, 0, n);; 485 memset(fEXlowd + begin, 0, n);; 486 memset(fEXhighd + begin, 0, n);; 487 memset(fEYlowd + begin, 0, n);; 488 memset(fEYhighd + begin, 0, n);; 489}; 490 ; 491 ; 492////////////////////////////////////////////////////////////////////////////////; 493/// Print graph and errors values.; 494 ; 495void TGraphBentErrors::Print(Option_t *) const; 496{; 497 for (Int_t i=0;i<fNpoints;i++) {; 498 printf(""x[%d]=%g, y[%d]=%g, exl[%d]=%g, exh[%d]=%g, eyl[%d]=%g, eyh[%d]=%g\n""; 499 ,i,fX[i],i,fY[i],i,fEXlow[i],i,fEXhigh[i],i,fEYlow[i],i,fEYhigh[i]);; 500 }; 501}; 502 ; 503////////////////////////////////////////////////////////////////////////////////; 504/// Multiply the values and errors of a TGraphBentErrors by a constant c1.; 505///; 506/// If option contains ""x"" the x values and errors are scaled; 507/// If option contains ""y"" the y values and errors are scaled; 508/// If option contains ""xy"" both x and y values and errors are scaled; 509 ; 510void TGraphBentErrors::Scale(Double_t c1, Option_t *option); 511{; 512 TGraph::Scale(c1, option);; 513 TString opt = option; opt.ToLower();; 514 if (opt.Contains(""x"") && GetEXlow()) {; 515 for (Int_t i=0; i<GetN(); i++); 516 GetEXlow()[i] *= c1;; 517 }; 518 if (opt.Contains(""x"") && GetEXhigh()) {; 519 for (Int_t i=0; i<GetN(); i++); 520 GetEXhigh()[i] *= c1;; 521 }; 522 if (opt.Contains(""y"") && GetEYlow()) {; 523 for (Int_t i=0; i<GetN(); i++); 524 GetEYlow()[i] *= c1;; 525 }; 526 if (opt.Contains(""y"") && GetEYhigh()) {; 527 for (Int_t i=0; i<GetN()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:16512,error,errors,16512,doc/master/TGraphBentErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html,1,['error'],['errors']
Availability,"//////////////////////////////////////////////////////////////; 737/// Returns `x` raised to the power `y`.; 738 ; 739inline Double_t TMath::Power(Double_t x, Double_t y); 740 { return pow(x, y); }; 741 ; 742////////////////////////////////////////////////////////////////////////////////; 743/// Returns `x` raised to the power `y`.; 744 ; 745inline Double_t TMath::Power(Double_t x, Int_t y) {; 746#ifdef R__ANSISTREAM; 747 return std::pow(x, y);; 748#else; 749 return pow(x, (Double_t) y);; 750#endif; 751}; 752 ; 753////////////////////////////////////////////////////////////////////////////////; 754/// Returns the natural logarithm of `x`.; 755 ; 756inline Double_t TMath::Log(Double_t x); 757 { return log(x); }; 758 ; 759////////////////////////////////////////////////////////////////////////////////; 760/// Returns the common (base-10) logarithm of `x`.; 761 ; 762inline Double_t TMath::Log10(Double_t x); 763 { return log10(x); }; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Check if it is finite with a mask in order to be consistent in presence of; 767/// fast math.; 768/// Inspired from the CMSSW FWCore/Utilities package; 769 ; 770inline Int_t TMath::Finite(Double_t x); 771#if defined(R__FAST_MATH); 772 ; 773{; 774 const unsigned long long mask = 0x7FF0000000000000LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { return isfinite(x); }; 782# elif defined(R__MACOSX); 783# ifdef isfinite; 784 // from math.h; 785 { return isfinite(x); }; 786# else; 787 // from cmath; 788 { return std::isfinite(x); }; 789# endif; 790# else; 791 { return finite(x); }; 792# endif; 793#endif; 794 ; 795////////////////////////////////////////////////////////////////////////////////; 796/// Check if it is finite with a mask in order to be consistent in presence of; 797/// fast math.; 798/// Inspired from the CMSSW FWCore/Utilities package; 799 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:28736,mask,mask,28736,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['mask'],['mask']
Availability,"/////////////////////////////////////////////////////////////; 1564/// Get high error e on y coordinate for point `i`.; 1565 ; 1566Double_t TGraphMultiErrors::GetErrorYhigh(Int_t i, Int_t e) const; 1567{; 1568 if (i < 0 || i >= fNpoints || e >= fNYErrors || fEyH.empty()); 1569 return -1.;; 1570 ; 1571 return fEyH[e][i];; 1572}; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575/// Get all low errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1576 ; 1577Double_t *TGraphMultiErrors::GetEYlow() const; 1578{; 1579 if (!fEyLSum); 1580 CalcYErrorsSum();; 1581 ; 1582 return fEyLSum;; 1583}; 1584 ; 1585////////////////////////////////////////////////////////////////////////////////; 1586/// Get all high errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1587 ; 1588Double_t *TGraphMultiErrors::GetEYhigh() const; 1589{; 1590 if (!fEyHSum); 1591 CalcYErrorsSum();; 1592 ; 1593 return fEyHSum;; 1594}; 1595 ; 1596////////////////////////////////////////////////////////////////////////////////; 1597/// Get all low errors `e` on y coordinates as an array.; 1598 ; 1599Double_t *TGraphMultiErrors::GetEYlow(Int_t e); 1600{; 1601 if (e >= fNYErrors || fEyL.empty()); 1602 return nullptr;; 1603 else; 1604 return fEyL[e].GetArray();; 1605}; 1606 ; 1607////////////////////////////////////////////////////////////////////////////////; 1608/// Get all high errors `e` on y coordinates as an array.; 1609 ; 1610Double_t *TGraphMultiErrors::GetEYhigh(Int_t e); 1611{; 1612 if (e >= fNYErrors || fEyH.empty()); 1613 return nullptr;; 1614 else; 1615 return fEyH[e].GetArray();; 1616}; 1617 ; 1618////////////////////////////////////////////////////////////////////////////////; 1619/// Get AttFill pointer for specified error dimension.; 1620 ; 1621TAttFill *TGraphMultiErrors::GetAttFill(Int_t e); 1622{; 1623 if (e >= 0 && e < fNYErrors); 1624 return &fAttFill.at(e);; 1625 else; 1626 return nullptr;; 1627}; 162",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:54563,error,errors,54563,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"/////////////////////////////////////////////////////////////; 3566/// Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable `obs`.; 3567/// \param[in] obs Observable to retrieve sampling hint for.; 3568/// \param[in] xlo Beginning of range.; 3569/// \param[in] xhi End of range.; 3570/// \return The caller owns the returned std::list.; 3571std::list<double>* RooAbsReal::plotSamplingHint(RooAbsRealLValue& /*obs*/, double /*xlo*/, double /*xhi*/) const {; 3572 return nullptr;; 3573}; 3574 ; 3575////////////////////////////////////////////////////////////////////////////////; 3576/// Print all outstanding logged evaluation error on the given ostream. If maxPerNode; 3577/// is zero, only the number of errors for each source (object with unique name) is listed.; 3578/// If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; 3579/// per source of errors. A truncation message is shown if there were more errors logged; 3580/// than shown.; 3581 ; 3582void RooAbsReal::printEvalErrors(std::ostream &os, Int_t maxPerNode); 3583{; 3584 if (evalErrorData().mode == CountErrors) {; 3585 os << evalErrorData().count << "" errors counted"" << std::endl;; 3586 }; 3587 ; 3588 if (maxPerNode < 0); 3589 return;; 3590 ; 3591 for (auto const &item : evalErrorData().errorList) {; 3592 if (maxPerNode == 0) {; 3593 ; 3594 // Only print node name with total number of errors; 3595 os << item.second.first;; 3596 // item.first->printStream(os,kName|kClassName|kArgs,kInline) ;; 3597 os << "" has "" << item.second.second.size() << "" errors"" << std::endl;; 3598 ; 3599 } else {; 3600 ; 3601 // Print node name and details of 'maxPerNode' errors; 3602 os << item.second.first << std::endl;; 3603 // item.first->printStream(os,kName|kClassName|kArgs,kSingleLine) ;; 3604 ; 3605 Int_t i(0);; 3606 for (auto const &item2 : item.second.second) {; 3607 os << "" "" << item2._msg << "" @ "" << item2._srvval << std::endl;; 360",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:153251,error,errors,153251,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['errors']
Availability,"/////////////////////////////////////////////////////////////; 87/// Create new canvas instance; 88 ; 89std::shared_ptr<ROOT::Experimental::RCanvas> ROOT::Experimental::RCanvas::Create(const std::string &title); 90{; 91 auto pCanvas = std::make_shared<RCanvas>();; 92 pCanvas->SetTitle(title);; 93 {; 94 std::lock_guard<std::mutex> grd(GetHeldCanvasesMutex());; 95 GetHeldCanvases().emplace_back(pCanvas);; 96 }; 97 ; 98 return pCanvas;; 99}; 100 ; 101//////////////////////////////////////////////////////////////////////////; 102/// Create new display for the canvas; 103/// The parameter `where` specifies which program could be used for display creation; 104/// Possible values:; 105///; 106/// - `cef` Chromium Embeded Framework, local display, local communication; 107/// - `qt5` Qt5 WebEngine (when running via rootqt5), local display, local communication; 108/// - `browser` default system web-browser, communication via random http port from range 8800 - 9800; 109/// - `<prog>` any program name which will be started instead of default browser, like firefox or /usr/bin/opera; 110/// one could also specify $url in program name, which will be replaced with canvas URL; 111/// - `native` either any available local display or default browser; 112///; 113/// Canvas can be displayed in several different places; 114 ; 115void ROOT::Experimental::RCanvas::Show(const std::string &where); 116{; 117 fShown = true;; 118 ; 119 // Do not display canvas in batch mode; 120 if (gROOT->IsWebDisplayBatch()); 121 return;; 122 ; 123 if (fPainter) {; 124 bool isany = (fPainter->NumDisplays() > 0);; 125 ; 126 if (!where.empty()); 127 fPainter->NewDisplay(where);; 128 ; 129 if (isany) return;; 130 }; 131 ; 132 if (!fModified); 133 fModified = 1; // 0 is special value, means no changes and no drawings; 134 ; 135 if (!fPainter); 136 fPainter = Internal::RVirtualCanvasPainter::Create(*this);; 137 ; 138 if (fPainter) {; 139 fPainter->NewDisplay(where);; 140 fPainter->CanvasUpdated(fModified, true, nul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RCanvas_8cxx_source.html:3905,avail,available,3905,doc/master/RCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RCanvas_8cxx_source.html,1,['avail'],['available']
Availability,////////////////////////////////////////////////////////////; 2335const Ranking *TMVA::MethodDL::CreateRanking(); 2336{; 2337 // TODO; 2338 return NULL;; 2339}; 2340 ; 2341////////////////////////////////////////////////////////////////////////////////; 2342void MethodDL::GetHelpMessage() const; 2343{; 2344 // TODO; 2345}; 2346 ; 2347} // namespace TMVA; Adadelta.h; Adagrad.h; Adam.h; ClassifierFactory.h; REGISTER_METHOD#define REGISTER_METHOD(CLASS)for exampleDefinition ClassifierFactory.h:124; Configurable.h; Cuda.h; DLMinimizers.h; IMethod.h; MethodDL.h; RMSProp.h; e#define e(i)Definition RSha256.hxx:103; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; SGD.h; TCudnn.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:94382,error,error,94382,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['error'],['error']
Availability,"///////////////////////////////////////////////////////////; 239/// TGraphMultiErrors normal constructor with name, title, `np` points and `ne` y-errors.; 240///; 241/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 242/// The multiple y-errors are passed as std::vectors of std::vectors.; 243 ; 244TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Float_t *x,; 245 const Float_t *y, const Float_t *exL, const Float_t *exH,; 246 std::vector<std::vector<Float_t>> eyL, std::vector<std::vector<Float_t>> eyH,; 247 Int_t m); 248 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 249{; 250 SetNameTitle(name, title);; 251}; 252 ; 253////////////////////////////////////////////////////////////////////////////////; 254/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 255///; 256/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 257/// The multiple y-errors are passed as std::vectors of std::vectors.; 258 ; 259TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Double_t *x, const Double_t *y, const Double_t *exL,; 260 const Double_t *exH, std::vector<std::vector<Double_t>> eyL,; 261 std::vector<std::vector<Double_t>> eyH, Int_t m); 262 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 263{; 264 if (!CtorAllocate()); 265 return;; 266 ; 267 Int_t n = fNpoints * sizeof(Double_t);; 268 ; 269 if (exL); 270 memcpy(fExL, exL, n);; 271 else; 272 memset(fExL, 0, n);; 273 if (exH); 274 memcpy(fExH, exH, n);; 275 else; 276 memset(fExH, 0, n);; 277 ; 278 for (Int_t i = 0; i < fNpoints; i++) {; 279 for (Int_t j = 0; j < fNYErrors; j++) {; 280 if (Int_t(eyL.size()) > j && Int_t(eyL[j].size()) > i); 281 fEyL[j][i] = eyL[j][i];; 282 else; 283 fEyL[j][i] = 0.;; 284 if (Int_t(eyH.size()) > j && Int_t(eyH[j].size()) > i); 285 fEyH[j][i] = eyH[j][i];; 286 else; 287 fEyH[j][i] = 0.;; 288 }; 289 }; 290 ; 291 CalcYErrorsSum();; 292}; 293 ; 294/////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:9305,error,errors,9305,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"///////////////////////////////////////////////////////////; 5276 ; 5277void TCling::Execute(TObject* obj, TClass* cl, const char* method,; 5278 const char* params, int* error); 5279{; 5280 Execute(obj,cl,method,params,false,error);; 5281}; 5282 ; 5283////////////////////////////////////////////////////////////////////////////////; 5284/// Execute a method from class cl with the arguments in array params; 5285/// (params[0] ... params[n] = array of TObjString parameters).; 5286/// Convert the TObjArray array of TObjString parameters to a character; 5287/// string of comma separated parameters.; 5288/// The parameters of type 'char' are enclosed in double quotes and all; 5289/// internal quotes are escaped.; 5290 ; 5291void TCling::Execute(TObject* obj, TClass* cl, TMethod* method,; 5292 TObjArray* params, int* error); 5293{; 5294 if (!method) {; 5295 Error(""Execute"", ""No method was defined"");; 5296 return;; 5297 }; 5298 TList* argList = method->GetListOfMethodArgs();; 5299 // Check number of actual parameters against of expected formal ones; 5300 ; 5301 Int_t nparms = argList->LastIndex() + 1;; 5302 Int_t argc = params ? params->GetEntries() : 0;; 5303 ; 5304 if (argc > nparms) {; 5305 Error(""Execute"",""Too many parameters to call %s, got %d but expected at most %d."",method->GetName(),argc,nparms);; 5306 return;; 5307 }; 5308 if (nparms != argc) {; 5309 // Let's see if the 'missing' argument are all defaulted.; 5310 // if nparms==0 then either we stopped earlier either argc is also zero and we can't reach here.; 5311 assert(nparms > 0);; 5312 ; 5313 TMethodArg *arg = (TMethodArg *) argList->At( 0 );; 5314 if (arg && arg->GetDefault() && arg->GetDefault()[0]) {; 5315 // There is a default value for the first missing; 5316 // argument, so we are fine.; 5317 } else {; 5318 Int_t firstDefault = -1;; 5319 for (Int_t i = 0; i < nparms; i ++) {; 5320 arg = (TMethodArg *) argList->At( i );; 5321 if (arg && arg->GetDefault() && arg->GetDefault()[0]) {; 5322 firstDefault = i;;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:206240,error,error,206240,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['error'],['error']
Availability,"///////////////////////////////////////////////////////////; 915/// Add a new y error to the graph and fill it with the values from `eyL` and `eyH`; 916 ; 917void TGraphMultiErrors::AddYError(Int_t np, const Double_t *eyL, const Double_t *eyH); 918{; 919 fEyL.emplace_back(np, eyL);; 920 fEyH.emplace_back(np, eyH);; 921 fEyL.back().Set(fNpoints);; 922 fEyH.back().Set(fNpoints);; 923 fAttFill.emplace_back();; 924 fAttLine.emplace_back();; 925 ; 926 fNYErrors += 1;; 927 ; 928 CalcYErrorsSum();; 929}; 930 ; 931////////////////////////////////////////////////////////////////////////////////; 932/// Allocate internal data structures for `size` points.; 933Double_t **TGraphMultiErrors::Allocate(Int_t size); 934{; 935 return AllocateArrays(6, size);; 936}; 937 ; 938////////////////////////////////////////////////////////////////////////////////; 939/// Apply a function to all data points \f$ y = f(x,y) \f$.; 940///; 941/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 942/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; 943///; 944/// Only the first error dimension is affected.; 945///; 946/// Special treatment has to be applied for the functions where the; 947/// role of ""up"" and ""down"" is reversed.; 948///; 949/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 950 ; 951void TGraphMultiErrors::Apply(TF1 *f); 952{; 953 Double_t x, y, eyL, eyH, eyLNew, eyHNew, fxy;; 954 ; 955 if (fHistogram) {; 956 delete fHistogram;; 957 fHistogram = nullptr;; 958 }; 959 ; 960 for (Int_t i = 0; i < fNpoints; i++) {; 961 GetPoint(i, x, y);; 962 eyL = GetErrorYlow(i, 0);; 963 eyH = GetErrorYhigh(i, 0);; 964 ; 965 fxy = f->Eval(x, y);; 966 SetPoint(i, x, fxy);; 967 ; 968 if (f->Eval(x, y - eyL) < f->Eval(x, y + eyH)) {; 969 eyLNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 970 eyHNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 971 } else {; 972 eyHNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 973 eyLNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 974 }; 975 ; 976 // sy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:32715,error,error,32715,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['error']
Availability,"///////////////////////////////////////////////////////////; 971/// Reduce the number of bins for this axis to the number of bins having a label.; 972 ; 973void TProfile::LabelsDeflate(Option_t *option); 974{; 975 TProfileHelper::LabelsDeflate(this, option);; 976}; 977 ; 978////////////////////////////////////////////////////////////////////////////////; 979/// Double the number of bins for axis.; 980/// Refill histogram; 981/// This function is called by TAxis::FindBin(const char *label); 982 ; 983void TProfile::LabelsInflate(Option_t *options); 984{; 985 TProfileHelper::LabelsInflate(this, options);; 986}; 987 ; 988////////////////////////////////////////////////////////////////////////////////; 989/// Set option(s) to draw axis with labels.; 990///; 991/// option might have the following values:; 992///; 993/// - ""a"" sort by alphabetic order; 994/// - "">"" sort by decreasing values; 995/// - ""<"" sort by increasing values; 996/// - ""h"" draw labels horizontal; 997/// - ""v"" draw labels vertical; 998/// - ""u"" draw labels up (end of label right adjusted); 999/// - ""d"" draw labels down (start of label left adjusted); 1000 ; 1001void TProfile::LabelsOption(Option_t *option, Option_t * /*ax */); 1002{; 1003 THashList *labels = fXaxis.GetLabels();; 1004 if (!labels) {; 1005 Warning(""LabelsOption"",""Cannot sort. No labels"");; 1006 return;; 1007 }; 1008 TString opt = option;; 1009 opt.ToLower();; 1010 if (opt.Contains(""h"")) {; 1011 fXaxis.SetBit(TAxis::kLabelsHori);; 1012 fXaxis.ResetBit(TAxis::kLabelsVert);; 1013 fXaxis.ResetBit(TAxis::kLabelsDown);; 1014 fXaxis.ResetBit(TAxis::kLabelsUp);; 1015 }; 1016 if (opt.Contains(""v"")) {; 1017 fXaxis.SetBit(TAxis::kLabelsVert);; 1018 fXaxis.ResetBit(TAxis::kLabelsHori);; 1019 fXaxis.ResetBit(TAxis::kLabelsDown);; 1020 fXaxis.ResetBit(TAxis::kLabelsUp);; 1021 }; 1022 if (opt.Contains(""u"")) {; 1023 fXaxis.SetBit(TAxis::kLabelsUp);; 1024 fXaxis.ResetBit(TAxis::kLabelsVert);; 1025 fXaxis.ResetBit(TAxis::kLabelsDown);; 1026 fXaxis.ResetBit(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:36972,down,down,36972,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,1,['down'],['down']
Availability,"//////////////////////////////////////////////////////////; 1875/// Expand a pathname getting rid of special shell characaters like ~.$, etc.; 1876/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1877/// environment variables in a pathname. If compatibility is not an issue; 1878/// you can use on Unix directly $XXX. The user must delete returned string.; 1879/// Returns the expanded pathname or 0 in case of error.; 1880/// The user must delete returned string (delete []).; 1881 ; 1882char *TUnixSystem::ExpandPathName(const char *path); 1883{; 1884 TString patbuf = path;; 1885 if (ExpandPathName(patbuf)); 1886 return nullptr;; 1887 return StrDup(patbuf.Data());; 1888}; 1889 ; 1890////////////////////////////////////////////////////////////////////////////////; 1891/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1892 ; 1893int TUnixSystem::Chmod(const char *file, UInt_t mode); 1894{; 1895 return ::chmod(file, mode);; 1896}; 1897 ; 1898////////////////////////////////////////////////////////////////////////////////; 1899/// Set the process file creation mode mask.; 1900 ; 1901int TUnixSystem::Umask(Int_t mask); 1902{; 1903 return ::umask(mask);; 1904}; 1905 ; 1906////////////////////////////////////////////////////////////////////////////////; 1907/// Set a files modification and access times. If actime = 0 it will be; 1908/// set to the modtime. Returns 0 on success and -1 in case of error.; 1909 ; 1910int TUnixSystem::Utime(const char *file, Long_t modtime, Long_t actime); 1911{; 1912 if (!actime); 1913 actime = modtime;; 1914 ; 1915 struct utimbuf t;; 1916 t.actime = (time_t)actime;; 1917 t.modtime = (time_t)modtime;; 1918 return ::utime(file, &t);; 1919}; 1920 ; 1921////////////////////////////////////////////////////////////////////////////////; 1922/// Find location of file ""wfil"" in a search path.; 1923/// The search path is specified as a : separated list of directories.; 1924/// Return value is pointing to wfi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:58365,mask,mask,58365,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['mask'],['mask']
Availability,//////////////////////////////////////////////////////////; 2403/// Assign a given node to be checked for overlaps. Any other overlaps will be ignored.; 2404 ; 2405void TGeoManager::SetCheckedNode(TGeoNode *node); 2406{; 2407 GetGeomPainter()->SetCheckedNode(node);; 2408}; 2409 ; 2410////////////////////////////////////////////////////////////////////////////////; 2411/// Set the number of points to be generated on the shape outline when checking; 2412/// for overlaps.; 2413 ; 2414void TGeoManager::SetNmeshPoints(Int_t npoints); 2415{; 2416 GetGeomPainter()->SetNmeshPoints(npoints);; 2417}; 2418 ; 2419////////////////////////////////////////////////////////////////////////////////; 2420/// set drawing mode :; 2421/// - option=0 (default) all nodes drawn down to vislevel; 2422/// - option=1 leaves and nodes at vislevel drawn; 2423/// - option=2 path is drawn; 2424/// - option=4 visibility changed; 2425 ; 2426void TGeoManager::SetVisOption(Int_t option); 2427{; 2428 if ((option >= 0) && (option < 3)); 2429 fVisOption = option;; 2430 if (fPainter); 2431 fPainter->SetVisOption(option);; 2432}; 2433 ; 2434////////////////////////////////////////////////////////////////////////////////; 2435/// Set visualization option (leaves only OR all volumes); 2436 ; 2437void TGeoManager::ViewLeaves(Bool_t flag); 2438{; 2439 if (flag); 2440 SetVisOption(1);; 2441 else; 2442 SetVisOption(0);; 2443}; 2444 ; 2445////////////////////////////////////////////////////////////////////////////////; 2446/// Set density threshold. Volumes with densities lower than this become; 2447/// transparent.; 2448 ; 2449void TGeoManager::SetVisDensity(Double_t density); 2450{; 2451 fVisDensity = density;; 2452 if (fPainter); 2453 fPainter->ModifiedPad();; 2454}; 2455 ; 2456////////////////////////////////////////////////////////////////////////////////; 2457/// set default level down to which visualization is performed; 2458 ; 2459void TGeoManager::SetVisLevel(Int_t level); 2460{; 2461 if (level > 0) {; 2,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:86774,down,down,86774,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['down'],['down']
Availability,"/////////////////////////////////////////////////////////; 458/// Apply a function to all data points \f$ y = f(x,y) \f$; 459///; 460/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 461/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; 462///; 463/// Special treatment has to be applied for the functions where the; 464/// role of ""up"" and ""down"" is reversed.; 465///; 466/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 467 ; 468void TGraphAsymmErrors::Apply(TF1 *f); 469{; 470 Double_t x,y,exl,exh,eyl,eyh,eyl_new,eyh_new,fxy;; 471 ; 472 if (fHistogram) {; 473 delete fHistogram;; 474 fHistogram = nullptr;; 475 }; 476 for (Int_t i=0;i<GetN();i++) {; 477 GetPoint(i,x,y);; 478 exl = GetErrorXlow(i);; 479 exh = GetErrorXhigh(i);; 480 eyl = GetErrorYlow(i);; 481 eyh = GetErrorYhigh(i);; 482 ; 483 fxy = f->Eval(x,y);; 484 SetPoint(i,x,fxy);; 485 ; 486 // in the case of the functions like y-> -1*y the roles of the; 487 // upper and lower error bars is reversed; 488 if (f->Eval(x,y-eyl)<f->Eval(x,y+eyh)) {; 489 eyl_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 490 eyh_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 491 } else {; 492 eyh_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 493 eyl_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 494 }; 495 ; 496 //error on x doesn't change; 497 SetPointError(i,exl,exh,eyl_new,eyh_new);; 498 }; 499 if (gPad) gPad->Modified();; 500}; 501 ; 502////////////////////////////////////////////////////////////////////////////////; 503///This function is only kept for backward compatibility.; 504///You should rather use the Divide method.; 505///It calls `Divide(pass,total,""cl=0.683 b(1,1) mode"")` which is equivalent to the; 506///former BayesDivide method.; 507 ; 508void TGraphAsymmErrors::BayesDivide(const TH1* pass, const TH1* total, Option_t *); 509{; 510 Divide(pass,total,""cl=0.683 b(1,1) mode"");; 511}; 512 ; 513////////////////////////////////////////////////////////////////////////////////; 514/// Fill this TGraphAsymmErrors",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:16829,error,error,16829,doc/master/TGraphAsymmErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////; 4061/// Perform a \f$ \chi^2 \f$ fit to given histogram. By default the fit is executed through the MINUIT; 4062/// commands MIGRAD, HESSE in succession; 4063///; 4064/// The following named arguments are supported; 4065///; 4066/// <table>; 4067/// <tr><th> <th> Options to control construction of chi2; 4068/// <tr><td> `Extended(bool flag)` <td> **Only applicable when fitting a RooAbsPdf**. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight.; 4069/// This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; 4070/// - If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events; 4071/// (in RooFit jargon, ""if the pdf can be extended"").; 4072/// - Passing `Extended(true)` when the the pdf makes no prediction on the expected number of events will result in error messages,; 4073/// and the chi2 will fall back to the total data weight to scale the normalized pdf.; 4074/// - There are cases where the fit **must** be done in extended mode. This happens for example when you have a RooAddPdf; 4075/// where the coefficients represent component yields. If the fit is not extended, these coefficients will not be; 4076/// well-defined, as the RooAddPdf always normalizes itself. If you pass `Extended(false)` in such a case, an error will be; 4077/// printed and you'll most likely get garbage results.; 4078/// <tr><td> `Range(const char* name)` <td> Fit only data inside range with given name; 4079/// <tr><td> `Range(double lo, double hi)` <td> Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; 4080/// Multiple comma separated range names can be specified.; 4081/// <tr><td> `NumCPU(int num)` <td> Parallelize NLL calculation on num CPUs; 4082/// <tr><td> `Optimize(bool flag)` <td> Activate constant ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:176493,error,error,176493,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['error']
Availability,"///////////////////////////////////////////////////////; 414/// It returns the error along Y at point `i`.; 415 ; 416Double_t TGraphBentErrors::GetErrorY(Int_t i) const; 417{; 418 if (i < 0 || i >= fNpoints) return -1;; 419 if (!fEYlow && !fEYhigh) return -1;; 420 Double_t elow=0, ehigh=0;; 421 if (fEYlow) elow = fEYlow[i];; 422 if (fEYhigh) ehigh = fEYhigh[i];; 423 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 424}; 425 ; 426 ; 427////////////////////////////////////////////////////////////////////////////////; 428/// Get high error on X[i].; 429 ; 430Double_t TGraphBentErrors::GetErrorXhigh(Int_t i) const; 431{; 432 if (i<0 || i>fNpoints) return -1;; 433 if (fEXhigh) return fEXhigh[i];; 434 return -1;; 435}; 436 ; 437 ; 438////////////////////////////////////////////////////////////////////////////////; 439/// Get low error on X[i].; 440 ; 441Double_t TGraphBentErrors::GetErrorXlow(Int_t i) const; 442{; 443 if (i<0 || i>fNpoints) return -1;; 444 if (fEXlow) return fEXlow[i];; 445 return -1;; 446}; 447 ; 448 ; 449////////////////////////////////////////////////////////////////////////////////; 450/// Get high error on Y[i].; 451 ; 452Double_t TGraphBentErrors::GetErrorYhigh(Int_t i) const; 453{; 454 if (i<0 || i>fNpoints) return -1;; 455 if (fEYhigh) return fEYhigh[i];; 456 return -1;; 457}; 458 ; 459 ; 460////////////////////////////////////////////////////////////////////////////////; 461/// Get low error on Y[i].; 462 ; 463Double_t TGraphBentErrors::GetErrorYlow(Int_t i) const; 464{; 465 if (i<0 || i>fNpoints) return -1;; 466 if (fEYlow) return fEYlow[i];; 467 return -1;; 468}; 469 ; 470 ; 471////////////////////////////////////////////////////////////////////////////////; 472/// Set zero values for point arrays in the range `[begin, end]`; 473 ; 474void TGraphBentErrors::FillZero(Int_t begin, Int_t end,; 475 Bool_t from_ctor); 476{; 477 if (!from_ctor) {; 478 TGraph::FillZero(begin, end, from_ctor);; 479 }; 480 Int_t n = (end - begin)*sizeof(Double_t);; 4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:14824,error,error,14824,doc/master/TGraphBentErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html,1,['error'],['error']
Availability,"///////////////////////////////////////////////////////; 717/// Terminate the application. Reset the terminal to sane mode and call; 718/// the logoff macro defined via Rint.Logoff environment variable.; 719/// @note The function does not return, unless the class has; 720/// been told to return from Run(), by a call to SetReturnFromRun().; 721 ; 722void TRint::Terminate(Int_t status); 723{; 724 Getlinem(kCleanUp, nullptr);; 725 ; 726 if (ReturnFromRun()) {; 727 gSystem->ExitLoop();; 728 } else {; 729 delete gTabCom;; 730 gTabCom = nullptr;; 731 ; 732 //Execute logoff macro; 733 const char *logoff;; 734 logoff = gEnv->GetValue(""Rint.Logoff"", (char*)nullptr);; 735 if (logoff && !NoLogOpt()) {; 736 char *mac = gSystem->Which(TROOT::GetMacroPath(), logoff, kReadPermission);; 737 if (mac); 738 ProcessFile(logoff);; 739 delete [] mac;; 740 }; 741 ; 742 TApplication::Terminate(status);; 743 }; 744}; 745 ; 746////////////////////////////////////////////////////////////////////////////////; 747/// Set console mode:; 748///; 749/// mode = kTRUE - echo input symbols; 750/// mode = kFALSE - noecho input symbols; 751 ; 752void TRint::SetEchoMode(Bool_t mode); 753{; 754 Gl_config(""noecho"", mode ? 0 : 1);; 755}; 756 ; 757////////////////////////////////////////////////////////////////////////////////; 758/// Process the content of a line starting with "".R"" (already stripped-off); 759/// The format is; 760/// [user@]host[:dir] [-l user] [-d dbg] [script]; 761/// The variable 'dir' is the remote directory to be used as working dir.; 762/// The username can be specified in two ways, ""-l"" having the priority; 763/// (as in ssh).; 764/// A 'dbg' value > 0 gives increasing verbosity.; 765/// The last argument 'script' allows to specify an alternative script to; 766/// be executed remotely to startup the session.; 767 ; 768Longptr_t TRint::ProcessRemote(const char *line, Int_t *); 769{; 770 Longptr_t ret = TApplication::ProcessRemote(line);; 771 ; 772 if (ret == 1) {; 773 if (fAppRemote) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:25506,echo,echo,25506,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,1,['echo'],['echo']
Availability,"//////////////////////////////////////////////////////; 257class TProcessEventTimer : public TTimer {; 258public:; 259 TProcessEventTimer(Long_t delay);; 260 Bool_t Notify() override { return kTRUE; }; 261 Bool_t ProcessEvents();; 262 ClassDefOverride(TProcessEventTimer,0) // Process pending events at fixed time intervals; 263};; 264 ; 265 ; 266class TSystem : public TNamed {; 267 ; 268public:; 269 enum EAclicMode { kDefault, kDebug, kOpt };; 270 enum EAclicProperties {; 271 kFlatBuildDir = BIT(0) // If set and a BuildDir is selected, then do not created sub-directories; 272 };; 273 ; 274protected:; 275 TFdSet *fReadmask{nullptr}; //!Files that should be checked for read events; 276 TFdSet *fWritemask{nullptr}; //!Files that should be checked for write events; 277 TFdSet *fReadready{nullptr}; //!Files with reads waiting; 278 TFdSet *fWriteready{nullptr}; //!Files with writes waiting; 279 TFdSet *fSignals{nullptr}; //!Signals that were trapped; 280 Int_t fNfd{0}; //Number of fd's in masks; 281 Int_t fMaxrfd{-1}; //Largest fd in read mask; 282 Int_t fMaxwfd{-1}; //Largest fd in write mask; 283 Int_t fSigcnt{0}; //Number of pending signals; 284 TString fWdpath; //Working directory; 285 TString fHostname; //Hostname; 286 std::atomic<Bool_t> fInsideNotify{kFALSE}; //Used by DispatchTimers(); 287 Int_t fBeepFreq{0}; //Used by Beep(); 288 Int_t fBeepDuration{0}; //Used by Beep(); 289 ; 290 Bool_t fInControl{kFALSE}; //True if in eventloop; 291 Bool_t fDone{kFALSE}; //True if eventloop should be finished; 292 Int_t fLevel{0}; //Level of nested eventloops; 293 ; 294 TList *fTimers{nullptr}; //List of timers; 295 TSeqCollection *fSignalHandler{nullptr}; //List of signal handlers; 296 TSeqCollection *fFileHandler{nullptr}; //List of file handlers; 297 TSeqCollection *fStdExceptionHandler{nullptr}; //List of std::exception handlers; 298 TSeqCollection *fOnExitList{nullptr}; //List of items to be cleaned-up on exit; 299 ; 300 TString fListLibs; //List shared libraries, cache use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:10593,mask,masks,10593,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['mask'],['masks']
Availability,"//////////////////////////////////////////////////////; 374 /// Add a forward declaration request.; 375 ; 376 void TTreeProxyGenerator::AddPragma(const char *pragma_text); 377 {; 378 TIter i( &fListOfPragmas );; 379 for(TObjString *n = (TObjString*) i(); n; n = (TObjString*)i() ) {; 380 if (pragma_text == n->GetString()) {; 381 return;; 382 }; 383 }; 384 ; 385 fListOfPragmas.Add( new TObjString( pragma_text ) );; 386 ; 387 }; 388 ; 389 ////////////////////////////////////////////////////////////////////////////////; 390 /// Add a branch descriptor.; 391 ; 392 void TTreeProxyGenerator::AddDescriptor(TBranchProxyDescriptor *desc); 393 {; 394 if (desc) {; 395 TBranchProxyDescriptor *existing =; 396 (TBranchProxyDescriptor*)((*fCurrentListOfTopProxies)(desc->GetName()));; 397 if (existing) {; 398 Warning(""TTreeProxyGenerator"",""The branch name \""%s\"" is duplicated. Only the first instance \n""; 399 ""\twill be available directly. The other instance(s) might be available via their complete name\n""; 400 ""\t(including the name of their mother branche's name)."",desc->GetName());; 401 } else {; 402 fCurrentListOfTopProxies->Add(desc);; 403 UInt_t len = strlen(desc->GetTypeName());; 404 if ((len+2)>fMaxDatamemberType) fMaxDatamemberType = len+2;; 405 }; 406 }; 407 }; 408 ; 409 ////////////////////////////////////////////////////////////////////////////////; 410 /// Generate an enum for a given type if it is not known in the list of class; 411 /// unless the type itself a template.; 412 ; 413 void TTreeProxyGenerator::AddMissingClassAsEnum(const char *clname, bool isscope); 414 {; 415 if (!TClassEdit::IsStdClass(clname) && !TClass::GetClass(clname) && gROOT->GetType(clname) == nullptr) {; 416 ; 417 TObject *obj = fListOfForwards.FindObject(clname);; 418 if (obj) return;; 419 ; 420 // The class does not exist, let's create it if ew can.; 421 if (clname[strlen(clname)-1]=='>') {; 422 // Template instantiation.; 423 fListOfForwards.Add(new TNamed(clname,TString::Format(""template <> c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:11997,avail,available,11997,doc/master/TTreeProxyGenerator_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html,1,['avail'],['available']
Availability,"/////////////////////////////////////////////////////; 1217/// Calculates the boundaries using the mid-P binomial; 1218/// interval (Lancaster method) from B. Cousing and J. Tucker.; 1219/// See http://arxiv.org/abs/0905.3831 for a description and references for the method; 1220///; 1221/// Modify equal_tailed to get the kind of interval you want.; 1222/// Can also be converted to interval on ratio of poisson means X/Y by the substitutions; 1223/// ~~~ {.cpp}; 1224/// X = passed; 1225/// total = X + Y; 1226/// lower_poisson = lower/(1 - lower); 1227/// upper_poisson = upper/(1 - upper); 1228/// ~~~; 1229 ; 1230Double_t TEfficiency::MidPInterval(Double_t total,Double_t passed,Double_t level,Bool_t bUpper); 1231{; 1232 const double alpha = 1. - level;; 1233 const bool equal_tailed = true; // change if you don;t want equal tailed interval; 1234 const double alpha_min = equal_tailed ? alpha/2 : alpha;; 1235 const double tol = 1e-9; // tolerance; 1236 double pmin = 0;; 1237 double pmax = 0;; 1238 double p = 0;; 1239 ; 1240 pmin = 0; pmax = 1;; 1241 ; 1242 ; 1243 // treat special case for 0<passed<1; 1244 // do a linear interpolation of the upper limit values; 1245 if ( passed > 0 && passed < 1) {; 1246 double p0 = MidPInterval(total,0.0,level,bUpper);; 1247 double p1 = MidPInterval(total,1.0,level,bUpper);; 1248 p = (p1 - p0) * passed + p0;; 1249 return p;; 1250 }; 1251 ; 1252 while (std::abs(pmax - pmin) > tol) {; 1253 p = (pmin + pmax)/2;; 1254 //double v = 0.5 * ROOT::Math::binomial_pdf(int(passed), p, int(total));; 1255 // make it work for non integer using the binomial - beta relationship; 1256 double v = 0.5 * ROOT::Math::beta_pdf(p, passed+1., total-passed+1)/(total+1);; 1257 //if (passed > 0) v += ROOT::Math::binomial_cdf(int(passed - 1), p, int(total));; 1258 // compute the binomial cdf at passed -1; 1259 if ( (passed-1) >= 0) v += ROOT::Math::beta_cdf_c(p, passed, total-passed+1);; 1260 ; 1261 double vmin = (bUpper) ? alpha_min : 1.- alpha_min;; 1262 if (v > vm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEfficiency_8cxx_source.html:51441,toler,tolerance,51441,doc/master/TEfficiency_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html,1,['toler'],['tolerance']
Availability,/////////////////////////////////////////////////////; 760/// Returns the common (base-10) logarithm of `x`.; 761 ; 762inline Double_t TMath::Log10(Double_t x); 763 { return log10(x); }; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Check if it is finite with a mask in order to be consistent in presence of; 767/// fast math.; 768/// Inspired from the CMSSW FWCore/Utilities package; 769 ; 770inline Int_t TMath::Finite(Double_t x); 771#if defined(R__FAST_MATH); 772 ; 773{; 774 const unsigned long long mask = 0x7FF0000000000000LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { return isfinite(x); }; 782# elif defined(R__MACOSX); 783# ifdef isfinite; 784 // from math.h; 785 { return isfinite(x); }; 786# else; 787 // from cmath; 788 { return std::isfinite(x); }; 789# endif; 790# else; 791 { return finite(x); }; 792# endif; 793#endif; 794 ; 795////////////////////////////////////////////////////////////////////////////////; 796/// Check if it is finite with a mask in order to be consistent in presence of; 797/// fast math.; 798/// Inspired from the CMSSW FWCore/Utilities package; 799 ; 800inline Int_t TMath::Finite(Float_t x); 801#if defined(R__FAST_MATH); 802 ; 803{; 804 const unsigned int mask = 0x7f800000;; 805 union { unsigned int l; float d;} v;; 806 v.d =x;; 807 return (v.l&mask)!=mask;; 808}; 809#else; 810{ return std::isfinite(x); }; 811#endif; 812 ; 813// This namespace provides all the routines necessary for checking if a number; 814// is a NaN also in presence of optimisations affecting the behaviour of the; 815// floating point calculations.; 816// Inspired from the CMSSW FWCore/Utilities package; 817 ; 818#if defined (R__FAST_MATH); 819namespace ROOT {; 820namespace Internal {; 821namespace Math {; 822// abridged from GNU libc 2.6.1 - in detail from; 823// math/math_private.h; 824// sysdeps/ieee754/ldbl-96/math_ld,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:29538,mask,mask,29538,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['mask'],['mask']
Availability,"///////////////////////////////////////////////////; 538/// Specify the path for this node.; 539 ; 540Bool_t TGeoPhysicalNode::SetPath(const char *path); 541{; 542 if (!gGeoManager->cd(path)) {; 543 Error(""SetPath"", ""wrong path -> maybe RestoreMasterVolume"");; 544 return kFALSE;; 545 }; 546 SetBranchAsState();; 547 return kTRUE;; 548}; 549 ; 550////////////////////////////////////////////////////////////////////////////////; 551/// Checks if a given navigator state matches this physical node; 552 ; 553Bool_t TGeoPhysicalNode::IsMatchingState(TGeoNavigator *nav) const; 554{; 555 TGeoNodeCache *cache = nav->GetCache();; 556 if (!cache) {; 557 Fatal(""SetBranchAsState"", ""no state available"");; 558 return kFALSE;; 559 }; 560 // the first condition is that the levels of navigator and this physical node must match; 561 if (cache->GetLevel() != fLevel) {; 562 return kFALSE;; 563 }; 564 // now we compare the nodes at each level; 565 // starting backwards since that enhances the probability of an early return; 566 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 567 for (Int_t i = fLevel; i >= 1; --i); 568 if (fNodes->At(i) != branch[i]); 569 return kFALSE;; 570 return kTRUE;; 571}; 572 ; 573ClassImp(TGeoPNEntry);; 574 ; 575////////////////////////////////////////////////////////////////////////////////; 576/// Default constructor; 577 ; 578TGeoPNEntry::TGeoPNEntry(); 579{; 580 fNode = nullptr;; 581 fMatrix = nullptr;; 582 fGlobalOrig = nullptr;; 583}; 584 ; 585////////////////////////////////////////////////////////////////////////////////; 586/// Default constructor; 587 ; 588TGeoPNEntry::TGeoPNEntry(const char *name, const char *path) : TNamed(name, path); 589{; 590 if (!gGeoManager || !gGeoManager->IsClosed() || !gGeoManager->CheckPath(path)) {; 591 TString errmsg(""Cannot define a physical node link without a closed geometry and a valid path !"");; 592 Error(""ctor"", ""%s"", errmsg.Data());; 593 throw errmsg;; 594 return;; 595 }; 596 gGeoManager->PushPath();; 597 gGeoMana",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:18773,avail,available,18773,doc/master/TGeoPhysicalNode_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html,1,['avail'],['available']
Availability,"///////////////////////////////////////////////////; 901/// When the argument is true the SIGALRM signal handler is set so that; 902/// interrupted syscalls will not be restarted by the kernel. This is; 903/// typically used in case one wants to put a timeout on an I/O operation.; 904/// By default interrupted syscalls will always be restarted (for all; 905/// signals). This can be controlled for each a-synchronous TTimer via; 906/// the method TTimer::SetInterruptSyscalls().; 907 ; 908void TUnixSystem::SigAlarmInterruptsSyscalls(Bool_t set); 909{; 910 UnixSigAlarmInterruptsSyscalls(set);; 911}; 912 ; 913////////////////////////////////////////////////////////////////////////////////; 914/// Return the bitmap of conditions that trigger a floating point exception.; 915 ; 916Int_t TUnixSystem::GetFPEMask(); 917{; 918 Int_t mask = 0;; 919 ; 920#if defined(R__LINUX) && !defined(__powerpc__); 921#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 922 ; 923#if __GLIBC_MINOR__>=3; 924 ; 925 Int_t oldmask = fegetexcept();; 926 ; 927#else; 928 fenv_t oldenv;; 929 fegetenv(&oldenv);; 930 fesetenv(&oldenv);; 931#if __ia64__; 932 Int_t oldmask = ~oldenv;; 933#else; 934 Int_t oldmask = ~oldenv.__control_word;; 935#endif; 936#endif; 937 ; 938 if (oldmask & FE_INVALID ) mask |= kInvalid;; 939 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 940 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 941 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 942# ifdef FE_INEXACT; 943 if (oldmask & FE_INEXACT ) mask |= kInexact;; 944# endif; 945#endif; 946#endif; 947 ; 948#if defined(R__MACOSX) && defined(__SSE2__); 949 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 950 Int_t oldmask = ~_MM_GET_EXCEPTION_MASK();; 951 ; 952 if (oldmask & _MM_MASK_INVALID ) mask |= kInvalid;; 953 if (oldmask & _MM_MASK_DIV_ZERO ) mask |= kDivByZero;; 954 if (oldmask & _MM_MASK_OVERFLOW ) mask |= kOverflow;; 955 if (oldmask & _MM_MASK_UNDERFLOW) mask |= kUnderf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:27900,mask,mask,27900,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['mask'],['mask']
Availability,"//////////////////////////////////////////////////; 223/// Set the application name (from command line, argv[0]) and copy it in; 224/// gProgName.; 225 ; 226void TSystem::SetProgname(const char *name); 227{; 228 delete [] gProgName;; 229 gProgName = StrDup(name);; 230}; 231 ; 232////////////////////////////////////////////////////////////////////////////////; 233/// Set DISPLAY environment variable based on utmp entry. Only for UNIX.; 234 ; 235void TSystem::SetDisplay(); 236{; 237}; 238 ; 239////////////////////////////////////////////////////////////////////////////////; 240/// Set the system error string. This string will be used by GetError().; 241/// To be used in case one does not want or can use the system error; 242/// string (e.g. because error is generated by a third party POSIX like; 243/// library that does not use standard errno).; 244 ; 245void TSystem::SetErrorStr(const char *errstr); 246{; 247 ResetErrno(); // so GetError() uses the fLastErrorString; 248 GetLastErrorString() = errstr;; 249}; 250 ; 251////////////////////////////////////////////////////////////////////////////////; 252/// Return system error string.; 253 ; 254const char *TSystem::GetError(); 255{; 256 if (GetErrno() == 0 && !GetLastErrorString().IsNull()); 257 return GetLastErrorString().Data();; 258 return Form(""errno: %d"", GetErrno());; 259}; 260 ; 261////////////////////////////////////////////////////////////////////////////////; 262/// Return cryptographic random number; 263/// Fill provided buffer with random values; 264/// Returns number of bytes written to buffer or -1 in case of error; 265 ; 266Int_t TSystem::GetCryptoRandom(void * /* buf */, Int_t /* len */); 267{; 268 Error(""GetCryptoRandom"", ""Not implemented"");; 269 return -1;; 270}; 271 ; 272 ; 273////////////////////////////////////////////////////////////////////////////////; 274/// Static function returning system error number.; 275 ; 276Int_t TSystem::GetErrno(); 277{; 278 return errno;; 279}; 280 ; 281/////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:7605,error,error,7605,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////////////////////////////; 2342/// dummy ctor; 2343 ; 2344TGeoIdentity::TGeoIdentity(); 2345{; 2346 if (!gGeoIdentity); 2347 gGeoIdentity = this;; 2348 RegisterYourself();; 2349}; 2350 ; 2351////////////////////////////////////////////////////////////////////////////////; 2352/// constructor; 2353 ; 2354TGeoIdentity::TGeoIdentity(const char *name) : TGeoMatrix(name); 2355{; 2356 if (!gGeoIdentity); 2357 gGeoIdentity = this;; 2358 RegisterYourself();; 2359}; 2360 ; 2361////////////////////////////////////////////////////////////////////////////////; 2362/// Return a temporary inverse of this.; 2363 ; 2364TGeoHMatrix TGeoIdentity::Inverse() const; 2365{; 2366 TGeoHMatrix h = *gGeoIdentity;; 2367 return h;; 2368}; 2369 ; 2370/** \class TGeoHMatrix; 2371\ingroup Geometry_classes; 2372 ; 2373Matrix class used for computing global transformations; 2374Should NOT be used for node definition. An instance of this class; 2375is generally used to pile-up local transformations starting from; 2376the top level physical node, down to the current node.; 2377*/; 2378 ; 2379ClassImp(TGeoHMatrix);; 2380 ; 2381////////////////////////////////////////////////////////////////////////////////; 2382/// dummy ctor; 2383 ; 2384TGeoHMatrix::TGeoHMatrix(); 2385{; 2386 memset(&fTranslation[0], 0, kN3);; 2387 memcpy(fRotationMatrix, kIdentityMatrix, kN9);; 2388 memcpy(fScale, kUnitScale, kN3);; 2389}; 2390 ; 2391////////////////////////////////////////////////////////////////////////////////; 2392/// constructor; 2393 ; 2394TGeoHMatrix::TGeoHMatrix(const char *name) : TGeoMatrix(name); 2395{; 2396 memset(&fTranslation[0], 0, kN3);; 2397 memcpy(fRotationMatrix, kIdentityMatrix, kN9);; 2398 memcpy(fScale, kUnitScale, kN3);; 2399}; 2400 ; 2401////////////////////////////////////////////////////////////////////////////////; 2402/// assignment; 2403 ; 2404TGeoHMatrix::TGeoHMatrix(const TGeoMatrix &matrix) : TGeoMatrix(matrix); 2405{; 2406 memset(&fTranslation[0], 0, kN3);; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:81862,down,down,81862,doc/master/TGeoMatrix_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html,1,['down'],['down']
Availability,//////////////////////////////////////////////////; 621/// It returns the error along Y at point `i`.; 622 ; 623Double_t TGraphErrors::GetErrorY(Int_t i) const; 624{; 625 if (i < 0 || i >= fNpoints) return -1;; 626 if (fEY) return fEY[i];; 627 return -1;; 628}; 629 ; 630 ; 631////////////////////////////////////////////////////////////////////////////////; 632/// It returns the error along X at point `i`. For TGraphErrors this method is; 633/// the same as GetErrorX.; 634 ; 635Double_t TGraphErrors::GetErrorXhigh(Int_t i) const; 636{; 637 if (i < 0 || i >= fNpoints) return -1;; 638 if (fEX) return fEX[i];; 639 return -1;; 640}; 641 ; 642 ; 643////////////////////////////////////////////////////////////////////////////////; 644/// It returns the error along X at point `i`. For TGraphErrors this method is; 645/// the same as GetErrorX.; 646 ; 647Double_t TGraphErrors::GetErrorXlow(Int_t i) const; 648{; 649 if (i < 0 || i >= fNpoints) return -1;; 650 if (fEX) return fEX[i];; 651 return -1;; 652}; 653 ; 654 ; 655////////////////////////////////////////////////////////////////////////////////; 656/// It returns the error along Y at point `i`. For TGraphErrors this method is; 657/// the same as GetErrorY.; 658 ; 659Double_t TGraphErrors::GetErrorYhigh(Int_t i) const; 660{; 661 if (i < 0 || i >= fNpoints) return -1;; 662 if (fEY) return fEY[i];; 663 return -1;; 664}; 665 ; 666 ; 667////////////////////////////////////////////////////////////////////////////////; 668/// It returns the error along Y at point `i`. For TGraphErrors this method is; 669/// the same as GetErrorY.; 670 ; 671Double_t TGraphErrors::GetErrorYlow(Int_t i) const; 672{; 673 if (i < 0 || i >= fNpoints) return -1;; 674 if (fEY) return fEY[i];; 675 return -1;; 676}; 677 ; 678////////////////////////////////////////////////////////////////////////////////; 679/// Adds all graphs with errors from the collection to this graph.; 680/// Returns the total number of points in the result or -1 in case of an error.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:20991,error,error,20991,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////////////////////////////; 671/// Save this object in the file specified by filename.; 672///; 673/// - if ""filename"" contains "".root"" the object is saved in filename as root; 674/// binary file.; 675///; 676/// - if ""filename"" contains "".xml"" the object is saved in filename as a xml; 677/// ascii file.; 678///; 679/// - if ""filename"" contains "".cc"" the object is saved in filename as C code; 680/// independant from ROOT. The code is generated via SavePrimitive().; 681/// Specific code should be implemented in each object to handle this; 682/// option. Like in TF1::SavePrimitive().; 683///; 684/// - otherwise the object is written to filename as a CINT/C++ script. The; 685/// C++ code to rebuild this object is generated via SavePrimitive(). The; 686/// ""option"" parameter is passed to SavePrimitive. By default it is an empty; 687/// string. It can be used to specify the Draw option in the code generated; 688/// by SavePrimitive.; 689///; 690/// The function is available via the object context menu.; 691 ; 692void TObject::SaveAs(const char *filename, Option_t *option) const; 693{; 694 //==============Save object as a root file===================================; 695 if (filename && strstr(filename,"".root"")) {; 696 if (gDirectory) gDirectory->SaveObjectAs(this,filename,"""");; 697 return;; 698 }; 699 ; 700 //==============Save object as a XML file====================================; 701 if (filename && strstr(filename,"".xml"")) {; 702 if (gDirectory) gDirectory->SaveObjectAs(this,filename,"""");; 703 return;; 704 }; 705 ; 706 //==============Save object as a JSON file================================; 707 if (filename && strstr(filename,"".json"")) {; 708 if (gDirectory) gDirectory->SaveObjectAs(this,filename,option);; 709 return;; 710 }; 711 ; 712 //==============Save object as a C, ROOT independant, file===================; 713 if (filename && strstr(filename,"".cc"")) {; 714 TString fname;; 715 if (filename && strlen(filename) > 0) {; 716 fname = file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:24947,avail,available,24947,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,1,['avail'],['available']
Availability,"//////////////////////////////////////////////////; 851/// Return bin effective entries for a weighted filled Profile histogram.; 852/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 853/// The effective entries is defined as the square of the sum of the weights divided by the; 854/// sum of the weights square.; 855/// TProfile::Sumw2() must be called before filling the profile with weights.; 856/// Only by calling this method the sum of the square of the weights per bin is stored.; 857 ; 858Double_t TProfile2D::GetBinEffectiveEntries(Int_t bin); 859{; 860 return TProfileHelper::GetBinEffectiveEntries(this, bin);; 861}; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Return bin error of a Profile2D histogram.; 865///; 866/// ### Computing errors: A moving field; 867///; 868/// The computation of errors for a TProfile2D has evolved with the versions; 869/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 870/// - prior to version 3.10, we had no special treatment of low statistic bins.; 871/// As a result, these bins had huge errors. The reason is that the; 872/// expression eprim2 is very close to 0 (rounding problems) or 0.; 873/// - The algorithm is modified/protected for the case; 874/// when a TProfile2D is projected (ProjectionX). The previous algorithm; 875/// generated a N^2 problem when projecting a TProfile2D with a large number of; 876/// bins (eg 100000).; 877/// - in version 3.10/02, a new static function TProfile::Approximate; 878/// is introduced to enable or disable (default) the approximation.; 879/// (see also comments in TProfile::GetBinError); 880 ; 881Double_t TProfile2D::GetBinError(Int_t bin) const; 882{; 883 return TProfileHelper::GetBinError((TProfile2D*)this, bin);; 884}; 885 ; 886////////////////////////////////////////////////////////////////////////////////; 887/// Return option to compute profile2D errors.; 888 ; 889Opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:30252,error,errors,30252,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,1,['error'],['errors']
Availability,"//////////////////////////////////////////////////; 939/// Apply a function to all data points \f$ y = f(x,y) \f$.; 940///; 941/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 942/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; 943///; 944/// Only the first error dimension is affected.; 945///; 946/// Special treatment has to be applied for the functions where the; 947/// role of ""up"" and ""down"" is reversed.; 948///; 949/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 950 ; 951void TGraphMultiErrors::Apply(TF1 *f); 952{; 953 Double_t x, y, eyL, eyH, eyLNew, eyHNew, fxy;; 954 ; 955 if (fHistogram) {; 956 delete fHistogram;; 957 fHistogram = nullptr;; 958 }; 959 ; 960 for (Int_t i = 0; i < fNpoints; i++) {; 961 GetPoint(i, x, y);; 962 eyL = GetErrorYlow(i, 0);; 963 eyH = GetErrorYhigh(i, 0);; 964 ; 965 fxy = f->Eval(x, y);; 966 SetPoint(i, x, fxy);; 967 ; 968 if (f->Eval(x, y - eyL) < f->Eval(x, y + eyH)) {; 969 eyLNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 970 eyHNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 971 } else {; 972 eyHNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 973 eyLNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 974 }; 975 ; 976 // systematic errors and error on x doesn't change; 977 SetPointEY(i, 0, eyLNew, eyHNew);; 978 }; 979 ; 980 if (gPad); 981 gPad->Modified();; 982}; 983 ; 984////////////////////////////////////////////////////////////////////////////////; 985/// This function is only kept for backward compatibility.; 986/// You should rather use the Divide method.; 987/// It calls `Divide(pass,total,""cl=0.683 b(1,1) mode"")` which is equivalent to the; 988/// former BayesDivide method.; 989 ; 990void TGraphMultiErrors::BayesDivide(const TH1 *pass, const TH1 *total, Option_t *); 991{; 992 Divide(pass, total, ""cl=0.683 b(1,1) mode"");; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// This function was adapted from the TGraphAsymmErrors class.; 997/// See TGra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:33664,error,errors,33664,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"/////////////////////////////////////////////////; 3248/// Announce UDP service.; 3249 ; 3250int TUnixSystem::AnnounceUdpService(int port, int backlog); 3251{; 3252 return UnixUdpService(port, backlog);; 3253}; 3254 ; 3255////////////////////////////////////////////////////////////////////////////////; 3256/// Announce unix domain service on path ""kServerPath/<port>""; 3257 ; 3258int TUnixSystem::AnnounceUnixService(int port, int backlog); 3259{; 3260 return UnixUnixService(port, backlog);; 3261}; 3262 ; 3263////////////////////////////////////////////////////////////////////////////////; 3264/// Announce unix domain service on path 'sockpath'; 3265 ; 3266int TUnixSystem::AnnounceUnixService(const char *sockpath, int backlog); 3267{; 3268 return UnixUnixService(sockpath, backlog);; 3269}; 3270 ; 3271////////////////////////////////////////////////////////////////////////////////; 3272/// Accept a connection. In case of an error return -1. In case; 3273/// non-blocking I/O is enabled and no connections are available; 3274/// return -2.; 3275 ; 3276int TUnixSystem::AcceptConnection(int sock); 3277{; 3278 int soc = -1;; 3279 ; 3280 while ((soc = ::accept(sock, nullptr, nullptr)) == -1 && GetErrno() == EINTR); 3281 ResetErrno();; 3282 ; 3283 if (soc == -1) {; 3284 if (GetErrno() == EWOULDBLOCK); 3285 return -2;; 3286 else {; 3287 SysError(""AcceptConnection"", ""accept"");; 3288 return -1;; 3289 }; 3290 }; 3291 ; 3292 return soc;; 3293}; 3294 ; 3295////////////////////////////////////////////////////////////////////////////////; 3296/// Close socket.; 3297 ; 3298void TUnixSystem::CloseConnection(int sock, Bool_t force); 3299{; 3300 if (sock < 0) return;; 3301 ; 3302#if !defined(R__AIX) || defined(_AIX41) || defined(_AIX43); 3303 if (force); 3304 ::shutdown(sock, 2); // will also close connection of parent; 3305#endif; 3306 ; 3307 while (::close(sock) == -1 && GetErrno() == EINTR); 3308 ResetErrno();; 3309}; 3310 ; 3311/////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:104858,avail,available,104858,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['avail'],['available']
Availability,"////////////////////////////////////////////////; 295/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 296///; 297/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 298/// The multiple y-errors are passed as std::vectors of std::vectors.; 299 ; 300TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Double_t *x,; 301 const Double_t *y, const Double_t *exL, const Double_t *exH,; 302 std::vector<std::vector<Double_t>> eyL, std::vector<std::vector<Double_t>> eyH,; 303 Int_t m); 304 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 305{; 306 SetNameTitle(name, title);; 307}; 308 ; 309////////////////////////////////////////////////////////////////////////////////; 310/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 311///; 312/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 313/// The multiple y-errors are passed as std::vectors of TArrayF objects.; 314 ; 315TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Float_t *x, const Float_t *y, const Float_t *exL,; 316 const Float_t *exH, std::vector<TArrayF> eyL, std::vector<TArrayF> eyH, Int_t m); 317 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 318{; 319 if (!CtorAllocate()); 320 return;; 321 ; 322 for (Int_t i = 0; i < fNpoints; i++) {; 323 if (exL); 324 fExL[i] = exL[i];; 325 else; 326 fExL[i] = 0.;; 327 if (exH); 328 fExH[i] = exH[i];; 329 else; 330 fExH[i] = 0.;; 331 ; 332 for (Int_t j = 0; j < fNYErrors; j++) {; 333 if (Int_t(eyL.size()) > j && eyL[j].GetSize() > i); 334 fEyL[j][i] = eyL[j][i];; 335 else; 336 fEyL[j][i] = 0.;; 337 if (Int_t(eyH.size()) > j && eyH[j].GetSize() > i); 338 fEyH[j][i] = eyH[j][i];; 339 else; 340 fEyH[j][i] = 0.;; 341 }; 342 }; 343 ; 344 CalcYErrorsSum();; 345}; 346 ; 347////////////////////////////////////////////////////////////////////////////////; 348/// TGraphMultiErrors normal construct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:11327,error,errors,11327,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"////////////////////////////////////////////////; 497 ; 498static void DylibAdded(const struct mach_header *mh, intptr_t /* vmaddr_slide */); 499{; 500 static int i = 0;; 501 static Bool_t gotFirstSo = kFALSE;; 502 static TString linkedDylibs;; 503 ; 504 // to copy the local linkedDylibs to the global gLinkedDylibs call this; 505 // function with mh==0; 506 if (!mh) {; 507 gLinkedDylibs = linkedDylibs;; 508 return;; 509 }; 510 ; 511 TString lib = _dyld_get_image_name(i++);; 512 ; 513 TRegexp sovers = ""libCore\\.[0-9]+\\.*[0-9]*\\.*[0-9]*\\.so"";; 514 TRegexp dyvers = ""libCore\\.[0-9]+\\.*[0-9]*\\.*[0-9]*\\.dylib"";; 515 ; 516#ifdef ROOTPREFIX; 517 if (gSystem->Getenv(""ROOTIGNOREPREFIX"")) {; 518#endif; 519 if (lib.EndsWith(""libCore.dylib"") || lib.EndsWith(""libCore.so"") ||; 520 lib.Index(sovers) != kNPOS || lib.Index(dyvers) != kNPOS) {; 521 char respath[kMAXPATHLEN];; 522 if (!realpath(lib, respath)) {; 523 if (!gSystem->Getenv(""ROOTSYS"")); 524 ::SysError(""TUnixSystem::DylibAdded"", ""error getting realpath of libCore, please set ROOTSYS in the shell"");; 525 } else {; 526 TString rs = gSystem->GetDirName(respath);; 527 gSystem->Setenv(""ROOTSYS"", gSystem->GetDirName(rs.Data()).Data());; 528 }; 529 }; 530#ifdef ROOTPREFIX; 531 }; 532#endif; 533 ; 534 // when libSystem.B.dylib is loaded we have finished loading all dylibs; 535 // explicitly linked against the executable. Additional dylibs; 536 // come when they are explicitly linked against loaded so's, currently; 537 // we are not interested in these; 538 if (lib.EndsWith(""/libSystem.B.dylib"")) {; 539 gotFirstSo = kTRUE;; 540 if (linkedDylibs.IsNull()) {; 541 // TSystem::GetLibraries() assumes that an empty GetLinkedLibraries(); 542 // means failure to extract the linked libraries. Signal ""we did; 543 // manage, but it's empty"" by returning a single space.; 544 linkedDylibs = ' ';; 545 }; 546 }; 547 ; 548 // add all libs loaded before libSystem.B.dylib; 549 if (!gotFirstSo && (lib.EndsWith("".dylib"") || lib.EndsWith("".so"")))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:15263,error,error,15263,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['error'],['error']
Availability,"///////////////////////////////////////////////; 70/// Internal function to initialize data members.; 71/// Use TF1::Copy instead of Clone.; 72 ; 73void TF1Convolution::InitializeDataMembers(TF1* function1, TF1* function2, Bool_t useFFT); 74{; 75 if (function1) {; 76 // functions must be 1d- if not flag an error; 77 if (function1->GetNdim() != 1); 78 Error(""InitializeDataMembers"",""function1 %s is not of dimension 1 "",function1->GetName());; 79 //TF1 * fnew1 = (TF1*) function1->IsA()->New();; 80 // since function1 is a TF1 (cannot be a derived class) we can instantiate it directly; 81 fFunction1 = std::make_unique<TF1> ();; 82 function1->Copy(*fFunction1);; 83 }; 84 if (function2) {; 85 if (function2->GetNdim() != 1); 86 Error(""InitializeDataMembers"",""function2 %s is not of dimension 1 "",function2->GetName());; 87 //TF1 * fnew2 = (TF1*) function2->IsA()->New();; 88 fFunction2 = std::make_unique<TF1>();; 89 function2->Copy(*fFunction2);; 90 }; 91 if (fFunction1 == nullptr|| fFunction2 == nullptr); 92 Fatal(""InitializeDataMembers"",""Invalid functions - Abort"");; 93 ; 94 // Set kNotGlobal bit; 95 fFunction1->SetBit(TF1::kNotGlobal, kTRUE);; 96 fFunction2->SetBit(TF1::kNotGlobal, kTRUE);; 97 ; 98 // use by default range of first function; 99 fFunction1->GetRange(fXmin, fXmax);; 100 // when using FFT add by default an extra 10% on each side; 101 if (useFFT) {; 102 SetExtraRange(fgExtraRangeFraction);; 103 }; 104 fNofParams1 = fFunction1->GetNpar();; 105 fNofParams2 = fFunction2->GetNpar();; 106 fParams1 = std::vector<Double_t>(fNofParams1);; 107 fParams2 = std::vector<Double_t>(fNofParams2);; 108 fCstIndex = (fFunction1->GetParNumber(""Constant"") == -1); 109 ? -1; 110 : fFunction2->GetParNumber(""Constant""); // TODO: add dropConstantParam flag?; 111 fFlagFFT = useFFT;; 112 fFlagGraph = false;; 113 fNofPoints = 10000;; 114 ; 115 fParNames.reserve( fNofParams1 + fNofParams2);; 116 for (int i=0; i<fNofParams1; i++); 117 {; 118 fParams1[i] = fFunction1 -> GetParameter(i);; 119 f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1Convolution_8cxx_source.html:2769,error,error,2769,doc/master/TF1Convolution_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html,1,['error'],['error']
Availability,"/////////////////////////////////////////////; 2432/// Compute the gradient (derivative) wrt a parameter ipar; 2433///; 2434/// \param ipar index of parameter for which the derivative is computed; 2435/// \param x point, where the derivative is computed; 2436/// \param eps - if the errors of parameters have been computed, the step used in; 2437/// numerical differentiation is eps*parameter_error.; 2438///; 2439/// if the errors have not been computed, step=eps is used; 2440/// default value of eps = 0.01; 2441/// Method is the same as in Derivative() function; 2442///; 2443/// If a parameter is fixed, the gradient on this parameter = 0; 2444 ; 2445Double_t TF1::GradientPar(Int_t ipar, const Double_t *x, Double_t eps); 2446{; 2447 return GradientParTempl<Double_t>(ipar, x, eps);; 2448}; 2449 ; 2450////////////////////////////////////////////////////////////////////////////////; 2451/// Compute the gradient wrt parameters; 2452/// If the TF1 object is based on a formula expression (TFormula); 2453/// and TFormula::GenerateGradientPar() has been successfully called; 2454/// automatic differentiation using CLAD is used instead of the default; 2455/// numerical differentiation; 2456///; 2457/// \param x point, were the gradient is computed; 2458/// \param grad used to return the computed gradient, assumed to be of at least fNpar size; 2459/// \param eps if the errors of parameters have been computed, the step used in; 2460/// numerical differentiation is eps*parameter_error.; 2461///; 2462/// if the errors have not been computed, step=eps is used; 2463/// default value of eps = 0.01; 2464/// Method is the same as in Derivative() function; 2465///; 2466/// If a parameter is fixed, the gradient on this parameter = 0; 2467 ; 2468void TF1::GradientPar(const Double_t *x, Double_t *grad, Double_t eps); 2469{; 2470 if (fFormula && fFormula->HasGeneratedGradient()) {; 2471 // need to zero the gradient buffer; 2472 std::fill(grad, grad + fNpar, 0.);; 2473 fFormula->GradientPar(x,g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:90146,error,errors,90146,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['error'],['errors']
Availability,"////////////////////////////////////////////; 846/// Return bin effective entries for a weighted filled Profile histogram.; 847/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 848/// The effective entries is defined as the square of the sum of the weights divided by the; 849/// sum of the weights square.; 850/// TProfile::Sumw2() must be called before filling the profile with weights.; 851/// Only by calling this method the sum of the square of the weights per bin is stored.; 852 ; 853Double_t TProfile::GetBinEffectiveEntries(Int_t bin) const; 854{; 855 return TProfileHelper::GetBinEffectiveEntries((TProfile*)this, bin);; 856}; 857 ; 858////////////////////////////////////////////////////////////////////////////////; 859/// Return bin error of a Profile histogram; 860///; 861/// Computing errors: A moving field; 862///; 863/// The computation of errors for a TProfile has evolved with the versions; 864/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 865///; 866/// - prior to version 3.00, we had no special treatment of low statistic bins.; 867/// As a result, these bins had huge errors. The reason is that the; 868/// expression eprim2 is very close to 0 (rounding problems) or 0.; 869/// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; 870/// eprim2 very small and the bin errors set to the average bin errors, following; 871/// recommendations from a group of users.; 872/// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; 873/// should be applied only to low statistic bins.; 874/// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; 875/// to take two times the average error on all bins for these low; 876/// statistics bins giving a very small value for eprim2.; 877/// - in version 3.04 (Nov 2002), the algorithm is modified/protected for the case; 878/// when a TProfile is projected (ProjectionX). The previous algorithm; 87",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:31327,error,errors,31327,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,1,['error'],['errors']
Availability,"///////////////////////////////////////////; 1240/// Multiply this profile by h1.; 1241///; 1242/// `this = this*h1`; 1243 ; 1244Bool_t TProfile::Multiply(const TH1 *); 1245{; 1246 Error(""Multiply"",""Multiplication of profile histograms not implemented"");; 1247 return kFALSE;; 1248}; 1249 ; 1250 ; 1251////////////////////////////////////////////////////////////////////////////////; 1252/// Replace contents of this profile by multiplication of h1 by h2.; 1253///; 1254/// `this = (c1*h1)*(c2*h2)`; 1255 ; 1256Bool_t TProfile::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 1257{; 1258 Error(""Multiply"",""Multiplication of profile histograms not implemented"");; 1259 return kFALSE;; 1260}; 1261 ; 1262////////////////////////////////////////////////////////////////////////////////; 1263/// Project this profile into a 1-D histogram along X; 1264///; 1265/// The projection is always of the type TH1D.; 1266///; 1267/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 1268/// to be equal to the errors of the profile.; 1269/// Option ""E"" is defined as the default one in the header file.; 1270/// - if option """" is specified the histogram errors are simply the sqrt of its content; 1271/// - if option ""B"" is specified, the content of bin of the returned histogram; 1272/// will be equal to the GetBinEntries(bin) of the profile,; 1273/// otherwise (default) it will be equal to GetBinContent(bin); 1274/// - if option ""C=E"" the bin contents of the projection are set to the; 1275/// bin errors of the profile; 1276/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 1277/// product of the bin content of the profile and the entries.; 1278/// With this option the returned histogram will be equivalent to the one obtained by; 1279/// filling directly a TH1D using the 2-nd value as a weight.; 1280/// This makes sense only for profile filled with weights =1. If not, the error of the; 1281/// project",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:46081,error,errors,46081,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,2,['error'],['errors']
Availability,///////////////////////////////////////////; 1608/// Get all high errors `e` on y coordinates as an array.; 1609 ; 1610Double_t *TGraphMultiErrors::GetEYhigh(Int_t e); 1611{; 1612 if (e >= fNYErrors || fEyH.empty()); 1613 return nullptr;; 1614 else; 1615 return fEyH[e].GetArray();; 1616}; 1617 ; 1618////////////////////////////////////////////////////////////////////////////////; 1619/// Get AttFill pointer for specified error dimension.; 1620 ; 1621TAttFill *TGraphMultiErrors::GetAttFill(Int_t e); 1622{; 1623 if (e >= 0 && e < fNYErrors); 1624 return &fAttFill.at(e);; 1625 else; 1626 return nullptr;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Get AttLine pointer for specified error dimension.; 1631 ; 1632TAttLine *TGraphMultiErrors::GetAttLine(Int_t e); 1633{; 1634 if (e >= 0 && e < fNYErrors); 1635 return &fAttLine.at(e);; 1636 else; 1637 return nullptr;; 1638}; 1639 ; 1640////////////////////////////////////////////////////////////////////////////////; 1641/// Get Fill Color for specified error e (-1 = Global and x errors).; 1642 ; 1643Color_t TGraphMultiErrors::GetFillColor(Int_t e) const; 1644{; 1645 if (e == -1); 1646 return GetFillColor();; 1647 else if (e >= 0 && e < fNYErrors); 1648 return fAttFill[e].GetFillColor();; 1649 else; 1650 return 0;; 1651}; 1652 ; 1653////////////////////////////////////////////////////////////////////////////////; 1654/// Get Fill Style for specified error e (-1 = Global and x errors).; 1655 ; 1656Style_t TGraphMultiErrors::GetFillStyle(Int_t e) const; 1657{; 1658 if (e == -1); 1659 return GetFillStyle();; 1660 else if (e >= 0 && e < fNYErrors); 1661 return fAttFill[e].GetFillStyle();; 1662 else; 1663 return 0;; 1664}; 1665 ; 1666////////////////////////////////////////////////////////////////////////////////; 1667/// Get Line Color for specified error e (-1 = Global and x errors).; 1668 ; 1669Color_t TGraphMultiErrors::GetLineColor(Int_t e) const; 1670{; 1671 if (e,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:55906,error,error,55906,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"///////////////////////////////////////////; 2454/// Returns static system info, like OS type, CPU type, number of CPUs; 2455/// RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 2456/// 0 otherwise.; 2457 ; 2458int TSystem::GetSysInfo(SysInfo_t *) const; 2459{; 2460 AbstractMethod(""GetSysInfo"");; 2461 return -1;; 2462}; 2463 ; 2464////////////////////////////////////////////////////////////////////////////////; 2465/// Returns cpu load average and load info into the CpuInfo_t structure.; 2466/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 2467/// interval over which the CPU load will be measured, in ms (default 1000).; 2468 ; 2469int TSystem::GetCpuInfo(CpuInfo_t *, Int_t) const; 2470{; 2471 AbstractMethod(""GetCpuInfo"");; 2472 return -1;; 2473}; 2474 ; 2475////////////////////////////////////////////////////////////////////////////////; 2476/// Returns ram and swap memory usage info into the MemInfo_t structure.; 2477/// Returns -1 in case of error, 0 otherwise.; 2478 ; 2479int TSystem::GetMemInfo(MemInfo_t *) const; 2480{; 2481 AbstractMethod(""GetMemInfo"");; 2482 return -1;; 2483}; 2484 ; 2485////////////////////////////////////////////////////////////////////////////////; 2486/// Returns cpu and memory used by this process into the ProcInfo_t structure.; 2487/// Returns -1 in case of error, 0 otherwise.; 2488 ; 2489int TSystem::GetProcInfo(ProcInfo_t *) const; 2490{; 2491 AbstractMethod(""GetProcInfo"");; 2492 return -1;; 2493}; 2494 ; 2495//---- Script Compiler ---------------------------------------------------------; 2496 ; 2497void AssignAndDelete(TString& target, char *tobedeleted); 2498{; 2499 // Assign the char* value to the TString and then delete it.; 2500 ; 2501 target = tobedeleted;; 2502 delete [] tobedeleted;; 2503}; 2504 ; 2505#ifdef WIN32; 2506 ; 2507static TString R__Exec(const char *cmd); 2508{; 2509 // Execute a command and return the stdout in a string.; 2510 ; 2511 FILE * f = gSystem->OpenPipe(cmd,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:79971,error,error,79971,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////////////////////; 2670/// Return Error on Integral of a parametric function between a and b; 2671/// due to the parameter uncertainties and their covariance matrix from the fit.; 2672/// In addition to the integral limits, this method takes as input a pointer to the fitted parameter values; 2673/// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; 2674/// previously performed fit using the TFitResult class.; 2675/// Note that to get the TFitResult, te fit should be done using the fit option `S`.; 2676/// Example:; 2677/// ~~~~{.cpp}; 2678/// TFitResultPtr r = histo->Fit(func, ""S"");; 2679/// func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; 2680/// ~~~~; 2681///; 2682/// IMPORTANT NOTE1:; 2683///; 2684/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2685/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2686/// TF1 function object are used in the integral error computation.; 2687/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2688/// from a global fitter instance when it exists. Note that the global fitter instance; 2689/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2690/// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; 2691/// returned.; 2692///; 2693///; 2694/// IMPORTANT NOTE2:; 2695///; 2696/// When no covariance matrix is passed and in the meantime a fit is done; 2697/// using another function, the routine will signal an error and it will return zero only; 2698/// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; 2699/// In the case that npar is the same, an incorrect result is returned.; 2700///; 2701/// IMPORTANT NOTE3:; 27",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:100279,error,error,100279,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////////////////////; 46/// TInterpreter ctor only called by derived classes.; 47 ; 48TInterpreter::TInterpreter(const char *name, const char *title); 49 : TNamed(name, title); 50{; 51 gInterpreterLocal = this;; 52 gCling = this;; 53}; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// returns gInterpreter global; 57 ; 58TInterpreter *TInterpreter::Instance(); 59{; 60 if (gInterpreterLocal == nullptr) {; 61 static TROOT *getROOT = ROOT::GetROOT(); // Make sure gInterpreterLocal is set; 62 if (!getROOT) {; 63 ::Fatal(""TInterpreter::Instance"",""TROOT object is required before accessing a TInterpreter"");; 64 }; 65 }; 66 return gInterpreterLocal;; 67}; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; namechar name[80]Definition TGX11.cxx:110; TGlobal.h; gInterpreterLocalstatic TInterpreter * gInterpreterLocalDefinition TInterpreter.cxx:25; gClingTInterpreter * gClingDefinition TInterpreter.cxx:24; TInterpreter.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; TGlobalMappedFunction::MakeFunctorstatic void MakeFunctor(const char *name, const char *type, GlobFunc &func)Definition TGlobal.h:73; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::TInterpreterTInterpreter()Definition TInterpreter.h:135; TInterpreter::Instancestatic TInterpreter * Instance()returns gInterpreter globalDefinition TInterpreter.cxx:58; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TROOTROOT top level object description.Definition TROOT.h:94; ROOT::GetROOTTROOT * GetROOT()Definition TROOT.cxx:472. coremetasrcTInterpreter.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TInterpreter_8cxx_source.html:3207,error,error,3207,doc/master/TInterpreter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TInterpreter_8cxx_source.html,1,['error'],['error']
Availability,"/////////////////////////////////////////; 596/// Set zero values for point arrays in the range `[begin, end]`.; 597 ; 598void TGraphErrors::FillZero(Int_t begin, Int_t end, Bool_t from_ctor); 599{; 600 if (!from_ctor) {; 601 TGraph::FillZero(begin, end, from_ctor);; 602 }; 603 Int_t n = (end - begin) * sizeof(Double_t);; 604 memset(fEX + begin, 0, n);; 605 memset(fEY + begin, 0, n);; 606}; 607 ; 608 ; 609////////////////////////////////////////////////////////////////////////////////; 610/// It returns the error along X at point `i`.; 611 ; 612Double_t TGraphErrors::GetErrorX(Int_t i) const; 613{; 614 if (i < 0 || i >= fNpoints) return -1;; 615 if (fEX) return fEX[i];; 616 return -1;; 617}; 618 ; 619 ; 620////////////////////////////////////////////////////////////////////////////////; 621/// It returns the error along Y at point `i`.; 622 ; 623Double_t TGraphErrors::GetErrorY(Int_t i) const; 624{; 625 if (i < 0 || i >= fNpoints) return -1;; 626 if (fEY) return fEY[i];; 627 return -1;; 628}; 629 ; 630 ; 631////////////////////////////////////////////////////////////////////////////////; 632/// It returns the error along X at point `i`. For TGraphErrors this method is; 633/// the same as GetErrorX.; 634 ; 635Double_t TGraphErrors::GetErrorXhigh(Int_t i) const; 636{; 637 if (i < 0 || i >= fNpoints) return -1;; 638 if (fEX) return fEX[i];; 639 return -1;; 640}; 641 ; 642 ; 643////////////////////////////////////////////////////////////////////////////////; 644/// It returns the error along X at point `i`. For TGraphErrors this method is; 645/// the same as GetErrorX.; 646 ; 647Double_t TGraphErrors::GetErrorXlow(Int_t i) const; 648{; 649 if (i < 0 || i >= fNpoints) return -1;; 650 if (fEX) return fEX[i];; 651 return -1;; 652}; 653 ; 654 ; 655////////////////////////////////////////////////////////////////////////////////; 656/// It returns the error along Y at point `i`. For TGraphErrors this method is; 657/// the same as GetErrorY.; 658 ; 659Double_t TGraphErrors::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:20244,error,error,20244,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['error']
Availability,"////////////////////////////////////////; 121/// Create a 3-D Profile with variable bins in X , Y and Z.; 122 ; 123TProfile3D::TProfile3D(const char *name,const char *title,Int_t nx,const Double_t *xbins,Int_t ny,const Double_t *ybins,Int_t nz,const Double_t *zbins,Option_t *option); 124 : TH3D(name,title,nx,xbins,ny,ybins,nz,zbins); 125{; 126 BuildOptions(0,0,option);; 127}; 128 ; 129////////////////////////////////////////////////////////////////////////////////; 130/// Set Profile3D histogram structure and options.; 131///; 132/// - tmin: minimum value allowed for t; 133/// - tmax: maximum value allowed for t; 134/// if (tmin = tmax = 0) there are no limits on the allowed t values (tmin = -inf, tmax = +inf); 135///; 136/// - option: this is the option for the computation of the t error of the profile ( TProfile3D::GetBinError ); 137/// possible values for the options are documented in TProfile3D::SetErrorOption; 138///; 139/// see also TProfile::BuildOptions for a detailed description; 140 ; 141void TProfile3D::BuildOptions(Double_t tmin, Double_t tmax, Option_t *option); 142{; 143 SetErrorOption(option);; 144 ; 145 // create extra profile data structure (bin entries/ y^2 and sum of weight square); 146 TProfileHelper::BuildArray(this);; 147 ; 148 fTmin = tmin;; 149 fTmax = tmax;; 150 fScaling = kFALSE;; 151 fTsumwt = fTsumwt2 = 0;; 152}; 153 ; 154////////////////////////////////////////////////////////////////////////////////; 155/// Copy constructor.; 156 ; 157TProfile3D::TProfile3D(const TProfile3D &profile3d) : TH3D(); 158{; 159 profile3d.TProfile3D::Copy(*this);; 160}; 161 ; 162TProfile3D &TProfile3D::operator=(const TProfile3D &profile3d); 163{; 164 if (this != &profile3d); 165 profile3d.TProfile3D::Copy(*this);; 166 return *this;; 167}; 168 ; 169////////////////////////////////////////////////////////////////////////////////; 170/// Performs the operation: `this = this + c1*f1` .; 171 ; 172Bool_t TProfile3D::Add(TF1 *, Double_t , Option_t*); 173{; 174 Error(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:5764,error,error,5764,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,1,['error'],['error']
Availability,////////////////////////////////////////; 1597/// Get all low errors `e` on y coordinates as an array.; 1598 ; 1599Double_t *TGraphMultiErrors::GetEYlow(Int_t e); 1600{; 1601 if (e >= fNYErrors || fEyL.empty()); 1602 return nullptr;; 1603 else; 1604 return fEyL[e].GetArray();; 1605}; 1606 ; 1607////////////////////////////////////////////////////////////////////////////////; 1608/// Get all high errors `e` on y coordinates as an array.; 1609 ; 1610Double_t *TGraphMultiErrors::GetEYhigh(Int_t e); 1611{; 1612 if (e >= fNYErrors || fEyH.empty()); 1613 return nullptr;; 1614 else; 1615 return fEyH[e].GetArray();; 1616}; 1617 ; 1618////////////////////////////////////////////////////////////////////////////////; 1619/// Get AttFill pointer for specified error dimension.; 1620 ; 1621TAttFill *TGraphMultiErrors::GetAttFill(Int_t e); 1622{; 1623 if (e >= 0 && e < fNYErrors); 1624 return &fAttFill.at(e);; 1625 else; 1626 return nullptr;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Get AttLine pointer for specified error dimension.; 1631 ; 1632TAttLine *TGraphMultiErrors::GetAttLine(Int_t e); 1633{; 1634 if (e >= 0 && e < fNYErrors); 1635 return &fAttLine.at(e);; 1636 else; 1637 return nullptr;; 1638}; 1639 ; 1640////////////////////////////////////////////////////////////////////////////////; 1641/// Get Fill Color for specified error e (-1 = Global and x errors).; 1642 ; 1643Color_t TGraphMultiErrors::GetFillColor(Int_t e) const; 1644{; 1645 if (e == -1); 1646 return GetFillColor();; 1647 else if (e >= 0 && e < fNYErrors); 1648 return fAttFill[e].GetFillColor();; 1649 else; 1650 return 0;; 1651}; 1652 ; 1653////////////////////////////////////////////////////////////////////////////////; 1654/// Get Fill Style for specified error e (-1 = Global and x errors).; 1655 ; 1656Style_t TGraphMultiErrors::GetFillStyle(Int_t e) const; 1657{; 1658 if (e == -1); 1659 return GetFillStyle();; 1660 else if (e >= 0 && e < fNYEr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:55585,error,error,55585,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////////////////; 17// //; 18// TProfile2D //; 19// //; 20// Profile2D histogram class. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TH2.h""; 25#include ""TProfile.h""; 26 ; 27class TProfile2D : public TH2D {; 28 ; 29public:; 30 friend class TProfileHelper;; 31 friend class TH1Merger;; 32 ; 33protected:; 34 TArrayD fBinEntries; ///< Number of entries per bin; 35 EErrorType fErrorMode; ///< Option to compute errors; 36 Double_t fZmin; ///< Lower limit in Z (if set); 37 Double_t fZmax; ///< Upper limit in Z (if set); 38 Bool_t fScaling; ///<! True when TProfile2D::Scale is called; 39 Double_t fTsumwz; ///< Total Sum of weight*Z; 40 Double_t fTsumwz2; ///< Total Sum of weight*Z*Z; 41 TArrayD fBinSumw2; ///< Array of sum of squares of weights per bin; 42 static Bool_t fgApproximate; ///< Bin error approximation option; 43 ; 44 Int_t BufferFill(Double_t, Double_t) override {return -2;} //may not use; 45 Int_t BufferFill(Double_t, Double_t, Double_t) override {return -2;} //may not use; 46 virtual Int_t BufferFill(Double_t x, Double_t y, Double_t z, Double_t w);; 47 ; 48 // helper methods for the Merge unification in TProfileHelper; 49 void SetBins(const Int_t* nbins, const Double_t* range) { SetBins(nbins[0], range[0], range[1],; 50 nbins[1], range[2], range[3]); };; 51 Int_t Fill(const Double_t* v) { return Fill(v[0], v[1], v[2], v[3]); };; 52 ; 53 TProfile *DoProfile(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) const override;; 54 ; 55 using TH2::Fill;; 56 Int_t Fill(Double_t, Double_t) override {return TH2::Fill(0); } //MayNotUse; 57 ; 58 Double_t RetrieveBinContent(Int_t bin) const override { return (fBinEntries.fArray[bin] > 0) ? fArray[bin]/fBinEntries.fArray[bin] : 0; }; 59 //virtual void UpdateBinContent(Int_t bin, Double_t content);; 60 Double_t GetBinErrorSqUnchecked(Int_t bin) const override { Double_t err = GetBinError(bin); return err*err; }; 61 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8h_source.html:1215,error,errors,1215,doc/master/TProfile2D_8h_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8h_source.html,2,['error'],"['error', 'errors']"
Availability,"//////////////////////////////////////; 431/// TGraphAsymmErrors default destructor.; 432 ; 433TGraphAsymmErrors::~TGraphAsymmErrors(); 434{; 435 if(fEXlow) delete [] fEXlow;; 436 if(fEXhigh) delete [] fEXhigh;; 437 if(fEYlow) delete [] fEYlow;; 438 if(fEYhigh) delete [] fEYhigh;; 439}; 440 ; 441////////////////////////////////////////////////////////////////////////////////; 442/// Allocate internal data structures for `size` points.; 443 ; 444Double_t** TGraphAsymmErrors::Allocate(Int_t size) {; 445 return AllocateArrays(6, size);; 446}; 447 ; 448////////////////////////////////////////////////////////////////////////////////; 449/// Add a point with asymmetric errorbars to the graph.; 450 ; 451void TGraphAsymmErrors::AddPointError(Double_t x, Double_t y, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); 452{; 453 AddPoint(x, y);; 454 SetPointError(fNpoints - 1, exl, exh, eyl, eyh);; 455}; 456 ; 457////////////////////////////////////////////////////////////////////////////////; 458/// Apply a function to all data points \f$ y = f(x,y) \f$; 459///; 460/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 461/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; 462///; 463/// Special treatment has to be applied for the functions where the; 464/// role of ""up"" and ""down"" is reversed.; 465///; 466/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 467 ; 468void TGraphAsymmErrors::Apply(TF1 *f); 469{; 470 Double_t x,y,exl,exh,eyl,eyh,eyl_new,eyh_new,fxy;; 471 ; 472 if (fHistogram) {; 473 delete fHistogram;; 474 fHistogram = nullptr;; 475 }; 476 for (Int_t i=0;i<GetN();i++) {; 477 GetPoint(i,x,y);; 478 exl = GetErrorXlow(i);; 479 exh = GetErrorXhigh(i);; 480 eyl = GetErrorYlow(i);; 481 eyh = GetErrorYhigh(i);; 482 ; 483 fxy = f->Eval(x,y);; 484 SetPoint(i,x,fxy);; 485 ; 486 // in the case of the functions like y-> -1*y the roles of the; 487 // upper and lower error bars is reversed; 488 if (f->Eval(x,y-eyl)<f->Eval(x,y+eyh)) {; 489 eyl_new =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:16199,down,down,16199,doc/master/TGraphAsymmErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html,1,['down'],['down']
Availability,"/////////////////////////////////////; 6312/// [Draw 1D histograms error bars.](\ref HP09); 6313 ; 6314void THistPainter::PaintErrors(Option_t *); 6315{; 6316 ; 6317 // On iOS, we do not highlight histogram, if it's not picked at the moment; 6318 // (but part of histogram (axis or pavestat) was picked, that's why this code; 6319 // is called at all. This conditional statement never executes on non-iOS platform.; 6320 if (gPad->PadInHighlightMode() && gPad->GetSelected() != fH) return;; 6321 ; 6322 const Int_t kBASEMARKER=8;; 6323 Double_t xp, yp, ex1, ex2, ey1, ey2;; 6324 Double_t delta;; 6325 Double_t s2x, s2y, bxsize, bysize, symbolsize, xerror, sbasex, sbasey;; 6326 Double_t xi1, xi2, xi3, xi4, yi1, yi2, yi3, yi4;; 6327 Double_t xmin, xmax, ymin, ymax;; 6328 Double_t logxmin = 0;; 6329 Double_t logymin = 0;; 6330 Double_t offset = 0.;; 6331 Double_t width = 0.;; 6332 Int_t i, k, npoints, first, last, fixbin;; 6333 Int_t if1 = 0;; 6334 Int_t if2 = 0;; 6335 Int_t drawmarker, errormarker;; 6336 Int_t option0, option1, option2, option3, option4, optionE, optionEX0, optionI0;; 6337 static Float_t cxx[30] = {1.0,1.0,0.5,0.5,1.0,1.0,0.5,0.6,1.0,0.5,0.5,1.0,0.5,0.6,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 6338 static Float_t cyy[30] = {1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 6339 ; 6340 std::vector<Double_t> xline, yline;; 6341 option0 = option1 = option2 = option3 = option4 = optionE = optionEX0 = optionI0 = 0;; 6342 if (Hoption.Error >= 40) {Hoption.Error -=40; option0 = 1;}; 6343 if (Int_t(Hoption.Error/10) == 2) {optionEX0 = 1; Hoption.Error -= 10;}; 6344 if (Hoption.Error == 31) {optionEX0 = 1; Hoption.Error = 1;}; 6345 if (Hoption.Error == 11) option1 = 1;; 6346 if (Hoption.Error == 12) option2 = 1;; 6347 if (Hoption.Error == 13) option3 = 1;; 6348 if (Hoption.Error == 14) {option4 = 1; option3 = 1;}; 6349 if (Hoption.Error == 15) {optionI0 = 1; option3 = 1;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:232768,error,errormarker,232768,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['error'],['errormarker']
Availability,"////////////////////////////////////; 2093/// Returns all group info in the UserGroup_t structure. The only active; 2094/// fields in the UserGroup_t structure for this call are:; 2095/// fGid and fGroup; 2096/// The returned structure must be deleted by the user. In case of; 2097/// error 0 is returned.; 2098 ; 2099UserGroup_t *TUnixSystem::GetGroupInfo(Int_t gid); 2100{; 2101 struct group *grp = getgrgid(gid);; 2102 if (grp) {; 2103 UserGroup_t *gr = new UserGroup_t;; 2104 gr->fUid = 0;; 2105 gr->fGid = grp->gr_gid;; 2106 gr->fGroup = grp->gr_name;; 2107 return gr;; 2108 }; 2109 return nullptr;; 2110}; 2111 ; 2112////////////////////////////////////////////////////////////////////////////////; 2113/// Returns all group info in the UserGroup_t structure. The only active; 2114/// fields in the UserGroup_t structure for this call are:; 2115/// fGid and fGroup; 2116/// If group = 0, returns current user's group. The returned structure; 2117/// must be deleted by the user. In case of error 0 is returned.; 2118 ; 2119UserGroup_t *TUnixSystem::GetGroupInfo(const char *group); 2120{; 2121 return GetGroupInfo(GetGid(group));; 2122}; 2123 ; 2124//---- environment manipulation ------------------------------------------------; 2125 ; 2126////////////////////////////////////////////////////////////////////////////////; 2127/// Set environment variable.; 2128 ; 2129void TUnixSystem::Setenv(const char *name, const char *value); 2130{; 2131 ::setenv(name, value, 1);; 2132}; 2133 ; 2134////////////////////////////////////////////////////////////////////////////////; 2135/// Get environment variable.; 2136 ; 2137const char *TUnixSystem::Getenv(const char *name); 2138{; 2139 return ::getenv(name);; 2140}; 2141 ; 2142////////////////////////////////////////////////////////////////////////////////; 2143/// Unset environment variable.; 2144 ; 2145void TUnixSystem::Unsetenv(const char *name); 2146{; 2147 ::unsetenv(name);; 2148}; 2149 ; 2150//---- Processes -----------------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:65472,error,error,65472,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['error'],['error']
Availability,"////////////////////////////////////; 24 ; 25#include ""TString.h""; 26#include ""TDictionary.h""; 27#include ""TBranchProxy.h""; 28 ; 29#include <type_traits>; 30#include <vector>; 31#include <string>; 32 ; 33class TBranch;; 34class TBranchElement;; 35class TLeaf;; 36class TTreeReader;; 37 ; 38namespace ROOT {; 39namespace Internal {; 40 ; 41/** \class TTreeReaderValueBase; 42Base class of TTreeReaderValue.; 43*/; 44 ; 45 class TTreeReaderValueBase {; 46 public:; 47 ; 48 /// Status flags, 0 is good; 49 enum ESetupStatus {; 50 kSetupNotSetup = -7, ///< No initialization has happened yet.; 51 kSetupTreeDestructed = -8, ///< The TTreeReader has been destructed / not set.; 52 kSetupMakeClassModeMismatch = -9, ///< readers disagree on whether TTree::SetMakeBranch() should be on; 53 kSetupMissingCounterBranch = -6, ///< The array cannot find its counter branch: Array[CounterBranch]; 54 kSetupMissingBranch = -5, ///< The specified branch cannot be found.; 55 kSetupInternalError = -4, ///< Some other error - hopefully the error message helps.; 56 kSetupMissingDictionary = -3, ///< To read this branch, we need a dictionary.; 57 kSetupMismatch = -2, ///< Mismatch of branch type and reader template type.; 58 kSetupNotACollection = -1, ///< The branch class type is not a collection.; 59 kSetupMatch = 0, ///< This branch has been set up, branch data type and reader template type match, reading should succeed.; 60 kSetupMatchBranch = 7, ///< This branch has been set up, branch data type and reader template type match, reading should succeed.; 61 //kSetupMatchConversion = 1, /// This branch has been set up, the branch data type can be converted to the reader template type, reading should succeed.; 62 //kSetupMatchConversionCollection = 2, /// This branch has been set up, the data type of the branch's collection elements can be converted to the reader template type, reading should succeed.; 63 //kSetupMakeClass = 3, /// This branch has been set up, enabling MakeClass mode for it, reading",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReaderValue_8h_source.html:2020,error,error,2020,doc/master/TTreeReaderValue_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html,2,['error'],['error']
Availability,"////////////////////////////////////; 649/// Browse; 650 ; 651void TGraph::Browse(TBrowser *b); 652{; 653 TString opt = gEnv->GetValue(""TGraph.BrowseOption"", """");; 654 if (opt.IsNull()) {; 655 opt = b ? b->GetDrawOption() : ""alp"";; 656 opt = (opt == """") ? ""alp"" : opt.Data();; 657 }; 658 Draw(opt.Data());; 659 gPad->Update();; 660}; 661 ; 662////////////////////////////////////////////////////////////////////////////////; 663/// Return the chisquare of this graph with respect to f1.; 664/// The chisquare is computed as the sum of the quantity below at each point:; 665/// \f[; 666/// \frac{(y-f1(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f1'(x))^{2}}; 667/// \f]; 668/// where x and y are the graph point coordinates and f1'(x) is the derivative of function f1(x).; 669/// This method to approximate the uncertainty in y because of the errors in x, is called; 670/// ""effective variance"" method.; 671/// In case of a pure TGraph, the denominator is 1.; 672/// In case of a TGraphErrors or TGraphAsymmErrors the errors are taken; 673/// into account.; 674/// By default the range of the graph is used whatever function range.; 675/// Use option ""R"" to use the function range; 676 ; 677Double_t TGraph::Chisquare(TF1 *func, Option_t * option) const; 678{; 679 if (!func) {; 680 Error(""Chisquare"",""Function pointer is Null - return -1"");; 681 return -1;; 682 }; 683 ; 684 TString opt(option); opt.ToUpper();; 685 bool useRange = opt.Contains(""R"");; 686 ; 687 return ROOT::Fit::Chisquare(*this, *func,useRange);; 688}; 689 ; 690////////////////////////////////////////////////////////////////////////////////; 691/// Return kTRUE if point number ""left""'s argument (angle with respect to positive; 692/// x-axis) is bigger than that of point number ""right"". Can be used by Sort.; 693 ; 694Bool_t TGraph::CompareArg(const TGraph* gr, Int_t left, Int_t right); 695{; 696 Double_t xl = 0, yl = 0, xr = 0, yr = 0;; 697 gr->GetPoint(left, xl, yl);; 698 gr->GetPoint(right, xr, yr);; 699 return (TMath::ATan2(yl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:21726,error,errors,21726,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['error'],['errors']
Availability,"///////////////////////////////////; 169 ; 170 if( pos == std::string::npos ) {; 171 error_string = ""Parsing error, no key found!"";; 172 return false;; 173 }; 174 ; 175 //--------------------------------------------------------------------; 176 // The key was found - process the arguments; 177 ///////////////////////////////////////////////////////////////////////; 178 ; 179 std::string key = TSchemaRuleProcessor::Trim( command.substr( 0, pos ) );; 180 command = TSchemaRuleProcessor::Trim( command.substr( pos+1 ) );; 181 ; 182 //--------------------------------------------------------------------; 183 // Nothing left to be processed; 184 ///////////////////////////////////////////////////////////////////////; 185 ; 186 if( command.size() < 1 ) {; 187 error_string = ""Parsing error, wrond or no value specified for key: "" + key;; 188 return false;; 189 }; 190 ; 191 Bool_t hasquote = command[0] == '""';; 192 ; 193 //--------------------------------------------------------------------; 194 // Processing code tag: ""{ code }""; 195 ///////////////////////////////////////////////////////////////////////; 196 ; 197 if( key == ""code"" ) {; 198 // Cleaning of the input command:; 199 // - Trim whitespaces at the borders; 200 // - Get the inner command (i.e. the part between quotes); 201 // - Trim whitespaces again; 202 // - Stitch back together; 203 auto clean_command = [](const std::string &c) {; 204 auto first_trim = TSchemaRuleProcessor::Trim(c);; 205 auto inner_command =; 206 first_trim.substr(first_trim.find_first_of('""') + 1, first_trim.find_last_of('""') - 1);; 207 auto second_trim = TSchemaRuleProcessor::Trim(inner_command);; 208 return '""' + second_trim + '""';; 209 };; 210 command = clean_command(command);; 211 ; 212 if( command[1] != '{' ) {; 213 error_string = ""Parsing error while processing key: code\n"";; 214 error_string += ""Expected \""{ at the beginning of the value."";; 215 return false;; 216 }; 217 l = command.find( ""}\"""" );; 218 if( l == std::string::npos ) {; 219 er",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html:6872,error,error,6872,doc/master/RConversionRuleParser_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html,2,['error'],['error']
Availability,"///////////////////////////////////; 1716/// Redefine x axis parameters.; 1717 ; 1718void TProfile::SetBins(Int_t nx, const Double_t *xbins); 1719{; 1720 fXaxis.Set(nx,xbins);; 1721 fNcells = nx+2;; 1722 SetBinsLength(fNcells);; 1723}; 1724 ; 1725////////////////////////////////////////////////////////////////////////////////; 1726/// Set total number of bins including under/overflow.; 1727/// Reallocate bin contents array; 1728 ; 1729void TProfile::SetBinsLength(Int_t n); 1730{; 1731 TH1D::SetBinsLength(n);; 1732 TProfileHelper::BuildArray(this);; 1733}; 1734 ; 1735////////////////////////////////////////////////////////////////////////////////; 1736/// Set the buffer size in units of 8 bytes (double).; 1737 ; 1738void TProfile::SetBuffer(Int_t buffersize, Option_t *); 1739{; 1740 if (fBuffer) {; 1741 BufferEmpty();; 1742 delete [] fBuffer;; 1743 fBuffer = nullptr;; 1744 }; 1745 if (buffersize <= 0) {; 1746 fBufferSize = 0;; 1747 return;; 1748 }; 1749 if (buffersize < 100) buffersize = 100;; 1750 fBufferSize = 1 + 3*buffersize;; 1751 fBuffer = new Double_t[fBufferSize];; 1752 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1753}; 1754 ; 1755////////////////////////////////////////////////////////////////////////////////; 1756/// Set option to compute profile errors.; 1757///; 1758/// The computation of the bin errors is based on the parameter option:; 1759///; 1760/// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; 1761/// i.e. the standard error of the bin contents.; 1762/// Note that if TProfile::Approximate() is called, an approximation is used when; 1763/// the spread in Y is 0 and the number of bin entries is > 0; 1764/// -'s' The bin errors are the standard deviations of the Y bin values; 1765/// Note that if TProfile::Approximate() is called, an approximation is used when; 1766/// the spread in Y is 0 and the number of bin entries is > 0; 1767/// -'i' Errors are as in default case (standard errors of the bin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:63786,error,errors,63786,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,1,['error'],['errors']
Availability,"///////////////////////////////////; 294/// static: Set the maximum number of function calls for the minimization algorithm; 295/// For example for MIGRAD this is the maxcalls value passed as first argument; 296/// (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html ); 297 ; 298void TVirtualFitter::SetMaxIterations(Int_t niter); 299{; 300 ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls(niter);; 301}; 302 ; 303////////////////////////////////////////////////////////////////////////////////; 304/// static: Set the Error Definition (default=1); 305/// For Minuit this is the value passed with the ""SET ERR"" command; 306/// (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html); 307 ; 308void TVirtualFitter::SetErrorDef(Double_t errdef); 309{; 310// fgErrorDef = errdef;; 311 ROOT::Math::MinimizerOptions::SetDefaultErrorDef(errdef);; 312 if (!GetGlobalFitter()) return;; 313 Double_t arglist[1];; 314 arglist[0] = errdef;; 315 GetGlobalFitter()->ExecuteCommand(""SET ERRORDEF"", arglist, 1);; 316}; 317 ; 318////////////////////////////////////////////////////////////////////////////////; 319/// static: Set the tolerance used in the minimization algorithm; 320/// For example for MIGRAD this is tolerance value passed as second argument; 321/// (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html ); 322 ; 323void TVirtualFitter::SetPrecision(Double_t prec); 324{; 325 //fgPrecision = prec;; 326 ROOT::Math::MinimizerOptions::SetDefaultTolerance(prec);; 327}; MinimizerOptions.h; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; namechar name[80]Definition TGX11.cxx:110; TPluginManager.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TVirtualFitter.h; ThreadLocalStorage.h; ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCallsstatic void SetDefaultMaxFunctionCal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html:10346,toler,tolerance,10346,doc/master/TVirtualFitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html,2,['toler'],['tolerance']
Availability,"//////////////////////////////////; 3112/// Dummy function kept for back compatibility.; 3113/// The cache is now activated automatically when processing TTrees/TChain.; 3114 ; 3115void TChain::UseCache(Int_t /* maxCacheSize */, Int_t /* pageSize */); 3116{; 3117}; InternalTreeUtils.hxx; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; h#define h(i)Definition RSha256.hxx:106; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Version_tshort Version_tDefinition RtypesCore.h:65; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBranch.h; TBrowser.h; TBuffer.h; TChainElement.h; TChain.h; TClass.h; TColor.h; TCut.h; EDataTypeEDataTypeDefinition TDataType.h:28; TEntryListFromFile.h; TEntryList.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; TEventList.h; TFileInfo.h; TFilePrefetch.h; TFileStager.h; TFile.h; TFriendElement.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; onOption_t Option_t TPoint TPoint const char GetTextMagnitude",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:113740,error,error,113740,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['error'],['error']
Availability,"/////////////////////////////////; 1242/// Multiply this profile2D by h1.; 1243///; 1244/// `this = this*h1`; 1245 ; 1246Bool_t TProfile2D::Multiply(const TH1 *); 1247{; 1248 Error(""Multiply"",""Multiplication of profile2D histograms not implemented"");; 1249 return kFALSE;; 1250}; 1251 ; 1252////////////////////////////////////////////////////////////////////////////////; 1253/// Replace contents of this profile2D by multiplication of h1 by h2.; 1254///; 1255/// `this = (c1*h1)*(c2*h2)`; 1256 ; 1257Bool_t TProfile2D::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 1258{; 1259 Error(""Multiply"",""Multiplication of profile2D histograms not implemented"");; 1260 return kFALSE;; 1261}; 1262 ; 1263////////////////////////////////////////////////////////////////////////////////; 1264/// Project this profile2D into a 2-D histogram along X,Y.; 1265///; 1266/// The projection is always of the type TH2D.; 1267///; 1268/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 1269/// to be equal to the errors of the profile.; 1270/// Option ""E"" is defined as the default one in the header file.; 1271/// - if option """" is specified the histogram errors are simply the sqrt of its content; 1272/// - if option ""B"" is specified, the content of bin of the returned histogram; 1273/// will be equal to the GetBinEntries(bin) of the profile,; 1274/// - if option ""C=E"" the bin contents of the projection are set to the; 1275/// bin errors of the profile; 1276/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 1277/// product of the bin content of the profile and the entries.; 1278/// With this option the returned histogram will be equivalent to the one obtained by; 1279/// filling directly a TH2D using the 3-rd value as a weight.; 1280/// This option makes sense only for profile filled with all weights =1.; 1281/// When the profile is weighted (filled with weights different than 1) the; 1282/// bin erro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:44448,error,errors,44448,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,2,['error'],['errors']
Availability,"/////////////////////////////////; 1960/// Minimization function for H1s using a Likelihood method.; 1961/// Basically, it forms the likelihood by determining the Poisson; 1962/// probability that given a number of entries in a particular bin,; 1963/// the fit would predict it's value. This is then done for each bin,; 1964/// and the sum of the logs is taken as the likelihood.; 1965///; 1966/// The ""I""ntegral method is used; 1967/// for each point the cache contains the following info; 1968/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1969/// - 2D : bc,e,xc,xw,yc,yw; 1970/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1971 ; 1972void TFumili::FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:56970,error,error,56970,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,1,['error'],['error']
Availability,"////////////////////////////////; 319/// Add a float spectator or expression to the reader; 320 ; 321void TMVA::Reader::AddSpectator( const TString& expression, Float_t* datalink ); 322{; 323 DataInfo().AddSpectator( expression, """", """", 0, 0, 'F', kFALSE ,(void*)datalink );; 324}; 325 ; 326////////////////////////////////////////////////////////////////////////////////; 327/// Add an integer spectator or expression to the reader; 328 ; 329void TMVA::Reader::AddSpectator( const TString& expression, Int_t* datalink ); 330{; 331 DataInfo().AddSpectator(expression, """", """", 0, 0, 'I', kFALSE, (void*)datalink );; 332}; 333 ; 334////////////////////////////////////////////////////////////////////////////////; 335/// read the method type from the file; 336 ; 337TString TMVA::Reader::GetMethodTypeFromFile( const TString& filename ); 338{; 339 std::ifstream fin( filename );; 340 if (!fin.good()) { // file not found --> Error; 341 Log() << kFATAL << ""<BookMVA> fatal error: ""; 342 << ""unable to open input weight file: "" << filename << Endl;; 343 }; 344 ; 345 TString fullMethodName("""");; 346 if (filename.EndsWith("".xml"")) {; 347 fin.close();; 348 void* doc = gTools().xmlengine().ParseFile(filename,gTools().xmlenginebuffersize());// the default buffer size in TXMLEngine::ParseFile is 100k. Starting with ROOT 5.29 one can set the buffer size, see: http://savannah.cern.ch/bugs/?78864. This might be necessary for large XML files; 349 void* rootnode = gTools().xmlengine().DocGetRootElement(doc); // node ""MethodSetup""; 350 gTools().ReadAttr(rootnode, ""Method"", fullMethodName);; 351 gTools().xmlengine().FreeDoc(doc);; 352 }; 353 else {; 354 char buf[512];; 355 fin.getline(buf,512);; 356 while (!TString(buf).BeginsWith(""Method"")) fin.getline(buf,512);; 357 fullMethodName = TString(buf);; 358 fin.close();; 359 }; 360 TString methodType = fullMethodName(0,fullMethodName.Index(""::""));; 361 if (methodType.Contains("" "")) methodType = methodType(methodType.Last(' ')+1,methodType.Length());; 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Reader_8cxx_source.html:12197,error,error,12197,doc/master/Reader_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Reader_8cxx_source.html,1,['error'],['error']
Availability,"////////////////////////////////; 3875/// Fit histogram with function fname.; 3876///; 3877///; 3878/// fname is the name of a function available in the global ROOT list of functions; 3879/// `gROOT->GetListOfFunctions`; 3880/// The list include any TF1 object created by the user plus some pre-defined functions; 3881/// which are automatically created by ROOT the first time a pre-defined function is requested from `gROOT`; 3882/// (i.e. when calling `gROOT->GetFunction(const char *name)`).; 3883/// These pre-defined functions are:; 3884/// - `gaus, gausn` where gausn is the normalized Gaussian; 3885/// - `landau, landaun`; 3886/// - `expo`; 3887/// - `pol1,...9, chebyshev1,...9`.; 3888///; 3889/// For printing the list of all available functions do:; 3890///; 3891/// TF1::InitStandardFunctions(); // not needed if `gROOT->GetFunction` is called before; 3892/// gROOT->GetListOfFunctions()->ls(); 3893///; 3894/// `fname` can also be a formula that is accepted by the linear fitter containing the special operator `++`,; 3895/// representing linear components separated by `++` sign, for example `x++sin(x)` for fitting `[0]*x+[1]*sin(x)`; 3896///; 3897/// This function finds a pointer to the TF1 object with name `fname` and calls TH1::Fit(TF1 *, Option_t *, Option_t *,; 3898/// Double_t, Double_t). See there for the fitting options and the details about fitting histograms; 3899 ; 3900TFitResultPtr TH1::Fit(const char *fname ,Option_t *option ,Option_t *goption, Double_t xxmin, Double_t xxmax); 3901{; 3902 char *linear;; 3903 linear= (char*)strstr(fname, ""++"");; 3904 Int_t ndim=GetDimension();; 3905 if (linear){; 3906 if (ndim<2){; 3907 TF1 f1(fname, fname, xxmin, xxmax);; 3908 return Fit(&f1,option,goption,xxmin,xxmax);; 3909 }; 3910 else if (ndim<3){; 3911 TF2 f2(fname, fname);; 3912 return Fit(&f2,option,goption,xxmin,xxmax);; 3913 }; 3914 else{; 3915 TF3 f3(fname, fname);; 3916 return Fit(&f3,option,goption,xxmin,xxmax);; 3917 }; 3918 }; 3919 else{; 3920 TF1 * f1 = (TF1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:153902,avail,available,153902,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['avail'],['available']
Availability,"///////////////////////////////; 2025/// Static function used to attach to an existing remote application; 2026/// or to start one.; 2027 ; 2028TApplication *TApplication::Open(const char *url,; 2029 Int_t debug, const char *script); 2030{; 2031 TApplication *ap = nullptr;; 2032 TUrl nu(url);; 2033 Int_t nnew = 0;; 2034 ; 2035 // Look among the existing ones; 2036 if (fgApplications) {; 2037 TIter nxa(fgApplications);; 2038 while ((ap = (TApplication *) nxa())) {; 2039 TString apn(ap->ApplicationName());; 2040 if (apn == url) {; 2041 // Found matching application; 2042 return ap;; 2043 } else {; 2044 // Check if same machine and user; 2045 TUrl au(apn);; 2046 if (strlen(au.GetUser()) > 0 && strlen(nu.GetUser()) > 0 &&; 2047 !strcmp(au.GetUser(), nu.GetUser())) {; 2048 if (!strncmp(au.GetHost(), nu.GetHost(), strlen(nu.GetHost()))); 2049 // New session on a known machine; 2050 nnew++;; 2051 }; 2052 }; 2053 }; 2054 } else {; 2055 ::Error(""TApplication::Open"", ""list of applications undefined - protocol error"");; 2056 return ap;; 2057 }; 2058 ; 2059 // If new session on a known machine pass the number as option; 2060 if (nnew > 0) {; 2061 nnew++;; 2062 nu.SetOptions(TString::Format(""%d"", nnew).Data());; 2063 }; 2064 ; 2065 // Instantiate the TApplication object to be run; 2066 TPluginHandler *h = nullptr;; 2067 if ((h = gROOT->GetPluginManager()->FindHandler(""TApplication"",""remote""))) {; 2068 if (h->LoadPlugin() == 0) {; 2069 ap = (TApplication *) h->ExecPlugin(3, nu.GetUrl(), debug, script);; 2070 } else {; 2071 ::Error(""TApplication::Open"", ""failed to load plugin for TApplicationRemote"");; 2072 }; 2073 } else {; 2074 ::Error(""TApplication::Open"", ""failed to find plugin for TApplicationRemote"");; 2075 }; 2076 ; 2077 // Add to the list; 2078 if (ap && !(ap->TestBit(kInvalidObject))) {; 2079 fgApplications->Add(ap);; 2080 gROOT->GetListOfBrowsables()->Add(ap, ap->ApplicationName());; 2081 TIter next(gROOT->GetListOfBrowsers());; 2082 TBrowser *b;; 2083 while ((b = (TBrow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:77564,error,error,77564,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['error'],['error']
Availability,"/////////////////////////////; 589 ; 590 for( it = source.begin(); it != source.end(); ++it ) {; 591 output << "" "";; 592 output << ""static Long_t offset_Onfile_"" << mappedName;; 593 output << ""_"" << it->second << "" = oldObj->GetClass()->GetDataMemberOffset(\"""";; 594 output << it->second << ""\"");\n"";; 595 }; 596 output << "" "" << ""char *onfile_add = (char*)oldObj->GetObject();\n"";; 597 output << "" "" << mappedName << ""_Onfile onfile(\n"";; 598 ; 599 for( start = true, it = source.begin(); it != source.end(); ++it ) {; 600 if( it->first.fType == """" ); 601 continue;; 602 ; 603 if( !start ); 604 output << "",\n"";; 605 ; 606 else; 607 start = false;; 608 ; 609 output << "" "";; 610 output << ""*("";; 611 if (it->first.fDimensions.size() == 0) {; 612 output << it->first.fType;; 613 } else {; 614 output << mappedName << ""_Onfile::onfile_"" << it->second << ""_t"";; 615 }; 616 output << ""*)(onfile_add+offset_Onfile_"";; 617 output << mappedName << ""_"" << it->second << "")"";; 618 }; 619 output << "" );\n\n"";; 620 }; 621 }; 622 ; 623 //-----------------------------------------------------------------------; 624 // Write down the targets; 625 //////////////////////////////////////////////////////////////////////////; 626 ; 627 if( !target.empty() ) {; 628 output << "" static TClassRef cls(\"""";; 629 output << className << ""\"");"" << std::endl;; 630 ; 631 std::list<std::string>::const_iterator it;; 632 for( it = target.begin(); it != target.end(); ++it ) {; 633 Internal::TSchemaType memData = members[*it];; 634 output << "" static Long_t offset_"" << *it << "" = "";; 635 output << ""cls->GetDataMemberOffset(\"""" << *it << ""\"");"";; 636 output << std::endl;; 637 if (memData.fDimensions.size()) {; 638 output << "" typedef "" << memData.fType << "" "" << *it << ""_t"" << memData.fDimensions << "";"" << std::endl;; 639 output << "" "" << *it << ""_t& "" << *it << "" = "";; 640 output << ""*("" << *it << ""_t *)(target+offset_"" << *it;; 641 output << "");"" << std::endl;; 642 } else {; 643 output << "" "" << memData.fType << ""&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html:23107,down,down,23107,doc/master/RConversionRuleParser_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html,2,['down'],['down']
Availability,"/////////////////////////////; 713/// Return bin effective entries for a weighted filled Profile histogram.; 714///; 715/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 716/// The effective entries is defined as the square of the sum of the weights divided by the; 717/// sum of the weights square.; 718/// TProfile::Sumw2() must be called before filling the profile with weights.; 719/// Only by calling this method the sum of the square of the weights per bin is stored.; 720 ; 721Double_t TProfile3D::GetBinEffectiveEntries(Int_t bin); 722{; 723 return TProfileHelper::GetBinEffectiveEntries((TProfile3D*)this, bin);; 724}; 725 ; 726////////////////////////////////////////////////////////////////////////////////; 727/// Return bin error of a Profile3D histogram.; 728///; 729/// ### Computing errors: A moving field; 730///; 731/// The computation of errors for a TProfile3D has evolved with the versions; 732/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 733///; 734/// - prior to version 3.10, we had no special treatment of low statistic bins.; 735/// As a result, these bins had huge errors. The reason is that the; 736/// expression eprim2 is very close to 0 (rounding problems) or 0.; 737/// - The algorithm is modified/protected for the case; 738/// when a TProfile3D is projected (ProjectionX). The previous algorithm; 739/// generated a N^2 problem when projecting a TProfile3D with a large number of; 740/// bins (eg 100000).; 741/// - in version 3.10/02, a new static function TProfile::Approximate; 742/// is introduced to enable or disable (default) the approximation.; 743/// (see also comments in TProfile::GetBinError); 744 ; 745Double_t TProfile3D::GetBinError(Int_t bin) const; 746{; 747 return TProfileHelper::GetBinError((TProfile3D*)this, bin);; 748}; 749 ; 750////////////////////////////////////////////////////////////////////////////////; 751/// Return option to compute profile2D errors.; 752 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:25334,error,errors,25334,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,1,['error'],['errors']
Availability,"/////////////////////////////; 800/// Set zero values for point arrays in the range `[begin, end]`.; 801 ; 802void TGraphMultiErrors::FillZero(Int_t begin, Int_t end, Bool_t from_ctor); 803{; 804 if (!from_ctor); 805 TGraph::FillZero(begin, end, from_ctor);; 806 ; 807 Int_t n = (end - begin) * sizeof(Double_t);; 808 memset(fExL + begin, 0, n);; 809 memset(fExH + begin, 0, n);; 810 memset(fEyLSum + begin, 0, n);; 811 memset(fEyHSum + begin, 0, n);; 812 ; 813 for (Int_t j = 0; j < fNYErrors; j++) {; 814 memset(fEyL[j].GetArray() + begin, 0, n);; 815 memset(fEyH[j].GetArray() + begin, 0, n);; 816 }; 817}; 818 ; 819////////////////////////////////////////////////////////////////////////////////; 820/// Recalculates the summed y error arrays.; 821 ; 822void TGraphMultiErrors::CalcYErrorsSum() const; 823{; 824 if (!fEyLSum); 825 fEyLSum = new Double_t[fNpoints];; 826 if (!fEyHSum); 827 fEyHSum = new Double_t[fNpoints];; 828 ; 829 for (Int_t i = 0; i < fNpoints; i++) {; 830 fEyLSum[i] = GetErrorYlow(i);; 831 fEyHSum[i] = GetErrorYhigh(i);; 832 }; 833}; 834 ; 835////////////////////////////////////////////////////////////////////////////////; 836/// Protected function to perform the merge operation of a graph with multiple asymmetric errors.; 837 ; 838Bool_t TGraphMultiErrors::DoMerge(const TGraph *tg); 839{; 840 if (tg->GetN() == 0); 841 return kFALSE;; 842 ; 843 if (tg->IsA() == TGraphMultiErrors::Class()) {; 844 auto tgme = (TGraphMultiErrors *)tg;; 845 ; 846 for (Int_t i = 0; i < tgme->GetN(); i++) {; 847 Int_t ipoint = GetN();; 848 Double_t x, y;; 849 tgme->GetPoint(i, x, y);; 850 SetPoint(ipoint, x, y);; 851 SetPointEX(ipoint, tgme->GetErrorXlow(i), tgme->GetErrorXhigh(i));; 852 for (Int_t j = 0; j < tgme->GetNYErrors(); j++); 853 SetPointEY(ipoint, j, tgme->GetErrorYlow(i, j), tgme->GetErrorYhigh(i, j));; 854 }; 855 ; 856 return kTRUE;; 857 } else {; 858 Warning(""DoMerge"", ""Merging a %s is not compatible with a TGraphMultiErrors - Errors will be ignored"",; 859 tg->Is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:28680,error,errors,28680,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"///////////////////////////; 1489/// Create a secure temporary file by appending a unique; 1490/// 6 letter string to base. The file will be created in; 1491/// a standard (system) directory or in the directory; 1492/// provided in dir. Optionally one can provide suffix; 1493/// append to the final name - like extension "".txt"" or "".html"".; 1494/// The full filename is returned in base; 1495/// and a filepointer is returned for safely writing to the file; 1496/// (this avoids certain security problems). Returns 0 in case; 1497/// of error.; 1498 ; 1499FILE *TSystem::TempFileName(TString &, const char *, const char *); 1500{; 1501 AbstractMethod(""TempFileName"");; 1502 return nullptr;; 1503}; 1504 ; 1505////////////////////////////////////////////////////////////////////////////////; 1506/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1507 ; 1508int TSystem::Chmod(const char *, UInt_t); 1509{; 1510 AbstractMethod(""Chmod"");; 1511 return -1;; 1512}; 1513 ; 1514////////////////////////////////////////////////////////////////////////////////; 1515/// Set the process file creation mode mask.; 1516 ; 1517int TSystem::Umask(Int_t); 1518{; 1519 AbstractMethod(""Umask"");; 1520 return -1;; 1521}; 1522 ; 1523////////////////////////////////////////////////////////////////////////////////; 1524/// Set the a files modification and access times. If actime = 0 it will be; 1525/// set to the modtime. Returns 0 on success and -1 in case of error.; 1526 ; 1527int TSystem::Utime(const char *, Long_t, Long_t); 1528{; 1529 AbstractMethod(""Utime"");; 1530 return -1;; 1531}; 1532 ; 1533////////////////////////////////////////////////////////////////////////////////; 1534/// Find location of file in a search path. Return value points to TString for; 1535/// compatibility with Which(const char *, const char *, EAccessMode).; 1536/// Returns 0 in case file is not found.; 1537 ; 1538const char *TSystem::FindFile(const char *, TString&, EAccessMode); 1539{; 1540 Abstrac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:47815,mask,mask,47815,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['mask'],['mask']
Availability,"///////////////////////////; 859/// Return bin error of a Profile histogram; 860///; 861/// Computing errors: A moving field; 862///; 863/// The computation of errors for a TProfile has evolved with the versions; 864/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 865///; 866/// - prior to version 3.00, we had no special treatment of low statistic bins.; 867/// As a result, these bins had huge errors. The reason is that the; 868/// expression eprim2 is very close to 0 (rounding problems) or 0.; 869/// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; 870/// eprim2 very small and the bin errors set to the average bin errors, following; 871/// recommendations from a group of users.; 872/// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; 873/// should be applied only to low statistic bins.; 874/// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; 875/// to take two times the average error on all bins for these low; 876/// statistics bins giving a very small value for eprim2.; 877/// - in version 3.04 (Nov 2002), the algorithm is modified/protected for the case; 878/// when a TProfile is projected (ProjectionX). The previous algorithm; 879/// generated a N^2 problem when projecting a TProfile with a large number of; 880/// bins (eg 100000).; 881/// - in version 3.05/06, a new static function TProfile::Approximate; 882/// is introduced to enable or disable (default) the approximation.; 883///; 884/// Ideas for improvements of this algorithm are welcome. No suggestions; 885/// received since our call for advice to roottalk in Jul 2002.; 886/// see for instance: http://root.cern/root/roottalk/roottalk02/2916.html; 887 ; 888Double_t TProfile::GetBinError(Int_t bin) const; 889{; 890 return TProfileHelper::GetBinError((TProfile*)this, bin);; 891}; 892 ; 893////////////////////////////////////////////////////////////////////////////////; 894/// Return option to compute ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:32070,error,error,32070,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////; 1892/// Set eyL values for point `i`.; 1893 ; 1894void TGraphMultiErrors::SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL); 1895{; 1896 for (Int_t j = 0; j < fNYErrors; j++) {; 1897 if (j < ne); 1898 SetPointEYlow(i, j, eyL[j]);; 1899 else; 1900 SetPointEYlow(i, j, 0.);; 1901 }; 1902}; 1903 ; 1904////////////////////////////////////////////////////////////////////////////////; 1905/// Set eyH values for point `i`.; 1906 ; 1907void TGraphMultiErrors::SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH); 1908{; 1909 for (Int_t j = 0; j < fNYErrors; j++) {; 1910 if (j < ne); 1911 SetPointEYhigh(i, j, eyH[j]);; 1912 else; 1913 SetPointEYhigh(i, j, 0.);; 1914 }; 1915}; 1916 ; 1917////////////////////////////////////////////////////////////////////////////////; 1918/// Set error e ey values for point `i`.; 1919 ; 1920void TGraphMultiErrors::SetPointEY(Int_t i, Int_t e, Double_t eyL, Double_t eyH); 1921{; 1922 SetPointEYlow(i, e, eyL);; 1923 SetPointEYhigh(i, e, eyH);; 1924}; 1925 ; 1926////////////////////////////////////////////////////////////////////////////////; 1927/// Set error e eyL value for point `i`.; 1928 ; 1929void TGraphMultiErrors::SetPointEYlow(Int_t i, Int_t e, Double_t eyL); 1930{; 1931 if (i < 0 || e < 0); 1932 return;; 1933 ; 1934 if (i >= fNpoints); 1935 // re-allocate the object; 1936 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1937 ; 1938 while (e >= fNYErrors); 1939 AddYError(fNpoints);; 1940 ; 1941 fEyL[e][i] = eyL;; 1942 if (fEyLSum); 1943 fEyLSum[i] = GetErrorYlow(i);; 1944 else; 1945 CalcYErrorsSum();; 1946}; 1947 ; 1948////////////////////////////////////////////////////////////////////////////////; 1949/// Set error e eyH value for point `i`.; 1950 ; 1951void TGraphMultiErrors::SetPointEYhigh(Int_t i, Int_t e, Double_t eyH); 1952{; 1953 if (i < 0 || e < 0); 1954 return;; 1955 ; 1956 if (i >= fNpoints); 1957 // re-allocate the object; 1958 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1959 ; 1960 while (e >= fNYErrors)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:65227,error,error,65227,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////; 2261/// The following named arguments are supported; 2262/// <table>; 2263/// <tr><th> Type of CmdArg <th> Effect on parameter box; 2264/// <tr><td> `Parameters(const RooArgSet& param)` <td> Only the specified subset of parameters will be shown. By default all non-constant parameters are shown.; 2265/// <tr><td> `ShowConstants(bool flag)` <td> Also display constant parameters; 2266/// <tr><td> `Format(const char* what,...)` <td> Parameter formatting options.; 2267/// | Parameter | Format; 2268/// | ---------------------- | --------------------------; 2269/// | `const char* what` | Controls what is shown. ""N"" adds name (alternatively, ""T"" adds the title), ""E"" adds error, ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; 2270/// | `FixedPrecision(int n)`| Controls precision, set fixed number of digits; 2271/// | `AutoPrecision(int n)` | Controls precision. Number of shown digits is calculated from error + n specified additional digits (1 is sensible default); 2272/// <tr><td> `Label(const chat* label)` <td> Add label to parameter box. Use `\n` for multi-line labels.; 2273/// <tr><td> `Layout(double xmin, double xmax, double ymax)` <td> Specify relative position of left/right side of box and top of box.; 2274/// Coordinates are given as position on the pad between 0 and 1.; 2275/// The lower end of the box is calculated automatically from the number of lines in the box.; 2276/// </table>; 2277///; 2278///; 2279/// Example use:; 2280/// ```; 2281/// pdf.paramOn(frame, Label(""fit result""), Format(""NEU"",AutoPrecision(1)) ) ;; 2282/// ```; 2283///; 2284 ; 2285RooPlot* RooAbsPdf::paramOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2,; 2286 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 2287 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 2288{; 2289 // Stuff all arguments in a list; 2290 RooLinkedList cmdList;; 2291 cmdList.Add(const_cast<RooCmdArg*>(&arg1)) ; cmdList.Add(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:110542,error,error,110542,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////; 472/// Refresh this physical node. Called for all registered physical nodes; 473/// after an Align() call.; 474 ; 475void TGeoPhysicalNode::Refresh(); 476{; 477 SetPath(fName.Data());; 478}; 479 ; 480////////////////////////////////////////////////////////////////////////////////; 481/// Set node branch according to current state; 482 ; 483void TGeoPhysicalNode::SetBranchAsState(); 484{; 485 TGeoNodeCache *cache = gGeoManager->GetCache();; 486 if (!cache) {; 487 Error(""SetBranchAsState"", ""no state available"");; 488 return;; 489 }; 490 if (!cache->IsDummy()) {; 491 Error(""SetBranchAsState"", ""not implemented for full cache"");; 492 return;; 493 }; 494 if (!fNodes); 495 fNodes = new TObjArray(30);; 496 if (!fMatrices); 497 fMatrices = new TObjArray(30);; 498 TGeoHMatrix **matrices = (TGeoHMatrix **)cache->GetMatrices();; 499 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 500 ; 501 Bool_t refresh = (fLevel > 0) ? kTRUE : kFALSE;; 502 if (refresh) {; 503 TGeoHMatrix *current;; 504 for (Int_t i = 0; i <= fLevel; i++) {; 505 fNodes->AddAtAndExpand(branch[i], i);; 506 current = (TGeoHMatrix *)fMatrices->UncheckedAt(i);; 507 *current = *matrices[i];; 508 }; 509 return;; 510 }; 511 fLevel = gGeoManager->GetLevel();; 512 for (Int_t i = 0; i <= fLevel; i++) {; 513 fNodes->AddAtAndExpand(branch[i], i);; 514 fMatrices->AddAtAndExpand(new TGeoHMatrix(*matrices[i]), i);; 515 }; 516 TGeoNode *node = (TGeoNode *)fNodes->UncheckedAt(fLevel);; 517 if (!fMatrixOrig); 518 fMatrixOrig = new TGeoHMatrix();; 519 *fMatrixOrig = node->GetMatrix();; 520}; 521 ; 522////////////////////////////////////////////////////////////////////////////////; 523/// Allows PN entries (or users) to preset the local original matrix for the; 524/// last node pointed by the path.; 525 ; 526void TGeoPhysicalNode::SetMatrixOrig(const TGeoMatrix *local); 527{; 528 if (!fMatrixOrig); 529 fMatrixOrig = new TGeoHMatrix();; 530 if (!local) {; 531 fMatrixOrig->Clear();; 532 return;; 533",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:16544,avail,available,16544,doc/master/TGeoPhysicalNode_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html,1,['avail'],['available']
Availability,"///////////////////////; 1193/// Print the path of the directory.; 1194 ; 1195void TDirectory::pwd() const; 1196{; 1197 Printf(""%s"", GetPath());; 1198}; 1199 ; 1200////////////////////////////////////////////////////////////////////////////////; 1201/// Recursively remove object from a Directory.; 1202 ; 1203void TDirectory::RecursiveRemove(TObject *obj); 1204{; 1205 if (fList); 1206 fList->RecursiveRemove(obj);; 1207}; 1208 ; 1209////////////////////////////////////////////////////////////////////////////////; 1210/// Remove an object from the in-memory list.; 1211 ; 1212TObject *TDirectory::Remove(TObject* obj); 1213{; 1214 TObject *p = nullptr;; 1215 if (fList) {; 1216 p = fList->Remove(obj);; 1217 }; 1218 return p;; 1219}; 1220 ; 1221////////////////////////////////////////////////////////////////////////////////; 1222/// Removes subdirectory from the directory; 1223/// When directory is deleted, all keys in all subdirectories will be; 1224/// read first and deleted from file (if exists); 1225/// Equivalent call is Delete(""name;*"");; 1226 ; 1227void TDirectory::rmdir(const char *name); 1228{; 1229 if ((name==nullptr) || (*name==0)) return;; 1230 ; 1231 TString mask(name);; 1232 mask+="";*"";; 1233 Delete(mask);; 1234}; 1235 ; 1236////////////////////////////////////////////////////////////////////////////////; 1237/// Save object in filename,; 1238/// if filename is `nullptr` or """", a file with ""<objectname>.root"" is created.; 1239/// The name of the key is the object name.; 1240/// By default new file will be created. Using option ""a"", one can append object; 1241/// to the existing ROOT file.; 1242/// If the operation is successful, it returns the number of bytes written to the file; 1243/// otherwise it returns 0.; 1244/// By default a message is printed. Use option ""q"" to not print the message.; 1245/// If filename contains "".json"" extension, JSON representation of the object; 1246/// will be created and saved in the text file. Such file can be used in; 1247///",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:42225,mask,mask,42225,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,3,['mask'],['mask']
Availability,"///////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:72634,recover,recovered,72634,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['recover'],['recovered']
Availability,"///////////////////////; 3368/// Interface function to force use of a given normalization range; 3369/// to interpret function value. Needed for functions or p.d.f.s; 3370/// whose shape depends on the choice of normalization such as; 3371/// RooAddPdf; 3372 ; 3373void RooAbsReal::selectNormalizationRange(const char*, bool); 3374{; 3375}; 3376 ; 3377 ; 3378 ; 3379////////////////////////////////////////////////////////////////////////////////; 3380/// Advertise capability to determine maximum value of function for given set of; 3381/// observables. If no direct generator method is provided, this information; 3382/// will assist the accept/reject generator to operate more efficiently as; 3383/// it can skip the initial trial sampling phase to empirically find the function; 3384/// maximum; 3385 ; 3386Int_t RooAbsReal::getMaxVal(const RooArgSet& /*vars*/) const; 3387{; 3388 return 0 ;; 3389}; 3390 ; 3391 ; 3392 ; 3393////////////////////////////////////////////////////////////////////////////////; 3394/// Return maximum value for set of observables identified by code assigned; 3395/// in getMaxVal; 3396 ; 3397double RooAbsReal::maxVal(Int_t /*code*/) const; 3398{; 3399 assert(1) ;; 3400 return 0 ;; 3401}; 3402 ; 3403 ; 3404 ; 3405////////////////////////////////////////////////////////////////////////////////; 3406/// Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream.; 3407 ; 3408void RooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString); 3409{; 3410 if (evalErrorData().mode == Ignore) {; 3411 return ;; 3412 }; 3413 ; 3414 if (evalErrorData().mode == CountErrors) {; 3415 evalErrorData().count++ ;; 3416 return ;; 3417 }; 3418 ; 3419 static bool inLogEvalError = false ;; 3420 ; 3421 if (inLogEvalError) {; 3422 return ;; 3423 }; 3424 inLogEvalError = true ;; 3425 ; 3426 EvalError ee ;; 3427 ee.setMessage(message) ;; 3428 ; 3429 if (serverVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:146257,error,error,146257,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,2,['error'],['error']
Availability,"///////////////////////; 840/// Return bin entries of a Profile2D histogram.; 841 ; 842Double_t TProfile2D::GetBinEntries(Int_t bin) const; 843{; 844 if (fBuffer) ((TProfile2D*)this)->BufferEmpty();; 845 ; 846 if (bin < 0 || bin >= fNcells) return 0;; 847 return fBinEntries.fArray[bin];; 848}; 849 ; 850////////////////////////////////////////////////////////////////////////////////; 851/// Return bin effective entries for a weighted filled Profile histogram.; 852/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 853/// The effective entries is defined as the square of the sum of the weights divided by the; 854/// sum of the weights square.; 855/// TProfile::Sumw2() must be called before filling the profile with weights.; 856/// Only by calling this method the sum of the square of the weights per bin is stored.; 857 ; 858Double_t TProfile2D::GetBinEffectiveEntries(Int_t bin); 859{; 860 return TProfileHelper::GetBinEffectiveEntries(this, bin);; 861}; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Return bin error of a Profile2D histogram.; 865///; 866/// ### Computing errors: A moving field; 867///; 868/// The computation of errors for a TProfile2D has evolved with the versions; 869/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 870/// - prior to version 3.10, we had no special treatment of low statistic bins.; 871/// As a result, these bins had huge errors. The reason is that the; 872/// expression eprim2 is very close to 0 (rounding problems) or 0.; 873/// - The algorithm is modified/protected for the case; 874/// when a TProfile2D is projected (ProjectionX). The previous algorithm; 875/// generated a N^2 problem when projecting a TProfile2D with a large number of; 876/// bins (eg 100000).; 877/// - in version 3.10/02, a new static function TProfile::Approximate; 878/// is introduced to enable or disable (default) the approximation.; 879/// (see",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:30030,error,error,30030,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////; 2682/// Visit all members over members, recursing over base classes.; 2683 ; 2684void TCling::InspectMembers(TMemberInspector& insp, const void* obj,; 2685 const TClass* cl, Bool_t isTransient); 2686{; 2687 if (insp.GetObjectValidity() == TMemberInspector::kUnset) {; 2688 insp.SetObjectValidity(obj ? TMemberInspector::kValidObjectGiven; 2689 : TMemberInspector::kNoObjectGiven);; 2690 }; 2691 ; 2692 if (!cl || cl->GetCollectionProxy()) {; 2693 // We do not need to investigate the content of the STL; 2694 // collection, they are opaque to us (and details are; 2695 // uninteresting).; 2696 return;; 2697 }; 2698 ; 2699 static const TClassRef clRefString(""std::string"");; 2700 if (clRefString == cl) {; 2701 // We stream std::string without going through members..; 2702 return;; 2703 }; 2704 ; 2705 if (TClassEdit::IsStdArray(cl->GetName())) {; 2706 // We treat std arrays as C arrays; 2707 return;; 2708 }; 2709 ; 2710 if (TClassEdit::IsUniquePtr(cl->GetName())) {; 2711 // Ignore error caused by the inside of std::unique_ptr; 2712 // This is needed solely because of rootclingIO's IsUnsupportedUniquePointer; 2713 // which checks the number of elements in the GetListOfRealData.; 2714 // If this usage is removed, this can be replaced with a return statement.; 2715 // See https://github.com/root-project/root/issues/13574; 2716 isTransient = true;; 2717 }; 2718 ; 2719 const char* cobj = (const char*) obj; // for ptr arithmetics; 2720 ; 2721 // Treat the case of std::complex in a special manner. We want to enforce; 2722 // the layout of a stl implementation independent class, which is the; 2723 // complex as implemented in ROOT5.; 2724 ; 2725 // A simple lambda to simplify the code; 2726 auto inspInspect = [&] (ptrdiff_t offset){; 2727 insp.Inspect(const_cast<TClass*>(cl), insp.GetParent(), ""_real"", cobj, isTransient);; 2728 insp.Inspect(const_cast<TClass*>(cl), insp.GetParent(), ""_imag"", cobj + offset, isTransient);; 2729 };; 2730 ; 2731 auto complexType =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:104551,error,error,104551,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['error'],['error']
Availability,"/////////////////////; 126/// Constructor with four vectors of floats in input.; 127///; 128/// A grapherrors is built with the X coordinates taken from vx and Y coord from vy; 129/// and the errors from vectors vex and vey.; 130/// The number of points in the graph is the minimum of number of points; 131/// in vx and vy.; 132 ; 133TGraphErrors::TGraphErrors(const TVectorF &vx, const TVectorF &vy, const TVectorF &vex, const TVectorF &vey); 134 : TGraph(TMath::Min(vx.GetNrows(), vy.GetNrows()), vx.GetMatrixArray(), vy.GetMatrixArray() ); 135{; 136 if (!CtorAllocate()) return;; 137 Int_t ivexlow = vex.GetLwb();; 138 Int_t iveylow = vey.GetLwb();; 139 for (Int_t i = 0; i < fNpoints; i++) {; 140 fEX[i] = vex(i + ivexlow);; 141 fEY[i] = vey(i + iveylow);; 142 }; 143}; 144 ; 145 ; 146////////////////////////////////////////////////////////////////////////////////; 147/// Constructor with four vectors of doubles in input.; 148///; 149/// A grapherrors is built with the X coordinates taken from vx and Y coord from vy; 150/// and the errors from vectors vex and vey.; 151/// The number of points in the graph is the minimum of number of points; 152/// in vx and vy.; 153 ; 154TGraphErrors::TGraphErrors(const TVectorD &vx, const TVectorD &vy, const TVectorD &vex, const TVectorD &vey); 155 : TGraph(TMath::Min(vx.GetNrows(), vy.GetNrows()), vx.GetMatrixArray(), vy.GetMatrixArray() ); 156{; 157 if (!CtorAllocate()) return;; 158 Int_t ivexlow = vex.GetLwb();; 159 Int_t iveylow = vey.GetLwb();; 160 for (Int_t i = 0; i < fNpoints; i++) {; 161 fEX[i] = vex(i + ivexlow);; 162 fEY[i] = vey(i + iveylow);; 163 }; 164}; 165 ; 166 ; 167////////////////////////////////////////////////////////////////////////////////; 168/// TGraphErrors copy constructor.; 169 ; 170TGraphErrors::TGraphErrors(const TGraphErrors &gr); 171 : TGraph(gr); 172{; 173 if (!CtorAllocate()) return;; 174 ; 175 Int_t n = sizeof(Double_t) * fNpoints;; 176 memcpy(fEX, gr.fEX, n);; 177 memcpy(fEY, gr.fEY, n);; 178}; 179 ; 180",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:4874,error,errors,4874,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['errors']
Availability,"/////////////////////; 743/// Returns `x` raised to the power `y`.; 744 ; 745inline Double_t TMath::Power(Double_t x, Int_t y) {; 746#ifdef R__ANSISTREAM; 747 return std::pow(x, y);; 748#else; 749 return pow(x, (Double_t) y);; 750#endif; 751}; 752 ; 753////////////////////////////////////////////////////////////////////////////////; 754/// Returns the natural logarithm of `x`.; 755 ; 756inline Double_t TMath::Log(Double_t x); 757 { return log(x); }; 758 ; 759////////////////////////////////////////////////////////////////////////////////; 760/// Returns the common (base-10) logarithm of `x`.; 761 ; 762inline Double_t TMath::Log10(Double_t x); 763 { return log10(x); }; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Check if it is finite with a mask in order to be consistent in presence of; 767/// fast math.; 768/// Inspired from the CMSSW FWCore/Utilities package; 769 ; 770inline Int_t TMath::Finite(Double_t x); 771#if defined(R__FAST_MATH); 772 ; 773{; 774 const unsigned long long mask = 0x7FF0000000000000LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { return isfinite(x); }; 782# elif defined(R__MACOSX); 783# ifdef isfinite; 784 // from math.h; 785 { return isfinite(x); }; 786# else; 787 // from cmath; 788 { return std::isfinite(x); }; 789# endif; 790# else; 791 { return finite(x); }; 792# endif; 793#endif; 794 ; 795////////////////////////////////////////////////////////////////////////////////; 796/// Check if it is finite with a mask in order to be consistent in presence of; 797/// fast math.; 798/// Inspired from the CMSSW FWCore/Utilities package; 799 ; 800inline Int_t TMath::Finite(Float_t x); 801#if defined(R__FAST_MATH); 802 ; 803{; 804 const unsigned int mask = 0x7f800000;; 805 union { unsigned int l; float d;} v;; 806 v.d =x;; 807 return (v.l&mask)!=mask;; 808}; 809#else; 810{ return std::isfinite(x); }; 811#",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:28979,mask,mask,28979,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['mask'],['mask']
Availability,"////////////////////; 1553/// Get low error e on y coordinate for point `i`.; 1554 ; 1555Double_t TGraphMultiErrors::GetErrorYlow(Int_t i, Int_t e) const; 1556{; 1557 if (i < 0 || i >= fNpoints || e >= fNYErrors || fEyL.empty()); 1558 return -1.;; 1559 ; 1560 return fEyL[e][i];; 1561}; 1562 ; 1563////////////////////////////////////////////////////////////////////////////////; 1564/// Get high error e on y coordinate for point `i`.; 1565 ; 1566Double_t TGraphMultiErrors::GetErrorYhigh(Int_t i, Int_t e) const; 1567{; 1568 if (i < 0 || i >= fNpoints || e >= fNYErrors || fEyH.empty()); 1569 return -1.;; 1570 ; 1571 return fEyH[e][i];; 1572}; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575/// Get all low errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1576 ; 1577Double_t *TGraphMultiErrors::GetEYlow() const; 1578{; 1579 if (!fEyLSum); 1580 CalcYErrorsSum();; 1581 ; 1582 return fEyLSum;; 1583}; 1584 ; 1585////////////////////////////////////////////////////////////////////////////////; 1586/// Get all high errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1587 ; 1588Double_t *TGraphMultiErrors::GetEYhigh() const; 1589{; 1590 if (!fEyHSum); 1591 CalcYErrorsSum();; 1592 ; 1593 return fEyHSum;; 1594}; 1595 ; 1596////////////////////////////////////////////////////////////////////////////////; 1597/// Get all low errors `e` on y coordinates as an array.; 1598 ; 1599Double_t *TGraphMultiErrors::GetEYlow(Int_t e); 1600{; 1601 if (e >= fNYErrors || fEyL.empty()); 1602 return nullptr;; 1603 else; 1604 return fEyL[e].GetArray();; 1605}; 1606 ; 1607////////////////////////////////////////////////////////////////////////////////; 1608/// Get all high errors `e` on y coordinates as an array.; 1609 ; 1610Double_t *TGraphMultiErrors::GetEYhigh(Int_t e); 1611{; 1612 if (e >= fNYErrors || fEyH.empty()); 1613 return nullptr;; 1614 else; 1615 return fEyH[e].GetArray();; 1616}; 1617 ; 1618",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:54229,error,errors,54229,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,////////////////////; 1575/// Get all low errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1576 ; 1577Double_t *TGraphMultiErrors::GetEYlow() const; 1578{; 1579 if (!fEyLSum); 1580 CalcYErrorsSum();; 1581 ; 1582 return fEyLSum;; 1583}; 1584 ; 1585////////////////////////////////////////////////////////////////////////////////; 1586/// Get all high errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1587 ; 1588Double_t *TGraphMultiErrors::GetEYhigh() const; 1589{; 1590 if (!fEyHSum); 1591 CalcYErrorsSum();; 1592 ; 1593 return fEyHSum;; 1594}; 1595 ; 1596////////////////////////////////////////////////////////////////////////////////; 1597/// Get all low errors `e` on y coordinates as an array.; 1598 ; 1599Double_t *TGraphMultiErrors::GetEYlow(Int_t e); 1600{; 1601 if (e >= fNYErrors || fEyL.empty()); 1602 return nullptr;; 1603 else; 1604 return fEyL[e].GetArray();; 1605}; 1606 ; 1607////////////////////////////////////////////////////////////////////////////////; 1608/// Get all high errors `e` on y coordinates as an array.; 1609 ; 1610Double_t *TGraphMultiErrors::GetEYhigh(Int_t e); 1611{; 1612 if (e >= fNYErrors || fEyH.empty()); 1613 return nullptr;; 1614 else; 1615 return fEyH[e].GetArray();; 1616}; 1617 ; 1618////////////////////////////////////////////////////////////////////////////////; 1619/// Get AttFill pointer for specified error dimension.; 1620 ; 1621TAttFill *TGraphMultiErrors::GetAttFill(Int_t e); 1622{; 1623 if (e >= 0 && e < fNYErrors); 1624 return &fAttFill.at(e);; 1625 else; 1626 return nullptr;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Get AttLine pointer for specified error dimension.; 1631 ; 1632TAttLine *TGraphMultiErrors::GetAttLine(Int_t e); 1633{; 1634 if (e >= 0 && e < fNYErrors); 1635 return &fAttLine.at(e);; 1636 else; 1637 return nullptr;; 1638}; 1639 ; 1640//////////////////////////////////////////////////////////////////,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:54900,error,errors,54900,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"////////////////////; 3873/// Set interval timer to time-out in ms milliseconds.; 3874 ; 3875int TUnixSystem::UnixSetitimer(Long_t ms); 3876{; 3877 struct itimerval itv;; 3878 itv.it_value.tv_sec = 0;; 3879 itv.it_value.tv_usec = 0;; 3880 itv.it_interval.tv_sec = 0;; 3881 itv.it_interval.tv_usec = 0;; 3882 if (ms > 0) {; 3883 itv.it_value.tv_sec = time_t(ms / 1000);; 3884 itv.it_value.tv_usec = time_t((ms % 1000) * 1000);; 3885 }; 3886 int st = setitimer(ITIMER_REAL, &itv, nullptr);; 3887 if (st == -1); 3888 ::SysError(""TUnixSystem::UnixSetitimer"", ""setitimer"");; 3889 return st;; 3890}; 3891 ; 3892//---- file descriptors --------------------------------------------------------; 3893 ; 3894////////////////////////////////////////////////////////////////////////////////; 3895/// Wait for events on the file descriptors specified in the readready and; 3896/// writeready masks or for timeout (in milliseconds) to occur. Returns; 3897/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 3898/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 3899/// the errno has been reset and the method can be called again.; 3900 ; 3901int TUnixSystem::UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 3902 Long_t timeout); 3903{; 3904 int retcode;; 3905 ; 3906 fd_set *rd = (readready) ? (fd_set*)readready->GetBits() : nullptr;; 3907 fd_set *wr = (writeready) ? (fd_set*)writeready->GetBits() : nullptr;; 3908 ; 3909 if (timeout >= 0) {; 3910 struct timeval tv;; 3911 tv.tv_sec = Int_t(timeout / 1000);; 3912 tv.tv_usec = (timeout % 1000) * 1000;; 3913 retcode = select(nfds, rd, wr, nullptr, &tv);; 3914 } else {; 3915 retcode = select(nfds, rd, wr, nullptr, nullptr);; 3916 }; 3917 if (retcode == -1) {; 3918 if (GetErrno() == EINTR) {; 3919 ResetErrno(); // errno is not self reseting; 3920 return -2;; 3921 }; 3922 if (GetErrno() == EBADF); 3923 return -3;; 3924 return -1;; 3925 }; 3926 ; 3927 return retcode;; 3928}; 3929 ; 3930//---- direct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:124919,error,error,124919,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['error'],['error']
Availability,///////////////////; 203/// This function is called by Graph2DFitChisquare.; 204/// It returns the error along X at point i.; 205 ; 206Double_t TGraph2DErrors::GetErrorX(Int_t i) const; 207{; 208 if (i < 0 || i >= fNpoints) return -1;; 209 if (fEX) return fEX[i];; 210 return -1;; 211}; 212 ; 213 ; 214////////////////////////////////////////////////////////////////////////////////; 215/// This function is called by Graph2DFitChisquare.; 216/// It returns the error along Y at point i.; 217 ; 218Double_t TGraph2DErrors::GetErrorY(Int_t i) const; 219{; 220 if (i < 0 || i >= fNpoints) return -1;; 221 if (fEY) return fEY[i];; 222 return -1;; 223}; 224 ; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// This function is called by Graph2DFitChisquare.; 228/// It returns the error along Z at point i.; 229 ; 230Double_t TGraph2DErrors::GetErrorZ(Int_t i) const; 231{; 232 if (i < 0 || i >= fNpoints) return -1;; 233 if (fEZ) return fEZ[i];; 234 return -1;; 235}; 236 ; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// Returns the X maximum with errors.; 240 ; 241Double_t TGraph2DErrors::GetXmaxE() const; 242{; 243 Double_t v = fX[0]+fEX[0];; 244 for (Int_t i=1; i<fNpoints; i++) if (fX[i]+fEX[i]>v) v=fX[i]+fEX[i];; 245 return v;; 246}; 247 ; 248 ; 249////////////////////////////////////////////////////////////////////////////////; 250/// Returns the X minimum with errors.; 251 ; 252Double_t TGraph2DErrors::GetXminE() const; 253{; 254 Double_t v = fX[0]-fEX[0];; 255 for (Int_t i=1; i<fNpoints; i++) if (fX[i]-fEX[i]<v) v=fX[i]-fEX[i];; 256 return v;; 257}; 258 ; 259 ; 260////////////////////////////////////////////////////////////////////////////////; 261/// Returns the Y maximum with errors.; 262 ; 263Double_t TGraph2DErrors::GetYmaxE() const; 264{; 265 Double_t v = fY[0]+fEY[0];; 266 for (Int_t i=1; i<fNpoints; i++) if (fY[i]+fEY[i]>v) v=fY[i]+fEY[i];; 267 return v;; 268}; 269 ; 270 ; 2,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:6986,error,errors,6986,doc/master/TGraph2DErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html,1,['error'],['errors']
Availability,"///////////////////; 675/// Canvas destructor; 676 ; 677TCanvas::~TCanvas(); 678{; 679 Destructor();; 680}; 681 ; 682////////////////////////////////////////////////////////////////////////////////; 683/// Browse.; 684 ; 685void TCanvas::Browse(TBrowser *b); 686{; 687 Draw();; 688 cd();; 689 if (fgIsFolder) fPrimitives->Browse(b);; 690}; 691 ; 692////////////////////////////////////////////////////////////////////////////////; 693/// Actual canvas destructor.; 694 ; 695void TCanvas::Destructor(); 696{; 697 if (gThreadXAR) {; 698 void *arr[2];; 699 arr[1] = this;; 700 if ((*gThreadXAR)(""CDEL"", 2, arr, nullptr)) return;; 701 }; 702 ; 703 if (ROOT::Detail::HasBeenDeleted(this)) return;; 704 ; 705 SafeDelete(fContextMenu);; 706 if (!gPad) return;; 707 ; 708 Close();; 709 ; 710 //If not yet (batch mode?).; 711 SafeDelete(fPainter);; 712}; 713 ; 714////////////////////////////////////////////////////////////////////////////////; 715/// Set current canvas & pad. Returns the new current pad,; 716/// or 0 in case of failure.; 717/// See TPad::cd() for an explanation of the parameter.; 718 ; 719TVirtualPad *TCanvas::cd(Int_t subpadnumber); 720{; 721 if (fCanvasID == -1) return nullptr;; 722 ; 723 TPad::cd(subpadnumber);; 724 ; 725 // in case doublebuffer is off, draw directly onto display window; 726 if (!IsBatch() && !IsWeb() && !fDoubleBuffer); 727 gVirtualX->SelectWindow(fCanvasID);//Ok, does not matter for glpad.; 728 ; 729 return gPad;; 730}; 731 ; 732////////////////////////////////////////////////////////////////////////////////; 733/// Remove all primitives from the canvas.; 734/// If option ""D"" is specified, direct sub-pads are cleared but not deleted.; 735/// This option is not recursive, i.e. pads in direct sub-pads are deleted.; 736 ; 737void TCanvas::Clear(Option_t *option); 738{; 739 if (fCanvasID == -1) return;; 740 ; 741 R__LOCKGUARD(gROOTMutex);; 742 ; 743 TString opt = option;; 744 opt.ToLower();; 745 if (opt.Contains(""d"")) {; 746 // clear subpads, but do no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:23349,failure,failure,23349,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['failure'],['failure']
Availability,"//////////////////; 1371/// Create/Delete structure to store sum of squares of weights per bin; 1372/// This is needed to compute the correct statistical quantities; 1373/// of a profile filled with weights; 1374///; 1375/// This function is automatically called when the histogram is created; 1376/// if the static function TH1::SetDefaultSumw2 has been called before.; 1377/// If flag = false the structure is deleted; 1378 ; 1379void TProfile3D::Sumw2(Bool_t flag); 1380{; 1381 TProfileHelper::Sumw2(this, flag);; 1382}; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; THLimitsFinder.h; THashList.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TMath.h; TProfile2D.h; TProfile3D.h; TProfileHelper.h; kERRORSPREAD@ kERRORSPREADDefinition TProfile.h:28; kERRORSPREADG@ kERRORSPREADGDefi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:53120,error,error,53120,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////; 4910/// Cast obj of this class type up to baseclass cl if up is true.; 4911/// Cast obj of this class type down from baseclass cl if up is false.; 4912/// If this class is not a baseclass of cl return 0, else the pointer; 4913/// to the cl part of this (up) or to this (down).; 4914 ; 4915void *TClass::DynamicCast(const TClass *cl, void *obj, Bool_t up); 4916{; 4917 if (cl == this) return obj;; 4918 ; 4919 if (!HasDataMemberInfo()) return nullptr;; 4920 ; 4921 Int_t off;; 4922 if ((off = GetBaseClassOffset(cl, obj)) != -1) {; 4923 if (up); 4924 return (void*)((Longptr_t)obj+off);; 4925 else; 4926 return (void*)((Longptr_t)obj-off);; 4927 }; 4928 return nullptr;; 4929}; 4930 ; 4931////////////////////////////////////////////////////////////////////////////////; 4932/// Cast obj of this class type up to baseclass cl if up is true.; 4933/// Cast obj of this class type down from baseclass cl if up is false.; 4934/// If this class is not a baseclass of cl return 0, else the pointer; 4935/// to the cl part of this (up) or to this (down).; 4936 ; 4937const void *TClass::DynamicCast(const TClass *cl, const void *obj, Bool_t up); 4938{; 4939 return DynamicCast(cl,const_cast<void*>(obj),up);; 4940}; 4941 ; 4942////////////////////////////////////////////////////////////////////////////////; 4943/// Return a pointer to a newly allocated object of this class.; 4944/// The class must have a default constructor. For meaning of; 4945/// defConstructor, see TClass::IsCallingNew().; 4946///; 4947/// If quiet is true, do no issue a message via Error on case; 4948/// of problems, just return 0.; 4949///; 4950/// The constructor actually called here can be customized by; 4951/// using the rootcint pragma:; 4952/// ~~~ {.cpp}; 4953/// #pragma link C++ ioctortype UserClass;; 4954/// ~~~; 4955/// For example, with this pragma and a class named MyClass,; 4956/// this method will called the first of the following 3; 4957/// constructors which exists and is public:; 4958///",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:188112,down,down,188112,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['down'],['down']
Availability,"//////////////////; 4977/// Cast obj of this class type up to baseclass cl if up is true.; 4978/// Cast obj of this class type down from baseclass cl if up is false.; 4979/// If this class is not a baseclass of cl return 0, else the pointer; 4980/// to the cl part of this (up) or to this (down).; 4981 ; 4982void *TClass::DynamicCast(const TClass *cl, void *obj, Bool_t up); 4983{; 4984 if (cl == this) return obj;; 4985 ; 4986 if (!HasDataMemberInfo()) return nullptr;; 4987 ; 4988 Int_t off;; 4989 if ((off = GetBaseClassOffset(cl, obj)) != -1) {; 4990 if (up); 4991 return (void*)((Longptr_t)obj+off);; 4992 else; 4993 return (void*)((Longptr_t)obj-off);; 4994 }; 4995 return nullptr;; 4996}; 4997 ; 4998////////////////////////////////////////////////////////////////////////////////; 4999/// Cast obj of this class type up to baseclass cl if up is true.; 5000/// Cast obj of this class type down from baseclass cl if up is false.; 5001/// If this class is not a baseclass of cl return 0, else the pointer; 5002/// to the cl part of this (up) or to this (down).; 5003 ; 5004const void *TClass::DynamicCast(const TClass *cl, const void *obj, Bool_t up); 5005{; 5006 return DynamicCast(cl,const_cast<void*>(obj),up);; 5007}; 5008 ; 5009////////////////////////////////////////////////////////////////////////////////; 5010/// Return a pointer to a newly allocated object of this class.; 5011/// The class must have a default constructor. For meaning of; 5012/// defConstructor, see TClass::IsCallingNew().; 5013///; 5014/// If quiet is true, do no issue a message via Error on case; 5015/// of problems, just return 0.; 5016///; 5017/// The constructor actually called here can be customized by; 5018/// using the rootcint pragma:; 5019/// ~~~ {.cpp}; 5020/// #pragma link C++ ioctortype UserClass;; 5021/// ~~~; 5022/// For example, with this pragma and a class named MyClass,; 5023/// this method will called the first of the following 3; 5024/// constructors which exists and is public:; 5025///",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:190863,down,down,190863,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['down'],['down']
Availability,"/////////////////; 1071/// Main minimization procedure; 1072///; 1073/// This function is called after setting theoretical function; 1074/// by means of TFumili::SetUserFunc and initializing parameters.; 1075/// Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); 1076/// If FCN is undefined then user has to provide data arrays by calling; 1077/// TFumili::SetData procedure.; 1078///; 1079/// TFumili::Minimize return following values:; 1080/// - 0 - fit is converged; 1081/// - -2 - function is not decreasing (or bad derivatives); 1082/// - -3 - error estimations are infinite; 1083/// - -4 - maximum number of iterations is exceeded; 1084 ; 1085Int_t TFumili::Minimize(); 1086{; 1087 Int_t i;; 1088 // Flag3 - is fit is chi2 or likelihood? 0 - chi2, 1 - likelihood; 1089 fINDFLG[2]=0;; 1090 //; 1091 // Are the parameters outside of the boundaries ?; 1092 //; 1093 Int_t parn;; 1094 ; 1095 if(fFCN) {; 1096 Eval(parn,fGr,fS,fA,9); fNfcn++;; 1097 }; 1098 for( i = 0; i < fNpar; i++) {; 1099 if(fA[i] > fAMX[i]) fA[i] = fAMX[i];; 1100 if(fA[i] < fAMN[i]) fA[i] = fAMN[i];; 1101 }; 1102 ; 1103 Int_t nn2, n, fixFLG, ifix1, fi, nn3, nn1, n0;; 1104 Double_t t1;; 1105 Double_t sp, t, olds=0;; 1106 Double_t bi, aiMAX=0, amb;; 1107 Double_t afix, sigi, akap;; 1108 Double_t alambd, al, bm, abi, abm;; 1109 Int_t l1, k, ifix;; 1110 ; 1111 nn2=0;; 1112 ; 1113 // Number of parameters;; 1114 n=fNpar;; 1115 fixFLG=0;; 1116 ; 1117 // Exit flag; 1118 fENDFLG=0;; 1119 ; 1120 // Flag2; 1121 fINDFLG[1] = 0;; 1122 ifix1=-1;; 1123 fi=0;; 1124 nn3=0;; 1125 ; 1126 // Initialize param.step limits; 1127 for( i=0; i < n; i++) {; 1128 fR[i]=0.;; 1129 if ( fEPS > 0.) fParamError[i] = 0.;; 1130 fPL[i] = fPL0[i];; 1131 }; 1132 ; 1133L3: // Start Iteration; 1134 ; 1135 nn1 = 1;; 1136 t1 = 1.;; 1137 ; 1138L4: // New iteration; 1139 ; 1140 // fS - objective function value - zero first; 1141 fS = 0.;; 1142 // n0 - number of variable parameters in fit; 1143 n0 = 0;; 1144 for( i = 0; i < n;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:31307,error,error,31307,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,1,['error'],['error']
Availability,/////////////////; 1586/// Get all high errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1587 ; 1588Double_t *TGraphMultiErrors::GetEYhigh() const; 1589{; 1590 if (!fEyHSum); 1591 CalcYErrorsSum();; 1592 ; 1593 return fEyHSum;; 1594}; 1595 ; 1596////////////////////////////////////////////////////////////////////////////////; 1597/// Get all low errors `e` on y coordinates as an array.; 1598 ; 1599Double_t *TGraphMultiErrors::GetEYlow(Int_t e); 1600{; 1601 if (e >= fNYErrors || fEyL.empty()); 1602 return nullptr;; 1603 else; 1604 return fEyL[e].GetArray();; 1605}; 1606 ; 1607////////////////////////////////////////////////////////////////////////////////; 1608/// Get all high errors `e` on y coordinates as an array.; 1609 ; 1610Double_t *TGraphMultiErrors::GetEYhigh(Int_t e); 1611{; 1612 if (e >= fNYErrors || fEyH.empty()); 1613 return nullptr;; 1614 else; 1615 return fEyH[e].GetArray();; 1616}; 1617 ; 1618////////////////////////////////////////////////////////////////////////////////; 1619/// Get AttFill pointer for specified error dimension.; 1620 ; 1621TAttFill *TGraphMultiErrors::GetAttFill(Int_t e); 1622{; 1623 if (e >= 0 && e < fNYErrors); 1624 return &fAttFill.at(e);; 1625 else; 1626 return nullptr;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Get AttLine pointer for specified error dimension.; 1631 ; 1632TAttLine *TGraphMultiErrors::GetAttLine(Int_t e); 1633{; 1634 if (e >= 0 && e < fNYErrors); 1635 return &fAttLine.at(e);; 1636 else; 1637 return nullptr;; 1638}; 1639 ; 1640////////////////////////////////////////////////////////////////////////////////; 1641/// Get Fill Color for specified error e (-1 = Global and x errors).; 1642 ; 1643Color_t TGraphMultiErrors::GetFillColor(Int_t e) const; 1644{; 1645 if (e == -1); 1646 return GetFillColor();; 1647 else if (e >= 0 && e < fNYErrors); 1648 return fAttFill[e].GetFillColor();; 1649 else; 1650 return 0;; 1651}; 1652 ; 165,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:55259,error,error,55259,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['error']
Availability,"/////////////////; 443/// Scan the memory lists of all files for an object with name; 444 ; 445TObject *TDirectoryFile::FindObjectAnyFile(const char *name) const; 446{; 447 TFile *f;; 448 R__LOCKGUARD(gROOTMutex);; 449 TIter next(gROOT->GetListOfFiles());; 450 while ((f = (TFile*)next())) {; 451 TObject *obj = f->GetList()->FindObject(name);; 452 if (obj) return obj;; 453 }; 454 return nullptr;; 455}; 456 ; 457////////////////////////////////////////////////////////////////////////////////; 458/// Find a directory named ""apath"".; 459///; 460/// It apath is null or empty, returns ""this"" directory.; 461/// Otherwise use the name ""apath"" to find a directory.; 462/// The absolute path syntax is:; 463///; 464/// file.root:/dir1/dir2; 465///; 466/// where file.root is the file and /dir1/dir2 the desired subdirectory; 467/// in the file. Relative syntax is relative to ""this"" directory. E.g:; 468/// ../aa.; 469/// Returns 0 in case path does not exist.; 470/// If printError is true, use Error with 'funcname' to issue an error message.; 471 ; 472TDirectory *TDirectoryFile::GetDirectory(const char *apath,; 473 Bool_t printError, const char *funcname); 474{; 475 Int_t nch = 0;; 476 if (apath) nch = strlen(apath);; 477 if (!nch) {; 478 return this;; 479 }; 480 ; 481 if (funcname==0 || strlen(funcname)==0) funcname = ""GetDirectory"";; 482 ; 483 TDirectory *result = this;; 484 ; 485 char *path = new char[nch+1]; path[0] = 0;; 486 if (nch) strlcpy(path,apath,nch+1);; 487 char *s = (char*)strchr(path, ':');; 488 if (s) {; 489 *s = '\0';; 490 R__LOCKGUARD(gROOTMutex);; 491 TDirectory *f = (TDirectory *)gROOT->GetListOfFiles()->FindObject(path);; 492 // Check if this is a duplicate (2nd opening) on this file and prefer; 493 // this file.; 494 if (GetFile()) {; 495 auto url = GetFile()->GetEndpointUrl();; 496 if (f && 0 == url->Compare(f->GetFile()->GetEndpointUrl())) {; 497 result = GetDirectory(s+1,printError,funcname);; 498 delete [] path;; 499 return result;; 500 }; 501 }; 502 if (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:15540,error,error,15540,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['error'],['error']
Availability,"/////////////////; 854/// Swap points.; 855 ; 856void TGraphErrors::SwapPoints(Int_t pos1, Int_t pos2); 857{; 858 SwapValues(fEX, pos1, pos2);; 859 SwapValues(fEY, pos1, pos2);; 860 TGraph::SwapPoints(pos1, pos2);; 861}; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Update the fX, fY, fEX, and fEY arrays with the sorted values.; 865 ; 866void TGraphErrors::UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low); 867{; 868 std::vector<Double_t> fEXSorted(numSortedPoints);; 869 std::vector<Double_t> fEYSorted(numSortedPoints);; 870 ; 871 // Fill the sorted X and Y error values based on the sorted indices; 872 std::generate(fEXSorted.begin(), fEXSorted.end(),; 873 [begin = low, &sorting_indices, this]() mutable { return fEX[sorting_indices[begin++]]; });; 874 std::generate(fEYSorted.begin(), fEYSorted.end(),; 875 [begin = low, &sorting_indices, this]() mutable { return fEY[sorting_indices[begin++]]; });; 876 ; 877 // Copy the sorted X and Y error values back to the original arrays; 878 std::copy(fEXSorted.begin(), fEXSorted.end(), fEX + low);; 879 std::copy(fEYSorted.begin(), fEYSorted.end(), fEY + low);; 880 ; 881 TGraph::UpdateArrays(sorting_indices, numSortedPoints, low);; 882}; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; g#define g(i)Definition RSha256.hxx:105; h#define h(i)Definition RSha256.hxx:106; Version_tshort Version_tDefinition RtypesCore.h:65; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; TF1.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineCol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:28191,error,error,28191,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['error']
Availability,"//////////////; 17// //; 18// TGraphErrors //; 19// //; 20// a Graph with error bars //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TGraph.h""; 25 ; 26class TGraphErrors : public TGraph {; 27 ; 28protected:; 29 Double_t *fEX{nullptr}; ///<[fNpoints] array of X errors; 30 Double_t *fEY{nullptr}; ///<[fNpoints] array of Y errors; 31 ; 32 void SwapPoints(Int_t pos1, Int_t pos2) override;; 33 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 34 ; 35 Double_t** Allocate(Int_t size) override;; 36 void CopyAndRelease(Double_t **newarrays,; 37 Int_t ibegin, Int_t iend, Int_t obegin) override;; 38 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 39 Int_t obegin) override;; 40 Bool_t CtorAllocate();; 41 void FillZero(Int_t begin, Int_t end,; 42 Bool_t from_ctor = kTRUE) override;; 43 Bool_t DoMerge(const TGraph * g) override;; 44 ; 45 ; 46public:; 47 TGraphErrors();; 48 TGraphErrors(Int_t n);; 49 TGraphErrors(Int_t n, const Float_t *x, const Float_t *y, const Float_t *ex = nullptr, const Float_t *ey = nullptr);; 50 TGraphErrors(Int_t n, const Double_t *x, const Double_t *y, const Double_t *ex = nullptr, const Double_t *ey = nullptr);; 51 TGraphErrors(const TVectorF &vx, const TVectorF &vy, const TVectorF &vex, const TVectorF &vey);; 52 TGraphErrors(const TVectorD &vx, const TVectorD &vy, const TVectorD &vex, const TVectorD &vey);; 53 TGraphErrors(const TGraphErrors &gr);; 54 TGraphErrors& operator=(const TGraphErrors &gr);; 55 TGraphErrors(const TH1 *h);; 56 TGraphErrors(const char *filename, const char *format=""%lg %lg %lg %lg"", Option_t *option="""");; 57 ~TGraphErrors() override;; 58 virtual void AddPointError(Double_t x, Double_t y, Double_t ex = 0., Double_t ey = 0.);; 59 void Apply(TF1 *f) override;; 60 virtual void ApplyX(TF1 *f);; 61 static Int_t CalculateScanfFields(const char *fmt);; 62 void ComputeRange(Double_t &xmin, Double_t &ymin, Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8h_source.html:1073,error,errors,1073,doc/master/TGraphErrors_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html,2,['error'],['errors']
Availability,"/////////////; 6155// Get the list of 'published'/'known' library for the class and load them.; 6156Int_t TCling::ShallowAutoLoadImpl(const char *cls); 6157{; 6158 Int_t status = 0;; 6159 ; 6160 // lookup class to find list of dependent libraries; 6161 TString deplibs = gCling->GetClassSharedLibs(cls);; 6162 if (!deplibs.IsNull()) {; 6163 TString delim("" "");; 6164 TObjArray* tokens = deplibs.Tokenize(delim);; 6165 for (Int_t i = (tokens->GetEntriesFast() - 1); i > 0; --i) {; 6166 const char* deplib = ((TObjString*)tokens->At(i))->GetName();; 6167 if (gROOT->LoadClass(cls, deplib) == 0) {; 6168 if (gDebug > 0) {; 6169 gCling->Info(""TCling::AutoLoad"",; 6170 ""loaded dependent library %s for %s"", deplib, cls);; 6171 }; 6172 }; 6173 else {; 6174 gCling->Error(""TCling::AutoLoad"",; 6175 ""failure loading dependent library %s for %s"",; 6176 deplib, cls);; 6177 }; 6178 }; 6179 const char* lib = ((TObjString*)tokens->At(0))->GetName();; 6180 if (lib && lib[0]) {; 6181 if (gROOT->LoadClass(cls, lib) == 0) {; 6182 if (gDebug > 0) {; 6183 gCling->Info(""TCling::AutoLoad"",; 6184 ""loaded library %s for %s"", lib, cls);; 6185 }; 6186 status = 1;; 6187 }; 6188 else {; 6189 gCling->Error(""TCling::AutoLoad"",; 6190 ""failure loading library %s for %s"", lib, cls);; 6191 }; 6192 }; 6193 delete tokens;; 6194 }; 6195 ; 6196 return status;; 6197}; 6198 ; 6199////////////////////////////////////////////////////////////////////////////////; 6200// Iterate through the data member of the class (either through the TProtoClass; 6201// or through Cling) and trigger, recursively, the loading the necessary libraries.; 6202// \note `cls` is expected to be already normalized!; 6203// \returns 1 on success.; 6204Int_t TCling::DeepAutoLoadImpl(const char *cls, std::unordered_set<std::string> &visited,; 6205 bool nameIsNormalized); 6206{; 6207 // Try to insert; if insertion failed because the entry existed, DeepAutoLoadImpl(); 6208 // has previously (within the same call to `AutoLoad()`) tried to load this cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:239285,failure,failure,239285,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['failure'],['failure']
Availability,"///////////; 636/// Scan parameter ipar between value of xmin and xmax; 637/// A array for x and y points should be provided; 638 ; 639bool FitResult::Scan(unsigned int ipar, unsigned int &npoints, double *pntsx, double *pntsy, double xmin, double xmax); 640{; 641 if (!pntsx || !pntsy || !npoints); 642 return false;; 643 ; 644 if (!fMinimizer) {; 645 MATH_ERROR_MSG(""FitResult::Scan"", ""Minimizer is not available - cannot Scan"");; 646 return false;; 647 }; 648 ; 649 return fMinimizer->Scan(ipar, npoints, pntsx, pntsy, xmin, xmax);; 650}; 651 ; 652////////////////////////////////////////////////////////////////////////////////; 653/// Create a 2D contour around the minimum for the parameter ipar and jpar; 654/// if a minimum does not exist or is invalid it will return false; 655/// A array for x and y points should be provided; 656/// Pass optionally the confidence level, default is 0.683; 657/// it is assumed that ErrorDef() defines the right error definition; 658/// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level; 659 ; 660bool FitResult::Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel); 661{; 662 if (!pntsx || !pntsy || !npoints); 663 return false;; 664 ; 665 if (!fMinimizer) {; 666 MATH_ERROR_MSG(""FitResult::Contour"", ""Minimizer is not available - cannot produce Contour"");; 667 return false;; 668 }; 669 ; 670 // get error level used for fitting; 671 double upScale = fMinimizer->ErrorDef();; 672 ; 673 double upVal = TMath::ChisquareQuantile(confLevel, 2); // 2 is number of parameter we do the contour; 674 ; 675 // set required error definition in minimizer; 676 fMinimizer->SetErrorDef(upScale * upVal);; 677 ; 678 bool ret = fMinimizer->Contour(ipar, jpar, npoints, pntsx, pntsy);; 679 ; 680 // restore the error level used for fitting; 681 fMinimizer->SetErrorDef(upScale);; 682 ; 683 return ret;; 684}; 685 ; 686 } // end namespace Fit; 687 ; 688} // end namesp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8cxx_source.html:24400,error,error,24400,doc/master/FitResult_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html,1,['error'],['error']
Availability,"//////////; 1501/// Get low error on y coordinate for point `i`.; 1502/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1503 ; 1504Double_t TGraphMultiErrors::GetErrorYlow(Int_t i) const; 1505{; 1506 if (i < 0 || i >= fNpoints || fEyL.empty()); 1507 return -1.;; 1508 ; 1509 if (fSumErrorsMode == TGraphMultiErrors::kOnlyFirst); 1510 return fEyL[0][i];; 1511 else if (fSumErrorsMode == TGraphMultiErrors::kSquareSum) {; 1512 Double_t sum = 0.;; 1513 for (Int_t j = 0; j < fNYErrors; j++); 1514 sum += fEyL[j][i] * fEyL[j][i];; 1515 return TMath::Sqrt(sum);; 1516 } else if (fSumErrorsMode == TGraphMultiErrors::kAbsSum) {; 1517 Double_t sum = 0.;; 1518 for (Int_t j = 0; j < fNYErrors; j++); 1519 sum += fEyL[j][i];; 1520 return sum;; 1521 }; 1522 ; 1523 return -1.;; 1524}; 1525 ; 1526////////////////////////////////////////////////////////////////////////////////; 1527/// Get high error on y coordinate for point `i`.; 1528/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1529 ; 1530Double_t TGraphMultiErrors::GetErrorYhigh(Int_t i) const; 1531{; 1532 if (i < 0 || i >= fNpoints || fEyH.empty()); 1533 return -1.;; 1534 ; 1535 if (fSumErrorsMode == TGraphMultiErrors::kOnlyFirst); 1536 return fEyH[0][i];; 1537 else if (fSumErrorsMode == TGraphMultiErrors::kSquareSum) {; 1538 Double_t sum = 0.;; 1539 for (Int_t j = 0; j < fNYErrors; j++); 1540 sum += fEyH[j][i] * fEyH[j][i];; 1541 return TMath::Sqrt(sum);; 1542 } else if (fSumErrorsMode == TGraphMultiErrors::kAbsSum) {; 1543 Double_t sum = 0.;; 1544 for (Int_t j = 0; j < fNYErrors; j++); 1545 sum += fEyH[j][i];; 1546 return sum;; 1547 }; 1548 ; 1549 return -1.;; 1550}; 1551 ; 1552////////////////////////////////////////////////////////////////////////////////; 1553/// Get low error e on y coordinate for point `i`.; 1554 ; 1555Double_t TGraphMultiErrors::GetErrorYlow(Int_t i, Int_t e) const; 1556{; 1557 if (i < 0 || i >= fNpoints || e >= fNYErrors || fEyL.empty()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:52340,error,errors,52340,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"//////////; 2245/// To list all objects of the application.; 2246/// Loop on all objects created in the ROOT linked lists.; 2247/// Objects may be files and windows or any other object directly; 2248/// attached to the ROOT linked list.; 2249 ; 2250void TROOT::ls(Option_t *option) const; 2251{; 2252// TObject::SetDirLevel();; 2253// GetList()->R__FOR_EACH(TObject,ls)(option);; 2254 TDirectory::ls(option);; 2255}; 2256 ; 2257////////////////////////////////////////////////////////////////////////////////; 2258/// Load a macro in the interpreter's memory. Equivalent to the command line; 2259/// command "".L filename"". If the filename has ""+"" or ""++"" appended; 2260/// the macro will be compiled by ACLiC. The filename must have the format:; 2261/// [path/]macro.C[+|++[g|O]].; 2262/// The possible error codes are defined by TInterpreter::EErrorCode.; 2263/// If check is true it will only check if filename exists and is; 2264/// readable.; 2265/// Returns 0 on successful loading and -1 in case filename does not; 2266/// exist or in case of error.; 2267 ; 2268Int_t TROOT::LoadMacro(const char *filename, int *error, Bool_t check); 2269{; 2270 Int_t err = -1;; 2271 Int_t lerr, *terr;; 2272 if (error); 2273 terr = error;; 2274 else; 2275 terr = &lerr;; 2276 ; 2277 if (fInterpreter) {; 2278 TString aclicMode;; 2279 TString arguments;; 2280 TString io;; 2281 TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);; 2282 ; 2283 if (arguments.Length()) {; 2284 Warning(""LoadMacro"", ""argument(%s) ignored in %s"", arguments.Data(), GetMacroPath());; 2285 }; 2286 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2287 if (!mac) {; 2288 if (!check); 2289 Error(""LoadMacro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2290 *terr = TInterpreter::kFatal;; 2291 } else {; 2292 err = 0;; 2293 if (!check) {; 2294 fname = mac;; 2295 fname += aclicMode;; 2296 fname += io;; 2297 gInterpreter->LoadMacro(fname.Data(), (TInterpreter::EErrorCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:86631,error,error,86631,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['error'],['error']
Availability,"/////////; 702/// Return bin entries of a Profile3D histogram.; 703 ; 704Double_t TProfile3D::GetBinEntries(Int_t bin) const; 705{; 706 if (fBuffer) ((TProfile3D*)this)->BufferEmpty();; 707 ; 708 if (bin < 0 || bin >= fNcells) return 0;; 709 return fBinEntries.fArray[bin];; 710}; 711 ; 712////////////////////////////////////////////////////////////////////////////////; 713/// Return bin effective entries for a weighted filled Profile histogram.; 714///; 715/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 716/// The effective entries is defined as the square of the sum of the weights divided by the; 717/// sum of the weights square.; 718/// TProfile::Sumw2() must be called before filling the profile with weights.; 719/// Only by calling this method the sum of the square of the weights per bin is stored.; 720 ; 721Double_t TProfile3D::GetBinEffectiveEntries(Int_t bin); 722{; 723 return TProfileHelper::GetBinEffectiveEntries((TProfile3D*)this, bin);; 724}; 725 ; 726////////////////////////////////////////////////////////////////////////////////; 727/// Return bin error of a Profile3D histogram.; 728///; 729/// ### Computing errors: A moving field; 730///; 731/// The computation of errors for a TProfile3D has evolved with the versions; 732/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 733///; 734/// - prior to version 3.10, we had no special treatment of low statistic bins.; 735/// As a result, these bins had huge errors. The reason is that the; 736/// expression eprim2 is very close to 0 (rounding problems) or 0.; 737/// - The algorithm is modified/protected for the case; 738/// when a TProfile3D is projected (ProjectionX). The previous algorithm; 739/// generated a N^2 problem when projecting a TProfile3D with a large number of; 740/// bins (eg 100000).; 741/// - in version 3.10/02, a new static function TProfile::Approximate; 742/// is introduced to enable or disable (default) the approximation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:25112,error,error,25112,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,1,['error'],['error']
Availability,"/////////; 829/// Returns the content of the input bin; 830/// Bin numbers are from [1,nbins] and; 831/// for the overflow/underflow/sea bins the range is [-9,-1]:; 832///~~~ {.cpp}; 833/// -1 | -2 | -3; 834/// ---+----+----; 835/// -4 | -5 | -6; 836/// ---+----+----; 837/// -7 | -8 | -9; 838///~~~; 839/// where -5 is the ""sea"" bin (i.e. unbinned areas); 840 ; 841Double_t TH2Poly::GetBinContent(Int_t bin) const; 842{; 843 if (bin > GetNumberOfBins() || bin == 0 || bin < -kNOverflow) return 0;; 844 if (bin<0) return fOverflow[-bin - 1];; 845 return ((TH2PolyBin*) fBins->At(bin-1))->GetContent();; 846}; 847 ; 848////////////////////////////////////////////////////////////////////////////////; 849/// Returns the value of error associated to bin number bin.; 850/// If the sum of squares of weights has been defined (via Sumw2),; 851/// this function returns the sqrt(sum of w2).; 852/// otherwise it returns the sqrt(contents) for this bin.; 853/// Bins are in range [1:nbins] and for bin < 0 in range [-9:-1] it returns errors for overflow bins.; 854/// See also TH2Poly::GetBinContent; 855 ; 856Double_t TH2Poly::GetBinError(Int_t bin) const; 857{; 858 if (bin == 0 || bin > GetNumberOfBins() || bin < - kNOverflow) return 0;; 859 if (fBuffer) ((TH1*)this)->BufferEmpty();; 860 // in case of weighted events the sum of the weights are stored in a different way than; 861 // a normal histogram; 862 // fSumw2.fArray[0:kNOverflow-1] : sum of weight squares for the overflow bins (; 863 // fSumw2.fArray[kNOverflow:fNcells] : sum of weight squares for the standard bins; 864 // fNcells = kNOverflow (9) + Number of bins; 865 if (fSumw2.fN) {; 866 Int_t binIndex = (bin > 0) ? bin+kNOverflow-1 : -(bin+1);; 867 Double_t err2 = fSumw2.fArray[binIndex];; 868 return TMath::Sqrt(err2);; 869 }; 870 Double_t error2 = TMath::Abs(GetBinContent(bin));; 871 return TMath::Sqrt(error2);; 872}; 873 ; 874////////////////////////////////////////////////////////////////////////////////; 875/// Return the n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8cxx_source.html:30285,error,errors,30285,doc/master/TH2Poly_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html,1,['error'],['errors']
Availability,"////////; 375/// static: set name of default fft; 376 ; 377void TVirtualFFT::SetDefaultFFT(const char *name); 378{; 379 if (fgDefault == name) return;; 380 delete fgFFT;; 381 fgFFT = nullptr;; 382 fgDefault = name;; 383}; h#define h(i)Definition RSha256.hxx:106; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; TPluginManager.h; TROOT.h; gROOTMutexR__EXTERN TVirtualMutex * gROOTMutexDefinition TROOT.h:63; gROOT#define gROOTDefinition TROOT.h:406; TVirtualFFT.h; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPluginHandlerDefinition TPluginManager.h:103; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms.Definition TVirtualFFT.h:88; TVirtualFFT::~TVirtualFFTvirtual ~TVirtualFFT()destructorDefinition TVirtualFFT.cxx:96; TVirtualFFT::SetDefaultFFTstatic void SetDefaultFFT(const char *name="""")static: set name of default fftDefinition TVirtualFFT.cxx:377; TVirtualFFT::SetTransformstatic void SetTransform(TVirtualFFT *fft)static: set the current transfrom to parameterDefinition TVirtualFFT.cxx:361; TVirtualFFT::Initvirtual void Init(Option_t *flag, Int_t sign, const In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:14462,error,error,14462,doc/master/TVirtualFFT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html,1,['error'],['error']
Availability,"///////; 1882/// Get number of types.; 1883 ; 1884Int_t TROOT::GetNtypes() const; 1885{; 1886 return fTypes->GetSize();; 1887}; 1888 ; 1889////////////////////////////////////////////////////////////////////////////////; 1890/// Execute command when system has been idle for idleTimeInSec seconds.; 1891 ; 1892void TROOT::Idle(UInt_t idleTimeInSec, const char *command); 1893{; 1894 if (!fApplication.load()); 1895 TApplication::CreateApplication();; 1896 ; 1897 if (idleTimeInSec <= 0); 1898 (*fApplication).RemoveIdleTimer();; 1899 else; 1900 (*fApplication).SetIdleTimer(idleTimeInSec, command);; 1901}; 1902 ; 1903////////////////////////////////////////////////////////////////////////////////; 1904/// Check whether className is a known class, and only autoload; 1905/// if we can. Helper function for TROOT::IgnoreInclude().; 1906 ; 1907static TClass* R__GetClassIfKnown(const char* className); 1908{; 1909 // Check whether the class is available for auto-loading first:; 1910 const char* libsToLoad = gInterpreter->GetClassSharedLibs(className);; 1911 TClass* cla = nullptr;; 1912 if (libsToLoad) {; 1913 // trigger autoload, and only create TClass in this case.; 1914 return TClass::GetClass(className);; 1915 } else if (gROOT->GetListOfClasses(); 1916 && (cla = (TClass*)gROOT->GetListOfClasses()->FindObject(className))) {; 1917 // cla assigned in if statement; 1918 } else if (gClassTable->FindObject(className)) {; 1919 return TClass::GetClass(className);; 1920 }; 1921 return cla;; 1922}; 1923 ; 1924////////////////////////////////////////////////////////////////////////////////; 1925/// Return 1 if the name of the given include file corresponds to a class that; 1926/// is known to ROOT, e.g. ""TLorentzVector.h"" versus TLorentzVector.; 1927 ; 1928Int_t TROOT::IgnoreInclude(const char *fname, const char * /*expandedfname*/); 1929{; 1930 if (fname == nullptr) return 0;; 1931 ; 1932 TString stem(fname);; 1933 // Remove extension if any, ignore files with extension not being .h*; 19",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:73351,avail,available,73351,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['avail'],['available']
Availability,"///////; 2425/// Send a buffer headed by a length indicator.; 2426 ; 2427int TSystem::SendBuf(int, const void *, int); 2428{; 2429 AbstractMethod(""SendBuf"");; 2430 return -1;; 2431}; 2432 ; 2433////////////////////////////////////////////////////////////////////////////////; 2434/// Set socket option.; 2435 ; 2436int TSystem::SetSockOpt(int, int, int); 2437{; 2438 AbstractMethod(""SetSockOpt"");; 2439 return -1;; 2440}; 2441 ; 2442////////////////////////////////////////////////////////////////////////////////; 2443/// Get socket option.; 2444 ; 2445int TSystem::GetSockOpt(int, int, int*); 2446{; 2447 AbstractMethod(""GetSockOpt"");; 2448 return -1;; 2449}; 2450 ; 2451//---- System, CPU and Memory info ---------------------------------------------; 2452 ; 2453////////////////////////////////////////////////////////////////////////////////; 2454/// Returns static system info, like OS type, CPU type, number of CPUs; 2455/// RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 2456/// 0 otherwise.; 2457 ; 2458int TSystem::GetSysInfo(SysInfo_t *) const; 2459{; 2460 AbstractMethod(""GetSysInfo"");; 2461 return -1;; 2462}; 2463 ; 2464////////////////////////////////////////////////////////////////////////////////; 2465/// Returns cpu load average and load info into the CpuInfo_t structure.; 2466/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 2467/// interval over which the CPU load will be measured, in ms (default 1000).; 2468 ; 2469int TSystem::GetCpuInfo(CpuInfo_t *, Int_t) const; 2470{; 2471 AbstractMethod(""GetCpuInfo"");; 2472 return -1;; 2473}; 2474 ; 2475////////////////////////////////////////////////////////////////////////////////; 2476/// Returns ram and swap memory usage info into the MemInfo_t structure.; 2477/// Returns -1 in case of error, 0 otherwise.; 2478 ; 2479int TSystem::GetMemInfo(MemInfo_t *) const; 2480{; 2481 AbstractMethod(""GetMemInfo"");; 2482 return -1;; 2483}; 2484 ; 2485/////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:79159,error,error,79159,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['error'],['error']
Availability,"//////; 1059/// Recursive method to fill full path for directory.; 1060 ; 1061void TDirectory::FillFullPath(TString& buf) const; 1062{; 1063 TDirectory* mom = GetMotherDir();; 1064 if (mom) {; 1065 mom->FillFullPath(buf);; 1066 buf += ""/"";; 1067 buf += GetName();; 1068 } else {; 1069 buf = GetName();; 1070 buf += "":"";; 1071 }; 1072}; 1073 ; 1074////////////////////////////////////////////////////////////////////////////////; 1075/// Create a sub-directory ""a"" or a hierarchy of sub-directories ""a/b/c/..."".; 1076///; 1077/// Returns 0 in case of error or if a sub-directory (hierarchy) with the requested; 1078/// name already exists.; 1079/// returnExistingDirectory returns a pointer to an already existing sub-directory with the same name.; 1080/// Returns a pointer to the created sub-directory or to the top sub-directory of; 1081/// the hierarchy (in the above example, the returned TDirectory * always points; 1082/// to ""a"").; 1083/// In particular, the steps to create first a/b/c and then a/b/d without receiving; 1084/// errors are:; 1085/// ~~~ {.cpp}; 1086/// TFile * file = new TFile(""afile"",""RECREATE"");; 1087/// file->mkdir(""a"");; 1088/// file->cd(""a"");; 1089/// gDirectory->mkdir(""b/c"");; 1090/// gDirectory->cd(""b"");; 1091/// gDirectory->mkdir(""d"");; 1092/// ~~~; 1093/// or; 1094/// ~~~ {.cpp}; 1095/// TFile * file = new TFile(""afile"",""RECREATE"");; 1096/// file->mkdir(""a"");; 1097/// file->cd(""a"");; 1098/// gDirectory->mkdir(""b/c"");; 1099/// gDirectory->mkdir(""b/d"", """", true);; 1100/// ~~~; 1101 ; 1102TDirectory *TDirectory::mkdir(const char *name, const char *title, Bool_t returnExistingDirectory); 1103{; 1104 if (returnExistingDirectory) {; 1105 auto existingdir = GetDirectory(name);; 1106 if (existingdir); 1107 return existingdir;; 1108 }; 1109 if (!name || !title || !name[0]) return nullptr;; 1110 if (!title[0]) title = name;; 1111 if (const char *slash = strchr(name,'/')) {; 1112 Long_t size = Long_t(slash-name);; 1113 char *workname = new char[size+1];; 1114 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:37734,error,errors,37734,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,1,['error'],['errors']
Availability,"//////; 1182/// Get low error on Y.; 1183 ; 1184Double_t TGraphAsymmErrors::GetErrorYlow(Int_t i) const; 1185{; 1186 if (i<0 || i>fNpoints) return -1;; 1187 if (fEYlow) return fEYlow[i];; 1188 return -1;; 1189}; 1190 ; 1191 ; 1192////////////////////////////////////////////////////////////////////////////////; 1193/// Adds all graphs with asymmetric errors from the collection to this graph.; 1194/// Returns the total number of points in the result or -1 in case of an error.; 1195 ; 1196Int_t TGraphAsymmErrors::Merge(TCollection* li); 1197{; 1198 TIter next(li);; 1199 while (TObject* o = next()) {; 1200 TGraph *g = dynamic_cast<TGraph*>(o);; 1201 if (!g) {; 1202 Error(""Merge"",; 1203 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 1204 return -1;; 1205 }; 1206 int n0 = GetN();; 1207 int n1 = n0+g->GetN();; 1208 Set(n1);; 1209 Double_t * x = g->GetX();; 1210 Double_t * y = g->GetY();; 1211 Double_t * exlow = g->GetEXlow();; 1212 Double_t * exhigh = g->GetEXhigh();; 1213 Double_t * eylow = g->GetEYlow();; 1214 Double_t * eyhigh = g->GetEYhigh();; 1215 for (Int_t i = 0 ; i < g->GetN(); i++) {; 1216 SetPoint(n0+i, x[i], y[i]);; 1217 if (exlow) fEXlow[n0+i] = exlow[i];; 1218 if (exhigh) fEXhigh[n0+i] = exhigh[i];; 1219 if (eylow) fEYlow[n0+i] = eylow[i];; 1220 if (eyhigh) fEYhigh[n0+i] = eyhigh[i];; 1221 }; 1222 }; 1223 return GetN();; 1224}; 1225 ; 1226////////////////////////////////////////////////////////////////////////////////; 1227/// Print graph and errors values.; 1228 ; 1229void TGraphAsymmErrors::Print(Option_t *) const; 1230{; 1231 for (Int_t i=0;i<fNpoints;i++) {; 1232 printf(""x[%d]=%g, y[%d]=%g, exl[%d]=%g, exh[%d]=%g, eyl[%d]=%g, eyh[%d]=%g\n""; 1233 ,i,fX[i],i,fY[i],i,fEXlow[i],i,fEXhigh[i],i,fEYlow[i],i,fEYhigh[i]);; 1234 }; 1235}; 1236 ; 1237 ; 1238////////////////////////////////////////////////////////////////////////////////; 1239/// Save primitive as a C++ statement(s) on output stream out.; 1240 ; 1241void TGraphAsymmE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:42352,error,errors,42352,doc/master/TGraphAsymmErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html,1,['error'],['errors']
Availability,"//////; 1980/// Set error e eyL values.; 1981 ; 1982void TGraphMultiErrors::SetEYlow(Int_t e, Int_t np, const Double_t *eyL); 1983{; 1984 for (Int_t i = 0; i < fNpoints; i++) {; 1985 if (i < np); 1986 SetPointEYlow(i, e, eyL[i]);; 1987 else; 1988 SetPointEYlow(i, e, 0.);; 1989 }; 1990}; 1991 ; 1992////////////////////////////////////////////////////////////////////////////////; 1993/// Set error e eyH values.; 1994 ; 1995void TGraphMultiErrors::SetEYhigh(Int_t e, Int_t np, const Double_t *eyH); 1996{; 1997 for (Int_t i = 0; i < fNpoints; i++) {; 1998 if (i < np); 1999 SetPointEYhigh(i, e, eyH[i]);; 2000 else; 2001 SetPointEYhigh(i, e, 0.);; 2002 }; 2003}; 2004 ; 2005////////////////////////////////////////////////////////////////////////////////; 2006/// Set the sum errors mode and recalculate summed errors.; 2007void TGraphMultiErrors::SetSumErrorsMode(Int_t m); 2008{; 2009 if (fSumErrorsMode == m); 2010 return;; 2011 fSumErrorsMode = m;; 2012 CalcYErrorsSum();; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).; 2017 ; 2018void TGraphMultiErrors::SetAttFill(Int_t e, TAttFill *taf); 2019{; 2020 if (e == -1); 2021 taf->TAttFill::Copy(*this);; 2022 else if (e >= 0 && e < fNYErrors); 2023 taf->TAttFill::Copy(fAttFill[e]);; 2024}; 2025 ; 2026////////////////////////////////////////////////////////////////////////////////; 2027/// Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).; 2028 ; 2029void TGraphMultiErrors::SetAttLine(Int_t e, TAttLine *taf); 2030{; 2031 if (e == -1); 2032 taf->TAttLine::Copy(*this);; 2033 else if (e >= 0 && e < fNYErrors); 2034 taf->TAttLine::Copy(fAttLine[e]);; 2035}; 2036 ; 2037////////////////////////////////////////////////////////////////////////////////; 2038/// Set Fill Color of error e (-1 = Global and x errors).; 2039 ; 2040void TGraphMulti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:67759,error,error,67759,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"//////; 4645/// Search for an object at pixel position px,py.; 4646///; 4647/// Check if point is in this pad.; 4648///; 4649/// If yes, check if it is in one of the sub-pads; 4650///; 4651/// If found in the pad, compute closest distance of approach; 4652/// to each primitive.; 4653///; 4654/// If one distance of approach is found to be within the limit Distancemaximum; 4655/// the corresponding primitive is selected and the routine returns.; 4656 ; 4657TPad *TPad::Pick(Int_t px, Int_t py, TObjLink *&pickobj); 4658{; 4659 //the two following statements are necessary under NT (multithreaded); 4660 //when a TCanvas object is being created and a thread calling TPad::Pick; 4661 //before the TPad constructor has completed in the other thread; 4662 if (!gPad) return nullptr; //Andy Haas; 4663 if (!GetListOfPrimitives()) return nullptr; //Andy Haas; 4664 ; 4665 Int_t dist;; 4666 // Search if point is in pad itself; 4667 Double_t x = AbsPixeltoX(px);; 4668 Double_t y = AbsPixeltoY(py);; 4669 if (this != gPad->GetCanvas()) {; 4670 if (!((x >= fX1 && x <= fX2) && (y >= fY1 && y <= fY2))) return nullptr;; 4671 }; 4672 ; 4673 // search for a primitive in this pad or its sub-pads; 4674 static TObjOptLink dummyLink(nullptr,""""); //place holder for when no link available; 4675 ; 4676 TContext ctxt(this, kFALSE); // since no drawing will be done, don't use cd() for efficiency reasons; 4677 ; 4678 TPad *pick = nullptr;; 4679 TPad *picked = this;; 4680 pickobj = nullptr;; 4681 if (DistancetoPrimitive(px,py) < fgMaxPickDistance) {; 4682 dummyLink.SetObject(this);; 4683 pickobj = &dummyLink;; 4684 }; 4685 ; 4686 // Loop backwards over the list of primitives. The first non-pad primitive; 4687 // found is the selected one. However, we have to keep going down the; 4688 // list to see if there is maybe a pad overlaying the primitive. In that; 4689 // case look into the pad for a possible primitive. Once a pad has been; 4690 // found we can terminate the loop.; 4691 Bool_t gotPrim = kFALSE;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:148579,avail,available,148579,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['avail'],['available']
Availability,"/////; 1070/// Replace contents of this histogram by the addition of h1 and h2.; 1071///; 1072/// `this = c1*h1 + c2*h2`; 1073/// if errors are defined (see TH1::Sumw2), errors are also recalculated; 1074///; 1075/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 1076/// if not already set.; 1077///; 1078/// Note also that adding histogram with labels is not supported, histogram will be; 1079/// added merging them by bin number independently of the labels.; 1080/// For adding histogram ith labels one should use TH1::Merge; 1081///; 1082/// SPECIAL CASE (Average/Efficiency histograms); 1083/// For histograms representing averages or efficiencies, one should compute the average; 1084/// of the two histograms and not the sum. One can mark a histogram to be an average; 1085/// histogram by setting its bit kIsAverage with; 1086/// myhist.SetBit(TH1::kIsAverage);; 1087/// Note that the two histograms must have their kIsAverage bit set; 1088///; 1089/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 1090/// you should call Sumw2 before making this operation.; 1091/// This is particularly important if you fit the histogram after TH1::Add; 1092///; 1093/// IMPORTANT NOTE2: You should be careful about the statistics of the; 1094/// returned histogram, whose statistics may be binned or unbinned,; 1095/// depending on whether c1 is negative, whether TAxis::kAxisRange is true,; 1096/// and whether TH1::ResetStats has been called on either this or h1.; 1097/// See TH1::GetStats.; 1098///; 1099/// ANOTHER SPECIAL CASE : h1 = h2 and c2 < 0; 1100/// do a scaling this = c1 * h1 / (bin Volume); 1101///; 1102/// The function returns kFALSE if the Add operation failed; 1103 ; 1104Bool_t TH1::Add(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2); 1105{; 1106 ; 1107 if (!h1 || !h2) {; 1108 Error(""Add"",""Attempt to add a non-existing histogram"");; 1109 return kFALSE;; 1110 }; 1111 ; 1112 // delete buffer if it is there since it ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:43530,error,errors,43530,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"/////; 2680/// Static function creating a color table with several connected linear gradients.; 2681///; 2682/// - Number: The number of end point colors that will form the gradients.; 2683/// Must be at least 2.; 2684/// - Stops: Where in the whole table the end point colors should lie.; 2685/// Each entry must be on [0, 1], each entry must be greater than; 2686/// the previous entry.; 2687/// - Red, Green, Blue: The end point color values.; 2688/// Each entry must be on [0, 1]; 2689/// - NColors: Total number of colors in the table. Must be at least 1.; 2690/// - alpha: the opacity factor, between 0 and 1. Default is no transparency (1).; 2691/// - setPalette: activate the newly created palette (true by default). If false,; 2692/// the caller is in charge of calling TColor::SetPalette using the; 2693/// return value of the function (first palette color index) and; 2694/// reconstructing the Int_t palette[NColors+1] array.; 2695///; 2696/// Returns a positive value (the index of the first color of the palette) on; 2697/// success and -1 on error.; 2698///; 2699/// The table is constructed by tracing lines between the given points in; 2700/// RGB space. Each color value may have a value between 0 and 1. The; 2701/// difference between consecutive ""Stops"" values gives the fraction of; 2702/// space in the whole table that should be used for the interval between; 2703/// the corresponding color values.; 2704///; 2705/// Normally the first element of Stops should be 0 and the last should be 1.; 2706/// If this is not true, fewer than NColors will be used in proportion with; 2707/// the total interval between the first and last elements of Stops.; 2708///; 2709/// This definition is similar to the povray-definition of gradient; 2710/// color tables.; 2711///; 2712/// For instance:; 2713/// ~~~ {.cpp}; 2714/// UInt_t Number = 3;; 2715/// Double_t Red[3] = { 0.0, 1.0, 1.0 };; 2716/// Double_t Green[3] = { 0.0, 0.0, 1.0 };; 2717/// Double_t Blue[3] = { 1.0, 0.0, 1.0 };; 27",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:98251,error,error,98251,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['error'],['error']
Availability,"////; 1842/// Rebin only the Y axis.; 1843/// see Rebin2D; 1844 ; 1845TProfile2D * TProfile2D::RebinY(Int_t ngroup,const char * newname ) {; 1846 return Rebin2D(1,ngroup,newname);; 1847}; 1848 ; 1849////////////////////////////////////////////////////////////////////////////////; 1850/// Save primitive as a C++ statement(s) on output stream out.; 1851///; 1852/// Note the following restrictions in the code generated:; 1853/// - variable bin size not implemented; 1854/// - SetErrorOption not implemented; 1855 ; 1856void TProfile2D::SavePrimitive(std::ostream &out, Option_t *option /*= """"*/); 1857{; 1858 char quote = '""';; 1859 out <<"" ""<<std::endl;; 1860 out <<"" ""<<ClassName()<<"" *"";; 1861 ; 1862 out << GetName() << "" = new "" << ClassName() << ""("" << quote; 1863 << GetName() << quote << "","" << quote<< GetTitle() << quote; 1864 << "","" << GetXaxis()->GetNbins();; 1865 out << "","" << GetXaxis()->GetXmin(); 1866 << "","" << GetXaxis()->GetXmax();; 1867 out << "","" << GetYaxis()->GetNbins();; 1868 out << "","" << GetYaxis()->GetXmin(); 1869 << "","" << GetYaxis()->GetXmax();; 1870 out << "","" << fZmin; 1871 << "","" << fZmax;; 1872 out << "");"" << std::endl;; 1873 ; 1874 ; 1875 // save bin entries; 1876 Int_t bin;; 1877 for (bin=0;bin<fNcells;bin++) {; 1878 Double_t bi = GetBinEntries(bin);; 1879 if (bi) {; 1880 out<<"" ""<<GetName()<<""->SetBinEntries(""<<bin<<"",""<<bi<<"");""<<std::endl;; 1881 }; 1882 }; 1883 //save bin contents; 1884 for (bin=0;bin<fNcells;bin++) {; 1885 Double_t bc = fArray[bin];; 1886 if (bc) {; 1887 out<<"" ""<<GetName()<<""->SetBinContent(""<<bin<<"",""<<bc<<"");""<<std::endl;; 1888 }; 1889 }; 1890 // save bin errors; 1891 if (fSumw2.fN) {; 1892 for (bin=0;bin<fNcells;bin++) {; 1893 Double_t be = TMath::Sqrt(fSumw2.fArray[bin]);; 1894 if (be) {; 1895 out<<"" ""<<GetName()<<""->SetBinError(""<<bin<<"",""<<be<<"");""<<std::endl;; 1896 }; 1897 }; 1898 }; 1899 ; 1900 TH1::SavePrimitiveHelp(out, GetName(), option);; 1901}; 1902 ; 1903//////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:68981,error,errors,68981,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,1,['error'],['errors']
Availability,"////; 257class TProcessEventTimer : public TTimer {; 258public:; 259 TProcessEventTimer(Long_t delay);; 260 Bool_t Notify() override { return kTRUE; }; 261 Bool_t ProcessEvents();; 262 ClassDefOverride(TProcessEventTimer,0) // Process pending events at fixed time intervals; 263};; 264 ; 265 ; 266class TSystem : public TNamed {; 267 ; 268public:; 269 enum EAclicMode { kDefault, kDebug, kOpt };; 270 enum EAclicProperties {; 271 kFlatBuildDir = BIT(0) // If set and a BuildDir is selected, then do not created sub-directories; 272 };; 273 ; 274protected:; 275 TFdSet *fReadmask{nullptr}; //!Files that should be checked for read events; 276 TFdSet *fWritemask{nullptr}; //!Files that should be checked for write events; 277 TFdSet *fReadready{nullptr}; //!Files with reads waiting; 278 TFdSet *fWriteready{nullptr}; //!Files with writes waiting; 279 TFdSet *fSignals{nullptr}; //!Signals that were trapped; 280 Int_t fNfd{0}; //Number of fd's in masks; 281 Int_t fMaxrfd{-1}; //Largest fd in read mask; 282 Int_t fMaxwfd{-1}; //Largest fd in write mask; 283 Int_t fSigcnt{0}; //Number of pending signals; 284 TString fWdpath; //Working directory; 285 TString fHostname; //Hostname; 286 std::atomic<Bool_t> fInsideNotify{kFALSE}; //Used by DispatchTimers(); 287 Int_t fBeepFreq{0}; //Used by Beep(); 288 Int_t fBeepDuration{0}; //Used by Beep(); 289 ; 290 Bool_t fInControl{kFALSE}; //True if in eventloop; 291 Bool_t fDone{kFALSE}; //True if eventloop should be finished; 292 Int_t fLevel{0}; //Level of nested eventloops; 293 ; 294 TList *fTimers{nullptr}; //List of timers; 295 TSeqCollection *fSignalHandler{nullptr}; //List of signal handlers; 296 TSeqCollection *fFileHandler{nullptr}; //List of file handlers; 297 TSeqCollection *fStdExceptionHandler{nullptr}; //List of std::exception handlers; 298 TSeqCollection *fOnExitList{nullptr}; //List of items to be cleaned-up on exit; 299 ; 300 TString fListLibs; //List shared libraries, cache used by GetLibraries; 301 ; 302 TString fBuildArch; //",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:10644,mask,mask,10644,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['mask'],['mask']
Availability,"////; 7582/// Enable/Disable the Autoparsing of headers.; 7583/// Returns the old value, i.e whether it was enabled or not.; 7584 ; 7585int TCling::SetClassAutoparsing(int autoparse); 7586{; 7587 bool oldVal = fHeaderParsingOnDemand;; 7588 fHeaderParsingOnDemand = autoparse;; 7589 return oldVal;; 7590}; 7591 ; 7592////////////////////////////////////////////////////////////////////////////////; 7593/// Suspend the Autoparsing of headers.; 7594/// Returns the old value, i.e whether it was suspended or not.; 7595 ; 7596Bool_t TCling::SetSuspendAutoParsing(Bool_t value) {; 7597 Bool_t old = fIsAutoParsingSuspended;; 7598 fIsAutoParsingSuspended = value;; 7599 if (fClingCallbacks) fClingCallbacks->SetAutoParsingSuspended(value);; 7600 return old;; 7601}; 7602 ; 7603////////////////////////////////////////////////////////////////////////////////; 7604/// Set a callback to receive error messages.; 7605 ; 7606void TCling::SetErrmsgcallback(void* p) const; 7607{; 7608#if defined(R__MUST_REVISIT); 7609#if R__MUST_REVISIT(6,2); 7610 Warning(""SetErrmsgcallback"", ""Interface not available yet."");; 7611#endif; 7612#endif; 7613}; 7614 ; 7615void TCling::ReportDiagnosticsToErrorHandler(bool enable); 7616{; 7617 if (enable) {; 7618 auto consumer = new TClingDelegateDiagnosticPrinter(; 7619 &fInterpreter->getDiagnostics().getDiagnosticOptions(),; 7620 fInterpreter->getCI()->getLangOpts(),; 7621 [] (clang::DiagnosticsEngine::Level Level, const std::string &Info) {; 7622 if (Level == clang::DiagnosticsEngine::Warning) {; 7623 ::Warning(""cling"", ""%s"", Info.c_str());; 7624 } else if (Level == clang::DiagnosticsEngine::Error; 7625 || Level == clang::DiagnosticsEngine::Fatal) {; 7626 ::Error(""cling"", ""%s"", Info.c_str());; 7627 } else {; 7628 ::Info(""cling"", ""%s"", Info.c_str());; 7629 }; 7630 });; 7631 fInterpreter->replaceDiagnosticConsumer(consumer, /*Own=*/true);; 7632 } else {; 7633 fInterpreter->replaceDiagnosticConsumer(nullptr);; 7634 }; 7635}; 7636 ; 7637 ; 7638/////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:296914,avail,available,296914,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avail'],['available']
Availability,"///; 189/// Get the scatter's x axis.; 190 ; 191TAxis *TScatter::GetXaxis() const; 192{; 193 auto h = GetHistogram();; 194 return h ? h->GetXaxis() : nullptr;; 195}; 196 ; 197 ; 198////////////////////////////////////////////////////////////////////////////////; 199/// Get the scatter's y axis.; 200 ; 201TAxis *TScatter::GetYaxis() const; 202{; 203 auto h = GetHistogram();; 204 return h ? h->GetYaxis() : nullptr;; 205}; 206 ; 207 ; 208////////////////////////////////////////////////////////////////////////////////; 209/// Get the scatter's z axis.; 210 ; 211TAxis *TScatter::GetZaxis() const; 212{; 213 auto h = GetHistogram();; 214 return h ? h->GetZaxis() : nullptr;; 215}; 216 ; 217 ; 218////////////////////////////////////////////////////////////////////////////////; 219/// Paint this scatter plot with its current attributes.; 220 ; 221void TScatter::Paint(Option_t *option); 222{; 223 TVirtualGraphPainter *painter = TVirtualGraphPainter::GetPainter();; 224 if (painter) painter->PaintScatter(this, option);; 225}; 226 ; 227 ; 228////////////////////////////////////////////////////////////////////////////////; 229/// Print graph and errors values.; 230 ; 231void TScatter::Print(Option_t *) const; 232{; 233 Double_t *X = fGraph->GetX();; 234 Double_t *Y = fGraph->GetY();; 235 for (Int_t i = 0; i < fNpoints; i++) {; 236 printf(""x[%d]=%g, y[%d]=%g"", i, X[i], i, Y[i]);; 237 if (fColor) printf("", color[%d]=%g"", i, fColor[i]);; 238 if (fSize) printf("", size[%d]=%g"", i, fSize[i]);; 239 printf(""\n"");; 240 }; 241}; 242 ; 243 ; 244////////////////////////////////////////////////////////////////////////////////; 245/// Set the margin around the plot in %; 246 ; 247void TScatter::SetMargin(Double_t margin); 248{; 249 if (fMargin != margin) {; 250 delete fHistogram;; 251 fHistogram = nullptr;; 252 fMargin = margin;; 253 }; 254}; 255 ; 256 ; 257////////////////////////////////////////////////////////////////////////////////; 258/// Save primitive as a C++ statement(s) on output stre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TScatter_8cxx_source.html:7233,error,errors,7233,doc/master/TScatter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TScatter_8cxx_source.html,1,['error'],['errors']
Availability,"///; 2947/// `this = c1*h1/(c2*h2)`; 2948///; 2949/// If errors are defined (see TH1::Sumw2), errors are also recalculated; 2950/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 2951/// if not already set.; 2952/// The resulting errors are calculated assuming uncorrelated histograms.; 2953/// However, if option =""B"" is specified, Binomial errors are computed.; 2954/// In this case c1 and c2 do not make real sense and they are ignored.; 2955///; 2956/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2957/// you should call Sumw2 before making this operation.; 2958/// This is particularly important if you fit the histogram after TH1::Divide; 2959///; 2960/// Please note also that in the binomial case errors are calculated using standard; 2961/// binomial statistics, which means when b1 = b2, the error is zero.; 2962/// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; 2963/// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; 2964/// error for the case b1=b2.; 2965///; 2966/// The function return kFALSE if the divide operation failed; 2967 ; 2968Bool_t TH1::Divide(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2, Option_t *option); 2969{; 2970 ; 2971 TString opt = option;; 2972 opt.ToLower();; 2973 Bool_t binomial = kFALSE;; 2974 if (opt.Contains(""b"")) binomial = kTRUE;; 2975 if (!h1 || !h2) {; 2976 Error(""Divide"", ""At least one of the input histograms passed does not exist (NULL)."");; 2977 return kFALSE;; 2978 }; 2979 ; 2980 // delete buffer if it is there since it will become invalid; 2981 if (fBuffer) BufferEmpty(1);; 2982 ; 2983 if (LoggedInconsistency(""Divide"", this, h1) >= kDifferentNumberOfBins ||; 2984 LoggedInconsistency(""Divide"", h1, h2) >= kDifferentNumberOfBins) {; 2985 return false;; 2986 }; 2987 ; 2988 if (!c2) {; 2989 Error(""Divide"",""Coefficient of dividing histogram cannot be zero"");; 2990 return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:117483,error,errors,117483,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"//; /// Compute distance from point px,py to a function; ///; /// \param[in] px x position; /// \param[in] py y position; ///; /// Compute the closest distance of approach from point px,py to this function.; /// The distance is computed in pixels units.;  ; Int_t TF2::DistancetoPrimitive(Int_t px, Int_t py); {; ...; }; Free functions documentation; Doxygen does not document default parameters of free functions if the only doxygen documentation provided for the function is in source files (as opposed to header files). To bypass this issue it is enough to provide a brief documentation for such functions in the header file. For example if the source file is:; ////////////////////////////////////////////////////////////////////////////////; /// @param[in] numthreads Number of threads to use. If not specified or; /// set to zero, the number of threads is automatically; /// decided by the implementation. Any other value is; /// used as a hint.; ///; /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.;  ; [...];  ; void EnableImplicitMT(UInt_t numthreads); and the header file:; /// Enable ROOT's implicit multi-threading for all objects and methods that provide an internal; /// parallelisation mechanism.; void EnableImplicitMT(UInt_t numthreads = 0);; Then a proper documentation with the default parameters is generated.; Data Member documentation; IMPORTANT: It is crucial to use ""///<"" and only ""///<"" to comment data members: this comment is correctly understood by genreflex/rootcling. The usage of other Doxygen constructs can interfere with the I/O subsystem!; Double_t fMymember ///< My Member; Double_t fMyTransientMember ///<! My Member; The usage of ""//!"" will still result in transiency of members but not in Doxygen documentation.; Tutorials' documentation; ROOT tutorials are also included in the ROOT documentation. The tutorials'; macros headers should look like:; \file; \ingroup tutorial_hist; \notebook; Getting Contours From TH2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/formatting-comments-doxygen.html:4891,avail,available,4891,d/formatting-comments-doxygen.html,https://root.cern,https://root.cern/d/formatting-comments-doxygen.html,1,['avail'],['available']
Availability,"//; 402/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 403///; 404/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 405/// The multiple y-errors are passed as std::vectors of TArrayD objects.; 406 ; 407TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Double_t *x,; 408 const Double_t *y, const Double_t *exL, const Double_t *exH,; 409 std::vector<TArrayD> eyL, std::vector<TArrayD> eyH, Int_t m); 410 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 411{; 412 SetNameTitle(name, title);; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416/// Constructor with six vectors of floats in input and a single y error dimension.; 417/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 418/// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; 419/// and the errors from vectors `tvExL`, `tvExH` and `tvEyL`, `tvEyH`.; 420/// The number of points in the graph is the minimum of number of points; 421/// in `tvX` and `tvY`.; 422 ; 423TGraphMultiErrors::TGraphMultiErrors(const TVectorF &tvX, const TVectorF &tvY, const TVectorF &tvExL,; 424 const TVectorF &tvExH, const TVectorF &tvEyL, const TVectorF &tvEyH, Int_t m); 425 : fNYErrors(1), fSumErrorsMode(m); 426{; 427 fNpoints = TMath::Min(tvX.GetNrows(), tvY.GetNrows());; 428 ; 429 if (!TGraph::CtorAllocate()); 430 return;; 431 ; 432 if (!CtorAllocate()); 433 return;; 434 ; 435 Int_t itvXL = tvX.GetLwb();; 436 Int_t itvYL = tvY.GetLwb();; 437 Int_t itvExLL = tvExL.GetLwb();; 438 Int_t itvExHL = tvExH.GetLwb();; 439 Int_t itvEyLL = tvEyL.GetLwb();; 440 Int_t itvEyHL = tvEyH.GetLwb();; 441 ; 442 for (Int_t i = 0; i < fNpoints; i++) {; 443 fX[i] = tvX(itvXL + i);; 444 fY[i] = tvY(itvYL + i);; 445 fExL[i] = tvExL(itvExLL + i);; 446 fExH[i] = tvExH(itvExHL + i);; 447 fEyL[0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:15273,error,errors,15273,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"//reset only Integral, contents and Errors; 6533 ; 6534 int iaxis = 0;; 6535 if (axis == &fXaxis) iaxis = 1;; 6536 if (axis == &fYaxis) iaxis = 2;; 6537 if (axis == &fZaxis) iaxis = 3;; 6538 bool firstw = kTRUE;; 6539 Int_t binx,biny, binz = 0;; 6540 Int_t ix = 0,iy = 0,iz = 0;; 6541 Double_t bx,by,bz;; 6542 Int_t ncells = hold->GetNcells();; 6543 for (Int_t bin = 0; bin < ncells; ++bin) {; 6544 hold->GetBinXYZ(bin,binx,biny,binz);; 6545 bx = hold->GetXaxis()->GetBinCenter(binx);; 6546 ix = fXaxis.FindFixBin(bx);; 6547 if (fDimension > 1) {; 6548 by = hold->GetYaxis()->GetBinCenter(biny);; 6549 iy = fYaxis.FindFixBin(by);; 6550 if (fDimension > 2) {; 6551 bz = hold->GetZaxis()->GetBinCenter(binz);; 6552 iz = fZaxis.FindFixBin(bz);; 6553 }; 6554 }; 6555 // exclude underflow/overflow; 6556 double content = hold->RetrieveBinContent(bin);; 6557 if (content == 0) continue;; 6558 if (IsBinUnderflow(bin,iaxis) || IsBinOverflow(bin,iaxis) ) {; 6559 if (firstw) {; 6560 Warning(""ExtendAxis"",""Histogram %s has underflow or overflow in the axis that is extendable""; 6561 "" their content will be lost"",GetName() );; 6562 firstw= kFALSE;; 6563 }; 6564 continue;; 6565 }; 6566 Int_t ibin= GetBin(ix,iy,iz);; 6567 AddBinContent(ibin, content);; 6568 if (errors) {; 6569 fSumw2.fArray[ibin] += hold->GetBinErrorSqUnchecked(bin);; 6570 }; 6571 }; 6572 delete hold;; 6573}; 6574 ; 6575////////////////////////////////////////////////////////////////////////////////; 6576/// Recursively remove object from the list of functions; 6577 ; 6578void TH1::RecursiveRemove(TObject *obj); 6579{; 6580 // Rely on TROOT::RecursiveRemove to take the readlock.; 6581 ; 6582 if (fFunctions) {; 6583 if (!fFunctions->TestBit(kInvalidObject)) fFunctions->RecursiveRemove(obj);; 6584 }; 6585}; 6586 ; 6587////////////////////////////////////////////////////////////////////////////////; 6588/// Multiply this histogram by a constant c1.; 6589///; 6590/// `this = c1*this`; 6591///; 6592/// Note that both contents and err",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:258822,error,errors,258822,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"//srv//mss/event?remote=1' root://srv//mss/event_<ord>_<#>?remote=1.root Default selector is TSelEventGen. Use SetDataGenSel and SetDataGenPar to change it and to pass the list of PARs defining the alternative selector. The argument 'nevt' controls the number of events per file (-1 for the default, which is 30000). Return 0 on success, -1 on error ; Definition at line 1343 of file TProofBench.cxx. ◆ OpenOutFile(). Int_t TProofBench::OpenOutFile ; (; Bool_t ; wrt = kFALSE, . Bool_t ; verbose = kTRUE . ). Set the otuput file Return 0 on success, -1 on error. ; Definition at line 261 of file TProofBench.cxx. ◆ ReleaseCache(). Int_t TProofBench::ReleaseCache ; (; const char * ; dset). Release memory cache for dataset 'dset' Return 0 on success, -1 on error. ; Definition at line 1303 of file TProofBench.cxx. ◆ RemoveDataSet(). Int_t TProofBench::RemoveDataSet ; (; const char * ; dset). Physically remove the dataset 'dset', i.e. ; remove the dataset and the files it describes Return 0 on success, -1 on error ; Definition at line 1315 of file TProofBench.cxx. ◆ RunCPU(). Int_t TProofBench::RunCPU ; (; Long64_t ; nevents = -1, . Int_t ; start = -1, . Int_t ; stop = -1, . Int_t ; step = -1 . ). Perform the CPU run Return 0 on success, -1 on error. ; Definition at line 336 of file TProofBench.cxx. ◆ RunCPUx(). Int_t TProofBench::RunCPUx ; (; Long64_t ; nevents = -1, . Int_t ; start = -1, . Int_t ; stop = -1 . ). Perform the CPU run scanning over the number of workers per node Return 0 on success, -1 on error. ; Definition at line 365 of file TProofBench.cxx. ◆ RunDataSet(). Int_t TProofBench::RunDataSet ; (; const char * ; dset = ""BenchDataSet"", . Int_t ; start = 1, . Int_t ; stop = -1, . Int_t ; step = 1 . ). Perform a test using dataset 'dset' Return 0 on success, -1 on error Open the file for the results. ; Definition at line 897 of file TProofBench.cxx. ◆ RunDataSetx(). Int_t TProofBench::RunDataSetx ; (; const char * ; dset = ""BenchDataSet"", . Int_t ; start = 1, . Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofBench.html:21066,error,error,21066,doc/master/classTProofBench.html,https://root.cern,https://root.cern/doc/master/classTProofBench.html,1,['error'],['error']
Availability,"//www.chilkatsoft.com/p/p_299.asp */; 6377 return -2;; 6378 } else {; 6379 DEBUG_TRACE(""recv() failed, error %d"", err);; 6380 return -2;; 6381 }; 6382#else; 6383 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6384 * if the timeout is reached and if the socket was set to non-; 6385 * blocking in close_socket_gracefully, so we can not distinguish; 6386 * here. We have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN(err)) {; 6389 /* TODO (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6428 ; 6429 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6430 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6431 if (n == -2) {; 6432 if (nread == 0) {; 6433 nread = -1; /* Propagate the error */; 6434 }; 6435 break;; 6436 } else if (n == -1) {; 6437 /* timeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:186599,error,error,186599,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,"['avail', 'error']","['available', 'error']"
Availability,"//www.chilkatsoft.com/p/p_299.asp */; 6378 return -2;; 6379 } else {; 6380 DEBUG_TRACE(""recv() failed, error %d"", err);; 6381 return -2;; 6382 }; 6383#else; 6384 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6385 * if the timeout is reached and if the socket was set to non-; 6386 * blocking in close_socket_gracefully, so we can not distinguish; 6387 * here. We have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN(err)) {; 6390 /* TODO (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6429 ; 6430 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6431 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6432 if (n == -2) {; 6433 if (nread == 0) {; 6434 nread = -1; /* Propagate the error */; 6435 }; 6436 break;; 6437 } else if (n == -1) {; 6438 /* timeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:186631,error,error,186631,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,"['avail', 'error']","['available', 'error']"
Availability,"/; 1036/// Returns the transient buffer currently used by this TTree for reading/writing baskets.; 1037 ; 1038TBuffer* TTree::GetTransientBuffer(Int_t size); 1039{; 1040 if (fTransientBuffer) {; 1041 if (fTransientBuffer->BufferSize() < size) {; 1042 fTransientBuffer->Expand(size);; 1043 }; 1044 return fTransientBuffer;; 1045 }; 1046 fTransientBuffer = new TBufferFile(TBuffer::kRead, size);; 1047 return fTransientBuffer;; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051/// Add branch with name bname to the Tree cache.; 1052/// If bname=""*"" all branches are added to the cache.; 1053/// if subbranches is true all the branches of the subbranches are; 1054/// also put to the cache.; 1055///; 1056/// Returns:; 1057/// - 0 branch added or already included; 1058/// - -1 on error; 1059 ; 1060Int_t TTree::AddBranchToCache(const char*bname, bool subbranches); 1061{; 1062 if (!GetTree()) {; 1063 if (LoadTree(0)<0) {; 1064 Error(""AddBranchToCache"",""Could not load a tree"");; 1065 return -1;; 1066 }; 1067 }; 1068 if (GetTree()) {; 1069 if (GetTree() != this) {; 1070 return GetTree()->AddBranchToCache(bname, subbranches);; 1071 }; 1072 } else {; 1073 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1085 return -1;; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:38038,error,error,38038,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,"['avail', 'error']","['available', 'error']"
Availability,"/; 1960/// Copy the command line argument, stripping MODULE/inc if; 1961/// necessary.; 1962 ; 1963void StrcpyArg(string &dest, const char *original); 1964{; 1965 dest = CopyArg(original);; 1966}; 1967 ; 1968////////////////////////////////////////////////////////////////////////////////; 1969/// Write the extra header injected into the module:; 1970/// umbrella header if (umbrella) else content header.; 1971 ; 1972static bool InjectModuleUtilHeader(const char *argv0,; 1973 TModuleGenerator &modGen,; 1974 cling::Interpreter &interp,; 1975 bool umbrella); 1976{; 1977 std::ostringstream out;; 1978 if (umbrella) {; 1979 // This will duplicate the -D,-U from clingArgs - but as they are surrounded; 1980 // by #ifndef there is no problem here.; 1981 modGen.WriteUmbrellaHeader(out);; 1982 if (interp.declare(out.str()) != cling::Interpreter::kSuccess) {; 1983 const std::string &hdrName; 1984 = umbrella ? modGen.GetUmbrellaName() : modGen.GetContentName();; 1985 ROOT::TMetaUtils::Error(nullptr, ""%s: compilation failure (%s)\n"", argv0,; 1986 hdrName.c_str());; 1987 return false;; 1988 }; 1989 } else {; 1990 modGen.WriteContentHeader(out);; 1991 }; 1992 return true;; 1993}; 1994 ; 1995////////////////////////////////////////////////////////////////////////////////; 1996/// Write the AST of the given CompilerInstance to the given File while; 1997/// respecting the given isysroot.; 1998/// If module is not a null pointer, we only write the given module to the; 1999/// given file and not the whole AST.; 2000/// Returns true if the AST was successfully written.; 2001static bool WriteAST(llvm::StringRef fileName, clang::CompilerInstance *compilerInstance,; 2002 llvm::StringRef iSysRoot,; 2003 clang::Module *module = nullptr); 2004{; 2005 // From PCHGenerator and friends:; 2006 llvm::SmallVector<char, 128> buffer;; 2007 llvm::BitstreamWriter stream(buffer);; 2008 clang::ASTWriter writer(stream, buffer, compilerInstance->getModuleCache(), /*Extensions=*/{});; 2009 std::unique_ptr<llv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:78546,failure,failure,78546,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['failure'],['failure']
Availability,"/; 2 ; 3/*************************************************************************; 4 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; 5 * All rights reserved. *; 6 * *; 7 * For the licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#ifndef ROOT_RConfig; 12#define ROOT_RConfig; 13 ; 14/*************************************************************************; 15 * *; 16 * RConfig *; 17 * *; 18 * Defines used by ROOT. *; 19 * *; 20 *************************************************************************/; 21 ; 22#include ""../RVersion.h""; 23#include ""RConfigure.h""; 24 ; 25 ; 26/*---- new C++ features ------------------------------------------------------*/; 27 ; 28#if defined __has_feature; 29# if __has_feature(modules); 30# define R__CXXMODULES; 31# endif; 32#endif; 33 ; 34#define R__USE_SHADOW_CLASS; 35 ; 36/* Now required, thus defined by default for backward compatibility */; 37#define R__ANSISTREAM /* ANSI C++ Standard Library conformant */; 38#define R__SSTREAM /* use sstream or strstream header */; 39 ; 40#if defined(_MSC_VER); 41# if (_MSC_VER < 1910); 42# error ""ROOT requires Visual Studio 2017 or higher.""; 43# else; 44# define R__NULLPTR; 45# endif; 46#else; 47#if defined(__cplusplus) && (__cplusplus < 201703L); 48#error ""ROOT requires support for C++17 or higher.""; 49# if defined(__GNUC__) || defined(__clang__); 50#error ""Pass `-std=c++17` as compiler argument.""; 51# endif; 52# endif; 53#endif; 54 ; 55/*---- machines --------------------------------------------------------------*/; 56 ; 57#ifdef __hpux; 58 /* R__HPUX10 or R__HPUX11 is determined in the Makefile */; 59# define R__HPUX; 60# define R__UNIX; 61# define ANSICPP; 62# ifdef __LP64__; 63# define R__B64; 64# endif; 65# ifdef R__HPUX10; 66# define NEED_SNPRINTF; 67# endif; 68#endif; 69 ; 70#ifdef _AIX; 71# define R__AIX; 72# define R__UNIX; 73# define",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RConfig_8hxx_source.html:1446,error,error,1446,doc/master/RConfig_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RConfig_8hxx_source.html,1,['error'],['error']
Availability,"/; 2583/// where; 2584/// \f[; 2585/// F_a(x) = \frac{ f(x,a+\mathrm{d}a) - f(x,a-\mathrm{d}a) }{2},; 2586/// \f]; 2587/// with \f$ f(x) \f$ the plotted curve and \f$ \mathrm{d}a \f$ taken from the fit result, and; 2588/// \f$ \mathrm{Corr}(a,a') \f$ = the correlation matrix from the fit result, and \f$ Z \f$ = requested signifance (\f$ Z \sigma \f$ band); 2589///; 2590/// The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; 2591/// not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made; 2592///; 2593/// Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; 2594/// is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; 2595/// from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; 2596/// for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; 2597/// that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); 2598/// Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); 2599/// longer to calculate.; 2600 ; 2601RooPlot* RooAbsReal::plotOnWithErrorBand(RooPlot* frame,const RooFitResult& fr, double Z,const RooArgSet* params, const RooLinkedList& argList, bool linMethod) const; 2602{; 2603 RooLinkedList plotArgListTmp(argList) ;; 2604 RooCmdConfig::stripCmdList(plotArgListTmp,""VisualizeError,MoveToBack"") ;; 2605 ; 2606 // Strip any 'internal normalization' arguments from list; 2607 RooLinkedList plotArgList ;; 2608 for (auto * cmd : static_range_cast<RooCmdArg*>(plotArgListTmp)) {; 2609 if (std::string(""Normal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:114200,error,error,114200,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['error']
Availability,"/; 3999/// \anchor HFitChi2; 4000/// ### Chi-square Fits; 4001///; 4002/// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; 4003/// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; 4004///; 4005/// \f[; 4006/// Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }; 4007/// \f]; 4008///; 4009/// where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for; 4010/// an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment; 4011/// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; 4012/// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; 4013/// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.; 4014/// In this case empty bins are considered in the fit.; 4015/// Both chi-square methods should not be used when the bin content represent counts, especially in case of low bin statistics,; 4016/// because they could return a biased result.; 4017///; 4018/// \anchor HFitNLL; 4019/// ### Likelihood Fits; 4020///; 4021/// When using option ""L"" a likelihood fit is used instead of the default chi-square fit.; 4022/// The likelihood is built assuming a Poisson probability density function for each bin.; 4023/// The negative log-likelihood to be minimized is; 4024///; 4025/// \f[; 4026/// NLL = - \sum_{i}{ \log {\mathrm P} ( y(i) | f(x(i) | p ) ) }; 4027/// \f]; 4028/// where `P(y|f)` is the Poisson distribution of observing a count `y(i)` in the bin when the expected count is `f(x(i)|p)`.; 4029/// The exact likelihood used is the Poisson likelihood described in this paper:; 4030/// S. Baker and R. D. Cousins, “Clarification of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:163001,error,error,163001,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['error']
Availability,"/; 4316/// In case of a 3-Dim expression, one can generate a TProfile2D histogram; 4317/// instead of a TH3F histogram by specifying option=prof or option=profs.; 4318/// or option=profi or option=profg ; the trailing letter select the way; 4319/// the bin error are computed, See TProfile2D::SetErrorOption for; 4320/// details on the differences.; 4321/// The option=prof is automatically selected in case of z:y:x>>pf; 4322/// where pf is an existing TProfile2D histogram.; 4323///; 4324/// ### Making a 5D plot using GL; 4325///; 4326/// If option GL5D is specified together with 5 variables, a 5D plot is drawn; 4327/// using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example.; 4328///; 4329/// ### Making a parallel coordinates plot; 4330///; 4331/// In case of a 2-Dim or more expression with the option=para, one can generate; 4332/// a parallel coordinates plot. With that option, the number of dimensions is; 4333/// arbitrary. Giving more than 4 variables without the option=para or; 4334/// option=candle or option=goff will produce an error.; 4335///; 4336/// ### Making a candle sticks chart; 4337///; 4338/// In case of a 2-Dim or more expression with the option=candle, one can generate; 4339/// a candle sticks chart. With that option, the number of dimensions is; 4340/// arbitrary. Giving more than 4 variables without the option=para or; 4341/// option=candle or option=goff will produce an error.; 4342///; 4343/// ### Normalizing the output histogram to 1; 4344///; 4345/// When option contains ""norm"" the output histogram is normalized to 1.; 4346///; 4347/// ### Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray; 4348///; 4349/// TTree::Draw can be used to fill a TEventList object (list of entry numbers); 4350/// instead of histogramming one variable.; 4351/// If varexp0 has the form >>elist , a TEventList object named ""elist""; 4352/// is created in the current directory. elist will contain the list; 4353/// of entry numbers satisfying th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:174820,error,error,174820,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['error'],['error']
Availability,"/; 53class RLogDiagCount {; 54protected:; 55 std::atomic<long long> fNumWarnings{0ll}; /// Number of warnings.; 56 std::atomic<long long> fNumErrors{0ll}; /// Number of errors.; 57 std::atomic<long long> fNumFatalErrors{0ll}; /// Number of fatal errors.; 58 ; 59public:; 60 /// Returns the current number of warnings.; 61 long long GetNumWarnings() const { return fNumWarnings; }; 62 ; 63 /// Returns the current number of errors.; 64 long long GetNumErrors() const { return fNumErrors; }; 65 ; 66 /// Returns the current number of fatal errors.; 67 long long GetNumFatalErrors() const { return fNumFatalErrors; }; 68 ; 69 /// Increase warning or error count.; 70 void Increment(ELogLevel severity); 71 {; 72 switch (severity) {; 73 case ELogLevel::kFatal: ++fNumFatalErrors; break;; 74 case ELogLevel::kError: ++fNumErrors; break;; 75 case ELogLevel::kWarning: ++fNumWarnings; break;; 76 default:;; 77 }; 78 }; 79};; 80 ; 81/**; 82 Abstract RLogHandler base class. ROOT logs everything from info to error; 83 to entities of this class.; 84 */; 85class RLogHandler {; 86public:; 87 virtual ~RLogHandler();; 88 /// Emit a log entry.; 89 /// \param entry - the RLogEntry to be emitted.; 90 /// \returns false if further emission of this Log should be suppressed.; 91 ///; 92 /// \note This function is called concurrently; log emission must be locked; 93 /// if needed. (The default log handler using ROOT's DefaultErrorHandler is locked.); 94 virtual bool Emit(const RLogEntry &entry) = 0;; 95};; 96 ; 97/**; 98 A log configuration for a channel, e.g. ""RHist"".; 99 Each ROOT module has its own log, with potentially distinct verbosity.; 100 */; 101class RLogChannel : public RLogDiagCount {; 102 /// Name as shown in diagnostics; 103 std::string fName;; 104 ; 105 /// Verbosity of this channel. By default, use the global verbosity.; 106 ELogLevel fVerbosity = ELogLevel::kUnset;; 107 ; 108public:; 109 /// Construct an anonymous channel.; 110 RLogChannel() = default;; 111 ; 112 /// Construct an anony",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RLogger_8hxx_source.html:2792,error,error,2792,doc/master/RLogger_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html,1,['error'],['error']
Availability,"/; 552/// Constructor allocate.; 553///; 554/// Note: This function should be called only from the constructor; 555/// since it does not delete previously existing arrays.; 556 ; 557Bool_t TGraphErrors::CtorAllocate(); 558{; 559 ; 560 if (!fNpoints) {; 561 fEX = fEY = nullptr;; 562 return kFALSE;; 563 } else {; 564 fEX = new Double_t[fMaxSize];; 565 fEY = new Double_t[fMaxSize];; 566 }; 567 return kTRUE;; 568}; 569 ; 570////////////////////////////////////////////////////////////////////////////////; 571/// Protected function to perform the merge operation of a graph with errors.; 572 ; 573Bool_t TGraphErrors::DoMerge(const TGraph *g); 574{; 575 if (g->GetN() == 0) return kFALSE;; 576 ; 577 Double_t * ex = g->GetEX();; 578 Double_t * ey = g->GetEY();; 579 if (ex == nullptr || ey == nullptr) {; 580 if (g->IsA() != TGraph::Class() ); 581 Warning(""DoMerge"",""Merging a %s is not compatible with a TGraphErrors - errors will be ignored"",g->IsA()->GetName());; 582 return TGraph::DoMerge(g);; 583 }; 584 for (Int_t i = 0 ; i < g->GetN(); i++) {; 585 Int_t ipoint = GetN();; 586 Double_t x = g->GetX()[i];; 587 Double_t y = g->GetY()[i];; 588 SetPoint(ipoint, x, y);; 589 SetPointError( ipoint, ex[i], ey[i] );; 590 }; 591 return kTRUE;; 592}; 593 ; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Set zero values for point arrays in the range `[begin, end]`.; 597 ; 598void TGraphErrors::FillZero(Int_t begin, Int_t end, Bool_t from_ctor); 599{; 600 if (!from_ctor) {; 601 TGraph::FillZero(begin, end, from_ctor);; 602 }; 603 Int_t n = (end - begin) * sizeof(Double_t);; 604 memset(fEX + begin, 0, n);; 605 memset(fEY + begin, 0, n);; 606}; 607 ; 608 ; 609////////////////////////////////////////////////////////////////////////////////; 610/// It returns the error along X at point `i`.; 611 ; 612Double_t TGraphErrors::GetErrorX(Int_t i) const; 613{; 614 if (i < 0 || i >= fNpoints) return -1;; 615 if (fEX) return fEX[i];; 616 return -1;; 61",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:18734,error,errors,18734,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['errors']
Availability,"/QT and shows the current print option in use.; ""Predefined"" combo box - contains a list of predefined functions in ROOT. The default one is Gaussian.; ""Operation"" radio button group defines selected operational mode between functions: NOP - no operation (default); ADD - addition CONV - convolution (will be implemented in the future).; Users can enter the function expression in a text entry field. The entered string is checked after Enter key was pressed. An error message shows up if the string is not accepted. The current prototype is limited and users have no freedom to enter file/user function names in this field.; ""Set Parameters"" button opens a dialog for parameters settings.; ""Fit Settings"" provides user interface elements related to the fitter. Currently there are two method choices: Chi-square and Binned Likelihood.; ""Linear Fit"" check button sets the use of Linear fitter is it is selected. Otherwise the option 'F' is applied if polN is selected. ""Robust"" number entry sets the robust value when fitting graphs. ""No Chi-square"" check button sets ON/OFF option 'C' - do not calculate Chi-square (for Linear fitter).; Fit options: ""Integral"" check button switch ON/OFF option 'I' - use integral of function instead of value in bin center. ""Best Errors"" sets ON/OFF option 'E' - better errors estimation using Minos technique. ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1, excluding empty bins and ignoring error bars. ""Empty bins, weights=1"" sets ON/OFF option 'WW' - all weights equal to 1, including empty bins, error bars ignored. ""Use range"" sets ON/OFF option 'R' - fit only data within the specified function range with the slider. ""Improve fit results"" sets ON/OFF option 'M' - after minimum is found, search for a new one. ""Add to list"" sets On/Off option '+'- add function to the list without deleting the previous.; Draw options: ""SAME"" sets On/Off function drawing on the same pad. ""No drawing"" sets On/Off option '0'- do not draw function graphics. """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFitEditor.html:2063,robust,robust,2063,doc/master/classTFitEditor.html,https://root.cern,https://root.cern/doc/master/classTFitEditor.html,1,['robust'],['robust']
Availability,"/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXTRU.html:8579,error,error,8579,doc/master/classTXTRU.html,https://root.cern,https://root.cern/doc/master/classTXTRU.html,19,['error'],['error']
Availability,"/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileDrawMap.html:6977,error,error,6977,doc/master/classTFileDrawMap.html,https://root.cern,https://root.cern/doc/master/classTFileDrawMap.html,3,['error'],['error']
Availability,"/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAxis3D.html:10146,error,error,10146,doc/master/classTAxis3D.html,https://root.cern,https://root.cern/doc/master/classTAxis3D.html,1,['error'],['error']
Availability,"/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAnnotation.html:15552,error,error,15552,doc/master/classTAnnotation.html,https://root.cern,https://root.cern/doc/master/classTAnnotation.html,8,['error'],['error']
Availability,"/h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; See the other TH1::Divide that gives the possibility to optionaly; compute Binomial errors. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Scale. void Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this histogram by the division of h1 by h2*-*-*. this = c1*h1/(c2*h2). if errors are defined (see TH1::Sumw2), errors are also recalculated; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. Please note also that in the binomial case errors are calculated using standard; binomial statistics, which means when b1 = b2, the error is zero.; If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; error for the case b1=b2. void Draw(Option_t* option = """"); -*-*-*-*-*-*-*-*-*Draw this histogram with options*-*-*-*-*-*-*-*-*-*-*-*. Histograms are drawn via the THistPainter class. Each histogram has; a pointer to its own painter (to be usable in a multithreaded program).; The same histogram can be drawn with different options in different pads.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:58813,error,errors,58813,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,2,['error'],['errors']
Availability,"/mathcore:$Id$; 2// Author: David Gonzalez Maline Wed Aug 28 15:33:03 2009; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for class BinData; 12 ; 13#include <iostream>; 14#include <iterator>; 15#include <algorithm>; 16 ; 17#include <vector>; 18#include <list>; 19 ; 20#include <stdexcept>; 21 ; 22#include <cmath>; 23#include <limits>; 24 ; 25#include ""Fit/BinData.h""; 26#include ""Fit/SparseData.h""; 27 ; 28using std::cout, std::endl, std::vector, std::list, std::ostream, std::ostream_iterator;; 29 ; 30namespace ROOT {; 31 ; 32 namespace Fit {; 33 ; 34 //This class is a helper. It represents a bin in N; 35 //dimensions. The change in the name is to avoid name collision.; 36 class Box; 37 {; 38 public:; 39 // Creates a Box with limits specified by the vectors and; 40 // content=value and error=error; 41 Box(const vector<double>& min, const vector<double>& max,; 42 const double value = 0.0, const double error = 1.0):; 43 fMin(min), fMax(max), fVal(value), fError(error); 44 { }; 45 ; 46 // Compares to Boxes to see if they are equal in all its; 47 // variables. This is to be used by the std::find algorithm; 48 bool operator==(const Box& b); 49 { return (fMin == b.fMin) && (fMax == b.fMax); 50 && (fVal == b.fVal) && (fError == b.fError); }; 51 ; 52 // Get the list of minimum coordinates; 53 const vector<double>& GetMin() const { return fMin; }; 54 // Get the list of maximum coordinates; 55 const vector<double>& GetMax() const { return fMax; }; 56 // Get the value of the Box; 57 double GetVal() const { return fVal; }; 58 // Get the error of the Box; 59 double GetError() const { return fError; }; 60 ; 61 // Add an amount to the content of the Box; 62 void AddVal(const double value) { fVal += value; }; 63 ; 64 friend class BoxContainer;; 65 friend ostream& operator <",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SparseData_8cxx_source.html:1211,error,error,1211,doc/master/SparseData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html,2,['error'],['error']
Availability,"/o buffer.; 2591 //; 2592 ; 2593 if (isptrptr) {; 2594 branch->SetAddress(addr);; 2595 } else {; 2596 branch->SetObject(addr);; 2597 }; 2598 ; 2599 if (delobj) {; 2600 cl->Destructor(objptr);; 2601 objptr = nullptr;; 2602 }; 2603 ; 2604 return branch;; 2605}; 2606 ; 2607////////////////////////////////////////////////////////////////////////////////; 2608/// Browse content of the TTree.; 2609 ; 2610void TTree::Browse(TBrowser* b); 2611{; 2612 fBranches.Browse(b);; 2613 if (fUserInfo) {; 2614 if (strcmp(""TList"",fUserInfo->GetName())==0) {; 2615 fUserInfo->SetName(""UserInfo"");; 2616 b->Add(fUserInfo);; 2617 fUserInfo->SetName(""TList"");; 2618 } else {; 2619 b->Add(fUserInfo);; 2620 }; 2621 }; 2622}; 2623 ; 2624////////////////////////////////////////////////////////////////////////////////; 2625/// Build a Tree Index (default is TTreeIndex).; 2626/// See a description of the parameters and functionality in; 2627/// TTreeIndex::TTreeIndex().; 2628///; 2629/// The return value is the number of entries in the Index (< 0 indicates failure).; 2630///; 2631/// A TTreeIndex object pointed by fTreeIndex is created.; 2632/// This object will be automatically deleted by the TTree destructor.; 2633/// If an index is already existing, this is replaced by the new one without being; 2634/// deleted. This behaviour prevents the deletion of a previously external index; 2635/// assigned to the TTree via the TTree::SetTreeIndex() method.; 2636/// \see also comments in TTree::SetTreeIndex().; 2637 ; 2638Int_t TTree::BuildIndex(const char* majorname, const char* minorname /* = ""0"" */); 2639{; 2640 fTreeIndex = GetPlayer()->BuildIndex(this, majorname, minorname);; 2641 if (fTreeIndex->IsZombie()) {; 2642 delete fTreeIndex;; 2643 fTreeIndex = nullptr;; 2644 return 0;; 2645 }; 2646 return fTreeIndex->GetN();; 2647}; 2648 ; 2649////////////////////////////////////////////////////////////////////////////////; 2650/// Build StreamerInfo for class cl.; 2651/// pointer is an optional argument tha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:103545,failure,failure,103545,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['failure'],['failure']
Availability,"/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:7170,reliab,reliability,7170,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,12,"['error', 'reliab']","['error', 'reliability']"
Availability,"/unuran.html#Methods_005ffor_005fCVEC"">UnuRan doc</A>; 133 A re-initialization is needed whenever distribution parameters have been changed.; 134 ; 135 The default method used for multi-dimensional distributions is ""vnrou""; 136 Note that some of the multi-dimensional continuous distribution methods like ""hitro"" are based on Markov-CHain sampler and; 137 they are much faster for sampling but require more time to converge. Furthermore, since they are Markov-Chain methods their; 138 generated sample values are correlated and cannot be used as i.i.d., one can instead use the obtained sample distribution.; 139 (see also the ROOT issue: #10222 ).; 140 ; 141 */; 142 bool Init(const TUnuranMultiContDist & distr, const std::string & method = ""vnrou"");; 143 ; 144 ; 145 /**; 146 Initialize method for continuous one-dimensional discrete distribution.; 147 User must provide a distribution object (which is copied inside) and a string for a method.; 148 For the list of available method for 1D discrete distribution see the; 149 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fDISCR"">UnuRan doc</A>; 150 A re-initialization is needed whenever distribution parameters have been changed.; 151 ; 152 */; 153 bool Init(const TUnuranDiscrDist & distr, const std::string & method = ""auto"");; 154 ; 155 ; 156 /**; 157 Initialize method for continuous empirical distribution.; 158 User must provide a distribution object (which is copied inside) and a string for a method.; 159 The distribution object can represent binned (only 1D) or unbinned (1D or multi-dim) data; 160 The method for the unbinned empirical distribution are based on the kernel smoothing, see; 161 <A href=""http://statmath.wu-wien.ac.at/software/unuran/doc/unuran.html#EMPK"">UnuRan doc</A>; 162 A re-initialization is needed whenever distribution parameters have been changed.; 163 ; 164 */; 165 bool Init(const TUnuranEmpDist & distr, const std::string & method = ""empk"");; 166 ; 167 ; 168 /**; 169 Initi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnuran_8h_source.html:5836,avail,available,5836,doc/master/TUnuran_8h_source.html,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html,1,['avail'],['available']
Availability,"0 (!=log(50.5)); NB: if the low edge of the bin is negative, the function returns the bin center; as computed by TAxis::GetBinCenter. Double_t GetBinLowEdge(Int_t bin) const; Return low edge of bin. Double_t GetBinUpEdge(Int_t bin) const; Return up edge of bin. Double_t GetBinWidth(Int_t bin) const; Return bin width. void GetCenter(Double_t* center) const; Return an array with the center of all bins. void GetLowEdge(Double_t* edge) const; Return an array with the lod edge of all bins. const char * GetTimeFormatOnly() const; Return *only* the time format from the string fTimeFormat. const char * GetTicks() const; Return the ticks option (see SetTicks). Bool_t HasBinWithoutLabel() const; this helper function checks if there is a bin without a label; if all bins have labels, the axis can / will become alphanumeric. void LabelsOption(Option_t* option = ""h""); Set option(s) to draw axis with labels; option = ""a"" sort by alphabetic order; = "">"" sort by decreasing values; = ""<"" sort by increasing values; = ""h"" draw labels horizonthal; = ""v"" draw labels vertical; = ""u"" draw labels up (end of label right adjusted); = ""d"" draw labels down (start of label left adjusted). void ImportAttributes(const TAxis* axis); Copy axis attributes to this. void SaveAttributes(ostream& out, const char* name, const char* subname); Save axis attributes as C++ statement(s) on output stream out. void Set(Int_t nbins, Double_t xmin, Double_t xmax); Initialize axis with fix bins. void Set(Int_t nbins, const Float_t* xbins); Initialize axis with variable bins. void Set(Int_t nbins, const Double_t* xbins); Initialize axis with variable bins. void SetAlphanumeric(Bool_t alphanumeric = kTRUE). void SetDefaults(); Set axis default values (from TStyle). void SetBinLabel(Int_t bin, const char* label); Set label for bin; If no label list exists, it is created. If all the bins have labels, the; axis becomes alphanumeric and extendable.; New labels will not be added with the Fill method but will end-up in the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TAxis.html:16827,down,down,16827,root/html602/TAxis.html,https://root.cern,https://root.cern/root/html602/TAxis.html,2,['down'],['down']
Availability,"0 // highlight object tracked over; 1251 pad = Pick(px, py, prevSelObj);; 1252 if (!pad) return;; 1253 ; 1254 EnterLeave(prevSelPad, prevSelObj);; 1255 ; 1256 gPad = pad; // don't use cd() we will use the current; 1257 // canvas via the GetCanvas member and not via; 1258 // gPad->GetCanvas; 1259 ; 1260 if (fSelected) {; 1261 fSelected->ExecuteEvent(event, px, py);; 1262 RunAutoExec();; 1263 }; 1264 ; 1265 break;; 1266 ; 1267 case kMouseEnter:; 1268 // mouse enters canvas; 1269 if (!fDoubleBuffer) FeedbackMode(kTRUE);; 1270 break;; 1271 ; 1272 case kMouseLeave:; 1273 // mouse leaves canvas; 1274 {; 1275 // force popdown of tooltips; 1276 TObject *sobj = fSelected;; 1277 TPad *spad = fSelectedPad;; 1278 fSelected = nullptr;; 1279 fSelectedPad = nullptr;; 1280 EnterLeave(prevSelPad, prevSelObj);; 1281 fSelected = sobj;; 1282 fSelectedPad = spad;; 1283 if (!fDoubleBuffer) FeedbackMode(kFALSE);; 1284 }; 1285 break;; 1286 ; 1287 case kButton1Double:; 1288 // triggered on the second button down within 350ms and within; 1289 // 3x3 pixels of the first button down, button up finishes action; 1290 ; 1291 case kButton1Down:; 1292 // find pad in which input occurred; 1293 pad = Pick(px, py, prevSelObj);; 1294 if (!pad) return;; 1295 ; 1296 gPad = pad; // don't use cd() because we won't draw in pad; 1297 // we will only use its coordinate system; 1298 ; 1299 if (fSelected) {; 1300 FeedbackMode(kTRUE); // to draw in rubberband mode; 1301 fSelected->ExecuteEvent(event, px, py);; 1302 ; 1303 RunAutoExec();; 1304 }; 1305 ; 1306 break;; 1307 ; 1308 case kArrowKeyPress:; 1309 case kArrowKeyRelease:; 1310 case kButton1Motion:; 1311 case kButton1ShiftMotion: //8 == kButton1Motion + shift modifier; 1312 if (fSelected) {; 1313 gPad = fSelectedPad;; 1314 ; 1315 fSelected->ExecuteEvent(event, px, py);; 1316 if (!IsWeb()); 1317 gVirtualX->Update();; 1318 if (fSelected && !fSelected->InheritsFrom(TAxis::Class())) {; 1319 Bool_t resize = kFALSE;; 1320 if (fSelected->InheritsFrom(TBox::Class()))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:41048,down,down,41048,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['down'],['down']
Availability,"0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = 2, TList* workers = 0); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0, Int_t chkveropt = 2); Build specified package on the client. Executes the PROOF-INF/BUILD.sh; script if it exists on the client.; If opt == 0, both the preparation and building phases are run.; If opt == 1, only the preparation phase (asserting and, eventually, downloading; of the package) is done; '*path' contains the full path to the; package to be passed in the next call; If opt == 2, only the building phase is run using *path .; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kBuildPackage; case). Keep in sync in case of changes. Int_t LoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0, TList* workers = 0); Load specified package. Executes the PROOF-INF/SETUP.C script; on all active nodes. If notOnClient = true, don't load package; on the client. The default is to load the package also on the client.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t LoadPackageOnClient(const char* package, TList* loadopts = 0); Load specified package in the client. Executes the PROOF-INF/SETUP.C; script on the clie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:71914,down,downloading,71914,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['down'],['downloading']
Availability,"0 of file RDFColumnRegister.cxx. ◆ GetDefine(). RDFDetail::RDefineBase * ROOT::Internal::RDF::RColumnRegister::GetDefine ; (; std::string_view ; colName); const. Return the RDefine for the requested column name, or nullptr. ; Definition at line 51 of file RDFColumnRegister.cxx. ◆ GetReader(). RDFDetail::RColumnReaderBase * ROOT::Internal::RDF::RColumnRegister::GetReader ; (; unsigned int ; slot, . const std::string & ; colName, . const std::string & ; variationName, . const std::type_info & ; requestedType . ). Return a RDefineReader or a RVariationReader, or nullptr if not available. ; If requestedType does not match the actual type of the Define or Variation, an exception is thrown. ; Definition at line 258 of file RDFColumnRegister.cxx. ◆ GetReaderUnchecked(). RDFDetail::RColumnReaderBase * ROOT::Internal::RDF::RColumnRegister::GetReaderUnchecked ; (; unsigned int ; slot, . const std::string & ; colName, . const std::string & ; variationName . ). Return a RDefineReader or a RVariationReader, or nullptr if not available. ; No type checking is done on the requested reader. ; Definition at line 287 of file RDFColumnRegister.cxx. ◆ GetVariationDeps() [1/2]. std::vector< std::string > ROOT::Internal::RDF::RColumnRegister::GetVariationDeps ; (; const std::string & ; column); const. Get the names of all variations that directly or indirectly affect a given column. ; This list includes variations applied to the column as well as variations applied to other columns on which the value of this column depends (typically via a Define expression). ; Definition at line 130 of file RDFColumnRegister.cxx. ◆ GetVariationDeps() [2/2]. std::vector< std::string > ROOT::Internal::RDF::RColumnRegister::GetVariationDeps ; (; const std::vector< std::string > & ; columns); const. Get the names of all variations that directly or indirectly affect the specified columns. ; This list includes variations applied to the columns as well as variations applied to other columns on which the value of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html:9256,avail,available,9256,doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html,1,['avail'],['available']
Availability,"0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:134209,error,error,134209,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,1,['error'],['error']
Availability,"0 std::cout << ""Number of iterations = "" << iter<< std::endl;; 311 ; 312 PrintState();; 313 }; 314 }; 315 fIter = iter;; 316 fStatus = status;; 317 return (fStatus == GSL_SUCCESS);; 318 ; 319}; 320 ; 321void GSLMultiRootFinder::PrintState(std::ostream & os) {; 322 // print current state; 323 if (!fSolver) return;; 324 double ndigits = std::log10( double( Dim() ) );; 325 int wi = int(ndigits)+1;; 326 const double * xtmp = fSolver->X();; 327 const double * ftmp = fSolver->FVal();; 328 os << ""Root values = "";; 329 for (unsigned int i = 0; i< Dim(); ++i); 330 os << ""x["" << std::setw(wi) << i << ""] = "" << std::setw(12) << xtmp[i] << "" "";; 331 os << std::endl;; 332 os << ""Function values = "";; 333 for (unsigned int i = 0; i< Dim(); ++i); 334 os << ""f["" << std::setw(wi) << i << ""] = "" << std::setw(12) << ftmp[i] << "" "";; 335 os << std::endl;; 336}; 337 ; 338 ; 339 ; 340} // namespace Math; 341} // namespace ROOT; Error.h; MATH_INFO_MSG#define MATH_INFO_MSG(loc, str)Pre-processor macro to report messages which can be configured to use ROOT error or simply an std::io...Definition Error.h:77; MATH_INFO_MSGVAL#define MATH_INFO_MSGVAL(loc, txt, x)Definition Error.h:101; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; GSLMultiRootFinder.h; GSLMultiRootSolver.h; IFunction.h; f#define f(i)Definition RSha256.hxx:104; GSL_SUCCESS#define GSL_SUCCESSDefinition RooAdaptiveGaussKronrodIntegrator1D.cxx:379; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GSLMultiRootFinder_8cxx_source.html:12171,error,error,12171,doc/master/GSLMultiRootFinder_8cxx_source.html,https://root.cern,https://root.cern/doc/master/GSLMultiRootFinder_8cxx_source.html,1,['error'],['error']
Availability,"0 || bin >= fNcells) return 0;; 847 return fBinEntries.fArray[bin];; 848}; 849 ; 850////////////////////////////////////////////////////////////////////////////////; 851/// Return bin effective entries for a weighted filled Profile histogram.; 852/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 853/// The effective entries is defined as the square of the sum of the weights divided by the; 854/// sum of the weights square.; 855/// TProfile::Sumw2() must be called before filling the profile with weights.; 856/// Only by calling this method the sum of the square of the weights per bin is stored.; 857 ; 858Double_t TProfile2D::GetBinEffectiveEntries(Int_t bin); 859{; 860 return TProfileHelper::GetBinEffectiveEntries(this, bin);; 861}; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Return bin error of a Profile2D histogram.; 865///; 866/// ### Computing errors: A moving field; 867///; 868/// The computation of errors for a TProfile2D has evolved with the versions; 869/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 870/// - prior to version 3.10, we had no special treatment of low statistic bins.; 871/// As a result, these bins had huge errors. The reason is that the; 872/// expression eprim2 is very close to 0 (rounding problems) or 0.; 873/// - The algorithm is modified/protected for the case; 874/// when a TProfile2D is projected (ProjectionX). The previous algorithm; 875/// generated a N^2 problem when projecting a TProfile2D with a large number of; 876/// bins (eg 100000).; 877/// - in version 3.10/02, a new static function TProfile::Approximate; 878/// is introduced to enable or disable (default) the approximation.; 879/// (see also comments in TProfile::GetBinError); 880 ; 881Double_t TProfile2D::GetBinError(Int_t bin) const; 882{; 883 return TProfileHelper::GetBinError((TProfile2D*)this, bin);; 884}; 885 ; 886/////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:30092,error,errors,30092,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,2,['error'],['errors']
Availability,"0 }; 4551 }; 4552 }; 4553}; 4554 ; 4555////////////////////////////////////////////////////////////////////////////////; 4556/// Fill all branches.; 4557///; 4558/// This function loops on all the branches of this tree. For; 4559/// each branch, it copies to the branch buffer (basket) the current; 4560/// values of the leaves data types. If a leaf is a simple data type,; 4561/// a simple conversion to a machine independent format has to be done.; 4562///; 4563/// This machine independent version of the data is copied into a; 4564/// basket (each branch has its own basket). When a basket is full; 4565/// (32k worth of data by default), it is then optionally compressed; 4566/// and written to disk (this operation is also called committing or; 4567/// 'flushing' the basket). The committed baskets are then; 4568/// immediately removed from memory.; 4569///; 4570/// The function returns the number of bytes committed to the; 4571/// individual branches.; 4572///; 4573/// If a write error occurs, the number of bytes returned is -1.; 4574///; 4575/// If no data are written, because, e.g., the branch is disabled,; 4576/// the number of bytes returned is 0.; 4577///; 4578/// __The baskets are flushed and the Tree header saved at regular intervals__; 4579///; 4580/// At regular intervals, when the amount of data written so far is; 4581/// greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; 4582/// This makes future reading faster as it guarantees that baskets belonging to nearby; 4583/// entries will be on the same disk region.; 4584/// When the first call to flush the baskets happen, we also take this opportunity; 4585/// to optimize the baskets buffers.; 4586/// We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; 4587/// In this case we also write the Tree header. This makes the Tree recoverable up to this point; 4588/// in case the program writing the Tree crashes.; 4589/// The decisions to FlushBaskets and A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:185324,error,error,185324,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['error'],['error']
Availability,"0"" When fitting a TGraphErrors do not consider errors in the coordinate; = ""ROB"" In case of linear fitting, compute the LTS regression; coefficients (robust (resistant) regression), using; the default fraction of good points; ""ROB=0.x"" - compute the LTS regression coefficients, using; 0.x as a fraction of good points; = ""S"" The result of the fit is returned in the TFitResultPtr; (see below Access to the Fit Result). When the fit is drawn (by default), the parameter goption may be used; to specify a list of graphics options. See TGraphPainter for a complete; list of these options. In order to use the Range option, one must first create a function; with the expression to be fitted. For example, if your graph; has a defined range between -4 and 4 and you want to fit a gaussian; only in the interval 1 to 3, you can do:; TF1 *f1 = new TF1(""f1"",""gaus"",1,3);; graph->Fit(""f1"",""R"");. Who is calling this function:. Note that this function is called when calling TGraphErrors::Fit; or TGraphAsymmErrors::Fit ot TGraphBentErrors::Fit; See the discussion below on error calulation. Linear fitting:. When the fitting function is linear (contains the ""++"" sign) or the fitting; function is a polynomial, a linear fitter is initialised.; To create a linear function, use the following syntax: linear parts; separated by ""++"" sign.; Example: to fit the parameters of ""[0]*x + [1]*sin(x)"", create a; TF1 *f1=new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; For such a TF1 you don't have to set the initial conditions.; Going via the linear fitter for functions, linear in parameters, gives a; considerable advantage in speed. Setting initial conditions:. Parameters must be initialized before invoking the Fit function.; The setting of the parameter initial values is automatic for the; predefined functions : poln, expo, gaus, landau. One can however disable; this automatic computation by specifying the option ""B"".; You can specify boundary limits for some or all parameters via; f1->SetParLimits(p_number, pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraph.html:23198,error,error,23198,root/html528/TGraph.html,https://root.cern,https://root.cern/root/html528/TGraph.html,3,['error'],['error']
Availability,"0""""""; 51); 52 ; 53df = df.DefinePerSample(""scale"", ""scale(rdfslot_, rdfsampleinfo_)""); 54 ; 55# Select events for the analysis; 56ROOT.gInterpreter.Declare(; 57 """"""; 58using ROOT::RVecF;; 59using ROOT::RVecI;; 60bool GoodElectronsAndMuons(const RVecI &type, const RVecF &pt, const RVecF &eta, const RVecF &phi, const RVecF &e, const RVecF &trackd0pv, const RVecF &tracksigd0pv, const RVecF &z0); 61{; 62 for (size_t i = 0; i < type.size(); i++) {; 63 ROOT::Math::PtEtaPhiEVector p(0.001*pt[i], eta[i], phi[i], 0.001*e[i]);; 64 if (type[i] == 11) {; 65 if (pt[i] < 7000 || abs(eta[i]) > 2.47 || abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; 66 } else {; 67 if (abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; 68 }; 69 }; 70 return true;; 71}; 72""""""; 73); 74 ; 75# Select electron or muon trigger; 76df = df.Filter(""trigE || trigM""); 77 ; 78# Select events with exactly four good leptons conserving charge and lepton numbers; 79# Note that all collections are RVecs and good_lep is the mask for the good leptons.; 80# The lepton types are PDG numbers and set to 11 or 13 for an electron or muon; 81# irrespective of the charge.; 82 ; 83df = (; 84 df.Define(; 85 ""good_lep"",; 86 ""abs(lep_eta) < 2.5 && lep_pt > 5000 && lep_ptcone30 / lep_pt < 0.3 && lep_etcone20 / lep_pt < 0.3"",; 87 ); 88 .Filter(""Sum(good_lep) == 4""); 89 .Filter(""Sum(lep_charge[good_lep]) == 0""); 90 .Define(""goodlep_sumtypes"", ""Sum(lep_type[good_lep])""); 91 .Filter(""goodlep_sumtypes == 44 || goodlep_sumtypes == 52 || goodlep_sumtypes == 48""); 92); 93 ; 94# Apply additional cuts depending on lepton flavour; 95df = df.Filter(; 96 ""GoodElectronsAndMuons(lep_type[good_lep], lep_pt[good_lep], lep_eta[good_lep], lep_phi[good_lep], lep_E[good_lep], lep_trackd0pvunbiased[good_lep], lep_tracksigd0pvunbiased[good_lep], lep_z0[good_lep])""; 97); 98 ; 99# Create new columns with the kinematics of good leptons; 100df = (; 101 df.Define(""goodlep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:3911,mask,mask,3911,doc/master/df106__HiggsToFourLeptons_8py_source.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html,1,['mask'],['mask']
Availability,"0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* nset); Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. void setNormValueCaching(Int_t m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:43303,error,error,43303,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,2,['error'],['error']
Availability,"0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:47069,error,error,47069,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,6,['error'],['error']
Availability,"0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. void setNormValueCachin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:43916,error,error,43916,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,6,['error'],['error']
Availability,"0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; MsgLogger & Log () const;  . Private Attributes; Int_t fCount;  number of updates contributing to error field ;  ; Double_t fDEDw;  sum of deltas ;  ; Double_t fDelta;  local error field ;  ; Double_t fLearnRate;  learning rate parameter ;  ; TNeuron * fPostNeuron;  pointer to post-neuron ;  ; TNeuron * fPreNeuron;  pointer to pre-neuron ;  ; Double_t fWeight;  weight of the synapse ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1TSynapse.html:9826,error,error,9826,doc/master/classTMVA_1_1TSynapse.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1TSynapse.html,2,['error'],['error']
Availability,"0). explicit . Class constructor. ; nWorkers is the number of times this ROOT session will be forked, i.e. the number of workers that will be spawned. ; Definition at line 90 of file TTreeProcessorMP.cxx. ◆ ~TTreeProcessorMP(). ROOT::TTreeProcessorMP::~TTreeProcessorMP ; (; ). default . ◆ TTreeProcessorMP() [2/2]. ROOT::TTreeProcessorMP::TTreeProcessorMP ; (; const TTreeProcessorMP & ; ). delete . Member Function Documentation. ◆ Collect(). template<class T > . void ROOT::TTreeProcessorMP::Collect ; (; std::vector< T > & ; reslist). private . Listen for messages sent by the workers and call the appropriate handler function. ; TTreeProcessorMP::HandlePoolCode is called on messages with a code < 1000 and TMPClient::HandleMPCode is called on messages with a code >= 1000. ; Definition at line 433 of file TTreeProcessorMP.hxx. ◆ FixLists(). void ROOT::TTreeProcessorMP::FixLists ; (; std::vector< TObject * > & ; lists). private . Fix list of lists before merging (to avoid errors about duplicated objects) ; Definition at line 324 of file TTreeProcessorMP.cxx. ◆ GetNWorkers(). unsigned ROOT::TTreeProcessorMP::GetNWorkers ; (; ); const. inline . Definition at line 166 of file TTreeProcessorMP.hxx. ◆ HandlePoolCode(). template<class T > . void ROOT::TTreeProcessorMP::HandlePoolCode ; (; MPCodeBufPair & ; msg, . TSocket * ; sender, . std::vector< T > & ; reslist . ). private . Handle message and reply to the worker. ; Definition at line 407 of file TTreeProcessorMP.hxx. ◆ operator=(). TTreeProcessorMP & ROOT::TTreeProcessorMP::operator= ; (; const TTreeProcessorMP & ; ). delete . ◆ Process() [1/20]. template<class F > . auto ROOT::TTreeProcessorMP::Process ; (; const std::string & ; fileName, . F ; procFunc, . const std::string & ; treeName = """", . ULong64_t ; nToProcess = 0, . ULong64_t ; jFirst = 0 . ); -> InvokeResult_t<F, std::reference_wrapper<TTreeReader>>. Definition at line 366 of file TTreeProcessorMP.hxx. ◆ Process() [2/20]. template<class F > . auto ROOT::TTreeProces",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TTreeProcessorMP.html:13136,error,errors,13136,doc/v632/classROOT_1_1TTreeProcessorMP.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TTreeProcessorMP.html,2,['error'],['errors']
Availability,"0); Int_tTProof::Retrieve(const char* queryref, const char* path = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTProof::SendDataSetStatus(const char* msg, UInt_t n, UInt_t tot, Bool_t st); Bool_tTProof::SendingLogToWindow() const; voidTProof::SendLogToWindow(Bool_t mode); voidTProof::SetActive(Bool_t = kTRUE); virtual voidTProof::SetAlias(const char* alias = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTProof::SetDataPoolUrl(const char* url); virtual Int_tTProof::SetDataSetTreeName(const char* dataset, const char* treename); voidTProof::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTProof::SetInputDataFile(const char* datafile); voidTProof::SetLogLevel(Int_t level, UInt_t mask = TProofDebug::kAll); voidTProof::SetManager(TProofMgr* mgr); voidTProof::SetMaxDrawQueries(Int_t max); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); Int_tTProof::SetParallel(Int_t nodes = 9999, Bool_t random = kFALSE); voidTProof::SetParameter(const char* par, const char* value); voidTProof::SetParameter(const char* par, Int_t value); voidTProof::SetParameter(const char* par, Long_t value); voidTProof::SetParameter(const char* par, Long64_t value); voidTProof::SetParameter(const char* par, Double_t value); voidTProof::SetPrintProgress(PrintProgress_t pp); voidTProof::SetProgressDialog(Bool_t on = kTRUE); voidTProof::SetQueryMode(TProof::EQueryMode mode); voidTProof::SetRealTimeLog(Bool_t on = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTProof::ShowCache(Bool_t all = kFALSE); voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofSuperMaster.html:15374,mask,mask,15374,root/html528/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html528/TProofSuperMaster.html,1,['mask'],['mask']
Availability,"0); rebuild the sampling distributions by; generating some toys and find for each of theam a new upper limit; Return the upper limit distribution and optionally also the pValue distributions for Cls, Clsb and Clbxs; as a TList for each scanned point. void SetFixedScan(int nBins, double xMin = 1, double xMax = -1); set for a fixed scan in nbins. void SetAutoScan(); set auto scan (default). { SetFixedScan(0); }. void UseCLs(bool on = true); { fUseCLs = on; if (fResults) fResults->UseCLs(on); }. void SetModel(const RooStats::ModelConfig& ); { }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size; if (fResults) fResults->SetTestSize(size); }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl; if (fResults) fResults->SetConfidenceLevel(cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. HypoTestCalculatorGeneric * GetHypoTestCalculator() const; retrieved a reference to the internally used HypoTestCalculator; it might be invalid when the class is deleted. { return fCalculator0; }. void SetVerbose(int level = 1); set verbose level (0,1,2). { fVerbose = level; }. void SetMaximumToys(int ntoys); set maximum number of toys. { fMaxToys = ntoys;}. void SetNumErr(double err); set numerical error in test statistic evaluation (default is zero). { fNumErr = err; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: HypoTestInverter.h 40096 2011-07-01 10:08:17Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HypoTestInverter.html:11741,error,error,11741,root/html530/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html530/RooStats__HypoTestInverter.html,1,['error'],['error']
Availability,"0); rebuild the sampling distributions by; generating some toys and find for each of theam a new upper limit; Return the upper limit distribution and optionally also the pValue distributions for Cls, Clsb and Clbxs; as a TList for each scanned point. void SetFixedScan(int nBins, double xMin = 1, double xMax = -1); set for a fixed scan in nbins. void SetAutoScan(); set auto scan (default). { SetFixedScan(0); }. void UseCLs(bool on = true); { fUseCLs = on; if (fResults) fResults->UseCLs(on); }. void SetModel(const RooStats::ModelConfig& ); { }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size; if (fResults) fResults->SetTestSize(size); }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl; if (fResults) fResults->SetConfidenceLevel(cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. HypoTestCalculatorGeneric * GetHypoTestCalculator() const; retrieved a reference to the internally used HypoTestCalculator; it might be invalid when the class is deleted. { return fCalculator0; }. void SetVerbose(int level = 1); set verbose level (0,1,2). { fVerbose = level; }. void SetMaximumToys(int ntoys); set maximum number of toys. { fMaxToys = ntoys;}. void SetNumErr(double err); set numerical error in test statistic evaluation (default is zero). { fNumErr = err; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: HypoTestInverter.h 41455 2011-10-18 13:23:21Z moneta $ » Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HypoTestInverter.html:12258,error,error,12258,root/html532/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html532/RooStats__HypoTestInverter.html,1,['error'],['error']
Availability,"0); virtual voidAddWithBurnIn(RooStats::MarkovChain& otherChain, Int_t burnIn = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__MarkovChain.html:1784,error,error,1784,root/html534/RooStats__MarkovChain.html,https://root.cern,https://root.cern/root/html534/RooStats__MarkovChain.html,1,['error'],['error']
Availability,"0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__MarkovChain.html:1621,error,error,1621,root/html526/RooStats__MarkovChain.html,https://root.cern,https://root.cern/root/html526/RooStats__MarkovChain.html,8,['error'],['error']
Availability,"0);; 4400 conn->in_error_handler = 0;; 4401 }; 4402 ; 4403 if (!handled_by_callback) {; 4404 /* Check for recursion */; 4405 if (conn->in_error_handler) {; 4406 DEBUG_TRACE(; 4407 ""Recursion when handling error %u - fall back to default"",; 4408 status);; 4409#if !defined(NO_FILESYSTEMS); 4410 } else {; 4411 /* Send user defined error pages, if defined */; 4412 error_handler = conn->dom_ctx->config[ERROR_PAGES];; 4413 error_page_file_ext = conn->dom_ctx->config[INDEX_FILES];; 4414 page_handler_found = 0;; 4415 ; 4416 if (error_handler != NULL) {; 4417 for (scope = 1; (scope <= 3) && !page_handler_found; scope++) {; 4418 switch (scope) {; 4419 case 1: /* Handler for specific error, e.g. 404 error */; 4420 mg_snprintf(conn,; 4421 &truncated,; 4422 path_buf,; 4423 sizeof(path_buf) - 32,; 4424 ""%serror%03u."",; 4425 error_handler,; 4426 status);; 4427 break;; 4428 case 2: /* Handler for error group, e.g., 5xx error; 4429 * handler; 4430 * for all server errors (500-599) */; 4431 mg_snprintf(conn,; 4432 &truncated,; 4433 path_buf,; 4434 sizeof(path_buf) - 32,; 4435 ""%serror%01uxx."",; 4436 error_handler,; 4437 status / 100);; 4438 break;; 4439 default: /* Handler for all errors */; 4440 mg_snprintf(conn,; 4441 &truncated,; 4442 path_buf,; 4443 sizeof(path_buf) - 32,; 4444 ""%serror."",; 4445 error_handler);; 4446 break;; 4447 }; 4448 ; 4449 /* String truncation in buf may only occur if; 4450 * error_handler is too long. This string is; 4451 * from the config, not from a client. */; 4452 (void)truncated;; 4453 ; 4454 /* The following code is redundant, but it should avoid; 4455 * false positives in static source code analyzers and; 4456 * vulnerability scanners.; 4457 */; 4458 path_buf[sizeof(path_buf) - 32] = 0;; 4459 len = (int)strlen(path_buf);; 4460 if (len > (int)sizeof(path_buf) - 32) {; 4461 len = (int)sizeof(path_buf) - 32;; 4462 }; 4463 ; 4464 /* Start with the file extenstion from the configuration. */; 4465 tstr = strchr(error_page_file_ext, '.');; 4466 ; 4467 while ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:132510,error,error,132510,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['error'],"['error', 'errors']"
Availability,"0);; 4401 conn->in_error_handler = 0;; 4402 }; 4403 ; 4404 if (!handled_by_callback) {; 4405 /* Check for recursion */; 4406 if (conn->in_error_handler) {; 4407 DEBUG_TRACE(; 4408 ""Recursion when handling error %u - fall back to default"",; 4409 status);; 4410#if !defined(NO_FILESYSTEMS); 4411 } else {; 4412 /* Send user defined error pages, if defined */; 4413 error_handler = conn->dom_ctx->config[ERROR_PAGES];; 4414 error_page_file_ext = conn->dom_ctx->config[INDEX_FILES];; 4415 page_handler_found = 0;; 4416 ; 4417 if (error_handler != NULL) {; 4418 for (scope = 1; (scope <= 3) && !page_handler_found; scope++) {; 4419 switch (scope) {; 4420 case 1: /* Handler for specific error, e.g. 404 error */; 4421 mg_snprintf(conn,; 4422 &truncated,; 4423 path_buf,; 4424 sizeof(path_buf) - 32,; 4425 ""%serror%03u."",; 4426 error_handler,; 4427 status);; 4428 break;; 4429 case 2: /* Handler for error group, e.g., 5xx error; 4430 * handler; 4431 * for all server errors (500-599) */; 4432 mg_snprintf(conn,; 4433 &truncated,; 4434 path_buf,; 4435 sizeof(path_buf) - 32,; 4436 ""%serror%01uxx."",; 4437 error_handler,; 4438 status / 100);; 4439 break;; 4440 default: /* Handler for all errors */; 4441 mg_snprintf(conn,; 4442 &truncated,; 4443 path_buf,; 4444 sizeof(path_buf) - 32,; 4445 ""%serror."",; 4446 error_handler);; 4447 break;; 4448 }; 4449 ; 4450 /* String truncation in buf may only occur if; 4451 * error_handler is too long. This string is; 4452 * from the config, not from a client. */; 4453 (void)truncated;; 4454 ; 4455 /* The following code is redundant, but it should avoid; 4456 * false positives in static source code analyzers and; 4457 * vulnerability scanners.; 4458 */; 4459 path_buf[sizeof(path_buf) - 32] = 0;; 4460 len = (int)strlen(path_buf);; 4461 if (len > (int)sizeof(path_buf) - 32) {; 4462 len = (int)sizeof(path_buf) - 32;; 4463 }; 4464 ; 4465 /* Start with the file extenstion from the configuration. */; 4466 tstr = strchr(error_page_file_ext, '.');; 4467 ; 4468 while ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:132542,error,error,132542,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['error'],"['error', 'errors']"
Availability,"0, -3, 3);; 66 h->FillRandom(""gaus"", nh);; 67 TF1 *f = new TF1(""fgaus"", ""gaus"", -3, 3);; 68 f->SetLineWidth(2);; 69 h->Fit(f, ""Q"");; 70 h->Draw();; 71 ; 72 /*Create a histogram to hold the confidence intervals*/; 73 TH1D *hint = new TH1D(""hint"",; 74 ""Fitted Gaussian with .95 conf.band"", 100, -3, 3);; 75 (TVirtualFitter::GetFitter())->GetConfidenceIntervals(hint);; 76 //Now the ""hint"" histogram has the fitted function values as the; 77 //bin contents and the confidence intervals as bin errors; 78 hint->SetStats(false);; 79 hint->SetFillColor(2);; 80 hint->Draw(""e3 same"");; 81 ; 82//### 3. A 2d graph; 83 //Create and fill the graph; 84 int ngr2 = 100;; 85 double z, rnd, e=0.3;; 86 TGraph2D *gr2 = new TGraph2D(ngr2);; 87 gr2->SetName(""Graph2DNoError"");; 88 TF2 *f2 = new TF2(""f2"",; 89 ""1000*(([0]*sin(x)/x)*([1]*sin(y)/y))+250"",-6,6,-6,6);; 90 f2->SetParameters(1,1);; 91 for (i=0; i<ngr2; i++){; 92 f2->GetRandom2(x,y);; 93 // Generate a random number in [-e,e]; 94 rnd = 2*gRandom->Rndm()*e-e;; 95 z = f2->Eval(x,y)*(1+rnd);; 96 gr2->SetPoint(i,x,y,z);; 97 }; 98 //Create a graph with errors to store the intervals; 99 TGraph2DErrors *grint2 = new TGraph2DErrors(ngr2);; 100 for (i=0; i<ngr2; i++); 101 grint2->SetPoint(i, gr2->GetX()[i], gr2->GetY()[i], 0);; 102 ; 103 //Fit the graph; 104 f2->SetParameters(0.5,1.5);; 105 gr2->Fit(f2, ""Q"");; 106 /*Compute the confidence intervals*/; 107 (TVirtualFitter::GetFitter())->GetConfidenceIntervals(grint2);; 108 //Now the ""grint2"" graph contains function values as z-coordinates; 109 //and confidence intervals as their errors; 110 //draw; 111 myc->cd(3);; 112 f2->SetNpx(30);; 113 f2->SetNpy(30);; 114 f2->SetFillColor(kBlue);; 115 f2->Draw(""surf4"");; 116 grint2->SetNpx(20);; 117 grint2->SetNpy(20);; 118 grint2->SetMarkerStyle(24);; 119 grint2->SetMarkerSize(0.7);; 120 grint2->SetMarkerColor(kRed);; 121 grint2->SetLineColor(kRed);; 122 grint2->Draw(""E0 same"");; 123 grint2->SetTitle(""Fitted 2d function with .95 error bars"");; 124 ; 125 myc-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ConfidenceIntervals_8C_source.html:3242,error,errors,3242,doc/master/ConfidenceIntervals_8C_source.html,https://root.cern,https://root.cern/doc/master/ConfidenceIntervals_8C_source.html,1,['error'],['errors']
Availability,"0, 5.30);; ; // Parameters; RooRealVar m0(""m0"", ""m0"", 5.291, 5.20, 5.30);; RooRealVar k(""k"", ""k"", -30, -50, -10);; ; // Pdf; RooArgusBG argus(""argus"", ""argus"", m, m0, k);; ; // Sample 1000 events in m from argus; std::unique_ptr<RooDataSet> data{argus.generate(m, 1000)};; ; // P l o t m o d e l a n d d a t a; // --------------------------------------; ; RooPlot *frame1 = m.frame(Bins(40), Title(""Argus model and data""));; data->plotOn(frame1);; argus.plotOn(frame1);; ; // F i t m o d e l t o d a t a; // ---------------------------------; ; // The ARGUS background shape has a sharp kinematic cutoff at m=m0; // and is prone to evaluation errors if the cutoff parameter m0; // is floated: when the pdf cutoff value is lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:1600,error,error,1600,doc/master/rf606__nllerrorhandling_8C.html,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html,2,['error'],"['error', 'errors']"
Availability,"0, UInt_t padbottom = 0); virtual~TGTableLayoutHints(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetAttachBottom() const; UInt_tGetAttachLeft() const; UInt_tGetAttachRight() const; UInt_tGetAttachTop() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; ULong_tTGLayoutHints::GetLayoutHints() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTGLayoutHints::GetPadBottom() const; Int_tTGLayoutHints::GetPadLeft() const; Int_tTGLayoutHints::GetPadRight() const; Int_tTGLayoutHints::GetPadT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTableLayoutHints.html:3237,error,error,3237,root/html528/TGTableLayoutHints.html,https://root.cern,https://root.cern/root/html528/TGTableLayoutHints.html,4,['error'],['error']
Availability,"0, const char* description = 0); voidAddToSet(const char* key, const char* value); voidAddToSetDescription(const char* key, const char* description); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = 0); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TStringGenerate(); const char*GetDescription(const char* key); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetValue(const char* key); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGridJDL.html:2297,error,error,2297,root/html528/TGridJDL.html,https://root.cern,https://root.cern/root/html528/TGridJDL.html,4,['error'],['error']
Availability,"0,0);; TH1F *h2 = new TH1F(""h2"",""h2"",220,0,110);; TH1F *h3 = new TH1F(""h3"",""h3"",330,-55,55);; TRandom r;; for (Int_t i=0;i<10000;i++) {; h1->Fill(r.Gaus(-55,10));; h2->Fill(r.Gaus(55,10));; h3->Fill(r.Gaus(0,10));; }. TList *list = new TList;; list->Add(h1);; list->Add(h2);; list->Add(h3);; TH1F *h = (TH1F*)h1->Clone(""h"");; h->Reset();; h->Merge(list);; h->Draw();; }. Bool_t Multiply(TF1* h1, Double_t c1 = 1); Performs the operation: this = this*c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. The function return kFALSE if the Multiply operation failed. Bool_t Multiply(const TH1* h1); -*-*-*-*-*-*-*-*-*Multiply this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this*h1. If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. The function return kFALSE if the Multiply operation failed. Bool_t Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this histogram by multiplication of h1 by h2*-*. this = (c1*h1)*(c2*h2). If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. The function return kFALSE if th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:98810,error,errors,98810,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,3,"['avail', 'error']","['available', 'errors']"
Availability,"0,; 11452 ""Error: Not enough memory for CGI buffer (%u bytes)"",; 11453 (unsigned int)buflen);; 11454 mg_cry_internal(; 11455 conn,; 11456 ""Error: CGI program \""%s\"": Not enough memory for buffer (%u ""; 11457 ""bytes)"",; 11458 prog,; 11459 (unsigned int)buflen);; 11460 goto done;; 11461 }; 11462 ; 11463 DEBUG_TRACE(""CGI: %s"", ""wait for response"");; 11464 headers_len = read_message(out, conn, buf, (int)buflen, &data_len);; 11465 DEBUG_TRACE(""CGI: response: %li"", (signed long)headers_len);; 11466 ; 11467 if (headers_len <= 0) {; 11468 ; 11469 /* Could not parse the CGI response. Check if some error message on; 11470 * stderr. */; 11471 i = pull_all(err, conn, buf, (int)buflen);; 11472 if (i > 0) {; 11473 /* CGI program explicitly sent an error */; 11474 /* Write the error message to the internal log */; 11475 mg_cry_internal(conn,; 11476 ""Error: CGI program \""%s\"" sent error ""; 11477 ""message: [%.*s]"",; 11478 prog,; 11479 i,; 11480 buf);; 11481 /* Don't send the error message back to the client */; 11482 mg_send_http_error(conn,; 11483 500,; 11484 ""Error: CGI program \""%s\"" failed."",; 11485 prog);; 11486 } else {; 11487 /* CGI program did not explicitly send an error, but a broken; 11488 * respon header */; 11489 mg_cry_internal(conn,; 11490 ""Error: CGI program sent malformed or too big ""; 11491 ""(>%u bytes) HTTP headers: [%.*s]"",; 11492 (unsigned)buflen,; 11493 data_len,; 11494 buf);; 11495 ; 11496 mg_send_http_error(conn,; 11497 500,; 11498 ""Error: CGI program sent malformed or too big ""; 11499 ""(>%u bytes) HTTP headers: [%.*s]"",; 11500 (unsigned)buflen,; 11501 data_len,; 11502 buf);; 11503 }; 11504 ; 11505 /* in both cases, abort processing CGI */; 11506 goto done;; 11507 }; 11508 ; 11509 pbuf = buf;; 11510 buf[headers_len - 1] = '\0';; 11511 ri.num_headers = parse_http_headers(&pbuf, ri.http_headers);; 11512 ; 11513 /* Make up and send the status line */; 11514 status_text = ""OK"";; 11515 if ((status = get_header(ri.http_headers, ri.num_headers, ""Status"")); 11516 != ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:332333,error,error,332333,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"0,; 11453 ""Error: Not enough memory for CGI buffer (%u bytes)"",; 11454 (unsigned int)buflen);; 11455 mg_cry_internal(; 11456 conn,; 11457 ""Error: CGI program \""%s\"": Not enough memory for buffer (%u ""; 11458 ""bytes)"",; 11459 prog,; 11460 (unsigned int)buflen);; 11461 goto done;; 11462 }; 11463 ; 11464 DEBUG_TRACE(""CGI: %s"", ""wait for response"");; 11465 headers_len = read_message(out, conn, buf, (int)buflen, &data_len);; 11466 DEBUG_TRACE(""CGI: response: %li"", (signed long)headers_len);; 11467 ; 11468 if (headers_len <= 0) {; 11469 ; 11470 /* Could not parse the CGI response. Check if some error message on; 11471 * stderr. */; 11472 i = pull_all(err, conn, buf, (int)buflen);; 11473 if (i > 0) {; 11474 /* CGI program explicitly sent an error */; 11475 /* Write the error message to the internal log */; 11476 mg_cry_internal(conn,; 11477 ""Error: CGI program \""%s\"" sent error ""; 11478 ""message: [%.*s]"",; 11479 prog,; 11480 i,; 11481 buf);; 11482 /* Don't send the error message back to the client */; 11483 mg_send_http_error(conn,; 11484 500,; 11485 ""Error: CGI program \""%s\"" failed."",; 11486 prog);; 11487 } else {; 11488 /* CGI program did not explicitly send an error, but a broken; 11489 * respon header */; 11490 mg_cry_internal(conn,; 11491 ""Error: CGI program sent malformed or too big ""; 11492 ""(>%u bytes) HTTP headers: [%.*s]"",; 11493 (unsigned)buflen,; 11494 data_len,; 11495 buf);; 11496 ; 11497 mg_send_http_error(conn,; 11498 500,; 11499 ""Error: CGI program sent malformed or too big ""; 11500 ""(>%u bytes) HTTP headers: [%.*s]"",; 11501 (unsigned)buflen,; 11502 data_len,; 11503 buf);; 11504 }; 11505 ; 11506 /* in both cases, abort processing CGI */; 11507 goto done;; 11508 }; 11509 ; 11510 pbuf = buf;; 11511 buf[headers_len - 1] = '\0';; 11512 ri.num_headers = parse_http_headers(&pbuf, ri.http_headers);; 11513 ; 11514 /* Make up and send the status line */; 11515 status_text = ""OK"";; 11516 if ((status = get_header(ri.http_headers, ri.num_headers, ""Status"")); 11517 != ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:332366,error,error,332366,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"0,Relative) ;; 1660 pc.defineSet(""sliceSet"",""SliceVars"",0) ;; 1661 pc.defineObject(""sliceCatList"",""SliceCat"",0,nullptr,true) ;; 1662 // This dummy is needed for plotOn to recognize the ""SliceCatMany"" command.; 1663 // It is not used directly, but the ""SliceCat"" commands are nested in it.; 1664 // Removing this dummy definition results in ""ERROR: unrecognized command: SliceCatMany"".; 1665 pc.defineObject(""dummy1"",""SliceCatMany"",0) ;; 1666 pc.defineSet(""projSet"",""Project"",0) ;; 1667 pc.defineObject(""asymCat"",""Asymmetry"",0) ;; 1668 pc.defineDouble(""precision"",""Precision"",0,1e-3) ;; 1669 pc.defineDouble(""evalErrorVal"",""EvalErrorValue"",0,0) ;; 1670 pc.defineInt(""doEvalError"",""EvalErrorValue"",0,0) ;; 1671 pc.defineInt(""shiftToZero"",""ShiftToZero"",0,0) ;; 1672 pc.defineSet(""projDataSet"",""ProjData"",0) ;; 1673 pc.defineObject(""projData"",""ProjData"",1) ;; 1674 pc.defineObject(""errorFR"",""VisualizeError"",0) ;; 1675 pc.defineDouble(""errorZ"",""VisualizeError"",0,1.) ;; 1676 pc.defineSet(""errorPars"",""VisualizeError"",0) ;; 1677 pc.defineInt(""linearMethod"",""VisualizeError"",0,0) ;; 1678 pc.defineInt(""binProjData"",""ProjData"",0,0) ;; 1679 pc.defineDouble(""rangeLo"",""Range"",0,-999.) ;; 1680 pc.defineDouble(""rangeHi"",""Range"",1,-999.) ;; 1681 pc.defineInt(""numee"",""PrintEvalErrors"",0,10) ;; 1682 pc.defineInt(""rangeAdjustNorm"",""Range"",0,0) ;; 1683 pc.defineInt(""rangeWNAdjustNorm"",""RangeWithName"",0,0) ;; 1684 pc.defineInt(""VLines"",""VLines"",0,2) ; // 2==ExtendedWings; 1685 pc.defineString(""rangeName"",""RangeWithName"",0,"""") ;; 1686 pc.defineString(""normRangeName"",""NormRange"",0,"""") ;; 1687 pc.defineInt(""markerColor"",""MarkerColor"",0,-999) ;; 1688 pc.defineInt(""markerStyle"",""MarkerStyle"",0,-999) ;; 1689 pc.defineDouble(""markerSize"",""MarkerSize"",0,-999) ;; 1690 pc.defineInt(""lineColor"",""LineColor"",0,-999) ;; 1691 pc.defineInt(""lineStyle"",""LineStyle"",0,-999) ;; 1692 pc.defineInt(""lineWidth"",""LineWidth"",0,-999) ;; 1693 pc.defineInt(""fillColor"",""FillColor"",0,-999) ;; 1694 pc.defineInt(""fillStyle"",""FillStyle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:72701,error,errorPars,72701,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['errorPars']
Availability,"0,sizeof(Double_t)*fBufferSize);; 1342}; 1343 ; 1344////////////////////////////////////////////////////////////////////////////////; 1345/// Set option to compute profile3D errors.; 1346///; 1347/// The computation of the bin errors is based on the parameter option:; 1348/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; 1349/// i.e. the standard error of the bin contents.; 1350/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1351/// the spread in T is 0 and the number of bin entries is > 0; 1352/// - 's' The bin errors are the standard deviations of the T bin values; 1353/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1354/// the spread in T is 0 and the number of bin entries is > 0; 1355/// - 'i' Errors are as in default case (standard errors of the bin contents); 1356/// The only difference is for the case when the spread in T is zero.; 1357/// In this case for N > 0 the error is 1./SQRT(12.*N); 1358/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1359/// W is the sum in the bin of the weights of the profile.; 1360/// This option is for combining measurements t +/- dt,; 1361/// and the profile is filled with values t and weights w = 1/dt**2; 1362///; 1363/// See TProfile::BuildOptions for explanation of all options; 1364 ; 1365void TProfile3D::SetErrorOption(Option_t *option); 1366{; 1367 TProfileHelper::SetErrorOption(this, option);; 1368}; 1369 ; 1370////////////////////////////////////////////////////////////////////////////////; 1371/// Create/Delete structure to store sum of squares of weights per bin; 1372/// This is needed to compute the correct statistical quantities; 1373/// of a profile filled with weights; 1374///; 1375/// This function is automatically called when the histogram is created; 1376/// if the static function TH1::SetDefaultSumw2 has been called before.; 1377/// If flag = false the structure is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:51519,error,error,51519,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,1,['error'],['error']
Availability,"0,sizeof(Double_t)*fBufferSize);; 1753}; 1754 ; 1755////////////////////////////////////////////////////////////////////////////////; 1756/// Set option to compute profile errors.; 1757///; 1758/// The computation of the bin errors is based on the parameter option:; 1759///; 1760/// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; 1761/// i.e. the standard error of the bin contents.; 1762/// Note that if TProfile::Approximate() is called, an approximation is used when; 1763/// the spread in Y is 0 and the number of bin entries is > 0; 1764/// -'s' The bin errors are the standard deviations of the Y bin values; 1765/// Note that if TProfile::Approximate() is called, an approximation is used when; 1766/// the spread in Y is 0 and the number of bin entries is > 0; 1767/// -'i' Errors are as in default case (standard errors of the bin contents); 1768/// The only difference is for the case when the spread in Y is zero.; 1769/// In this case for N > 0 the error is 1./SQRT(12.*N); 1770/// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1771/// W is the sum in the bin of the weights of the profile.; 1772/// This option is for combining measurements y +/- dy,; 1773/// and the profile is filled with values y and weights w = 1/dy**2; 1774///; 1775/// See TProfile::BuildOptions for a detailed explanation of all options; 1776 ; 1777void TProfile::SetErrorOption(Option_t *option); 1778{; 1779 TProfileHelper::SetErrorOption(this, option);; 1780}; 1781 ; 1782////////////////////////////////////////////////////////////////////////////////; 1783/// Stream an object of class TProfile.; 1784 ; 1785void TProfile::Streamer(TBuffer &R__b); 1786{; 1787 if (R__b.IsReading()) {; 1788 UInt_t R__s, R__c;; 1789 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 1790 if (R__v > 2) {; 1791 R__b.ReadClassBuffer(TProfile::Class(), this, R__v, R__s, R__c);; 1792 return;; 1793 }; 1794 //====process old versions before automatic schema ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:64627,error,error,64627,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,1,['error'],['error']
Availability,"0.0, . Double_t ; oneOverZeroError = 0.0, . const TH2 * ; hist_vyy = nullptr, . const TH2 * ; hist_vyy_inv = nullptr . ). virtual . Define input data for subsequent calls to DoUnfold(tau) ; Parameters. [in]inputinput distribution with uncertainties ; [in]scaleBias(default=nullptr) scale factor applied to the bias ; [in]oneOverZeroError(default=nullptr) for bins with zero error, this number defines 1/error. ; [in]hist_vyy(default=nullptr) if non-zero, this defines the data covariance matrix ; [in]hist_vyy_inv(default=nullptr) if non-zero and hist_vyy is set, defines the inverse of the data covariance matrix. This feature can be useful for repeated unfoldings in cases where the inversion of the input covariance matrix is lengthy. Return value: nError1+10000*nError2 . nError1: number of bins where the uncertainty is zero. these bins either are not used for the unfolding (if oneOverZeroError==nullptr) or 1/uncertainty is set to oneOverZeroError. . nError2: return values>10000 are fatal errors, because the unfolding can not be done. The number nError2 corresponds to the number of truth bins which are not constrained by data points. . Reimplemented in TUnfoldSys.; Definition at line 2274 of file TUnfold.cxx. ◆ Streamer(). void TUnfold::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TUnfoldDensity, and TUnfoldSys. ◆ StreamerNVirtual(). void TUnfold::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 357 of file TUnfold.h. Member Data Documentation. ◆ fA. TMatrixDSparse* TUnfold::fA. protected . response matrix A ; Definition at line 154 of file TUnfold.h. ◆ fAx. TMatrixDSparse* TUnfold::fAx. private . result x folded back A*x ; Definition at line 191 of file TUnfold.h. ◆ fBiasScale. Double_t TUnfold::fBiasScale. protected . scale factor for the bias ; Definition at line 162 of file TUnfold.h. ◆ fChi2A. Double_t TUnfold::fChi2A. private . chi**2 co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:58514,error,errors,58514,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,1,['error'],['errors']
Availability,"0.00000000001244332, 0.00000000000182256,; 129 -0.00000000000027007, 0.00000000000004042,-0.00000000000000610,; 130 0.00000000000000093,-0.00000000000000014, 0.00000000000000002};; 131 ; 132 Double_t t,h,y,s,a,alfa,b1,b2,b0;; 133 t=h=y=s=a=alfa=b1=b2=b0=0.;; 134 ; 135 if (x == 1) {; 136 h = pi6;; 137 } else if (x == -1) {; 138 h = -pi12;; 139 } else {; 140 t = -x;; 141 if (t <= -2) {; 142 y = -1/(1+t);; 143 s = 1;; 144 b1= TMath::Log(-t);; 145 b2= TMath::Log(1+1/t);; 146 a = -pi3+hf*(b1*b1-b2*b2);; 147 } else if (t < -1) {; 148 y = -1-t;; 149 s = -1;; 150 a = TMath::Log(-t);; 151 a = -pi6+a*(a+TMath::Log(1+1/t));; 152 } else if (t <= -0.5) {; 153 y = -(1+t)/t;; 154 s = 1;; 155 a = TMath::Log(-t);; 156 a = -pi6+a*(-hf*a+TMath::Log(1+t));; 157 } else if (t < 0) {; 158 y = -t/(1+t);; 159 s = -1;; 160 b1= TMath::Log(1+t);; 161 a = hf*b1*b1;; 162 } else if (t <= 1) {; 163 y = t;; 164 s = 1;; 165 a = 0;; 166 } else {; 167 y = 1/t;; 168 s = -1;; 169 b1= TMath::Log(t);; 170 a = pi6+hf*b1*b1;; 171 }; 172 h = y+y-1;; 173 alfa = h+h;; 174 b1 = 0;; 175 b2 = 0;; 176 for (Int_t i=19;i>=0;i--){; 177 b0 = c[i] + alfa*b1-b2;; 178 b2 = b1;; 179 b1 = b0;; 180 }; 181 h = -(s*(b0-h*b2)+a);; 182 }; 183 return h;; 184}; 185 ; 186////////////////////////////////////////////////////////////////////////////////; 187/// Computation of the error function erf(x).; 188/// Erf(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between 0 and x; 189 ; 190Double_t TMath::Erf(Double_t x); 191{; 192 return ::ROOT::Math::erf(x);; 193}; 194 ; 195////////////////////////////////////////////////////////////////////////////////; 196/// Computes the complementary error function erfc(x).; 197/// Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity; 198 ; 199Double_t TMath::Erfc(Double_t x); 200{; 201 return ::ROOT::Math::erfc(x);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Returns the inverse error function.; 206/// x must be <-1<x<1; 207 ; 208D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:5475,error,error,5475,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['error'],['error']
Availability,0.00175028 43608.4 4; : 944 | 3.87035 5.70718 0.0200345 0.0017513 43756.1 5; : 945 | 4.07017 5.95519 0.020321 0.00177709 43140.8 6; : 946 Minimum Test error found - save the configuration ; : 946 | 4.03451 5.59581 0.0201405 0.00182817 43686.3 0; : 947 | 3.85593 5.66203 0.0200425 0.00175434 43744.1 1; : 948 Minimum Test error found - save the configuration ; : 948 | 3.86683 5.35682 0.0204778 0.00185498 42958.2 0; : 949 Minimum Test error found - save the configuration ; : 949 | 3.68334 5.31467 0.0201988 0.00181717 43521.8 0; : 950 | 3.73312 5.52286 0.0201437 0.00175576 43506.8 1; : 951 | 3.85908 5.35112 0.0203536 0.00178284 43078.6 2; : 952 | 3.97296 5.91801 0.0201499 0.00177356 43534.3 3; : 953 Minimum Test error found - save the configuration ; : 953 | 3.78482 5.22353 0.0202416 0.0018489 43495.5 0; : 954 | 3.77661 6.79704 0.0200822 0.00176597 43677.1 1; : 955 | 4.26211 5.70833 0.020048 0.0017647 43755.8 2; : 956 | 3.83703 5.25865 0.0200643 0.00176603 43720 3; : 957 Minimum Test error found - save the configuration ; : 957 | 3.70429 5.19606 0.0204948 0.00189018 43000 0; : 958 | 3.80095 5.43788 0.0203069 0.00176137 43137.1 1; : 959 Minimum Test error found - save the configuration ; : 959 | 3.68258 5.15386 0.0202548 0.00182461 43407 0; : 960 Minimum Test error found - save the configuration ; : 960 | 3.74165 4.97436 0.0200851 0.00180832 43771.4 0; : 961 | 3.60053 5.18492 0.0200347 0.00175376 43761.4 1; : 962 | 4.06747 4.98756 0.0202606 0.00194113 43669.3 2; : 963 | 3.72111 5.2317 0.020058 0.00176556 43733.9 3; : 964 | 3.60317 5.20936 0.020113 0.00175786 43584.5 4; : 965 | 3.63413 5.37485 0.0201057 0.00175921 43605 5; : 966 | 3.74764 5.16986 0.0200985 0.00180899 43741 6; : 967 | 3.64317 5.0911 0.0200896 0.00175556 43634.6 7; : 968 Minimum Test error found - save the configuration ; : 968 | 3.75704 4.83525 0.0200988 0.00182012 43766.9 0; : 969 | 3.53402 4.87481 0.020433 0.0017954 42924.1 1; : 970 | 3.39152 4.92875 0.0207012 0.00184125 42417.9 2; : 971 | 3.38481 4.91243,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:110243,error,error,110243,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,0.00175322 43748.2 3; : 843 Minimum Test error found - save the configuration ; : 843 | 7.01613 10.4197 0.0201334 0.00182993 43707.5 0; : 844 | 6.83302 10.8151 0.020039 0.00176037 43767.1 1; : 845 | 6.97518 10.5462 0.0200409 0.00175987 43761.2 2; : 846 | 6.93317 10.5904 0.0200239 0.00176026 43802.8 3; : 847 | 6.86223 10.6492 0.0200268 0.00176058 43796.8 4; : 848 | 7.00201 10.9279 0.0200258 0.00175939 43796.3 5; : 849 | 6.9266 10.4735 0.0200333 0.00176264 43785.9 6; : 850 | 6.72856 10.6877 0.0200521 0.00176189 43739.2 7; : 851 | 6.84236 10.8522 0.0200238 0.00176009 43802.7 8; : 852 Minimum Test error found - save the configuration ; : 852 | 6.78011 10.0733 0.0201111 0.00182524 43749.6 0; : 853 Minimum Test error found - save the configuration ; : 853 | 6.53284 9.90736 0.0201187 0.00181829 43714.8 0; : 854 | 6.67108 10.0768 0.0205443 0.0017732 42618.8 1; : 855 | 6.58878 10.7427 0.0200637 0.00176264 43713.2 2; : 856 | 6.54513 10.3387 0.0200413 0.00176141 43764 3; : 857 Minimum Test error found - save the configuration ; : 857 | 6.43616 9.72218 0.020097 0.00182688 43787.4 0; : 858 | 6.34936 10.0458 0.0200349 0.00176193 43780.5 1; : 859 Minimum Test error found - save the configuration ; : 859 | 6.20554 9.48603 0.0201607 0.00183833 43662.6 0; : 860 | 6.16695 10.0812 0.0200598 0.00175295 43699.5 1; : 861 Minimum Test error found - save the configuration ; : 861 | 6.43224 9.42041 0.0201492 0.00182399 43655.7 0; : 862 | 6.08067 10.0276 0.0200725 0.0017577 43680.5 1; : 863 | 6.34296 10.0575 0.0200642 0.00175521 43694.5 2; : 864 Minimum Test error found - save the configuration ; : 864 | 6.33486 9.34508 0.0201279 0.00182025 43697.5 0; : 865 | 6.18959 10.0219 0.0205128 0.00175205 42642.3 1; : 866 Minimum Test error found - save the configuration ; : 866 | 6.05678 9.24173 0.0204648 0.00182051 42908.5 0; : 867 | 5.92011 9.34278 0.0202303 0.00193747 43733 1; : 868 Minimum Test error found - save the configuration ; : 868 | 5.90509 9.03441 0.0202616 0.0019877 43778.3 0; : 869 | 5.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:102667,error,error,102667,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,0.00175434 43744.1 1; : 948 Minimum Test error found - save the configuration ; : 948 | 3.86683 5.35682 0.0204778 0.00185498 42958.2 0; : 949 Minimum Test error found - save the configuration ; : 949 | 3.68334 5.31467 0.0201988 0.00181717 43521.8 0; : 950 | 3.73312 5.52286 0.0201437 0.00175576 43506.8 1; : 951 | 3.85908 5.35112 0.0203536 0.00178284 43078.6 2; : 952 | 3.97296 5.91801 0.0201499 0.00177356 43534.3 3; : 953 Minimum Test error found - save the configuration ; : 953 | 3.78482 5.22353 0.0202416 0.0018489 43495.5 0; : 954 | 3.77661 6.79704 0.0200822 0.00176597 43677.1 1; : 955 | 4.26211 5.70833 0.020048 0.0017647 43755.8 2; : 956 | 3.83703 5.25865 0.0200643 0.00176603 43720 3; : 957 Minimum Test error found - save the configuration ; : 957 | 3.70429 5.19606 0.0204948 0.00189018 43000 0; : 958 | 3.80095 5.43788 0.0203069 0.00176137 43137.1 1; : 959 Minimum Test error found - save the configuration ; : 959 | 3.68258 5.15386 0.0202548 0.00182461 43407 0; : 960 Minimum Test error found - save the configuration ; : 960 | 3.74165 4.97436 0.0200851 0.00180832 43771.4 0; : 961 | 3.60053 5.18492 0.0200347 0.00175376 43761.4 1; : 962 | 4.06747 4.98756 0.0202606 0.00194113 43669.3 2; : 963 | 3.72111 5.2317 0.020058 0.00176556 43733.9 3; : 964 | 3.60317 5.20936 0.020113 0.00175786 43584.5 4; : 965 | 3.63413 5.37485 0.0201057 0.00175921 43605 5; : 966 | 3.74764 5.16986 0.0200985 0.00180899 43741 6; : 967 | 3.64317 5.0911 0.0200896 0.00175556 43634.6 7; : 968 Minimum Test error found - save the configuration ; : 968 | 3.75704 4.83525 0.0200988 0.00182012 43766.9 0; : 969 | 3.53402 4.87481 0.020433 0.0017954 42924.1 1; : 970 | 3.39152 4.92875 0.0207012 0.00184125 42417.9 2; : 971 | 3.38481 4.91243 0.0205923 0.00181714 42609.4 3; : 972 | 3.49443 4.93416 0.0204303 0.00180084 42942.7 4; : 973 | 3.50169 4.88411 0.0201535 0.00176496 43505.4 5; : 974 | 3.70493 4.95915 0.0200555 0.00176513 43738.9 6; : 975 Minimum Test error found - save the configuration ; : 975 | 3.52504 4.659,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:110523,error,error,110523,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,0.4 0; : 648 Minimum Test error found - save the configuration ; : 648 | 65.1425 47.9895 0.0205925 0.00181541 42605 0; : 649 Minimum Test error found - save the configuration ; : 649 | 64.2291 47.827 0.0205836 0.00185514 42715.8 0; : 650 Minimum Test error found - save the configuration ; : 650 | 63.5181 47.2461 0.0203914 0.00184161 43127.1 0; : 651 Minimum Test error found - save the configuration ; : 651 | 62.641 46.7417 0.020143 0.00182812 43680.3 0; : 652 Minimum Test error found - save the configuration ; : 652 | 61.875 46.3421 0.0201124 0.00182035 43734.8 0; : 653 Minimum Test error found - save the configuration ; : 653 | 61.1155 45.9892 0.0201549 0.00182806 43651.9 0; : 654 | 60.3955 46.5097 0.0201006 0.00177795 43661.9 1; : 655 Minimum Test error found - save the configuration ; : 655 | 59.5776 45.1172 0.0204622 0.00186914 43026.9 0; : 656 Minimum Test error found - save the configuration ; : 656 | 58.5813 44.6814 0.020214 0.00181641 43484.1 0; : 657 Minimum Test error found - save the configuration ; : 657 | 58.1075 44.2582 0.0201216 0.0018139 43697.5 0; : 658 Minimum Test error found - save the configuration ; : 658 | 57.7428 43.9646 0.0201606 0.00184632 43681.8 0; : 659 Minimum Test error found - save the configuration ; : 659 | 56.5877 43.7448 0.0201275 0.00181379 43683.2 0; : 660 Minimum Test error found - save the configuration ; : 660 | 56.1107 42.9226 0.0200887 0.00181275 43773.3 0; : 661 Minimum Test error found - save the configuration ; : 661 | 55.5039 42.6809 0.0201245 0.00180935 43679.7 0; : 662 Minimum Test error found - save the configuration ; : 662 | 54.3572 42.2723 0.0202587 0.00183315 43417.9 0; : 663 Minimum Test error found - save the configuration ; : 663 | 53.566 41.7624 0.0203991 0.00186617 43166.5 0; : 664 Minimum Test error found - save the configuration ; : 664 | 52.9086 41.2393 0.0201899 0.00182999 43573.1 0; : 665 Minimum Test error found - save the configuration ; : 665 | 52.1886 40.6761 0.020181 0.00182542 43583.6 0; : 666 Min,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:84911,error,error,84911,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,0.623882 0.0409529 4288.69 0; : 6 Minimum Test error found - save the configuration ; : 6 | 0.660284 0.667264 0.616834 0.0410715 4342.07 0; : 7 Minimum Test error found - save the configuration ; : 7 | 0.640131 0.636981 0.607427 0.0404816 4409.59 0; : 8 | 0.616397 0.638352 0.60791 0.0403928 4405.16 1; : 9 Minimum Test error found - save the configuration ; : 9 | 0.599679 0.608826 0.606268 0.0407993 4421.11 0; : 10 Minimum Test error found - save the configuration ; : 10 | 0.585295 0.60026 0.604906 0.0402508 4427.48 0; : 11 Minimum Test error found - save the configuration ; : 11 | 0.568589 0.592822 0.598106 0.0406425 4484.6 0; : 12 Minimum Test error found - save the configuration ; : 12 | 0.559657 0.589421 0.600393 0.0404151 4464.46 0; : 13 Minimum Test error found - save the configuration ; : 13 | 0.552318 0.583187 0.601709 0.0405559 4455.11 0; : 14 Minimum Test error found - save the configuration ; : 14 | 0.540541 0.58147 0.593964 0.0401674 4514.29 0; : 15 Minimum Test error found - save the configuration ; : 15 | 0.532596 0.581192 0.589633 0.0399271 4547.88 0; : 16 Minimum Test error found - save the configuration ; : 16 | 0.529842 0.56732 0.599541 0.040336 4470.63 0; : 17 | 0.521737 0.574812 0.603666 0.0406979 4440.75 1; : 18 Minimum Test error found - save the configuration ; : 18 | 0.517445 0.565391 0.598324 0.0405273 4481.92 0; : 19 Minimum Test error found - save the configuration ; : 19 | 0.509836 0.557055 0.617073 0.042121 4348.19 0; : 20 | 0.510257 0.574511 0.617241 0.0402784 4333.04 1; : ; : Elapsed time for training with 3200 events: 12.3 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.22 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.class.C␛[0m; Factory : T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:16851,error,error,16851,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['error'],['error']
Availability,"0.777 -0.839; 3 0.99995 0.259 -0.777 1.000 0.990; 4 0.99980 0.141 -0.839 0.990 1.000; ; #include ""TMinuit.h""; ; float z[5],x[5],y[5],errorz[5];; ; //______________________________________________________________________________; double func(float x,float y,double *par); {; double value=( (par[0]*par[0])/(x*x)-1)/ ( par[1]+par[2]*y-par[3]*y*y);; return value;; }; ; //______________________________________________________________________________; void fcn(int &npar, double *gin, double &f, double *par, int iflag); {; const int nbins = 5;; int i;; ; //calculate chisquare; double chisq = 0;; double delta;; for (i=0;i<nbins; i++) {; delta = (z[i]-func(x[i],y[i],par))/errorz[i];; chisq += delta*delta;; }; f = chisq;; }; ; //______________________________________________________________________________; void Ifit(); {; // The z values; z[0]=1;; z[1]=0.96;; z[2]=0.89;; z[3]=0.85;; z[4]=0.78;; // The errors on z values; float error = 0.01;; errorz[0]=error;; errorz[1]=error;; errorz[2]=error;; errorz[3]=error;; errorz[4]=error;; // the x values; x[0]=1.5751;; x[1]=1.5825;; x[2]=1.6069;; x[3]=1.6339;; x[4]=1.6706;; // the y values; y[0]=1.0642;; y[1]=0.97685;; y[2]=1.13168;; y[3]=1.128654;; y[4]=1.44016;; ; TMinuit *gMinuit = new TMinuit(5); //initialize TMinuit with a maximum of 5 params; gMinuit->SetFCN(fcn);; ; double arglist[10];; int ierflg = 0;; ; arglist[0] = 1;; gMinuit->mnexcm(""SET ERR"", arglist ,1,ierflg);; ; // Set starting values and step sizes for parameters; static double vstart[4] = {3, 1 , 0.1 , 0.01};; static double step[4] = {0.1 , 0.1 , 0.01 , 0.001};; gMinuit->mnparm(0, ""a1"", vstart[0], step[0], 0,0,ierflg);; gMinuit->mnparm(1, ""a2"", vstart[1], step[1], 0,0,ierflg);; gMinuit->mnparm(2, ""a3"", vstart[2], step[2], 0,0,ierflg);; gMinuit->mnparm(3, ""a4"", vstart[3], step[3], 0,0,ierflg);; ; // Now ready for minimization step; arglist[0] = 500;; arglist[1] = 1.;; gMinuit->mnexcm(""MIGRAD"", arglist ,2,ierflg);; ; // Print results; double amin,edm,errdef;; int nvpar,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Ifit_8C.html:4034,error,errorz,4034,doc/master/Ifit_8C.html,https://root.cern,https://root.cern/doc/master/Ifit_8C.html,10,['error'],"['error', 'errorz']"
Availability,"0.8};; 52 auto gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", np, x, y, exl, exh, eylstat, eyhstat);; 53 gme->AddYError(np, eylsys, eyhsys);; 54 gme->SetMarkerStyle(20);; 55 gme->SetLineColor(kRed);; 56 gme->GetAttLine(0)->SetLineColor(kRed);; 57 gme->GetAttLine(1)->SetLineColor(kBlue);; 58 gme->GetAttFill(1)->SetFillStyle(0);; 59 gme->Draw(""APS ; Z ; 5 s=0.5"");; 60}; 61End_Macro; 62*/; 63////////////////////////////////////////////////////////////////////////////////; 64/// TGraphMultiErrors default constructor.; 65 ; 66TGraphMultiErrors::TGraphMultiErrors(); 67 : fNYErrors(0), fSumErrorsMode(TGraphMultiErrors::kOnlyFirst), fExL(nullptr), fExH(nullptr); 68{; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////////; 72/// TGraphMultiErrors default constructor with name and title.; 73 ; 74TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title) : TGraphMultiErrors(); 75{; 76 SetNameTitle(name, title);; 77}; 78 ; 79////////////////////////////////////////////////////////////////////////////////; 80/// TGraphMultiErrors normal constructor with np points and ne y-errors.; 81///; 82/// All values are initialized to 0.; 83 ; 84TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne); 85 : TGraph(np), fNYErrors(ne), fSumErrorsMode(TGraphMultiErrors::kOnlyFirst); 86{; 87 CtorAllocate();; 88}; 89 ; 90////////////////////////////////////////////////////////////////////////////////; 91/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 92///; 93/// All values are initialized to 0.; 94 ; 95TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne); 96 : TGraphMultiErrors(np, ne); 97{; 98 SetNameTitle(name, title);; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////////; 102/// TGraphMultiErrors normal constructor with `np` points and a single y-error.; 103///; 104/// The signature of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:3056,error,errors,3056,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.70799; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.70053 0.692869 0.625222 0.0421632 4287.73 0; : 2 | 0.694153 0.694394 0.638111 0.0419725 4193.66 1; : 3 | 0.689625 0.697522 0.634816 0.0412563 4211.88 2; : 4 | 0.681203 0.694822 0.628686 0.0407413 4252.1 3; : 5 Minimum Test error found - save the configuration ; : 5 | 0.673678 0.681248 0.619972 0.0411822 4319.36 0; : 6 Minimum Test error found - save the configuration ; : 6 | 0.660284 0.667264 0.614022 0.0406714 4360.33 0; : 7 Minimum Test error found - save the configuration ; : 7 | 0.640131 0.636981 0.602694 0.0404119 4446.16 0; : 8 | 0.616397 0.638352 0.610274 0.0409979 4391.54 1; : 9 Minimum Test error found - save the configuration ; : 9 | 0.599679 0.608826 0.618875 0.0405848 4323.09 0; : 10 Minimum Test error found - save the configuration ; : 10 | 0.585295 0.60026 0.603058 0.0404042 4443.23 0; : ; : Elapsed time for training with 3200 events: 6.25 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.214 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: TMVA_DNN for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 1, 1, 300 ) Batch size = 256 Loss function = C; Layer 0 DENSE Layer: ( Input = 300 , Width = 64 ) Ou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:16518,error,error,16518,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['error'],['error']
Availability,"0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.70799; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.70053 0.692869 0.629389 0.0419042 4255.43 0; : 2 | 0.694153 0.694394 0.642643 0.0421501 4163.24 1; : 3 | 0.689625 0.697522 0.642119 0.0416746 4163.58 2; : 4 | 0.681203 0.694822 0.637781 0.0412238 4190.71 3; : 5 Minimum Test error found - save the configuration ; : 5 | 0.673678 0.681248 0.623882 0.0409529 4288.69 0; : 6 Minimum Test error found - save the configuration ; : 6 | 0.660284 0.667264 0.616834 0.0410715 4342.07 0; : 7 Minimum Test error found - save the configuration ; : 7 | 0.640131 0.636981 0.607427 0.0404816 4409.59 0; : 8 | 0.616397 0.638352 0.60791 0.0403928 4405.16 1; : 9 Minimum Test error found - save the configuration ; : 9 | 0.599679 0.608826 0.606268 0.0407993 4421.11 0; : 10 Minimum Test error found - save the configuration ; : 10 | 0.585295 0.60026 0.604906 0.0402508 4427.48 0; : 11 Minimum Test error found - save the configuration ; : 11 | 0.568589 0.592822 0.598106 0.0406425 4484.6 0; : 12 Minimum Test error found - save the configuration ; : 12 | 0.559657 0.589421 0.600393 0.0404151 4464.46 0; : 13 Minimum Test error found - save the configuration ; : 13 | 0.552318 0.583187 0.601709 0.0405559 4455.11 0; : 14 Minimum Test error found - save the configuration ; : 14 | 0.540541 0.58147 0.593964 0.0401674 4514.29 0; : 15 Minimum Test error found - save the configuration ; : 15 | 0.532596 0.581192 0.589633 0.0399271 4547.88 0; : 16 Minimum Test error found - save the configuration ; : 16 | 0.529842 0.56732 0.599541 0.040336 4470.63 0; : 17 | 0.521737 0.574812 0.603666 0.0406979 4440.75 1; : 18 Minimum Test error found - save the configuration ; : 18 | 0.517445 0.565391 0.5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:16183,error,error,16183,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['error'],['error']
Availability,"00 ) Output = ( 1 , 100 , 100 ) Activation Function = Relu; Layer 7 DENSE Layer: ( Input = 100 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity; : Using 1280 events for training and 320 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 119.005; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.881238 0.852851 0.181896 0.0160504 7235.64 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.658204 0.827727 0.182292 0.0161751 7223.84 0; : 3 Minimum Test error found - save the configuration ; : 3 | 0.58547 0.792475 0.182478 0.0158424 7201.32 0; : 4 Minimum Test error found - save the configuration ; : 4 | 0.508772 0.760461 0.18258 0.0158465 7197.11 0; : 5 Minimum Test error found - save the configuration ; : 5 | 0.445197 0.705323 0.183204 0.015935 7174.07 0; : 6 | 0.409018 0.708257 0.18274 0.0151517 7160.42 1; : 7 | 0.369062 0.747523 0.18295 0.0151377 7150.84 2; : 8 | 0.31294 0.740134 0.183339 0.015769 7161.2 3; : 9 | 0.256184 0.756239 0.181088 0.0154708 7245.63 4; : 10 | 0.224257 0.809455 0.18089 0.0153446 7248.78 5; : ; : Elapsed time for training with 1600 events: 1.86 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; TMVA_DNN_CPU : [dataset] : Evaluation of TMVA_DNN_CPU on training sample (1600 events); : Elapsed time for evaluation of 1600 events: 0.0796 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_TMVA_DNN_CPU.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_CNN_Classification_TMVA_DNN_CPU.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:11904,error,error,11904,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['error'],['error']
Availability,"00 *ret = evhdl;; 2601 } else {; 2602 (void)close(evhdl);; 2603 }; 2604 ; 2605 return (void *)ret;; 2606}; 2607 ; 2608 ; 2609static int; 2610event_wait(void *eventhdl); 2611{; 2612 uint64_t u;; 2613 int evhdl, s;; 2614 ; 2615 if (!eventhdl) {; 2616 /* error */; 2617 return 0;; 2618 }; 2619 evhdl = *(int *)eventhdl;; 2620 ; 2621 s = (int)read(evhdl, &u, sizeof(u));; 2622 if (s != sizeof(u)) {; 2623 /* error */; 2624 return 0;; 2625 }; 2626 (void)u; /* the value is not required */; 2627 return 1;; 2628}; 2629 ; 2630 ; 2631static int; 2632event_signal(void *eventhdl); 2633{; 2634 uint64_t u = 1;; 2635 int evhdl, s;; 2636 ; 2637 if (!eventhdl) {; 2638 /* error */; 2639 return 0;; 2640 }; 2641 evhdl = *(int *)eventhdl;; 2642 ; 2643 s = (int)write(evhdl, &u, sizeof(u));; 2644 if (s != sizeof(u)) {; 2645 /* error */; 2646 return 0;; 2647 }; 2648 return 1;; 2649}; 2650 ; 2651 ; 2652static void; 2653event_destroy(void *eventhdl); 2654{; 2655 int evhdl;; 2656 ; 2657 if (!eventhdl) {; 2658 /* error */; 2659 return;; 2660 }; 2661 evhdl = *(int *)eventhdl;; 2662 ; 2663 close(evhdl);; 2664 mg_free(eventhdl);; 2665}; 2666 ; 2667 ; 2668#endif; 2669 ; 2670#endif; 2671 ; 2672 ; 2673#if !defined(__linux__) && !defined(_WIN32) && defined(ALTERNATIVE_QUEUE); 2674 ; 2675struct posix_event {; 2676 pthread_mutex_t mutex;; 2677 pthread_cond_t cond;; 2678 int signaled;; 2679};; 2680 ; 2681 ; 2682static void *; 2683event_create(void); 2684{; 2685 struct posix_event *ret = mg_malloc(sizeof(struct posix_event));; 2686 if (ret == 0) {; 2687 /* out of memory */; 2688 return 0;; 2689 }; 2690 if (0 != pthread_mutex_init(&(ret->mutex), NULL)) {; 2691 /* pthread mutex not available */; 2692 mg_free(ret);; 2693 return 0;; 2694 }; 2695 if (0 != pthread_cond_init(&(ret->cond), NULL)) {; 2696 /* pthread cond not available */; 2697 pthread_mutex_destroy(&(ret->mutex));; 2698 mg_free(ret);; 2699 return 0;; 2700 }; 2701 ret->signaled = 0;; 2702 return (void *)ret;; 2703}; 2704 ; 2705 ; 2706static int; 2707e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:82466,error,error,82466,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"00) = 1.25319; g->IntegralFast(n,x,w,0,5) = 1.25331; g->IntegralFast(n,x,w,0,1000) = 1.25331; g->IntegralFast(n,x,w,0,10000) = 1.25331; g->IntegralFast(n,x,w,0,100000)= 1.253. Double_t Integral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t epsilon = 1e-12); Return Integral of a 2d function in range [ax,bx],[ay,by]. Double_t Integral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t az, Double_t bz, Double_t epsilon = 1e-12); Return Integral of a 3d function in range [ax,bx],[ay,by],[az,bz]. Double_t IntegralError(Double_t a, Double_t b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 1e-12); Return Error on Integral of a parameteric function between a and b; due to the parameter uncertainties.; A pointer to a vector of parameter values and to the elements of the covariance matrix (covmat); can be optionally passed. By default (i.e. when a zero pointer is passed) the current stored; parameter values are used to estimate the integral error together with the covariance matrix; from the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:53445,error,error,53445,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,4,['error'],['error']
Availability,"00);; h1->Fit(""gaus"", ""0"");; h1->GetXaxis()->SetTitle(""x"");; auto rp1 = new TRatioPlot(h1);; rp1->Draw();; rp1->GetLowerRefYaxis()->SetTitle(""ratio"");; rp1->GetUpperRefYaxis()->SetTitle(""entries"");; }; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; c1return c1Definition legend1.C:41; ratioplot2Definition ratioplot2.py:1; . Error options for difference divided by uncertainty and fit residual; The uncertainty that is used in the calculation can be steered by providing options to the option argument. Option Description . errasym Uses calculated asymmetric errors from TH1::GetBinErrorUp/TH1::GetBinErrorLow. Note that you need to set TH1::SetBinErrorOption first . errfunc Uses \( \sqrt{f(x)} \) as the error . The asymmetric error case uses the upper or lower error depending on the relative size of the bin contents, or the bin content and the function value. Access to internal parts; You can access the internal objects that are used to construct the plot via a series of methods. TRatioPlot::GetUpperPad and TRatioPlot::GetLowerPad can be used to draw additional elements on top of the existing ones. TRatioPlot::GetLowerRefGraph returns a reference to the lower pad's graph that is responsible for the range, which enables you to modify the range. Definition at line 43 of file TRatioPlot.h. Public Member Functions;  TRatioPlot ();  TRatioPlot default constructor. ;  ;  TRatioPlot (TH1 *h1, Option_t *option="""", TFitResult *fitres=nullptr);  Constructor for one histogram and a fit. ;  ;  TRatioPlot (TH1 *h1, TH1 *h2, Option_t *option=""pois"");  Constructor for two histograms. ;  ;  TRatioPlot (TH1 *h1, THStack *st, Option_t *option=""pois"");  Constructor which accepts a THStac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRatioPlot.html:6108,error,error,6108,doc/master/classTRatioPlot.html,https://root.cern,https://root.cern/doc/master/classTRatioPlot.html,1,['error'],['error']
Availability,00.3 1; : 1008 | 3.23752 4.46797 0.0204556 0.0017847 42847.4 2; : 1009 | 3.5099 4.04664 0.0203963 0.00177013 42950.3 3; : 1010 | 3.39993 4.32216 0.0201011 0.00176915 43639.8 4; : 1011 | 3.28002 4.35065 0.020045 0.00175269 43734.2 5; : 1012 | 3.24301 4.1309 0.0202482 0.00178612 43332 6; : 1013 | 3.47685 4.13785 0.0205714 0.00178247 42578.3 7; : 1014 | 3.38367 4.59532 0.0203076 0.00178189 43183.2 8; : 1015 Minimum Test error found - save the configuration ; : 1015 | 3.15343 3.81668 0.0204522 0.00185272 43011.9 0; : 1016 | 2.99441 4.01707 0.0202697 0.00183758 43402.5 1; : 1017 | 3.3956 4.54944 0.0201133 0.00176644 43604.1 2; : 1018 | 3.2792 3.85661 0.0202747 0.00181943 43348.2 3; : 1019 | 3.37748 4.22044 0.0208054 0.00183497 42170.8 4; : 1020 | 3.48034 4.07947 0.020447 0.00177824 42852.4 5; : 1021 | 3.50059 4.11275 0.020219 0.00176964 43361.9 6; : 1022 | 3.15174 3.86168 0.0203283 0.00176093 43086.3 7; : 1023 | 3.4694 4.52782 0.0204007 0.00179059 42987.4 8; : 1024 Minimum Test error found - save the configuration ; : 1024 | 3.57333 3.68346 0.0207199 0.00186469 42428.5 0; : 1025 | 3.1448 3.86932 0.020257 0.0018083 43363.6 1; : 1026 | 3.14966 3.71614 0.0204412 0.00177219 42851.8 2; : 1027 Minimum Test error found - save the configuration ; : 1027 | 3.06278 3.47888 0.0204485 0.00186251 43043.1 0; : 1028 | 3.22518 4.06346 0.0201016 0.00179042 43689.3 1; : 1029 | 3.47015 5.10048 0.0212551 0.0017691 41055.1 2; : 1030 | 3.28552 3.92634 0.0200717 0.0017618 43692.2 3; : 1031 | 3.09879 3.64842 0.0200603 0.0017557 43704.9 4; : 1032 | 3.23242 4.45782 0.0201318 0.0017893 43614.6 5; : 1033 Minimum Test error found - save the configuration ; : 1033 | 3.57665 3.43738 0.0206178 0.00193324 42816.1 0; : 1034 | 3.26951 3.4755 0.0201231 0.00175901 43563.3 1; : 1035 | 3.0748 4.32816 0.0202002 0.00180771 43496 2; : 1036 | 3.05868 3.88772 0.0202082 0.00176323 43372.3 3; : 1037 | 3.11243 3.8552 0.0200473 0.00176925 43768.4 4; : 1038 | 2.97479 4.01382 0.020048 0.00176307 43752 5; : 1039 | 3.15714,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:114733,error,error,114733,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"000) = %g\n"",r2);; printf(""g->IntegralFast(n,x,w,0,5) = %g\n"",r3);; printf(""g->IntegralFast(n,x,w,0,1000) = %g\n"",r4);; printf(""g->IntegralFast(n,x,w,0,10000) = %g\n"",r5);; printf(""g->IntegralFast(n,x,w,0,100000)= %g\n"",r6);; delete [] x;; delete [] w;; }. This example produces the following results:. g->Integral(0,5) = 1.25331; g->Integral(0,1000) = 1.25319; g->IntegralFast(n,x,w,0,5) = 1.25331; g->IntegralFast(n,x,w,0,1000) = 1.25331; g->IntegralFast(n,x,w,0,10000) = 1.25331; g->IntegralFast(n,x,w,0,100000)= 1.253. Double_t IntegralError(Double_t a, Double_t b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 0.01); Return Error on Integral of a parameteric function between a and b; due to the parameter uncertainties.; A pointer to a vector of parameter values and to the elements of the covariance matrix (covmat); can be optionally passed. By default (i.e. when a zero pointer is passed) the current stored; parameter values are used to estimate the integral error together with the covariance matrix; from the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF1.html:56025,error,error,56025,root/html602/TF1.html,https://root.cern,https://root.cern/root/html602/TF1.html,2,['error'],['error']
Availability,"000.0;; 10828 }; 10829 }; 10830 ; 10831 request_len = get_http_header_len(buf, *nread);; 10832 ; 10833 while (request_len == 0) {; 10834 /* Full request not yet received */; 10835 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 10836 /* Server is to be stopped. */; 10837 return -1;; 10838 }; 10839 ; 10840 if (*nread >= bufsiz) {; 10841 /* Request too long */; 10842 return -2;; 10843 }; 10844 ; 10845 n = pull_inner(; 10846 fp, conn, buf + *nread, bufsiz - *nread, request_timeout);; 10847 if (n == -2) {; 10848 /* Receive error */; 10849 return -1;; 10850 }; 10851 ; 10852 /* update clock after every read request */; 10853 clock_gettime(CLOCK_MONOTONIC, &last_action_time);; 10854 ; 10855 if (n > 0) {; 10856 *nread += n;; 10857 request_len = get_http_header_len(buf, *nread);; 10858 }; 10859 ; 10860 if ((request_len == 0) && (request_timeout >= 0)) {; 10861 if (mg_difftimespec(&last_action_time, &(conn->req_time)); 10862 > request_timeout) {; 10863 /* Timeout */; 10864 return -1;; 10865 }; 10866 }; 10867 }; 10868 ; 10869 return request_len;; 10870}; 10871 ; 10872 ; 10873#if !defined(NO_CGI) || !defined(NO_FILES); 10874static int; 10875forward_body_data(struct mg_connection *conn, FILE *fp, SOCKET sock, SSL *ssl); 10876{; 10877 const char *expect;; 10878 char buf[MG_BUF_LEN];; 10879 int success = 0;; 10880 ; 10881 if (!conn) {; 10882 return 0;; 10883 }; 10884 ; 10885 expect = mg_get_header(conn, ""Expect"");; 10886 DEBUG_ASSERT(fp != NULL);; 10887 if (!fp) {; 10888 mg_send_http_error(conn, 500, ""%s"", ""Error: NULL File"");; 10889 return 0;; 10890 }; 10891 ; 10892 if ((expect != NULL) && (mg_strcasecmp(expect, ""100-continue"") != 0)) {; 10893 /* Client sent an ""Expect: xyz"" header and xyz is not 100-continue.; 10894 */; 10895 mg_send_http_error(conn, 417, ""Error: Can not fulfill expectation"");; 10896 } else {; 10897 if (expect != NULL) {; 10898 (void)mg_printf(conn, ""%s"", ""HTTP/1.1 100 Continue\r\n\r\n"");; 10899 conn->status_code = 100;; 10900 } else {; 10901 conn->status",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:312184,error,error,312184,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"000.0;; 10829 }; 10830 }; 10831 ; 10832 request_len = get_http_header_len(buf, *nread);; 10833 ; 10834 while (request_len == 0) {; 10835 /* Full request not yet received */; 10836 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 10837 /* Server is to be stopped. */; 10838 return -1;; 10839 }; 10840 ; 10841 if (*nread >= bufsiz) {; 10842 /* Request too long */; 10843 return -2;; 10844 }; 10845 ; 10846 n = pull_inner(; 10847 fp, conn, buf + *nread, bufsiz - *nread, request_timeout);; 10848 if (n == -2) {; 10849 /* Receive error */; 10850 return -1;; 10851 }; 10852 ; 10853 /* update clock after every read request */; 10854 clock_gettime(CLOCK_MONOTONIC, &last_action_time);; 10855 ; 10856 if (n > 0) {; 10857 *nread += n;; 10858 request_len = get_http_header_len(buf, *nread);; 10859 }; 10860 ; 10861 if ((request_len == 0) && (request_timeout >= 0)) {; 10862 if (mg_difftimespec(&last_action_time, &(conn->req_time)); 10863 > request_timeout) {; 10864 /* Timeout */; 10865 return -1;; 10866 }; 10867 }; 10868 }; 10869 ; 10870 return request_len;; 10871}; 10872 ; 10873 ; 10874#if !defined(NO_CGI) || !defined(NO_FILES); 10875static int; 10876forward_body_data(struct mg_connection *conn, FILE *fp, SOCKET sock, SSL *ssl); 10877{; 10878 const char *expect;; 10879 char buf[MG_BUF_LEN];; 10880 int success = 0;; 10881 ; 10882 if (!conn) {; 10883 return 0;; 10884 }; 10885 ; 10886 expect = mg_get_header(conn, ""Expect"");; 10887 DEBUG_ASSERT(fp != NULL);; 10888 if (!fp) {; 10889 mg_send_http_error(conn, 500, ""%s"", ""Error: NULL File"");; 10890 return 0;; 10891 }; 10892 ; 10893 if ((expect != NULL) && (mg_strcasecmp(expect, ""100-continue"") != 0)) {; 10894 /* Client sent an ""Expect: xyz"" header and xyz is not 100-continue.; 10895 */; 10896 mg_send_http_error(conn, 417, ""Error: Can not fulfill expectation"");; 10897 } else {; 10898 if (expect != NULL) {; 10899 (void)mg_printf(conn, ""%s"", ""HTTP/1.1 100 Continue\r\n\r\n"");; 10900 conn->status_code = 100;; 10901 } else {; 10902 conn->status",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:312217,error,error,312217,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"0000000."");; ; auto ptr = std::make_shared<double>();; KahanSum<double> helper(ptr);; ; auto kahanResult = dd.Book<double>(std::move(helper), {""x""});; auto plainResult = dd.Sum<double>({""x""});; ; std::cout << std::setprecision(24) << ""Kahan: "" << *kahanResult << "" Classical: "" << *plainResult << std::endl;; // Outputs: Kahan: 1000000000.00000011920929 Classical: 1000000000; }; d#define d(i)Definition RSha256.hxx:102; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; ROOT::Detail::RDF::RActionImplBase class for action helpers, see RInterface::Book() for more information.Definition RActionImpl.hxx:26; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; ROOT::Math::Chebyshev::Tdouble T(double x)Definition ChebyshevPol.h:34; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; TMVA::TMVAGlob::Initializevoid Initialize(Bool_t useTMVAStyle=kTRUE)Definition tmvaglob.cxx:176; v@ vDefinition rootcling_impl.cxx:3699; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345; ; Kahan: 1000000000.00000",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df022__useKahan_8C.html:3032,robust,robust,3032,doc/master/df022__useKahan_8C.html,https://root.cern,https://root.cern/doc/master/df022__useKahan_8C.html,1,['robust'],['robust']
Availability,"000000000000001E-9, double relTol = 1.0000000000000001E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options. » Author: M. Slawinska 08/2007 » Copyright (c) 2007 , LCG ROOT MathLib Team *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html:7239,error,error,7239,root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html,3,"['error', 'toler']","['error', 'tolerance']"
Availability,"000000000000001E-9, double relTol = 1.0000000000000001E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options. » Author: M. Slawinska 08/2007 » Copyright (c) 2007 , LCG ROOT MathLib Team *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__AdaptiveIntegratorMultiDim.html:7239,error,error,7239,root/html604/ROOT__Math__AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__AdaptiveIntegratorMultiDim.html,3,"['error', 'toler']","['error', 'tolerance']"
Availability,"000000000001, Option_t* option = """") const; Overlap checking tool. Check for illegal overlaps within a limit OVLP.; Use option=""s[number]"" to force overlap checking by sampling volume with; [number] points.; Ex: myVol->CheckOverlaps(0.01, ""s10000000""); // shoot 10000000 points; myVol->CheckOverlaps(0.01, ""s""); // shoot the default value of 1e6 points. void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); Tests for checking the shape navigation algorithms. See TGeoShape::CheckShape(). void CleanAll(); Clean data of the volume. void ClearShape(); Clear the shape of this volume from the list held by the current manager. void CheckShapes(); check for negative parameters in shapes.; THIS METHOD LEAVES SOME GARBAGE NODES -> memory leak, to be fixed; printf(""---Checking daughters of volume %s\n"", GetName());. Int_t CountNodes(Int_t nlevels = 1000, Int_t option = 0); Count total number of subnodes starting from this volume, nlevels down; option = 0 (default) - count only once per volume; option = 1 - count every time; option = 2 - count volumes on visible branches; option = 3 - return maximum level counted already with option = 0. Bool_t IsAllInvisible() const; Return TRUE if volume and all daughters are invisible. void InvisibleAll(Bool_t flag = kTRUE); Make volume and each of it daughters (in)visible. Bool_t IsFolder() const; Return TRUE if volume contains nodes; return (GetNdaughters()?kTRUE:kFALSE);. Bool_t IsStyleDefault() const; check if the visibility and attributes are the default ones. Bool_t IsTopVolume() const; True if this is the top volume of the geometry. Bool_t IsRaytracing() const; Check if the painter is currently ray-tracing the content of this volume. void InspectMaterial() const; Inspect the material for this volume. TGeoVolume * Import(const char* filename, const char* name = """", Option_t* option = """"); Import a volume from a file. Int_t Export(const char* filename, const char* name = """", Option_t* option = """"); Export this volume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolume.html:35287,down,down,35287,root/html602/TGeoVolume.html,https://root.cern,https://root.cern/root/html602/TGeoVolume.html,2,['down'],['down']
Availability,"000000001, Option_t* option = """")MENU ; voidCheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCountDaughters(Bool_t unique_volumes = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawOnly(Option_t* option = """"); voidDrawOverlaps(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); voidFillIdArray(Int_t& ifree, Int_t& nodeid, Int_t* array) const; Int_tFindNode(const TGeoNode* node, Int_t level); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetByteCount() const; Int_tGetColour() const; TGeoNode*GetDaughter(Int_t ind) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TGeoPatternFinder*GetFinder() const; TGeoExtension*GetFWExtension() const; virtual const char*TObject::GetIconName() const; virtual Int_tGetIndex() const; virtual TGeoMatrix*GetMatrix() const; TGeoMedium*GetMedium() const; TGeoVolume*GetMotherVolume() const; virtual const char*TNamed::GetName() const; Int_tGetNdaughters() const; TObjArray*GetNodes() const; Int_tGetNumber() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoNode.html:4642,error,error,4642,root/html602/TGeoNode.html,https://root.cern,https://root.cern/root/html602/TGeoNode.html,2,['error'],['error']
Availability,"0000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase&, const vector<double>&, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const vector<double>&, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnUserCovariance&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnUserCovariance&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::MnFcn&, const ROOT::Minuit2::GradientCalculator&, const ROOT::Minuit2::MinimumSeed&, const ROOT::Minuit2::MnStrategy&, unsigned int, double) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase&, const vector<double>&, unsigned int, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__ModularFunctionMinimizer.html:2401,toler,toler,2401,root/html602/ROOT__Minuit2__ModularFunctionMinimizer.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__ModularFunctionMinimizer.html,2,['toler'],['toler']
Availability,"000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TMultiDimFit ();  Empty CTOR. Do not use. ;  ;  TMultiDimFit (Int_t dimension, EMDFPolyType type=kMonomials, Option_t *option="""");  Constructor Second argument is the type of polynomials to use in parameterisation, one of: TMultiDimFit::kMonomials TMultiDimFit::kChebyshev TMultiDimFit::kLegendre. ;  ;  ~TMultiDimFit () override;  Destructor. ;  ; virtual void AddRow (const Double_t *x, Double_t D, Double_t E=0);  Add a row consisting of fNVariables independent variables, the known, dependent quantity, and optionally, the square error in the dependent quantity, to the training sample to be used for the parameterization. ;  ; virtual void AddTestRow (const Double_t *x, Double_t D, Double_t E=0);  Add a row consisting of fNVariables independent variables, the known, dependent quantity, and optionally, the square error in the dependent quantity, to the test sample to be used for the test of the parameterization. ;  ; void Browse (TBrowser *b) override;  Browse the TMultiDimFit object in the TBrowser. ;  ; void Clear (Option_t *option="""") override;  Clear internal structures and variables. ;  ; void Draw (Option_t *=""d"") override;  Default Draw method for all objects. ;  ; virtual Double_t Eval (const Double_t *x, const Double_t *coeff=nullptr) const;  Evaluate parameterization at point x. ;  ; virtual Double_t EvalError (const Double_t *x, const Double_t *coeff=nullptr) const;  Evaluate parameterization error at point x. ;  ; virtual void FindParameterization (Opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:19062,error,error,19062,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['error'],['error']
Availability,"0000;i++) {; h1->Fill(r.Gaus(-55,10));; h2->Fill(r.Gaus(55,10));; h3->Fill(r.Gaus(0,10));; }. TList *list = new TList;; list->Add(h1);; list->Add(h2);; list->Add(h3);; TH1F *h = (TH1F*)h1->Clone(""h"");; h->Reset();; h.Merge(list);; h->Draw();; }. void Multiply(TF1* h1, Double_t c1 = 1); Performs the operation: this = this*c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Multiply(const TH1* h1); -*-*-*-*-*-*-*-*-*Multiply this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this*h1. If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this histogram by multiplication of h1 by h2*-*. this = (c1*h1)*(c2*h2). If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Paint(Option_t* option = """"); -*-*-*-*-*-*-*Control routine to paint any kind of histograms*-*-*-*-*-*-*. This function is automatically called by TCanvas::Update.; (see TH1::Draw for the list of options). TH1 * Rebin(Int_t ngroup = 2, const char* newname = """", const Double_t* xb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:93283,error,errors,93283,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,3,['error'],['errors']
Availability,"001) const; static Double_tTF1::DerivativeError(); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTF1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTF1::Draw(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF12.html:2743,error,error,2743,root/html604/TF12.html,https://root.cern,https://root.cern/root/html604/TF12.html,1,['error'],['error']
Availability,00175928 43792 2; : 899 Minimum Test error found - save the configuration ; : 899 | 5.1416 7.3348 0.0201215 0.00182199 43717.1 0; : 900 | 4.88699 7.46821 0.0200416 0.0017612 43762.6 1; : 901 Minimum Test error found - save the configuration ; : 901 | 4.92918 7.2702 0.0200754 0.00181642 43814.2 0; : 902 Minimum Test error found - save the configuration ; : 902 | 5.04871 7.17895 0.0200791 0.00180807 43785.1 0; : 903 | 4.88551 7.21813 0.0200213 0.00174992 43784.3 1; : 904 | 4.98683 7.44507 0.0200553 0.00174858 43699.9 2; : 905 | 4.82992 7.45009 0.0202406 0.00175807 43284.1 3; : 906 | 4.86112 7.78644 0.0202162 0.00175457 43333 4; : 907 Minimum Test error found - save the configuration ; : 907 | 4.76534 7.04169 0.0202678 0.00183052 43390.4 0; : 908 | 4.77659 7.36078 0.0201903 0.00174867 43380.2 1; : 909 | 5.40526 9.09975 0.0204121 0.00175613 42881.7 2; : 910 | 5.23108 7.3695 0.0200572 0.0017555 43711.7 3; : 911 | 4.9718 7.21676 0.0200739 0.00175828 43678.5 4; : 912 Minimum Test error found - save the configuration ; : 912 | 4.64478 6.77041 0.0201181 0.00182552 43733.5 0; : 913 | 4.96617 7.29752 0.0200675 0.00175608 43688.5 1; : 914 | 4.79524 7.25946 0.0200357 0.00175682 43766.4 2; : 915 Minimum Test error found - save the configuration ; : 915 | 4.5624 6.6787 0.0201058 0.0018145 43736.7 0; : 916 Minimum Test error found - save the configuration ; : 916 | 4.49553 6.65717 0.0201015 0.00180949 43734.9 0; : 917 Minimum Test error found - save the configuration ; : 917 | 4.36563 6.60613 0.0201007 0.00181415 43748 0; : 918 Minimum Test error found - save the configuration ; : 918 | 4.47049 6.3479 0.0200865 0.00182018 43796.4 0; : 919 | 4.35846 6.60136 0.0200632 0.00176343 43716.3 1; : 920 | 4.30933 6.53557 0.0200239 0.00175965 43801.4 2; : 921 Minimum Test error found - save the configuration ; : 921 | 4.32266 6.29119 0.0200952 0.00182605 43789.5 0; : 922 | 4.32742 6.39561 0.0200257 0.00176292 43804.9 1; : 923 | 4.33774 6.46608 0.0200201 0.00176071 43813 2; : 924 | 4.36503 6.31,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:106879,error,error,106879,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,00176071 43813 2; : 924 | 4.36503 6.3111 0.0200702 0.00177545 43728.3 3; : 925 | 4.7314 7.24632 0.0202093 0.00176259 43368.2 4; : 926 | 4.61316 6.64099 0.020249 0.00181216 43391.3 5; : 927 Minimum Test error found - save the configuration ; : 927 | 4.41727 6.09792 0.0203192 0.00184107 43294.4 0; : 928 | 4.15393 6.23618 0.0200677 0.00177036 43722.3 1; : 929 | 4.2848 6.29195 0.0202769 0.00175908 43201.6 2; : 930 | 4.39879 6.60248 0.0204218 0.00176177 42872.3 3; : 931 | 4.17549 6.55946 0.0200581 0.00175886 43717.6 4; : 932 | 4.18849 6.67063 0.0200652 0.00175543 43692.5 5; : 933 Minimum Test error found - save the configuration ; : 933 | 4.07608 6.08713 0.0202588 0.00184594 43447.8 0; : 934 | 4.3998 6.10426 0.0204691 0.00178412 42815.1 1; : 935 | 4.23034 6.39854 0.0202977 0.00176426 43165.2 2; : 936 Minimum Test error found - save the configuration ; : 936 | 4.45077 5.93539 0.020128 0.0018336 43729.3 0; : 937 | 4.31583 6.35935 0.0203501 0.00176302 43040.6 1; : 938 Minimum Test error found - save the configuration ; : 938 | 4.1293 5.8271 0.0205749 0.0018749 42780.8 0; : 939 Minimum Test error found - save the configuration ; : 939 | 4.02273 5.7049 0.0206164 0.00186577 42665.2 0; : 940 | 3.91188 6.29174 0.0201055 0.00180854 43723.1 1; : 941 | 3.89757 5.80965 0.0203179 0.00179759 43195.8 2; : 942 | 3.94904 5.73464 0.0200877 0.00175468 43637.1 3; : 943 | 3.90362 5.73888 0.0200954 0.00175028 43608.4 4; : 944 | 3.87035 5.70718 0.0200345 0.0017513 43756.1 5; : 945 | 4.07017 5.95519 0.020321 0.00177709 43140.8 6; : 946 Minimum Test error found - save the configuration ; : 946 | 4.03451 5.59581 0.0201405 0.00182817 43686.3 0; : 947 | 3.85593 5.66203 0.0200425 0.00175434 43744.1 1; : 948 Minimum Test error found - save the configuration ; : 948 | 3.86683 5.35682 0.0204778 0.00185498 42958.2 0; : 949 Minimum Test error found - save the configuration ; : 949 | 3.68334 5.31467 0.0201988 0.00181717 43521.8 0; : 950 | 3.73312 5.52286 0.0201437 0.00175576 43506.8 1; : 951 | 3.85908 5.35,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:108842,error,error,108842,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,00176171 43266.9 2; : 871 Minimum Test error found - save the configuration ; : 871 | 5.78015 8.79318 0.0200883 0.00182097 43794.1 0; : 872 | 5.76603 9.46642 0.0200354 0.00176138 43778.1 1; : 873 Minimum Test error found - save the configuration ; : 873 | 5.70638 8.71803 0.0200731 0.00181478 43815.7 0; : 874 Minimum Test error found - save the configuration ; : 874 | 5.53455 8.53383 0.0201925 0.00181685 43535.8 0; : 875 | 5.74708 8.69754 0.0202376 0.00177647 43334.2 1; : 876 | 5.6794 9.00589 0.0202045 0.00176006 43373.5 2; : 877 | 5.64383 8.64736 0.0203248 0.00179972 43184.7 3; : 878 Minimum Test error found - save the configuration ; : 878 | 5.55379 8.16524 0.0206602 0.00187795 42593.5 0; : 879 | 5.63754 8.31065 0.0203728 0.00175638 42972.7 1; : 880 | 5.71571 8.37499 0.0201251 0.00178041 43609.3 2; : 881 | 5.7556 8.5037 0.0200424 0.00175411 43743.8 3; : 882 | 5.47815 8.64255 0.0200508 0.00175977 43737.3 4; : 883 | 5.49484 8.19099 0.0201663 0.00175135 43443 5; : 884 Minimum Test error found - save the configuration ; : 884 | 5.44144 8.14796 0.020157 0.00182376 43636.7 0; : 885 | 5.72885 9.21369 0.0207466 0.00176462 42145.2 1; : 886 | 5.67418 8.64993 0.0200759 0.00176094 43680.2 2; : 887 Minimum Test error found - save the configuration ; : 887 | 5.55202 8.05484 0.0201465 0.00184145 43703.7 0; : 888 Minimum Test error found - save the configuration ; : 888 | 5.4009 7.86368 0.0201494 0.00184759 43711.4 0; : 889 | 5.09006 7.93881 0.0200766 0.00176618 43691 1; : 890 | 5.16257 8.05551 0.0200625 0.00176866 43730.7 2; : 891 Minimum Test error found - save the configuration ; : 891 | 5.07326 7.82028 0.0201532 0.0018382 43680.1 0; : 892 | 5.14088 7.89491 0.0200852 0.00179174 43731.4 1; : 893 Minimum Test error found - save the configuration ; : 893 | 5.13302 7.67646 0.0201541 0.00183919 43680.3 0; : 894 | 5.44229 7.83993 0.0200562 0.00176505 43736.9 1; : 895 | 5.40474 8.2327 0.0200223 0.00176151 43809.8 2; : 896 Minimum Test error found - save the configuration ; : 896 | 5.3,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:104749,error,error,104749,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,0018126 43734.4 0; : 706 Minimum Test error found - save the configuration ; : 706 | 30.3399 28.5636 0.0203047 0.00182247 43284.8 0; : 707 | 29.8899 28.5807 0.0200458 0.00176314 43757.3 1; : 708 | 29.6409 28.6883 0.0201432 0.0017637 43526.7 2; : 709 Minimum Test error found - save the configuration ; : 709 | 29.434 28.2 0.0201313 0.00182437 43699.3 0; : 710 | 28.7076 28.492 0.0200557 0.00176519 43738.5 1; : 711 Minimum Test error found - save the configuration ; : 711 | 28.4018 27.2754 0.0201013 0.00182194 43765.3 0; : 712 | 28.1436 28.1139 0.020041 0.00175734 43754.9 1; : 713 | 27.878 27.4183 0.0200281 0.0017564 43783.5 2; : 714 | 27.4734 27.8632 0.020054 0.00175612 43720.8 3; : 715 Minimum Test error found - save the configuration ; : 715 | 27.1251 26.6487 0.0201232 0.0018277 43726.6 0; : 716 | 26.6302 26.7712 0.0200343 0.00176196 43782.1 1; : 717 Minimum Test error found - save the configuration ; : 717 | 26.542 26.4691 0.020103 0.00182338 43764.7 0; : 718 Minimum Test error found - save the configuration ; : 718 | 25.9613 26.206 0.0200958 0.00181915 43771.6 0; : 719 Minimum Test error found - save the configuration ; : 719 | 25.6965 25.7845 0.0200932 0.00181887 43777.1 0; : 720 Minimum Test error found - save the configuration ; : 720 | 25.279 25.7029 0.0200856 0.00181582 43788.1 0; : 721 | 24.9296 25.8529 0.0200326 0.00176051 43782.6 1; : 722 | 24.8179 25.9725 0.0200485 0.0017542 43729.4 2; : 723 Minimum Test error found - save the configuration ; : 723 | 24.602 25.0488 0.0200826 0.00181241 43787.1 0; : 724 Minimum Test error found - save the configuration ; : 724 | 24.1724 25.032 0.0200931 0.00180717 43749.4 0; : 725 Minimum Test error found - save the configuration ; : 725 | 23.8272 24.7604 0.0201019 0.00180745 43729.1 0; : 726 Minimum Test error found - save the configuration ; : 726 | 23.3507 24.439 0.0200878 0.00180894 43766.5 0; : 727 | 23.4129 26.1943 0.0200349 0.00176004 43776.1 1; : 728 Minimum Test error found - save the configuration ; : 728 | 23.014,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:90788,error,error,90788,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,00182247 43284.8 0; : 707 | 29.8899 28.5807 0.0200458 0.00176314 43757.3 1; : 708 | 29.6409 28.6883 0.0201432 0.0017637 43526.7 2; : 709 Minimum Test error found - save the configuration ; : 709 | 29.434 28.2 0.0201313 0.00182437 43699.3 0; : 710 | 28.7076 28.492 0.0200557 0.00176519 43738.5 1; : 711 Minimum Test error found - save the configuration ; : 711 | 28.4018 27.2754 0.0201013 0.00182194 43765.3 0; : 712 | 28.1436 28.1139 0.020041 0.00175734 43754.9 1; : 713 | 27.878 27.4183 0.0200281 0.0017564 43783.5 2; : 714 | 27.4734 27.8632 0.020054 0.00175612 43720.8 3; : 715 Minimum Test error found - save the configuration ; : 715 | 27.1251 26.6487 0.0201232 0.0018277 43726.6 0; : 716 | 26.6302 26.7712 0.0200343 0.00176196 43782.1 1; : 717 Minimum Test error found - save the configuration ; : 717 | 26.542 26.4691 0.020103 0.00182338 43764.7 0; : 718 Minimum Test error found - save the configuration ; : 718 | 25.9613 26.206 0.0200958 0.00181915 43771.6 0; : 719 Minimum Test error found - save the configuration ; : 719 | 25.6965 25.7845 0.0200932 0.00181887 43777.1 0; : 720 Minimum Test error found - save the configuration ; : 720 | 25.279 25.7029 0.0200856 0.00181582 43788.1 0; : 721 | 24.9296 25.8529 0.0200326 0.00176051 43782.6 1; : 722 | 24.8179 25.9725 0.0200485 0.0017542 43729.4 2; : 723 Minimum Test error found - save the configuration ; : 723 | 24.602 25.0488 0.0200826 0.00181241 43787.1 0; : 724 Minimum Test error found - save the configuration ; : 724 | 24.1724 25.032 0.0200931 0.00180717 43749.4 0; : 725 Minimum Test error found - save the configuration ; : 725 | 23.8272 24.7604 0.0201019 0.00180745 43729.1 0; : 726 Minimum Test error found - save the configuration ; : 726 | 23.3507 24.439 0.0200878 0.00180894 43766.5 0; : 727 | 23.4129 26.1943 0.0200349 0.00176004 43776.1 1; : 728 Minimum Test error found - save the configuration ; : 728 | 23.0149 24.223 0.0201139 0.00181842 43726.6 0; : 729 Minimum Test error found - save the configuration ; : 729 | 22.677,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:90901,error,error,90901,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"001 . ); const. virtual . Returns the first derivative of the function at point x, computed by Richardson's extrapolation method (use 2 derivative estimates to compute a third, more accurate estimation) first, derivatives with steps h and h/2 are computed by central difference formulas. . \[; D(h) = \frac{f(x+h) - f(x-h)}{2h}; \]. the final estimate ; \[; D = \frac{4D(h/2) - D(h)}{3}; \]. ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; if the argument params is null, the current function parameters are used, otherwise the parameters in params are used.; the argument eps may be specified to control the step size (precision). the step size is taken as eps*(xmax-xmin). the default value (0.001) should be good enough for the vast majority of functions. Give a smaller value if your function has many changes of the second derivative in the function range.; Getting the error via TF1::DerivativeError: (total error = roundoff error + interpolation error) the estimate of the roundoff error is taken as follows: ; \[; err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; \]. where k is the double precision, ai are coefficients used in central difference formulas interpolation error is decreased by making the step size h smaller.; AuthorAnna Kreshuk ; Definition at line 1113 of file TF1.cxx. ◆ Derivative2(). Double_t TF1::Derivative2 ; (; Double_t ; x, . Double_t * ; params = nullptr, . Double_t ; eps = 0.001 . ); const. virtual . Returns the second derivative of the function at point x, computed by Richardson's extrapolation method (use 2 derivative estimates to compute a third, more accurate estimation) first, derivatives with steps h and h/2 are computed by central difference formulas. . \[; D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}; \]. the final estimate ; \[; D = \frac{4D(h/2) - D(h)}{3}; \]. ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; if the argument params is null, the current function parameters are used",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:62896,error,error,62896,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,5,['error'],['error']
Availability,"004////////////////////////////////////////////////////////////////////////////////; 2005/// Set number of points to be generated on the shape outline when checking for overlaps.; 2006 ; 2007void TGeoPainter::SetNmeshPoints(Int_t npoints); 2008{; 2009 fChecker->SetNmeshPoints(npoints);; 2010}; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Select a node to be checked for overlaps. All overlaps not involving it will; 2014/// be ignored.; 2015 ; 2016void TGeoPainter::SetCheckedNode(TGeoNode *node); 2017{; 2018 fChecker->SetSelectedNode(node);; 2019}; 2020 ; 2021////////////////////////////////////////////////////////////////////////////////; 2022/// Set default level down to which visualization is performed; 2023 ; 2024void TGeoPainter::SetVisLevel(Int_t level); 2025{; 2026 if (level == fVisLevel && fLastVolume == fTopVolume); 2027 return;; 2028 fVisLevel = level;; 2029 if (!fTopVolume); 2030 return;; 2031 if (fVisLock) {; 2032 ClearVisibleVolumes();; 2033 fVisLock = kFALSE;; 2034 }; 2035 if (!fLastVolume) {; 2036 // printf(""--- Drawing %6d nodes with %d visible levels\n"",fNVisNodes,fVisLevel);; 2037 return;; 2038 }; 2039 if (!gPad); 2040 return;; 2041 if (gPad->GetView()) {; 2042 // printf(""--- Drawing %6d nodes with %d visible levels\n"",fNVisNodes,fVisLevel);; 2043 ModifiedPad();; 2044 }; 2045}; 2046 ; 2047////////////////////////////////////////////////////////////////////////////////; 2048/// Set top geometry volume as visible.; 2049 ; 2050void TGeoPainter::SetTopVisible(Bool_t vis); 2051{; 2052 if (fTopVisible == vis); 2053 return;; 2054 fTopVisible = vis;; 2055 ModifiedPad();; 2056}; 2057 ; 2058////////////////////////////////////////////////////////////////////////////////; 2059/// Set drawing mode :; 2060/// - option=0 (default) all nodes drawn down to vislevel; 2061/// - option=1 leaves and nodes at vislevel drawn; 2062/// - option=2 path is drawn; 2063 ; 2064void TGeoPainter::SetVisOption(Int_t option); 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:66116,down,down,66116,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,1,['down'],['down']
Availability,"00:Layout=DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM:CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|1|300"" [The Layout of the input]; : Layout: ""DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:9929,error,error,9929,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,2,['error'],['error']
Availability,"01 *ret = evhdl;; 2602 } else {; 2603 (void)close(evhdl);; 2604 }; 2605 ; 2606 return (void *)ret;; 2607}; 2608 ; 2609 ; 2610static int; 2611event_wait(void *eventhdl); 2612{; 2613 uint64_t u;; 2614 int evhdl, s;; 2615 ; 2616 if (!eventhdl) {; 2617 /* error */; 2618 return 0;; 2619 }; 2620 evhdl = *(int *)eventhdl;; 2621 ; 2622 s = (int)read(evhdl, &u, sizeof(u));; 2623 if (s != sizeof(u)) {; 2624 /* error */; 2625 return 0;; 2626 }; 2627 (void)u; /* the value is not required */; 2628 return 1;; 2629}; 2630 ; 2631 ; 2632static int; 2633event_signal(void *eventhdl); 2634{; 2635 uint64_t u = 1;; 2636 int evhdl, s;; 2637 ; 2638 if (!eventhdl) {; 2639 /* error */; 2640 return 0;; 2641 }; 2642 evhdl = *(int *)eventhdl;; 2643 ; 2644 s = (int)write(evhdl, &u, sizeof(u));; 2645 if (s != sizeof(u)) {; 2646 /* error */; 2647 return 0;; 2648 }; 2649 return 1;; 2650}; 2651 ; 2652 ; 2653static void; 2654event_destroy(void *eventhdl); 2655{; 2656 int evhdl;; 2657 ; 2658 if (!eventhdl) {; 2659 /* error */; 2660 return;; 2661 }; 2662 evhdl = *(int *)eventhdl;; 2663 ; 2664 close(evhdl);; 2665 mg_free(eventhdl);; 2666}; 2667 ; 2668 ; 2669#endif; 2670 ; 2671#endif; 2672 ; 2673 ; 2674#if !defined(__linux__) && !defined(_WIN32) && defined(ALTERNATIVE_QUEUE); 2675 ; 2676struct posix_event {; 2677 pthread_mutex_t mutex;; 2678 pthread_cond_t cond;; 2679 int signaled;; 2680};; 2681 ; 2682 ; 2683static void *; 2684event_create(void); 2685{; 2686 struct posix_event *ret = mg_malloc(sizeof(struct posix_event));; 2687 if (ret == 0) {; 2688 /* out of memory */; 2689 return 0;; 2690 }; 2691 if (0 != pthread_mutex_init(&(ret->mutex), NULL)) {; 2692 /* pthread mutex not available */; 2693 mg_free(ret);; 2694 return 0;; 2695 }; 2696 if (0 != pthread_cond_init(&(ret->cond), NULL)) {; 2697 /* pthread cond not available */; 2698 pthread_mutex_destroy(&(ret->mutex));; 2699 mg_free(ret);; 2700 return 0;; 2701 }; 2702 ret->signaled = 0;; 2703 return (void *)ret;; 2704}; 2705 ; 2706 ; 2707static int; 2708e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:82498,error,error,82498,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"01 /* Local variables */; 7702 Double_t si;; 7703 Int_t i, j, k, kp1, km1;; 7704 ; 7705 /* Parameter adjustments */; 7706 a_offset = l + 1;; 7707 a -= a_offset;; 7708 ; 7709 /* Function Body */; 7710 ifail = 0;; 7711 if (n < 1) goto L100;; 7712 if (n > fMaxint) goto L100;; 7713// scale matrix by sqrt of diag elements; 7714 for (i = 1; i <= n; ++i) {; 7715 si = a[i + i*l];; 7716 if (si <= 0) goto L100;; 7717 fVERTs[i-1] = 1 / TMath::Sqrt(si);; 7718 }; 7719 for (i = 1; i <= n; ++i) {; 7720 for (j = 1; j <= n; ++j) {; 7721 a[i + j*l] = a[i + j*l]*fVERTs[i-1]*fVERTs[j-1];; 7722 }; 7723 }; 7724// start main loop; 7725 for (i = 1; i <= n; ++i) {; 7726 k = i;; 7727// preparation for elimination step1; 7728 if (a[k + k*l] != 0) fVERTq[k-1] = 1 / a[k + k*l];; 7729 else goto L100;; 7730 fVERTpp[k-1] = 1;; 7731 a[k + k*l] = 0;; 7732 kp1 = k + 1;; 7733 km1 = k - 1;; 7734 if (km1 < 0) goto L100;; 7735 else if (km1 == 0) goto L50;; 7736 else goto L40;; 7737L40:; 7738 for (j = 1; j <= km1; ++j) {; 7739 fVERTpp[j-1] = a[j + k*l];; 7740 fVERTq[j-1] = a[j + k*l]*fVERTq[k-1];; 7741 a[j + k*l] = 0;; 7742 }; 7743L50:; 7744 if (k - n < 0) goto L51;; 7745 else if (k - n == 0) goto L60;; 7746 else goto L100;; 7747L51:; 7748 for (j = kp1; j <= n; ++j) {; 7749 fVERTpp[j-1] = a[k + j*l];; 7750 fVERTq[j-1] = -a[k + j*l]*fVERTq[k-1];; 7751 a[k + j*l] = 0;; 7752 }; 7753// elimination proper; 7754L60:; 7755 for (j = 1; j <= n; ++j) {; 7756 for (k = j; k <= n; ++k) { a[j + k*l] += fVERTpp[j-1]*fVERTq[k-1]; }; 7757 }; 7758 }; 7759// elements of left diagonal and unscaling; 7760 for (j = 1; j <= n; ++j) {; 7761 for (k = 1; k <= j; ++k) {; 7762 a[k + j*l] = a[k + j*l]*fVERTs[k-1]*fVERTs[j-1];; 7763 a[j + k*l] = a[k + j*l];; 7764 }; 7765 }; 7766 return;; 7767// failure return; 7768L100:; 7769 ifail = 1;; 7770}; 7771 ; 7772////////////////////////////////////////////////////////////////////////////////; 7773/// Prints Warning messages; 7774///; 7775/// - If COPT='W', CMES is a WARning message from CORG.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:248225,failure,failure,248225,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['failure'],['failure']
Availability,"01 of file TCondor.cxx. ◆ Class(). static TClass * TCondor::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TCondor::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TCondor::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 88 of file TCondor.h. ◆ DeclFileName(). static const char * TCondor::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 88 of file TCondor.h. ◆ GetImage(). TString TCondor::GetImage ; (; const char * ; host); const. Get image of the worker. ; Definition at line 440 of file TCondor.cxx. ◆ GetState(). EState TCondor::GetState ; (; ); const. inline . Definition at line 79 of file TCondor.h. ◆ GetVirtualMachines(). TList * TCondor::GetVirtualMachines ; (; ); const. Get the names of the virtual machines in the pool. ; Return a TList of TObjString or 0 in case of failure ; Definition at line 194 of file TCondor.cxx. ◆ GetVmInfo(). Bool_t TCondor::GetVmInfo ; (; const char * ; vm, . TString & ; image, . Int_t & ; perfidx . ); const. Get info about worker status. ; Definition at line 401 of file TCondor.cxx. ◆ IsA(). TClass * TCondor::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 88 of file TCondor.h. ◆ IsValid(). Bool_t TCondor::IsValid ; (; ); const. inline . Definition at line 72 of file TCondor.h. ◆ Print(). void TCondor::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print master status. ; Reimplemented from TObject.; Definition at line 89 of file TCondor.cxx. ◆ Release(). Bool_t TCondor::Release ; (; ). Release worker. ; Definition at line 357 of file TCondor.cxx. ◆ Resume(). Bool_t TCondor::Resume ; (; ). Resume worker. ; Definition at line 343 of file TCondor.cxx. ◆ SetState(). Bool_t TCondor::SetState ; (; EState ; state). Set the state ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCondor.html:13444,failure,failure,13444,doc/master/classTCondor.html,https://root.cern,https://root.cern/doc/master/classTCondor.html,1,['failure'],['failure']
Availability,"01) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const vector<double>&, unsigned int, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; ROOT::Minuit2::ModularFunctionMinimizerModularFunctionMinimizer(); ROOT::Minuit2::ModularFunctionMinimizerModularFunctionMinimizer(const ROOT::Minuit2::ModularFunctionMinimizer&); ROOT::Minuit2::ModularFunctionMinimizer&operator=(const ROOT::Minuit2::ModularFunctionMinimizer&); virtual const ROOT::Minuit2::MinimumSeedGenerator&SeedGenerator() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~ModularFunctionMinimizer(); {}. FunctionMinimum Minimize(const FCNBase&, const std::vector<double>&, const std::vector<double>&, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1); inherited interface. FunctionMinimum Minimize(const FCNGradientBase&, const std::vector<double>&, const std::vector<double>&, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase&, const std::vector<double>&, unsigned int, const std::vector<double>&, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNGradientBase&, const std::vector<double>&, unsigned int, const std::vector<double>&, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase&, const MnUserParameters&, const MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1); extension. FunctionMinimum Minimize(const FCNGradientBase&, const MnUserParameters&, const MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase&, const MnUserParameters&, const MnUserCovariance&, const MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNGradientBase&, const MnUserParameters&, const MnUserCovariance&, const MnStra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__ModularFunctionMinimizer.html:4474,toler,toler,4474,root/html602/ROOT__Minuit2__ModularFunctionMinimizer.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__ModularFunctionMinimizer.html,2,['toler'],['toler']
Availability,"01); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSVDUnfold.html:1641,error,error,1641,root/html528/TSVDUnfold.html,https://root.cern,https://root.cern/root/html528/TSVDUnfold.html,2,['error'],['error']
Availability,"01);  Return nth moment of function between a and b. ;  ; template<class T > ; T operator() (const T *x, const Double_t *params=nullptr);  ; virtual Double_t operator() (Double_t x, Double_t y=0, Double_t z=0, Double_t t=0) const;  ; TF1 & operator= (const TF1 &rhs);  Operator =. ;  ; void Paint (Option_t *option="""") override;  Paint this function with its current attributes. ;  ; void Print (Option_t *option="""") const override;  This method must be overridden when a class wants to print itself. ;  ; virtual void ReleaseParameter (Int_t ipar);  Release parameter number ipar during a fit operation. ;  ; virtual void Save (Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax);  Save values of function in array fSave. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save primitive as a C++ statement(s) on output stream out. ;  ; virtual void SetChisquare (Double_t chi2);  ; virtual void SetFitResult (const ROOT::Fit::FitResult &result, const Int_t *indpar=nullptr);  Set the result from the fit parameter values, errors, chi2, etc... Optionally a pointer to a vector (with size fNpar) of the parameter indices in the FitResult can be passed This is useful in the case of a combined fit with different functions, and the FitResult contains the global result By default it is assume that indpar = {0,1,2,....,fNpar-1}. ;  ; template<typename Func > ; void SetFunction (Func f);  ; template<class PtrObj , typename MemFn > ; void SetFunction (PtrObj &p, MemFn memFn);  ; virtual void SetMaximum (Double_t maximum=-1111);  Set the maximum value along Y for this function In case the function is already drawn, set also the maximum in the helper histogram. ;  ; virtual void SetMinimum (Double_t minimum=-1111);  Set the minimum value along Y for this function In case the function is already drawn, set also the minimum in the helper histogram. ;  ; virtual void SetNDF (Int_t ndf);  Set the number of degrees of freedom ndf shoul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:25471,error,errors,25471,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['error'],['errors']
Availability,"01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TProofServLogHandler (const char *cmd, TSocket *s, const char *pfx="""");  Execute 'cmd' in a pipe and handle output messages from the related file. ;  ;  TProofServLogHandler (FILE *f, TSocket *s, const char *pfx="""");  Handle available message from the open file 'f'. ;  ;  ~TProofServLogHandler () override;  Handle available message in the open file. ;  ; Bool_t IsValid ();  ; Bool_t Notify () override;  Handle available message in the open file. ;  ; Bool_t ReadNotify () override;  Notify when something can be read from the descriptor associated with this handler. ;  ;  Public Member Functions inherited from TFileHandler;  TFileHandler (int fd, int mask);  Create a file descriptor event handler. ;  ; virtual ~TFileHandler ();  ; void Add () override;  Add file event handler to system file handler list. ;  ; int GetFd () const;  ; virtual Bool_t HasReadInterest ();  True if handler is interested in read events. ;  ; virtual Bool_t HasWriteInterest ();  True if handler is interested in write events. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsReadReady () const;  ; virtual Bool_t IsWriteReady () const;  ; void Remove () override;  Remove file event handler from system file handler list. ;  ; virtual void ResetReadyMask ();  ; void SetFd (int fd);  ; virtual void SetInterest (Int_t mask);  Set interest mask to 'mask'. ;  ; virtual void SetReadReady ();  ; virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServLogHandler.html:1617,avail,available,1617,doc/master/classTProofServLogHandler.html,https://root.cern,https://root.cern/doc/master/classTProofServLogHandler.html,1,['avail'],['available']
Availability,"0130 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20131 mg_free(ctx->worker_threadids);; 20132 ; 20133 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20134 mg_snprintf(NULL,; 20135 NULL, /* No truncation check for error buffers */; 20136 error->text,; 20137 error->text_buffer_size,; 20138 ""%s"",; 20139 err_msg);; 20140 }; 20141 free_context(ctx);; 20142 pthread_setspecific(sTlsKey, NULL);; 20143 return NULL;; 20144 }; 20145 ; 20146 ctx->client_socks =; 20147 (struct socket *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20148 sizeof(ctx->client_socks[0]),; 20149 ctx);; 20150 if (ctx->client_socks == NULL) {; 20151 const char *err_msg = ""Not enough memory for worker socket array"";; 20152 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20153 mg_free(ctx->client_wait_events);; 20154 mg_free(ctx->worker_threadids);; 20155 ; 20156 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20157 mg_snprintf(NULL,; 20158 NULL, /* No truncation check for error buffers */; 20159 error->text,; 20160 error->text_buffer_size,; 20161 ""%s"",; 20162 err_msg);; 20163 }; 20164 free_context(ctx);; 20165 pthread_setspecific(sTlsKey, NULL);; 20166 return NULL;; 20167 }; 20168 ; 20169 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20170 ctx->client_wait_events[i] = event_create();; 20171 if (ctx->client_wait_events[i] == 0) {; 20172 const char *err_msg = ""Error creating worker event %i"";; 20173 mg_cry_ctx_internal(ctx, err_msg, i);; 20174 while (i > 0) {; 20175 i--;; 20176 event_destroy(ctx->client_wait_events[i]);; 20177 }; 20178 mg_free(ctx->client_socks);; 20179 mg_free(ctx->client_wait_events);; 20180 mg_free(ctx->worker_threadids);; 20181 ; 20182 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20183 mg_snprintf(NULL,; 20184 NULL, /* No truncation check for error buffers */; 20185 error->text,; 20186 error->text_buffer_size,; 20187 err_msg,; 20188 i);; 20189 }; 20190 free_context(ctx);; 20191 pthread_setspecific(sTlsKey, NULL);; 20192 return NULL;; 20193 }; 20194 }; 2019",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:602662,error,error,602662,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"0131 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20132 mg_free(ctx->worker_threadids);; 20133 ; 20134 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20135 mg_snprintf(NULL,; 20136 NULL, /* No truncation check for error buffers */; 20137 error->text,; 20138 error->text_buffer_size,; 20139 ""%s"",; 20140 err_msg);; 20141 }; 20142 free_context(ctx);; 20143 pthread_setspecific(sTlsKey, NULL);; 20144 return NULL;; 20145 }; 20146 ; 20147 ctx->client_socks =; 20148 (struct socket *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20149 sizeof(ctx->client_socks[0]),; 20150 ctx);; 20151 if (ctx->client_socks == NULL) {; 20152 const char *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20171 ctx->client_wait_events[i] = event_create();; 20172 if (ctx->client_wait_events[i] == 0) {; 20173 const char *err_msg = ""Error creating worker event %i"";; 20174 mg_cry_ctx_internal(ctx, err_msg, i);; 20175 while (i > 0) {; 20176 i--;; 20177 event_destroy(ctx->client_wait_events[i]);; 20178 }; 20179 mg_free(ctx->client_socks);; 20180 mg_free(ctx->client_wait_events);; 20181 mg_free(ctx->worker_threadids);; 20182 ; 20183 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20184 mg_snprintf(NULL,; 20185 NULL, /* No truncation check for error buffers */; 20186 error->text,; 20187 error->text_buffer_size,; 20188 err_msg,; 20189 i);; 20190 }; 20191 free_context(ctx);; 20192 pthread_setspecific(sTlsKey, NULL);; 20193 return NULL;; 20194 }; 20195 }; 2019",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:602695,error,error,602695,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,017578 43434.8 2; : 987 | 3.50466 4.60061 0.0201538 0.00175522 43481.6 3; : 988 | 3.61316 4.68965 0.0201071 0.00176 43603.6 4; : 989 | 3.88349 5.24185 0.0200475 0.00175499 43733.8 5; : 990 | 4.0647 4.52576 0.020036 0.00175545 43762.3 6; : 991 | 3.77396 5.32769 0.0200783 0.00175786 43667.1 7; : 992 | 3.45322 4.61211 0.0200841 0.00175232 43640 8; : 993 | 3.32586 4.54016 0.0200585 0.00176018 43719.9 9; : 994 | 3.54317 4.65875 0.0201539 0.00181263 43617.4 10; : 995 | 3.38008 5.03795 0.0206532 0.00179392 42419.4 11; : 996 | 3.40103 4.41295 0.0204644 0.00176564 42783.5 12; : 997 | 3.23461 4.8031 0.0203306 0.00176616 43093.1 13; : 998 | 3.41797 4.46788 0.0203618 0.00175568 42996.7 14; : 999 Minimum Test error found - save the configuration ; : 999 | 3.31412 4.14973 0.0202938 0.00187677 43438 0; : 1000 | 3.20867 4.17264 0.0201802 0.00179416 43511.4 1; : 1001 | 3.31742 4.17699 0.020287 0.00175118 43159.8 2; : 1002 | 3.35839 4.8143 0.0207434 0.00177731 42180.6 3; : 1003 Minimum Test error found - save the configuration ; : 1003 | 3.42381 4.04915 0.0202591 0.00184351 43441.4 0; : 1004 Minimum Test error found - save the configuration ; : 1004 | 3.27488 4.0384 0.0205262 0.00189376 42935.9 0; : 1005 | 3.09776 4.19224 0.0200956 0.00176781 43649.6 1; : 1006 Minimum Test error found - save the configuration ; : 1006 | 3.1757 3.91876 0.0201134 0.00183093 43757.7 0; : 1007 | 3.17471 4.33126 0.0203423 0.00178093 43100.3 1; : 1008 | 3.23752 4.46797 0.0204556 0.0017847 42847.4 2; : 1009 | 3.5099 4.04664 0.0203963 0.00177013 42950.3 3; : 1010 | 3.39993 4.32216 0.0201011 0.00176915 43639.8 4; : 1011 | 3.28002 4.35065 0.020045 0.00175269 43734.2 5; : 1012 | 3.24301 4.1309 0.0202482 0.00178612 43332 6; : 1013 | 3.47685 4.13785 0.0205714 0.00178247 42578.3 7; : 1014 | 3.38367 4.59532 0.0203076 0.00178189 43183.2 8; : 1015 Minimum Test error found - save the configuration ; : 1015 | 3.15343 3.81668 0.0204522 0.00185272 43011.9 0; : 1016 | 2.99441 4.01707 0.0202697 0.00183758 43402.5 1; : 1017 ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:113313,error,error,113313,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,0176264 43713.2 2; : 856 | 6.54513 10.3387 0.0200413 0.00176141 43764 3; : 857 Minimum Test error found - save the configuration ; : 857 | 6.43616 9.72218 0.020097 0.00182688 43787.4 0; : 858 | 6.34936 10.0458 0.0200349 0.00176193 43780.5 1; : 859 Minimum Test error found - save the configuration ; : 859 | 6.20554 9.48603 0.0201607 0.00183833 43662.6 0; : 860 | 6.16695 10.0812 0.0200598 0.00175295 43699.5 1; : 861 Minimum Test error found - save the configuration ; : 861 | 6.43224 9.42041 0.0201492 0.00182399 43655.7 0; : 862 | 6.08067 10.0276 0.0200725 0.0017577 43680.5 1; : 863 | 6.34296 10.0575 0.0200642 0.00175521 43694.5 2; : 864 Minimum Test error found - save the configuration ; : 864 | 6.33486 9.34508 0.0201279 0.00182025 43697.5 0; : 865 | 6.18959 10.0219 0.0205128 0.00175205 42642.3 1; : 866 Minimum Test error found - save the configuration ; : 866 | 6.05678 9.24173 0.0204648 0.00182051 42908.5 0; : 867 | 5.92011 9.34278 0.0202303 0.00193747 43733 1; : 868 Minimum Test error found - save the configuration ; : 868 | 5.90509 9.03441 0.0202616 0.0019877 43778.3 0; : 869 | 5.98345 9.15873 0.0200325 0.00175472 43768.9 1; : 870 | 5.90893 9.16507 0.0202516 0.00176171 43266.9 2; : 871 Minimum Test error found - save the configuration ; : 871 | 5.78015 8.79318 0.0200883 0.00182097 43794.1 0; : 872 | 5.76603 9.46642 0.0200354 0.00176138 43778.1 1; : 873 Minimum Test error found - save the configuration ; : 873 | 5.70638 8.71803 0.0200731 0.00181478 43815.7 0; : 874 Minimum Test error found - save the configuration ; : 874 | 5.53455 8.53383 0.0201925 0.00181685 43535.8 0; : 875 | 5.74708 8.69754 0.0202376 0.00177647 43334.2 1; : 876 | 5.6794 9.00589 0.0202045 0.00176006 43373.5 2; : 877 | 5.64383 8.64736 0.0203248 0.00179972 43184.7 3; : 878 Minimum Test error found - save the configuration ; : 878 | 5.55379 8.16524 0.0206602 0.00187795 42593.5 0; : 879 | 5.63754 8.31065 0.0203728 0.00175638 42972.7 1; : 880 | 5.71571 8.37499 0.0201251 0.00178041 43609.3 2; : 881 | 5,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:103569,error,error,103569,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"019 ; 1020An example of transparency usage with parallel coordinates can be found; 1021in parallelcoordtrans.C.; 1022 ; 1023To ease the creation of a transparent color the static method; 1024`GetColorTransparent(Int_t color, Float_t a)` is provided.; 1025In the following example the `trans_red` color index point to; 1026a red color 30% opaque (70% transparent). The alpha value of; 1027the color index `kRed` is not modified.; 1028 ; 1029~~~ {.cpp}; 1030 Int_t trans_red = GetColorTransparent(kRed, 0.3);; 1031~~~; 1032 ; 1033This function is also used in the methods; 1034`SetFillColorAlpha()`, `SetLineColorAlpha()`,; 1035`SetMarkerColorAlpha()` and `SetTextColorAlpha()`.; 1036In the following example the fill color of the histogram `histo`; 1037is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 1038(The color `kBlue` itself is internally stored as fully opaque.); 1039 ; 1040~~~ {.cpp}; 1041 histo->SetFillColorAlpha(kBlue, 0.35);; 1042~~~; 1043 ; 1044The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1`; 1045in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output; 1046it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; 1047 ; 1048Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`.; 1049Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.; 1050 ; 1051The following macro gives an example of transparency usage:; 1052 ; 1053Begin_Macro(source); 1054../../../tutorials/graphics/transparency.C; 1055End_Macro; 1056 ; 1057*/; 1058 ; 1059////////////////////////////////////////////////////////////////////////////////; 1060/// Default constructor.; 1061 ; 1062TColor::TColor(): TNamed(); 1063{; 1064 fNumber = -1;; 1065 fRed = fGreen = fBlue = fHue = fLight = fSaturation = -1;; 1066 fAlpha = 1;; 1067}; 1068 ; 1069////////////////////////////////////////////////////////////////////////////////; 1070/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:37199,avail,available,37199,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['avail'],['available']
Availability,"01998 0.192893 0.0153949 14422.7 2; : 6 | 0.6867 0.696275 0.191869 0.0152227 14492.2 3; : 7 Minimum Test error found - save the configuration ; : 7 | 0.692231 0.691692 0.197632 0.0164904 14132.6 0; : 8 | 0.683383 0.694963 0.194299 0.0156318 14328.3 1; : 9 Minimum Test error found - save the configuration ; : 9 | 0.682898 0.684979 0.192122 0.0157399 14513.9 0; : 10 | 0.670592 0.688549 0.192796 0.0152906 14422.1 1; : 11 Minimum Test error found - save the configuration ; : 11 | 0.670202 0.684295 0.191832 0.0154715 14515.7 0; : 12 Minimum Test error found - save the configuration ; : 12 | 0.675447 0.682107 0.194058 0.0158608 14366.1 0; : 13 | 0.678105 0.691356 0.193716 0.0152633 14345.5 1; : 14 | 0.684972 0.687408 0.191852 0.0154194 14509.8 2; : 15 | 0.676423 0.689156 0.193176 0.0153404 14395.3 3; : 16 | 0.683185 0.689966 0.191807 0.0149908 14478.3 4; : 17 | 0.672717 0.689982 0.192316 0.0149466 14433.2 5; : 18 | 0.670449 0.68412 0.190877 0.0151753 14570.1 6; : 19 Minimum Test error found - save the configuration ; : 19 | 0.661329 0.670317 0.192098 0.0154074 14488.6 0; : 20 Minimum Test error found - save the configuration ; : 20 | 0.658253 0.661402 0.192014 0.0155677 14508.7 0; : ; : Elapsed time for training with 3200 events: 3.87 sec ; : Evaluate deep neural network on CPU using batches with size = 256; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.102 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: PyKeras_LSTM for Classification; : ; : Split TMVA training data in 2560 training events and 640 validation events; : Training Model Summary; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; ========================",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:20419,error,error,20419,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['error'],['error']
Availability,"019{; 2020 if (e == -1); 2021 taf->TAttFill::Copy(*this);; 2022 else if (e >= 0 && e < fNYErrors); 2023 taf->TAttFill::Copy(fAttFill[e]);; 2024}; 2025 ; 2026////////////////////////////////////////////////////////////////////////////////; 2027/// Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).; 2028 ; 2029void TGraphMultiErrors::SetAttLine(Int_t e, TAttLine *taf); 2030{; 2031 if (e == -1); 2032 taf->TAttLine::Copy(*this);; 2033 else if (e >= 0 && e < fNYErrors); 2034 taf->TAttLine::Copy(fAttLine[e]);; 2035}; 2036 ; 2037////////////////////////////////////////////////////////////////////////////////; 2038/// Set Fill Color of error e (-1 = Global and x errors).; 2039 ; 2040void TGraphMultiErrors::SetFillColor(Int_t e, Color_t fcolor); 2041{; 2042 if (e == -1); 2043 SetFillColor(fcolor);; 2044 else if (e >= 0 && e < fNYErrors); 2045 fAttFill[e].SetFillColor(fcolor);; 2046}; 2047 ; 2048////////////////////////////////////////////////////////////////////////////////; 2049/// Set Fill Color and Alpha of error e (-1 = Global and x errors).; 2050 ; 2051void TGraphMultiErrors::SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha); 2052{; 2053 if (e == -1); 2054 SetFillColorAlpha(fcolor, falpha);; 2055 else if (e >= 0 && e < fNYErrors); 2056 fAttFill[e].SetFillColorAlpha(fcolor, falpha);; 2057}; 2058 ; 2059////////////////////////////////////////////////////////////////////////////////; 2060/// Set Fill Style of error e (-1 = Global and x errors).; 2061 ; 2062void TGraphMultiErrors::SetFillStyle(Int_t e, Style_t fstyle); 2063{; 2064 if (e == -1); 2065 SetFillStyle(fstyle);; 2066 else if (e >= 0 && e < fNYErrors); 2067 fAttFill[e].SetFillStyle(fstyle);; 2068}; 2069 ; 2070////////////////////////////////////////////////////////////////////////////////; 2071/// Set Line Color of error e (-1 = Global and x errors).; 2072 ; 2073void TGraphMultiErrors::SetLineColor(Int_t e, Color_t lcolor); 2074{; 2075 if (e == -1); 2076 SetLine",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:68963,error,error,68963,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"022void TH1::Sumw2(Bool_t flag); 9023{; 9024 if (!flag) {; 9025 // clear the array if existing - do nothing otherwise; 9026 if (fSumw2.fN > 0 ) fSumw2.Set(0);; 9027 return;; 9028 }; 9029 ; 9030 if (fSumw2.fN == fNcells) {; 9031 if (!fgDefaultSumw2 ); 9032 Warning(""Sumw2"",""Sum of squares of weights structure already created"");; 9033 return;; 9034 }; 9035 ; 9036 fSumw2.Set(fNcells);; 9037 ; 9038 // empty the buffer; 9039 if (fBuffer) BufferEmpty();; 9040 ; 9041 if (fEntries > 0); 9042 for (Int_t i = 0; i < fNcells; ++i); 9043 fSumw2.fArray[i] = TMath::Abs(RetrieveBinContent(i));; 9044}; 9045 ; 9046////////////////////////////////////////////////////////////////////////////////; 9047/// Return pointer to function with name.; 9048///; 9049///; 9050/// Functions such as TH1::Fit store the fitted function in the list of; 9051/// functions of this histogram.; 9052 ; 9053TF1 *TH1::GetFunction(const char *name) const; 9054{; 9055 return (TF1*)fFunctions->FindObject(name);; 9056}; 9057 ; 9058////////////////////////////////////////////////////////////////////////////////; 9059/// Return value of error associated to bin number bin.; 9060///; 9061/// if the sum of squares of weights has been defined (via Sumw2),; 9062/// this function returns the sqrt(sum of w2).; 9063/// otherwise it returns the sqrt(contents) for this bin.; 9064 ; 9065Double_t TH1::GetBinError(Int_t bin) const; 9066{; 9067 if (bin < 0) bin = 0;; 9068 if (bin >= fNcells) bin = fNcells-1;; 9069 if (fBuffer) ((TH1*)this)->BufferEmpty();; 9070 if (fSumw2.fN) return TMath::Sqrt(fSumw2.fArray[bin]);; 9071 ; 9072 return TMath::Sqrt(TMath::Abs(RetrieveBinContent(bin)));; 9073}; 9074 ; 9075////////////////////////////////////////////////////////////////////////////////; 9076/// Return lower error associated to bin number bin.; 9077///; 9078/// The error will depend on the statistic option used will return; 9079/// the binContent - lower interval value; 9080 ; 9081Double_t TH1::GetBinErrorLow(Int_t bin) const; 9082{; 90",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:353189,error,error,353189,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['error']
Availability,02416 0.0018489 43495.5 0; : 954 | 3.77661 6.79704 0.0200822 0.00176597 43677.1 1; : 955 | 4.26211 5.70833 0.020048 0.0017647 43755.8 2; : 956 | 3.83703 5.25865 0.0200643 0.00176603 43720 3; : 957 Minimum Test error found - save the configuration ; : 957 | 3.70429 5.19606 0.0204948 0.00189018 43000 0; : 958 | 3.80095 5.43788 0.0203069 0.00176137 43137.1 1; : 959 Minimum Test error found - save the configuration ; : 959 | 3.68258 5.15386 0.0202548 0.00182461 43407 0; : 960 Minimum Test error found - save the configuration ; : 960 | 3.74165 4.97436 0.0200851 0.00180832 43771.4 0; : 961 | 3.60053 5.18492 0.0200347 0.00175376 43761.4 1; : 962 | 4.06747 4.98756 0.0202606 0.00194113 43669.3 2; : 963 | 3.72111 5.2317 0.020058 0.00176556 43733.9 3; : 964 | 3.60317 5.20936 0.020113 0.00175786 43584.5 4; : 965 | 3.63413 5.37485 0.0201057 0.00175921 43605 5; : 966 | 3.74764 5.16986 0.0200985 0.00180899 43741 6; : 967 | 3.64317 5.0911 0.0200896 0.00175556 43634.6 7; : 968 Minimum Test error found - save the configuration ; : 968 | 3.75704 4.83525 0.0200988 0.00182012 43766.9 0; : 969 | 3.53402 4.87481 0.020433 0.0017954 42924.1 1; : 970 | 3.39152 4.92875 0.0207012 0.00184125 42417.9 2; : 971 | 3.38481 4.91243 0.0205923 0.00181714 42609.4 3; : 972 | 3.49443 4.93416 0.0204303 0.00180084 42942.7 4; : 973 | 3.50169 4.88411 0.0201535 0.00176496 43505.4 5; : 974 | 3.70493 4.95915 0.0200555 0.00176513 43738.9 6; : 975 Minimum Test error found - save the configuration ; : 975 | 3.52504 4.65912 0.0202218 0.00185299 43552 0; : 976 | 3.7346 5.23443 0.0200603 0.00176255 43721.2 1; : 977 | 3.73856 4.9727 0.0200443 0.00176151 43757 2; : 978 | 3.60727 4.99113 0.0200479 0.00175633 43736 3; : 979 | 3.40672 4.84357 0.0200357 0.00175685 43766.5 4; : 980 | 3.44899 4.83288 0.0200548 0.0017499 43704.2 5; : 981 | 3.46445 4.72048 0.0203135 0.00176046 43119.7 6; : 982 Minimum Test error found - save the configuration ; : 982 | 3.46604 4.64127 0.0202116 0.00183381 43530.8 0; : 983 Minimum Test error foun,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:111021,error,error,111021,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"030{; 2031 if (e == -1); 2032 taf->TAttLine::Copy(*this);; 2033 else if (e >= 0 && e < fNYErrors); 2034 taf->TAttLine::Copy(fAttLine[e]);; 2035}; 2036 ; 2037////////////////////////////////////////////////////////////////////////////////; 2038/// Set Fill Color of error e (-1 = Global and x errors).; 2039 ; 2040void TGraphMultiErrors::SetFillColor(Int_t e, Color_t fcolor); 2041{; 2042 if (e == -1); 2043 SetFillColor(fcolor);; 2044 else if (e >= 0 && e < fNYErrors); 2045 fAttFill[e].SetFillColor(fcolor);; 2046}; 2047 ; 2048////////////////////////////////////////////////////////////////////////////////; 2049/// Set Fill Color and Alpha of error e (-1 = Global and x errors).; 2050 ; 2051void TGraphMultiErrors::SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha); 2052{; 2053 if (e == -1); 2054 SetFillColorAlpha(fcolor, falpha);; 2055 else if (e >= 0 && e < fNYErrors); 2056 fAttFill[e].SetFillColorAlpha(fcolor, falpha);; 2057}; 2058 ; 2059////////////////////////////////////////////////////////////////////////////////; 2060/// Set Fill Style of error e (-1 = Global and x errors).; 2061 ; 2062void TGraphMultiErrors::SetFillStyle(Int_t e, Style_t fstyle); 2063{; 2064 if (e == -1); 2065 SetFillStyle(fstyle);; 2066 else if (e >= 0 && e < fNYErrors); 2067 fAttFill[e].SetFillStyle(fstyle);; 2068}; 2069 ; 2070////////////////////////////////////////////////////////////////////////////////; 2071/// Set Line Color of error e (-1 = Global and x errors).; 2072 ; 2073void TGraphMultiErrors::SetLineColor(Int_t e, Color_t lcolor); 2074{; 2075 if (e == -1); 2076 SetLineColor(lcolor);; 2077 else if (e >= 0 && e < fNYErrors); 2078 fAttLine[e].SetLineColor(lcolor);; 2079}; 2080 ; 2081////////////////////////////////////////////////////////////////////////////////; 2082/// Set Line Color and Alpha of error e (-1 = Global and x errors).; 2083 ; 2084void TGraphMultiErrors::SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha); 2085{; 2086 if (e == -1); 2087 SetLineColorAlpha(lcol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:69381,error,error,69381,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"0316 ; 20317 if ((ctx == NULL) || (options == NULL)) {; 20318 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20319 mg_snprintf(NULL,; 20320 NULL, /* No truncation check for error buffers */; 20321 error->text,; 20322 error->text_buffer_size,; 20323 ""%s"",; 20324 ""Invalid parameters"");; 20325 }; 20326 return -1;; 20327 }; 20328 ; 20329 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20330 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20331 mg_snprintf(NULL,; 20332 NULL, /* No truncation check for error buffers */; 20333 error->text,; 20334 error->text_buffer_size,; 20335 ""%s"",; 20336 ""Server already stopped"");; 20337 }; 20338 return -1;; 20339 }; 20340 ; 20341 new_dom = (struct mg_domain_context *); 20342 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20343 ; 20344 if (!new_dom) {; 20345 /* Out of memory */; 20346 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20347 mg_snprintf(NULL,; 20348 NULL, /* No truncation check for error buffers */; 20349 error->text,; 20350 error->text_buffer_size,; 20351 ""%s"",; 20352 ""Out or memory"");; 20353 }; 20354 return -6;; 20355 }; 20356 ; 20357 /* Store options - TODO: unite duplicate code */; 20358 while (options && (name = *options++) != NULL) {; 20359 if ((idx = get_option_index(name)) == -1) {; 20360 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20361 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20362 mg_snprintf(NULL,; 20363 NULL, /* No truncation check for error buffers */; 20364 error->text,; 20365 error->text_buffer_size,; 20366 ""Invalid option: %s"",; 20367 name);; 20368 }; 20369 mg_free(new_dom);; 20370 return -2;; 20371 } else if ((value = *options++) == NULL) {; 20372 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20373 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20374 mg_snprintf(NULL,; 20375 NULL, /* No truncation check for error buffers */; 20376 error->text,; 20377 error->text_buffer_size,; 20378 ""Invalid option value: %s"",; 203",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:608253,error,error,608253,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"0317 ; 20318 if ((ctx == NULL) || (options == NULL)) {; 20319 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20320 mg_snprintf(NULL,; 20321 NULL, /* No truncation check for error buffers */; 20322 error->text,; 20323 error->text_buffer_size,; 20324 ""%s"",; 20325 ""Invalid parameters"");; 20326 }; 20327 return -1;; 20328 }; 20329 ; 20330 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20331 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20332 mg_snprintf(NULL,; 20333 NULL, /* No truncation check for error buffers */; 20334 error->text,; 20335 error->text_buffer_size,; 20336 ""%s"",; 20337 ""Server already stopped"");; 20338 }; 20339 return -1;; 20340 }; 20341 ; 20342 new_dom = (struct mg_domain_context *); 20343 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20344 ; 20345 if (!new_dom) {; 20346 /* Out of memory */; 20347 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20348 mg_snprintf(NULL,; 20349 NULL, /* No truncation check for error buffers */; 20350 error->text,; 20351 error->text_buffer_size,; 20352 ""%s"",; 20353 ""Out or memory"");; 20354 }; 20355 return -6;; 20356 }; 20357 ; 20358 /* Store options - TODO: unite duplicate code */; 20359 while (options && (name = *options++) != NULL) {; 20360 if ((idx = get_option_index(name)) == -1) {; 20361 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20362 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20363 mg_snprintf(NULL,; 20364 NULL, /* No truncation check for error buffers */; 20365 error->text,; 20366 error->text_buffer_size,; 20367 ""Invalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 203",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:608286,error,error,608286,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"039through filters, defines and actions, and RDataFrame will take these dependencies into account when producing varied; 1040results. \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" is included in header `ROOT/RDFHelpers.hxx`. The compiled C++ programs must include this header; 1041explicitly, this is not required for ROOT macros. ; 1042 ; 1043An example usage of Vary() and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in C++:; 1044 ; 1045~~~{.cpp}; 1046auto nominal_hx =; 1047 df.Vary(""pt"", ""ROOT::RVecD{pt*0.9f, pt*1.1f}"", {""down"", ""up""}); 1048 .Filter(""pt > pt_cut""); 1049 .Define(""x"", someFunc, {""pt""}); 1050 .Histo1D<float>(""x"");; 1051 ; 1052// request the generation of varied results from the nominal_hx; 1053ROOT::RDF::Experimental::RResultMap<TH1D> hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; 1054 ; 1055// the event loop runs here, upon first access to any of the results or varied results:; 1056hx[""nominal""].Draw(); // same effect as nominal_hx->Draw(); 1057hx[""pt:down""].Draw(""SAME"");; 1058hx[""pt:up""].Draw(""SAME"");; 1059~~~; 1060 ; 1061A list of variation ""tags"" is passed as the last argument to Vary(). The tags give names to the varied values that are returned; 1062as elements of an RVec of the appropriate C++ type. The number of variation tags must correspond to the number of elements of; 1063this RVec (2 in the example above: the first element will correspond to the tag ""down"", the second; 1064to the tag ""up""). The _full_ variation name will be composed of the varied column name and the variation tags (e.g.; 1065""pt:down"", ""pt:up"" in this example). Python usage looks similar.; 1066 ; 1067Note how we use the ""pt"" column as usual in the Filter() and Define() calls and we simply use ""x"" as the value to fill; 1068the resulting histogram. To produce the varied results, RDataFrame will automatically execute the Filter and Define; 1069calls for each variation and fill the histogram with values and cuts that depend on the var",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:61467,down,down,61467,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['down'],['down']
Availability,"04 leaf->SetName(branchname);; 605 leaf->SetTitle(branchname);; 606 leaf->SetRange(true);; 607 // Create sub branches for each data member of an STL container.; 608 Unroll(name, valueClass, valueClass, pointer, basketsize, splitlevel+splitSTLP, 41);; 609 BuildTitle(name);; 610 SetReadLeavesPtr();; 611 SetFillLeavesPtr();; 612 return;; 613 }; 614 } else if (!strchr(elemType, '*') && ((fStreamerType == TVirtualStreamerInfo::kObject) || (fStreamerType == TVirtualStreamerInfo::kAny))) {; 615 // -- Create sub-branches for members that are classes.; 616 //; 617 // Note: This can only happen if we were called directly; 618 // (usually by TClass::Bronch) because Unroll never; 619 // calls us for an element of this type.; 620 fType = 2;; 621 TClass* clm = elementClass;; 622 Int_t err = Unroll(name, clm, clm, pointer, basketsize, splitlevel+splitSTLP, 0);; 623 if (err >= 0) {; 624 // Return on success.; 625 // FIXME: Why not on error too?; 626 SetReadLeavesPtr();; 627 SetFillLeavesPtr();; 628 return;; 629 }; 630 }; 631 }; 632 }; 633 ; 634 //; 635 // Create a leaf to represent this branch.; 636 //; 637 ; 638 TLeaf* leaf = new TLeafElement(this, GetTitle(), fID, fStreamerType);; 639 leaf->SetTitle(GetTitle());; 640 fNleaves = 1;; 641 fLeaves.Add(leaf);; 642 fTree->GetListOfLeaves()->Add(leaf);; 643 ; 644 //; 645 // If we have a counter branch set it now that we have; 646 // created our leaf, we cannot do it before then.; 647 //; 648 ; 649 if (brOfCounter) {; 650 SetBranchCount(brOfCounter);; 651 }; 652 ; 653 SetReadLeavesPtr();; 654 SetFillLeavesPtr();; 655}; 656 ; 657////////////////////////////////////////////////////////////////////////////////; 658/// Constructor when the branch object is a TClonesArray.; 659///; 660/// If splitlevel > 0 this branch in turn is split into sub branches.; 661 ; 662TBranchElement::TBranchElement(TTree *tree, const char* bname, TClonesArray* clones, Int_t basketsize, Int_t splitlevel, Int_t compress); 663: TBranch(); 664, fClassName(""TClonesArra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:22936,error,error,22936,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['error'],['error']
Availability,"0406e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 4.2647e-01 +/- 7.59e-02; a1 1.7594e-01 +/- 1.10e-01; nbkg 5.1101e+02 +/- 3.60e+01; nsig 4.8899e+02 +/- 3.57e+01; sig1frac 8.6392e-01 +/- 1.08e-01; ; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'left' created with bounds [0,4]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'right' created with bounds [6,10]; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_left' created with bounds [0,4]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_right' created with bounds [6,10]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: -1134.15, estimated distance to minimum: 3.61209e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 3.2415e-01 +/- 1.09e-01; a1 3.0373e-02 +/- 2.12e-01; nbkg 5.0182e+02 +/- 3.94e+01; nsig 4.1091e+02 +/- 2.63e+02; sig1frac 8.5838e-01 +/- 2.74e-01; ; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) p.d.f was fitted in a subrange and no explicit Range() and NormRange() was specified. Plotting / normalising in fit range. To override, do one of the following; - Clear the automatic fit range attribute: <pdf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204a__extendedLikelihood_8C.html:8815,error,error,8815,doc/master/rf204a__extendedLikelihood_8C.html,https://root.cern,https://root.cern/doc/master/rf204a__extendedLikelihood_8C.html,2,['error'],['error']
Availability,"05 // compute size of the lines at the end of the error bars; 6406 Int_t dxend = Int_t(gStyle->GetEndErrorSize());; 6407 bxsize = gPad->PixeltoX(dxend) - gPad->PixeltoX(0);; 6408 bysize =-gPad->PixeltoY(dxend) + gPad->PixeltoY(0);; 6409 ; 6410 ; 6411 if (fixbin) {; 6412 if (Hoption.Logx) xp = TMath::Power(10,Hparam.xmin) + 0.5*Hparam.xbinsize;; 6413 else xp = Hparam.xmin + 0.5*Hparam.xbinsize;; 6414 } else {; 6415 delta = fH->GetBinWidth(first);; 6416 xp = fH->GetBinLowEdge(first) + 0.5*delta;; 6417 }; 6418 ; 6419 // if errormarker = 0 or symbolsize = 0. no symbol is drawn; 6420 if (Hoption.Logx) logxmin = TMath::Power(10,Hparam.xmin);; 6421 if (Hoption.Logy) logymin = TMath::Power(10,Hparam.ymin);; 6422 ; 6423 // ---------------------- Loop over the points---------------------; 6424 for (k=first; k<=last; k++) {; 6425 ; 6426 // get the data; 6427 // xp = X position of the current point; 6428 // yp = Y position of the current point; 6429 // ex1 = Low X error; 6430 // ex2 = Up X error; 6431 // ey1 = Low Y error; 6432 // ey2 = Up Y error; 6433 // (xi,yi) = Error bars coordinates; 6434 ; 6435 // apply offset on errors for bar histograms; 6436 Double_t xminTmp = gPad->XtoPad(fXaxis->GetBinLowEdge(k));; 6437 Double_t xmaxTmp = gPad->XtoPad(fXaxis->GetBinUpEdge(k));; 6438 if (Hoption.Logx) {; 6439 xminTmp = TMath::Power(10, xminTmp);; 6440 xmaxTmp = TMath::Power(10, xmaxTmp);; 6441 }; 6442 Double_t w = (xmaxTmp-xminTmp)*width;; 6443 xminTmp += offset*(xmaxTmp-xminTmp);; 6444 xmaxTmp = xminTmp + w;; 6445 xp = (xminTmp+xmaxTmp)/2.;; 6446 ; 6447 if (Hoption.Logx) {; 6448 if (xp <= 0) goto L30;; 6449 if (xp < logxmin) goto L30;; 6450 if (xp > TMath::Power(10,xmax)) break;; 6451 } else {; 6452 if (xp < xmin) goto L30;; 6453 if (xp > xmax) break;; 6454 }; 6455 yp = factor*fH->GetBinContent(k);; 6456 if (optionI0 && yp==0) goto L30;; 6457 if (fixbin) {; 6458 ex1 = xerror*Hparam.xbinsize;; 6459 } else {; 6460 delta = fH->GetBinWidth(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:236449,error,error,236449,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,5,['error'],"['error', 'errors']"
Availability,05 0; : 649 Minimum Test error found - save the configuration ; : 649 | 64.2291 47.827 0.0205836 0.00185514 42715.8 0; : 650 Minimum Test error found - save the configuration ; : 650 | 63.5181 47.2461 0.0203914 0.00184161 43127.1 0; : 651 Minimum Test error found - save the configuration ; : 651 | 62.641 46.7417 0.020143 0.00182812 43680.3 0; : 652 Minimum Test error found - save the configuration ; : 652 | 61.875 46.3421 0.0201124 0.00182035 43734.8 0; : 653 Minimum Test error found - save the configuration ; : 653 | 61.1155 45.9892 0.0201549 0.00182806 43651.9 0; : 654 | 60.3955 46.5097 0.0201006 0.00177795 43661.9 1; : 655 Minimum Test error found - save the configuration ; : 655 | 59.5776 45.1172 0.0204622 0.00186914 43026.9 0; : 656 Minimum Test error found - save the configuration ; : 656 | 58.5813 44.6814 0.020214 0.00181641 43484.1 0; : 657 Minimum Test error found - save the configuration ; : 657 | 58.1075 44.2582 0.0201216 0.0018139 43697.5 0; : 658 Minimum Test error found - save the configuration ; : 658 | 57.7428 43.9646 0.0201606 0.00184632 43681.8 0; : 659 Minimum Test error found - save the configuration ; : 659 | 56.5877 43.7448 0.0201275 0.00181379 43683.2 0; : 660 Minimum Test error found - save the configuration ; : 660 | 56.1107 42.9226 0.0200887 0.00181275 43773.3 0; : 661 Minimum Test error found - save the configuration ; : 661 | 55.5039 42.6809 0.0201245 0.00180935 43679.7 0; : 662 Minimum Test error found - save the configuration ; : 662 | 54.3572 42.2723 0.0202587 0.00183315 43417.9 0; : 663 Minimum Test error found - save the configuration ; : 663 | 53.566 41.7624 0.0203991 0.00186617 43166.5 0; : 664 Minimum Test error found - save the configuration ; : 664 | 52.9086 41.2393 0.0201899 0.00182999 43573.1 0; : 665 Minimum Test error found - save the configuration ; : 665 | 52.1886 40.6761 0.020181 0.00182542 43583.6 0; : 666 Minimum Test error found - save the configuration ; : 666 | 51.2956 40.6256 0.0201396 0.00182896 43690.5 0; : 667 Mi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:85024,error,error,85024,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"051 ; 1052The above call will produce variations ""ptAndEta:down"" and ""ptAndEta:up"".; 1053 ; 1054#### Combining multiple variations; 1055 ; 1056Even if a result depends on multiple variations, only one variation is applied at a time, i.e. there will be no result produced; 1057by applying multiple systematic variations at the same time.; 1058For example, in the following example snippet, the RResultMap instance `all_h` will contain keys ""nominal"", ""pt:down"",; 1059""pt:up"", ""eta:0"", ""eta:1"", but no ""pt:up&&eta:0"" or similar:; 1060 ; 1061~~~{.cpp}; 1062auto df = _df.Vary(""pt"",; 1063 ""ROOT::RVecD{pt*0.9, pt*1.1}"",; 1064 {""down"", ""up""}); 1065 .Vary(""eta"",; 1066 [](float eta) { return RVecF{eta*0.9f, eta*1.1f}; },; 1067 {""eta""},; 1068 2);; 1069 ; 1070auto nom_h = df.Histo2D(histoModel, ""pt"", ""eta"");; 1071auto all_hs = VariationsFor(nom_h);; 1072all_hs.GetKeys(); // returns {""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1""}; 1073~~~; 1074 ; 1075Note how we passed the integer `2` instead of a list of variation tags to the second Vary() invocation: this is a; 1076shorthand that automatically generates tags 0 to N-1 (in this case 0 and 1).; 1077 ; 1078\note Currently, VariationsFor() and RResultMap are in the `ROOT::RDF::Experimental` namespace, to indicate that these; 1079 interfaces might still evolve and improve based on user feedback. We expect that some aspects of the related; 1080 programming model will be streamlined in future versions.; 1081 ; 1082\note Currently, the results of a Snapshot(), Report() or Display() call cannot be varied (i.e. it is not possible to; 1083 call \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" on them. These limitations will be lifted in future releases.; 1084 ; 1085See the Vary() method for more information and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; 1086for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the analysis.; 1087 ; 1088\anchor rno",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:62839,down,down,62839,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['down'],['down']
Availability,"057 static UserInfoCache_t gUserInfo;; 2058 ; 2059 UserInfoCache_t::const_iterator iUserInfo = gUserInfo.find(uid);; 2060 if (iUserInfo != gUserInfo.end()); 2061 return new UserGroup_t(iUserInfo->second);; 2062 ; 2063 struct passwd *apwd = getpwuid(uid);; 2064 if (apwd) {; 2065 UserGroup_t *ug = new UserGroup_t;; 2066 ug->fUid = apwd->pw_uid;; 2067 ug->fGid = apwd->pw_gid;; 2068 ug->fUser = apwd->pw_name;; 2069 ug->fPasswd = apwd->pw_passwd;; 2070 ug->fRealName = apwd->pw_gecos;; 2071 ug->fShell = apwd->pw_shell;; 2072 UserGroup_t *gr = GetGroupInfo(apwd->pw_gid);; 2073 if (gr) ug->fGroup = gr->fGroup;; 2074 delete gr;; 2075 ; 2076 gUserInfo[uid] = *ug;; 2077 return ug;; 2078 }; 2079 return nullptr;; 2080}; 2081 ; 2082////////////////////////////////////////////////////////////////////////////////; 2083/// Returns all user info in the UserGroup_t structure. If user = 0, returns; 2084/// current user's id info. The returned structure must be deleted by the; 2085/// user. In case of error 0 is returned.; 2086 ; 2087UserGroup_t *TUnixSystem::GetUserInfo(const char *user); 2088{; 2089 return GetUserInfo(GetUid(user));; 2090}; 2091 ; 2092////////////////////////////////////////////////////////////////////////////////; 2093/// Returns all group info in the UserGroup_t structure. The only active; 2094/// fields in the UserGroup_t structure for this call are:; 2095/// fGid and fGroup; 2096/// The returned structure must be deleted by the user. In case of; 2097/// error 0 is returned.; 2098 ; 2099UserGroup_t *TUnixSystem::GetGroupInfo(Int_t gid); 2100{; 2101 struct group *grp = getgrgid(gid);; 2102 if (grp) {; 2103 UserGroup_t *gr = new UserGroup_t;; 2104 gr->fUid = 0;; 2105 gr->fGid = grp->gr_gid;; 2106 gr->fGroup = grp->gr_name;; 2107 return gr;; 2108 }; 2109 return nullptr;; 2110}; 2111 ; 2112////////////////////////////////////////////////////////////////////////////////; 2113/// Returns all group info in the UserGroup_t structure. The only active; 2114/// fields in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:64277,error,error,64277,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['error'],['error']
Availability,"06 ; 21107 ; 21108void; 21109mg_disable_connection_keep_alive(struct mg_connection *conn); 21110{; 21111 /* https://github.com/civetweb/civetweb/issues/727 */; 21112 if (conn != NULL) {; 21113 conn->must_close = 1;; 21114 }; 21115}; 21116 ; 21117 ; 21118#if defined(MG_EXPERIMENTAL_INTERFACES); 21119/* Get connection information. It can be printed or stored by the caller.; 21120 * Return the size of available information. */; 21121int; 21122mg_get_connection_info(const struct mg_context *ctx,; 21123 int idx,; 21124 char *buffer,; 21125 int buflen); 21126{; 21127 const struct mg_connection *conn;; 21128 const struct mg_request_info *ri;; 21129 char *end, *append_eoobj = NULL, block[256];; 21130 size_t connection_info_length = 0;; 21131 int state = 0;; 21132 const char *state_str = ""unknown"";; 21133 ; 21134#if defined(_WIN32); 21135 static const char eol[] = ""\r\n"", eoobj[] = ""\r\n}\r\n"";; 21136#else; 21137 static const char eol[] = ""\n"", eoobj[] = ""\n}\n"";; 21138#endif; 21139 ; 21140 if ((buffer == NULL) || (buflen < 1)) {; 21141 buflen = 0;; 21142 end = buffer;; 21143 } else {; 21144 *buffer = 0;; 21145 end = buffer + buflen;; 21146 }; 21147 if (buflen > (int)(sizeof(eoobj) - 1)) {; 21148 /* has enough space to append eoobj */; 21149 append_eoobj = buffer;; 21150 end -= sizeof(eoobj) - 1;; 21151 }; 21152 ; 21153 if ((ctx == NULL) || (idx < 0)) {; 21154 /* Parameter error */; 21155 return 0;; 21156 }; 21157 ; 21158 if ((unsigned)idx >= ctx->cfg_worker_threads) {; 21159 /* Out of range */; 21160 return 0;; 21161 }; 21162 ; 21163 /* Take connection [idx]. This connection is not locked in; 21164 * any way, so some other thread might use it. */; 21165 conn = (ctx->worker_connections) + idx;; 21166 ; 21167 /* Initialize output string */; 21168 connection_info_length += mg_str_append(&buffer, end, ""{"");; 21169 ; 21170 /* Init variables */; 21171 ri = &(conn->request_info);; 21172 ; 21173#if defined(USE_SERVER_STATS); 21174 state = conn->conn_state;; 21175 ; 21176 /* State as",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:631284,error,error,631284,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"06 fColors = new TExMap;; 307 Long64_t key, value;; 308 TExMapIter it(org.fColors);; 309 while (it.Next(key, value)) {; 310 XColor_t *colo = (XColor_t *) (Long_t)value;; 311 XColor_t *col = new XColor_t;; 312 col->fPixel = colo->fPixel;; 313 col->fRed = colo->fRed;; 314 col->fGreen = colo->fGreen;; 315 col->fBlue = colo->fBlue;; 316 col->fDefined = colo->fDefined;; 317 fColors->Add(key, (Long_t) col);; 318 }; 319}; 320 ; 321////////////////////////////////////////////////////////////////////////////////; 322/// Destructor.; 323 ; 324TGX11::~TGX11(); 325{; 326 delete (XEvent*)fXEvent;; 327 if (fWindows) TStorage::Dealloc(fWindows);; 328 ; 329 if (!fColors) return;; 330 Long64_t key, value;; 331 TExMapIter it(fColors);; 332 while (it.Next(key, value)) {; 333 XColor_t *col = (XColor_t *) (Long_t)value;; 334 delete col;; 335 }; 336 delete fColors;; 337}; 338 ; 339////////////////////////////////////////////////////////////////////////////////; 340/// Initialize X11 system. Returns kFALSE in case of failure.; 341 ; 342Bool_t TGX11::Init(void *display); 343{; 344 if (OpenDisplay(display) == -1) return kFALSE;; 345 return kTRUE;; 346}; 347 ; 348////////////////////////////////////////////////////////////////////////////////; 349/// Allocate color in colormap. If we are on an <= 8 plane machine; 350/// we will use XAllocColor. If we are on a >= 15 (15, 16 or 24) plane; 351/// true color machine we will calculate the pixel value using:; 352/// for 15 and 16 bit true colors have 6 bits precision per color however; 353/// only the 5 most significant bits are used in the color index.; 354/// Except for 16 bits where green uses all 6 bits. I.e.:; 355/// ~~~ {.cpp}; 356/// 15 bits = rrrrrgggggbbbbb; 357/// 16 bits = rrrrrggggggbbbbb; 358/// ~~~; 359/// for 24 bits each r, g and b are represented by 8 bits.; 360///; 361/// Since all colors are set with a max of 65535 (16 bits) per r, g, b; 362/// we just right shift them by 10, 11 and 10 bits for 16 planes, and; 363/// (10, 10, 10 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:10643,failure,failure,10643,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['failure'],['failure']
Availability,"065 }; 7066 }; 7067 }; 7068 if (fDimension == 3) {; 7069 for (binz=firstz;binz<=lastz;binz++) {; 7070 z = fZaxis.GetBinCenter(binz);; 7071 for (biny=firsty;biny<=lasty;biny++) {; 7072 y = fYaxis.GetBinCenter(biny);; 7073 for (binx=firstx;binx<=lastx;binx++) {; 7074 bin = GetBin(binx,biny,binz);; 7075 x = fXaxis.GetBinCenter(binx);; 7076 w = RetrieveBinContent(bin);; 7077 e = GetBinError(bin);; 7078 if(fSumw2.fN) printf("" fSumw[%d][%d][%d]=%g, x=%g, y=%g, z=%g, error=%g\n"",binx,biny,binz,w,x,y,z,e);; 7079 else printf("" fSumw[%d][%d][%d]=%g, x=%g, y=%g, z=%g\n"",binx,biny,binz,w,x,y,z);; 7080 }; 7081 }; 7082 }; 7083 }; 7084}; 7085 ; 7086////////////////////////////////////////////////////////////////////////////////; 7087/// Using the current bin info, recompute the arrays for contents and errors; 7088 ; 7089void TH1::Rebuild(Option_t *); 7090{; 7091 SetBinsLength();; 7092 if (fSumw2.fN) {; 7093 fSumw2.Set(fNcells);; 7094 }; 7095}; 7096 ; 7097////////////////////////////////////////////////////////////////////////////////; 7098/// Reset this histogram: contents, errors, etc.; 7099/// \param[in] option; 7100/// - if ""ICE"" is specified, resets only Integral, Contents and Errors.; 7101/// - if ""ICES"" is specified, resets only Integral, Contents, Errors and Statistics; 7102/// This option is used; 7103/// - if ""M"" is specified, resets also Minimum and Maximum; 7104 ; 7105void TH1::Reset(Option_t *option); 7106{; 7107 // The option ""ICE"" is used when extending the histogram (in ExtendAxis, LabelInflate, etc..); 7108 // The option ""ICES is used in combination with the buffer (see BufferEmpty and BufferFill); 7109 ; 7110 TString opt = option;; 7111 opt.ToUpper();; 7112 fSumw2.Reset();; 7113 if (fIntegral) {; 7114 delete [] fIntegral;; 7115 fIntegral = nullptr;; 7116 }; 7117 ; 7118 if (opt.Contains(""M"")) {; 7119 SetMinimum();; 7120 SetMaximum();; 7121 }; 7122 ; 7123 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 7124 ; 7125 // Setting fBuffer[0] = 0 is like resetting t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:277562,error,errors,277562,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"068 for (i = 0; i <= newxbins; ++i) xbins[i] = fXaxis.GetBinLowEdge(1+i*nxgroup);; 3069 Double_t *ybins = new Double_t[newybins+1];; 3070 for (i = 0; i <= newybins; ++i) ybins[i] = fYaxis.GetBinLowEdge(1+i*nygroup);; 3071 Double_t *zbins = new Double_t[newzbins+1];; 3072 for (i = 0; i <= newzbins; ++i) zbins[i] = fZaxis.GetBinLowEdge(1+i*nzgroup);; 3073 hnew->SetBins(newxbins,xbins, newybins, ybins, newzbins, zbins);//changes also errors array (if any); 3074 delete [] xbins;; 3075 delete [] ybins;; 3076 delete [] zbins;; 3077 } else {; 3078 hnew->SetBins(newxbins, xmin, xmax, newybins, ymin, ymax, newzbins, zmin, zmax);//changes also errors array; 3079 }; 3080 ; 3081 Double_t binContent, binSumw2;; 3082 Int_t oldxbin = 1;; 3083 Int_t oldybin = 1;; 3084 Int_t oldzbin = 1;; 3085 Int_t bin;; 3086 for (xbin = 1; xbin <= newxbins; xbin++) {; 3087 oldybin=1;; 3088 oldzbin=1;; 3089 for (ybin = 1; ybin <= newybins; ybin++) {; 3090 oldzbin=1;; 3091 for (zbin = 1; zbin <= newzbins; zbin++) {; 3092 binContent = 0;; 3093 binSumw2 = 0;; 3094 for (i = 0; i < nxgroup; i++) {; 3095 if (oldxbin+i > nxbins) break;; 3096 for (j =0; j < nygroup; j++) {; 3097 if (oldybin+j > nybins) break;; 3098 for (k =0; k < nzgroup; k++) {; 3099 if (oldzbin+k > nzbins) break;; 3100 //get global bin (same conventions as in TH1::GetBin(xbin,ybin); 3101 bin = oldxbin + i + (oldybin + j)*(nxbins + 2) + (oldzbin + k)*(nxbins + 2)*(nybins + 2);; 3102 binContent += oldBins[bin];; 3103 if (oldSumw2) binSumw2 += oldSumw2[bin];; 3104 }; 3105 }; 3106 }; 3107 Int_t ibin = hnew->GetBin(xbin,ybin,zbin); // new bin number; 3108 hnew->SetBinContent(ibin, binContent);; 3109 if (oldSumw2) hnew->fSumw2.fArray[ibin] = binSumw2;; 3110 oldzbin += nzgroup;; 3111 }; 3112 oldybin += nygroup;; 3113 }; 3114 oldxbin += nxgroup;; 3115 }; 3116 ; 3117 // compute new underflow/overflows for the 8 vertices; 3118 for (Int_t xover = 0; xover <= 1; xover++) {; 3119 for (Int_t yover = 0; yover <= 1; yover++) {; 3120 for (Int_t zover = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:122039,error,errors,122039,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,2,['error'],['errors']
Availability,"07 ; 21108 ; 21109void; 21110mg_disable_connection_keep_alive(struct mg_connection *conn); 21111{; 21112 /* https://github.com/civetweb/civetweb/issues/727 */; 21113 if (conn != NULL) {; 21114 conn->must_close = 1;; 21115 }; 21116}; 21117 ; 21118 ; 21119#if defined(MG_EXPERIMENTAL_INTERFACES); 21120/* Get connection information. It can be printed or stored by the caller.; 21121 * Return the size of available information. */; 21122int; 21123mg_get_connection_info(const struct mg_context *ctx,; 21124 int idx,; 21125 char *buffer,; 21126 int buflen); 21127{; 21128 const struct mg_connection *conn;; 21129 const struct mg_request_info *ri;; 21130 char *end, *append_eoobj = NULL, block[256];; 21131 size_t connection_info_length = 0;; 21132 int state = 0;; 21133 const char *state_str = ""unknown"";; 21134 ; 21135#if defined(_WIN32); 21136 static const char eol[] = ""\r\n"", eoobj[] = ""\r\n}\r\n"";; 21137#else; 21138 static const char eol[] = ""\n"", eoobj[] = ""\n}\n"";; 21139#endif; 21140 ; 21141 if ((buffer == NULL) || (buflen < 1)) {; 21142 buflen = 0;; 21143 end = buffer;; 21144 } else {; 21145 *buffer = 0;; 21146 end = buffer + buflen;; 21147 }; 21148 if (buflen > (int)(sizeof(eoobj) - 1)) {; 21149 /* has enough space to append eoobj */; 21150 append_eoobj = buffer;; 21151 end -= sizeof(eoobj) - 1;; 21152 }; 21153 ; 21154 if ((ctx == NULL) || (idx < 0)) {; 21155 /* Parameter error */; 21156 return 0;; 21157 }; 21158 ; 21159 if ((unsigned)idx >= ctx->cfg_worker_threads) {; 21160 /* Out of range */; 21161 return 0;; 21162 }; 21163 ; 21164 /* Take connection [idx]. This connection is not locked in; 21165 * any way, so some other thread might use it. */; 21166 conn = (ctx->worker_connections) + idx;; 21167 ; 21168 /* Initialize output string */; 21169 connection_info_length += mg_str_append(&buffer, end, ""{"");; 21170 ; 21171 /* Init variables */; 21172 ri = &(conn->request_info);; 21173 ; 21174#if defined(USE_SERVER_STATS); 21175 state = conn->conn_state;; 21176 ; 21177 /* State as",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:631317,error,error,631317,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,07.7 0; : 625 | 88.1287 61.343 0.0200847 0.00175821 43652.7 1; : 626 Minimum Test error found - save the configuration ; : 626 | 87.0203 60.0927 0.0202246 0.00182742 43485 0; : 627 | 86.1022 60.6165 0.020286 0.00178227 43234.5 1; : 628 Minimum Test error found - save the configuration ; : 628 | 84.7933 59.0719 0.0201769 0.00183209 43609.1 0; : 629 Minimum Test error found - save the configuration ; : 629 | 83.7285 58.2513 0.0204361 0.0018731 43096.5 0; : 630 Minimum Test error found - save the configuration ; : 630 | 82.639 58.0942 0.0203377 0.00185077 43273.9 0; : 631 Minimum Test error found - save the configuration ; : 631 | 81.6101 57.1049 0.0203504 0.00184845 43238.6 0; : 632 | 80.6827 57.1221 0.0201225 0.00176999 43590.8 1; : 633 Minimum Test error found - save the configuration ; : 633 | 79.5527 56.2669 0.0201884 0.00185082 43626.2 0; : 634 Minimum Test error found - save the configuration ; : 634 | 78.6493 55.4759 0.0202109 0.00182609 43514.1 0; : 635 Minimum Test error found - save the configuration ; : 635 | 77.3887 55.223 0.020166 0.00184577 43667.6 0; : 636 Minimum Test error found - save the configuration ; : 636 | 76.4488 55.0573 0.020202 0.00188181 43667.6 0; : 637 Minimum Test error found - save the configuration ; : 637 | 75.4894 54.0711 0.0202555 0.00186268 43495.3 0; : 638 Minimum Test error found - save the configuration ; : 638 | 74.5839 53.0373 0.0201113 0.00181775 43731.4 0; : 639 Minimum Test error found - save the configuration ; : 639 | 73.497 52.6629 0.0200838 0.00181639 43793.9 0; : 640 Minimum Test error found - save the configuration ; : 640 | 72.4195 52.0402 0.0201153 0.00181887 43724.4 0; : 641 | 71.5077 52.3492 0.0200565 0.00175616 43715 1; : 642 Minimum Test error found - save the configuration ; : 642 | 70.8829 51.1798 0.0201079 0.00181215 43725.9 0; : 643 Minimum Test error found - save the configuration ; : 643 | 69.8143 50.8726 0.0201142 0.00180555 43695.1 0; : 644 Minimum Test error found - save the configuration ; : 644 | 68.8,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:82535,error,error,82535,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"0791 0.0403928 4405.16 1; : 9 Minimum Test error found - save the configuration ; : 9 | 0.599679 0.608826 0.606268 0.0407993 4421.11 0; : 10 Minimum Test error found - save the configuration ; : 10 | 0.585295 0.60026 0.604906 0.0402508 4427.48 0; : 11 Minimum Test error found - save the configuration ; : 11 | 0.568589 0.592822 0.598106 0.0406425 4484.6 0; : 12 Minimum Test error found - save the configuration ; : 12 | 0.559657 0.589421 0.600393 0.0404151 4464.46 0; : 13 Minimum Test error found - save the configuration ; : 13 | 0.552318 0.583187 0.601709 0.0405559 4455.11 0; : 14 Minimum Test error found - save the configuration ; : 14 | 0.540541 0.58147 0.593964 0.0401674 4514.29 0; : 15 Minimum Test error found - save the configuration ; : 15 | 0.532596 0.581192 0.589633 0.0399271 4547.88 0; : 16 Minimum Test error found - save the configuration ; : 16 | 0.529842 0.56732 0.599541 0.040336 4470.63 0; : 17 | 0.521737 0.574812 0.603666 0.0406979 4440.75 1; : 18 Minimum Test error found - save the configuration ; : 18 | 0.517445 0.565391 0.598324 0.0405273 4481.92 0; : 19 Minimum Test error found - save the configuration ; : 19 | 0.509836 0.557055 0.617073 0.042121 4348.19 0; : 20 | 0.510257 0.574511 0.617241 0.0402784 4333.04 1; : ; : Elapsed time for training with 3200 events: 12.3 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.22 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: TMVA_DNN for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 1, 1, 300 ) Batch size = 256 Loss function = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:17128,error,error,17128,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['error'],['error']
Availability,"08 exh = value[3];; 409 eyl = value[4];; 410 eyh = value[5];; 411 SetPoint(np, x, y);; 412 SetPointError(np, exl, exh, eyl, eyh);; 413 np++ ;; 414 }; 415 }; 416 isLineToBeSkipped = kFALSE;; 417 token = nullptr;; 418 token_idx = 0;; 419 value_idx = 0;; 420 }; 421 Set(np) ;; 422 ; 423 // Cleaning; 424 delete [] isTokenToBeSaved;; 425 delete token;; 426 }; 427 infile.close();; 428}; 429 ; 430////////////////////////////////////////////////////////////////////////////////; 431/// TGraphAsymmErrors default destructor.; 432 ; 433TGraphAsymmErrors::~TGraphAsymmErrors(); 434{; 435 if(fEXlow) delete [] fEXlow;; 436 if(fEXhigh) delete [] fEXhigh;; 437 if(fEYlow) delete [] fEYlow;; 438 if(fEYhigh) delete [] fEYhigh;; 439}; 440 ; 441////////////////////////////////////////////////////////////////////////////////; 442/// Allocate internal data structures for `size` points.; 443 ; 444Double_t** TGraphAsymmErrors::Allocate(Int_t size) {; 445 return AllocateArrays(6, size);; 446}; 447 ; 448////////////////////////////////////////////////////////////////////////////////; 449/// Add a point with asymmetric errorbars to the graph.; 450 ; 451void TGraphAsymmErrors::AddPointError(Double_t x, Double_t y, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); 452{; 453 AddPoint(x, y);; 454 SetPointError(fNpoints - 1, exl, exh, eyl, eyh);; 455}; 456 ; 457////////////////////////////////////////////////////////////////////////////////; 458/// Apply a function to all data points \f$ y = f(x,y) \f$; 459///; 460/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 461/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; 462///; 463/// Special treatment has to be applied for the functions where the; 464/// role of ""up"" and ""down"" is reversed.; 465///; 466/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 467 ; 468void TGraphAsymmErrors::Apply(TF1 *f); 469{; 470 Double_t x,y,exl,exh,eyl,eyh,eyl_new,eyh_new,fxy;; 471 ; 472 if (fHistogram) {; 473 delete fHistogram;; 474 fHi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:15583,error,errorbars,15583,doc/master/TGraphAsymmErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html,1,['error'],['errorbars']
Availability,"08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TSelectorDraw; enum  EStatusBits { kWarn = (1ULL << ( 12 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TSelectorDraw; virtual void ClearFormula ();  Delete internal buffers. ;  ; virtual bool CompileVariables (const char *varexp="""", const char *selection="""");  Compile input variables and selection expression. ;  ; virtual void InitArrays (Int_t newsize);  Initialization of the primitive type arrays if the new size is bigger than the available space. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <ROOT/REveTreeTools.hxx>. Inheritance diagram for ROOT::Experimental::REvePointSelector:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ REvePointSelector() [1/2]. ROOT::Experimental::REvePointSelector::REvePointSelector ; (; const REvePointSelector & ; ). privatedelete . ◆ REvePointSelector() [2/2]. REvePointSelector::REvePointSelector ; (; TTree * ; t = nullptr, . REvePointSelectorConsumer * ; c = nullptr, . const char * ; vexp = """", . const char * ; sel = """" . ). Constructor. ; Definition at line 67 of file REveTreeTools.cxx. ◆ ~REvePointSelector(). ROOT::Experimental::REvePointSelector::~REvePointSele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REvePointSelector.html:18271,avail,available,18271,doc/master/classROOT_1_1Experimental_1_1REvePointSelector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REvePointSelector.html,1,['avail'],['available']
Availability,"08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TSelectorDraw; enum  EStatusBits { kWarn = (1ULL << ( 12 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TSelectorDraw; virtual void ClearFormula ();  Delete internal buffers. ;  ; virtual bool CompileVariables (const char *varexp="""", const char *selection="""");  Compile input variables and selection expression. ;  ; virtual void InitArrays (Int_t newsize);  Initialization of the primitive type arrays if the new size is bigger than the available space. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <ROOT/REveTreeTools.hxx>. Inheritance diagram for ROOT::Experimental::REveSelectorToEventList:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ REveSelectorToEventList() [1/2]. ROOT::Experimental::REveSelectorToEventList::REveSelectorToEventList ; (; const REveSelectorToEventList & ; ). privatedelete . ◆ REveSelectorToEventList() [2/2]. REveSelectorToEventList::REveSelectorToEventList ; (; TEventList * ; evl, . const char * ; sel . ). Constructor. ; Definition at line 33 of file REveTreeTools.cxx. ◆ ~REveSelectorToEventList(). ROOT::Experimental::REveSelectorToEventList::~REveSelectorToEventList ; (; ). in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REveSelectorToEventList.html:17525,avail,available,17525,doc/master/classROOT_1_1Experimental_1_1REveSelectorToEventList.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REveSelectorToEventList.html,1,['avail'],['available']
Availability,"08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TSelectorDraw; enum  EStatusBits { kWarn = (1ULL << ( 12 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TSelectorDraw; virtual void ClearFormula ();  Delete internal buffers. ;  ; virtual bool CompileVariables (const char *varexp="""", const char *selection="""");  Compile input variables and selection expression. ;  ; virtual void InitArrays (Int_t newsize);  Initialization of the primitive type arrays if the new size is bigger than the available space. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TEveTreeTools.h>. Inheritance diagram for TEvePointSelector:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TEvePointSelector() [1/2]. TEvePointSelector::TEvePointSelector ; (; const TEvePointSelector & ; ). privatedelete . ◆ TEvePointSelector() [2/2]. TEvePointSelector::TEvePointSelector ; (; TTree * ; t = nullptr, . TEvePointSelectorConsumer * ; c = nullptr, . const char * ; vexp = """", . const char * ; sel = """" . ). Constructor. ; Definition at line 69 of file TEveTreeTools.cxx. ◆ ~TEvePointSelector(). TEvePointSelector::~TEvePointSelector ; (; ). inlineoverride . Definition at line 86 of file TEveTre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEvePointSelector.html:18269,avail,available,18269,doc/master/classTEvePointSelector.html,https://root.cern,https://root.cern/doc/master/classTEvePointSelector.html,1,['avail'],['available']
Availability,"08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TSelectorDraw; enum  EStatusBits { kWarn = (1ULL << ( 12 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TSelectorDraw; virtual void ClearFormula ();  Delete internal buffers. ;  ; virtual bool CompileVariables (const char *varexp="""", const char *selection="""");  Compile input variables and selection expression. ;  ; virtual void InitArrays (Int_t newsize);  Initialization of the primitive type arrays if the new size is bigger than the available space. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TEveTreeTools.h>. Inheritance diagram for TEveSelectorToEventList:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TEveSelectorToEventList() [1/2]. TEveSelectorToEventList::TEveSelectorToEventList ; (; const TEveSelectorToEventList & ; ). privatedelete . ◆ TEveSelectorToEventList() [2/2]. TEveSelectorToEventList::TEveSelectorToEventList ; (; TEventList * ; evl, . const char * ; sel . ). Constructor. ; Definition at line 32 of file TEveTreeTools.cxx. Member Function Documentation. ◆ Class(). static TClass * TEveSelectorToEventList::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveSelectorToEventList.html:17445,avail,available,17445,doc/master/classTEveSelectorToEventList.html,https://root.cern,https://root.cern/doc/master/classTEveSelectorToEventList.html,1,['avail'],['available']
Availability,"081 /*! \brief d'tor; 1082 *; 1083 *; 1084 */; 1085 Net (const Net& other); 1086 : m_eErrorFunction (other.m_eErrorFunction); 1087 , m_sizeInput (other.m_sizeInput); 1088 , m_layers (other.m_layers); 1089 {; 1090 }; 1091 ; 1092 void setInputSize (size_t sizeInput) { m_sizeInput = sizeInput; } ///< set the input size of the DNN; 1093 void setOutputSize (size_t sizeOutput) { m_sizeOutput = sizeOutput; } ///< set the output size of the DNN; 1094 void addLayer (Layer& layer) { m_layers.push_back (layer); } ///< add a layer (layout); 1095 void addLayer (Layer&& layer) { m_layers.push_back (layer); }; 1096 void setErrorFunction (ModeErrorFunction eErrorFunction) { m_eErrorFunction = eErrorFunction; } ///< which error function is to be used; 1097 ; 1098 size_t inputSize () const { return m_sizeInput; } ///< input size of the DNN; 1099 size_t outputSize () const { return m_sizeOutput; } ///< output size of the DNN; 1100 ; 1101 /*! \brief set the drop out configuration; 1102 *; 1103 *; 1104 */; 1105 template <typename WeightsType, typename DropProbabilities>; 1106 void dropOutWeightFactor (WeightsType& weights,; 1107 const DropProbabilities& drops,; 1108 bool inverse = false);; 1109 ; 1110 /*! \brief start the training; 1111 *; 1112 * \param weights weight vector; 1113 * \param trainPattern training pattern; 1114 * \param testPattern test pattern; 1115 * \param minimizer use this minimizer for training (e.g. SGD); 1116 * \param settings settings used for this training run; 1117 */; 1118 template <typename Minimizer>; 1119 double train (std::vector<double>& weights,; 1120 std::vector<Pattern>& trainPattern,; 1121 const std::vector<Pattern>& testPattern,; 1122 Minimizer& minimizer,; 1123 Settings& settings);; 1124 ; 1125 /*! \brief pre-training for future use; 1126 *; 1127 *; 1128 */; 1129 template <typename Minimizer>; 1130 void preTrain (std::vector<double>& weights,; 1131 std::vector<Pattern>& trainPattern,; 1132 const std::vector<Pattern>& testPattern,; 1133 Minimizer& mini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:39450,error,error,39450,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['error'],['error']
Availability,"081 ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20082 sizeof(pthread_t),; 20083 ctx);; 20084 ; 20085 if (ctx->worker_threadids == NULL) {; 20086 const char *err_msg = ""Not enough memory for worker thread ID array"";; 20087 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20088 ; 20089 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20090 mg_snprintf(NULL,; 20091 NULL, /* No truncation check for error buffers */; 20092 error->text,; 20093 error->text_buffer_size,; 20094 ""%s"",; 20095 err_msg);; 20096 }; 20097 free_context(ctx);; 20098 pthread_setspecific(sTlsKey, NULL);; 20099 return NULL;; 20100 }; 20101 ctx->worker_connections =; 20102 (struct mg_connection *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20103 sizeof(struct mg_connection),; 20104 ctx);; 20105 if (ctx->worker_connections == NULL) {; 20106 const char *err_msg =; 20107 ""Not enough memory for worker thread connection array"";; 20108 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20109 ; 20110 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20111 mg_snprintf(NULL,; 20112 NULL, /* No truncation check for error buffers */; 20113 error->text,; 20114 error->text_buffer_size,; 20115 ""%s"",; 20116 err_msg);; 20117 }; 20118 free_context(ctx);; 20119 pthread_setspecific(sTlsKey, NULL);; 20120 return NULL;; 20121 }; 20122 ; 20123#if defined(ALTERNATIVE_QUEUE); 20124 ctx->client_wait_events =; 20125 (void **)mg_calloc_ctx(ctx->cfg_worker_threads,; 20126 sizeof(ctx->client_wait_events[0]),; 20127 ctx);; 20128 if (ctx->client_wait_events == NULL) {; 20129 const char *err_msg = ""Not enough memory for worker event array"";; 20130 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20131 mg_free(ctx->worker_threadids);; 20132 ; 20133 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20134 mg_snprintf(NULL,; 20135 NULL, /* No truncation check for error buffers */; 20136 error->text,; 20137 error->text_buffer_size,; 20138 ""%s"",; 20139 err_msg);; 20140 }; 20141 free_context(ctx);; 20142 pthread_s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:601033,error,error,601033,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"082 ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20083 sizeof(pthread_t),; 20084 ctx);; 20085 ; 20086 if (ctx->worker_threadids == NULL) {; 20087 const char *err_msg = ""Not enough memory for worker thread ID array"";; 20088 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20089 ; 20090 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20091 mg_snprintf(NULL,; 20092 NULL, /* No truncation check for error buffers */; 20093 error->text,; 20094 error->text_buffer_size,; 20095 ""%s"",; 20096 err_msg);; 20097 }; 20098 free_context(ctx);; 20099 pthread_setspecific(sTlsKey, NULL);; 20100 return NULL;; 20101 }; 20102 ctx->worker_connections =; 20103 (struct mg_connection *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20104 sizeof(struct mg_connection),; 20105 ctx);; 20106 if (ctx->worker_connections == NULL) {; 20107 const char *err_msg =; 20108 ""Not enough memory for worker thread connection array"";; 20109 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20110 ; 20111 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20112 mg_snprintf(NULL,; 20113 NULL, /* No truncation check for error buffers */; 20114 error->text,; 20115 error->text_buffer_size,; 20116 ""%s"",; 20117 err_msg);; 20118 }; 20119 free_context(ctx);; 20120 pthread_setspecific(sTlsKey, NULL);; 20121 return NULL;; 20122 }; 20123 ; 20124#if defined(ALTERNATIVE_QUEUE); 20125 ctx->client_wait_events =; 20126 (void **)mg_calloc_ctx(ctx->cfg_worker_threads,; 20127 sizeof(ctx->client_wait_events[0]),; 20128 ctx);; 20129 if (ctx->client_wait_events == NULL) {; 20130 const char *err_msg = ""Not enough memory for worker event array"";; 20131 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20132 mg_free(ctx->worker_threadids);; 20133 ; 20134 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20135 mg_snprintf(NULL,; 20136 NULL, /* No truncation check for error buffers */; 20137 error->text,; 20138 error->text_buffer_size,; 20139 ""%s"",; 20140 err_msg);; 20141 }; 20142 free_context(ctx);; 20143 pthread_s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:601066,error,error,601066,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"091 ; 1092The above call will produce variations ""ptAndEta:down"" and ""ptAndEta:up"".; 1093 ; 1094#### Combining multiple variations; 1095 ; 1096Even if a result depends on multiple variations, only one variation is applied at a time, i.e. there will be no result produced; 1097by applying multiple systematic variations at the same time.; 1098For example, in the following example snippet, the RResultMap instance `all_h` will contain keys ""nominal"", ""pt:down"",; 1099""pt:up"", ""eta:0"", ""eta:1"", but no ""pt:up&&eta:0"" or similar:; 1100 ; 1101~~~{.cpp}; 1102auto df = _df.Vary(""pt"",; 1103 ""ROOT::RVecD{pt*0.9, pt*1.1}"",; 1104 {""down"", ""up""}); 1105 .Vary(""eta"",; 1106 [](float eta) { return RVecF{eta*0.9f, eta*1.1f}; },; 1107 {""eta""},; 1108 2);; 1109 ; 1110auto nom_h = df.Histo2D(histoModel, ""pt"", ""eta"");; 1111auto all_hs = VariationsFor(nom_h);; 1112all_hs.GetKeys(); // returns {""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1""}; 1113~~~; 1114 ; 1115Note how we passed the integer `2` instead of a list of variation tags to the second Vary() invocation: this is a; 1116shorthand that automatically generates tags 0 to N-1 (in this case 0 and 1).; 1117 ; 1118\note Currently, VariationsFor() and RResultMap are in the `ROOT::RDF::Experimental` namespace, to indicate that these; 1119 interfaces might still evolve and improve based on user feedback. We expect that some aspects of the related; 1120 programming model will be streamlined in future versions.; 1121 ; 1122\note Currently, the results of a Snapshot(), Report() or Display() call cannot be varied (i.e. it is not possible to; 1123 call \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" on them. These limitations will be lifted in future releases.; 1124 ; 1125See the Vary() method for more information and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; 1126for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the analysis.; 1127 ; 1128\anchor rno",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:64519,down,down,64519,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['down'],['down']
Availability,"092 while (libs.Tokenize(tok, from, "" "")) {; 2093 if ((tok.Index(pat, &ext) != 0) || (ext != tok.Length())); 2094 continue;; 2095 std::cout << tok << ""\n"";; 2096 }; 2097}; 2098 ; 2099////////////////////////////////////////////////////////////////////////////////; 2100/// Return the thread local storage for the custom last error message; 2101 ; 2102TString &TSystem::GetLastErrorString(); 2103{; 2104 TTHREAD_TLS_DECL( TString, gLastErrorString);; 2105 return gLastErrorString;; 2106}; 2107 ; 2108////////////////////////////////////////////////////////////////////////////////; 2109/// Return the thread local storage for the custom last error message; 2110 ; 2111const TString &TSystem::GetLastErrorString() const; 2112{; 2113 return const_cast<TSystem*>(this)->GetLastErrorString();; 2114}; 2115 ; 2116////////////////////////////////////////////////////////////////////////////////; 2117/// Get list of shared libraries loaded at the start of the executable.; 2118/// Returns 0 in case list cannot be obtained or in case of error.; 2119 ; 2120const char *TSystem::GetLinkedLibraries(); 2121{; 2122 return nullptr;; 2123}; 2124 ; 2125////////////////////////////////////////////////////////////////////////////////; 2126/// Return a space separated list of loaded shared libraries.; 2127/// Regexp is a wildcard expression, see TRegexp::MakeWildcard.; 2128/// This list is of a format suitable for a linker, i.e it may contain; 2129/// -Lpathname and/or -lNameOfLib.; 2130/// Option can be any of:; 2131/// - S: shared libraries loaded at the start of the executable, because; 2132/// they were specified on the link line.; 2133/// - D: shared libraries dynamically loaded after the start of the program.; 2134/// - L: this option is ignored, and available for backward compatibility.; 2135 ; 2136const char *TSystem::GetLibraries(const char *regexp, const char *options,; 2137 Bool_t isRegexp); 2138{; 2139 fListLibs.Clear();; 2140 ; 2141 TString libs;; 2142 TString opt(options);; 2143 Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:68694,error,error,68694,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['error'],['error']
Availability,"0935 ; 10936#if defined(USE_TIMERS); 10937 ; 10938#define TIMER_API static; 10939#include ""timer.inl""; 10940 ; 10941#endif /* USE_TIMERS */; 10942 ; 10943 ; 10944#if !defined(NO_CGI); 10945/* This structure helps to create an environment for the spawned CGI; 10946 * program.; 10947 * Environment is an array of ""VARIABLE=VALUE\0"" ASCII strings,; 10948 * last element must be NULL.; 10949 * However, on Windows there is a requirement that all these; 10950 * VARIABLE=VALUE\0; 10951 * strings must reside in a contiguous buffer. The end of the buffer is; 10952 * marked by two '\0' characters.; 10953 * We satisfy both worlds: we create an envp array (which is vars), all; 10954 * entries are actually pointers inside buf. */; 10955struct cgi_environment {; 10956 struct mg_connection *conn;; 10957 /* Data block */; 10958 char *buf; /* Environment buffer */; 10959 size_t buflen; /* Space available in buf */; 10960 size_t bufused; /* Space taken in buf */; 10961 /* Index block */; 10962 char **var; /* char **envp */; 10963 size_t varlen; /* Number of variables available in var */; 10964 size_t varused; /* Number of variables stored in var */; 10965};; 10966 ; 10967 ; 10968static void addenv(struct cgi_environment *env,; 10969 PRINTF_FORMAT_STRING(const char *fmt),; 10970 ...) PRINTF_ARGS(2, 3);; 10971 ; 10972/* Append VARIABLE=VALUE\0 string to the buffer, and add a respective; 10973 * pointer into the vars array. Assumes env != NULL and fmt != NULL. */; 10974static void; 10975addenv(struct cgi_environment *env, const char *fmt, ...); 10976{; 10977 size_t i, n, space;; 10978 int truncated = 0;; 10979 char *added;; 10980 va_list ap;; 10981 ; 10982 if ((env->varlen - env->varused) < 2) {; 10983 mg_cry_internal(env->conn,; 10984 ""%s: Cannot register CGI variable [%s]"",; 10985 __func__,; 10986 fmt);; 10987 return;; 10988 }; 10989 ; 10990 /* Calculate how much space is left in the buffer */; 10991 space = (env->buflen - env->bufused);; 10992 ; 10993 do {; 10994 /* Space for ""\0\0"" is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:315452,avail,available,315452,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['avail'],['available']
Availability,"0936 ; 10937#if defined(USE_TIMERS); 10938 ; 10939#define TIMER_API static; 10940#include ""timer.inl""; 10941 ; 10942#endif /* USE_TIMERS */; 10943 ; 10944 ; 10945#if !defined(NO_CGI); 10946/* This structure helps to create an environment for the spawned CGI; 10947 * program.; 10948 * Environment is an array of ""VARIABLE=VALUE\0"" ASCII strings,; 10949 * last element must be NULL.; 10950 * However, on Windows there is a requirement that all these; 10951 * VARIABLE=VALUE\0; 10952 * strings must reside in a contiguous buffer. The end of the buffer is; 10953 * marked by two '\0' characters.; 10954 * We satisfy both worlds: we create an envp array (which is vars), all; 10955 * entries are actually pointers inside buf. */; 10956struct cgi_environment {; 10957 struct mg_connection *conn;; 10958 /* Data block */; 10959 char *buf; /* Environment buffer */; 10960 size_t buflen; /* Space available in buf */; 10961 size_t bufused; /* Space taken in buf */; 10962 /* Index block */; 10963 char **var; /* char **envp */; 10964 size_t varlen; /* Number of variables available in var */; 10965 size_t varused; /* Number of variables stored in var */; 10966};; 10967 ; 10968 ; 10969static void addenv(struct cgi_environment *env,; 10970 PRINTF_FORMAT_STRING(const char *fmt),; 10971 ...) PRINTF_ARGS(2, 3);; 10972 ; 10973/* Append VARIABLE=VALUE\0 string to the buffer, and add a respective; 10974 * pointer into the vars array. Assumes env != NULL and fmt != NULL. */; 10975static void; 10976addenv(struct cgi_environment *env, const char *fmt, ...); 10977{; 10978 size_t i, n, space;; 10979 int truncated = 0;; 10980 char *added;; 10981 va_list ap;; 10982 ; 10983 if ((env->varlen - env->varused) < 2) {; 10984 mg_cry_internal(env->conn,; 10985 ""%s: Cannot register CGI variable [%s]"",; 10986 __func__,; 10987 fmt);; 10988 return;; 10989 }; 10990 ; 10991 /* Calculate how much space is left in the buffer */; 10992 space = (env->buflen - env->bufused);; 10993 ; 10994 do {; 10995 /* Space for ""\0\0"" is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:315485,avail,available,315485,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['avail'],['available']
Availability,"0977] - Exit code 0 with failing C++ notebook in nbconvert; [ROOT-11006] - [TTreeReader] Crash when reading array branch. Release 6.32.02; Published on June 18, 2024; Items addressed in this release. [#7236] - Memory leak in TFile::WriteObjectAny, depending on data type; [#10075] - Difficult to configure Xrootd to use non-builtin openssl; [#14051] - [web graphics] Web graphics resizes canvas despite canvas size definition in the macro; [#15321] - [MSVC] Root is failed with error G694476FC: static_assert failed “Unexpected size”; [#15405] - [RF] ExternalConstraints documentation incorrect for RooMCStudy; [#15430] - Test failures with Python 3.13; [#15473] - Segmentation fault when building with the mold linker; [#15498] - gPad is not consistent in pyROOT with web canvas; [#15511] - Possible memory corruption in cling; [#15579] - Performance regression (slowdown) in ALICE event generation; [#15686] - JITted code changes the execution order of computation graph nodes; [#15688] - PyROOT TProfile2D::Fill ambiguities preventing use of some signatures in pyROOT; [#15690] - [RF] SegFault in RooBernstein::fillBuffer; [#15694] - [RF] New RooFit EvalBackend returning incorrect result for binned likelihoods; [#15703] - Leaking memory though strings in PyROOT; [#15727] - Windows CMake project cannot find_library() after integrating with ROOT.; [#15751] - [RF] Using a conditional RooProdPdf in a multi-channel fit spawns too many integrals with new CPU evaluation backend; [#15791] - JS ROOT does not draw tprofile2d correctly with “TEXT” draw option; [#15799] - pyunittests-pyroot-pyz-ttree-setbranchaddress segfaults with Python 3.13; [ROOT-7412] - Strange results looking for nested types; [ROOT-8439] - PyROOT does not treat exceptions properly in overloaded methods; [ROOT-9307] - TPad::GetListOfPrimitives() double deletion error in TList::Clear(). Release 6.32.04; Published on August 14, 2024; Items addressed in this release. [#7223] - [RF] RDataFrame to RooDataSet/RooDataHist conve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:42987,fault,fault,42987,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['fault'],['fault']
Availability,0985 0.00180899 43741 6; : 967 | 3.64317 5.0911 0.0200896 0.00175556 43634.6 7; : 968 Minimum Test error found - save the configuration ; : 968 | 3.75704 4.83525 0.0200988 0.00182012 43766.9 0; : 969 | 3.53402 4.87481 0.020433 0.0017954 42924.1 1; : 970 | 3.39152 4.92875 0.0207012 0.00184125 42417.9 2; : 971 | 3.38481 4.91243 0.0205923 0.00181714 42609.4 3; : 972 | 3.49443 4.93416 0.0204303 0.00180084 42942.7 4; : 973 | 3.50169 4.88411 0.0201535 0.00176496 43505.4 5; : 974 | 3.70493 4.95915 0.0200555 0.00176513 43738.9 6; : 975 Minimum Test error found - save the configuration ; : 975 | 3.52504 4.65912 0.0202218 0.00185299 43552 0; : 976 | 3.7346 5.23443 0.0200603 0.00176255 43721.2 1; : 977 | 3.73856 4.9727 0.0200443 0.00176151 43757 2; : 978 | 3.60727 4.99113 0.0200479 0.00175633 43736 3; : 979 | 3.40672 4.84357 0.0200357 0.00175685 43766.5 4; : 980 | 3.44899 4.83288 0.0200548 0.0017499 43704.2 5; : 981 | 3.46445 4.72048 0.0203135 0.00176046 43119.7 6; : 982 Minimum Test error found - save the configuration ; : 982 | 3.46604 4.64127 0.0202116 0.00183381 43530.8 0; : 983 Minimum Test error found - save the configuration ; : 983 | 3.37896 4.59559 0.0201715 0.00182642 43608.5 0; : 984 Minimum Test error found - save the configuration ; : 984 | 3.36213 4.34126 0.0202597 0.00185498 43467.1 0; : 985 | 3.39032 4.51659 0.0201503 0.00185184 43719.5 1; : 986 | 3.5234 4.95577 0.0201762 0.0017578 43434.8 2; : 987 | 3.50466 4.60061 0.0201538 0.00175522 43481.6 3; : 988 | 3.61316 4.68965 0.0201071 0.00176 43603.6 4; : 989 | 3.88349 5.24185 0.0200475 0.00175499 43733.8 5; : 990 | 4.0647 4.52576 0.020036 0.00175545 43762.3 6; : 991 | 3.77396 5.32769 0.0200783 0.00175786 43667.1 7; : 992 | 3.45322 4.61211 0.0200841 0.00175232 43640 8; : 993 | 3.32586 4.54016 0.0200585 0.00176018 43719.9 9; : 994 | 3.54317 4.65875 0.0201539 0.00181263 43617.4 10; : 995 | 3.38008 5.03795 0.0206532 0.00179392 42419.4 11; : 996 | 3.40103 4.41295 0.0204644 0.00176564 42783.5 12; : 997 | 3.23461 4.8031 0,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:111910,error,error,111910,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"0; , kCheckROOT = 1; , kCheckGIT = 2; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TPackMgr (const char *dir, const char *key=""L0"");  Create a PROOF package manager. ;  ;  ~TPackMgr () override;  Destroy a TPackMgr instance. ;  ; Int_t Build (const char *pack, Int_t opt=TPackMgr::kCheckROOT);  Method to build a package. ;  ; Int_t Clean (const char *pack);  Clean dir for package 'pack' Return -1 in case of error, 0 otherwise. ;  ; const char * GetDir () const;  ; Int_t GetDownloadDir (TString &dldir);  Method to get the download dir; create if not existing Return -1 in case of error (not found; not created), 0 otherwise. ;  ; void GetEnabledPackages (TString &packlist);  Method to get a semi-colon separated list with the names of the enabled packages. ;  ; TList * GetList () const;  Get list of available packages Returns a pointer to a TList object, transferring ownership to the caller. ;  ; TList * GetListOfEnabled () const;  Get list of enabled packages Returns a pointer to a TList object, transferring ownership to the caller. ;  ; TLockPath * GetLock ();  ; TMD5 * GetMD5 (const char *pack);  Get MD5 checksum of the PAR file corresponding to given package Returns a pointer to a TMD5 object, transferring ownership to the caller. ;  ; const char * GetName () const override;  Returns name of object. ;  ; Int_t GetPackDir (const char *pack, TString &pdir)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPackMgr.html:1658,error,error,1658,doc/master/classTPackMgr.html,https://root.cern,https://root.cern/doc/master/classTPackMgr.html,1,['error'],['error']
Availability,"0; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGraphErrors; Double_t ** Allocate (Int_t size) override;  Allocate internal data structures for newsize points. ;  ; void CopyAndRelease (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy and release. ;  ; Bool_t CopyPoints (Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin != iend. ;  ; Bool_t CtorAllocate ();  Constructor allocate. ;  ; Bool_t DoMerge (const TGraph *g) override;  Protected function to perform the merge operation of a graph with errors. ;  ; void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) override;  Set zero values for point arrays in the range [begin, end]. ;  ; void SwapPoints (Int_t pos1, Int_t pos2) override;  Swap points. ;  ; void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fEX, and fEY arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPolar.html:33993,error,errors,33993,doc/master/classTGraphPolar.html,https://root.cern,https://root.cern/doc/master/classTGraphPolar.html,1,['error'],['errors']
Availability,0; : 568 Minimum Test error found - save the configuration ; : 568 | 178.451 108.059 0.0201373 0.00182611 43689.1 0; : 569 Minimum Test error found - save the configuration ; : 569 | 176.264 106.78 0.0201111 0.00181323 43721.1 0; : 570 Minimum Test error found - save the configuration ; : 570 | 174.355 105.885 0.0201445 0.00181905 43655.2 0; : 571 | 172.647 106.784 0.0200848 0.0017791 43702.2 1; : 572 Minimum Test error found - save the configuration ; : 572 | 170.589 104.683 0.020165 0.00182763 43626.8 0; : 573 Minimum Test error found - save the configuration ; : 573 | 168.468 102.528 0.0201413 0.00182619 43679.9 0; : 574 Minimum Test error found - save the configuration ; : 574 | 166.622 102.085 0.0201407 0.00181861 43663.2 0; : 575 Minimum Test error found - save the configuration ; : 575 | 164.293 100.588 0.0203765 0.00182671 43127.2 0; : 576 Minimum Test error found - save the configuration ; : 576 | 162.136 99.7953 0.0201485 0.00182291 43654.8 0; : 577 Minimum Test error found - save the configuration ; : 577 | 160.429 98.8873 0.0202404 0.00182125 43433.1 0; : 578 Minimum Test error found - save the configuration ; : 578 | 158.663 98.2522 0.020118 0.00181189 43701.3 0; : 579 Minimum Test error found - save the configuration ; : 579 | 156.666 96.9925 0.0201133 0.00181082 43710 0; : 580 Minimum Test error found - save the configuration ; : 580 | 154.635 96.1367 0.0201142 0.00181294 43712.9 0; : 581 Minimum Test error found - save the configuration ; : 581 | 153.026 95.3539 0.0201307 0.0018172 43683.7 0; : 582 Minimum Test error found - save the configuration ; : 582 | 151.197 94.0449 0.020143 0.00182303 43668.3 0; : 583 Minimum Test error found - save the configuration ; : 583 | 149.229 93.6244 0.0201231 0.00181874 43705.4 0; : 584 Minimum Test error found - save the configuration ; : 584 | 147.504 92.2301 0.0202996 0.00182281 43297.5 0; : 585 Minimum Test error found - save the configuration ; : 585 | 145.457 91.5459 0.020121 0.00181177 43693.8 0; : 586 Minimum,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:76199,error,error,76199,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,0; : 569 Minimum Test error found - save the configuration ; : 569 | 176.264 106.78 0.0201111 0.00181323 43721.1 0; : 570 Minimum Test error found - save the configuration ; : 570 | 174.355 105.885 0.0201445 0.00181905 43655.2 0; : 571 | 172.647 106.784 0.0200848 0.0017791 43702.2 1; : 572 Minimum Test error found - save the configuration ; : 572 | 170.589 104.683 0.020165 0.00182763 43626.8 0; : 573 Minimum Test error found - save the configuration ; : 573 | 168.468 102.528 0.0201413 0.00182619 43679.9 0; : 574 Minimum Test error found - save the configuration ; : 574 | 166.622 102.085 0.0201407 0.00181861 43663.2 0; : 575 Minimum Test error found - save the configuration ; : 575 | 164.293 100.588 0.0203765 0.00182671 43127.2 0; : 576 Minimum Test error found - save the configuration ; : 576 | 162.136 99.7953 0.0201485 0.00182291 43654.8 0; : 577 Minimum Test error found - save the configuration ; : 577 | 160.429 98.8873 0.0202404 0.00182125 43433.1 0; : 578 Minimum Test error found - save the configuration ; : 578 | 158.663 98.2522 0.020118 0.00181189 43701.3 0; : 579 Minimum Test error found - save the configuration ; : 579 | 156.666 96.9925 0.0201133 0.00181082 43710 0; : 580 Minimum Test error found - save the configuration ; : 580 | 154.635 96.1367 0.0201142 0.00181294 43712.9 0; : 581 Minimum Test error found - save the configuration ; : 581 | 153.026 95.3539 0.0201307 0.0018172 43683.7 0; : 582 Minimum Test error found - save the configuration ; : 582 | 151.197 94.0449 0.020143 0.00182303 43668.3 0; : 583 Minimum Test error found - save the configuration ; : 583 | 149.229 93.6244 0.0201231 0.00181874 43705.4 0; : 584 Minimum Test error found - save the configuration ; : 584 | 147.504 92.2301 0.0202996 0.00182281 43297.5 0; : 585 Minimum Test error found - save the configuration ; : 585 | 145.457 91.5459 0.020121 0.00181177 43693.8 0; : 586 Minimum Test error found - save the configuration ; : 586 | 143.954 90.9958 0.02013 0.00181326 43675.8 0; : 587 Minimum T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:76313,error,error,76313,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,0; : 570 Minimum Test error found - save the configuration ; : 570 | 174.355 105.885 0.0201445 0.00181905 43655.2 0; : 571 | 172.647 106.784 0.0200848 0.0017791 43702.2 1; : 572 Minimum Test error found - save the configuration ; : 572 | 170.589 104.683 0.020165 0.00182763 43626.8 0; : 573 Minimum Test error found - save the configuration ; : 573 | 168.468 102.528 0.0201413 0.00182619 43679.9 0; : 574 Minimum Test error found - save the configuration ; : 574 | 166.622 102.085 0.0201407 0.00181861 43663.2 0; : 575 Minimum Test error found - save the configuration ; : 575 | 164.293 100.588 0.0203765 0.00182671 43127.2 0; : 576 Minimum Test error found - save the configuration ; : 576 | 162.136 99.7953 0.0201485 0.00182291 43654.8 0; : 577 Minimum Test error found - save the configuration ; : 577 | 160.429 98.8873 0.0202404 0.00182125 43433.1 0; : 578 Minimum Test error found - save the configuration ; : 578 | 158.663 98.2522 0.020118 0.00181189 43701.3 0; : 579 Minimum Test error found - save the configuration ; : 579 | 156.666 96.9925 0.0201133 0.00181082 43710 0; : 580 Minimum Test error found - save the configuration ; : 580 | 154.635 96.1367 0.0201142 0.00181294 43712.9 0; : 581 Minimum Test error found - save the configuration ; : 581 | 153.026 95.3539 0.0201307 0.0018172 43683.7 0; : 582 Minimum Test error found - save the configuration ; : 582 | 151.197 94.0449 0.020143 0.00182303 43668.3 0; : 583 Minimum Test error found - save the configuration ; : 583 | 149.229 93.6244 0.0201231 0.00181874 43705.4 0; : 584 Minimum Test error found - save the configuration ; : 584 | 147.504 92.2301 0.0202996 0.00182281 43297.5 0; : 585 Minimum Test error found - save the configuration ; : 585 | 145.457 91.5459 0.020121 0.00181177 43693.8 0; : 586 Minimum Test error found - save the configuration ; : 586 | 143.954 90.9958 0.02013 0.00181326 43675.8 0; : 587 Minimum Test error found - save the configuration ; : 587 | 142.242 89.8853 0.0201892 0.0018256 43564.4 0; : 588 Minimum T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:76426,error,error,76426,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,0; : 652 Minimum Test error found - save the configuration ; : 652 | 61.875 46.3421 0.0201124 0.00182035 43734.8 0; : 653 Minimum Test error found - save the configuration ; : 653 | 61.1155 45.9892 0.0201549 0.00182806 43651.9 0; : 654 | 60.3955 46.5097 0.0201006 0.00177795 43661.9 1; : 655 Minimum Test error found - save the configuration ; : 655 | 59.5776 45.1172 0.0204622 0.00186914 43026.9 0; : 656 Minimum Test error found - save the configuration ; : 656 | 58.5813 44.6814 0.020214 0.00181641 43484.1 0; : 657 Minimum Test error found - save the configuration ; : 657 | 58.1075 44.2582 0.0201216 0.0018139 43697.5 0; : 658 Minimum Test error found - save the configuration ; : 658 | 57.7428 43.9646 0.0201606 0.00184632 43681.8 0; : 659 Minimum Test error found - save the configuration ; : 659 | 56.5877 43.7448 0.0201275 0.00181379 43683.2 0; : 660 Minimum Test error found - save the configuration ; : 660 | 56.1107 42.9226 0.0200887 0.00181275 43773.3 0; : 661 Minimum Test error found - save the configuration ; : 661 | 55.5039 42.6809 0.0201245 0.00180935 43679.7 0; : 662 Minimum Test error found - save the configuration ; : 662 | 54.3572 42.2723 0.0202587 0.00183315 43417.9 0; : 663 Minimum Test error found - save the configuration ; : 663 | 53.566 41.7624 0.0203991 0.00186617 43166.5 0; : 664 Minimum Test error found - save the configuration ; : 664 | 52.9086 41.2393 0.0201899 0.00182999 43573.1 0; : 665 Minimum Test error found - save the configuration ; : 665 | 52.1886 40.6761 0.020181 0.00182542 43583.6 0; : 666 Minimum Test error found - save the configuration ; : 666 | 51.2956 40.6256 0.0201396 0.00182896 43690.5 0; : 667 Minimum Test error found - save the configuration ; : 667 | 50.7315 40.0752 0.0201193 0.00182284 43724.4 0; : 668 | 49.9429 40.0919 0.0200598 0.00176937 43738.7 1; : 669 Minimum Test error found - save the configuration ; : 669 | 49.7924 39.9525 0.02013 0.00182828 43711.6 0; : 670 Minimum Test error found - save the configuration ; : 670 | 48,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:85366,error,error,85366,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,0; : 737 Minimum Test error found - save the configuration ; : 737 | 20.4393 22.6213 0.0200735 0.00180745 43797.2 0; : 738 Minimum Test error found - save the configuration ; : 738 | 20.2862 22.4457 0.0201199 0.00181602 43706.6 0; : 739 Minimum Test error found - save the configuration ; : 739 | 20.1208 22.4048 0.0200963 0.00181207 43753.7 0; : 740 Minimum Test error found - save the configuration ; : 740 | 19.913 22.3841 0.0200932 0.00181057 43757.3 0; : 741 Minimum Test error found - save the configuration ; : 741 | 19.6956 22.1693 0.0200949 0.00182186 43780.3 0; : 742 Minimum Test error found - save the configuration ; : 742 | 19.5563 22.0339 0.0201148 0.00182382 43737.3 0; : 743 Minimum Test error found - save the configuration ; : 743 | 19.2633 21.9202 0.0201113 0.00181809 43732 0; : 744 Minimum Test error found - save the configuration ; : 744 | 18.9779 21.4146 0.0200848 0.00181658 43791.8 0; : 745 | 19.0558 21.8309 0.0200351 0.00176335 43783.5 1; : 746 Minimum Test error found - save the configuration ; : 746 | 18.8292 21.203 0.0201069 0.00182679 43763.3 0; : 747 Minimum Test error found - save the configuration ; : 747 | 18.4234 20.9247 0.0201054 0.00181179 43731.2 0; : 748 Minimum Test error found - save the configuration ; : 748 | 18.2054 20.8597 0.0200854 0.00181067 43776.4 0; : 749 Minimum Test error found - save the configuration ; : 749 | 17.9119 20.8249 0.0200825 0.00181515 43794.1 0; : 750 | 17.7295 20.9077 0.0200909 0.00176261 43648.3 1; : 751 Minimum Test error found - save the configuration ; : 751 | 17.6646 20.1562 0.02009 0.00181812 43783 0; : 752 Minimum Test error found - save the configuration ; : 752 | 17.2045 20.1301 0.0200899 0.00181385 43773 0; : 753 Minimum Test error found - save the configuration ; : 753 | 17.2492 20.0483 0.0200805 0.00181433 43796.8 0; : 754 Minimum Test error found - save the configuration ; : 754 | 16.8738 20.0271 0.0201173 0.00182078 43724.2 0; : 755 | 16.6744 20.3793 0.0200328 0.00175569 43770.5 1; : 756 Minimum T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:93556,error,error,93556,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"0; TProfileHelper::Addstatic Bool_t Add(T *p, const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2=1)Definition TProfileHelper.h:71; TProfileHelper::GetBinEffectiveEntriesstatic Double_t GetBinEffectiveEntries(T *p, Int_t bin)Definition TProfileHelper.h:143; TProfileHelper::LabelsDeflatestatic void LabelsDeflate(T *p, Option_t *)Definition TProfileHelper.h:560; TProfileProfile Histogram.Definition TProfile.h:32; TProfile::GetBinSumw2virtual TArrayD * GetBinSumw2()Definition TProfile.h:111; TProfile::SetBinEntriesvirtual void SetBinEntries(Int_t bin, Double_t w)Set the number of entries in bin.Definition TProfile.cxx:1700; TProfile::Sumw2void Sumw2(Bool_t flag=kTRUE) overrideCreate/delete structure to store sum of squares of weights per bin.Definition TProfile.cxx:1825; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; c2return c2Definition legend2.C:14; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. histhistsrcTProfile2D.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:96332,down,down,96332,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,1,['down'],['down']
Availability,"0; k < n; ++k); 960 newCov[i*n+j] += cov[i*n + k] * tmp[k*n + j];; 961 }; 962 }; 963 // update fit result with new corrected covariance matrix; 964 unsigned int k = 0;; 965 for (unsigned int i = 0; i < n; ++i) {; 966 fResult->fErrors[i] = std::sqrt( newCov[i*(n+1)] );; 967 for (unsigned int j = 0; j <= i; ++j); 968 fResult->fCovMatrix[k++] = newCov[i *n + j];; 969 }; 970 ; 971 // restore previous used objective function; 972 fObjFunction.swap( objFunc );; 973 ; 974 return true;; 975}; 976 ; 977 ; 978 ; 979void Fitter::ExamineFCN() {; 980 // return a pointer to the binned data used in the fit; 981 // works only for chi2 or binned likelihood fits; 982 // thus when the objective function stored is a Chi2Func or a PoissonLikelihood; 983 // This also set the model function correctly if it has not been set; 984 ; 985 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGenFunction, ROOT::Math::IParamMultiFunction, BinData> >() ) return;; 986 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGenFunction, ROOT::Math::IParamMultiFunction, UnBinData> >() ) return;; 987 ; 988 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGradFunction, ROOT::Math::IParamMultiFunction, BinData> >() ) return;; 989 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGradFunction, ROOT::Math::IParamMultiFunction, UnBinData> >() ) return;; 990 ; 991 //MATH_INFO_MSG(""Fitter::ExamineFCN"",""Objective function is not of a known type - FitData and ModelFunction objects are not available"");; 992 return;; 993}; 994 ; 995 } // end namespace Fit; 996 ; 997} // end namespace ROOT; BasicFCN.h; BinData.h; Chi2FCN.h; Error.h; MATH_INFO_MSG#define MATH_INFO_MSG(loc, str)Pre-processor macro to report messages which can be configured to use ROOT error or simply an std::io...Definition Error.h:77; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; MATH_WARN_MSG#define MATH_WARN_MSG(loc, str)Definition Error.h:80; FcnAdapter.h; FitConfig.h; FitMethodFunction.h; FitResult.h; Fitter.h; IParamFunction.h; LogLikelihoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:39206,avail,available,39206,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,1,['avail'],['available']
Availability,"0; kbeg = 0;}; 1600 if (opt.Contains(""O"")) {iend = ncx1+1; jend = ncy1+1; kend = ncz1+1;}; 1601 ; 1602 Int_t i,j,k,bin;; 1603 Double_t sum1 = 0;; 1604 Double_t sum2 = 0;; 1605 Double_t w1 = 0;; 1606 Double_t w2 = 0;; 1607 for (i = ibeg; i <= iend; i++) {; 1608 for (j = jbeg; j <= jend; j++) {; 1609 for (k = kbeg; k <= kend; k++) {; 1610 bin = h1->GetBin(i,j,k);; 1611 sum1 += h1->GetBinContent(bin);; 1612 sum2 += h2->GetBinContent(bin);; 1613 Double_t ew1 = h1->GetBinError(bin);; 1614 Double_t ew2 = h2->GetBinError(bin);; 1615 w1 += ew1*ew1;; 1616 w2 += ew2*ew2;; 1617 }; 1618 }; 1619 }; 1620 ; 1621 ; 1622 // Check that both scatterplots contain events; 1623 if (sum1 == 0) {; 1624 Error(""KolmogorovTest"",""Integral is zero for h1=%s\n"",h1->GetName());; 1625 return 0;; 1626 }; 1627 if (sum2 == 0) {; 1628 Error(""KolmogorovTest"",""Integral is zero for h2=%s\n"",h2->GetName());; 1629 return 0;; 1630 }; 1631 // calculate the effective entries.; 1632 // the case when errors are zero (w1 == 0 or w2 ==0) are equivalent to; 1633 // compare to a function. In that case the rescaling is done only on sqrt(esum2) or sqrt(esum1); 1634 Double_t esum1 = 0, esum2 = 0;; 1635 if (w1 > 0); 1636 esum1 = sum1 * sum1 / w1;; 1637 else; 1638 afunc1 = kTRUE; // use later for calculating z; 1639 ; 1640 if (w2 > 0); 1641 esum2 = sum2 * sum2 / w2;; 1642 else; 1643 afunc2 = kTRUE; // use later for calculating z; 1644 ; 1645 if (afunc2 && afunc1) {; 1646 Error(""KolmogorovTest"",""Errors are zero for both histograms\n"");; 1647 return 0;; 1648 }; 1649 ; 1650 // Find Kolmogorov distance; 1651 // order is arbitrary take average of all possible 6 starting orders x,y,z; 1652 int order[3] = {0,1,2};; 1653 int binbeg[3];; 1654 int binend[3];; 1655 int ibin[3];; 1656 binbeg[0] = ibeg; binbeg[1] = jbeg; binbeg[2] = kbeg;; 1657 binend[0] = iend; binend[1] = jend; binend[2] = kend;; 1658 Double_t vdfmax[6]; // there are in total 6 combinations; 1659 int icomb = 0;; 1660 Double_t s1 = 1./(6.*sum1);; 1661 Double_t s2 = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:64147,error,errors,64147,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['error'],['errors']
Availability,"0;; 16732 } else if (callback_ret > 0) {; 16733 /* Callback exists and returns >0: Initializing complete,; 16734 * civetweb should not modify the SSL context. */; 16735 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16736 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16737 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16738 return 0;; 16739 }; 16740 return 1;; 16741 }; 16742 /* If the callback does not exist or return 0, civetweb must initialize; 16743 * the SSL context. Handle ""domain"" callback next. */; 16744 ; 16745 /* Check for external domain SSL_CTX callback. */; 16746 callback_ret = (phys_ctx->callbacks.external_ssl_ctx_domain == NULL); 16747 ? 0; 16748 : (phys_ctx->callbacks.external_ssl_ctx_domain(; 16749 dom_ctx->config[AUTHENTICATION_DOMAIN],; 16750 &ssl_ctx,; 16751 phys_ctx->user_data));; 16752 ; 16753 if (callback_ret < 0) {; 16754 /* Callback < 0: Error. Abort init. */; 16755 mg_cry_ctx_internal(; 16756 phys_ctx,; 16757 ""external_ssl_ctx_domain callback returned error: %i"",; 16758 callback_ret);; 16759 return 0;; 16760 } else if (callback_ret > 0) {; 16761 /* Callback > 0: Consider init done. */; 16762 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16763 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16764 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16765 return 0;; 16766 }; 16767 return 1;; 16768 }; 16769 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16770 * 0, CivetWeb should continue initializing SSL */; 16771 ; 16772 /* If PEM file is not specified and the init_ssl callbacks; 16773 * are not specified, setup will fail. */; 16774 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16775 && (phys_ctx->callbacks.init_ssl == NULL); 16776 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16777 /* No certificate and no init_ssl callbacks:; 16778 * Essential data to set up TLS is missing.; 16779 */; 16780 mg_cry_ctx_internal(phys_ctx,; 16781 ""Initializing SSL failed: -%s is not set"",; 16782 config_options[SSL_CERTIFICATE].name);; 1678",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:497311,error,error,497311,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"0;; 16733 } else if (callback_ret > 0) {; 16734 /* Callback exists and returns >0: Initializing complete,; 16735 * civetweb should not modify the SSL context. */; 16736 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16737 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16738 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16739 return 0;; 16740 }; 16741 return 1;; 16742 }; 16743 /* If the callback does not exist or return 0, civetweb must initialize; 16744 * the SSL context. Handle ""domain"" callback next. */; 16745 ; 16746 /* Check for external domain SSL_CTX callback. */; 16747 callback_ret = (phys_ctx->callbacks.external_ssl_ctx_domain == NULL); 16748 ? 0; 16749 : (phys_ctx->callbacks.external_ssl_ctx_domain(; 16750 dom_ctx->config[AUTHENTICATION_DOMAIN],; 16751 &ssl_ctx,; 16752 phys_ctx->user_data));; 16753 ; 16754 if (callback_ret < 0) {; 16755 /* Callback < 0: Error. Abort init. */; 16756 mg_cry_ctx_internal(; 16757 phys_ctx,; 16758 ""external_ssl_ctx_domain callback returned error: %i"",; 16759 callback_ret);; 16760 return 0;; 16761 } else if (callback_ret > 0) {; 16762 /* Callback > 0: Consider init done. */; 16763 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16764 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16765 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16766 return 0;; 16767 }; 16768 return 1;; 16769 }; 16770 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16771 * 0, CivetWeb should continue initializing SSL */; 16772 ; 16773 /* If PEM file is not specified and the init_ssl callbacks; 16774 * are not specified, setup will fail. */; 16775 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16776 && (phys_ctx->callbacks.init_ssl == NULL); 16777 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16778 /* No certificate and no init_ssl callbacks:; 16779 * Essential data to set up TLS is missing.; 16780 */; 16781 mg_cry_ctx_internal(phys_ctx,; 16782 ""Initializing SSL failed: -%s is not set"",; 16783 config_options[SSL_CERTIFICATE].name);; 1678",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:497344,error,error,497344,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"0;; 3374 ; 3375 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3376 ; 3377 if (!conn) {; 3378 puts(buf);; 3379 return;; 3380 }; 3381 ; 3382 /* Do not lock when getting the callback value, here and below.; 3383 * I suppose this is fine, since function cannot disappear in the; 3384 * same way string option can. */; 3385 if ((conn->phys_ctx->callbacks.log_message == NULL); 3386 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. Used for logging, if connection; 3434 * is not applicable at the moment of logging. */; 3435static struct mg_connection *; 3436fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3437{; 3438 static const struct mg_connection conn_z",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:101362,error,error,101362,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"0;; 3375 ; 3376 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3377 ; 3378 if (!conn) {; 3379 puts(buf);; 3380 return;; 3381 }; 3382 ; 3383 /* Do not lock when getting the callback value, here and below.; 3384 * I suppose this is fine, since function cannot disappear in the; 3385 * same way string option can. */; 3386 if ((conn->phys_ctx->callbacks.log_message == NULL); 3387 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. Used for logging, if connection; 3435 * is not applicable at the moment of logging. */; 3436static struct mg_connection *; 3437fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3438{; 3439 static const struct mg_connection conn_z",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:101394,error,error,101394,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,0=7.28945 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=7.28945 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=7.28945 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so fa,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:28240,error,error,28240,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,2,['error'],['error']
Availability,"0LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { return isfinite(x); }; 782# elif defined(R__MACOSX); 783# ifdef isfinite; 784 // from math.h; 785 { return isfinite(x); }; 786# else; 787 // from cmath; 788 { return std::isfinite(x); }; 789# endif; 790# else; 791 { return finite(x); }; 792# endif; 793#endif; 794 ; 795////////////////////////////////////////////////////////////////////////////////; 796/// Check if it is finite with a mask in order to be consistent in presence of; 797/// fast math.; 798/// Inspired from the CMSSW FWCore/Utilities package; 799 ; 800inline Int_t TMath::Finite(Float_t x); 801#if defined(R__FAST_MATH); 802 ; 803{; 804 const unsigned int mask = 0x7f800000;; 805 union { unsigned int l; float d;} v;; 806 v.d =x;; 807 return (v.l&mask)!=mask;; 808}; 809#else; 810{ return std::isfinite(x); }; 811#endif; 812 ; 813// This namespace provides all the routines necessary for checking if a number; 814// is a NaN also in presence of optimisations affecting the behaviour of the; 815// floating point calculations.; 816// Inspired from the CMSSW FWCore/Utilities package; 817 ; 818#if defined (R__FAST_MATH); 819namespace ROOT {; 820namespace Internal {; 821namespace Math {; 822// abridged from GNU libc 2.6.1 - in detail from; 823// math/math_private.h; 824// sysdeps/ieee754/ldbl-96/math_ldbl.h; 825 ; 826// part of this file:; 827 /*; 828 * ====================================================; 829 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.; 830 *; 831 * Developed at SunPro, a Sun Microsystems, Inc. business.; 832 * Permission to use, copy, modify, and distribute this; 833 * software is freely granted, provided that this notice; 834 * is preserved.; 835 * ====================================================; 836 */; 837 ; 838 // A union which permits us to convert between a double and two 32 bit ints.; 839 typedef union {; 840 Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:29865,mask,mask,29865,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,2,['mask'],['mask']
Availability,"0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFumili.html:22899,error,error,22899,root/html528/TFumili.html,https://root.cern,https://root.cern/root/html528/TFumili.html,6,['error'],['error']
Availability,"0] PROGRESS:Caching -- current storage has size 10; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf_over_wrap_pdf_Int[pTV]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_wrap_pdf_over_wrap_pdf_Int[pTV]_pseudo_dh) Summation contains a RooNLLVar, using its error level; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0 cHl3=0 cHq3=-0.0202918; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.213672 cHl3=1.97898 cHq3=0.00773174; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLogVal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:8740,recover,recover,8740,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Availability,"0|30|10|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=10Optimizer=ADAM,DropConfig=0.0+0.+0.+0.:Architecture=CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""10|30"" [The Layout of the input]; : Layout: ""LSTM|10|30|10|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : RandomSeed: ""1234"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""0.2"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=10Optimizer=ADAM,DropConfig=0.0+0.+0.+0."" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:2491,error,error,2491,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['error'],['error']
Availability,"0}; 61End_Macro; 62*/; 63////////////////////////////////////////////////////////////////////////////////; 64/// TGraphMultiErrors default constructor.; 65 ; 66TGraphMultiErrors::TGraphMultiErrors(); 67 : fNYErrors(0), fSumErrorsMode(TGraphMultiErrors::kOnlyFirst), fExL(nullptr), fExH(nullptr); 68{; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////////; 72/// TGraphMultiErrors default constructor with name and title.; 73 ; 74TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title) : TGraphMultiErrors(); 75{; 76 SetNameTitle(name, title);; 77}; 78 ; 79////////////////////////////////////////////////////////////////////////////////; 80/// TGraphMultiErrors normal constructor with np points and ne y-errors.; 81///; 82/// All values are initialized to 0.; 83 ; 84TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne); 85 : TGraph(np), fNYErrors(ne), fSumErrorsMode(TGraphMultiErrors::kOnlyFirst); 86{; 87 CtorAllocate();; 88}; 89 ; 90////////////////////////////////////////////////////////////////////////////////; 91/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 92///; 93/// All values are initialized to 0.; 94 ; 95TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne); 96 : TGraphMultiErrors(np, ne); 97{; 98 SetNameTitle(name, title);; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////////; 102/// TGraphMultiErrors normal constructor with `np` points and a single y-error.; 103///; 104/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 105/// If `exL`,`exH` or `eyL`,`exH` are NULL, the corresponding values are preset to zero.; 106 ; 107TGraphMultiErrors::TGraphMultiErrors(Int_t np, const Float_t *x, const Float_t *y, const Float_t *exL,; 108 const Float_t *exH, const Float_t *eyL, const Float_t *eyH, Int_t m); 109 : TGraph(np, x, y),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:3463,error,errors,3463,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,1 0; : 629 Minimum Test error found - save the configuration ; : 629 | 83.7285 58.2513 0.0204361 0.0018731 43096.5 0; : 630 Minimum Test error found - save the configuration ; : 630 | 82.639 58.0942 0.0203377 0.00185077 43273.9 0; : 631 Minimum Test error found - save the configuration ; : 631 | 81.6101 57.1049 0.0203504 0.00184845 43238.6 0; : 632 | 80.6827 57.1221 0.0201225 0.00176999 43590.8 1; : 633 Minimum Test error found - save the configuration ; : 633 | 79.5527 56.2669 0.0201884 0.00185082 43626.2 0; : 634 Minimum Test error found - save the configuration ; : 634 | 78.6493 55.4759 0.0202109 0.00182609 43514.1 0; : 635 Minimum Test error found - save the configuration ; : 635 | 77.3887 55.223 0.020166 0.00184577 43667.6 0; : 636 Minimum Test error found - save the configuration ; : 636 | 76.4488 55.0573 0.020202 0.00188181 43667.6 0; : 637 Minimum Test error found - save the configuration ; : 637 | 75.4894 54.0711 0.0202555 0.00186268 43495.3 0; : 638 Minimum Test error found - save the configuration ; : 638 | 74.5839 53.0373 0.0201113 0.00181775 43731.4 0; : 639 Minimum Test error found - save the configuration ; : 639 | 73.497 52.6629 0.0200838 0.00181639 43793.9 0; : 640 Minimum Test error found - save the configuration ; : 640 | 72.4195 52.0402 0.0201153 0.00181887 43724.4 0; : 641 | 71.5077 52.3492 0.0200565 0.00175616 43715 1; : 642 Minimum Test error found - save the configuration ; : 642 | 70.8829 51.1798 0.0201079 0.00181215 43725.9 0; : 643 Minimum Test error found - save the configuration ; : 643 | 69.8143 50.8726 0.0201142 0.00180555 43695.1 0; : 644 Minimum Test error found - save the configuration ; : 644 | 68.806 50.1244 0.0201666 0.00186273 43706.7 0; : 645 Minimum Test error found - save the configuration ; : 645 | 67.8562 49.8828 0.0202418 0.00183622 43465.2 0; : 646 Minimum Test error found - save the configuration ; : 646 | 67.0733 49.0958 0.0205161 0.00187288 42911 0; : 647 Minimum Test error found - save the configuration ; : 647 | 66.0,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:82874,error,error,82874,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,1 0; : 651 Minimum Test error found - save the configuration ; : 651 | 62.641 46.7417 0.020143 0.00182812 43680.3 0; : 652 Minimum Test error found - save the configuration ; : 652 | 61.875 46.3421 0.0201124 0.00182035 43734.8 0; : 653 Minimum Test error found - save the configuration ; : 653 | 61.1155 45.9892 0.0201549 0.00182806 43651.9 0; : 654 | 60.3955 46.5097 0.0201006 0.00177795 43661.9 1; : 655 Minimum Test error found - save the configuration ; : 655 | 59.5776 45.1172 0.0204622 0.00186914 43026.9 0; : 656 Minimum Test error found - save the configuration ; : 656 | 58.5813 44.6814 0.020214 0.00181641 43484.1 0; : 657 Minimum Test error found - save the configuration ; : 657 | 58.1075 44.2582 0.0201216 0.0018139 43697.5 0; : 658 Minimum Test error found - save the configuration ; : 658 | 57.7428 43.9646 0.0201606 0.00184632 43681.8 0; : 659 Minimum Test error found - save the configuration ; : 659 | 56.5877 43.7448 0.0201275 0.00181379 43683.2 0; : 660 Minimum Test error found - save the configuration ; : 660 | 56.1107 42.9226 0.0200887 0.00181275 43773.3 0; : 661 Minimum Test error found - save the configuration ; : 661 | 55.5039 42.6809 0.0201245 0.00180935 43679.7 0; : 662 Minimum Test error found - save the configuration ; : 662 | 54.3572 42.2723 0.0202587 0.00183315 43417.9 0; : 663 Minimum Test error found - save the configuration ; : 663 | 53.566 41.7624 0.0203991 0.00186617 43166.5 0; : 664 Minimum Test error found - save the configuration ; : 664 | 52.9086 41.2393 0.0201899 0.00182999 43573.1 0; : 665 Minimum Test error found - save the configuration ; : 665 | 52.1886 40.6761 0.020181 0.00182542 43583.6 0; : 666 Minimum Test error found - save the configuration ; : 666 | 51.2956 40.6256 0.0201396 0.00182896 43690.5 0; : 667 Minimum Test error found - save the configuration ; : 667 | 50.7315 40.0752 0.0201193 0.00182284 43724.4 0; : 668 | 49.9429 40.0919 0.0200598 0.00176937 43738.7 1; : 669 Minimum Test error found - save the configuration ; : 669 | ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:85252,error,error,85252,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,1 43774.1 0; : 822 | 8.40042 12.784 0.0200174 0.0017606 43819.3 1; : 823 | 8.60218 12.5837 0.0200326 0.00176535 43794.3 2; : 824 | 8.73942 12.9376 0.0204734 0.00180446 42851.9 3; : 825 Minimum Test error found - save the configuration ; : 825 | 8.34428 12.1043 0.0201737 0.00186372 43692 0; : 826 Minimum Test error found - save the configuration ; : 826 | 8.00332 12.0945 0.0202264 0.00188916 43627.1 0; : 827 Minimum Test error found - save the configuration ; : 827 | 7.99254 11.726 0.0202903 0.00182656 43328.1 0; : 828 | 7.97363 11.7656 0.0202489 0.00176045 43270.2 1; : 829 | 7.98909 11.7293 0.0200352 0.00175475 43762.5 2; : 830 | 7.96378 12.2512 0.0200553 0.00175667 43719.1 3; : 831 Minimum Test error found - save the configuration ; : 831 | 8.22376 11.6427 0.0201223 0.00181824 43706.2 0; : 832 Minimum Test error found - save the configuration ; : 832 | 7.83287 11.3952 0.0201042 0.0018127 43736.1 0; : 833 | 7.77712 11.6148 0.0201377 0.00175591 43521.3 1; : 834 Minimum Test error found - save the configuration ; : 834 | 7.55905 11.3034 0.0200924 0.00180566 43747.5 0; : 835 | 7.51796 11.4086 0.0200653 0.00174972 43678.7 1; : 836 | 7.6539 11.6743 0.0201454 0.00175856 43509.3 2; : 837 | 7.98319 11.3225 0.0201169 0.00175643 43571.8 3; : 838 | 7.66699 11.6657 0.0201662 0.00181142 43585.5 4; : 839 Minimum Test error found - save the configuration ; : 839 | 7.52525 10.9666 0.0202646 0.00182844 43392.9 0; : 840 | 7.48548 11.313 0.020051 0.00174873 43710.5 1; : 841 | 7.28024 11.1847 0.0200374 0.0017493 43744.4 2; : 842 | 7.18939 11.0082 0.0200397 0.00175322 43748.2 3; : 843 Minimum Test error found - save the configuration ; : 843 | 7.01613 10.4197 0.0201334 0.00182993 43707.5 0; : 844 | 6.83302 10.8151 0.020039 0.00176037 43767.1 1; : 845 | 6.97518 10.5462 0.0200409 0.00175987 43761.2 2; : 846 | 6.93317 10.5904 0.0200239 0.00176026 43802.8 3; : 847 | 6.86223 10.6492 0.0200268 0.00176058 43796.8 4; : 848 | 7.00201 10.9279 0.0200258 0.00175939 43796.3 5; : 849 | 6.9266 10.4735 ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:101098,error,error,101098,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,1 7; : 992 | 3.45322 4.61211 0.0200841 0.00175232 43640 8; : 993 | 3.32586 4.54016 0.0200585 0.00176018 43719.9 9; : 994 | 3.54317 4.65875 0.0201539 0.00181263 43617.4 10; : 995 | 3.38008 5.03795 0.0206532 0.00179392 42419.4 11; : 996 | 3.40103 4.41295 0.0204644 0.00176564 42783.5 12; : 997 | 3.23461 4.8031 0.0203306 0.00176616 43093.1 13; : 998 | 3.41797 4.46788 0.0203618 0.00175568 42996.7 14; : 999 Minimum Test error found - save the configuration ; : 999 | 3.31412 4.14973 0.0202938 0.00187677 43438 0; : 1000 | 3.20867 4.17264 0.0201802 0.00179416 43511.4 1; : 1001 | 3.31742 4.17699 0.020287 0.00175118 43159.8 2; : 1002 | 3.35839 4.8143 0.0207434 0.00177731 42180.6 3; : 1003 Minimum Test error found - save the configuration ; : 1003 | 3.42381 4.04915 0.0202591 0.00184351 43441.4 0; : 1004 Minimum Test error found - save the configuration ; : 1004 | 3.27488 4.0384 0.0205262 0.00189376 42935.9 0; : 1005 | 3.09776 4.19224 0.0200956 0.00176781 43649.6 1; : 1006 Minimum Test error found - save the configuration ; : 1006 | 3.1757 3.91876 0.0201134 0.00183093 43757.7 0; : 1007 | 3.17471 4.33126 0.0203423 0.00178093 43100.3 1; : 1008 | 3.23752 4.46797 0.0204556 0.0017847 42847.4 2; : 1009 | 3.5099 4.04664 0.0203963 0.00177013 42950.3 3; : 1010 | 3.39993 4.32216 0.0201011 0.00176915 43639.8 4; : 1011 | 3.28002 4.35065 0.020045 0.00175269 43734.2 5; : 1012 | 3.24301 4.1309 0.0202482 0.00178612 43332 6; : 1013 | 3.47685 4.13785 0.0205714 0.00178247 42578.3 7; : 1014 | 3.38367 4.59532 0.0203076 0.00178189 43183.2 8; : 1015 Minimum Test error found - save the configuration ; : 1015 | 3.15343 3.81668 0.0204522 0.00185272 43011.9 0; : 1016 | 2.99441 4.01707 0.0202697 0.00183758 43402.5 1; : 1017 | 3.3956 4.54944 0.0201133 0.00176644 43604.1 2; : 1018 | 3.2792 3.85661 0.0202747 0.00181943 43348.2 3; : 1019 | 3.37748 4.22044 0.0208054 0.00183497 42170.8 4; : 1020 | 3.48034 4.07947 0.020447 0.00177824 42852.4 5; : 1021 | 3.50059 4.11275 0.020219 0.00176964 43361.9 6; : 1022 | 3.151,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:113601,error,error,113601,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(ESlaves list, Long_t timeout, Int_t endtype, Bool_t deactonfail); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of messages; received. Can be 0 if there are no active slaves.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. void CleanGDirectory(TList* ol); Remove links to objects in list 'ol' from gDirectory. Int_t CollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect and analyze available input from socket s.; Returns 0 on success, -1 if any failure occurs. Int_t HandleInputMessage(TSlave* wrk, TMessage* m, Bool_t deactonfail = kFALSE); Analyze the received message.; Returns 0 on success (1 if this the last message from this socket), -1 if; any failure occurs. void HandleSubmerger(TMessage* mess, TSlave* sl); Process a message of type kPROOF_SUBMERGER. void RedirectWorker(TSocket* s, TSlave* sl, Int_t output_size); Redirect output of worker sl to some merger. Int_t FindNextFreeMerger(); Return a merger, which is both active and still accepts some workers to be; assigned to it. It works on the 'round-robin' basis. void AskForOutput(TSlave* sl); Master asks for output from worker sl. void UpdateDialog(); Final update of the progress dialog. void ActivateAsyncInput(); Activate the a-sync input handler. void DeActivateAsyncInput(); De-activate a-sync input handler. Int_t GetActiveMergersCount(); Get the active mergers count. B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:43228,avail,available,43228,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,3,['avail'],['available']
Availability,"1 in case; the mode did not change (was already as requested or wrong; input arguments) and -1 in case of failure, in which case; the file cannot be used anymore. Bool_t ReadBuffer(char* buffer, Int_t length); Read a data chunk of the given size. param buffer: a pointer to a buffer big enough to hold the data; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffer(char* buffer, Long64_t position, Int_t length); Read a data chunk of the given size, starting from the given offset. param buffer: a pointer to a buffer big enough to hold the data; param position: offset from the beginning of the file; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffers(char* buffer, Long64_t* position, Int_t* length, Int_t nbuffs); Read scattered data chunks in one operation. param buffer: a pointer to a buffer big enough to hold all of the; requested data; param position: position[i] is the seek position of chunk i of len; length[i]; param length: length[i] is the length of the chunk at offset; position[i]; param nbuffs: number of chunks; returns: kTRUE in case of failure. Bool_t WriteBuffer(const char* buffer, Int_t length); Write a data chunk. param buffer: the data to be written; param length: the size of the buffer; returns: kTRUE in case of failure. void Flush(). void Seek(Long64_t offset, TFile::ERelativeTo position = kBeg); Set the position within the file. param offset: the new offset relative to position; param position: the relative position, either kBeg, kCur or kEnd. Bool_t IsUseable() const; Check the file is open and isn't a zombie. Bool_t GetVectorReadLimits(); Find the server-specific readv config params. Returns kFALSE in case of; error, kTRUE otherwise. void SetEnv(); Map ROOT and xrootd environment variables. TNetXNGFile(); {}. TNetXNGFile(const char* url, Option_t* mode = """", const char* title = """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE). TString GetNewUrl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetXNGFile.html:25211,failure,failure,25211,root/html534/TNetXNGFile.html,https://root.cern,https://root.cern/root/html534/TNetXNGFile.html,1,['failure'],['failure']
Availability,"1 in case; the mode did not change (was already as requested or wrong; input arguments) and -1 in case of failure, in which case; the file cannot be used anymore. Bool_t ReadBuffer(char* buffer, Int_t length); Read a data chunk of the given size. param buffer: a pointer to a buffer big enough to hold the data; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffer(char* buffer, Long64_t position, Int_t length); Read a data chunk of the given size, starting from the given offset. param buffer: a pointer to a buffer big enough to hold the data; param position: offset from the beginning of the file; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffers(char* buffer, Long64_t* position, Int_t* length, Int_t nbuffs); Read scattered data chunks in one operation. param buffer: a pointer to a buffer big enough to hold all of the; requested data; param position: position[i] is the seek position of chunk i of len; length[i]; param length: length[i] is the length of the chunk at offset; position[i]; param nbuffs: number of chunks; returns: kTRUE in case of failure. Bool_t WriteBuffer(const char* buffer, Int_t length); Write a data chunk. param buffer: the data to be written; param length: the size of the buffer; returns: kTRUE in case of failure. void Flush(). void Seek(Long64_t offset, TFile::ERelativeTo position = kBeg); Set the position within the file. param offset: the new offset relative to position; param position: the relative position, either kBeg, kCur or kEnd. Int_t ParseOpenMode(Option_t* in, TString& modestr, XrdCl::OpenFlags::Flags& mode, Bool_t assumeRead); Parse a file open mode given as a string into a canonically formatted; output mode string and an integer code that the xroot client can use. param in: the file open mode as a string (in); modestr: open mode string after parsing (out); mode: correctly parsed option mode code (out); assumeRead: if the open mode is not recognised a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetXNGFile.html:26559,failure,failure,26559,root/html602/TNetXNGFile.html,https://root.cern,https://root.cern/root/html602/TNetXNGFile.html,2,['failure'],['failure']
Availability,1 nsig=145.338 sig1frac=0.822833; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-798.509) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.791035 a1=-0.287544 mean=4.98693 nbkg=127.577 nsig=149.203 sig1frac=0.914567; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 410; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 400; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 390; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-977.775) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.565967 a1=-0.529635 mean=5.0065 nbkg=153.38 nsig=185.083 sig1frac=0.751239; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 380; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 370; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-945.036) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.824344 a1=-0.338546 mean=5.06339 nbkg=161.705 nsig=169.087 sig1frac=0.910016; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 360; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 350; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 340; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 330; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 320; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 310; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-831.776) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.823781 a1=-0.287947 mean=4.96347 nbkg=133.185 nsig=155.535 sig1,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8C.html:20402,error,errors,20402,doc/master/rf801__mcstudy_8C.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html,4,['error'],"['error', 'errors']"
Availability,"1 of file GSLMultiRootFinder.cxx. ◆ GetGSLType(). const gsl_multiroot_fsolver_type * ROOT::Math::GetGSLType ; (; GSLMultiRootFinder::EType ; type). Definition at line 183 of file GSLMultiRootFinder.cxx. ◆ getSum(). int ROOT::Math::getSum ; (; const int * ; x, . int ; n . ). Definition at line 534 of file GoFTest.cxx. ◆ human_readable(). template<class char_t , class traits_t > . std::basic_ios< char_t, traits_t > & ROOT::Math::human_readable ; (; std::basic_ios< char_t, traits_t > & ; ios). inline . Definition at line 197 of file GenVectorIO.h. ◆ Lmag(). template<class A , class T > . T ROOT::Math::Lmag ; (; const VecExpr< A, T, 4 > & ; rhs). inline . Definition at line 308 of file Functions.h. ◆ Lmag2(). template<class A , class T > . T ROOT::Math::Lmag2 ; (; const VecExpr< A, T, 4 > & ; rhs). inline . Definition at line 284 of file Functions.h. ◆ log1p(). double ROOT::Math::log1p ; (; double ; x). inline . declarations for functions which are not implemented by some compilers ; log(1+x) with error cancelation when x is small ; Definition at line 98 of file Math.h. ◆ machine_readable(). template<class char_t , class traits_t > . std::basic_ios< char_t, traits_t > & ROOT::Math::machine_readable ; (; std::basic_ios< char_t, traits_t > & ; ios). inline . Definition at line 208 of file GenVectorIO.h. ◆ Mag(). template<class A , class T , unsigned int D> . T ROOT::Math::Mag ; (; const VecExpr< A, T, D > & ; rhs). inline . Definition at line 261 of file Functions.h. ◆ Mag2(). template<class A , class T , unsigned int D> . T ROOT::Math::Mag2 ; (; const VecExpr< A, T, D > & ; rhs). inline . Definition at line 238 of file Functions.h. ◆ minfunction(). double ROOT::Math::minfunction ; (; const std::vector< double > & ; x). function to return the function values at point x ; Definition at line 19 of file RMinimizer.cxx. ◆ mingradfunction(). TVectorD ROOT::Math::mingradfunction ; (; TVectorD ; y). function to return the gradient values at point y ; Definition at line 25 of file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Math.html:153674,error,error,153674,doc/v632/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Math.html,1,['error'],['error']
Availability,"1 of file TProof.cxx. ◆ SetMaxDrawQueries(). void TProof::SetMaxDrawQueries ; (; Int_t ; max). Set max number of draw queries whose results are saved. ; Definition at line 2115 of file TProof.cxx. ◆ SetMonitor(). void TProof::SetMonitor ; (; TMonitor * ; mon = 0, . Bool_t ; on = kTRUE . ). private . Activate (on == TRUE) or deactivate (on == FALSE) all sockets monitored by 'mon'. ; Definition at line 2408 of file TProof.cxx. ◆ SetParallel(). Int_t TProof::SetParallel ; (; Int_t ; nodes = -1, . Bool_t ; random = kFALSE . ). Tell PROOF how many slaves to use in parallel. ; Returns the number of parallel slaves. Returns -1 in case of error. ; Definition at line 7140 of file TProof.cxx. ◆ SetParallelSilent(). Int_t TProof::SetParallelSilent ; (; Int_t ; nodes, . Bool_t ; random = kFALSE . ). private . Tell PROOF how many slaves to use in parallel. ; If random is TRUE a random selection is done (if nodes is less than the available nodes). Returns the number of parallel slaves. Returns -1 in case of error. ; Definition at line 7112 of file TProof.cxx. ◆ SetParameter() [1/5]. void TProof::SetParameter ; (; const char * ; par, . const char * ; value . ). Set input list parameter. ; If the parameter is already set it will be set to the new value. ; Definition at line 9822 of file TProof.cxx. ◆ SetParameter() [2/5]. void TProof::SetParameter ; (; const char * ; par, . Double_t ; value . ). Set an input list parameter. ; Definition at line 9898 of file TProof.cxx. ◆ SetParameter() [3/5]. void TProof::SetParameter ; (; const char * ; par, . Int_t ; value . ). Set an input list parameter. ; Definition at line 9841 of file TProof.cxx. ◆ SetParameter() [4/5]. void TProof::SetParameter ; (; const char * ; par, . Long64_t ; value . ). Set an input list parameter. ; Definition at line 9879 of file TProof.cxx. ◆ SetParameter() [5/5]. void TProof::SetParameter ; (; const char * ; par, . Long_t ; value . ). Set an input list parameter. ; Definition at line 9860 of file TProof.cxx. ◆ SetP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:145119,error,error,145119,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['error'],['error']
Availability,"1 of file TProofPlayerLite.cxx. ◆ Finalize() [2/2]. Long64_t TProofPlayerLite::Finalize ; (; TQueryResult * ; qr). inlineoverridevirtual . Finalize query (may not be used in this class). ; Reimplemented from TProofPlayer.; Definition at line 48 of file TProofPlayerLite.h. ◆ HandleTimer(). Bool_t TProofPlayerLite::HandleTimer ; (; TTimer * ; timer). overrideprotectedvirtual . Send feedback objects to client. ; Reimplemented from TObject.; Definition at line 442 of file TProofPlayerLite.cxx. ◆ IsA(). TClass * TProofPlayerLite::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TProofPlayer.; Definition at line 53 of file TProofPlayerLite.h. ◆ MakeSelector(). Int_t TProofPlayerLite::MakeSelector ; (; const char * ; selfile). protected . Create the selector object and save the relevant files and binary information in the cache so that the worker can pick it up. ; Returns 0 and fill fSelector in case of success. Returns -1 and sets fSelector to 0 in case of failure. ; Definition at line 45 of file TProofPlayerLite.cxx. ◆ Process() [1/2]. Long64_t TProofPlayerLite::Process ; (; TDSet * ; dset, . const char * ; selector_file, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0 . ). overridevirtual . Process specified TDSet on PROOF. ; This method is called on client and on the PROOF master. The return value is -1 in case of error and TSelector::GetStatus() in in case of success. ; Reimplemented from TProofPlayer.; Definition at line 109 of file TProofPlayerLite.cxx. ◆ Process() [2/2]. Long64_t TProofPlayerLite::Process ; (; TDSet * ; dset, . TSelector * ; selector, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0 . ). overridevirtual . Process specified TDSet on PROOF. ; This method is called on client and on the PROOF master. The return value is -1 in case of an error and TSelector::GetStatus() in in case of success. ; Reimplemented from TProofPlayer.; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:29550,failure,failure,29550,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,1,['failure'],['failure']
Availability,"1 return fTree->GetLeaf(branchname, leafname);; 1092 }; 1093 return nullptr;; 1094}; 1095 ; 1096////////////////////////////////////////////////////////////////////////////////; 1097/// Return a pointer to the leaf name in the current tree.; 1098 ; 1099TLeaf* TChain::GetLeaf(const char* name); 1100{; 1101 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 1102 // Make sure the element list is up to date; 1103 if (!TestBit(kProofUptodate)); 1104 SetProof(true, true);; 1105 return fProofChain->GetLeaf(name);; 1106 }; 1107 if (fTree) {; 1108 return fTree->GetLeaf(name);; 1109 }; 1110 LoadTree(0);; 1111 if (fTree) {; 1112 return fTree->GetLeaf(name);; 1113 }; 1114 return nullptr;; 1115}; 1116 ; 1117////////////////////////////////////////////////////////////////////////////////; 1118/// Return a pointer to the list of branches of the current tree.; 1119///; 1120/// Warning: If there is no current TTree yet, this routine will open the; 1121/// first in the chain.; 1122///; 1123/// Returns 0 on failure.; 1124 ; 1125TObjArray* TChain::GetListOfBranches(); 1126{; 1127 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 1128 // Make sure the element list is up to date; 1129 if (!TestBit(kProofUptodate)); 1130 SetProof(true, true);; 1131 return fProofChain->GetListOfBranches();; 1132 }; 1133 if (fTree) {; 1134 return fTree->GetListOfBranches();; 1135 }; 1136 LoadTree(0);; 1137 if (fTree) {; 1138 return fTree->GetListOfBranches();; 1139 }; 1140 return nullptr;; 1141}; 1142 ; 1143////////////////////////////////////////////////////////////////////////////////; 1144/// Return a pointer to the list of leaves of the current tree.; 1145///; 1146/// Warning: May set the current tree!; 1147 ; 1148TObjArray* TChain::GetListOfLeaves(); 1149{; 1150 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 1151 // Make sure the element list is up to date; 1152 if (!TestBit(kProofUptodate)); 1153 SetProof(true, true);; 1154 return fProofChain->GetListOfLeaves();; 1155 }; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:41777,failure,failure,41777,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['failure'],['failure']
Availability,"1 same"");; 207 ; 208 ; 209The default drawing option can be set with `TH1::SetOption` and retrieve; 210using `TH1::GetOption`:; 211 ; 212 root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; 213 root [1] h->Draw(""E""); // Draw ""h"" using error bars; 214 root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; 215 root [4] h->Draw(); // Draw ""h"" using error bars; 216 root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; 217 (const Option_t* 0xa3ff948)""E""; 218 ; 219 ; 220\anchor HP01a; 221#### Options supported for 1D and 2D histograms; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""E"" | Draw error bars. |; 226| ""AXIS"" | Draw only axis. |; 227| ""AXIG"" | Draw only grid (if the grid is requested). |; 228| \anchor OPTHIST ""HIST"" | When an histogram has errors it is visualized by default with error bars. To visualize it without errors use the option ""HIST"" together with the required option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the histogram and not the associated function(s). |; 229| ""FUNC"" | When an histogram has a fitted function, this option allows to draw the fit result only. |; 230| ""SAME"" | Superimpose on previous picture in the same pad. |; 231| ""SAMES"" | Same as ""SAME"" and draw the statistics box|; 232| ""PFC"" | Palette Fill Color: histogram's fill color is taken in the current palette. |; 233| ""PLC"" | Palette Line Color: histogram's line color is taken in the current palette. |; 234| ""PMC"" | Palette Marker Color: histogram's marker color is taken in the current palette. |; 235| ""LEGO"" | Draw a lego plot with hidden line removal. |; 236| ""LEGO1"" | Draw a lego plot with hidden surface removal. |; 237| ""LEGO2"" | Draw a lego plot using colors to show the cell contents When the option ""0"" is used with any LEGO option, the empty bins are not drawn.|; 238| ""LEGO3"" | Draw a lego plot with hidden surface remo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:8898,error,errors,8898,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['error'],['errors']
Availability,"1 }; 2812}; 2813 ; 2814////////////////////////////////////////////////////////////////////////////////; 2815/// Compute distance from point px,py to a line.; 2816///; 2817/// Compute the closest distance of approach from point px,py to elements; 2818/// of a histogram.; 2819/// The distance is computed in pixels units.; 2820///; 2821/// #### Algorithm:; 2822/// Currently, this simple model computes the distance from the mouse; 2823/// to the histogram contour only.; 2824 ; 2825Int_t TH1::DistancetoPrimitive(Int_t px, Int_t py); 2826{; 2827 if (!fPainter) return 9999;; 2828 return fPainter->DistancetoPrimitive(px,py);; 2829}; 2830 ; 2831////////////////////////////////////////////////////////////////////////////////; 2832/// Performs the operation: `this = this/(c1*f1)`; 2833/// if errors are defined (see TH1::Sumw2), errors are also recalculated.; 2834///; 2835/// Only bins inside the function range are recomputed.; 2836/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2837/// you should call Sumw2 before making this operation.; 2838/// This is particularly important if you fit the histogram after TH1::Divide; 2839///; 2840/// The function return kFALSE if the divide operation failed; 2841 ; 2842Bool_t TH1::Divide(TF1 *f1, Double_t c1); 2843{; 2844 if (!f1) {; 2845 Error(""Divide"",""Attempt to divide by a non-existing function"");; 2846 return kFALSE;; 2847 }; 2848 ; 2849 // delete buffer if it is there since it will become invalid; 2850 if (fBuffer) BufferEmpty(1);; 2851 ; 2852 Int_t nx = GetNbinsX() + 2; // normal bins + uf / of; 2853 Int_t ny = GetNbinsY() + 2;; 2854 Int_t nz = GetNbinsZ() + 2;; 2855 if (fDimension < 2) ny = 1;; 2856 if (fDimension < 3) nz = 1;; 2857 ; 2858 ; 2859 SetMinimum();; 2860 SetMaximum();; 2861 ; 2862 // - Loop on bins (including underflows/overflows); 2863 Int_t bin, binx, biny, binz;; 2864 Double_t cu, w;; 2865 Double_t xx[3];; 2866 Double_t *params = nullptr;; 2867 f1->InitArgs(xx,params);; 2868 for (binz = 0;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:112710,error,errors,112710,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"1"", -0.5, -10., 20.);; RooRealVar a2(""a2"", ""a2"", 0.2, -10., 20.);; RooRealVar a3(""a3"", ""a3"", 0.01);; RooPolynomial pdf(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, RooArgSet(a1, a2, a3));; ; // Create toy data with all-positive coefficients:; std::unique_ptr<RooDataSet> data(pdf.generate(x, 10000));; ; // For plotting.; // We create pointers to the plotted objects. We want these objects to leak out of the function,; // so we can still see them after it returns.; TCanvas* c = new TCanvas();; RooPlot* frame = x.frame();; data->plotOn(frame, RooFit::Name(""data""));; ; // Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; // Therefore, we disable plotting messages in RooFit's message streams:; RooMsgService::instance().getStream(0).removeTopic(RooFit::Plotting);; RooMsgService::instance().getStream(1).removeTopic(RooFit::Plotting);; ; ; // RooFit before ROOT 6.24; // --------------------------------; // Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; // the starting values of the parameters without finding any improvement.; ; // Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Perform a fit:; std::unique_ptr<RooFitResult> fitWithoutRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::end",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:3286,recover,recover,3286,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,1,['recover'],['recover']
Availability,"1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TF11-Dim function classDefinition TF1.h:233; TF1::SetParLimitsvirtual void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax)Set lower and upper limits for parameter ipar.Definition TF1.cxx:3507; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:670; 1, 2 and 3 Dimensional fits are supported. See also TTree::Fit; Return status:. The function return the status of the fit in the following form fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1 . Definition at line 9692 of file TTree.cxx. ◆ UseCurrentStyle(). void TTree::UseCurrentStyle ; (; ). overridevirtual . Replace current attributes by current style. ; Reimplemented from TObject.; Definition at line 9704 of file TTree.cxx. ◆ Write() [1/2]. Int_t TTree::Write ; (; const char * ; name = nullptr, . Int_t ; option = 0, . Int_t ; bufsize = 0 . ); const. overridevirtual . Write this object to the current directory. ; For more see TObject::Write If option & kFlushBasket, call FlushBasket before writing the tree. ; Reimplemented from TObject.; Definition at line 9731 of file TTree.cxx. ◆ Write() [2/2]. Int_t TTree::Write ; (; const char * ; name = nullptr, . Int_t ; option = 0, . Int_t ; bufsize = 0 . ). overridevirtual . Write this object to the current directory. ; For more see TObject::Wr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:221895,error,error,221895,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['error'],['error']
Availability,"1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TF11-Dim function classDefinition TF1.h:233; TF1::SetParLimitsvirtual void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax)Set lower and upper limits for parameter ipar.Definition TF1.cxx:3507; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; 1, 2 and 3 Dimensional fits are supported. See also TTree::Fit; Return status:. The function return the status of the fit in the following form fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1 . Definition at line 9702 of file TTree.cxx. ◆ UseCurrentStyle(). void TTree::UseCurrentStyle ; (; ). overridevirtual . Replace current attributes by current style. ; Reimplemented from TObject.; Definition at line 9714 of file TTree.cxx. ◆ Write() [1/2]. Int_t TTree::Write ; (; const char * ; name = nullptr, . Int_t ; option = 0, . Int_t ; bufsize = 0 . ); const. overridevirtual . Write this object to the current directory. ; For more see TObject::Write If option & kFlushBasket, call FlushBasket before writing the tree. ; Reimplemented from TObject.; Definition at line 9741 of file TTree.cxx. ◆ Write() [2/2]. Int_t TTree::Write ; (; const char * ; name = nullptr, . Int_t ; option = 0, . Int_t ; bufsize = 0 . ). overridevirtual . Write this object to the current directory. ; For more see TObject::Wr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:224858,error,error,224858,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['error'],['error']
Availability,"1(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const TH1& ); Copy constructor.; The list of functions is not copied. (Use Clone if needed). Bool_t AddDirectoryStatus(); static function: cannot be inlined on Windows/NT. void Browse(TBrowser* b); Browe the Histogram object. void Build(); -*-*-*-*-*-*-*-*Creates histogram basic data structure*-*-*-*-*-*-*-*-*-*. Bool_t Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. By default, the function is computed at the centre of the bin.; if option ""I"" is specified (1-d histogram only), the integral of the; function in each bin is used instead of the value of the function at; the centre of the bin.; Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Add. The function return kFALSE if the Add operation failed. Bool_t Add(const TH1* h1, Double_t c1 = 1); Performs the operation: this = this + c1*h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; Note also that adding histogram with labels is not supported, histogram will be; added merging them by bin number independen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:41194,error,errors,41194,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,2,['error'],['errors']
Availability,"1) >= 1) {; 2182 Warning(""Chi2TestX"",""First histogram is not unweighted and option UW has been requested"");; 2183 }; 2184 }; 2185 if ( (!scaledHistogram && comparisonUU) ) {; 2186 if ( ( TMath::Abs(sumBinContent1 - effEntries1) >= 1) || (TMath::Abs(sumBinContent2 - effEntries2) >= 1) ) {; 2187 Warning(""Chi2TestX"",""Both histograms are not unweighted and option UU has been requested"");; 2188 }; 2189 }; 2190 ; 2191 ; 2192 //get number of events in histogram; 2193 if (comparisonUU && scaledHistogram) {; 2194 for (Int_t i = i_start; i <= i_end; ++i) {; 2195 for (Int_t j = j_start; j <= j_end; ++j) {; 2196 for (Int_t k = k_start; k <= k_end; ++k) {; 2197 ; 2198 Int_t bin = GetBin(i, j, k);; 2199 ; 2200 Double_t cnt1 = RetrieveBinContent(bin);; 2201 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2202 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2203 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2204 ; 2205 if (e1sq > 0.0) cnt1 = TMath::Floor(cnt1 * cnt1 / e1sq + 0.5); // avoid rounding errors; 2206 else cnt1 = 0.0;; 2207 ; 2208 if (e2sq > 0.0) cnt2 = TMath::Floor(cnt2 * cnt2 / e2sq + 0.5); // avoid rounding errors; 2209 else cnt2 = 0.0;; 2210 ; 2211 // sum contents; 2212 sum1 += cnt1;; 2213 sum2 += cnt2;; 2214 sumw1 += e1sq;; 2215 sumw2 += e2sq;; 2216 }; 2217 }; 2218 }; 2219 if (sumw1 <= 0.0 || sumw2 <= 0.0) {; 2220 Error(""Chi2TestX"", ""Cannot use option NORM when one histogram has all zero errors"");; 2221 return 0.0;; 2222 }; 2223 ; 2224 } else {; 2225 for (Int_t i = i_start; i <= i_end; ++i) {; 2226 for (Int_t j = j_start; j <= j_end; ++j) {; 2227 for (Int_t k = k_start; k <= k_end; ++k) {; 2228 ; 2229 Int_t bin = GetBin(i, j, k);; 2230 ; 2231 sum1 += RetrieveBinContent(bin);; 2232 sum2 += h2->RetrieveBinContent(bin);; 2233 ; 2234 if ( comparisonWW ) sumw1 += GetBinErrorSqUnchecked(bin);; 2235 if ( comparisonUW || comparisonWW ) sumw2 += h2->GetBinErrorSqUnchecked(bin);; 2236 }; 2237 }; 2238 }; 2239 }; 2240 //checks that the histograms are not empty; 2241 if (sum1 == 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:89550,error,errors,89550,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"1)/2;; 2785 Int_t y_push = (ksize_y-1)/2;; 2786 ; 2787 // main work loop; 2788 for (i=ifirst; i<=ilast; i++){; 2789 for (j=jfirst; j<=jlast; j++) {; 2790 Double_t content = 0.0;; 2791 Double_t error = 0.0;; 2792 Double_t norm = 0.0;; 2793 ; 2794 for (Int_t n=0; n<ksize_x; n++) {; 2795 for (Int_t m=0; m<ksize_y; m++) {; 2796 Int_t xb = i+(n-x_push);; 2797 Int_t yb = j+(m-y_push);; 2798 if ( (xb >= 1) && (xb <= nx) && (yb >= 1) && (yb <= ny) ) {; 2799 bin = GetBin(xb,yb);; 2800 Double_t k = kernel[n*ksize_y +m];; 2801 //if ( (k != 0.0 ) && (buf[bin] != 0.0) ) { // General version probably does not want the second condition; 2802 if ( k != 0.0 ) {; 2803 norm += k;; 2804 content += k*buf[bin];; 2805 if (ebuf) error += k*k*ebuf[bin]*ebuf[bin];; 2806 }; 2807 }; 2808 }; 2809 }; 2810 ; 2811 if ( norm != 0.0 ) {; 2812 SetBinContent(i,j,content/norm);; 2813 if (ebuf) {; 2814 error /= (norm*norm);; 2815 SetBinError(i,j,sqrt(error));; 2816 }; 2817 }; 2818 }; 2819 }; 2820 fEntries = nentries;; 2821 ; 2822 delete [] buf;; 2823 delete [] ebuf;; 2824}; 2825 ; 2826 ; 2827////////////////////////////////////////////////////////////////////////////////; 2828/// Stream an object of class TH2.; 2829 ; 2830void TH2::Streamer(TBuffer &R__b); 2831{; 2832 if (R__b.IsReading()) {; 2833 UInt_t R__s, R__c;; 2834 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 2835 if (R__v > 2) {; 2836 R__b.ReadClassBuffer(TH2::Class(), this, R__v, R__s, R__c);; 2837 return;; 2838 }; 2839 //====process old versions before automatic schema evolution; 2840 TH1::Streamer(R__b);; 2841 R__b >> fScalefactor;; 2842 R__b >> fTsumwy;; 2843 R__b >> fTsumwy2;; 2844 R__b >> fTsumwxy;; 2845 //====end of old versions; 2846 ; 2847 } else {; 2848 R__b.WriteClassBuffer(TH2::Class(),this);; 2849 }; 2850}; 2851 ; 2852 ; 2853//______________________________________________________________________________; 2854// TH2C methods; 2855// TH2C a 2-D histogram with one byte per cell (char); 2856//______________________________________",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:114672,error,error,114672,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,2,['error'],['error']
Availability,"1); 4614 ((TBranch *)fBranches.UncheckedAt(0))->UpdateAddress();; 4615 ; 4616 if (fBranchRef); 4617 fBranchRef->Clear();; 4618 ; 4619#ifdef R__USE_IMT; 4620 const auto useIMT = ROOT::IsImplicitMTEnabled() && fIMTEnabled;; 4621 ROOT::Internal::TBranchIMTHelper imtHelper;; 4622 if (useIMT) {; 4623 fIMTFlush = true;; 4624 fIMTZipBytes.store(0);; 4625 fIMTTotBytes.store(0);; 4626 }; 4627#endif; 4628 ; 4629 for (Int_t i = 0; i < nbranches; ++i) {; 4630 // Loop over all branches, filling and accumulating bytes written and error counts.; 4631 TBranch *branch = (TBranch *)fBranches.UncheckedAt(i);; 4632 ; 4633 if (branch->TestBit(kDoNotProcess)); 4634 continue;; 4635 ; 4636#ifndef R__USE_IMT; 4637 nwrite = branch->FillImpl(nullptr);; 4638#else; 4639 nwrite = branch->FillImpl(useIMT ? &imtHelper : nullptr);; 4640#endif; 4641 if (nwrite < 0) {; 4642 if (nerror < 2) {; 4643 Error(""Fill"", ""Failed filling branch:%s.%s, nbytes=%d, entry=%lld\n""; 4644 "" This error is symptomatic of a Tree created as a memory-resident Tree\n""; 4645 "" Instead of doing:\n""; 4646 "" TTree *T = new TTree(...)\n""; 4647 "" TFile *f = new TFile(...)\n""; 4648 "" you should do:\n""; 4649 "" TFile *f = new TFile(...)\n""; 4650 "" TTree *T = new TTree(...)\n\n"",; 4651 GetName(), branch->GetName(), nwrite, fEntries + 1);; 4652 } else {; 4653 Error(""Fill"", ""Failed filling branch:%s.%s, nbytes=%d, entry=%lld"", GetName(), branch->GetName(), nwrite,; 4654 fEntries + 1);; 4655 }; 4656 ++nerror;; 4657 } else {; 4658 nbytes += nwrite;; 4659 }; 4660 }; 4661 ; 4662#ifdef R__USE_IMT; 4663 if (fIMTFlush) {; 4664 imtHelper.Wait();; 4665 fIMTFlush = false;; 4666 const_cast<TTree *>(this)->AddTotBytes(fIMTTotBytes);; 4667 const_cast<TTree *>(this)->AddZipBytes(fIMTZipBytes);; 4668 nbytes += imtHelper.GetNbytes();; 4669 nerror += imtHelper.GetNerrors();; 4670 }; 4671#endif; 4672 ; 4673 if (fBranchRef); 4674 fBranchRef->Fill();; 4675 ; 4676 ++fEntries;; 4677 ; 4678 if (fEntries > fMaxEntries); 4679 KeepCircular();; 4680 ; 4681 if (gD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:188401,error,error,188401,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['error'],['error']
Availability,"1);; for (i = 0; i < nbins; i++) response[i]=d->GetBinContent(i + 1);; TCanvas *Decon1 = gROOT->GetListOfCanvases()->FindObject(""Decon1"");; if (!Decon1) Decon1 = new TCanvas(""Decon1"",; ""Deconvolution of closely positioned overlapping peaks using boosted Gold deconvolution method"",10,10,1000,700);; h->SetMaximum(110000);; h->Draw(""L"");; TSpectrum *s = new TSpectrum();; s->Deconvolution(source,response,256,200,50,1.2);; for (i = 0; i < nbins; i++) d->SetBinContent(i + 1,source[i]);; d->SetLineColor(kRed);; d->Draw(""SAME L"");; }; ; . const char * DeconvolutionRL(Double_t* source, const Double_t* response, Int_t ssize, Int_t numberIterations, Int_t numberRepetitions, Double_t boost). One-dimensional deconvolution function. This function calculates deconvolution from source spectrum according to; response spectrum using Richardson-Lucy deconvolution algorithm. The result; is placed in the vector pointed by source pointer. On successful completion; it returns 0. On error it returns pointer to the string describing error.; If desired after every numberIterations one can apply boosting operation; (exponential function with exponent given by boost coefficient) and repeat; it numberRepetitions times (see Gold deconvolution).; ; Function parameters:; ; source: pointer to the vector of source spectrum; response: pointer to the vector of response spectrum; ssize: length of source and response spectra; numberIterations, for details we refer to the reference given above; numberRepetitions, for repeated boosted deconvolution; boost, boosting coefficient; . Richardson-Lucy deconvolution algorithm:. For discrete systems it has the form:; . for positive input data and response matrix this iterative method forces; the deconvoluted spectra to be non-negative. The Richardson-Lucy; iteration converges to the maximum likelihood solution for Poisson statistics; in the data.; ; References:. Abreu M.C. et al., A four-dimensional deconvolution method to correct NA38; experimental data, NIM A 4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum.html:42949,error,error,42949,root/html602/TSpectrum.html,https://root.cern,https://root.cern/root/html602/TSpectrum.html,4,['error'],['error']
Availability,"1)MENU ; virtual voidTF1::SetMinimum(Double_t minimum = -1111)MENU ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTF1::SetNDF(Int_t ndf); virtual voidTF1::SetNormalized(Bool_t flag); virtual voidTF1::SetNpx(Int_t npx = 100)MENU ; virtual voidTF2::SetNpy(Int_t npy = 100)MENU ; virtual voidSetNpz(Int_t npz = 30); virtual voidTF1::SetNumberFitPoints(Int_t npfits); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTF1::SetParameter(Int_t param, Double_t value); virtual voidTF1::SetParameter(const TString& name, Double_t value); virtual voidTF1::SetParameters(const Double_t* params); virtual voidTF1::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidTF1::SetParent(TObject* p = 0); virtual voidTF1::SetParError(Int_t ipar, Double_t error); virtual voidTF1::SetParErrors(const Double_t* errors); virtual voidTF1::SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); virtual voidTF1::SetParName(Int_t ipar, const char* name); virtual voidTF1::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; virtual voidSetRange(Double_t xmin, Double_t xmax); virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax)MENU ; virtual voidTF1::SetSavedPoint(Int_t point, Double_t value); virtual voidTF1::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF3.html:16103,error,error,16103,root/html604/TF3.html,https://root.cern,https://root.cern/root/html604/TF3.html,1,['error'],['error']
Availability,"1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetA() const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoTube::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual Double_tGetB() const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoTube::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoEltu.html:3154,error,error,3154,root/html528/TGeoEltu.html,https://root.cern,https://root.cern/root/html528/TGeoEltu.html,3,['error'],['error']
Availability,"1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTGeoTrap::GetAlpha1() const; Double_tTGeoTrap::GetAlpha2() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoArb8::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Double_tTGeoTrap::GetBl1() const; Double_tTGeoTrap::GetBl2() const; virtual voidTGeoArb8::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoArb8::GetByteCount() const; Double_tTGeoArb8::GetClosestEdge(Double_t* point, Double_t* vert, Int_t& isegment) const; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoGtra.html:3853,error,error,3853,root/html528/TGeoGtra.html,https://root.cern,https://root.cern/root/html528/TGeoGtra.html,3,['error'],['error']
Availability,"1, Option_t* option = """"); *-*-*-*-*Multiply this profile by a constant c1*-*-*-*-*-*-*-*-*; *-* ======================================. this = c1*this. This function uses the services of TProfile::Add. void SetBinEntries(Int_t bin, Double_t w); Set the number of entries in bin*-*-*-; *-* ================================. void SetBins(Int_t nbins, Double_t xmin, Double_t xmax); Redefine x axis parameters*-*-*-; *-* ===========================. void SetBins(Int_t nx, const Double_t* xbins); Redefine x axis parameters*-*-*-; *-* ===========================. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void SetBuffer(Int_t buffersize, Option_t* option = """"); set the buffer size in units of 8 bytes (double). void SetErrorOption(Option_t* option = """"); -*Set option to compute profile errors; *-* =====================================. The computation of the bin errors is based on the parameter option:; option:; ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; i.e. the standard error of the bin contents.; Note that if TProfile::Approximate() is called, an approximation is used when; the spread in Y is 0 and the number of bin entries is > 0. 's' The bin errors are the standard deviations of the Y bin values; Note that if TProfile::Approximate() is called, an approximation is used when; the spread in Y is 0 and the number of bin entries is > 0. 'i' Errors are as in default case (standard errors of the bin contents); The only difference is for the case when the spread in Y is zero.; In this case for N > 0 the error is 1./SQRT(12.*N). 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; W is the sum in the bin of the weights of the profile.; This option is for combining measurements y +/- dy,; and the profile is filled with values y and weights w = 1/dy**2. See TProfile::BuildOptions for a detailed explanation of all options. void Streamer(TBuffer&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile.html:45282,error,errors,45282,root/html534/TProfile.html,https://root.cern,https://root.cern/root/html534/TProfile.html,9,['error'],"['error', 'errors']"
Availability,"1, Option_t* option = """")MENU ; voidTGeoNode::CheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTGeoNode::CountDaughters(Bool_t unique_volumes = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoNode::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGeoNode::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidTGeoNode::DrawOnly(Option_t* option = """"); voidTGeoNode::DrawOverlaps(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoNode::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNodeMatrix.html:1713,error,error,1713,root/html528/TGeoNodeMatrix.html,https://root.cern,https://root.cern/root/html528/TGeoNodeMatrix.html,4,['error'],['error']
Availability,"1, i.e. fit without errors (default is false); 53 bool fExpErrors; ///< use expected errors from the function and not from the data; 54 bool fCoordErrors; ///< use errors on the x coordinates when available (default is true); 55 bool fAsymErrors; ///< use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); 56 ; 57 ; 58};; 59 ; 60 } // end namespace Fit; 61 ; 62} // end namespace ROOT; 63 ; 64 ; 65#endif /* ROOT_Fit_DataOptions */; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::Fit::DataOptionsDataOptions : simple structure holding the options on how the data are filled.Definition DataOptions.h:28; ROOT::Fit::DataOptions::fErrors1bool fErrors1use all errors equal to 1, i.e. fit without errors (default is false)Definition DataOptions.h:52; ROOT::Fit::DataOptions::fAsymErrorsbool fAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residua...Definition DataOptions.h:55; ROOT::Fit::DataOptions::fNormBinVolumebool fNormBinVolumenormalize data by a normalized the bin volume (bin volume divided by a reference value)Definition DataOptions.h:49; ROOT::Fit::DataOptions::fUseRangebool fUseRangeuse the function range when creating the fit data (default is false)Definition DataOptions.h:51; ROOT::Fit::DataOptions::fUseEmptybool fUseEmptyuse empty bins (default is false) with a fixed error of 1Definition DataOptions.h:50; ROOT::Fit::DataOptions::fIntegralbool fIntegraluse integral of bin content instead of bin center (default is false)Definition DataOptions.h:47; ROOT::Fit::DataOptions::fExpErrorsbool fExpErrorsuse expected errors from the function and not from the dataDefin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataOptions_8h_source.html:2788,error,errors,2788,doc/master/DataOptions_8h_source.html,https://root.cern,https://root.cern/doc/master/DataOptions_8h_source.html,1,['error'],['errors']
Availability,"1,y1);; gr1->SetLineColor(2);; gr1->SetLineWidth(1504);; gr1->SetFillStyle(3005);. TGraph *gr2 = new TGraph(n,x2,y2);; gr2->SetLineColor(4);; gr2->SetLineWidth(-2002);; gr2->SetFillStyle(3004);; gr2->SetFillColor(9);. TGraph *gr3 = new TGraph(n,x3,y3);; gr3->SetLineColor(5);; gr3->SetLineWidth(-802);; gr3->SetFillStyle(3002);; gr3->SetFillColor(2);. mg->Add(gr1);; mg->Add(gr2);; mg->Add(gr3);; mg->Draw(""AC"");. return c1;; }; Graphs with error bars; Three classes are available to handle graphs with error bars:; TGraphErrors, TGraphAsymmErrors and TGraphBentErrors.; In addition to the drawing options previously described, the graphs with error; bars can be drawn with the following extra options:. ""Z""; By default horizonthal and vertical small lines are drawn at; the end of the error bars. If option ""z"" or ""Z"" is specified,; these lines are not drawn. "">""; An arrow is drawn at the end of the error bars.; The size of the arrow is set to 2/3 of the marker size. ""|>""; A filled arrow is drawn at the end of the error bars.; The size of the arrow is set to 2/3 of the marker size. ""X""; By default the error bars are drawn. If option ""X"" is specified,; the errors are not drawn. The graph with errors in drawn like a normal graph. ""||""; Only the end vertical/horizonthal lines; of the error bars are drawn. This option is interesting to superimpose; systematic errors on top of a graph with statistical errors. ""[]""; Does the same as option ""||"" except that it draws additionnal tick marks at the; end of the vertical/horizonthal lines. This makes less ambiguous plots; in case several graphs are drawn on the same picture. ""0""; By default, when a data point is outside the visible range along the Y axis the error; bars are not drawn. Combined with other options, this option forces error bars'; drawing for the data points outside the visible range along the Y axis. ""2""; Error rectangles are drawn. ""3""; A filled area is drawn through the end points of the vertical error bars. ""4""; A smooth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGraphPainter.html:5281,error,error,5281,root/html530/TGraphPainter.html,https://root.cern,https://root.cern/root/html530/TGraphPainter.html,1,['error'],['error']
Availability,"1,y1);; gr1->SetLineColor(2);; gr1->SetLineWidth(1504);; gr1->SetFillStyle(3005);. TGraph *gr2 = new TGraph(n,x2,y2);; gr2->SetLineColor(4);; gr2->SetLineWidth(-2002);; gr2->SetFillStyle(3004);; gr2->SetFillColor(9);. TGraph *gr3 = new TGraph(n,x3,y3);; gr3->SetLineColor(5);; gr3->SetLineWidth(-802);; gr3->SetFillStyle(3002);; gr3->SetFillColor(2);. mg->Add(gr1);; mg->Add(gr2);; mg->Add(gr3);; mg->Draw(""AC"");. return c1;; }; Graphs with error bars; Three classes are available to handle graphs with error bars:; TGraphErrors, TGraphAsymmErrors and TGraphBentErrors.; In addition to the drawing options previously described, the graphs with error; bars can be drawn with the following extra options:. ""Z""; By default horizonthal and vertical small lines are drawn at; the end of the error bars. If option ""z"" or ""Z"" is specified,; these lines are not drawn. "">""; An arrow is drawn at the end of the error bars.; The size of the arrow is set to 2/3 of the marker size. ""|>""; A filled arrow is drawn at the end of the error bars.; The size of the arrow is set to 2/3 of the marker size. ""X""; By default the error bars are drawn. If option ""X"" is specified,; the errors are not drawn. The graph with errors in drawn like a normal graph. ""||""; Only the end vertical/horizonthal lines; of the error bars are drawn. This option is interesting to superimpose; systematic errors on top of a graph with statistical errors. ""[]""; Does the same as option ""||"" except that it draws additionnal tick marks at the; end of the vertical/horizonthal lines. This makes less ambiguous plots; in case several graphs are drawn on the same picture. ""2""; Error rectangles are drawn. ""3""; A filled area is drawn through the end points of the vertical error bars. ""4""; A smoothed filled area is drawn through the end points of the vertical error; bars. gStyle->SetErrorX(dx) controls the size of the error along x.; dx = 0 removes the error along x. gStyle->SetEndErrorSize(np) controls the size of the lines; at the end o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphPainter.html:5281,error,error,5281,root/html528/TGraphPainter.html,https://root.cern,https://root.cern/root/html528/TGraphPainter.html,1,['error'],['error']
Availability,"1->28]; fSeekFree; Pointer to FREE data record. 21 -> 24 [29->32]; fNbytesFree; Number of bytes in FREE data record. 25 -> 28 [33->36]; nfree; Number of free data records. 29 -> 32 [37->40]; fNbytesName; Number of bytes in TNamed at creation time. 33 -> 33 [41->41]; fUnits; Number of bytes for file pointers. 34 -> 37 [42->45]; fCompress; Zip compression level. 38 -> 41 [46->53]; fSeekInfo; Pointer to TStreamerInfo record. 42 -> 45 [54->57]; fNBytesInfo; Number of bytes in TStreamerInfo record. 46 -> 63 [58->75]; fCompress; Universal Unique ID. The first four bytes of the file header contain the string “root” which identifies a file as a ROOT file. Because of this identifier, ROOT is not dependent on the “.root” extension. It is still a good idea to use the extension, just for us to recognize them easier. The nfree and value is the number of free records. This variable along with FNBytesFree keeps track of the free space in terms of records and bytes. This count also includes the deleted records, which are available again.; 11.1.2 The Top Directory Description; The 84 bytes after the file header contain the top directory description, including the name, the date and time it was created, and the date and time of the last modification.; 20010404/092347 At:64 N=84 TFile; 11.1.3 The Histogram Records; What follows are the 15 histograms, in records of variable length.; 20010404/092347 At:148 N=380 TH1F CX = 2.49; 20010404/092347 At:528 N=377 TH1F CX = 2.51; The first 4 bytes of each record is an integer holding the number of bytes in this record. A negative number flags the record as deleted, and makes the space available for recycling in the next writing. The rest of bytes in the header contain all the information to identify uniquely a data block on the file. It is followed by the object data.; The next table explains the values in each individual record. If the key is located past the 32 bit file limit (> 2 GB) then some fields will be 8 bytes instead of 4 bytes (values",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:433966,avail,available,433966,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['avail'],['available']
Availability,"1->Draw(""AC*"");. // superimpose the second graph by leaving out the axis option ""A""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; 4.3 Graphs with Error Bars; A TGraphErrors is a TGraph with error bars. The various draw format options of TGraphErrors::Paint() are derived from TGraph.; void TGraphErrors::Paint(Option_t *option). Graphs with different draw options of error bars. In addition, it can be drawn with the “Z” option to leave off the small lines at the end of the error bars. If option contains “>”, an arrow is drawn at the end of the error bars. If option contains “|>”, a full arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size.; The option “[]” is interesting to superimpose systematic errors on top of the graph with the statistical errors. When it is specified, only the end vertical/horizontal lines of the error bars are drawn.; To control the size of the lines at the end of the error bars (when option 1 is chosen) use SetEndErrorSize(np). By default np=1; np represents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, and Y-errors - the size of the errors in the x and y direction. Next example is $ROOTSYS/tutorials/graphs/gerrors.C.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:146667,error,error,146667,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['error'],['error']
Availability,1.002) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.744046 a1=-0.311529 mean=5.09799 nbkg=161.409 nsig=148.884 sig1frac=0.512806; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 660; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 650; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 640; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 630; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 620; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 610; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-809.027) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.719517 a1=-0.347533 mean=5.00927 nbkg=127.977 nsig=152.559 sig1frac=0.917291; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 600; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 590; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 580; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-869.586) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.621299 a1=-0.442393 mean=5.13262 nbkg=131.7 nsig=167.982 sig1frac=0.776177; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 570; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 560; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 550; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 540; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 530; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-820.086) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.699182 a1=-0.532303 mean=4.90748 nbkg=130.722 nsig=155.109 sig1frac=0.843514; RooAddPdf::model,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8C.html:16781,error,errors,16781,doc/master/rf801__mcstudy_8C.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html,4,['error'],"['error', 'errors']"
Availability,"1.1 MnSimplex(const FCNBase&, const std::vector\(<\)double\(>\)&,; const std::vector\(<\)double\(>\)&, unsigned int); 5.11.2 MnSimplex(const FCNBase&, const MnUserParameters&,; unsigned int); 5.11.3 MnSimplex(const FCNBase&, const MnUserParameterState&,; const MnStrategy&); 5.11.4 operator(); 5.11.5 Parameter interaction; 5.11.6 SimplexMinimizer(); 5.11.7 minimize(const FCNBase&, …). 5.12 MnStrategy; 5.12.1 MnStrategy(); 5.12.2 MnStrategy(unsigned int level); 5.12.3 setLowStrategy(), setMediumStrategy(), setHighStrategy(); 5.12.4 Other methods. 5.13 MnUserCovariance; 5.13.1 MnUserCovariance(const std::vector\(<\)double\(>\)&, unsigned int nrow); 5.13.2 MnUserCovariance(unsigned int nrow); 5.13.3 MnUserCovariance::operator()(unsigned int, unsigned int). 5.14 MnUserParameters; 5.14.1 add(…); 5.14.2 setValue(…); 5.14.3 setError(…); 5.14.4 fix(…); 5.14.5 release(…); 5.14.6 setLimits(…); 5.14.7 setUpperLimit(…); 5.14.8 setLowerLimit(…); 5.14.9 removeLimits(…); 5.14.10 value(…); 5.14.11 error(…); 5.14.12 index(…); 5.14.13 name(…). 5.15 MnUserParameterState; 5.15.1 MnUserParameterState(const std::vector\(<\)double\(>\)&,; const std::vector\(<\)double\(>\)&); 5.15.2 MnUserParameterState(const MnUserParameters&); 5.15.3 MnUserParameterState(const MnUserParameters&,; const MnUserCovariance&); 5.15.4 parameters(); 5.15.5 covariance(); 5.15.6 globalCC(); 5.15.7 MnUserParameterState::isValid() and; MnUserParameterState::hasCovariance(); 5.15.8 MnUserParameterState::fval(), MnUserParameterState::edm(),; MnUserParameterState::nfcn(). 5.16 MnPrint.h; 5.16.1 operator\(<<\)(std::ostream&, const FunctionMinimum&); 5.16.2 operator\(<<\)(std::ostream&, const MnUserParameters&); 5.16.3 operator\(<<\)(std::ostream&, const MnUserCovariance&); 5.16.4 operator\(<<\)(std::ostream&, const MnGlobalCorrelationCoeff&); 5.16.5 operator\(<<\)(std::ostream&, const MnUserParameterState&); 5.16.6 operator\(<<\)(std::ostream&, const MinosError&); 5.16.7 operator\(<<\)(std::ostream&, const ContoursErros&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:3783,error,error,3783,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['error'],['error']
Availability,"1.cxx:3343; TF1::fAlphastd::vector< Double_t > fAlpha! Array alpha. for each bin in x the deconvolution r of fIntegralDefinition TF1.h:279; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12)IntegralOneDim or analytical integral.Definition TF1.cxx:2531; TF1::SetTitlevoid SetTitle(const char *title="""") overrideSet function title if title has the form ""fffffff;xxxx;yyyy"", it is assumed that the function title i...Definition TF1.cxx:3558; TF1::fFormulastd::unique_ptr< TFormula > fFormulaPointer to TFormula in case when user define formula.Definition TF1.h:288; TF1::SetParNamesvirtual void SetParNames(const char *name0="""", const char *name1="""", const char *name2="""", const char *name3="""", const char *name4="""", const char *name5="""", const char *name6="""", const char *name7="""", const char *name8="""", const char *name9="""", const char *name10="""")Set up to 10 parameter names.Definition TF1.cxx:3463; TF1::DerivativeErrorstatic Double_t DerivativeError()Static function returning the error of the last call to the of Derivative's functions.Definition TF1.cxx:1277; TF1::fParMinstd::vector< Double_t > fParMinArray of lower limits of the fNpar parameters.Definition TF1.h:275; TF1::InitStandardFunctionsstatic void InitStandardFunctions()Create the basic function objects.Definition TF1.cxx:2497; TF1::fMaximumDouble_t fMaximumMaximum value for plotting.Definition TF1.h:273; TF1::SetNpxvirtual void SetNpx(Int_t npx=100)Set the number of points used to draw the function.Definition TF1.cxx:3433; TF1::GetParametersvirtual Double_t * GetParameters() constDefinition TF1.h:548; TF1::fMinimumDouble_t fMinimumMinimum value for plotting.Definition TF1.h:272; TF1::TermCoeffLengthint TermCoeffLength(TString &term)Definition TF1.cxx:924; TF1::fgRejectPointstatic Bool_t fgRejectPointDefinition TF1.h:325; TF1::Copyvoid Copy(TObject &f1) const overrideCopy this F1 to a new F1.Definition TF1.cxx:1005; TF1::Streamervoid Streamer(TBuffer &) overrideStream a class object.De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:181721,error,error,181721,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['error'],['error']
Availability,"1/(n1+n2); using an error bar calculated with Binomial statistics. void addEfficiencyBinWithError(Axis_t binCenter, Double_t n1, Double_t n2, Double_t en1, Double_t en2, Double_t binWidth = 0, Double_t xErrorFrac = 1., Double_t scaleFactor = 1.); Add a bin to this histogram with the value n1/(n1+n2); using an error bar calculated with Binomial statistics. ~RooHist(); Destructor. Bool_t hasIdenticalBinning(const RooHist& other) const; Return kTRUE if binning of this RooHist is identical to that of 'other'. Bool_t isIdentical(const RooHist& other, Double_t tol = 9.9999999999999995E-7) const; Return kTRUE if contents of this RooHIst is identical within given; relative tolerance to that of 'other'. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this histogram to the specified output stream. Standard: number of entries; Shape: error CL and maximum value; Verbose: print our bin contents and errors. void printName(ostream& os) const; Print name of RooHist. void printTitle(ostream& os) const; Print title of RooHist. void printClassName(ostream& os) const; Print class name of RooHist. RooHist* makeResidHist(const RooCurve& curve, bool normalize = false, bool useAverage = false) const; Create and return RooHist containing residuals w.r.t to given curve.; If normalize is true, the residuals are normalized by the histogram; errors creating a RooHist with pull values. RooHist(). void Print(Option_t* options = 0) const; Printing interface. Double_t getNominalBinWidth() const; { return _nominalBinWidth; }. void setRawEntries(Double_t n); { _rawEntries = n ; }. RooHist* makePullHist(const RooCurve& curve, bool useAverage = false) const; {return makeResidHist(curve,true,useAverage); }. » Last changed: Tue Jun 2 15:31:27 2015 » Last generated: 2015-06-02 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooHist.html:26552,error,errors,26552,root/html604/RooHist.html,https://root.cern,https://root.cern/root/html604/RooHist.html,1,['error'],['errors']
Availability,"10 ; 11#include ""ROOT/InternalTreeUtils.hxx""; 12#include ""ROOT/RDataFrame.hxx""; 13#include ""ROOT/RDataSource.hxx""; 14#include ""ROOT/RDF/RDatasetSpec.hxx""; 15#include ""ROOT/RDF/RInterface.hxx""; 16#include ""ROOT/RDF/RLoopManager.hxx""; 17#include ""ROOT/RDF/Utils.hxx""; 18#include <string_view>; 19#include ""TChain.h""; 20#include ""TDirectory.h""; 21#include ""RtypesCore.h"" // for ULong64_t; 22#include ""TTree.h""; 23 ; 24#include <fstream> // std::ifstream; 25#include <nlohmann/json.hpp> // nlohmann::json::parse; 26#include <memory> // for make_shared, allocator, shared_ptr; 27#include <ostream> // ostringstream; 28#include <stdexcept>; 29#include <string>; 30#include <vector>; 31 ; 32// clang-format off; 33/**; 34* \class ROOT::RDataFrame; 35* \ingroup dataframe; 36* \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python.; 37 ; 38In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; 39on their machines completely transparently.<br>; 40Skip to the [class reference](#reference) or keep reading for the user guide.; 41 ; 42In a nutshell:; 43~~~{.cpp}; 44ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; 45ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; 46auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; 47myHisto->Draw(); // Event loop is run here, upon first access to a result; 48~~~; 49 ; 50Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; 51care of their execution. The implementation automatically puts in place several low level optimisations such as; 52multi-thread parallelization and caching.; 53 ; 54\htmlonly; 55<a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; 56alt=""DOI""></a>; 57\endhtmlonly; 58 ; 59## For the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:1650,avail,available,1650,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,2,['avail'],['available']
Availability,"10 TClass__GetCallingNewRAII callingNew(defConstructor);; 5211 p = fCollectionProxy->NewObject(arena);; 5212 }; 5213 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5214 // There is no dictionary at all and we do not have; 5215 // the services of a collection proxy available, so; 5216 // use the streamer info to approximate calling a; 5217 // constructor (basically we just make sure that the; 5218 // pointer data members are null, unless they are marked; 5219 // as preallocated with the ""->"" comment, in which case; 5220 // we default-construct an object to point at).; 5221 ; 5222 // ???BUG??? ???WHY???; 5223 // Do not register any TObject's that we create; 5224 // as a result of creating this object.; 5225 Bool_t statsave = GetObjectStat();; 5226 if(statsave) {; 5227 SetObjectStat(kFALSE);; 5228 }; 5229 ; 5230 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5231 if (!sinfo) {; 5232 Error(""New with placement"", ""Cannot construct class '%s' version %d at address %p, no streamer info available!"", GetName(), fClassVersion, arena);; 5233 return nullptr;; 5234 }; 5235 ; 5236 {; 5237 TClass__GetCallingNewRAII callingNew(defConstructor);; 5238 p = { sinfo->New(arena), sinfo };; 5239 }; 5240 ; 5241 // ???BUG???; 5242 // Allow TObject's to be registered again.; 5243 if(statsave) {; 5244 SetObjectStat(statsave);; 5245 }; 5246 ; 5247 } else {; 5248 Error(""New with placement"", ""This cannot happen!"");; 5249 }; 5250 ; 5251 return p;; 5252}; 5253 ; 5254////////////////////////////////////////////////////////////////////////////////; 5255/// Return a pointer to a newly allocated array of objects; 5256/// of this class.; 5257/// The class must have a default constructor. For meaning of; 5258/// defConstructor, see TClass::IsCallingNew().; 5259 ; 5260void *TClass::NewArray(Long_t nElements, ENewType defConstructor) const; 5261{; 5262 auto obj = NewObjectArray(nElements, defConstructor);; 5263 if (obj.GetPtr() && obj.GetAllocator()) {; 5264 // Register the object for special",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:200048,avail,available,200048,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['avail'],['available']
Availability,"10) const; Find the nearest point to xvalue. Return -1 if distance; exceeds tolerance. Double_t interpolate(Double_t x, Double_t tolerance = 1.0E-10) const; Return linearly interpolated value of curve at xvalue. If distance; to nearest point is less than tolerance, return nearest point value; instead. RooCurve* makeErrorBand(const vector<RooCurve*>& variations, Double_t Z = 1) const; Construct filled RooCurve represented error band that captures alpha% of the variations; of the curves passed through argument variations, where the percentage alpha corresponds to; the central interval fraction of a significance Z. RooCurve* makeErrorBand(const vector<RooCurve*>& plusVar, const vector<RooCurve*>& minusVar, const TMatrixD& V, Double_t Z = 1) const; Construct filled RooCurve represented error band represent the error added in quadrature defined by the curves arguments; plusVar and minusVar corresponding to one-sigma variations of each parameter. The resulting error band, combined used the correlation matrix C; is multiplied with the significance parameter Z to construct the equivalent of a Z sigma error band (in Gaussian approximation). void calcBandInterval(const vector<RooCurve*>& plusVar, const vector<RooCurve*>& minusVar, Int_t i, const TMatrixD& V, Double_t Z, Double_t& lo, Double_t& hi) const; Retrieve variation points from curves. void calcBandInterval(const vector<RooCurve*>& variations, Int_t i, Double_t Z, Double_t& lo, Double_t& hi, Bool_t approxGauss) const. Bool_t isIdentical(const RooCurve& other, Double_t tol = 9.9999999999999995E-7) const; Return true if curve is identical to other curve allowing for given; absolute tolerance on each point compared point. RooCurve(). void Print(Option_t* options = 0) const; Printing interface. » Last changed: Tue Jun 30 14:32:21 2015 » Last generated: 2015-06-30 14:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCurve.html:24434,error,error,24434,root/html602/RooCurve.html,https://root.cern,https://root.cern/root/html602/RooCurve.html,3,"['error', 'toler']","['error', 'tolerance']"
Availability,"10, 10 for 15 planes) and by 8 bits for 24 planes.; Returns kFALSE in case color allocation failed. void QueryColors(unsigned long cmap, XColor* colors, Int_t ncolors); Returns the current RGB value for the pixel in the XColor structure. void ClearPixmap(unsigned long* pix); Clear the pixmap pix. void ClearWindow(); Clear current window. void ClosePixmap(); Delete current pixmap. void CloseWindow(); Delete current window. void CloseWindow1(); Delete current window. void CopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); Copy the pixmap wid at the position xpos, ypos in the current window. void CopyWindowtoPixmap(unsigned long* pix, Int_t xpos, Int_t ypos); Copy area of current window in the pixmap pix. void DrawBox(Int_t x1, Int_t y1, Int_t x2, Int_t y2, TVirtualX::EBoxMode mode); Draw a box.; mode=0 hollow (kHollow); mode=1 solid (kSolid). void DrawCellArray(Int_t x1, Int_t y1, Int_t x2, Int_t y2, Int_t nx, Int_t ny, Int_t* ic); Draw a cell array.; x1,y1 : left down corner; x2,y2 : right up corner; nx,ny : array size; ic : array. Draw a cell array. The drawing is done with the pixel presicion; if (X2-X1)/NX (or Y) is not a exact pixel number the position of; the top rigth corner may be wrong. void DrawFillArea(Int_t n, TPoint* xy); Fill area described by polygon.; n : number of points; xy(2,n) : list of points. void DrawLine(Int_t x1, Int_t y1, Int_t x2, Int_t y2); Draw a line.; x1,y1 : begin of line; x2,y2 : end of line. void DrawPolyLine(Int_t n, TPoint* xy); Draw a line through all points.; n : number of points; xy : list of points. void DrawPolyMarker(Int_t n, TPoint* xy); Draw n markers with the current attributes at position x, y.; n : number of markers to draw; xy : x,y coordinates of markers. void DrawText(Int_t x, Int_t y, Float_t angle, Float_t mgn, const char* text, TVirtualX::ETextMode mode); Draw a text string using current font.; mode : drawing mode; mode=0 : the background is not drawn (kClear); mode=1 : the background is drawn (kOpaque); x,y : text posi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGX11.html:26397,down,down,26397,root/html528/TGX11.html,https://root.cern,https://root.cern/root/html528/TGX11.html,4,['down'],['down']
Availability,"10// template ROOT::Double_v vecCore::math::Cbrt(const ROOT::Double_v & x);; 3211#endif; PdfFuncMathCore.h; ProbFuncMathCore.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; g#define g(i)Definition RSha256.hxx:105; a#define a(i)Definition RSha256.hxx:99; s1#define s1(x)Definition RSha256.hxx:91; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; Int_tint Int_tDefinition RtypesCore.h:45; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; Long_tlong Long_tDefinition RtypesCore.h:54; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; NamespaceImp#define NamespaceImp(name)Definition Rtypes.h:398; SpecFuncMathCore.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; N#define N; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; vvwinID h TVirtualViewer3D vvDefinition TGWin32VirtualGLProxy.cxx:49; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; delOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t delDefinition TGWin32VirtualXProxy.cxx:188; rOption_t Option_t TPoint TPoint co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:114217,error,error,114217,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['error'],['error']
Availability,"10000000000000001, Option_t* option = """")MENU ; voidTGeoNode::CheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTGeoNode::CountDaughters(Bool_t unique_volumes = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoNode::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGeoNode::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidTGeoNode::DrawOnly(Option_t* option = """"); voidTGeoNode::DrawOverlaps(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoNode::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); voidTGeoNode::FillIdArray(Int_t& ifree, Int_t& nodeid, Int_t* array) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoNodeMatrix.html:1646,error,error,1646,root/html602/TGeoNodeMatrix.html,https://root.cern,https://root.cern/root/html602/TGeoNodeMatrix.html,2,['error'],['error']
Availability,"1024 *16)THnBaseprotectedstatic; CreateHnAny(const char *name, const char *title, const THnBase *hn, Bool_t sparse, Int_t chunkSize=1024 *16)THnBaseprotectedstatic; CreateIter(Bool_t respectAxisRange) const overrideTHnvirtual; DeclFileName()THninlinestatic; Delete(Option_t *option="""")TObjectvirtual; DistancetoPrimitive(Int_t px, Int_t py)TObjectvirtual; Divide(const THnBase *h)THnBase; Divide(const THnBase *h1, const THnBase *h2, Double_t c1=1., Double_t c2=1., Option_t *option="""")THnBase; DoError(int level, const char *location, const char *fmt, va_list va) constTObjectprotectedvirtual; Draw(Option_t *option="""")TObjectvirtual; DrawClass() constTObjectvirtual; DrawClone(Option_t *option="""") constTObjectvirtual; Dump() constTObjectvirtual; EDeprecatedStatusBits enum nameTObject; Error(const char *method, const char *msgfmt,...) constTObjectvirtual; EStatusBits enum nameTObject; Execute(const char *method, const char *params, Int_t *error=nullptr)TObjectvirtual; Execute(TMethod *method, TObjArray *params, Int_t *error=nullptr)TObjectvirtual; ExecuteEvent(Int_t event, Int_t px, Int_t py)TObjectvirtual; Fatal(const char *method, const char *msgfmt,...) constTObjectvirtual; fAxesTHnBaseprotected; fBitsTObjectprivate; fBrowsablesTHnBaseprotected; fCoordBufTHnmutableprotected; fEntriesTHnBaseprotected; fgDtorOnlyTObjectprivatestatic; fgObjectStatTObjectprivatestatic; Fill(const Double_t *x, Double_t w=1.)THnBaseinline; Fill(const char *name[], Double_t w=1.)THnBaseinline; Fill(Double_t firstval, MoreTypes... morevals)THnBaseinline; FillBin(Long64_t bin, Double_t w) overrideTHninlinevirtual; FillBinBase(Double_t w)THnBaseinlineprotected; FillBuffer(char *&buffer)TNamedvirtual; FindObject(const char *name) constTObjectvirtual; FindObject(const TObject *obj) constTObjectvirtual; fIntegralTHnBaseprotected; fIntegralStatusTHnBaseprotected; Fit(TF1 *f1, Option_t *option="""", Option_t *goption="""")THnBase; fNameTNamedprotected; fNdimensionsTHnBaseprotected; fSumw2THnprotected; fTit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHn-members.html:2711,error,error,2711,doc/master/classTHn-members.html,https://root.cern,https://root.cern/doc/master/classTHn-members.html,2,['error'],['error']
Availability,"103 ; 104//; 105// Text management; 106//; 107const Int_t kMAXFONT = 4;; 108static struct {; 109 XFontStruct *id;; 110 char name[80]; // Font name; 111} gFont[kMAXFONT]; // List of fonts loaded; 112 ; 113static XFontStruct *gTextFont; // Current font; 114static Int_t gCurrentFontNumber = 0; // Current font number in gFont[]; 115 ; 116//; 117// Markers; 118//; 119const Int_t kMAXMK = 100;; 120static struct {; 121 int type;; 122 int n;; 123 XPoint xy[kMAXMK];; 124} gMarker; // Point list to draw marker; 125static int gMarkerLineWidth = 0;; 126static int gMarkerLineStyle = LineSolid;; 127static int gMarkerCapStyle = CapRound;; 128static int gMarkerJoinStyle = JoinRound;; 129 ; 130//; 131// Keep style values for line GC; 132//; 133static int gLineWidth = 0;; 134static int gLineStyle = LineSolid;; 135static int gCapStyle = CapButt;; 136static int gJoinStyle = JoinMiter;; 137static char gDashList[10];; 138static int gDashLength = 0;; 139static int gDashOffset = 0;; 140static int gDashSize = 0;; 141 ; 142//; 143// Event masks; 144//; 145static ULong_t gMouseMask = ButtonPressMask | ButtonReleaseMask |; 146 EnterWindowMask | LeaveWindowMask |; 147 PointerMotionMask | KeyPressMask |; 148 KeyReleaseMask;; 149static ULong_t gKeybdMask = ButtonPressMask | KeyPressMask |; 150 EnterWindowMask | LeaveWindowMask;; 151 ; 152//; 153// Data to create an invisible cursor; 154//; 155const char null_cursor_bits[] = {; 1560x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,; 1570x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,; 1580x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};; 159static Cursor gNullCursor = 0;; 160 ; 161struct RXGCValues:XGCValues{};; 162struct RXColor:XColor{};; 163struct RXImage:XImage{};; 164struct RXPoint:XPoint{};; 165struct RXVisualInfo:XVisualInfo{};; 166struct RVisual:Visual{};; 167 ; 168ClassImp(TGX11);; 169 ; 170////////////////////////////////////////////////////////////////////////////////; 171/// Default constructor.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:4560,mask,masks,4560,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['mask'],['masks']
Availability,"1049 /// \brief Register systematic variations for a single existing column using custom variation tags.; 1050 /// \param[in] colName name of the column for which varied values are provided.; 1051 /// \param[in] expression a string containing valid C++ code that evaluates to an RVec containing the varied; 1052 /// values for the specified column.; 1053 /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; 1054 /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; 1055 /// colName is used if none is provided.; 1056 ///; 1057 /// This overload adds the possibility for the expression used to evaluate the varied values to be just-in-time; 1058 /// compiled. The example below shows how Vary() is used while dealing with a single column. The variation tags are; 1059 /// defined as `{""down"", ""up""}`.; 1060 /// ~~~{.cpp}; 1061 /// auto nominal_hx =; 1062 /// df.Vary(""pt"", ""ROOT::RVecD{pt*0.9, pt*1.1}"", {""down"", ""up""}); 1063 /// .Filter(""pt > k""); 1064 /// .Define(""x"", someFunc, {""pt""}); 1065 /// .Histo1D(""x"");; 1066 ///; 1067 /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; 1068 /// hx[""nominal""].Draw();; 1069 /// hx[""pt:down""].Draw(""SAME"");; 1070 /// hx[""pt:up""].Draw(""SAME"");; 1071 /// ~~~; 1072 ///; 1073 /// \sa This Vary() overload for more information.; 1074 RInterface<Proxied, DS_t> Vary(std::string_view colName, std::string_view expression,; 1075 const std::vector<std::string> &variationTags, std::string_view variationName = """"); 1076 {; 1077 std::vector<std::string> colNames{{std::string(colName)}};; 1078 const std::string theVariationName{variationName.empty() ? colName : variationName};; 1079 ; 1080 return JittedVaryImpl(colNames, expression, variationTags, theVariationName, /*isSingleColumn=*/true);; 1081 }; 1082 ; 1083 /// \brief Register systematic variations for a single existing column using auto-generated variation tags.; 1084 /// \param[in] colName name of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:58236,down,down,58236,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['down'],['down']
Availability,"1074 PrependPathName(dir, nameString);; 1075 return StrDup(nameString.Data());; 1076}; 1077 ; 1078////////////////////////////////////////////////////////////////////////////////; 1079/// Concatenate a directory and a file name.; 1080 ; 1081const char *TSystem::PrependPathName(const char *, TString&); 1082{; 1083 AbstractMethod(""PrependPathName"");; 1084 return nullptr;; 1085}; 1086 ; 1087 ; 1088//---- Paths & Files -----------------------------------------------------------; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1092/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1093/// environment variables in a pathname. If compatibility is not an issue; 1094/// you can use on Unix directly $XXX. This is a protected function called; 1095/// from the OS specific system classes, like TUnixSystem and TWinNTSystem.; 1096/// Returns the expanded filename or 0 in case of error.; 1097 ; 1098const char *TSystem::ExpandFileName(const char *fname); 1099{; 1100 const int kBufSize = kMAXPATHLEN;; 1101 TTHREAD_TLS_ARRAY(char, kBufSize, xname);; 1102 ; 1103 Bool_t res = ExpandFileName(fname, xname, kBufSize);; 1104 if (res); 1105 return nullptr;; 1106 else; 1107 return xname;; 1108}; 1109 ; 1110//////////////////////////////////////////////////////////////////////////////; 1111/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1112/// This function is analogous to ExpandFileName(const char *), except that; 1113/// it receives a TString reference of the pathname to be expanded.; 1114/// Returns kTRUE in case of error and kFALSE otherwise.; 1115 ; 1116Bool_t TSystem::ExpandFileName(TString &fname); 1117{; 1118 const int kBufSize = kMAXPATHLEN;; 1119 char xname[kBufSize];; 1120 ; 1121 Bool_t res = ExpandFileName(fname.Data(), xname, kBufSize);; 1122 if (!res); 1123 fname = xname;; 1124 ; 1125 return res;; 1126};",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:33716,error,error,33716,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['error'],['error']
Availability,"1078 ""\""now\"" : \""%s\""%s""; 21079 ""}"",; 21080 eol,; 21081 eol,; 21082 difftime(now, start_time),; 21083 eol,; 21084 start_time_str,; 21085 eol,; 21086 now_str,; 21087 eol);; 21088 context_info_length += mg_str_append(&buffer, end, block);; 21089 }; 21090 ; 21091 /* Terminate string */; 21092 if (append_eoobj) {; 21093 strcat(append_eoobj, eoobj);; 21094 }; 21095 context_info_length += sizeof(eoobj) - 1;; 21096 ; 21097 return (int)context_info_length;; 21098#else; 21099 (void)ctx;; 21100 if ((buffer != NULL) && (buflen > 0)) {; 21101 *buffer = 0;; 21102 }; 21103 return 0;; 21104#endif; 21105}; 21106 ; 21107 ; 21108void; 21109mg_disable_connection_keep_alive(struct mg_connection *conn); 21110{; 21111 /* https://github.com/civetweb/civetweb/issues/727 */; 21112 if (conn != NULL) {; 21113 conn->must_close = 1;; 21114 }; 21115}; 21116 ; 21117 ; 21118#if defined(MG_EXPERIMENTAL_INTERFACES); 21119/* Get connection information. It can be printed or stored by the caller.; 21120 * Return the size of available information. */; 21121int; 21122mg_get_connection_info(const struct mg_context *ctx,; 21123 int idx,; 21124 char *buffer,; 21125 int buflen); 21126{; 21127 const struct mg_connection *conn;; 21128 const struct mg_request_info *ri;; 21129 char *end, *append_eoobj = NULL, block[256];; 21130 size_t connection_info_length = 0;; 21131 int state = 0;; 21132 const char *state_str = ""unknown"";; 21133 ; 21134#if defined(_WIN32); 21135 static const char eol[] = ""\r\n"", eoobj[] = ""\r\n}\r\n"";; 21136#else; 21137 static const char eol[] = ""\n"", eoobj[] = ""\n}\n"";; 21138#endif; 21139 ; 21140 if ((buffer == NULL) || (buflen < 1)) {; 21141 buflen = 0;; 21142 end = buffer;; 21143 } else {; 21144 *buffer = 0;; 21145 end = buffer + buflen;; 21146 }; 21147 if (buflen > (int)(sizeof(eoobj) - 1)) {; 21148 /* has enough space to append eoobj */; 21149 append_eoobj = buffer;; 21150 end -= sizeof(eoobj) - 1;; 21151 }; 21152 ; 21153 if ((ctx == NULL) || (idx < 0)) {; 21154 /* Parameter error */; 21",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:630299,avail,available,630299,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['avail'],['available']
Availability,"1079 ""\""now\"" : \""%s\""%s""; 21080 ""}"",; 21081 eol,; 21082 eol,; 21083 difftime(now, start_time),; 21084 eol,; 21085 start_time_str,; 21086 eol,; 21087 now_str,; 21088 eol);; 21089 context_info_length += mg_str_append(&buffer, end, block);; 21090 }; 21091 ; 21092 /* Terminate string */; 21093 if (append_eoobj) {; 21094 strcat(append_eoobj, eoobj);; 21095 }; 21096 context_info_length += sizeof(eoobj) - 1;; 21097 ; 21098 return (int)context_info_length;; 21099#else; 21100 (void)ctx;; 21101 if ((buffer != NULL) && (buflen > 0)) {; 21102 *buffer = 0;; 21103 }; 21104 return 0;; 21105#endif; 21106}; 21107 ; 21108 ; 21109void; 21110mg_disable_connection_keep_alive(struct mg_connection *conn); 21111{; 21112 /* https://github.com/civetweb/civetweb/issues/727 */; 21113 if (conn != NULL) {; 21114 conn->must_close = 1;; 21115 }; 21116}; 21117 ; 21118 ; 21119#if defined(MG_EXPERIMENTAL_INTERFACES); 21120/* Get connection information. It can be printed or stored by the caller.; 21121 * Return the size of available information. */; 21122int; 21123mg_get_connection_info(const struct mg_context *ctx,; 21124 int idx,; 21125 char *buffer,; 21126 int buflen); 21127{; 21128 const struct mg_connection *conn;; 21129 const struct mg_request_info *ri;; 21130 char *end, *append_eoobj = NULL, block[256];; 21131 size_t connection_info_length = 0;; 21132 int state = 0;; 21133 const char *state_str = ""unknown"";; 21134 ; 21135#if defined(_WIN32); 21136 static const char eol[] = ""\r\n"", eoobj[] = ""\r\n}\r\n"";; 21137#else; 21138 static const char eol[] = ""\n"", eoobj[] = ""\n}\n"";; 21139#endif; 21140 ; 21141 if ((buffer == NULL) || (buflen < 1)) {; 21142 buflen = 0;; 21143 end = buffer;; 21144 } else {; 21145 *buffer = 0;; 21146 end = buffer + buflen;; 21147 }; 21148 if (buflen > (int)(sizeof(eoobj) - 1)) {; 21149 /* has enough space to append eoobj */; 21150 append_eoobj = buffer;; 21151 end -= sizeof(eoobj) - 1;; 21152 }; 21153 ; 21154 if ((ctx == NULL) || (idx < 0)) {; 21155 /* Parameter error */; 21",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:630332,avail,available,630332,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['avail'],['available']
Availability,10; : 1102 Minimum Test error found - save the configuration ; : 1102 | 2.66188 2.52638 0.020367 0.00185502 43215.3 0; : 1103 | 3.01155 3.18843 0.0202364 0.00176536 43311 1; : 1104 | 2.71885 3.00051 0.0201103 0.00176305 43603.3 2; : 1105 Minimum Test error found - save the configuration ; : 1105 | 2.73591 2.50832 0.0201341 0.0018587 43774.7 0; : 1106 | 2.7002 2.7081 0.0203577 0.00176876 43036.3 1; : 1107 | 2.85017 3.38001 0.0201747 0.00176074 43445.3 2; : 1108 | 2.78494 2.55451 0.0203389 0.00176376 43068.3 3; : 1109 | 2.71632 3.12003 0.0200899 0.00175276 43627.4 4; : 1110 | 3.16531 2.9918 0.020346 0.00180026 43136.7 5; : 1111 Minimum Test error found - save the configuration ; : 1111 | 2.97087 2.45167 0.0201922 0.00182484 43555.6 0; : 1112 | 2.60355 2.50464 0.0200664 0.00176061 43702 1; : 1113 | 2.54376 2.96916 0.0200737 0.00178101 43733.3 2; : 1114 | 2.77186 2.89815 0.0200657 0.00175793 43697.4 3; : 1115 | 2.58652 2.73506 0.020068 0.00175912 43694.6 4; : 1116 Minimum Test error found - save the configuration ; : 1116 | 2.82496 2.31503 0.0201083 0.00181922 43742 0; : 1117 | 2.74168 2.90157 0.0200454 0.00175765 43745.2 1; : 1118 | 2.51176 4.00704 0.0201409 0.00176812 43542.7 2; : 1119 | 3.03618 2.55498 0.0202517 0.00178949 43331.7 3; : 1120 | 2.66116 2.61177 0.0204165 0.00176394 42889.5 4; : 1121 | 3.00965 2.56116 0.0204562 0.00180217 42886.2 5; : 1122 | 3.0625 3.75816 0.0204635 0.00176149 42776.2 6; : 1123 | 2.88666 2.6576 0.0204265 0.00178135 42906.6 7; : 1124 | 2.54231 2.73598 0.020225 0.00176346 43333.4 8; : 1125 | 2.44231 2.73459 0.0201498 0.00175906 43500.1 9; : 1126 | 2.45201 2.82465 0.0200726 0.00175651 43677.5 10; : 1127 | 2.54248 2.42056 0.0201867 0.00176633 43430.3 11; : 1128 | 2.47016 2.53962 0.0206089 0.00182988 42600.8 12; : 1129 | 2.38268 2.44496 0.0204067 0.00176828 42922.1 13; : 1130 | 2.59925 2.55821 0.0200531 0.00176378 43741.4 14; : 1131 | 2.55367 2.59723 0.0200573 0.00177202 43751.1 15; : 1132 | 2.73554 2.74944 0.020135 0.00176885 43558.3 16; : 11,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:120744,error,error,120744,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,11 0; : 647 Minimum Test error found - save the configuration ; : 647 | 66.0907 48.4839 0.0203074 0.00181472 43260.4 0; : 648 Minimum Test error found - save the configuration ; : 648 | 65.1425 47.9895 0.0205925 0.00181541 42605 0; : 649 Minimum Test error found - save the configuration ; : 649 | 64.2291 47.827 0.0205836 0.00185514 42715.8 0; : 650 Minimum Test error found - save the configuration ; : 650 | 63.5181 47.2461 0.0203914 0.00184161 43127.1 0; : 651 Minimum Test error found - save the configuration ; : 651 | 62.641 46.7417 0.020143 0.00182812 43680.3 0; : 652 Minimum Test error found - save the configuration ; : 652 | 61.875 46.3421 0.0201124 0.00182035 43734.8 0; : 653 Minimum Test error found - save the configuration ; : 653 | 61.1155 45.9892 0.0201549 0.00182806 43651.9 0; : 654 | 60.3955 46.5097 0.0201006 0.00177795 43661.9 1; : 655 Minimum Test error found - save the configuration ; : 655 | 59.5776 45.1172 0.0204622 0.00186914 43026.9 0; : 656 Minimum Test error found - save the configuration ; : 656 | 58.5813 44.6814 0.020214 0.00181641 43484.1 0; : 657 Minimum Test error found - save the configuration ; : 657 | 58.1075 44.2582 0.0201216 0.0018139 43697.5 0; : 658 Minimum Test error found - save the configuration ; : 658 | 57.7428 43.9646 0.0201606 0.00184632 43681.8 0; : 659 Minimum Test error found - save the configuration ; : 659 | 56.5877 43.7448 0.0201275 0.00181379 43683.2 0; : 660 Minimum Test error found - save the configuration ; : 660 | 56.1107 42.9226 0.0200887 0.00181275 43773.3 0; : 661 Minimum Test error found - save the configuration ; : 661 | 55.5039 42.6809 0.0201245 0.00180935 43679.7 0; : 662 Minimum Test error found - save the configuration ; : 662 | 54.3572 42.2723 0.0202587 0.00183315 43417.9 0; : 663 Minimum Test error found - save the configuration ; : 663 | 53.566 41.7624 0.0203991 0.00186617 43166.5 0; : 664 Minimum Test error found - save the configuration ; : 664 | 52.9086 41.2393 0.0201899 0.00182999 43573.1 0; : 665 Min,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:84798,error,error,84798,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"11.h""; #include ""TPoint.h""; #include ""TMath.h""; #include ""TStorage.h""; #include ""TStyle.h""; #include ""TExMap.h""; #include ""TEnv.h""; #include ""TString.h""; #include ""TObjString.h""; #include ""TObjArray.h""; #include ""RStipples.h""; #include ""strlcpy.h""; #include <X11/Xlib.h>; #include <X11/Xutil.h>; #include <X11/Xatom.h>; #include <X11/cursorfont.h>; #include <X11/keysym.h>; #include <X11/xpm.h>; #include <cstdio>; #include <cstring>; #include <cstdlib>; #include <cctype>; #include <unistd.h>. Include dependency graph for TGX11.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  RVisual;  ; struct  RXColor;  ; struct  RXGCValues;  ; struct  RXImage;  ; struct  RXPoint;  ; struct  RXVisualInfo;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Functions; static Int_t DummyX11ErrorHandler (Display *, XErrorEvent *);  Dummy error handler for X11. Used by FindUsableVisual(). ;  ; static void GetPixel (int y, int width, Byte_t *scline);  Get pixels in line y and put in array scline. ;  ; int GIFdecode (Byte_t *gifArr, Byte_t *pixArr, int *Width, int *Height, int *Ncols, Byte_t *R, Byte_t *G, Byte_t *B);  ; long GIFencode (int Width, int Height, Int_t Ncol, Byte_t R[], Byte_t G[], Byte_t B[], Byte_t ScLine[], void(*get_scline)(int, int, Byte_t *), void(*pb)(Byte_t));  ; int GIFinfo (Byte_t *gifArr, int *Width, int *Height, int *Ncols);  ; int GIFquantize (UInt_t width, UInt_t height, Int_t *ncol, Byte_t *red, Byte_t *green, Byte_t *blue, Byte_t *outputBuf, Byte_t *outputCmap);  ; static void PutByte (Byte_t b);  Put byte b in output stream. ;  ; int XRotDrawAlignedImageString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *, int);  A front end to XRotPaintAlignedString: -does alignment, paints background. ;  ; int XRotDrawAlignedString (Display *, XFontStruct *, f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx.html:1290,error,error,1290,doc/master/TGX11_8cxx.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx.html,2,['error'],['error']
Availability,"11134 conn->path_info);; 11135 }; 11136 ; 11137 addenv(env, ""HTTPS=%s"", (conn->ssl == NULL) ? ""off"" : ""on"");; 11138 ; 11139 if ((s = mg_get_header(conn, ""Content-Type"")) != NULL) {; 11140 addenv(env, ""CONTENT_TYPE=%s"", s);; 11141 }; 11142 if (conn->request_info.query_string != NULL) {; 11143 addenv(env, ""QUERY_STRING=%s"", conn->request_info.query_string);; 11144 }; 11145 if ((s = mg_get_header(conn, ""Content-Length"")) != NULL) {; 11146 addenv(env, ""CONTENT_LENGTH=%s"", s);; 11147 }; 11148 if ((s = getenv(""PATH"")) != NULL) {; 11149 addenv(env, ""PATH=%s"", s);; 11150 }; 11151 if (conn->path_info != NULL) {; 11152 addenv(env, ""PATH_INFO=%s"", conn->path_info);; 11153 }; 11154 ; 11155 if (conn->status_code > 0) {; 11156 /* CGI error handler should show the status code */; 11157 addenv(env, ""STATUS=%d"", conn->status_code);; 11158 }; 11159 ; 11160#if defined(_WIN32); 11161 if ((s = getenv(""COMSPEC"")) != NULL) {; 11162 addenv(env, ""COMSPEC=%s"", s);; 11163 }; 11164 if ((s = getenv(""SYSTEMROOT"")) != NULL) {; 11165 addenv(env, ""SYSTEMROOT=%s"", s);; 11166 }; 11167 if ((s = getenv(""SystemDrive"")) != NULL) {; 11168 addenv(env, ""SystemDrive=%s"", s);; 11169 }; 11170 if ((s = getenv(""ProgramFiles"")) != NULL) {; 11171 addenv(env, ""ProgramFiles=%s"", s);; 11172 }; 11173 if ((s = getenv(""ProgramFiles(x86)"")) != NULL) {; 11174 addenv(env, ""ProgramFiles(x86)=%s"", s);; 11175 }; 11176#else; 11177 if ((s = getenv(""LD_LIBRARY_PATH"")) != NULL) {; 11178 addenv(env, ""LD_LIBRARY_PATH=%s"", s);; 11179 }; 11180#endif /* _WIN32 */; 11181 ; 11182 if ((s = getenv(""PERLLIB"")) != NULL) {; 11183 addenv(env, ""PERLLIB=%s"", s);; 11184 }; 11185 ; 11186 if (conn->request_info.remote_user != NULL) {; 11187 addenv(env, ""REMOTE_USER=%s"", conn->request_info.remote_user);; 11188 addenv(env, ""%s"", ""AUTH_TYPE=Digest"");; 11189 }; 11190 ; 11191 /* Add all headers as HTTP_* variables */; 11192 for (i = 0; i < conn->request_info.num_headers; i++) {; 11193 ; 11194 (void)mg_snprintf(conn,; 11195 &truncated,; 11196 http_var_na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:322088,error,error,322088,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"11135 conn->path_info);; 11136 }; 11137 ; 11138 addenv(env, ""HTTPS=%s"", (conn->ssl == NULL) ? ""off"" : ""on"");; 11139 ; 11140 if ((s = mg_get_header(conn, ""Content-Type"")) != NULL) {; 11141 addenv(env, ""CONTENT_TYPE=%s"", s);; 11142 }; 11143 if (conn->request_info.query_string != NULL) {; 11144 addenv(env, ""QUERY_STRING=%s"", conn->request_info.query_string);; 11145 }; 11146 if ((s = mg_get_header(conn, ""Content-Length"")) != NULL) {; 11147 addenv(env, ""CONTENT_LENGTH=%s"", s);; 11148 }; 11149 if ((s = getenv(""PATH"")) != NULL) {; 11150 addenv(env, ""PATH=%s"", s);; 11151 }; 11152 if (conn->path_info != NULL) {; 11153 addenv(env, ""PATH_INFO=%s"", conn->path_info);; 11154 }; 11155 ; 11156 if (conn->status_code > 0) {; 11157 /* CGI error handler should show the status code */; 11158 addenv(env, ""STATUS=%d"", conn->status_code);; 11159 }; 11160 ; 11161#if defined(_WIN32); 11162 if ((s = getenv(""COMSPEC"")) != NULL) {; 11163 addenv(env, ""COMSPEC=%s"", s);; 11164 }; 11165 if ((s = getenv(""SYSTEMROOT"")) != NULL) {; 11166 addenv(env, ""SYSTEMROOT=%s"", s);; 11167 }; 11168 if ((s = getenv(""SystemDrive"")) != NULL) {; 11169 addenv(env, ""SystemDrive=%s"", s);; 11170 }; 11171 if ((s = getenv(""ProgramFiles"")) != NULL) {; 11172 addenv(env, ""ProgramFiles=%s"", s);; 11173 }; 11174 if ((s = getenv(""ProgramFiles(x86)"")) != NULL) {; 11175 addenv(env, ""ProgramFiles(x86)=%s"", s);; 11176 }; 11177#else; 11178 if ((s = getenv(""LD_LIBRARY_PATH"")) != NULL) {; 11179 addenv(env, ""LD_LIBRARY_PATH=%s"", s);; 11180 }; 11181#endif /* _WIN32 */; 11182 ; 11183 if ((s = getenv(""PERLLIB"")) != NULL) {; 11184 addenv(env, ""PERLLIB=%s"", s);; 11185 }; 11186 ; 11187 if (conn->request_info.remote_user != NULL) {; 11188 addenv(env, ""REMOTE_USER=%s"", conn->request_info.remote_user);; 11189 addenv(env, ""%s"", ""AUTH_TYPE=Digest"");; 11190 }; 11191 ; 11192 /* Add all headers as HTTP_* variables */; 11193 for (i = 0; i < conn->request_info.num_headers; i++) {; 11194 ; 11195 (void)mg_snprintf(conn,; 11196 &truncated,; 11197 http_var_na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:322121,error,error,322121,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,1142 43585.5 4; : 839 Minimum Test error found - save the configuration ; : 839 | 7.52525 10.9666 0.0202646 0.00182844 43392.9 0; : 840 | 7.48548 11.313 0.020051 0.00174873 43710.5 1; : 841 | 7.28024 11.1847 0.0200374 0.0017493 43744.4 2; : 842 | 7.18939 11.0082 0.0200397 0.00175322 43748.2 3; : 843 Minimum Test error found - save the configuration ; : 843 | 7.01613 10.4197 0.0201334 0.00182993 43707.5 0; : 844 | 6.83302 10.8151 0.020039 0.00176037 43767.1 1; : 845 | 6.97518 10.5462 0.0200409 0.00175987 43761.2 2; : 846 | 6.93317 10.5904 0.0200239 0.00176026 43802.8 3; : 847 | 6.86223 10.6492 0.0200268 0.00176058 43796.8 4; : 848 | 7.00201 10.9279 0.0200258 0.00175939 43796.3 5; : 849 | 6.9266 10.4735 0.0200333 0.00176264 43785.9 6; : 850 | 6.72856 10.6877 0.0200521 0.00176189 43739.2 7; : 851 | 6.84236 10.8522 0.0200238 0.00176009 43802.7 8; : 852 Minimum Test error found - save the configuration ; : 852 | 6.78011 10.0733 0.0201111 0.00182524 43749.6 0; : 853 Minimum Test error found - save the configuration ; : 853 | 6.53284 9.90736 0.0201187 0.00181829 43714.8 0; : 854 | 6.67108 10.0768 0.0205443 0.0017732 42618.8 1; : 855 | 6.58878 10.7427 0.0200637 0.00176264 43713.2 2; : 856 | 6.54513 10.3387 0.0200413 0.00176141 43764 3; : 857 Minimum Test error found - save the configuration ; : 857 | 6.43616 9.72218 0.020097 0.00182688 43787.4 0; : 858 | 6.34936 10.0458 0.0200349 0.00176193 43780.5 1; : 859 Minimum Test error found - save the configuration ; : 859 | 6.20554 9.48603 0.0201607 0.00183833 43662.6 0; : 860 | 6.16695 10.0812 0.0200598 0.00175295 43699.5 1; : 861 Minimum Test error found - save the configuration ; : 861 | 6.43224 9.42041 0.0201492 0.00182399 43655.7 0; : 862 | 6.08067 10.0276 0.0200725 0.0017577 43680.5 1; : 863 | 6.34296 10.0575 0.0200642 0.00175521 43694.5 2; : 864 Minimum Test error found - save the configuration ; : 864 | 6.33486 9.34508 0.0201279 0.00182025 43697.5 0; : 865 | 6.18959 10.0219 0.0205128 0.00175205 42642.3 1; : 866 Minimum Test ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:102388,error,error,102388,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"116 /**; 117 Initialize method for continuous one-dimensional distribution.; 118 User must provide a distribution object (which is copied inside) and a string for a method.; 119 For the list of available method for 1D cont. distribution see the; 120 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCONT"">UnuRan doc</A>.; 121 A re-initialization is needed whenever distribution parameters have been changed.; 122 Note that the method string can contain in addition to the method name all the specific method; 123 parameters specified using the UNURAN method string API.; 124 For example a valid string can be `""method=arou; max_segments=1000; max_sqhratio = 0.9""`; 125 */; 126 bool Init(const TUnuranContDist & distr, const std::string & method = ""auto"");; 127 ; 128 /**; 129 Initialize method for continuous multi-dimensional distribution.; 130 User must provide a distribution object (which is copied inside) and a string for a method.; 131 For the list of available method for multivariate cont. distribution see the; 132 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCVEC"">UnuRan doc</A>; 133 A re-initialization is needed whenever distribution parameters have been changed.; 134 ; 135 The default method used for multi-dimensional distributions is ""vnrou""; 136 Note that some of the multi-dimensional continuous distribution methods like ""hitro"" are based on Markov-CHain sampler and; 137 they are much faster for sampling but require more time to converge. Furthermore, since they are Markov-Chain methods their; 138 generated sample values are correlated and cannot be used as i.i.d., one can instead use the obtained sample distribution.; 139 (see also the ROOT issue: #10222 ).; 140 ; 141 */; 142 bool Init(const TUnuranMultiContDist & distr, const std::string & method = ""vnrou"");; 143 ; 144 ; 145 /**; 146 Initialize method for continuous one-dimensional discrete distribution.; 147 User must provide a distribution objec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnuran_8h_source.html:4752,avail,available,4752,doc/master/TUnuran_8h_source.html,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html,1,['avail'],['available']
Availability,"116; 216; 126; 130. Poisson(m-10); 147; 1161; 162; 239. Poisson(m=10) UNURAN; 80; 294; 89; 99. 13.5 Mathematical Functions; The mathematical functions are present in both MathCore and MathMore libraries. All mathematical functions are implemented as free functions in the namespace ROOT::Math. The most used functions are in the MathCore library while the others are in the MathMore library. The functions in MathMore are all using the implementation of the GNU Scientific Library (GSL). The naming of the special functions is the same defined in the C++ Technical Report on Standard Library extensions. The special functions are defined in the header file Math/SpecFunc.h.; 13.5.1 Special Functions in MathCore. ROOT::Math::beta(double x,double y) -evaluates the beta function: \[B(x,y) = \frac{\Gamma(x) \Gamma(y)}{\Gamma(x+y)}\]; double ROOT::Math::erf(double x) - evaluates the error function encountered in integrating the normal distribution: \[erf(x) = \frac{2}{\sqrt{\pi}} \int_{0}^{x} e^{-t^2} dt\]; double ROOT::Math::erfc(double x) - evaluates the complementary error function: \[erfc(x) = 1 - erf(x) = \frac{2}{\sqrt{\pi}} \int_{x}^{\infty} e^{-t^2} dt\]; double ROOT::Math::tgamma(double x) - calculates the gamma function: \[\Gamma(x) = \int_{0}^{\infty} t^{x-1} e^{-t} dt\]. 13.5.2 Special Functions in MathMore. double ROOT::Math::assoc_legendre(unsigned l,unsigned m,double x) -computes the associated Legendre polynomials (with m>=0, l>=m and |x|<1): \[P_{l}^{m}(x) = (1-x^2)^{m/2} \frac{d^m}{dx^m} P_{l}(x)\]; double ROOT::Math::comp_ellint_1(double k) - calculates the complete elliptic integral of the first kind (with \(0 \le k^2 \le 1\): \[; K(k) = F(k, \pi / 2) = \int_{0}^{\pi /2} \frac{d \theta}{\sqrt{1 - k^2 \sin^2{\theta}}}; \]; double ROOT::Math::comp_ellint_2(double k) - calculates the complete elliptic integral of the second kind (with \(0 \le k^2 \le 1\)): \[; E(k) = E(k , \pi / 2) = \int_{0}^{\pi /2} \sqrt{1 - k^2 \sin^2{\theta}} d \theta; \]; double ROOT::Math::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:676778,error,error,676778,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['error'],['error']
Availability,"11::DrawLine(Drawable_t id, GContext_t gc, Int_t x1, Int_t y1, Int_t x2, Int_t y2); virtual voidTGX11::DrawPolyLine(Int_t n, TPoint* xy); virtual voidTGX11::DrawPolyMarker(Int_t n, TPoint* xy); virtual voidTGX11::DrawRectangle(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGX11::DrawSegments(Drawable_t id, GContext_t gc, Segment_t* seg, Int_t nseg); virtual voidDrawString(Drawable_t id, GContext_t gc, Int_t x, Int_t y, const char* s, Int_t len); virtual voidDrawText(Int_t x, Int_t y, Float_t angle, Float_t mgn, const char* text, TVirtualX::ETextMode mode); virtual voidTObject::Dump() constMENU ; virtual Bool_tTGX11::EmptyRegion(Region_t reg); virtual Bool_tTGX11::EqualRegion(Region_t rega, Region_t regb); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tTGX11::EventsPending(); virtual UInt_tTVirtualX::ExecCommand(TGWin32Command* code); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTGX11::FillPolygon(Window_t id, GContext_t gc, Point_t* points, Int_t npnt); virtual voidTGX11::FillRectangle(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Window_tTGX11::FindRWindow(Window_t win, Window_t dragwin, Window_t input, int x, int y, int maxd); virtual voidTGX11::FreeColor(Colormap_t cmap, ULong_t pixel); virtual voidTGX11::FreeFontNames(char** fontlist); virtual voidTGX11::FreeFontStruct(FontStruct_t fs); virtual voidTGX11::GetCharacterUp(Float_t& chupx, Float_t& chupy); virtual unsigned char*TGX11::GetColorBits(Drawable_t wid, Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGX11TTF.html:6131,error,error,6131,root/html528/TGX11TTF.html,https://root.cern,https://root.cern/root/html528/TGX11TTF.html,3,['error'],['error']
Availability,"11; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::IsATClass * IsA() const overrideDefinition TGraphErrors.h:78; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphErrors.cxx:510; TGraphErrors::TGraphErrorsTGraphErrors()TGraphErrors default constructor.Definition TGraphErrors.cxx:69; TGraphErrors::GetErr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:35126,error,error,35126,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['error']
Availability,"11]. template<typename Proxied , typename DataSource = void> . template<typename F > . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::Vary ; (; const std::vector< std::string > & ; colNames, . F && ; expression, . const ColumnNames_t & ; inputColumns, . const std::vector< std::string > & ; variationTags, . std::string_view ; variationName . ). inline . Register systematic variations for multiple existing columns using custom variation tags. ; Parameters. [in]colNamesset of names of the columns for which varied values are provided. ; [in]expressiona callable that evaluates the varied values for the specified columns. The callable can take any column values as input, similarly to what happens during Filter and Define calls. It must return an RVec of varied values, one for each variation tag, in the same order as the tags. ; [in]inputColumnsthe names of the columns to be passed to the callable. ; [in]variationTagsnames for each of the varied values, e.g. ""up"" and ""down"". ; [in]variationNamea generic name for this set of varied values, e.g. ""ptvariation"". This overload of Vary takes a list of column names as first argument and requires that the expression returns an RVec of RVecs of values: one inner RVec for the variations of each affected column. The variationTags are defined as {""down"", ""up""}.; Example usage: // produce variations ""ptAndEta:down"" and ""ptAndEta:up""; auto nominal_hx =; df.Vary({""pt"", ""eta""}, // the columns that will vary simultaneously; [](double pt, double eta) { return RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}; },; {""pt"", ""eta""}, // inputs to the Vary expression, independent of what columns are varied; {""down"", ""up""}, // variation tags; ""ptAndEta"") // variation name; .Histo1D(""pt"", ""eta"");; ; auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; hx[""nominal""].Draw();; hx[""ptAndEta:down""].Draw(""SAME"");; hx[""ptAndEta:up""].Draw(""SAME"");; ROOT::RDF::RInterface::Histo1DRResultPtr<::TH1D > Histo1D(const TH1DModel ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:137396,down,down,137396,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['down'],['down']
Availability,"1243 // nS = Max(S,s) + 0.5 * Nfree; 1244 Int_t stillNeedForTraining = TMath::Max(requestedTraining-availableTraining,0);; 1245 Int_t stillNeedForTesting = TMath::Max(requestedTesting-availableTesting,0);; 1246 ; 1247 int NFree = availableUndefined - stillNeedForTraining - stillNeedForTesting;; 1248 if (NFree <0) NFree = 0;; 1249 useForTraining = TMath::Max(requestedTraining,availableTraining) + NFree/2;; 1250 useForTesting= allAvailable - useForTraining; // the rest; 1251 }; 1252 ; 1253 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""determined event sample size to select training sample from=""<<useForTraining<<Endl;; 1254 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""determined event sample size to select test sample from=""<<useForTesting<<Endl;; 1255 ; 1256 ; 1257 ; 1258 // associate undefined events; 1259 if( splitMode == ""ALTERNATE"" ){; 1260 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""split 'ALTERNATE'"" << Endl;; 1261 Int_t nTraining = availableTraining;; 1262 for( EventVector::iterator it = eventVectorUndefined.begin(), itEnd = eventVectorUndefined.end(); it != itEnd; ){; 1263 ++nTraining;; 1264 if( nTraining <= requestedTraining ){; 1265 eventVectorTraining.insert( eventVectorTraining.end(), (*it) );; 1266 ++it;; 1267 }; 1268 if( it != itEnd ){; 1269 eventVectorTesting.insert( eventVectorTesting.end(), (*it) );; 1270 ++it;; 1271 }; 1272 }; 1273 } else {; 1274 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""split '"" << splitMode << ""'"" << Endl;; 1275 ; 1276 // test if enough events are available; 1277 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""availableundefined : "" << availableUndefined << Endl;; 1278 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""useForTraining : "" << useForTraining << Endl;; 1279 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""useForTesting : "" << useForTesting << Endl;; 1280 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""availableTraining :",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:55102,avail,availableTraining,55102,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['avail'],['availableTraining']
Availability,"12947 *(uint32_t *)(void *)(out + i) =; 12948 *(uint32_t *)(void *)(in + i) ^ masking_key;; 12949 i += 4;; 12950 }; 12951 }; 12952 if (i != in_len) {; 12953 /* convert 1-3 remaining bytes if ((dataLen % 4) != 0)*/; 12954 while (i < in_len) {; 12955 *(uint8_t *)(void *)(out + i) =; 12956 *(uint8_t *)(void *)(in + i); 12957 ^ *(((uint8_t *)&masking_key) + (i % 4));; 12958 i++;; 12959 }; 12960 }; 12961}; 12962 ; 12963 ; 12964int; 12965mg_websocket_client_write(struct mg_connection *conn,; 12966 int opcode,; 12967 const char *data,; 12968 size_t dataLen); 12969{; 12970 int retval = -1;; 12971 char *masked_data =; 12972 (char *)mg_malloc_ctx(((dataLen + 7) / 4) * 4, conn->phys_ctx);; 12973 uint32_t masking_key = 0;; 12974 ; 12975 if (masked_data == NULL) {; 12976 /* Return -1 in an error case */; 12977 mg_cry_internal(conn,; 12978 ""%s"",; 12979 ""Cannot allocate buffer for masked websocket response: ""; 12980 ""Out of memory"");; 12981 return -1;; 12982 }; 12983 ; 12984 do {; 12985 /* Get a masking key - but not 0 */; 12986 masking_key = (uint32_t)get_random();; 12987 } while (masking_key == 0);; 12988 ; 12989 mask_data(data, dataLen, masking_key, masked_data);; 12990 ; 12991 retval = mg_websocket_write_exec(; 12992 conn, opcode, masked_data, dataLen, masking_key);; 12993 mg_free(masked_data);; 12994 ; 12995 return retval;; 12996}; 12997 ; 12998 ; 12999static void; 13000handle_websocket_request(struct mg_connection *conn,; 13001 const char *path,; 13002 int is_callback_resource,; 13003 struct mg_websocket_subprotocols *subprotocols,; 13004 mg_websocket_connect_handler ws_connect_handler,; 13005 mg_websocket_ready_handler ws_ready_handler,; 13006 mg_websocket_data_handler ws_data_handler,; 13007 mg_websocket_close_handler ws_close_handler,; 13008 void *cbData); 13009{; 13010 const char *websock_key = mg_get_header(conn, ""Sec-WebSocket-Key"");; 13011 const char *version = mg_get_header(conn, ""Sec-WebSocket-Version"");; 13012 ptrdiff_t lua_websock = 0;; 13013 ; 13014#if !defined(U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:377990,mask,masking,377990,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['mask'],['masking']
Availability,"12948 *(uint32_t *)(void *)(out + i) =; 12949 *(uint32_t *)(void *)(in + i) ^ masking_key;; 12950 i += 4;; 12951 }; 12952 }; 12953 if (i != in_len) {; 12954 /* convert 1-3 remaining bytes if ((dataLen % 4) != 0)*/; 12955 while (i < in_len) {; 12956 *(uint8_t *)(void *)(out + i) =; 12957 *(uint8_t *)(void *)(in + i); 12958 ^ *(((uint8_t *)&masking_key) + (i % 4));; 12959 i++;; 12960 }; 12961 }; 12962}; 12963 ; 12964 ; 12965int; 12966mg_websocket_client_write(struct mg_connection *conn,; 12967 int opcode,; 12968 const char *data,; 12969 size_t dataLen); 12970{; 12971 int retval = -1;; 12972 char *masked_data =; 12973 (char *)mg_malloc_ctx(((dataLen + 7) / 4) * 4, conn->phys_ctx);; 12974 uint32_t masking_key = 0;; 12975 ; 12976 if (masked_data == NULL) {; 12977 /* Return -1 in an error case */; 12978 mg_cry_internal(conn,; 12979 ""%s"",; 12980 ""Cannot allocate buffer for masked websocket response: ""; 12981 ""Out of memory"");; 12982 return -1;; 12983 }; 12984 ; 12985 do {; 12986 /* Get a masking key - but not 0 */; 12987 masking_key = (uint32_t)get_random();; 12988 } while (masking_key == 0);; 12989 ; 12990 mask_data(data, dataLen, masking_key, masked_data);; 12991 ; 12992 retval = mg_websocket_write_exec(; 12993 conn, opcode, masked_data, dataLen, masking_key);; 12994 mg_free(masked_data);; 12995 ; 12996 return retval;; 12997}; 12998 ; 12999 ; 13000static void; 13001handle_websocket_request(struct mg_connection *conn,; 13002 const char *path,; 13003 int is_callback_resource,; 13004 struct mg_websocket_subprotocols *subprotocols,; 13005 mg_websocket_connect_handler ws_connect_handler,; 13006 mg_websocket_ready_handler ws_ready_handler,; 13007 mg_websocket_data_handler ws_data_handler,; 13008 mg_websocket_close_handler ws_close_handler,; 13009 void *cbData); 13010{; 13011 const char *websock_key = mg_get_header(conn, ""Sec-WebSocket-Key"");; 13012 const char *version = mg_get_header(conn, ""Sec-WebSocket-Version"");; 13013 ptrdiff_t lua_websock = 0;; 13014 ; 13015#if !defined(U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:378023,mask,masking,378023,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['mask'],['masking']
Availability,"1296Int_t TChain::LoadBaskets(Long64_t /*maxmemory*/); 1297{; 1298 Error(""LoadBaskets"", ""Function not yet implemented for TChain."");; 1299 return 0;; 1300}; 1301 ; 1302////////////////////////////////////////////////////////////////////////////////; 1303/// Find the tree which contains entry, and set it as the current tree.; 1304///; 1305/// Returns the entry number in that tree.; 1306///; 1307/// The input argument entry is the entry serial number in the whole chain.; 1308///; 1309/// In case of error, LoadTree returns a negative number:; 1310/// * -1: The chain is empty.; 1311/// * -2: The requested entry number is less than zero or too large for the chain.; 1312/// * -3: The file corresponding to the entry could not be correctly open; 1313/// * -4: The TChainElement corresponding to the entry is missing or; 1314/// the TTree is missing from the file.; 1315/// * -5: Internal error, please report the circumstance when this happen; 1316/// as a ROOT issue.; 1317/// * -6: An error occurred within the notify callback.; 1318///; 1319/// Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new sub-tree.; 1320/// See TNotifyLink for more information on the notification mechanism.; 1321///; 1322/// \note This is the only routine which sets the value of fTree to a non-zero pointer.; 1323///; 1324Long64_t TChain::LoadTree(Long64_t entry); 1325{; 1326 // We already have been visited while recursively looking; 1327 // through the friends tree, let's return.; 1328 if (kLoadTree & fFriendLockStatus) {; 1329 return 0;; 1330 }; 1331 ; 1332 if (!fNtrees) {; 1333 // -- The chain is empty.; 1334 return -1;; 1335 }; 1336 ; 1337 if ((entry < 0) || ((entry > 0) && (entry >= fEntries && entry!=(TTree::kMaxEntries-1) ))) {; 1338 // -- Invalid entry number.; 1339 if (fTree) fTree->LoadTree(-1);; 1340 fReadEntry = -1;; 1341 return -2;; 1342 }; 1343 ; 1344 // Find out which tree in the chain contains the passed entry.; 1345 Int_t treenum = fTreeNumber;; 1346 if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:48131,error,error,48131,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['error'],['error']
Availability,"13 Double_t w = GetBinContent(binx,biny,binz);; 7714 np+=w;; 7715 sum+=w*(x-mean)*(x-mean)*(x-mean);; 7716 }; 7717 }; 7718 }; 7719 sum/=np*stddev3;; 7720 return sum;; 7721 }; 7722 else if (axis > 10 && axis <= 13) {; 7723 //compute standard error of skewness; 7724 // assume parent normal distribution use formula from Kendall-Stuart, Vol 1 pag 243, second edition; 7725 Double_t neff = GetEffectiveEntries();; 7726 return ( neff > 0 ? TMath::Sqrt(6./neff ) : 0. );; 7727 }; 7728 else {; 7729 Error(""GetSkewness"", ""illegal value of parameter"");; 7730 return 0;; 7731 }; 7732}; 7733 ; 7734////////////////////////////////////////////////////////////////////////////////; 7735/// - For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.; 7736/// Kurtosis(gaussian(0, 1)) = 0.; 7737/// - For axis =11, 12 or 13 returns the approximate standard error of kurtosis; 7738/// of the histogram along x, y or z axis; 7739////; 7740/// Note, that since third and fourth moment are not calculated; 7741/// at the fill time, kurtosis and its standard error are computed bin by bin; 7742///; 7743/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7744/// are calculated. See TH1::GetMean and TH1::GetStdDev.; 7745 ; 7746Double_t TH1::GetKurtosis(Int_t axis) const; 7747{; 7748 if (axis > 0 && axis <= 3){; 7749 ; 7750 Double_t mean = GetMean(axis);; 7751 Double_t stddev = GetStdDev(axis);; 7752 Double_t stddev4 = stddev*stddev*stddev*stddev;; 7753 ; 7754 Int_t firstBinX = fXaxis.GetFirst();; 7755 Int_t lastBinX = fXaxis.GetLast();; 7756 Int_t firstBinY = fYaxis.GetFirst();; 7757 Int_t lastBinY = fYaxis.GetLast();; 7758 Int_t firstBinZ = fZaxis.GetFirst();; 7759 Int_t lastBinZ = fZaxis.GetLast();; 7760 // include underflow/overflow if TH1::StatOverflows(kTRUE) in case no range is set on the axis; 7761 if (GetStatOverflowsBehaviour()) {; 7762 if ( !fXaxis.TestBit(TAxis::kAxisRange) ) {; 7763 if (firstBinX == 1) firstBinX = 0;; 7764 if (lastBinX == fXaxis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:303193,error,error,303193,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,2,['error'],['error']
Availability,"1344 Int_t i = 1;; 1345 while ((lb=(TObjString*)iL())) {; 1346 h1->GetXaxis()->SetBinLabel(i,lb->String().Data());; 1347 i++;; 1348 }; 1349 }; 1350 ; 1351 h1->SetEntries(fEntries);; 1352 return h1;; 1353}; 1354 ; 1355////////////////////////////////////////////////////////////////////////////////; 1356/// Replace current statistics with the values in array stats.; 1357 ; 1358void TProfile::PutStats(Double_t *stats); 1359{; 1360 fTsumw = stats[0];; 1361 fTsumw2 = stats[1];; 1362 fTsumwx = stats[2];; 1363 fTsumwx2 = stats[3];; 1364 fTsumwy = stats[4];; 1365 fTsumwy2 = stats[5];; 1366}; 1367 ; 1368////////////////////////////////////////////////////////////////////////////////; 1369/// Rebin this profile grouping ngroup bins together.; 1370///; 1371/// ## case 1 xbins=0; 1372/// if newname is not blank a new temporary profile hnew is created.; 1373/// else the current profile is modified (default); 1374/// The parameter ngroup indicates how many bins of this have to me merged; 1375/// into one bin of hnew; 1376/// If the original profile has errors stored (via Sumw2), the resulting; 1377/// profile has new errors correctly calculated.; 1378///; 1379/// examples: if hp is an existing TProfile histogram with 100 bins; 1380///; 1381/// ~~~ {.cpp}; 1382/// hp->Rebin(); //merges two bins in one in hp: previous contents of hp are lost; 1383/// hp->Rebin(5); //merges five bins in one in hp; 1384/// TProfile *hnew = hp->Rebin(5,""hnew""); // creates a new profile hnew; 1385/// //merging 5 bins of hp in one bin; 1386/// ~~~; 1387///; 1388/// NOTE: If ngroup is not an exact divider of the number of bins,; 1389/// the top limit of the rebinned profile is changed; 1390/// to the upper edge of the bin=newbins*ngroup and the corresponding; 1391/// bins are added to the overflow bin.; 1392/// Statistics will be recomputed from the new bin contents.; 1393///; 1394/// ## case 2 xbins!=0; 1395/// a new profile is created (you should specify newname).; 1396/// The parameter ngroup is the n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:50586,error,errors,50586,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,2,['error'],['errors']
Availability,135 43443 5; : 884 Minimum Test error found - save the configuration ; : 884 | 5.44144 8.14796 0.020157 0.00182376 43636.7 0; : 885 | 5.72885 9.21369 0.0207466 0.00176462 42145.2 1; : 886 | 5.67418 8.64993 0.0200759 0.00176094 43680.2 2; : 887 Minimum Test error found - save the configuration ; : 887 | 5.55202 8.05484 0.0201465 0.00184145 43703.7 0; : 888 Minimum Test error found - save the configuration ; : 888 | 5.4009 7.86368 0.0201494 0.00184759 43711.4 0; : 889 | 5.09006 7.93881 0.0200766 0.00176618 43691 1; : 890 | 5.16257 8.05551 0.0200625 0.00176866 43730.7 2; : 891 Minimum Test error found - save the configuration ; : 891 | 5.07326 7.82028 0.0201532 0.0018382 43680.1 0; : 892 | 5.14088 7.89491 0.0200852 0.00179174 43731.4 1; : 893 Minimum Test error found - save the configuration ; : 893 | 5.13302 7.67646 0.0201541 0.00183919 43680.3 0; : 894 | 5.44229 7.83993 0.0200562 0.00176505 43736.9 1; : 895 | 5.40474 8.2327 0.0200223 0.00176151 43809.8 2; : 896 Minimum Test error found - save the configuration ; : 896 | 5.30823 7.62628 0.0201123 0.00182273 43740.8 0; : 897 | 6.20081 8.04326 0.0200652 0.00176931 43725.7 1; : 898 | 5.99101 8.0649 0.0200274 0.00175928 43792 2; : 899 Minimum Test error found - save the configuration ; : 899 | 5.1416 7.3348 0.0201215 0.00182199 43717.1 0; : 900 | 4.88699 7.46821 0.0200416 0.0017612 43762.6 1; : 901 Minimum Test error found - save the configuration ; : 901 | 4.92918 7.2702 0.0200754 0.00181642 43814.2 0; : 902 Minimum Test error found - save the configuration ; : 902 | 5.04871 7.17895 0.0200791 0.00180807 43785.1 0; : 903 | 4.88551 7.21813 0.0200213 0.00174992 43784.3 1; : 904 | 4.98683 7.44507 0.0200553 0.00174858 43699.9 2; : 905 | 4.82992 7.45009 0.0202406 0.00175807 43284.1 3; : 906 | 4.86112 7.78644 0.0202162 0.00175457 43333 4; : 907 Minimum Test error found - save the configuration ; : 907 | 4.76534 7.04169 0.0202678 0.00183052 43390.4 0; : 908 | 4.77659 7.36078 0.0201903 0.00174867 43380.2 1; : 909 | 5.40526 9.09975,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:105705,error,error,105705,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"1361/// Assume another process1 is connecting this directory in Update mode; 1362/// - Process1 is adding/updating objects in this directory; 1363/// - You want to see the latest status from process1.; 1364/// Example Process1:; 1365/// ~~~{.cpp}; 1366/// obj1.Write();; 1367/// obj2.Write();; 1368/// gDirectory->SaveSelf();; 1369/// ~~~; 1370///; 1371/// Example Process2:; 1372/// ~~~{.cpp}; 1373/// gDirectory->ReadKeys();; 1374/// obj1->Draw();; 1375/// ~~~; 1376/// This is an efficient way (without opening/closing files) to view; 1377/// the latest updates of a file being modified by another process; 1378/// as it is typically the case in a data acquisition system.; 1379 ; 1380Int_t TDirectoryFile::ReadKeys(Bool_t forceRead); 1381{; 1382 if (!fFile || !fKeys) return 0;; 1383 ; 1384 if (!fFile->IsBinary()); 1385 return fFile->DirReadKeys(this);; 1386 ; 1387 TDirectory::TContext ctxt(this);; 1388 ; 1389 char *buffer;; 1390 if (forceRead) {; 1391 fKeys->Delete();; 1392 //In case directory was updated by another process, read new; 1393 //position for the keys; 1394 Int_t nbytes = fNbytesName + TDirectoryFile::Sizeof();; 1395 char *header = new char[nbytes];; 1396 buffer = header;; 1397 fFile->Seek(fSeekDir);; 1398 if ( fFile->ReadBuffer(buffer,nbytes) ) {; 1399 // ReadBuffer return kTRUE in case of failure.; 1400 delete [] header;; 1401 return 0;; 1402 }; 1403 buffer += fNbytesName;; 1404 Version_t versiondir;; 1405 frombuf(buffer,&versiondir);; 1406 fDatimeC.ReadBuffer(buffer);; 1407 fDatimeM.ReadBuffer(buffer);; 1408 frombuf(buffer, &fNbytesKeys);; 1409 frombuf(buffer, &fNbytesName);; 1410 if (versiondir > 1000) {; 1411 frombuf(buffer, &fSeekDir);; 1412 frombuf(buffer, &fSeekParent);; 1413 frombuf(buffer, &fSeekKeys);; 1414 } else {; 1415 Int_t sdir,sparent,skeys;; 1416 frombuf(buffer, &sdir); fSeekDir = (Long64_t)sdir;; 1417 frombuf(buffer, &sparent); fSeekParent = (Long64_t)sparent;; 1418 frombuf(buffer, &skeys); fSeekKeys = (Long64_t)skeys;; 1419 }; 1420 delete []",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:47564,failure,failure,47564,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['failure'],['failure']
Availability,"137; ROOT::Experimental::RLogManager::Removestd::unique_ptr< RLogHandler > Remove(RLogHandler *handler)Remove and return the given log handler. Returns nullptr if not found.Definition RLogger.cxx:68; ROOT::Experimental::RLogManager::Getstatic RLogManager & Get()Definition RLogger.cxx:62; ROOT::Experimental::RLogManager::RLogManagerRLogManager(std::unique_ptr< RLogHandler > lh)Initialize taking a RLogHandler.Definition RLogger.hxx:142; ROOT::Experimental::RLogManager::Emitbool Emit(const RLogEntry &entry) overrideEmit a log entry.Definition RLogger.cxx:82; ROOT::Experimental::RLogManager::PushFrontvoid PushFront(std::unique_ptr< RLogHandler > handler)Add a RLogHandler in the front - to be called before all others.Definition RLogger.hxx:150; ROOT::Experimental::RLogManager::PushBackvoid PushBack(std::unique_ptr< RLogHandler > handler)Add a RLogHandler in the back - to be called after all others.Definition RLogger.hxx:153; ROOT::Experimental::RLogScopedDiagCountObject to count the number of warnings and errors emitted by a section of code, after construction of...Definition RLogger.hxx:260; ROOT::Experimental::RLogScopedDiagCount::GetAccumulatedWarningslong long GetAccumulatedWarnings() constGet the number of warnings that the RLogDiagCount has emitted since construction of *this.Definition RLogger.hxx:282; ROOT::Experimental::RLogScopedDiagCount::HasWarningOccurredbool HasWarningOccurred() constWhether the RLogDiagCount has emitted a warnings since construction time of *this.Definition RLogger.hxx:291; ROOT::Experimental::RLogScopedDiagCount::HasErrorOrWarningOccurredbool HasErrorOrWarningOccurred() constWhether the RLogDiagCount has emitted an error or a warning since construction time of *this.Definition RLogger.hxx:297; ROOT::Experimental::RLogScopedDiagCount::HasErrorOccurredbool HasErrorOccurred() constWhether the RLogDiagCount has emitted an error (fatal or not) since construction time of *this.Definition RLogger.hxx:294; ROOT::Experimental::RLogScopedDiagCount:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RLogger_8hxx_source.html:21420,error,errors,21420,doc/master/RLogger_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html,1,['error'],['errors']
Availability,140 of file Minuit2Minimizer.h. ◆ Errors(). const double * ROOT::Minuit2::Minuit2Minimizer::Errors ; (; ); const. overridevirtual . return errors at the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 717 of file Minuit2Minimizer.cxx. ◆ ExamineMinimum(). bool ROOT::Minuit2::Minuit2Minimizer::ExamineMinimum ; (; const ROOT::Minuit2::FunctionMinimum & ; min). protected . examine the minimum result ; Definition at line 594 of file Minuit2Minimizer.cxx. ◆ FixVariable(). bool ROOT::Minuit2::Minuit2Minimizer::FixVariable ; (; unsigned int ; ivar). overridevirtual . fix an existing variable ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 338 of file Minuit2Minimizer.cxx. ◆ GetCovMatrix(). bool ROOT::Minuit2::Minuit2Minimizer::GetCovMatrix ; (; double * ; cov); const. overridevirtual . Fill the passed array with the covariance matrix elements if the variable is fixed or const the value is zero. ; The array will be filled as cov[i *ndim + j] The ordering of the variables is the same as in errors and parameter value. This is different from the direct interface of Minuit2 or TMinuit where the values were obtained only to variable parameters ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 755 of file Minuit2Minimizer.cxx. ◆ GetFCN(). virtual const ROOT::Minuit2::FCNBase * ROOT::Minuit2::Minuit2Minimizer::GetFCN ; (; ); const. inlineprotectedvirtual . Definition at line 287 of file Minuit2Minimizer.h. ◆ GetHessianMatrix(). bool ROOT::Minuit2::Minuit2Minimizer::GetHessianMatrix ; (; double * ; h); const. overridevirtual . Fill the passed array with the Hessian matrix elements The Hessian matrix is the matrix of the second derivatives and is the inverse of the covariance matrix If the variable is fixed or const the values for that variables are zero. ; The array will be filled as h[i *ndim + j] ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 784 of file Minuit2Minimizer.cxx. ◆ GetMinimizer(). virtual const ROOT,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html:16421,error,errors,16421,doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,1,['error'],['errors']
Availability,"142 of file TAuthenticate.cxx. ◆ PromptUser(). char * TAuthenticate::PromptUser ; (; const char * ; remote). static . Static method to prompt for the user name to be used for authentication to rootd or proofd. ; User is asked to type user name. Returns user name (which must be deleted by caller) or 0. If non-interactive run (eg ProofServ) returns default user. ; Definition at line 1102 of file TAuthenticate.cxx. ◆ ProofAuthSetup() [1/2]. Int_t TAuthenticate::ProofAuthSetup ; (; ). private . Authentication related stuff setup in TProofServ. ; This is the place where the buffer send by the client / master is decoded. It contains also password information, if the case requires. Return 0 on success, -1 on failure. ; Definition at line 3699 of file TAuthenticate.cxx. ◆ ProofAuthSetup() [2/2]. Int_t TAuthenticate::ProofAuthSetup ; (; TSocket * ; sock, . Bool_t ; client . ). staticprivate . Setup of authetication related stuff in PROOF run after a successful authentication. ; Return 0 on success, -1 on failure. ; Definition at line 3820 of file TAuthenticate.cxx. ◆ ReadRootAuthrc(). Int_t TAuthenticate::ReadRootAuthrc ; (; ). static . Read authentication directives from $ROOTAUTHRC, $HOME/.rootauthrc or <Root_etc_dir>/system.rootauthrc and create related THostAuth objects. ; Files are read only if they changed since last reading If 'proofconf' is defined, check also file proofconf for directives ; Definition at line 3212 of file TAuthenticate.cxx. ◆ RemoveHostAuth(). void TAuthenticate::RemoveHostAuth ; (; THostAuth * ; ha, . Option_t * ; opt = """" . ). static . Remove THostAuth instance from the list. ; Definition at line 2203 of file TAuthenticate.cxx. ◆ RemoveSecContext(). void TAuthenticate::RemoveSecContext ; (; TRootSecContext * ; ctx). staticprivate . Tool for removing SecContext ctx from THostAuth listed in fgAuthInfo or fgProofAuthInfo. ; Definition at line 3661 of file TAuthenticate.cxx. ◆ RfioAuth(). Int_t TAuthenticate::RfioAuth ; (; TString & ; user). private .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:35260,failure,failure,35260,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['failure'],['failure']
Availability,"143 of file RooDataSet.h. ◆ sumEntries() [1/2]. double RooDataSet::sumEntries ; (; ); const. overridevirtual . Return effective number of entries in dataset, i.e., sum all weights. ; Implements RooAbsData.; Definition at line 844 of file RooDataSet.cxx. ◆ sumEntries() [2/2]. double RooDataSet::sumEntries ; (; const char * ; cutSpec, . const char * ; cutRange = nullptr . ); const. overridevirtual . Return the sum of weights in all entries matching cutSpec (if specified) and in named range cutRange (if specified) ; Implements RooAbsData.; Definition at line 854 of file RooDataSet.cxx. ◆ weight(). double RooDataSet::weight ; (; ); const. overridevirtual . Return event weight of current event. ; Implements RooAbsData.; Definition at line 759 of file RooDataSet.cxx. ◆ weightError() [1/2]. void RooDataSet::weightError ; (; double & ; lo, . double & ; hi, . ErrorType ; etype = SumW2 . ); const. overridevirtual . Return the asymmetric errors on the current weight. ; See also weightError(ErrorType) const for symmetric error. Parameters. [out]loLow error. ; [out]hiHigh error. ; etypeerror type . Reimplemented from RooAbsData.; Definition at line 817 of file RooDataSet.cxx. ◆ weightError() [2/2]. double RooDataSet::weightError ; (; ErrorType ; etype = SumW2); const. overridevirtual . Parameters. etypeerror type . Reimplemented from RooAbsData.; Definition at line 826 of file RooDataSet.cxx. ◆ weightSquared(). double RooDataSet::weightSquared ; (; ); const. overridevirtual . Return squared event weight of the current event. ; If this RooDataSet has no weight errors set, this will be the same as weight() * weight(), like expected for an unbinned dataset. When weight errors are set, it is assumed that the RooDataSet represents a weighted binned dataset and weightSquared() is the corresponding sum of weight squares for the bin. ; Implements RooAbsData.; Definition at line 773 of file RooDataSet.cxx. ◆ weightVar(). RooRealVar * RooDataSet::weightVar ; (; ); const. inline . Returns a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataSet.html:58336,error,error,58336,doc/master/classRooDataSet.html,https://root.cern,https://root.cern/doc/master/classRooDataSet.html,1,['error'],['error']
Availability,"144 out *= _scaleFactor;; 145 ; 146 _var.setVal(oldVal);; 147 return out;; 148 }; 149 double getMinLimit(UInt_t /*dimension*/) const override { return _var.getMin(); }; 150 double getMaxLimit(UInt_t /*dimension*/) const override { return _var.getMax(); }; 151 ; 152private:; 153 RooAbsRealLValue &_var;; 154 std::unique_ptr<RooAbsReal> _arg;; 155 std::span<const double> _dataWeights;; 156 double _scaleFactor;; 157 std::unique_ptr<RooFit::Evaluator> _evaluator;; 158 std::stack<std::vector<double>> _vectorBuffers;; 159};; 160 ; 161struct EvalErrorData {; 162 using ErrorList = std::map<const RooAbsArg *, std::pair<std::string, std::list<RooAbsReal::EvalError>>>;; 163 RooAbsReal::ErrorLoggingMode mode = RooAbsReal::PrintErrors;; 164 int count = 0;; 165 ErrorList errorList;; 166};; 167 ; 168EvalErrorData &evalErrorData(); 169{; 170 static EvalErrorData data;; 171 return data;; 172}; 173 ; 174} // namespace; 175 ; 176Int_t RooAbsReal::numEvalErrorItems(); 177{; 178 return evalErrorData().errorList.size();; 179}; 180 ; 181EvalErrorData::ErrorList::iterator RooAbsReal::evalErrorIter(); 182{; 183 return evalErrorData().errorList.begin();; 184}; 185 ; 186ClassImp(RooAbsReal); 187 ; 188bool RooAbsReal::_globalSelectComp = false;; 189bool RooAbsReal::_hideOffset = true ;; 190 ; 191void RooAbsReal::setHideOffset(bool flag) { _hideOffset = flag ; }; 192bool RooAbsReal::hideOffset() { return _hideOffset ; }; 193 ; 194 ; 195////////////////////////////////////////////////////////////////////////////////; 196/// coverity[UNINIT_CTOR]; 197/// Default constructor; 198 ; 199RooAbsReal::RooAbsReal() {}; 200 ; 201 ; 202////////////////////////////////////////////////////////////////////////////////; 203/// Constructor with unit label; 204 ; 205RooAbsReal::RooAbsReal(const char *name, const char *title, const char *unit) : RooAbsReal{name, title, 0.0, 0.0, unit}; 206{; 207}; 208 ; 209 ; 210////////////////////////////////////////////////////////////////////////////////; 211/// Constructor w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:6066,error,errorList,6066,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['errorList']
Availability,"144# Save data for statistical analysis tutorial (rf618_mixture_models.py) ; 145df.Snapshot(""tree"", ROOT.gROOT.GetTutorialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root"", [""m4l"", ""sample_category"", ""weight""]); 146 ; 147# Book histograms for the four different samples: data, higgs, zz and other (this is specific to this particular analysis); 148histos = []; 149for sample_category in [""data"", ""higgs"", ""zz"", ""other""]:; 150 histos.append(; 151 df.Filter(f'sample_category == ""{sample_category}""').Histo1D(; 152 ROOT.RDF.TH1DModel(f""{sample_category}"", ""m4l"", 24, 80, 170),; 153 ""m4l"",; 154 ""weight"",; 155 ); 156 ); 157 ; 158# Evaluate the systematic uncertainty; 159 ; 160# The systematic uncertainty in this analysis is the MC scale factor uncertainty that depends on lepton; 161# kinematics such as pT or pseudorapidity.; 162# Muons uncertainties are negligible, as stated in https://atlas.web.cern.ch/Atlas/GROUPS/PHYSICS/PAPERS/MUON-2018-03/.; 163# Electrons uncertainties are evaluated based on the plots available in https://doi.org/10.48550/arXiv.1908.00005.; 164# The uncertainties are linearly interpolated, using the `TGraph::Eval()` method, to cover a range of pT values covered by the analysis.; 165 ; 166# Create a VaryHelper to interpolate the available data.; 167ROOT.gInterpreter.Declare(; 168 """"""; 169using namespace ROOT::VecOps;; 170 ; 171class VaryHelper; 172{; 173 const std::vector<double> x{5.50e3, 5.52e3, 12.54e3, 17.43e3, 22.40e3, 27.48e3, 30e3, 10000e3};; 174 const std::vector<double> y{0.06628, 0.06395, 0.06396, 0.03372, 0.02441, 0.01403, 0, 0};; 175 TGraph graph;; 176 ; 177public:; 178 VaryHelper() : graph(x.size(), x.data(), y.data()) {}; 179 RVec<double> operator()(const double &w, const RVecF &pt, const RVec<unsigned int> &type); 180 {; 181 const auto v = Mean(Map(pt[type == 11], [this](auto p); 182 {return this->graph.Eval(p); }); 183 );; 184 return RVec<double>{(1 + v) * w, (1 - v) * w};; 185 }; 186};; 187 ; 188VaryHelper variationsFactory;; 189""""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:7698,avail,available,7698,doc/master/df106__HiggsToFourLeptons_8py_source.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html,1,['avail'],['available']
Availability,"15 fNdf = npoints - fNFree;; 316 else; 317 fNdf = 0;; 318}; 319 ; 320double FitResult::Prob() const {; 321 // fit probability; 322 return ROOT::Math::chisquared_cdf_c(fChi2, static_cast<double>(fNdf) );; 323}; 324 ; 325bool FitResult::HasMinosError(unsigned int i) const {; 326 // query if the parameter i has the Minos error; 327 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 328 return (itr != fMinosErrors.end() );; 329}; 330 ; 331 ; 332double FitResult::LowerError(unsigned int i) const {; 333 // return lower Minos error for parameter i; 334 // return the parabolic error if Minos error has not been calculated for the parameter i; 335 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 336 return ( itr != fMinosErrors.end() ) ? itr->second.first : Error(i) ;; 337}; 338 ; 339double FitResult::UpperError(unsigned int i) const {; 340 // return upper Minos error for parameter i; 341 // return the parabolic error if Minos error has not been calculated for the parameter i; 342 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 343 return ( itr != fMinosErrors.end() ) ? itr->second.second : Error(i) ;; 344}; 345 ; 346void FitResult::SetMinosError(unsigned int i, double elow, double eup) {; 347 // set the Minos error for parameter i; 348 fMinosErrors[i] = std::make_pair(elow,eup);; 349}; 350 ; 351int FitResult::Index(const std::string & name) const {; 352 // find index for given parameter name; 353 if (! fFitFunc) return -1;; 354 unsigned int npar = fParams.size();; 355 for (unsigned int i = 0; i < npar; ++i); 356 if ( fFitFunc->ParameterName(i) == name) return i;; 357 ; 358 return -1; // case name is not found; 359}; 360 ; 361bool FitResult::IsParameterBound(unsigned int ipar) const {; 362 return fBoundParams.find(ipar) != fBoundParams.end();; 363}; 364 ; 365bool FitResult::IsParameterFixed(unsigned int ipar) const {; 366 return fFixedParams.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8cxx_source.html:11452,error,error,11452,doc/master/FitResult_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html,3,['error'],['error']
Availability,"15) && findvis) {; 787 ; 788 // try to find better visual; 789 static XVisualInfo templates[] = {; 790 // Visual, visualid, screen, depth, class , red_mask, green_mask, blue_mask, colormap_size, bits_per_rgb; 791 { nullptr, 0 , 0 , 24 , TrueColor , 0 , 0 , 0 , 0 , 0 },; 792 { nullptr, 0 , 0 , 32 , TrueColor , 0 , 0 , 0 , 0 , 0 },; 793 { nullptr, 0 , 0 , 16 , TrueColor , 0 , 0 , 0 , 0 , 0 },; 794 { nullptr, 0 , 0 , 15 , TrueColor , 0 , 0 , 0 , 0 , 0 },; 795 // no suitable TrueColorMode found - now do the same thing to DirectColor; 796 { nullptr, 0 , 0 , 24 , DirectColor, 0 , 0 , 0 , 0 , 0 },; 797 { nullptr, 0 , 0 , 32 , DirectColor, 0 , 0 , 0 , 0 , 0 },; 798 { nullptr, 0 , 0 , 16 , DirectColor, 0 , 0 , 0 , 0 , 0 },; 799 { nullptr, 0 , 0 , 15 , DirectColor, 0 , 0 , 0 , 0 , 0 },; 800 { nullptr, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },; 801 };; 802 ; 803 Int_t nitems = 0;; 804 XVisualInfo *vlist = nullptr;; 805 for (Int_t i = 0; templates[i].depth != 0; i++) {; 806 Int_t mask = VisualScreenMask|VisualDepthMask|VisualClassMask;; 807 templates[i].screen = fScreenNumber;; 808 if ((vlist = XGetVisualInfo((Display*)fDisplay, mask, &(templates[i]), &nitems))) {; 809 FindUsableVisual((RXVisualInfo*)vlist, nitems);; 810 XFree(vlist);; 811 vlist = nullptr;; 812 if (fVisual); 813 break;; 814 }; 815 }; 816 }; 817 ; 818 fRootWin = RootWindow((Display*)fDisplay, fScreenNumber);; 819 ; 820 if (!fVisual) {; 821 fDepth = DefaultDepth((Display*)fDisplay, fScreenNumber);; 822 fVisual = (RVisual*)DefaultVisual((Display*)fDisplay, fScreenNumber);; 823 fVisRootWin = fRootWin;; 824 if (fDepth > 1); 825 fColormap = DefaultColormap((Display*)fDisplay, fScreenNumber);; 826 fBlackPixel = BlackPixel((Display*)fDisplay, fScreenNumber);; 827 fWhitePixel = WhitePixel((Display*)fDisplay, fScreenNumber);; 828 }; 829 if (gDebug > 1); 830 Printf(""Selected visual 0x%lx: depth %d, class %d, colormap: %s"",; 831 fVisual->visualid, fDepth, fVisual->c_class,; 832 fColormap == DefaultColormap((Display*)fDisplay, fS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:25846,mask,mask,25846,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['mask'],['mask']
Availability,"151\frac{\partial F}{\partial P_{\mathrm{ext}}}; 152\frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; 153\frac{\partial F}{\partial P_{\mathrm{ext}}} = 0; 154\f]; 155 ; 156#### Getting the right parameter errors with limits.; 157 ; 158In the best case, where the minimum is far from any limits, MINUIT will; 159correctly transform the error matrix, and the parameter errors it reports; 160should be accurate and very close to those you would have got without; 161limits. In other cases (which should be more common, since otherwise you; 162wouldn't need limits), the very meaning of parameter errors becomes; 163problematic. Mathematically, since the limit is an absolute constraint on; 164the parameter, a parameter at its limit has no error, at least in one; 165direction. The error matrix, which can assign only symmetric errors, then; 166becomes essentially meaningless.; 167 ; 168### Interpretation of Parameter Errors:; 169 ; 170There are two kinds of problems that can arise: the reliability of; 171MINUIT's error estimates, and their statistical interpretation, assuming; 172they are accurate.; 173 ; 174### Statistical interpretation:; 175 ; 176For discussion of basic concepts, such as the meaning of the elements of; 177the error matrix, or setting of exact confidence levels see:; 178 ; 179 1. F.James.; 180 Determining the statistical Significance of experimental Results.; 181 Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; 182 ; 183 2. W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; 184 Statistical Methods in Experimental Physics.; 185 North-Holland, 1971.; 186 ; 187### Reliability of MINUIT error estimates.; 188 ; 189MINUIT always carries around its own current estimates of the parameter; 190errors, which it will print out on request, no matter how accurate they; 191are at any given point in the execution. For example, at initialization,; 192these estimates are just the starting step sizes as specified by the user.; 193After a HESSE step, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:8297,reliab,reliability,8297,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,2,"['error', 'reliab']","['error', 'reliability']"
Availability,"153 if (exl) memcpy(fEXlow, exl, memsz);; 154 else memset(fEXlow, 0, memsz);; 155 if (exh) memcpy(fEXhigh, exh, memsz);; 156 else memset(fEXhigh, 0, memsz);; 157 if (eyl) memcpy(fEYlow, eyl, memsz);; 158 else memset(fEYlow, 0, memsz);; 159 if (eyh) memcpy(fEYhigh, eyh, memsz);; 160 else memset(fEYhigh, 0, memsz);; 161 ; 162 if (exld) memcpy(fEXlowd, exld, memsz);; 163 else memset(fEXlowd, 0, memsz);; 164 if (exhd) memcpy(fEXhighd, exhd, memsz);; 165 else memset(fEXhighd, 0, memsz);; 166 if (eyld) memcpy(fEYlowd, eyld, memsz);; 167 else memset(fEYlowd, 0, memsz);; 168 if (eyhd) memcpy(fEYhighd, eyhd, memsz);; 169 else memset(fEYhighd, 0, memsz);; 170}; 171 ; 172 ; 173////////////////////////////////////////////////////////////////////////////////; 174/// TGraphBentErrors default destructor.; 175 ; 176TGraphBentErrors::~TGraphBentErrors(); 177{; 178 delete [] fEXlow;; 179 delete [] fEXhigh;; 180 delete [] fEYlow;; 181 delete [] fEYhigh;; 182 ; 183 delete [] fEXlowd;; 184 delete [] fEXhighd;; 185 delete [] fEYlowd;; 186 delete [] fEYhighd;; 187}; 188 ; 189////////////////////////////////////////////////////////////////////////////////; 190/// Add a point with bent errors to the graph.; 191 ; 192void TGraphBentErrors::AddPointError(Double_t x, Double_t y, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh,; 193 Double_t exld, Double_t exhd, Double_t eyld, Double_t eyhd); 194{; 195 AddPoint(x, y);; 196 SetPointError(fNpoints - 1, exl, exh, eyl, eyh, exld, exhd, eyld, eyhd);; 197}; 198 ; 199////////////////////////////////////////////////////////////////////////////////; 200/// Apply a function to all data points \f$ y = f(x,y) \f$.; 201///; 202/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 203/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$.; 204///; 205/// Special treatment has to be applied for the functions where the; 206/// role of ""up"" and ""down"" is reversed.; 207///; 208/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 209 ; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:6329,error,errors,6329,doc/master/TGraphBentErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html,1,['error'],['errors']
Availability,"1556736; // months (average # days); 1231 rangeOffset = (Double_t) ((Long_t)(timeoffset)%rangeBase);; 1232 if (range>31536000) {; 1233 tp0 = gmtime(&timetp);; 1234 tp0->tm_mon = 0;; 1235 tp0->tm_mday = 1;; 1236 tp0->tm_hour = 0;; 1237 tp0->tm_min = 0;; 1238 tp0->tm_sec = 0;; 1239 tp0->tm_isdst = 1; // daylight saving time is on.; 1240 rangeBase = (timetp-mktime(tp0)); // years; 1241 rangeOffset = (Double_t) (rangeBase);; 1242 }; 1243 wmax += rangeOffset;; 1244 wmin += rangeOffset;; 1245 }; 1246 ; 1247// Determine number of divisions 1, 2 and 3 and the maximum digits for this axis; 1248 n1a = (ndiv%100);; 1249 n2a = (ndiv%10000 - n1a)/100;; 1250 n3a = (ndiv%1000000 - n2a -n1a)/10000;; 1251 nn3 = TMath::Max(n3a,1);; 1252 nn2 = TMath::Max(n2a,1)*nn3;; 1253 nn1 = TMath::Max(n1a,1)*nn2+1;; 1254 nticks = nn1;; 1255 maxDigits = (ndiv/1000000);; 1256 if (maxDigits==0) maxDigits = gStyle->GetAxisMaxDigits();; 1257 ; 1258// Axis bining optimisation is ignored if:; 1259// - the first and the last label are equal; 1260// - the number of divisions is 0; 1261// - less than 1 primary division is requested; 1262// - logarithmic scale is requested; 1263 ; 1264 if (wmin == wmax || ndiv == 0 || n1a <= 1 || optionLog) {; 1265 optionNoopt = 1;; 1266 optionInt = 0;; 1267 }; 1268 ; 1269// Axis bining optimisation; 1270 if ( (wmax-wmin) < 1 && optionInt) {; 1271 Error(where, ""option I not available"");; 1272 optionInt = 0;; 1273 }; 1274 if (!optionNoopt || optionInt ) {; 1275 ; 1276// Primary divisions optimisation; 1277// When integer labelling is required, Optimize is invoked first; 1278// and only if the result is not an integer labelling, AdjustBinSize is invoked.; 1279 ; 1280 THLimitsFinder::Optimize(wmin,wmax,n1a,binLow,binHigh,nbins,binWidth,fChopt.Data());; 1281 if (optionInt) {; 1282 if (binLow != Double_t(int(binLow)) || binWidth != Double_t(int(binWidth))) {; 1283 AdjustBinSize(wmin,wmax,n1a,binLow,binHigh,nbins,binWidth);; 1284 }; 1285 }; 1286 if ((wmin-binLow) > epsilon) { binLo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGaxis_8cxx_source.html:44769,avail,available,44769,doc/master/TGaxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html,1,['avail'],['available']
Availability,"1574/*! \brief compute the error function; 1575 *; 1576 *; 1577 */; 1578 template <typename Container, typename ItWeight>; 1579 double Net::errorFunction (LayerData& layerData,; 1580 Container truth,; 1581 ItWeight itWeight,; 1582 ItWeight itWeightEnd,; 1583 double patternWeight,; 1584 double factorWeightDecay,; 1585 EnumRegularization eRegularization) const; 1586 {; 1587 double error (0);; 1588 switch (m_eErrorFunction); 1589 {; 1590 case ModeErrorFunction::SUMOFSQUARES:; 1591 {; 1592 error = sumOfSquares (layerData.valuesBegin (), layerData.valuesEnd (), begin (truth), end (truth),; 1593 layerData.deltasBegin (), layerData.deltasEnd (),; 1594 layerData.inverseActivationFunction (),; 1595 patternWeight);; 1596 break;; 1597 }; 1598 case ModeErrorFunction::CROSSENTROPY:; 1599 {; 1600 assert (!TMVA::DNN::isFlagSet (ModeOutputValues::DIRECT, layerData.outputMode ()));; 1601 std::vector<double> probabilities = layerData.probabilities ();; 1602 error = crossEntropy (begin (probabilities), end (probabilities),; 1603 begin (truth), end (truth),; 1604 layerData.deltasBegin (), layerData.deltasEnd (),; 1605 layerData.inverseActivationFunction (),; 1606 patternWeight);; 1607 break;; 1608 }; 1609 case ModeErrorFunction::CROSSENTROPY_MUTUALEXCLUSIVE:; 1610 {; 1611 std::cout << ""softmax."" << std::endl;; 1612 assert (!TMVA::DNN::isFlagSet (ModeOutputValues::DIRECT, layerData.outputMode ()));; 1613 std::vector<double> probabilities = layerData.probabilities ();; 1614 error = softMaxCrossEntropy (begin (probabilities), end (probabilities),; 1615 begin (truth), end (truth),; 1616 layerData.deltasBegin (), layerData.deltasEnd (),; 1617 layerData.inverseActivationFunction (),; 1618 patternWeight);; 1619 break;; 1620 }; 1621 }; 1622 if (factorWeightDecay != 0 && eRegularization != EnumRegularization::NONE); 1623 {; 1624 error = weightDecay (error, itWeight, itWeightEnd, factorWeightDecay, eRegularization);; 1625 }; 1626 return error;; 1627 }; 1628 ; 1629 ; 1630 ; 1631 ; 1632 ; 1633 ; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:53104,error,error,53104,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['error'],['error']
Availability,"157; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2906; TROOT::GetApplicationTApplication * GetApplication() constDefinition TROOT.h:209; TROOT::SetBatchvoid SetBatch(Bool_t batch=kTRUE)Set batch mode for ROOT If the argument evaluates to true, the session does not use interactive graph...Definition TROOT.cxx:2803; TROOT::fLineIsProcessingInt_t fLineIsProcessingTo synchronize multi-threads.Definition TROOT.h:100; TROOT::TimerInt_t Timer() constDefinition TROOT.h:336; TROOT::GetSourceDirstatic const TString & GetSourceDir()Get the source directory in the installation. Static utility function.Definition TROOT.cxx:3147; TROOT::GetMacroDirstatic const TString & GetMacroDir()Get the macro directory in the installation. Static utility function.Definition TROOT.cxx:3094; TROOT::fGitCommitTString fGitCommitGit commit SHA1 of built.Definition TROOT.h:120; TROOT::ProcessLineLongptr_t ProcessLine(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2370; TROOT::fClosedObjectsTSeqCollection * fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.Definition TROOT.h:145; TROOT::fTasksTSeqCollection * fTasksList of tasks.Definition TROOT.h:152; TROOT::fClipboardTSeqCollection * fClipboardList of clipboard objects.Definition TROOT.h:163; TROOT::GetGitDateconst char * GetGitDate()Return date/time make was run.Definition TROOT.cxx:2474; TROOT::GetUUIDsTProcessUUID * GetUUIDs() constDefinition TROOT.h:275; TROOT::SetEditorModevoid SetEditorMode(const char *mode="""")Set editor mode.Definition TROOT.cxx:2704; TROOT::GetListOfStreamerInfoTSeqCollection * GetListOfStreamerInfo() constDefinition TROOT.h:249; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3115; TROOT::~TROOTvirtual ~TROOT()Clean",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:39287,error,error,39287,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,1,['error'],['error']
Availability,"157; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2910; TROOT::GetApplicationTApplication * GetApplication() constDefinition TROOT.h:209; TROOT::SetBatchvoid SetBatch(Bool_t batch=kTRUE)Set batch mode for ROOT If the argument evaluates to true, the session does not use interactive graph...Definition TROOT.cxx:2803; TROOT::fLineIsProcessingInt_t fLineIsProcessingTo synchronize multi-threads.Definition TROOT.h:100; TROOT::TimerInt_t Timer() constDefinition TROOT.h:336; TROOT::GetSourceDirstatic const TString & GetSourceDir()Get the source directory in the installation. Static utility function.Definition TROOT.cxx:3151; TROOT::GetMacroDirstatic const TString & GetMacroDir()Get the macro directory in the installation. Static utility function.Definition TROOT.cxx:3098; TROOT::fGitCommitTString fGitCommitGit commit SHA1 of built.Definition TROOT.h:120; TROOT::ProcessLineLongptr_t ProcessLine(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2370; TROOT::fClosedObjectsTSeqCollection * fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.Definition TROOT.h:145; TROOT::fTasksTSeqCollection * fTasksList of tasks.Definition TROOT.h:152; TROOT::fClipboardTSeqCollection * fClipboardList of clipboard objects.Definition TROOT.h:163; TROOT::GetGitDateconst char * GetGitDate()Return date/time make was run.Definition TROOT.cxx:2474; TROOT::GetUUIDsTProcessUUID * GetUUIDs() constDefinition TROOT.h:275; TROOT::SetEditorModevoid SetEditorMode(const char *mode="""")Set editor mode.Definition TROOT.cxx:2704; TROOT::GetListOfStreamerInfoTSeqCollection * GetListOfStreamerInfo() constDefinition TROOT.h:249; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3119; TROOT::~TROOTvirtual ~TROOT()Clean",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:39286,error,error,39286,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,1,['error'],['error']
Availability,"16233 if (version_id > 0); 16234 ret |= SSL_OP_NO_SSLv2;; 16235 if (version_id > 1); 16236 ret |= SSL_OP_NO_SSLv3;; 16237 if (version_id > 2); 16238 ret |= SSL_OP_NO_TLSv1;; 16239 if (version_id > 3); 16240 ret |= SSL_OP_NO_TLSv1_1;; 16241 if (version_id > 4); 16242 ret |= SSL_OP_NO_TLSv1_2;; 16243#if defined(SSL_OP_NO_TLSv1_3); 16244 if (version_id > 5); 16245 ret |= SSL_OP_NO_TLSv1_3;; 16246#endif; 16247 return (long)ret;; 16248}; 16249#endif /* OPENSSL_API_1_1 */; 16250 ; 16251 ; 16252/* SSL callback documentation:; 16253 * https://www.openssl.org/docs/man1.1.0/ssl/SSL_set_info_callback.html; 16254 * https://wiki.openssl.org/index.php/Manual:SSL_CTX_set_info_callback(3); 16255 * https://linux.die.net/man/3/ssl_set_info_callback */; 16256/* Note: There is no ""const"" for the first argument in the documentation; 16257 * examples, however some (maybe most, but not all) headers of OpenSSL; 16258 * versions / OpenSSL compatibility layers have it. Having a different; 16259 * definition will cause a warning in C and an error in C++. Use ""const SSL; 16260 * *"", while automatical conversion from ""SSL *"" works for all compilers,; 16261 * but not other way around */; 16262static void; 16263ssl_info_callback(const SSL *ssl, int what, int ret); 16264{; 16265 (void)ret;; 16266 ; 16267 if (what & SSL_CB_HANDSHAKE_START) {; 16268 SSL_get_app_data(ssl);; 16269 }; 16270 if (what & SSL_CB_HANDSHAKE_DONE) {; 16271 /* TODO: check for openSSL 1.1 */; 16272 //#define SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS 0x0001; 16273 // ssl->s3->flags |= SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS;; 16274 }; 16275}; 16276 ; 16277 ; 16278static int; 16279ssl_servername_callback(SSL *ssl, int *ad, void *arg); 16280{; 16281#if defined(GCC_DIAGNOSTIC); 16282#pragma GCC diagnostic push; 16283#pragma GCC diagnostic ignored ""-Wcast-align""; 16284#endif /* defined(GCC_DIAGNOSTIC) */; 16285 ; 16286 /* We used an aligned pointer in SSL_set_app_data */; 16287 struct mg_connection *conn = (struct mg_connection *)SSL_get_app_data",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:480317,error,error,480317,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"16234 if (version_id > 0); 16235 ret |= SSL_OP_NO_SSLv2;; 16236 if (version_id > 1); 16237 ret |= SSL_OP_NO_SSLv3;; 16238 if (version_id > 2); 16239 ret |= SSL_OP_NO_TLSv1;; 16240 if (version_id > 3); 16241 ret |= SSL_OP_NO_TLSv1_1;; 16242 if (version_id > 4); 16243 ret |= SSL_OP_NO_TLSv1_2;; 16244#if defined(SSL_OP_NO_TLSv1_3); 16245 if (version_id > 5); 16246 ret |= SSL_OP_NO_TLSv1_3;; 16247#endif; 16248 return (long)ret;; 16249}; 16250#endif /* OPENSSL_API_1_1 */; 16251 ; 16252 ; 16253/* SSL callback documentation:; 16254 * https://www.openssl.org/docs/man1.1.0/ssl/SSL_set_info_callback.html; 16255 * https://wiki.openssl.org/index.php/Manual:SSL_CTX_set_info_callback(3); 16256 * https://linux.die.net/man/3/ssl_set_info_callback */; 16257/* Note: There is no ""const"" for the first argument in the documentation; 16258 * examples, however some (maybe most, but not all) headers of OpenSSL; 16259 * versions / OpenSSL compatibility layers have it. Having a different; 16260 * definition will cause a warning in C and an error in C++. Use ""const SSL; 16261 * *"", while automatical conversion from ""SSL *"" works for all compilers,; 16262 * but not other way around */; 16263static void; 16264ssl_info_callback(const SSL *ssl, int what, int ret); 16265{; 16266 (void)ret;; 16267 ; 16268 if (what & SSL_CB_HANDSHAKE_START) {; 16269 SSL_get_app_data(ssl);; 16270 }; 16271 if (what & SSL_CB_HANDSHAKE_DONE) {; 16272 /* TODO: check for openSSL 1.1 */; 16273 //#define SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS 0x0001; 16274 // ssl->s3->flags |= SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS;; 16275 }; 16276}; 16277 ; 16278 ; 16279static int; 16280ssl_servername_callback(SSL *ssl, int *ad, void *arg); 16281{; 16282#if defined(GCC_DIAGNOSTIC); 16283#pragma GCC diagnostic push; 16284#pragma GCC diagnostic ignored ""-Wcast-align""; 16285#endif /* defined(GCC_DIAGNOSTIC) */; 16286 ; 16287 /* We used an aligned pointer in SSL_set_app_data */; 16288 struct mg_connection *conn = (struct mg_connection *)SSL_get_app_data",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:480350,error,error,480350,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"1626 printf("" Kolmo Probabil = %f for shape alone, =%f for normalisation alone\n"",prb1,prb2);; 1627 }; 1628 // This numerical error condition should never occur:; 1629 if (TMath::Abs(rsum1-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h1=%s\n"",h1->GetName());; 1630 if (TMath::Abs(rsum2-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h2=%s\n"",h2->GetName());; 1631 ; 1632 if(opt.Contains(""M"")) return dfmax; // return average of max distance; 1633 ; 1634 return prb;; 1635}; 1636 ; 1637 ; 1638////////////////////////////////////////////////////////////////////////////////; 1639/// Rebin only the X axis; 1640/// see Rebin2D; 1641 ; 1642TH2 *TH2::RebinX(Int_t ngroup, const char *newname); 1643{; 1644 return Rebin2D(ngroup, 1, newname);; 1645}; 1646 ; 1647 ; 1648////////////////////////////////////////////////////////////////////////////////; 1649/// Rebin only the Y axis; 1650/// see Rebin2D; 1651 ; 1652TH2 *TH2::RebinY(Int_t ngroup, const char *newname); 1653{; 1654 return Rebin2D(1, ngroup, newname);; 1655}; 1656 ; 1657////////////////////////////////////////////////////////////////////////////////; 1658/// Override TH1::Rebin as TH2::RebinX; 1659/// Rebinning in variable binning as for TH1 is not allowed; 1660/// If a non-null pointer is given an error is flagged; 1661/// see RebinX and Rebin2D; 1662 ; 1663TH2 * TH2::Rebin( Int_t ngroup, const char*newname, const Double_t *xbins); 1664{; 1665 if (xbins != nullptr) {; 1666 Error(""Rebin"",""Rebinning a 2-d histogram into variable bins is not supported (it is possible only for 1-d histograms). Return a nullptr"");; 1667 return nullptr;; 1668 }; 1669 Info(""Rebin"",""Rebinning only the x-axis. Use Rebin2D for rebinning both axes"");; 1670 return RebinX(ngroup, newname);; 1671}; 1672////////////////////////////////////////////////////////////////////////////////; 1673/// Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.; 1674///; 1675/// if newname is not blank a new te",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:66378,error,error,66378,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['error'],['error']
Availability,"1641 fU[ke2-1] = u2min;; 1642 goto L2000;; 1643// Error returns; 1644L1350:; 1645 Printf("" INVALID PARAMETER NUMBERS."");; 1646 goto L1450;; 1647L1400:; 1648 Printf("" LESS THAN FOUR POINTS REQUESTED."");; 1649L1450:; 1650 ierrf = -1;; 1651 fCstatu = ""USER ERROR"";; 1652 goto L2000;; 1653L1500:; 1654 Printf("" MNCONT UNABLE TO FIND FOUR POINTS."");; 1655 fU[ke1-1] = u1min;; 1656 fU[ke2-1] = u2min;; 1657 ierrf = 0;; 1658 fCstatu = ""FAILED"";; 1659L2000:; 1660 fCfrom = ""MNContour "";; 1661 fNfcnfr = nfcnco;; 1662}; 1663 ; 1664////////////////////////////////////////////////////////////////////////////////; 1665/// Cracks the free-format input; 1666///; 1667/// Cracks the free-format input, expecting zero or more; 1668/// alphanumeric fields (which it joins into COMAND(1:LNC)); 1669/// followed by one or more numeric fields separated by; 1670/// blanks and/or one comma. The numeric fields are put into; 1671/// the LLIST (but at most MXP) elements of PLIST.; 1672///; 1673/// IERR :; 1674/// - = 0 if no errors,; 1675/// - = 1 if error(s).; 1676 ; 1677void TMinuit::mncrck(TString cardbuf, Int_t maxcwd, TString &comand, Int_t &lnc,; 1678 Int_t mxp, Double_t *plist, Int_t &llist, Int_t &ierr, Int_t); 1679{; 1680 /* Initialized data */; 1681 ; 1682 char *cnull = nullptr;; 1683 const char *cnumer = ""123456789-.0+"";; 1684 ; 1685 /* Local variables */; 1686 Int_t ifld, iend, lend, left, nreq, ipos, kcmnd, nextb, ic, ibegin, ltoadd;; 1687 Int_t ielmnt, lelmnt[25], nelmnt;; 1688 TString ctemp;; 1689 char *celmnt[25];; 1690 char command[25];; 1691 ; 1692 /* Function Body */; 1693 char *crdbuf = (char*)cardbuf.Data();; 1694 lend = cardbuf.Length();; 1695 ielmnt = 0;; 1696 nextb = 1;; 1697 ierr = 0;; 1698// loop over words CELMNT; 1699L10:; 1700 for (ipos = nextb; ipos <= lend; ++ipos) {; 1701 ibegin = ipos;; 1702 if (crdbuf[ipos-1] == ' ') continue;; 1703 if (crdbuf[ipos-1] == ',') goto L250;; 1704 goto L150;; 1705 }; 1706 goto L300;; 1707L150:; 1708// found beginning of word, look for end",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:56796,error,errors,56796,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"16451static int; 16452init_ssl_ctx_impl(struct mg_context *phys_ctx,; 16453 struct mg_domain_context *dom_ctx,; 16454 const char *pem,; 16455 const char *chain); 16456{; 16457 int callback_ret;; 16458 int should_verify_peer;; 16459 int peer_certificate_optional;; 16460 const char *ca_path;; 16461 const char *ca_file;; 16462 int use_default_verify_paths;; 16463 int verify_depth;; 16464 struct timespec now_mt;; 16465 md5_byte_t ssl_context_id[16];; 16466 md5_state_t md5state;; 16467 int protocol_ver;; 16468 int ssl_cache_timeout;; 16469 ; 16470#if (defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0)) \; 16471 && !defined(NO_SSL_DL); 16472 if ((dom_ctx->ssl_ctx = SSL_CTX_new(TLS_server_method())) == NULL) {; 16473 mg_cry_ctx_internal(phys_ctx,; 16474 ""SSL_CTX_new (server) error: %s"",; 16475 ssl_error());; 16476 return 0;; 16477 }; 16478#else; 16479 if ((dom_ctx->ssl_ctx = SSL_CTX_new(SSLv23_server_method())) == NULL) {; 16480 mg_cry_ctx_internal(phys_ctx,; 16481 ""SSL_CTX_new (server) error: %s"",; 16482 ssl_error());; 16483 return 0;; 16484 }; 16485#endif /* OPENSSL_API_1_1 || OPENSSL_API_3_0 */; 16486 ; 16487#if defined(SSL_OP_NO_TLSv1_3); 16488 SSL_CTX_clear_options(dom_ctx->ssl_ctx,; 16489 SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1; 16490 | SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_2; 16491 | SSL_OP_NO_TLSv1_3);; 16492#else; 16493 SSL_CTX_clear_options(dom_ctx->ssl_ctx,; 16494 SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1; 16495 | SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_2);; 16496#endif; 16497 ; 16498 protocol_ver = atoi(dom_ctx->config[SSL_PROTOCOL_VERSION]);; 16499 SSL_CTX_set_options(dom_ctx->ssl_ctx, ssl_get_protocol(protocol_ver));; 16500 SSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_SINGLE_DH_USE);; 16501 SSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);; 16502 SSL_CTX_set_options(dom_ctx->ssl_ctx,; 16503 SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);; 16504 SSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_NO_COMPRESSION);; 16505 ; 16506",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:487413,error,error,487413,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"16452static int; 16453init_ssl_ctx_impl(struct mg_context *phys_ctx,; 16454 struct mg_domain_context *dom_ctx,; 16455 const char *pem,; 16456 const char *chain); 16457{; 16458 int callback_ret;; 16459 int should_verify_peer;; 16460 int peer_certificate_optional;; 16461 const char *ca_path;; 16462 const char *ca_file;; 16463 int use_default_verify_paths;; 16464 int verify_depth;; 16465 struct timespec now_mt;; 16466 md5_byte_t ssl_context_id[16];; 16467 md5_state_t md5state;; 16468 int protocol_ver;; 16469 int ssl_cache_timeout;; 16470 ; 16471#if (defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0)) \; 16472 && !defined(NO_SSL_DL); 16473 if ((dom_ctx->ssl_ctx = SSL_CTX_new(TLS_server_method())) == NULL) {; 16474 mg_cry_ctx_internal(phys_ctx,; 16475 ""SSL_CTX_new (server) error: %s"",; 16476 ssl_error());; 16477 return 0;; 16478 }; 16479#else; 16480 if ((dom_ctx->ssl_ctx = SSL_CTX_new(SSLv23_server_method())) == NULL) {; 16481 mg_cry_ctx_internal(phys_ctx,; 16482 ""SSL_CTX_new (server) error: %s"",; 16483 ssl_error());; 16484 return 0;; 16485 }; 16486#endif /* OPENSSL_API_1_1 || OPENSSL_API_3_0 */; 16487 ; 16488#if defined(SSL_OP_NO_TLSv1_3); 16489 SSL_CTX_clear_options(dom_ctx->ssl_ctx,; 16490 SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1; 16491 | SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_2; 16492 | SSL_OP_NO_TLSv1_3);; 16493#else; 16494 SSL_CTX_clear_options(dom_ctx->ssl_ctx,; 16495 SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1; 16496 | SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_2);; 16497#endif; 16498 ; 16499 protocol_ver = atoi(dom_ctx->config[SSL_PROTOCOL_VERSION]);; 16500 SSL_CTX_set_options(dom_ctx->ssl_ctx, ssl_get_protocol(protocol_ver));; 16501 SSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_SINGLE_DH_USE);; 16502 SSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);; 16503 SSL_CTX_set_options(dom_ctx->ssl_ctx,; 16504 SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);; 16505 SSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_NO_COMPRESSION);; 16506 ; 16507",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:487446,error,error,487446,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"1660 TSystem *helper = FindHelper(path);; 1661 if (helper); 1662 return helper->GetPathInfo(path, buf);; 1663 ; 1664 return UnixFilestat(path, buf);; 1665}; 1666 ; 1667////////////////////////////////////////////////////////////////////////////////; 1668/// Get info about a file system: id, bsize, bfree, blocks.; 1669/// Id is file system type (machine dependend, see statfs()); 1670/// Bsize is block size of file system; 1671/// Blocks is total number of blocks in file system; 1672/// Bfree is number of free blocks in file system; 1673/// The function returns 0 in case of success and 1 if the file system could; 1674/// not be stat'ed.; 1675 ; 1676int TUnixSystem::GetFsInfo(const char *path, Long_t *id, Long_t *bsize,; 1677 Long_t *blocks, Long_t *bfree); 1678{; 1679 return UnixFSstat(path, id, bsize, blocks, bfree);; 1680}; 1681 ; 1682////////////////////////////////////////////////////////////////////////////////; 1683/// Create a link from file1 to file2. Returns 0 when successful,; 1684/// -1 in case of failure.; 1685 ; 1686int TUnixSystem::Link(const char *from, const char *to); 1687{; 1688 return ::link(from, to);; 1689}; 1690 ; 1691////////////////////////////////////////////////////////////////////////////////; 1692/// Create a symlink from file1 to file2. Returns 0 when successful,; 1693/// -1 in case of failure.; 1694 ; 1695int TUnixSystem::Symlink(const char *from, const char *to); 1696{; 1697#if defined(R__AIX); 1698 return ::symlink((char*)from, (char*)to);; 1699#else; 1700 return ::symlink(from, to);; 1701#endif; 1702}; 1703 ; 1704////////////////////////////////////////////////////////////////////////////////; 1705/// Unlink, i.e. remove, a file or directory. Returns 0 when successful,; 1706/// -1 in case of failure.; 1707 ; 1708int TUnixSystem::Unlink(const char *name); 1709{; 1710 TSystem *helper = FindHelper(name);; 1711 if (helper); 1712 return helper->Unlink(name);; 1713 ; 1714#if defined(R__SEEK64); 1715 struct stat64 finfo;; 1716 if (lstat64(name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:51938,failure,failure,51938,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['failure'],['failure']
Availability,"1737 return 0;; 1738 }; 1739 ; 1740 if (sync); 1741 return gInterpreter->ProcessLineSynch(line, (TInterpreter::EErrorCode*)err);; 1742 else; 1743 return gInterpreter->ProcessLine(line, (TInterpreter::EErrorCode*)err);; 1744}; 1745 ; 1746////////////////////////////////////////////////////////////////////////////////; 1747/// Process a file containing a C++ macro.; 1748 ; 1749Longptr_t TApplication::ProcessFile(const char *file, Int_t *error, Bool_t keep); 1750{; 1751 return ExecuteFile(file, error, keep);; 1752}; 1753 ; 1754////////////////////////////////////////////////////////////////////////////////; 1755/// Execute a file containing a C++ macro (static method). Can be used; 1756/// while TApplication is not yet created.; 1757 ; 1758Longptr_t TApplication::ExecuteFile(const char *file, Int_t *error, Bool_t keep); 1759{; 1760 static const Int_t kBufSize = 1024;; 1761 ; 1762 if (!file || !*file) return 0;; 1763 ; 1764 TString aclicMode;; 1765 TString arguments;; 1766 TString io;; 1767 TString fname = gSystem->SplitAclicMode(file, aclicMode, arguments, io);; 1768 ; 1769 char *exnam = gSystem->Which(TROOT::GetMacroPath(), fname, kReadPermission);; 1770 if (!exnam) {; 1771 ::Error(""TApplication::ExecuteFile"", ""macro %s not found in path %s"", fname.Data(),; 1772 TROOT::GetMacroPath());; 1773 delete [] exnam;; 1774 if (error); 1775 *error = (Int_t)TInterpreter::kRecoverable;; 1776 return 0;; 1777 }; 1778 ; 1779 ::std::ifstream macro(exnam, std::ios::in);; 1780 if (!macro.good()) {; 1781 ::Error(""TApplication::ExecuteFile"", ""%s no such file"", exnam);; 1782 if (error); 1783 *error = (Int_t)TInterpreter::kRecoverable;; 1784 delete [] exnam;; 1785 return 0;; 1786 }; 1787 ; 1788 char currentline[kBufSize];; 1789 char dummyline[kBufSize];; 1790 int tempfile = 0;; 1791 int comment = 0;; 1792 int ifndefc = 0;; 1793 int ifdef = 0;; 1794 char *s = nullptr;; 1795 Bool_t execute = kFALSE;; 1796 Longptr_t retval = 0;; 1797 ; 1798 while (1) {; 1799 bool res = (bool)macro.getline(curr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:68316,error,error,68316,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['error'],['error']
Availability,"174 /// \brief Register systematic variations for multiple existing columns using custom variation tags.; 1175 /// \param[in] colNames set of names of the columns for which varied values are provided.; 1176 /// \param[in] expression a string containing valid C++ code that evaluates to an RVec or RVecs containing the varied; 1177 /// values for the specified columns.; 1178 /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; 1179 /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; 1180 ///; 1181 /// This overload adds the possibility for the expression used to evaluate the varied values to be just-in-time; 1182 /// compiled. The example below shows how Vary() is used while dealing with multiple columns. The tags are defined as; 1183 /// `{""down"", ""up""}`.; 1184 /// ~~~{.cpp}; 1185 /// auto nominal_hx =; 1186 /// df.Vary({""x"", ""y""}, ""ROOT::RVec<ROOT::RVecD>{{x*0.9, x*1.1}, {y*0.9, y*1.1}}"", {""down"", ""up""}, ""xy""); 1187 /// .Histo1D(""x"", ""y"");; 1188 ///; 1189 /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; 1190 /// hx[""nominal""].Draw();; 1191 /// hx[""xy:down""].Draw(""SAME"");; 1192 /// hx[""xy:up""].Draw(""SAME"");; 1193 /// ~~~; 1194 ///; 1195 /// \sa This Vary() overload for more information.; 1196 RInterface<Proxied, DS_t> Vary(const std::vector<std::string> &colNames, std::string_view expression,; 1197 const std::vector<std::string> &variationTags, std::string_view variationName); 1198 {; 1199 return JittedVaryImpl(colNames, expression, variationTags, variationName, /*isSingleColumn=*/false);; 1200 }; 1201 ; 1202 ////////////////////////////////////////////////////////////////////////////; 1203 /// \brief Allow to refer to a column with a different name.; 1204 /// \param[in] alias name of the column alias; 1205 /// \param[in] columnName of the column to be aliased; 1206 /// \return the first node of the computation graph for which the alias is available.; 1207 ///; 1208 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:65120,down,down,65120,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['down'],['down']
Availability,175543 43692.5 5; : 933 Minimum Test error found - save the configuration ; : 933 | 4.07608 6.08713 0.0202588 0.00184594 43447.8 0; : 934 | 4.3998 6.10426 0.0204691 0.00178412 42815.1 1; : 935 | 4.23034 6.39854 0.0202977 0.00176426 43165.2 2; : 936 Minimum Test error found - save the configuration ; : 936 | 4.45077 5.93539 0.020128 0.0018336 43729.3 0; : 937 | 4.31583 6.35935 0.0203501 0.00176302 43040.6 1; : 938 Minimum Test error found - save the configuration ; : 938 | 4.1293 5.8271 0.0205749 0.0018749 42780.8 0; : 939 Minimum Test error found - save the configuration ; : 939 | 4.02273 5.7049 0.0206164 0.00186577 42665.2 0; : 940 | 3.91188 6.29174 0.0201055 0.00180854 43723.1 1; : 941 | 3.89757 5.80965 0.0203179 0.00179759 43195.8 2; : 942 | 3.94904 5.73464 0.0200877 0.00175468 43637.1 3; : 943 | 3.90362 5.73888 0.0200954 0.00175028 43608.4 4; : 944 | 3.87035 5.70718 0.0200345 0.0017513 43756.1 5; : 945 | 4.07017 5.95519 0.020321 0.00177709 43140.8 6; : 946 Minimum Test error found - save the configuration ; : 946 | 4.03451 5.59581 0.0201405 0.00182817 43686.3 0; : 947 | 3.85593 5.66203 0.0200425 0.00175434 43744.1 1; : 948 Minimum Test error found - save the configuration ; : 948 | 3.86683 5.35682 0.0204778 0.00185498 42958.2 0; : 949 Minimum Test error found - save the configuration ; : 949 | 3.68334 5.31467 0.0201988 0.00181717 43521.8 0; : 950 | 3.73312 5.52286 0.0201437 0.00175576 43506.8 1; : 951 | 3.85908 5.35112 0.0203536 0.00178284 43078.6 2; : 952 | 3.97296 5.91801 0.0201499 0.00177356 43534.3 3; : 953 Minimum Test error found - save the configuration ; : 953 | 3.78482 5.22353 0.0202416 0.0018489 43495.5 0; : 954 | 3.77661 6.79704 0.0200822 0.00176597 43677.1 1; : 955 | 4.26211 5.70833 0.020048 0.0017647 43755.8 2; : 956 | 3.83703 5.25865 0.0200643 0.00176603 43720 3; : 957 Minimum Test error found - save the configuration ; : 957 | 3.70429 5.19606 0.0204948 0.00189018 43000 0; : 958 | 3.80095 5.43788 0.0203069 0.00176137 43137.1 1; : 959 Minimum Test er,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:109400,error,error,109400,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,175638 42972.7 1; : 880 | 5.71571 8.37499 0.0201251 0.00178041 43609.3 2; : 881 | 5.7556 8.5037 0.0200424 0.00175411 43743.8 3; : 882 | 5.47815 8.64255 0.0200508 0.00175977 43737.3 4; : 883 | 5.49484 8.19099 0.0201663 0.00175135 43443 5; : 884 Minimum Test error found - save the configuration ; : 884 | 5.44144 8.14796 0.020157 0.00182376 43636.7 0; : 885 | 5.72885 9.21369 0.0207466 0.00176462 42145.2 1; : 886 | 5.67418 8.64993 0.0200759 0.00176094 43680.2 2; : 887 Minimum Test error found - save the configuration ; : 887 | 5.55202 8.05484 0.0201465 0.00184145 43703.7 0; : 888 Minimum Test error found - save the configuration ; : 888 | 5.4009 7.86368 0.0201494 0.00184759 43711.4 0; : 889 | 5.09006 7.93881 0.0200766 0.00176618 43691 1; : 890 | 5.16257 8.05551 0.0200625 0.00176866 43730.7 2; : 891 Minimum Test error found - save the configuration ; : 891 | 5.07326 7.82028 0.0201532 0.0018382 43680.1 0; : 892 | 5.14088 7.89491 0.0200852 0.00179174 43731.4 1; : 893 Minimum Test error found - save the configuration ; : 893 | 5.13302 7.67646 0.0201541 0.00183919 43680.3 0; : 894 | 5.44229 7.83993 0.0200562 0.00176505 43736.9 1; : 895 | 5.40474 8.2327 0.0200223 0.00176151 43809.8 2; : 896 Minimum Test error found - save the configuration ; : 896 | 5.30823 7.62628 0.0201123 0.00182273 43740.8 0; : 897 | 6.20081 8.04326 0.0200652 0.00176931 43725.7 1; : 898 | 5.99101 8.0649 0.0200274 0.00175928 43792 2; : 899 Minimum Test error found - save the configuration ; : 899 | 5.1416 7.3348 0.0201215 0.00182199 43717.1 0; : 900 | 4.88699 7.46821 0.0200416 0.0017612 43762.6 1; : 901 Minimum Test error found - save the configuration ; : 901 | 4.92918 7.2702 0.0200754 0.00181642 43814.2 0; : 902 Minimum Test error found - save the configuration ; : 902 | 5.04871 7.17895 0.0200791 0.00180807 43785.1 0; : 903 | 4.88551 7.21813 0.0200213 0.00174992 43784.3 1; : 904 | 4.98683 7.44507 0.0200553 0.00174858 43699.9 2; : 905 | 4.82992 7.45009 0.0202406 0.00175807 43284.1 3; : 906 | 4.86112 7.7864,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:105480,error,error,105480,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,175682 43766.4 2; : 915 Minimum Test error found - save the configuration ; : 915 | 4.5624 6.6787 0.0201058 0.0018145 43736.7 0; : 916 Minimum Test error found - save the configuration ; : 916 | 4.49553 6.65717 0.0201015 0.00180949 43734.9 0; : 917 Minimum Test error found - save the configuration ; : 917 | 4.36563 6.60613 0.0201007 0.00181415 43748 0; : 918 Minimum Test error found - save the configuration ; : 918 | 4.47049 6.3479 0.0200865 0.00182018 43796.4 0; : 919 | 4.35846 6.60136 0.0200632 0.00176343 43716.3 1; : 920 | 4.30933 6.53557 0.0200239 0.00175965 43801.4 2; : 921 Minimum Test error found - save the configuration ; : 921 | 4.32266 6.29119 0.0200952 0.00182605 43789.5 0; : 922 | 4.32742 6.39561 0.0200257 0.00176292 43804.9 1; : 923 | 4.33774 6.46608 0.0200201 0.00176071 43813 2; : 924 | 4.36503 6.3111 0.0200702 0.00177545 43728.3 3; : 925 | 4.7314 7.24632 0.0202093 0.00176259 43368.2 4; : 926 | 4.61316 6.64099 0.020249 0.00181216 43391.3 5; : 927 Minimum Test error found - save the configuration ; : 927 | 4.41727 6.09792 0.0203192 0.00184107 43294.4 0; : 928 | 4.15393 6.23618 0.0200677 0.00177036 43722.3 1; : 929 | 4.2848 6.29195 0.0202769 0.00175908 43201.6 2; : 930 | 4.39879 6.60248 0.0204218 0.00176177 42872.3 3; : 931 | 4.17549 6.55946 0.0200581 0.00175886 43717.6 4; : 932 | 4.18849 6.67063 0.0200652 0.00175543 43692.5 5; : 933 Minimum Test error found - save the configuration ; : 933 | 4.07608 6.08713 0.0202588 0.00184594 43447.8 0; : 934 | 4.3998 6.10426 0.0204691 0.00178412 42815.1 1; : 935 | 4.23034 6.39854 0.0202977 0.00176426 43165.2 2; : 936 Minimum Test error found - save the configuration ; : 936 | 4.45077 5.93539 0.020128 0.0018336 43729.3 0; : 937 | 4.31583 6.35935 0.0203501 0.00176302 43040.6 1; : 938 Minimum Test error found - save the configuration ; : 938 | 4.1293 5.8271 0.0205749 0.0018749 42780.8 0; : 939 Minimum Test error found - save the configuration ; : 939 | 4.02273 5.7049 0.0206164 0.00186577 42665.2 0; : 940 | 3.91188 6.2917,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:108056,error,error,108056,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,175791 43723.2 2; : 797 | 11.12 15.292 0.0200628 0.00175972 43708.5 3; : 798 | 10.8935 14.9786 0.0200585 0.0017545 43706.3 4; : 799 Minimum Test error found - save the configuration ; : 799 | 10.7942 14.6749 0.0201633 0.00182171 43616.6 0; : 800 Minimum Test error found - save the configuration ; : 800 | 10.3317 14.1583 0.0201165 0.00182126 43727.2 0; : 801 | 10.3503 14.2866 0.0200523 0.00175781 43729 1; : 802 | 10.3453 15.2815 0.0200406 0.00175563 43751.8 2; : 803 | 10.2123 14.6873 0.0200478 0.00175638 43736.3 3; : 804 | 10.1133 14.2109 0.0201368 0.00176313 43540.5 4; : 805 Minimum Test error found - save the configuration ; : 805 | 10.3447 13.9911 0.0201319 0.00182751 43705.3 0; : 806 | 10.3558 15.0191 0.0200537 0.00175652 43722.7 1; : 807 Minimum Test error found - save the configuration ; : 807 | 9.87362 13.4104 0.0202002 0.0018848 43679 0; : 808 | 9.75883 13.5009 0.0202529 0.00175832 43255.9 1; : 809 | 9.54989 13.8103 0.0201225 0.00175709 43560.3 2; : 810 Minimum Test error found - save the configuration ; : 810 | 9.43647 13.1509 0.0201534 0.00182442 43646.8 0; : 811 | 9.40272 13.8504 0.0200559 0.00175676 43717.9 1; : 812 Minimum Test error found - save the configuration ; : 812 | 9.42328 13.0239 0.0202708 0.00183859 43402.3 0; : 813 | 9.26754 13.347 0.0200488 0.00175838 43738.7 1; : 814 | 9.30693 13.2737 0.0200298 0.0017551 43776.4 2; : 815 | 9.2453 13.4411 0.0200383 0.0017608 43769.8 3; : 816 Minimum Test error found - save the configuration ; : 816 | 8.97729 12.8621 0.0200894 0.00181862 43785.8 0; : 817 | 9.05512 13.256 0.0200147 0.0017603 43825 1; : 818 Minimum Test error found - save the configuration ; : 818 | 8.88115 12.6122 0.0201221 0.00182968 43733.9 0; : 819 | 8.6338 13.2547 0.0200872 0.00177159 43678.6 1; : 820 Minimum Test error found - save the configuration ; : 820 | 8.87738 12.3889 0.0200904 0.00182003 43786.8 0; : 821 Minimum Test error found - save the configuration ; : 821 | 8.4572 12.2134 0.0200973 0.00182161 43774.1 0; : 822 | 8.40042 12.784,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:99132,error,error,99132,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,175856 43509.3 2; : 837 | 7.98319 11.3225 0.0201169 0.00175643 43571.8 3; : 838 | 7.66699 11.6657 0.0201662 0.00181142 43585.5 4; : 839 Minimum Test error found - save the configuration ; : 839 | 7.52525 10.9666 0.0202646 0.00182844 43392.9 0; : 840 | 7.48548 11.313 0.020051 0.00174873 43710.5 1; : 841 | 7.28024 11.1847 0.0200374 0.0017493 43744.4 2; : 842 | 7.18939 11.0082 0.0200397 0.00175322 43748.2 3; : 843 Minimum Test error found - save the configuration ; : 843 | 7.01613 10.4197 0.0201334 0.00182993 43707.5 0; : 844 | 6.83302 10.8151 0.020039 0.00176037 43767.1 1; : 845 | 6.97518 10.5462 0.0200409 0.00175987 43761.2 2; : 846 | 6.93317 10.5904 0.0200239 0.00176026 43802.8 3; : 847 | 6.86223 10.6492 0.0200268 0.00176058 43796.8 4; : 848 | 7.00201 10.9279 0.0200258 0.00175939 43796.3 5; : 849 | 6.9266 10.4735 0.0200333 0.00176264 43785.9 6; : 850 | 6.72856 10.6877 0.0200521 0.00176189 43739.2 7; : 851 | 6.84236 10.8522 0.0200238 0.00176009 43802.7 8; : 852 Minimum Test error found - save the configuration ; : 852 | 6.78011 10.0733 0.0201111 0.00182524 43749.6 0; : 853 Minimum Test error found - save the configuration ; : 853 | 6.53284 9.90736 0.0201187 0.00181829 43714.8 0; : 854 | 6.67108 10.0768 0.0205443 0.0017732 42618.8 1; : 855 | 6.58878 10.7427 0.0200637 0.00176264 43713.2 2; : 856 | 6.54513 10.3387 0.0200413 0.00176141 43764 3; : 857 Minimum Test error found - save the configuration ; : 857 | 6.43616 9.72218 0.020097 0.00182688 43787.4 0; : 858 | 6.34936 10.0458 0.0200349 0.00176193 43780.5 1; : 859 Minimum Test error found - save the configuration ; : 859 | 6.20554 9.48603 0.0201607 0.00183833 43662.6 0; : 860 | 6.16695 10.0812 0.0200598 0.00175295 43699.5 1; : 861 Minimum Test error found - save the configuration ; : 861 | 6.43224 9.42041 0.0201492 0.00182399 43655.7 0; : 862 | 6.08067 10.0276 0.0200725 0.0017577 43680.5 1; : 863 | 6.34296 10.0575 0.0200642 0.00175521 43694.5 2; : 864 Minimum Test error found - save the configuration ; : 864 | 6.33486 9,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:102274,error,error,102274,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,17637 43526.7 2; : 709 Minimum Test error found - save the configuration ; : 709 | 29.434 28.2 0.0201313 0.00182437 43699.3 0; : 710 | 28.7076 28.492 0.0200557 0.00176519 43738.5 1; : 711 Minimum Test error found - save the configuration ; : 711 | 28.4018 27.2754 0.0201013 0.00182194 43765.3 0; : 712 | 28.1436 28.1139 0.020041 0.00175734 43754.9 1; : 713 | 27.878 27.4183 0.0200281 0.0017564 43783.5 2; : 714 | 27.4734 27.8632 0.020054 0.00175612 43720.8 3; : 715 Minimum Test error found - save the configuration ; : 715 | 27.1251 26.6487 0.0201232 0.0018277 43726.6 0; : 716 | 26.6302 26.7712 0.0200343 0.00176196 43782.1 1; : 717 Minimum Test error found - save the configuration ; : 717 | 26.542 26.4691 0.020103 0.00182338 43764.7 0; : 718 Minimum Test error found - save the configuration ; : 718 | 25.9613 26.206 0.0200958 0.00181915 43771.6 0; : 719 Minimum Test error found - save the configuration ; : 719 | 25.6965 25.7845 0.0200932 0.00181887 43777.1 0; : 720 Minimum Test error found - save the configuration ; : 720 | 25.279 25.7029 0.0200856 0.00181582 43788.1 0; : 721 | 24.9296 25.8529 0.0200326 0.00176051 43782.6 1; : 722 | 24.8179 25.9725 0.0200485 0.0017542 43729.4 2; : 723 Minimum Test error found - save the configuration ; : 723 | 24.602 25.0488 0.0200826 0.00181241 43787.1 0; : 724 Minimum Test error found - save the configuration ; : 724 | 24.1724 25.032 0.0200931 0.00180717 43749.4 0; : 725 Minimum Test error found - save the configuration ; : 725 | 23.8272 24.7604 0.0201019 0.00180745 43729.1 0; : 726 Minimum Test error found - save the configuration ; : 726 | 23.3507 24.439 0.0200878 0.00180894 43766.5 0; : 727 | 23.4129 26.1943 0.0200349 0.00176004 43776.1 1; : 728 Minimum Test error found - save the configuration ; : 728 | 23.0149 24.223 0.0201139 0.00181842 43726.6 0; : 729 Minimum Test error found - save the configuration ; : 729 | 22.6778 23.9945 0.0201044 0.00181062 43730.7 0; : 730 | 22.455 23.9981 0.020057 0.0017578 43717.8 1; : 731 Minimum Test ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:91015,error,error,91015,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,176618 43691 1; : 890 | 5.16257 8.05551 0.0200625 0.00176866 43730.7 2; : 891 Minimum Test error found - save the configuration ; : 891 | 5.07326 7.82028 0.0201532 0.0018382 43680.1 0; : 892 | 5.14088 7.89491 0.0200852 0.00179174 43731.4 1; : 893 Minimum Test error found - save the configuration ; : 893 | 5.13302 7.67646 0.0201541 0.00183919 43680.3 0; : 894 | 5.44229 7.83993 0.0200562 0.00176505 43736.9 1; : 895 | 5.40474 8.2327 0.0200223 0.00176151 43809.8 2; : 896 Minimum Test error found - save the configuration ; : 896 | 5.30823 7.62628 0.0201123 0.00182273 43740.8 0; : 897 | 6.20081 8.04326 0.0200652 0.00176931 43725.7 1; : 898 | 5.99101 8.0649 0.0200274 0.00175928 43792 2; : 899 Minimum Test error found - save the configuration ; : 899 | 5.1416 7.3348 0.0201215 0.00182199 43717.1 0; : 900 | 4.88699 7.46821 0.0200416 0.0017612 43762.6 1; : 901 Minimum Test error found - save the configuration ; : 901 | 4.92918 7.2702 0.0200754 0.00181642 43814.2 0; : 902 Minimum Test error found - save the configuration ; : 902 | 5.04871 7.17895 0.0200791 0.00180807 43785.1 0; : 903 | 4.88551 7.21813 0.0200213 0.00174992 43784.3 1; : 904 | 4.98683 7.44507 0.0200553 0.00174858 43699.9 2; : 905 | 4.82992 7.45009 0.0202406 0.00175807 43284.1 3; : 906 | 4.86112 7.78644 0.0202162 0.00175457 43333 4; : 907 Minimum Test error found - save the configuration ; : 907 | 4.76534 7.04169 0.0202678 0.00183052 43390.4 0; : 908 | 4.77659 7.36078 0.0201903 0.00174867 43380.2 1; : 909 | 5.40526 9.09975 0.0204121 0.00175613 42881.7 2; : 910 | 5.23108 7.3695 0.0200572 0.0017555 43711.7 3; : 911 | 4.9718 7.21676 0.0200739 0.00175828 43678.5 4; : 912 Minimum Test error found - save the configuration ; : 912 | 4.64478 6.77041 0.0201181 0.00182552 43733.5 0; : 913 | 4.96617 7.29752 0.0200675 0.00175608 43688.5 1; : 914 | 4.79524 7.25946 0.0200357 0.00175682 43766.4 2; : 915 Minimum Test error found - save the configuration ; : 915 | 4.5624 6.6787 0.0201058 0.0018145 43736.7 0; : 916 Minimum Test error,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:106208,error,error,106208,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"1791 SysError(""ReadBuffer"", ""error reading from file %s"", GetName());; 1792 return kTRUE;; 1793 }; 1794 if (siz != len) {; 1795 Error(""ReadBuffer"", ""error reading all requested bytes from file %s, got %ld of %d"",; 1796 GetName(), (Long_t)siz, len);; 1797 return kTRUE;; 1798 }; 1799 fBytesRead += siz;; 1800 fgBytesRead += siz;; 1801 fReadCalls++;; 1802 fgReadCalls++;; 1803 ; 1804 if (gMonitoringWriter); 1805 gMonitoringWriter->SendFileReadProgress(this);; 1806 if (gPerfStats) {; 1807 gPerfStats->FileReadEvent(this, len, start);; 1808 }; 1809 return kFALSE;; 1810 }; 1811 return kTRUE;; 1812}; 1813 ; 1814////////////////////////////////////////////////////////////////////////////////; 1815/// Read the nbuf blocks described in arrays pos and len.; 1816///; 1817/// The value pos[i] is the seek position of block i of length len[i].; 1818/// Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; 1819/// This function is overloaded by TNetFile, TWebFile, etc.; 1820/// Returns kTRUE in case of failure.; 1821 ; 1822Bool_t TFile::ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf); 1823{; 1824 // called with buf=0, from TFileCacheRead to pass list of readahead buffers; 1825 if (!buf) {; 1826 for (Int_t j = 0; j < nbuf; j++) {; 1827 if (ReadBufferAsync(pos[j], len[j])) {; 1828 return kTRUE;; 1829 }; 1830 }; 1831 return kFALSE;; 1832 }; 1833 ; 1834 Int_t k = 0;; 1835 Bool_t result = kTRUE;; 1836 TFileCacheRead *old = fCacheRead;; 1837 fCacheRead = nullptr;; 1838 Long64_t curbegin = pos[0];; 1839 Long64_t cur;; 1840 char *buf2 = nullptr;; 1841 Int_t i = 0, n = 0;; 1842 while (i < nbuf) {; 1843 cur = pos[i]+len[i];; 1844 Bool_t bigRead = kTRUE;; 1845 if (cur -curbegin < fgReadaheadSize) {n++; i++; bigRead = kFALSE;}; 1846 if (bigRead || (i>=nbuf)) {; 1847 if (n == 0) {; 1848 //if the block to read is about the same size as the read-ahead buffer; 1849 //we read the block directly; 1850 Seek(pos[i]);; 1851 result = ReadBuffer(&buf[k], len[i]);; 1852 if (result",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:65798,failure,failure,65798,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['failure'],['failure']
Availability,"18#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L; 119#define mg_static_assert _Static_assert; 120#elif defined(__cplusplus) && __cplusplus >= 201103L; 121#define mg_static_assert static_assert; 122#else; 123char static_assert_replacement[1];; 124#define mg_static_assert(cond, txt) \; 125 extern char static_assert_replacement[(cond) ? 1 : -1]; 126#endif; 127 ; 128mg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,; 129 ""int data type size check"");; 130mg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:5751,avail,available,5751,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['avail'],['available']
Availability,181141 43797.6 0; : 769 Minimum Test error found - save the configuration ; : 769 | 14.3366 17.8635 0.0200909 0.00180773 43756.2 0; : 770 Minimum Test error found - save the configuration ; : 770 | 14.5733 17.5465 0.0200968 0.00180191 43728 0; : 771 | 13.9827 17.8429 0.0200367 0.0017469 43740.1 1; : 772 Minimum Test error found - save the configuration ; : 772 | 14.2497 17.3556 0.0201068 0.00181254 43729.6 0; : 773 | 14.0413 17.7428 0.020033 0.00175319 43764.2 1; : 774 Minimum Test error found - save the configuration ; : 774 | 13.9671 16.982 0.020108 0.00180715 43713.8 0; : 775 | 13.7965 17.224 0.0200334 0.0017548 43767 1; : 776 | 13.601 17.9652 0.0200139 0.00175385 43811.5 2; : 777 | 14.0445 17.0226 0.0200253 0.00175316 43782.5 3; : 778 Minimum Test error found - save the configuration ; : 778 | 13.4936 16.5395 0.0200845 0.00181482 43788.4 0; : 779 | 13.0033 16.7495 0.0200505 0.00176209 43743.6 1; : 780 | 12.772 17.4981 0.0200745 0.00176104 43683.8 2; : 781 Minimum Test error found - save the configuration ; : 781 | 12.7689 16.2598 0.0201132 0.00182368 43740.8 0; : 782 | 12.7687 16.3043 0.0200467 0.00175214 43728.9 1; : 783 Minimum Test error found - save the configuration ; : 783 | 12.8267 16.1842 0.0201195 0.00182779 43735.8 0; : 784 Minimum Test error found - save the configuration ; : 784 | 12.4995 16.0856 0.0201584 0.00184241 43677.8 0; : 785 Minimum Test error found - save the configuration ; : 785 | 12.0807 15.9892 0.0201102 0.00181891 43736.6 0; : 786 Minimum Test error found - save the configuration ; : 786 | 12.1859 15.8365 0.0202015 0.00183664 43561.5 0; : 787 Minimum Test error found - save the configuration ; : 787 | 12.2089 15.7994 0.0201254 0.00182497 43714.8 0; : 788 Minimum Test error found - save the configuration ; : 788 | 11.8962 15.4841 0.0201259 0.00183192 43730.1 0; : 789 | 11.7703 15.6571 0.0200815 0.00176624 43679.3 1; : 790 Minimum Test error found - save the configuration ; : 790 | 11.5659 15.3611 0.0201716 0.00184466 43651.5 0; : 791 Mi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:96654,error,error,96654,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,181585 43750.6 0; : 705 Minimum Test error found - save the configuration ; : 705 | 30.8198 28.9852 0.0201048 0.0018126 43734.4 0; : 706 Minimum Test error found - save the configuration ; : 706 | 30.3399 28.5636 0.0203047 0.00182247 43284.8 0; : 707 | 29.8899 28.5807 0.0200458 0.00176314 43757.3 1; : 708 | 29.6409 28.6883 0.0201432 0.0017637 43526.7 2; : 709 Minimum Test error found - save the configuration ; : 709 | 29.434 28.2 0.0201313 0.00182437 43699.3 0; : 710 | 28.7076 28.492 0.0200557 0.00176519 43738.5 1; : 711 Minimum Test error found - save the configuration ; : 711 | 28.4018 27.2754 0.0201013 0.00182194 43765.3 0; : 712 | 28.1436 28.1139 0.020041 0.00175734 43754.9 1; : 713 | 27.878 27.4183 0.0200281 0.0017564 43783.5 2; : 714 | 27.4734 27.8632 0.020054 0.00175612 43720.8 3; : 715 Minimum Test error found - save the configuration ; : 715 | 27.1251 26.6487 0.0201232 0.0018277 43726.6 0; : 716 | 26.6302 26.7712 0.0200343 0.00176196 43782.1 1; : 717 Minimum Test error found - save the configuration ; : 717 | 26.542 26.4691 0.020103 0.00182338 43764.7 0; : 718 Minimum Test error found - save the configuration ; : 718 | 25.9613 26.206 0.0200958 0.00181915 43771.6 0; : 719 Minimum Test error found - save the configuration ; : 719 | 25.6965 25.7845 0.0200932 0.00181887 43777.1 0; : 720 Minimum Test error found - save the configuration ; : 720 | 25.279 25.7029 0.0200856 0.00181582 43788.1 0; : 721 | 24.9296 25.8529 0.0200326 0.00176051 43782.6 1; : 722 | 24.8179 25.9725 0.0200485 0.0017542 43729.4 2; : 723 Minimum Test error found - save the configuration ; : 723 | 24.602 25.0488 0.0200826 0.00181241 43787.1 0; : 724 Minimum Test error found - save the configuration ; : 724 | 24.1724 25.032 0.0200931 0.00180717 43749.4 0; : 725 Minimum Test error found - save the configuration ; : 725 | 23.8272 24.7604 0.0201019 0.00180745 43729.1 0; : 726 Minimum Test error found - save the configuration ; : 726 | 23.3507 24.439 0.0200878 0.00180894 43766.5 0; : 727 | 23.4129 ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:90676,error,error,90676,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"182THn::THn(const char* name, const char* title,; 183 Int_t dim, const Int_t* nbins,; 184 const Double_t* xmin, const Double_t* xmax):; 185 THnBase(name, title, dim, nbins, xmin, xmax),; 186 fSumw2(dim, nbins, kTRUE /*overflow*/); 187{; 188}; 189 ; 190THn::THn(const char *name, const char *title, Int_t dim, const Int_t *nbins,; 191 const std::vector<std::vector<double>> &xbins); 192 : THnBase(name, title, dim, nbins, xbins), fSumw2(dim, nbins, kTRUE /*overflow*/); 193{; 194}; 195 ; 196////////////////////////////////////////////////////////////////////////////////; 197/// Destruct a THn; 198 ; 199THn::~THn(); 200{; 201}; 202 ; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Create an iterator over all bins. Public interface is THnIter.; 206 ; 207ROOT::Internal::THnBaseBinIter* THn::CreateIter(Bool_t respectAxisRange) const; 208{; 209 return new THnBinIter(GetNdimensions(), GetListOfAxes(), &GetArray(),; 210 respectAxisRange);; 211}; 212 ; 213////////////////////////////////////////////////////////////////////////////////; 214/// Enable calculation of errors; 215 ; 216void THn::Sumw2() {; 217 if (!GetCalculateErrors()) {; 218 fTsumw2 = 0.;; 219 }; 220 // fill sumw2 array with current content; 221 TNDArray & content = GetArray();; 222 Long64_t nbins = GetNbins();; 223 for (Long64_t ibin = 0; ibin < nbins; ++ibin); 224 fSumw2.At(ibin) = content.AtAsDouble(ibin);; 225}; 226 ; 227 ; 228////////////////////////////////////////////////////////////////////////////////; 229/// Create the coordinate buffer. Outlined to hide allocation; 230/// from inlined functions.; 231 ; 232void THn::AllocCoordBuf() const; 233{; 234 fCoordBuf.assign(fNdimensions, 0);; 235}; 236 ; 237////////////////////////////////////////////////////////////////////////////////; 238/// Initialize the storage of a histogram created via Init(); 239 ; 240void THn::InitStorage(Int_t* nbins, Int_t /*chunkSize*/); 241{; 242 fCoordBuf.assign(fNdimensions, 0);; 243",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THn_8cxx_source.html:7909,error,errors,7909,doc/master/THn_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THn_8cxx_source.html,1,['error'],['errors']
Availability,"186 if( command.size() < 1 ) {; 187 error_string = ""Parsing error, wrond or no value specified for key: "" + key;; 188 return false;; 189 }; 190 ; 191 Bool_t hasquote = command[0] == '""';; 192 ; 193 //--------------------------------------------------------------------; 194 // Processing code tag: ""{ code }""; 195 ///////////////////////////////////////////////////////////////////////; 196 ; 197 if( key == ""code"" ) {; 198 // Cleaning of the input command:; 199 // - Trim whitespaces at the borders; 200 // - Get the inner command (i.e. the part between quotes); 201 // - Trim whitespaces again; 202 // - Stitch back together; 203 auto clean_command = [](const std::string &c) {; 204 auto first_trim = TSchemaRuleProcessor::Trim(c);; 205 auto inner_command =; 206 first_trim.substr(first_trim.find_first_of('""') + 1, first_trim.find_last_of('""') - 1);; 207 auto second_trim = TSchemaRuleProcessor::Trim(inner_command);; 208 return '""' + second_trim + '""';; 209 };; 210 command = clean_command(command);; 211 ; 212 if( command[1] != '{' ) {; 213 error_string = ""Parsing error while processing key: code\n"";; 214 error_string += ""Expected \""{ at the beginning of the value."";; 215 return false;; 216 }; 217 l = command.find( ""}\"""" );; 218 if( l == std::string::npos ) {; 219 error_string = ""Parsing error while processing key: \"""" + key + ""\""\n"";; 220 error_string += ""Expected }\"" at the end of the value."";; 221 return false;; 222 }; 223 auto rawCode = command.substr( 2, l-2 );; 224 RemoveEscapeSequences(rawCode);; 225 result[key] = rawCode;; 226 ++l;; 227 }; 228 //--------------------------------------------------------------------; 229 // Processing normal tag: ""value""; 230 ///////////////////////////////////////////////////////////////////////; 231 ; 232 else {; 233 if( hasquote) {; 234 l = command.find( '""', 1 );; 235 if (l == std::string::npos ) {; 236 error_string = ""\nParsing error while processing key: \"""" + key + ""\""\n"";; 237 error_string += ""Expected \"" at the end of the value."";",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html:7882,error,error,7882,doc/master/RConversionRuleParser_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html,2,['error'],['error']
Availability,"187 MATH_ERROR_MSG(""Minimizer::Hesse"", ""Hesse not implemented"");; 188 return false;; 189}; 190 ; 191/**; 192 scan function minimum for variable i. Variable and function must be set before using Scan; 193 Return false if an error or if minimizer does not support this functionality; 194 */; 195bool Minimizer::Scan(unsigned int ivar, unsigned int &nstep, double *x, double *y, double xmin, double xmax); 196{; 197 MATH_ERROR_MSG(""Minimizer::Scan"", ""Scan not implemented"");; 198 MATH_UNUSED(ivar);; 199 MATH_UNUSED(nstep);; 200 MATH_UNUSED(x);; 201 MATH_UNUSED(y);; 202 MATH_UNUSED(xmin);; 203 MATH_UNUSED(xmax);; 204 return false;; 205}; 206 ; 207/**; 208 find the contour points (xi, xj) of the function for parameter ivar and jvar around the minimum; 209 The contour will be find for value of the function = Min + ErrorUp();; 210 */; 211bool Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int &npoints, double *xi, double *xj); 212{; 213 MATH_ERROR_MSG(""Minimizer::Contour"", ""Contour not implemented"");; 214 MATH_UNUSED(ivar);; 215 MATH_UNUSED(jvar);; 216 MATH_UNUSED(npoints);; 217 MATH_UNUSED(xi);; 218 MATH_UNUSED(xj);; 219 return false;; 220}; 221 ; 222/// get name of variables (override if minimizer support storing of variable names); 223/// return an empty string if variable is not found; 224std::string Minimizer::VariableName(unsigned int ivar) const; 225{; 226 MATH_UNUSED(ivar);; 227 return std::string(); // return empty string; 228}; 229 ; 230/// get index of variable given a variable given a name; 231/// return -1 if variable is not found; 232int Minimizer::VariableIndex(const std::string &name) const; 233{; 234 MATH_ERROR_MSG(""Minimizer::VariableIndex"", ""Getting variable index from name not implemented"");; 235 MATH_UNUSED(name);; 236 return -1;; 237}; 238 ; 239} // namespace Math; 240} // namespace ROOT; Error.h; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; MATH_WARN_MSG#define MATH_WARN_MSG(loc, str)Definition Error.h:80; Minimiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Minimizer_8cxx_source.html:6906,error,error,6906,doc/master/Minimizer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Minimizer_8cxx_source.html,1,['error'],['error']
Availability,"191 ; 1192 template <typename OutputContainer>; 1193 void fetchOutput (const LayerData& lastLayerData, OutputContainer& outputContainer) const;; 1194 ; 1195 template <typename OutputContainer>; 1196 void fetchOutput (const std::vector<LayerData>& layerPatternData, OutputContainer& outputContainer) const;; 1197 ; 1198 ; 1199 template <typename ItWeight>; 1200 std::tuple</*sumError*/double,/*sumWeights*/double> computeError (const Settings& settings,; 1201 std::vector<LayerData>& lastLayerData,; 1202 Batch& batch,; 1203 ItWeight itWeightBegin,; 1204 ItWeight itWeightEnd) const;; 1205 ; 1206 template <typename Settings>; 1207 void backPropagate (std::vector<std::vector<LayerData>>& layerPatternData,; 1208 const Settings& settings,; 1209 size_t trainFromLayer,; 1210 size_t totalNumWeights) const;; 1211 ; 1212 ; 1213 ; 1214 /*! \brief main NN computation function; 1215 *; 1216 *; 1217 */; 1218 template <typename LayerContainer, typename PassThrough, typename ItWeight, typename ItGradient, typename OutContainer>; 1219 double forward_backward (LayerContainer& layers, PassThrough& settingsAndBatch,; 1220 ItWeight itWeightBegin, ItWeight itWeightEnd,; 1221 ItGradient itGradientBegin, ItGradient itGradientEnd,; 1222 size_t trainFromLayer,; 1223 OutContainer& outputContainer, bool fetchOutput) const;; 1224 ; 1225 ; 1226 ; 1227 double E ();; 1228 void dE ();; 1229 ; 1230 ; 1231 /*! \brief computes the error of the DNN; 1232 *; 1233 *; 1234 */; 1235 template <typename Container, typename ItWeight>; 1236 double errorFunction (LayerData& layerData,; 1237 Container truth,; 1238 ItWeight itWeight,; 1239 ItWeight itWeightEnd,; 1240 double patternWeight,; 1241 double factorWeightDecay,; 1242 EnumRegularization eRegularization) const;; 1243 ; 1244 ; 1245 const std::vector<Layer>& layers () const { return m_layers; } ///< returns the layers (structure); 1246 std::vector<Layer>& layers () { return m_layers; } ///< returns the layers (structure); 1247 ; 1248 void removeLayer () { m_layers.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:45270,error,error,45270,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,2,['error'],"['error', 'errorFunction']"
Availability,"1959 BufferEmpty();; 1960 delete [] fBuffer;; 1961 fBuffer = nullptr;; 1962 }; 1963 if (buffersize <= 0) {; 1964 fBufferSize = 0;; 1965 return;; 1966 }; 1967 if (buffersize < 100) buffersize = 100;; 1968 fBufferSize = 1 + 4*buffersize;; 1969 fBuffer = new Double_t[fBufferSize];; 1970 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1971}; 1972 ; 1973////////////////////////////////////////////////////////////////////////////////; 1974/// Set option to compute profile2D errors.; 1975///; 1976/// The computation of the bin errors is based on the parameter option:; 1977/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; 1978/// i.e. the standard error of the bin contents.; 1979/// Note that if TProfile::Approximate() is called, an approximation is used when; 1980/// the spread in Z is 0 and the number of bin entries is > 0; 1981/// - 's' The bin errors are the standard deviations of the Z bin values; 1982/// Note that if TProfile::Approximate() is called, an approximation is used when; 1983/// the spread in Z is 0 and the number of bin entries is > 0; 1984/// - 'i' Errors are as in default case (standard errors of the bin contents); 1985/// The only difference is for the case when the spread in Z is zero.; 1986/// In this case for N > 0 the error is 1./SQRT(12.*N); 1987/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1988/// W is the sum in the bin of the weights of the profile.; 1989/// This option is for combining measurements z +/- dz,; 1990/// and the profile is filled with values y and weights z = 1/dz**2; 1991///; 1992/// See TProfile::BuildOptions for a detailed explanation of all options; 1993 ; 1994void TProfile2D::SetErrorOption(Option_t *option); 1995{; 1996 TProfileHelper::SetErrorOption(this, option);; 1997}; 1998 ; 1999////////////////////////////////////////////////////////////////////////////////; 2000/// Stream an object of class TProfile2D.; 2001 ; 2002void TProfile2D::Streamer(T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:72203,error,errors,72203,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,2,['error'],['errors']
Availability,"19712 exit_callback = init->callbacks->exit_context;; 19713 /* The exit callback is activated once the context is successfully; 19714 * created. It should not be called, if an incomplete context object; 19715 * is deleted during a failed initialization. */; 19716 ctx->callbacks.exit_context = 0;; 19717 }; 19718 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19719 ctx->dd.handlers = NULL;; 19720 ctx->dd.next = NULL;; 19721 ; 19722#if defined(USE_LUA); 19723 lua_ctx_init(ctx);; 19724#endif; 19725 ; 19726 /* Store options */; 19727 while (options && (name = *options++) != NULL) {; 19728 if ((idx = get_option_index(name)) == -1) {; 19729 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19730 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19731 mg_snprintf(NULL,; 19732 NULL, /* No truncation check for error buffers */; 19733 error->text,; 19734 error->text_buffer_size,; 19735 ""Invalid configuration option: %s"",; 19736 name);; 19737 }; 19738 free_context(ctx);; 19739 pthread_setspecific(sTlsKey, NULL);; 19740 return NULL;; 19741 } else if ((value = *options++) == NULL) {; 19742 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19743 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19744 mg_snprintf(NULL,; 19745 NULL, /* No truncation check for error buffers */; 19746 error->text,; 19747 error->text_buffer_size,; 19748 ""Invalid configuration option value: %s"",; 19749 name);; 19750 }; 19751 free_context(ctx);; 19752 pthread_setspecific(sTlsKey, NULL);; 19753 return NULL;; 19754 }; 19755 if (ctx->dd.config[idx] != NULL) {; 19756 /* A duplicate configuration option is not an error - the last; 19757 * option value will be used. */; 19758 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19759 mg_free(ctx->dd.config[idx]);; 19760 }; 19761 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19762 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19763 }; 19764 ; 19765 /* Set default value if needed */; 19766 for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:588684,error,error,588684,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,10,['error'],['error']
Availability,"19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19731 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19732 mg_snprintf(NULL,; 19733 NULL, /* No truncation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:588717,error,error,588717,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,10,['error'],['error']
Availability,"1999, Vol.41, NO.3; What are robust estimators? ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recognise them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected."" R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz ""Data Analysis Techniques for High-Energy Physics"", 2nd edition; What does this algorithm do? It computes a highly robust estimator of multivariate location and scatter. Then, it takes those estimates to compute robust distances of all the data vectors. Those with large robust distances are considered outliers. Robust distances can then be plotted for better visualization of the data.; How does this algorithm do it? The MCD objective is to find h observations(out of n) whose classical covariance matrix has the lowest determinant. The MCD estimator of location is then the average of those h points and the MCD estimate of scatter is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2 so the algorithm is effective when less than (n+nvar+1)/2 variables are outliers. The algorithm also allows for exact fit situations - that is, when h or more observations lie on a hyperplane. Then the algorithm still yields the MCD location T and scatter matrix S, the latter being singular as it should be. From (T,S) the program then computes the equation of the hyperplane.; How can this algorithm be used? In any case, when contamination of data is suspected, that might influence the classical estimates. Also, robust estimation of location and scatter is a tool to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRobustEstimator.html:1645,robust,robust,1645,doc/master/classTRobustEstimator.html,https://root.cern,https://root.cern/doc/master/classTRobustEstimator.html,1,['robust'],['robust']
Availability,"1::GetMaximumBin can be used to get the location of the maximum value. ; Reimplemented in TH2Poly.; Definition at line 8545 of file TH1.cxx. ◆ GetMaximumBin() [1/2]. Int_t TH1::GetMaximumBin ; (; ); const. virtual . Return location of bin with maximum value in the range. ; TH1::GetMaximum can be used to get the maximum value. ; Definition at line 8577 of file TH1.cxx. ◆ GetMaximumBin() [2/2]. Int_t TH1::GetMaximumBin ; (; Int_t & ; locmax, . Int_t & ; locmay, . Int_t & ; locmaz . ); const. virtual . Return location of bin with maximum value in the range. ; Definition at line 8586 of file TH1.cxx. ◆ GetMaximumStored(). virtual Double_t TH1::GetMaximumStored ; (; ); const. inlinevirtual . Definition at line 289 of file TH1.h. ◆ GetMean(). Double_t TH1::GetMean ; (; Int_t ; axis = 1); const. virtual . For axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis. ; For axis = 11, 12, 13 returns the standard error of the mean value of the histogram along X, Y or Z axis; Note that the mean value/StdDev is computed using the bins in the currently defined range (see TAxis::SetRange). By default the range includes all bins from 1 to nbins included, excluding underflows and overflows. To force the underflows and overflows in the computation, one must call the static function TH1::StatOverflows(kTRUE) before filling the histogram.; IMPORTANT NOTE: The returned value depends on how the histogram statistics are calculated. By default, if no range has been set, the returned mean is the (unbinned) one calculated at fill time. If a range has been set, however, the mean is calculated using the bins in range, as described above; THIS IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS–use TAxis::SetRange(0, 0) to unset the range. To ensure that the returned mean (and all other statistics) is always that of the binned data stored in the histogram, call TH1::ResetStats. See TH1::GetStats.; Return mean value of this histogram along the X axis. ; Definition at line 7535 of file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:161144,error,error,161144,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['error'],['error']
Availability,"1::Integral(). ROOT::Fit::Fitter* GetFitter(); Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). TFitResultPtr Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). If option ""S"" a TFitResult object is returned and it can be used to obtain; additional fit information, like covariance or correlation matrix. Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, but in such cases; an arbitrary starting step size will be used, and the reliability of; the fit should be questioned). If parameters are to be fixed, this; should be done by specifying non-null parameter limits, with lower; limits larger than upper limits. On output, f1 contains the fitted parameters and errors, as well as; the number of degrees of freedom, and the goodness-of-fit estimator; as given by S. Baker and R. Cousins, Nucl. Instr. Meth. A221 (1984) 437. void ComputeFCN(Double_t& f, const Double_t* par); Compute the likelihood. TBinomialEfficiencyFitter(). Double_t EvaluateFCN(const Double_t* par). » Author: Frank Filthaut, Rene Brun 30/05/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TBinomialEfficiencyFitter.html:10876,reliab,reliability,10876,root/html604/TBinomialEfficiencyFitter.html,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html,2,"['error', 'reliab']","['errors', 'reliability']"
Availability,"1::Integral(). ROOT::Fit::Fitter* GetFitter(); Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). TFitResultPtr Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). If option ""S"" a TFitResult object is returned and it can be used to obtain; additional fit information, like covariance or correlation matrix. Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, but in such cases; an arbitrary starting step size will be used, and the reliability of; the fit should be questioned). If parameters are to be fixed, this; should be done by specifying non-null parameter limits, with lower; limits larger than upper limits. On output, f1 contains the fitted parameters and errors, as well as; the number of degrees of freedom, and the goodness-of-fit estimator; as given by S. Baker and R. Cousins, Nucl. Instr. Meth. A221 (1984) 437. void ComputeFCN(Double_t& f, const Double_t* par); Compute the likelihood. TBinomialEfficiencyFitter(). Double_t EvaluateFCN(const Double_t* par). » Author: Frank Filthaut, Rene Brun 30/05/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-30 14:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBinomialEfficiencyFitter.html:10876,reliab,reliability,10876,root/html602/TBinomialEfficiencyFitter.html,https://root.cern,https://root.cern/root/html602/TBinomialEfficiencyFitter.html,2,"['error', 'reliab']","['errors', 'reliability']"
Availability,1; : 1001 | 3.31742 4.17699 0.020287 0.00175118 43159.8 2; : 1002 | 3.35839 4.8143 0.0207434 0.00177731 42180.6 3; : 1003 Minimum Test error found - save the configuration ; : 1003 | 3.42381 4.04915 0.0202591 0.00184351 43441.4 0; : 1004 Minimum Test error found - save the configuration ; : 1004 | 3.27488 4.0384 0.0205262 0.00189376 42935.9 0; : 1005 | 3.09776 4.19224 0.0200956 0.00176781 43649.6 1; : 1006 Minimum Test error found - save the configuration ; : 1006 | 3.1757 3.91876 0.0201134 0.00183093 43757.7 0; : 1007 | 3.17471 4.33126 0.0203423 0.00178093 43100.3 1; : 1008 | 3.23752 4.46797 0.0204556 0.0017847 42847.4 2; : 1009 | 3.5099 4.04664 0.0203963 0.00177013 42950.3 3; : 1010 | 3.39993 4.32216 0.0201011 0.00176915 43639.8 4; : 1011 | 3.28002 4.35065 0.020045 0.00175269 43734.2 5; : 1012 | 3.24301 4.1309 0.0202482 0.00178612 43332 6; : 1013 | 3.47685 4.13785 0.0205714 0.00178247 42578.3 7; : 1014 | 3.38367 4.59532 0.0203076 0.00178189 43183.2 8; : 1015 Minimum Test error found - save the configuration ; : 1015 | 3.15343 3.81668 0.0204522 0.00185272 43011.9 0; : 1016 | 2.99441 4.01707 0.0202697 0.00183758 43402.5 1; : 1017 | 3.3956 4.54944 0.0201133 0.00176644 43604.1 2; : 1018 | 3.2792 3.85661 0.0202747 0.00181943 43348.2 3; : 1019 | 3.37748 4.22044 0.0208054 0.00183497 42170.8 4; : 1020 | 3.48034 4.07947 0.020447 0.00177824 42852.4 5; : 1021 | 3.50059 4.11275 0.020219 0.00176964 43361.9 6; : 1022 | 3.15174 3.86168 0.0203283 0.00176093 43086.3 7; : 1023 | 3.4694 4.52782 0.0204007 0.00179059 42987.4 8; : 1024 Minimum Test error found - save the configuration ; : 1024 | 3.57333 3.68346 0.0207199 0.00186469 42428.5 0; : 1025 | 3.1448 3.86932 0.020257 0.0018083 43363.6 1; : 1026 | 3.14966 3.71614 0.0204412 0.00177219 42851.8 2; : 1027 Minimum Test error found - save the configuration ; : 1027 | 3.06278 3.47888 0.0204485 0.00186251 43043.1 0; : 1028 | 3.22518 4.06346 0.0201016 0.00179042 43689.3 1; : 1029 | 3.47015 5.10048 0.0212551 0.0017691 41055.1 2; : 1030 | 3,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:114166,error,error,114166,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,1; : 780 | 12.772 17.4981 0.0200745 0.00176104 43683.8 2; : 781 Minimum Test error found - save the configuration ; : 781 | 12.7689 16.2598 0.0201132 0.00182368 43740.8 0; : 782 | 12.7687 16.3043 0.0200467 0.00175214 43728.9 1; : 783 Minimum Test error found - save the configuration ; : 783 | 12.8267 16.1842 0.0201195 0.00182779 43735.8 0; : 784 Minimum Test error found - save the configuration ; : 784 | 12.4995 16.0856 0.0201584 0.00184241 43677.8 0; : 785 Minimum Test error found - save the configuration ; : 785 | 12.0807 15.9892 0.0201102 0.00181891 43736.6 0; : 786 Minimum Test error found - save the configuration ; : 786 | 12.1859 15.8365 0.0202015 0.00183664 43561.5 0; : 787 Minimum Test error found - save the configuration ; : 787 | 12.2089 15.7994 0.0201254 0.00182497 43714.8 0; : 788 Minimum Test error found - save the configuration ; : 788 | 11.8962 15.4841 0.0201259 0.00183192 43730.1 0; : 789 | 11.7703 15.6571 0.0200815 0.00176624 43679.3 1; : 790 Minimum Test error found - save the configuration ; : 790 | 11.5659 15.3611 0.0201716 0.00184466 43651.5 0; : 791 Minimum Test error found - save the configuration ; : 791 | 11.5078 15.2368 0.0201178 0.00182919 43743 0; : 792 | 11.3858 15.3308 0.0200358 0.001762 43778.5 1; : 793 Minimum Test error found - save the configuration ; : 793 | 11.148 14.9168 0.0201055 0.00182242 43756.2 0; : 794 Minimum Test error found - save the configuration ; : 794 | 10.9366 14.9107 0.0201153 0.00182387 43736.3 0; : 795 | 11.1392 14.953 0.020041 0.00176266 43767.6 1; : 796 | 11.1019 15.4101 0.0200549 0.00175791 43723.2 2; : 797 | 11.12 15.292 0.0200628 0.00175972 43708.5 3; : 798 | 10.8935 14.9786 0.0200585 0.0017545 43706.3 4; : 799 Minimum Test error found - save the configuration ; : 799 | 10.7942 14.6749 0.0201633 0.00182171 43616.6 0; : 800 Minimum Test error found - save the configuration ; : 800 | 10.3317 14.1583 0.0201165 0.00182126 43727.2 0; : 801 | 10.3503 14.2866 0.0200523 0.00175781 43729 1; : 802 | 10.3453 15.2815 0,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:97564,error,error,97564,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"1; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TFastCgiTHttpEngine implementation, based on fastcgi package.Definition TFastCgi.h:20; THttpCallArgContains arguments for single HTTP call.Definition THttpCallArg.h:27; THttpCallArg::Set404void Set404()mark reply as 404 error - page/request not exists or refusedDefinition THttpCallArg.h:163; THttpCallArg::kZipAlways@ kZipAlwaysDefinition THttpCallArg.h:38; THttpEngineAbstract class for implementing http protocol for THttpServer.Definition THttpEngine.h:19; THttpEngine::SetServervoid SetServer(THttpServer *serv)Definition THttpEngine.h:27; THttpEngine::Createvirtual Bool_t Create(const char *)Method to create all components of engine.Definition THttpEngine.h:37; THttpLongPollEngineEmulation of websocket with long poll requests.Definition THttpLongPollEngine.h:23; THttpServerOnline http server for arbitrary ROOT application.Definition THttpServer.h:31; THttpServer::IsReadOnlyBool_t IsReadOnly() constreturns read-only modeDefinition THttpServer.cxx:285; THttpServer::RegisterCommandBool_t RegisterCommand(const char *cmdname, const char *method, const char *icon=nullptr)Register command which can be executed from web interface.Definition THttpServer.cxx:1428; THttpServer::fJSROOTTString fJSROOT! location of ext",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:56211,error,error,56211,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['error'],['error']
Availability,"1; j<= ymax; j++){; 4375 for(Int_t k=1; k<= zmax; k++){; 4376 Int_t bin = GetBin(i, j, k);; 4377 // here some bin contents are written into variables to make the error; 4378 // calculation a little more legible:; 4379 Double_t a = h1->RetrieveBinContent(bin);; 4380 Double_t b = h2->RetrieveBinContent(bin);; 4381 Double_t bot = bottom->RetrieveBinContent(bin);; 4382 ; 4383 // make sure there are some events, if not, then the errors are set = 0; 4384 // automatically.; 4385 //if(bot < 1){} was changed to the next line from recommendation of Jason Seely (28 Nov 2005); 4386 if(bot < 1e-6){}; 4387 else{; 4388 // computation of errors by Christos Leonidopoulos; 4389 Double_t dasq = h1->GetBinErrorSqUnchecked(bin);; 4390 Double_t dbsq = h2->GetBinErrorSqUnchecked(bin);; 4391 Double_t error = 2*TMath::Sqrt(a*a*c2*c2*dbsq + c2*c2*b*b*dasq+a*a*b*b*dc2*dc2)/(bot*bot);; 4392 asym->SetBinError(i,j,k,error);; 4393 }; 4394 }; 4395 }; 4396 }; 4397 delete top;; 4398 delete bottom;; 4399 ; 4400 return asym;; 4401}; 4402 ; 4403////////////////////////////////////////////////////////////////////////////////; 4404/// Static function; 4405/// return the default buffer size for automatic histograms; 4406/// the parameter fgBufferSize may be changed via SetDefaultBufferSize; 4407 ; 4408Int_t TH1::GetDefaultBufferSize(); 4409{; 4410 return fgBufferSize;; 4411}; 4412 ; 4413////////////////////////////////////////////////////////////////////////////////; 4414/// Return kTRUE if TH1::Sumw2 must be called when creating new histograms.; 4415/// see TH1::SetDefaultSumw2.; 4416 ; 4417Bool_t TH1::GetDefaultSumw2(); 4418{; 4419 return fgDefaultSumw2;; 4420}; 4421 ; 4422////////////////////////////////////////////////////////////////////////////////; 4423/// Return the current number of entries.; 4424 ; 4425Double_t TH1::GetEntries() const; 4426{; 4427 if (fBuffer) {; 4428 Int_t nentries = (Int_t) fBuffer[0];; 4429 if (nentries > 0) return nentries;; 4430 }; 4431 ; 4432 return fEntries;; 4433}; 4434 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:181420,error,errors,181420,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,3,['error'],"['error', 'errors']"
Availability,1=1 p_ph_sig2_gamma_bin_22=7.28945 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=7.28945 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=7.28945 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGR,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:29874,error,error,29874,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,2,['error'],['error']
Availability,"1D histogram.Definition TH1.cxx:9152; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetSumw2virtual TArrayD * GetSumw2()Definition TH1.h:313; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TIterDefinition TCollection.h:235; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::AtofDouble_t Atof() constReturn floating-point value contained in string.Definition TString.cxx:2054; TString::IsFloatBool_t IsFloat() constReturns kTRUE if string contains a floating point or integer number.Definition TString.cxx:1858; TString::Dataconst char * Data() constDefinition TString.h:376; TString::IsDigitBool_t IsDigit() constReturns true if all characters in string are digits (0-9) or white spaces, i.e.Definition TString.cxx:1830; TString::ReplaceAllTStr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:70157,error,error,70157,doc/master/TGraphAsymmErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html,1,['error'],['error']
Availability,"1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position. To change the type of information for an histogram with an existing; TPaveStats one should do:. st->SetOptStat(mode);. Where ""mode"" has the same meaning than when calling; gStyle->SetOptStat(mode) (see above).; One can delete the statistics box for a histogram TH1* h with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Labels used in the statistics box (""Mean"", ""Std Dev"", ...) can be changed from; $ROOTSYS/etc/system.rootrc or; .rootrc; (look for the string ""Hist.Stats.""). Fit Statistics; The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THistPainter.html:19755,error,errors,19755,root/html604/THistPainter.html,https://root.cern,https://root.cern/root/html604/THistPainter.html,1,['error'],['errors']
Availability,"1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TSpectrumFit (Int_t numberPeaks);  numberPeaks: number of fitted peaks (must be greater than zero) ;  ;  TSpectrumFit (void);  Default constructor. ;  ;  ~TSpectrumFit () override;  Destructor. ;  ; void FitAwmi (Double_t *source);  This function fits the source spectrum. ;  ; void FitStiefel (Double_t *source);  This function fits the source spectrum. ;  ; Double_t * GetAmplitudes () const;  ; Double_t * GetAmplitudesErrors () const;  ; Double_t * GetAreas () const;  ; Double_t * GetAreasErrors () const;  ; void GetBackgroundParameters (Double_t &a0, Double_t &a0Err, Double_t &a1, Double_t &a1Err, Double_t &a2, Double_t &a2Err);  This function gets the background parameters and their errors. ;  ; Double_t GetChi () const;  ; Double_t * GetPositions () const;  ; Double_t * GetPositionsErrors () const;  ; void GetSigma (Double_t &sigma, Double_t &sigmaErr);  This function gets the sigma parameter and its error. ;  ; void GetTailParameters (Double_t &t, Double_t &tErr, Double_t &b, Double_t &bErr, Double_t &s, Double_t &sErr);  This function gets the tail parameters and their errors. ;  ; TClass * IsA () const override;  ; void SetBackgroundParameters (Double_t a0Init, Bool_t fixA0, Double_t a1Init, Bool_t fixA1, Double_t a2Init, Bool_t fixA2);  This function sets the following fitting parameters of background: ;  ; void SetFitParameters (Int_t xmin, Int_t xmax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor);  This function sets the following fitting parameters: ;  ; void SetPeakParameters (Double_t sigma, Bool_t fixSigma, const Double_t *positionInit, const Bool_t *fixPosition, const Double_t *ampInit, const Bool_t *fixAmp);  This function sets the following fitting parameters of peaks: ;  ; void SetTailParameters (Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumFit.html:3574,error,error,3574,doc/master/classTSpectrumFit.html,https://root.cern,https://root.cern/doc/master/classTSpectrumFit.html,1,['error'],['error']
Availability,"1[,server2:port2,...]/pathfile?checkenv""; c. set the cache size (in bytes); ""root://server1:port1[,server2:port2,...]/pathfile?cachesz=20000000""; d. set the read-ahead size (in bytes); ""root://server1:port1[,server2:port2,...]/pathfile?readaheadsz=100000""; e. set the cache remove policy; ""root://server1:port1[,server2:port2,...]/pathfile?rmpolicy=1""; f. set the max number of redirections; ""root://server1:port1[,server2:port2,...]/pathfile?mxredir=2""; (multiple options can be set concurrently). ~TXNetFile(); Destructor. void FormUrl(TUrl uut, TString& uu); Form url for rootd socket. Int_t ParseOptions(const char* opts, Int_t& cachesz, Int_t& readaheadsz, Int_t& rmpolicy, Int_t& mxredir, Int_t& rastrategy, Int_t& readtrimblksz); Parse input options for cache parameters. void CreateXClient(const char* url, Option_t* option, Int_t netopt, Bool_t parallelopen); The real creation work is done here. Int_t GetRootdProtocol(TSocket* s); Find out the remote rootd protocol version.; Returns -1 in case of error. Bool_t Open(Option_t* option, Bool_t parallelopen); The real creation work is done here. Bool_t ReadBuffer(char* buf, Int_t len); Override TNetFile::ReadBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Pass through to TNetFile implementation which will call back eventually; to our ReadBuffer with 2 arguments to deal with xrootd errors. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Implementation dealing with the xrootd server.; Returns kTRUE in case of errors.; This is the same as TXNetFile::ReadBuffer but using the async; call from xrootd. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReadBuffer; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure.; Note:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetFile.html:28382,error,error,28382,root/html602/TXNetFile.html,https://root.cern,https://root.cern/root/html602/TXNetFile.html,2,['error'],['error']
Availability,"1[,server2:port2,...]/pathfile?checkenv""; c. set the cache size (in bytes); ""root://server1:port1[,server2:port2,...]/pathfile?cachesz=20000000""; d. set the read-ahead size (in bytes); ""root://server1:port1[,server2:port2,...]/pathfile?readaheadsz=100000""; e. set the cache remove policy; ""root://server1:port1[,server2:port2,...]/pathfile?rmpolicy=1""; f. set the max number of redirections; ""root://server1:port1[,server2:port2,...]/pathfile?mxredir=2""; (multiple options can be set concurrently). ~TXNetFile(); Destructor. void FormUrl(TUrl uut, TString& uu); Form url for rootd socket. Int_t ParseOptions(const char* opts, Int_t& cachesz, Int_t& readaheadsz, Int_t& rmpolicy, Int_t& mxredir, Int_t& rastrategy, Int_t& readtrimblksz); Parse input options for cache parameters. void CreateXClient(const char* url, Option_t* option, Int_t netopt, Bool_t parallelopen); The real creation work is done here. Int_t GetRootdProtocol(TSocket* s); Find out the remote rootd protocol version.; Returns -1 in case of error. Bool_t Open(Option_t* option, Bool_t parallelopen); The real creation work is done here. Bool_t ReadBuffer(char* buf, Int_t len); Override TNetFile::ReadBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Pass through to TNetFile implementation which will call back eventually; to our ReadBuffer with 2 arguments to deal with xrootd errors. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Implementation dealing with the xrootd server.; Returns kTRUE in case of errors.; This is the same as TXNetFile::ReadBuffer but using the async; call from xrootd. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure.; Note:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:26370,error,error,26370,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,4,['error'],['error']
Availability,"1] ; for (i=0;i<11;i++) buf[i]=0;; 2348 Bool_t opFound ;; 2349 Int_t opFrac = 0;; 2350 Int_t length = text.Length() ;; 2351 ; 2352 Int_t nOfCurlyBracket, nOfKW1, nOfKW2, nOfKW3, nOfSquareCurly, nOfCurlyCurly ;; 2353 Int_t nOfSquareBracket = 0 ;; 2354 Int_t error = 0 ;; 2355 Bool_t quote1 = kFALSE , quote2 = kFALSE;; 2356 ; 2357 // first find and replace all occurrences of ""kLeft1"" keyword by ""kLeft2"" keyword,; 2358 // and all occurrences of ""kRight"" keyword by ""}"".; 2359 i = 0 ;; 2360 while (i < length) {; 2361 // The string in 'buf' does not need to be null terminated,; 2362 // we will only check with strncmp.; 2363 strncpy(buf,&text[i],TMath::Min(7,length-i));; 2364 opFound = kFALSE ;; 2365 for (k = 0 ; k < nLeft1 ; k++) {; 2366 if (strncmp(buf,kLeft1[k],lLeft1)==0) {; 2367 nOfLeft++ ;; 2368 i+=lLeft1 ;; 2369 opFound = kTRUE ;; 2370 break ;; 2371 }; 2372 }; 2373 if (opFound) continue ;; 2374 ; 2375 for(k=0;k<nRight;k++) {; 2376 if (strncmp(buf,kRight[k],lRight)==0) {; 2377 nOfRight++ ;; 2378 i+=lRight ;; 2379 opFound = kTRUE ;; 2380 break ;; 2381 }; 2382 }; 2383 if (!opFound) i++ ;; 2384 }; 2385 if (nOfLeft != nOfRight) {; 2386 printf("" nOfLeft = %d, nOfRight = %d\n"",nOfLeft,nOfRight) ;; 2387 error = 1 ;; 2388 fError = ""Operators \""#left\"" and \""#right\"" don't match !"" ;; 2389 goto ERROR_END ;; 2390 }; 2391 ; 2392 for (k = 0 ; k < nLeft1 ; k++) {; 2393 text.ReplaceAll(kLeft1[k],lLeft1,kLeft2[k],lLeft2) ;; 2394 }; 2395 for (k = 0 ; k < nRight ; k++) {; 2396 text.ReplaceAll(kRight[k],lRight,""}"",1) ;; 2397 }; 2398 length = text.Length() ;; 2399 ; 2400 i = nOfCurlyBracket = nOfKW1 = nOfKW2 = nOfKW3 = nOfSquareCurly = nOfCurlyCurly =0 ;; 2401 while (i< length){; 2402 switch (text[i]) {; 2403 case '""' : quote1 = !quote1 ; break ;; 2404 case '\'': quote2 = !quote2 ; break ;; 2405 }; 2406 // The string in 'buf' does not need to be null terminated,; 2407 // we will only check with strncmp; 2408 strncpy(buf,&text[i],TMath::Min(11,length-i));; 2409 opFound = kFALSE ;; 2410 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLatex_8cxx_source.html:86387,error,error,86387,doc/master/TLatex_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html,1,['error'],['error']
Availability,"1}; b#define b(i)Definition RSha256.hxx:100; g#define g(i)Definition RSha256.hxx:105; Version_tshort Version_tDefinition RtypesCore.h:65; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; TGraph2DErrors.h; TH2.h; THLimitsFinder.h; TVirtualFitter.h; TVirtualPad.h; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TGraph2DErrorsGraph 2D class with errors.Definition TGraph2DErrors.h:26; TGraph2DErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraph2DErrors.Definition TGraph2DErrors.cxx:462; TGraph2DErrors::GetErrorZDouble_t GetErrorZ(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:230; TGraph2DErrors::~TGraph2DErrors~TGraph2DErrors() overrideTGraph2DErrors destructor.Definition TGraph2DErrors.cxx:137; TGraph2DErrors::GetYminEDouble_t GetYminE() const overrideReturns the Y minimum with errors.Definition TGraph2DErrors.cxx:274; TGraph2DErrors::GetXminEDouble_t GetXminE() const overrideReturns the X minimum with errors.Definition TGraph2DErrors.cxx:252; TGraph2DErrors::GetEZDouble_t * GetEZ() const overrideDefinition TGraph2DErrors.h:47; TGraph2DErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraph2DErrors.h:30; TGraph2DErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraph2DErrors.h:46; TGraph2DErrors::SetPointvoid SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) overrideSet x, y and z values for point number i.Definition TGraph2DErrors.cxx:404; TGraph2DErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""z"") overrideMultiply the values and errors of a TGraph2DErrors by a constant c1.Definition TGraph2DErrors.cxx:322; TGraph2DErrors::fEZDouble_t * fEZ[fNpoints] array of Z errorsDefinition TGraph2DErrors.h:31; TGraph2DErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraph2DErrors.h:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:14953,error,errors,14953,doc/master/TGraph2DErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html,1,['error'],['errors']
Availability,"1 . ). Display the current content starting from line 'from' to line 'to' inclusive. ; A negative value for 'from' indicates lines counted from the end (tail action); 'to' is ignored in such a case. TProofLog::Prt is called to display: the location (screen, file, box) is defined there. Return 0 on success, -1 in case of any error. ; Definition at line 467 of file TProofLog.cxx. ◆ GetMacro(). TMacro * TProofLogElem::GetMacro ; (; ); const. inline . Definition at line 100 of file TProofLog.h. ◆ GetMaxTransferSize(). Long64_t TProofLogElem::GetMaxTransferSize ; (; ). static . Get max transfer size. ; Definition at line 351 of file TProofLog.cxx. ◆ GetRole(). const char * TProofLogElem::GetRole ; (; ). inline . Definition at line 101 of file TProofLog.h. ◆ Grep(). Int_t TProofLogElem::Grep ; (; const char * ; txt, . TString & ; res, . Int_t ; from = 0 . ). Search lines containing 'txt', starting from line 'from'. ; Return their blanck-separated list into 'res'. Return the number of lines found, or -1 in case of error. ; Definition at line 559 of file TProofLog.cxx. ◆ IsA(). TClass * TProofLogElem::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 114 of file TProofLog.h. ◆ IsMaster(). Bool_t TProofLogElem::IsMaster ; (; ); const. inline . Definition at line 103 of file TProofLog.h. ◆ IsSubMaster(). Bool_t TProofLogElem::IsSubMaster ; (; ); const. inline . Definition at line 104 of file TProofLog.h. ◆ IsWorker(). Bool_t TProofLogElem::IsWorker ; (; ); const. inline . Definition at line 105 of file TProofLog.h. ◆ Print(). void TProofLogElem::Print ; (; Option_t * ; opt = 0); const. overridevirtual . Print a line with the relevant info. ; Reimplemented from TNamed.; Definition at line 536 of file TProofLog.cxx. ◆ Prt(). void TProofLogElem::Prt ; (; const char * ; what). Special printing procedure. ; Definition at line 548 of file TProofLog.cxx. ◆ Retrieve(). Int_t TProofLogElem::Retrieve ; (;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLogElem.html:14244,error,error,14244,doc/master/classTProofLogElem.html,https://root.cern,https://root.cern/doc/master/classTProofLogElem.html,1,['error'],['error']
Availability,"1 ;  . ). ◆ VOID_METHOD_ARG7(). Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t VOID_METHOD_ARG7 ; (; VirtualX ; , . DrawCellArray ; , . Int_t ; , . x1 ; , . Int_t ; , . y1 ; , . Int_t ; , . x2 ; , . Int_t ; , . y2 ; , . Int_t ; , . nx ; , . Int_t ; , . ny ; , . Int_t * ; , . ic ; , . 1 ;  . ). ◆ VOID_METHOD_ARG8(). Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t VOID_METHOD_ARG8 ; (; VirtualX ; , . QueryPointer ; , . Window_t ; , . id ; , . Window_t & ; , . rootw ; , . Window_t & ; , . childw ; , . Int_t & ; , . root_x ; , . Int_t & ; , . root_y ; , . Int_t & ; , . win_x ; , . Int_t & ; , . win_y ; , . UInt_t & ; , . mask ; , . 1 ;  . ). ◆ VOID_METHOD_ARG9(). Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t VOID_METHOD_ARG9 ; (; VirtualX ; , . PutImage ; , . Drawable_t ; , . id ; , . GContext_t ; , . gc ; , . Drawable_t ; , . img ; , . Int_t ; , . dx ; , . Int_t ; , . dy ; , . Int_t ; , . x ; , . Int_t ; , . y ; , . UInt_t ; , . w ; , . UInt_t ; , . h ; , . 1 ;  . ). Variable Documentation. ◆ act_format. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html:145711,mask,mask,145711,doc/master/TGWin32VirtualXProxy_8cxx.html,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html,2,['mask'],['mask']
Availability,"2 * Rsq_ij ] ]; r5 = sum_i [ M1_mi * H_ni ]; r6 = sum_i [ M1_ni * H_mi ]. calculate contributions containing matrices F and G; r0,r1,r2. void SetTauError(Double_t delta_tau); set uncertainty on tau. void GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). void GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); get correlated shift induced by a background source; delta: output shift vector histogram; source: name of background source; binMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfoldSys.html:25208,error,error,25208,root/html528/TUnfoldSys.html,https://root.cern,https://root.cern/root/html528/TUnfoldSys.html,6,['error'],"['error', 'errors']"
Availability,"2 // On the link line, we must list the most dependent .o file; 983 // and end with the least dependent (LLVM libraries), unfortunately,; 984 // Fedora Core 17+ or Ubuntu 12 will also execute the initialization; 985 // in the same order (hence doing libCore's before LLVM's and; 986 // vice et versa for both the destructor. We worked around the; 987 // initialization order by delay the TROOT creation until first use.; 988 // We can not do the same for destruction as we have no way of knowing; 989 // the last access ...; 990 // So for now, let's avoid delete TCling except in the special build; 991 // checking the completeness of the termination deletion.; 992 ; 993 // TODO: Should we do more cleanup here than just call delete?; 994 // Segfaults rootcling in some cases, debug and uncomment:; 995 //; 996 // delete fInterpreter;; 997 ; 998 // We cannot delete fCleanups because of the logic in atexit which needs it.; 999 SafeDelete(fCleanups);; 1000#endif; 1001 ; 1002#ifdef _MSC_VER; 1003 // usedToIdentifyRootClingByDlSym is available when TROOT is part of rootcling.; 1004 if (dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"")) {; 1005 // deleting the interpreter makes things crash at exit in some cases; 1006 delete fInterpreter;; 1007 }; 1008#else; 1009 // deleting the interpreter makes things crash at exit in some cases; 1010 delete fInterpreter;; 1011#endif; 1012 ; 1013 // Prints memory stats; 1014 TStorage::PrintStatistics();; 1015 ; 1016 gROOTLocal = nullptr;; 1017 fgRootInit = kFALSE;; 1018 }; 1019}; 1020 ; 1021////////////////////////////////////////////////////////////////////////////////; 1022/// Add a class to the list and map of classes.; 1023/// This routine is deprecated, use TClass::AddClass directly.; 1024 ; 1025void TROOT::AddClass(TClass *cl); 1026{; 1027 TClass::AddClass(cl);; 1028}; 1029 ; 1030////////////////////////////////////////////////////////////////////////////////; 1031/// Add a class generator. This generator will be called by TClass::GetCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:39813,avail,available,39813,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['avail'],['available']
Availability,"2 // Set entry offset in buffer and read data from all leaves.; 1803 if (!TestBit(kDoNotUseBufferMap)) {; 1804 buf->ResetMap();; 1805 }; 1806 if (R__unlikely(!buf->IsReading())) {; 1807 basket->SetReadMode();; 1808 }; 1809 Int_t* entryOffset = basket->GetEntryOffset();; 1810 Int_t bufbegin = 0;; 1811 if (entryOffset) {; 1812 bufbegin = entryOffset[entry-first];; 1813 buf->SetBufferOffset(bufbegin);; 1814 Int_t* displacement = basket->GetDisplacement();; 1815 if (R__unlikely(displacement)) {; 1816 buf->SetBufferDisplacement(displacement[entry-first]);; 1817 }; 1818 } else {; 1819 bufbegin = basket->GetKeylen() + ((entry-first) * basket->GetNevBufSize());; 1820 buf->SetBufferOffset(bufbegin);; 1821 }; 1822 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(0);; 1823 leaf->ReadBasketExport(*buf, li, nentries);; 1824 nbytes = buf->Length() - bufbegin;; 1825 return nbytes;; 1826}; 1827 ; 1828////////////////////////////////////////////////////////////////////////////////; 1829/// Fill expectedClass and expectedType with information on the data type of the; 1830/// object/values contained in this branch (and thus the type of pointers; 1831/// expected to be passed to Set[Branch]Address; 1832/// return 0 in case of success and > 0 in case of failure.; 1833 ; 1834Int_t TBranch::GetExpectedType(TClass *&expectedClass,EDataType &expectedType); 1835{; 1836 expectedClass = nullptr;; 1837 expectedType = kOther_t;; 1838 TLeaf* l = (TLeaf*) GetListOfLeaves()->At(0);; 1839 if (l) {; 1840 expectedType = (EDataType) gROOT->GetType(l->GetTypeName())->GetType();; 1841 return 0;; 1842 } else {; 1843 Error(""GetExpectedType"", ""Did not find any leaves in %s"",GetName());; 1844 return 1;; 1845 }; 1846}; 1847 ; 1848////////////////////////////////////////////////////////////////////////////////; 1849/// Return pointer to the file where branch buffers reside, returns 0; 1850/// in case branch buffers reside in the same file as tree header.; 1851/// If mode is 1 the branch buffer file is recreated.; 18",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:66820,failure,failure,66820,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['failure'],['failure']
Availability,"2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style; X#define X(type, name); angleOption_t Option_t TPoint TPoint angleDefinition TGWin32VirtualXProxy.cxx:68; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; styleOption_t Option_t styleDefinition TGWin32VirtualXProxy.cxx:46; TObject::fUniqueIDUInt_t fUniqueIDobject unique identifierDefinition TObject.h:44; TObject::fBitsUInt_t fBitsbit field status wordDefinition TObject.h:45; lineTLine * lineDefinition entrylistblock_figure1.C:235. Reimplemented in TSystemFile, TCollection, TClass, TGFrame, and TGPack.; Definition at line 348 of file TObject.cxx. ◆ Error(). void TObject::Error ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue error message. ; Use ""location"" to specify the method where the error occurred. Accepts standard printf formatting arguments. ; Reimplemented in TFitResult.; Definition at line 987 of file TObject.cxx. ◆ Execute() [1/2]. void TObject::Execute ; (; const char * ; method, . const char * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with the given parameter string, e.g. ; ""3.14,1,\""text\"""". ; Reimplemented in TMethodCall, TCling, TInterpreter, ROOT::R::TRInterface, and TContextMenu.; Definition at line 359 of file TObject.cxx. ◆ Execute() [2/2]. void TObject::Execute ; (; TMethod * ; method, . TObjArray * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with parameters stored in the TObjArray. ; The TObjArray should contain an argv vector like: argv[0] ... argv[n] = the list of TObjString parameters; TObjStringCollectable string class.Definition TObjString.h:28; nconst Int_t nDefinition legend1.C:16. Reimplemented in TCling, TMethodCall, TInterpreter, ROOT::R::TRIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTObject.html:33334,error,error,33334,doc/v632/classTObject.html,https://root.cern,https://root.cern/doc/v632/classTObject.html,1,['error'],['error']
Availability,"2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style; X#define X(type, name); angleOption_t Option_t TPoint TPoint angleDefinition TGWin32VirtualXProxy.cxx:68; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; styleOption_t Option_t styleDefinition TGWin32VirtualXProxy.cxx:46; TObject::fUniqueIDUInt_t fUniqueIDobject unique identifierDefinition TObject.h:44; TObject::fBitsUInt_t fBitsbit field status wordDefinition TObject.h:45; lineTLine * lineDefinition entrylistblock_figure1.C:235. Reimplemented in TSystemFile, TCollection, TClass, TGFrame, and TGPack.; Definition at line 353 of file TObject.cxx. ◆ Error(). void TObject::Error ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue error message. ; Use ""location"" to specify the method where the error occurred. Accepts standard printf formatting arguments. ; Reimplemented in TFitResult.; Definition at line 993 of file TObject.cxx. ◆ Execute() [1/2]. void TObject::Execute ; (; const char * ; method, . const char * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with the given parameter string, e.g. ; ""3.14,1,\""text\"""". ; Reimplemented in TMethodCall, TCling, TInterpreter, ROOT::R::TRInterface, and TContextMenu.; Definition at line 364 of file TObject.cxx. ◆ Execute() [2/2]. void TObject::Execute ; (; TMethod * ; method, . TObjArray * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with parameters stored in the TObjArray. ; The TObjArray should contain an argv vector like: argv[0] ... argv[n] = the list of TObjString parameters; TObjStringCollectable string class.Definition TObjString.h:28; nconst Int_t nDefinition legend1.C:16. Reimplemented in TCling, TMethodCall, TInterpreter, ROOT::R::TRIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObject.html:33047,error,error,33047,doc/master/classTObject.html,https://root.cern,https://root.cern/doc/master/classTObject.html,1,['error'],['error']
Availability,2 0; : 696 Minimum Test error found - save the configuration ; : 696 | 34.4357 31.1348 0.0201081 0.00181563 43733.9 0; : 697 Minimum Test error found - save the configuration ; : 697 | 34.0416 30.9812 0.0205543 0.00184744 42765.1 0; : 698 Minimum Test error found - save the configuration ; : 698 | 33.7716 30.3897 0.0201321 0.00181458 43673.9 0; : 699 | 33.1269 30.7769 0.0201928 0.00175872 43397.8 1; : 700 Minimum Test error found - save the configuration ; : 700 | 32.8076 30.1388 0.0201025 0.00181993 43757.5 0; : 701 | 32.6014 30.2991 0.0200398 0.0017563 43755.4 1; : 702 | 32.0925 30.8793 0.0200419 0.00175584 43749.1 2; : 703 Minimum Test error found - save the configuration ; : 703 | 31.9128 29.3224 0.0202722 0.00182152 43358.7 0; : 704 Minimum Test error found - save the configuration ; : 704 | 31.2876 29.167 0.0201013 0.00181585 43750.6 0; : 705 Minimum Test error found - save the configuration ; : 705 | 30.8198 28.9852 0.0201048 0.0018126 43734.4 0; : 706 Minimum Test error found - save the configuration ; : 706 | 30.3399 28.5636 0.0203047 0.00182247 43284.8 0; : 707 | 29.8899 28.5807 0.0200458 0.00176314 43757.3 1; : 708 | 29.6409 28.6883 0.0201432 0.0017637 43526.7 2; : 709 Minimum Test error found - save the configuration ; : 709 | 29.434 28.2 0.0201313 0.00182437 43699.3 0; : 710 | 28.7076 28.492 0.0200557 0.00176519 43738.5 1; : 711 Minimum Test error found - save the configuration ; : 711 | 28.4018 27.2754 0.0201013 0.00182194 43765.3 0; : 712 | 28.1436 28.1139 0.020041 0.00175734 43754.9 1; : 713 | 27.878 27.4183 0.0200281 0.0017564 43783.5 2; : 714 | 27.4734 27.8632 0.020054 0.00175612 43720.8 3; : 715 Minimum Test error found - save the configuration ; : 715 | 27.1251 26.6487 0.0201232 0.0018277 43726.6 0; : 716 | 26.6302 26.7712 0.0200343 0.00176196 43782.1 1; : 717 Minimum Test error found - save the configuration ; : 717 | 26.542 26.4691 0.020103 0.00182338 43764.7 0; : 718 Minimum Test error found - save the configuration ; : 718 | 25.9613 26.206 0.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:89839,error,error,89839,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"2 28 BRATISLAVA; SLOVAKIA. email:fyzimiro@savba.sk, fax:+421 7 54772479. The original code in C has been repackaged as a C++ class by R.Brun. The algorithms in this class have been published in the following; references:; [1] M.Morhac et al.: Background elimination methods for; multidimensional coincidence gamma-ray spectra. Nuclear; Instruments and Methods in Physics Research A 401 (1997) 113-; 132. [2] M.Morhac et al.: Efficient one- and two-dimensional Gold; deconvolution and its application to gamma-ray spectra; decomposition. Nuclear Instruments and Methods in Physics; Research A 401 (1997) 385-408. [3] M. Morhac et al.: Efficient algorithm of multidimensional; deconvolution and its application to nuclear data processing. Digital; Signal Processing, Vol. 13, No. 1, (2003), 144-171. [4] M.Morhac et al.: Identification of peaks in multidimensional; coincidence gamma-ray spectra. Nuclear Instruments and Methods in; Research Physics A 443(2000), 108-125. These NIM papers are also available as Postscript files from:. ftp://root.cern.ch/root/SpectrumDec.ps.gz; ftp://root.cern.ch/root/SpectrumSrc.ps.gz; ftp://root.cern.ch/root/SpectrumBck.ps.gz. Function Members (Methods); public:. TSpectrum3(); TSpectrum3(const TSpectrum3&); TSpectrum3(Int_t maxpositions, Float_t resolution = 1); virtual~TSpectrum3(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*Background(const TH1* hist, int niter, Option_t* option = ""goff""); const char*Background(float*** spectrum, Int_t ssizex, Int_t ssizey, Int_t ssizez, Int_t numberIterationsX, Int_t numberIterationsY, Int_t numberIterationsZ, Int_t direction, Int_t filterType); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum3.html:1645,avail,available,1645,root/html528/TSpectrum3.html,https://root.cern,https://root.cern/root/html528/TSpectrum3.html,4,['avail'],['available']
Availability,"2 28 BRATISLAVA; SLOVAKIA. email:fyzimiro@savba.sk, fax:+421 7 54772479. The original code in C has been repackaged as a C++ class by R.Brun. The algorithms in this class have been published in the following; references:; [1] M.Morhac et al.: Background elimination methods for; multidimensional coincidence gamma-ray spectra. Nuclear; Instruments and Methods in Physics Research A 401 (1997) 113-; 132. [2] M.Morhac et al.: Efficient one- and two-dimensional Gold; deconvolution and its application to gamma-ray spectra; decomposition. Nuclear Instruments and Methods in Physics; Research A 401 (1997) 385-408. [3] M. Morhac et al.: Efficient algorithm of multidimensional; deconvolution and its application to nuclear data processing. Digital; Signal Processing, Vol. 13, No. 1, (2003), 144-171. [4] M.Morhac et al.: Identification of peaks in multidimensional; coincidence gamma-ray spectra. Nuclear Instruments and Methods in; Research Physics A 443(2000), 108-125. These NIM papers are also available as Postscript files from:. ftp://root.cern.ch/root/SpectrumDec.ps.gz; ftp://root.cern.ch/root/SpectrumSrc.ps.gz; ftp://root.cern.ch/root/SpectrumBck.ps.gz. Function Members (Methods); public:. virtual~TSpectrum3(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*Background(const TH1* hist, Int_t niter, Option_t* option = ""goff""); const char*Background(Double_t*** spectrum, Int_t ssizex, Int_t ssizey, Int_t ssizez, Int_t numberIterationsX, Int_t numberIterationsY, Int_t numberIterationsZ, Int_t direction, Int_t filterType); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; const char*Deconvolution(Double_t*** source, const Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum3.html:1669,avail,available,1669,root/html602/TSpectrum3.html,https://root.cern,https://root.cern/root/html602/TSpectrum3.html,2,['avail'],['available']
Availability,2 43397.8 1; : 700 Minimum Test error found - save the configuration ; : 700 | 32.8076 30.1388 0.0201025 0.00181993 43757.5 0; : 701 | 32.6014 30.2991 0.0200398 0.0017563 43755.4 1; : 702 | 32.0925 30.8793 0.0200419 0.00175584 43749.1 2; : 703 Minimum Test error found - save the configuration ; : 703 | 31.9128 29.3224 0.0202722 0.00182152 43358.7 0; : 704 Minimum Test error found - save the configuration ; : 704 | 31.2876 29.167 0.0201013 0.00181585 43750.6 0; : 705 Minimum Test error found - save the configuration ; : 705 | 30.8198 28.9852 0.0201048 0.0018126 43734.4 0; : 706 Minimum Test error found - save the configuration ; : 706 | 30.3399 28.5636 0.0203047 0.00182247 43284.8 0; : 707 | 29.8899 28.5807 0.0200458 0.00176314 43757.3 1; : 708 | 29.6409 28.6883 0.0201432 0.0017637 43526.7 2; : 709 Minimum Test error found - save the configuration ; : 709 | 29.434 28.2 0.0201313 0.00182437 43699.3 0; : 710 | 28.7076 28.492 0.0200557 0.00176519 43738.5 1; : 711 Minimum Test error found - save the configuration ; : 711 | 28.4018 27.2754 0.0201013 0.00182194 43765.3 0; : 712 | 28.1436 28.1139 0.020041 0.00175734 43754.9 1; : 713 | 27.878 27.4183 0.0200281 0.0017564 43783.5 2; : 714 | 27.4734 27.8632 0.020054 0.00175612 43720.8 3; : 715 Minimum Test error found - save the configuration ; : 715 | 27.1251 26.6487 0.0201232 0.0018277 43726.6 0; : 716 | 26.6302 26.7712 0.0200343 0.00176196 43782.1 1; : 717 Minimum Test error found - save the configuration ; : 717 | 26.542 26.4691 0.020103 0.00182338 43764.7 0; : 718 Minimum Test error found - save the configuration ; : 718 | 25.9613 26.206 0.0200958 0.00181915 43771.6 0; : 719 Minimum Test error found - save the configuration ; : 719 | 25.6965 25.7845 0.0200932 0.00181887 43777.1 0; : 720 Minimum Test error found - save the configuration ; : 720 | 25.279 25.7029 0.0200856 0.00181582 43788.1 0; : 721 | 24.9296 25.8529 0.0200326 0.00176051 43782.6 1; : 722 | 24.8179 25.9725 0.0200485 0.0017542 43729.4 2; : 723 Minimum Test err,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:90229,error,error,90229,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"2 ; 763/* Power series for incomplete beta integral.; 764 Use when b*x is small and x not too close to 1. */; 765 ; 766double pseries( double a, double b, double x ); 767{; 768 double s, t, u, v, n, t1, z, ai;; 769 ; 770 ai = 1.0 / a;; 771 u = (1.0 - b) * x;; 772 v = u / (a + 1.0);; 773 t1 = v;; 774 t = u;; 775 n = 2.0;; 776 s = 0.0;; 777 z = kMACHEP * ai;; 778 while( std::abs(v) > z ); 779 {; 780 u = (n - b) * x / n;; 781 t *= u;; 782 v = t / (a + n);; 783 s += v;; 784 n += 1.0;; 785 }; 786 s += t1;; 787 s += ai;; 788 ; 789 u = a * log(x);; 790 if( (a+b) < kMAXSTIR && std::abs(u) < kMAXLOG ); 791 {; 792 t = gamma(a+b)/(gamma(a)*gamma(b));; 793 s = s * t * pow(x,a);; 794 }; 795 else; 796 {; 797 t = lgam(a+b) - lgam(a) - lgam(b) + u + std::log(s);; 798 if( t < kMINLOG ); 799 s = 0.0;; 800 else; 801 s = std::exp(t);; 802 }; 803 return(s);; 804}; 805 ; 806/*---------------------------------------------------------------------------*/; 807 ; 808 ; 809/*---------------------------------------------------------------------------*/; 810/* for evaluation of error function */; 811/*---------------------------------------------------------------------------*/; 812 ; 813static double erfP[] = {; 814 2.46196981473530512524E-10,; 815 5.64189564831068821977E-1,; 816 7.46321056442269912687E0,; 817 4.86371970985681366614E1,; 818 1.96520832956077098242E2,; 819 5.26445194995477358631E2,; 820 9.34528527171957607540E2,; 821 1.02755188689515710272E3,; 822 5.57535335369399327526E2; 823};; 824static double erfQ[] = {; 825/* 1.00000000000000000000E0,*/; 826 1.32281951154744992508E1,; 827 8.67072140885989742329E1,; 828 3.54937778887819891062E2,; 829 9.75708501743205489753E2,; 830 1.82390916687909736289E3,; 831 2.24633760818710981792E3,; 832 1.65666309194161350182E3,; 833 5.57535340817727675546E2; 834};; 835static double erfR[] = {; 836 5.64189583547755073984E-1,; 837 1.27536670759978104416E0,; 838 5.01905042251180477414E0,; 839 6.16021097993053585195E0,; 840 7.40974269950448939160E0,; 841 2.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:17616,error,error,17616,doc/master/SpecFuncCephes_8cxx_source.html,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html,1,['error'],['error']
Availability,"2 = new TH2F(""h2"",""h2"",40,-3,3,40,-3,3);; auto h3 = new TH2F(""h3"",""h3"",40,-3,3,40,-3,3);; auto h4 = new TH2F(""h4"",""h4"",40,-3,3,40,-3,3);; h1->SetBit(TH1::kNoStats);; for (Int_t i=0;i<5000;i++) {; double x,y;; gRandom->Rannor(x,y);; if(x>0 && y>0) h1->Fill(x,y,4);; if(x<0 && y<0) h2->Fill(x,y,3);; if(x>0 && y<0) h3->Fill(x,y,2);; if(x<0 && y>0) h4->Fill(x,y,1);; }; h1->Draw(""colz"");; h2->Draw(""col same"");; h3->Draw(""col same"");; h4->Draw(""col same"");; }; c#define c(i)Definition RSha256.hxx:101; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786. The option COL can be combined with the option POL:; {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol1->Fill(px,py);; }; hcol1->Draw(""COLZPOL"");; }. SinceROOT version 6.07/03:; A second rendering technique is also available with the COL2 and COLZ2 options.; These options provide potential performance improvements compared to the standard COL option. The performance comparison of the COL2 to the COL option depends on the histogram and the size of the rendering region in the current pad. In general, a small (approx. less than 100 bins per axis), sparsely populated TH2 will render faster with the COL option.; However, for larger histograms (approx. more than 100 bins per axis) that are not sparse, the COL2 option will provide up to 20 times performance improvements. For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude faster with the COL2 option.; The COL2 option will also scale its performance based on the size of the pixmap the histogram image is being rendered into. It also is much better optimized for sessions where the user is forwarding X11 windows through an ssh connection.; For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:47885,avail,available,47885,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['avail'],['available']
Availability,"2 are satisfied'. For unweighted weighted comparison; igood=1'There is a bin in the 1st histogram with less then 1 event'; igood=2'There is a bin in the 2nd histogram with less then 10 effective number of events'; igood=3'when the conditions for igood=1 and igood=2 are satisfied'. For weighted weighted comparison; igood=1'There is a bin in the 1st histogram with less then 10 effective number of events'; igood=2'There is a bin in the 2nd histogram with less then 10 effective number of events'; igood=3'when the conditions for igood=1 and igood=2 are satisfied' . [out]chi2chisquare of the test ; [out]ndfnumber of degrees of freedom (important, when both histograms have the same empty bins) ; [out]resnormalized residuals for further analysis . Definition at line 2067 of file TH1.cxx. ◆ Chisquare(). Double_t TH1::Chisquare ; (; TF1 * ; func, . Option_t * ; option = """" . ); const. virtual . Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ; Use option ""R"" for restricting the chisquare calculation to the given range of the function Use option ""L"" for using the chisquare based on the poisson likelihood (Baker-Cousins Chisquare) Use option ""P"" for using the Pearson chisquare based on the expected bin errors ; Definition at line 2496 of file TH1.cxx. ◆ Class(). static TClass * TH1::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TH1::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TH1::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 444 of file TH1.h. ◆ ClearUnderflowAndOverflow(). void TH1::ClearUnderflowAndOverflow ; (; ). virtual . Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:101026,error,error,101026,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['error'],['error']
Availability,"2 fBytesRead -= extra;; 1873 fgBytesRead -= extra;; 1874 n = 0;; 1875 }; 1876 curbegin = i < nbuf ? pos[i] : 0;; 1877 }; 1878 }; 1879 if (buf2) delete [] buf2;; 1880 fCacheRead = old;; 1881 return result;; 1882}; 1883 ; 1884////////////////////////////////////////////////////////////////////////////////; 1885/// Read buffer via cache.; 1886///; 1887/// Returns 0 if the requested block is not in the cache, 1 in case read via; 1888/// cache was successful, 2 in case read via cache failed.; 1889 ; 1890Int_t TFile::ReadBufferViaCache(char *buf, Int_t len); 1891{; 1892 Long64_t off = GetRelOffset();; 1893 if (fCacheRead) {; 1894 Int_t st = fCacheRead->ReadBuffer(buf, off, len);; 1895 if (st < 0); 1896 return 2; // failure reading; 1897 else if (st == 1) {; 1898 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1899 SetOffset(off + len);; 1900 return 1;; 1901 }; 1902 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1903 Seek(off);; 1904 } else {; 1905 // if write cache is active check if data still in write cache; 1906 if (fWritable && fCacheWrite) {; 1907 if (fCacheWrite->ReadBuffer(buf, off, len) == 0) {; 1908 SetOffset(off + len);; 1909 return 1;; 1910 }; 1911 // fOffset might have been changed via TFileCacheWrite::ReadBuffer(), reset it; 1912 SetOffset(off);; 1913 }; 1914 }; 1915 ; 1916 return 0;; 1917}; 1918 ; 1919////////////////////////////////////////////////////////////////////////////////; 1920/// Read the FREE linked list.; 1921///; 1922/// Every file has a linked list (fFree) of free segments.; 1923/// This linked list has been written on the file via WriteFree; 1924/// as a single data record.; 1925 ; 1926void TFile::ReadFree(); 1927{; 1928 // Avoid problem with file corruption.; 1929 if (fNbytesFree < 0 || fNbytesFree > fEND) {; 1930 fNbytesFree = 0;; 1931 return;; 1932 }; 1933 TKey *headerfree = new TKey(fSeekFree, fNbytesFree, this);; 1934 headerfree->ReadFile();; 1935 char *buffer = headerfree->Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:68142,failure,failure,68142,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['failure'],['failure']
Availability,"2 of file RuleFitAPI.h. ◆ VarImp(). void TMVA::RuleFitAPI::VarImp ; (; ). inline . Definition at line 221 of file RuleFitAPI.h. ◆ WelcomeMessage(). void TMVA::RuleFitAPI::WelcomeMessage ; (; ). welcome message ; Definition at line 76 of file RuleFitAPI.cxx. ◆ WriteAll(). Bool_t TMVA::RuleFitAPI::WriteAll ; (; ). protected . write all files read by rf_go.exe ; Definition at line 248 of file RuleFitAPI.cxx. ◆ WriteFloat(). Bool_t TMVA::RuleFitAPI::WriteFloat ; (; std::ofstream & ; f, . const Float_t * ; v, . Int_t ; n = 1 . ). inlineprotected . Definition at line 274 of file RuleFitAPI.h. ◆ WriteInt(). Bool_t TMVA::RuleFitAPI::WriteInt ; (; std::ofstream & ; f, . const Int_t * ; v, . Int_t ; n = 1 . ). inlineprotected . Definition at line 266 of file RuleFitAPI.h. ◆ WriteIntParms(). Bool_t TMVA::RuleFitAPI::WriteIntParms ; (; ). protected . write int params file ; Definition at line 264 of file RuleFitAPI.cxx. ◆ WriteLx(). Bool_t TMVA::RuleFitAPI::WriteLx ; (; ). protected . Save input variable mask. ; If the lx vector size is not the same as inputVars, resize it and fill it with 1 NOTE: Always set all to 1 if (fRFLx.size() != m_inputVars->size()) { ; Definition at line 291 of file RuleFitAPI.cxx. ◆ WriteProgram(). Bool_t TMVA::RuleFitAPI::WriteProgram ; (; ). protected . write command to rf_go.exe ; Definition at line 305 of file RuleFitAPI.cxx. ◆ WriteRealParms(). Bool_t TMVA::RuleFitAPI::WriteRealParms ; (; ). protected . write int params file ; Definition at line 275 of file RuleFitAPI.cxx. ◆ WriteRealVarImp(). Bool_t TMVA::RuleFitAPI::WriteRealVarImp ; (; ). protected . write the minimum importance to be considered ; Definition at line 333 of file RuleFitAPI.cxx. ◆ WriteRfOut(). Bool_t TMVA::RuleFitAPI::WriteRfOut ; (; ). protected . written by rf_go.exe; write rulefit output (rfout) ; Definition at line 347 of file RuleFitAPI.cxx. ◆ WriteRfStatus(). Bool_t TMVA::RuleFitAPI::WriteRfStatus ; (; ). protected . written by rf_go.exe; write rulefit status ; Definition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitAPI.html:12049,mask,mask,12049,doc/master/classTMVA_1_1RuleFitAPI.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitAPI.html,1,['mask'],['mask']
Availability,"2 of file TTree.cxx. ◆ IsA(). TClass * TTree::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 659 of file TTree.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 547 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; NoteThis function is overloaded in TChain. ; Reimplemented in TChain, and TTreeSQL.; Definition at line 6473 of file TTree.cxx. ◆ LoadTreeFriend(). Long64_t TTree::LoadTreeFriend ; (; Long64_t ; entry, . TTree * ; masterTree . ). virtual . Load entry on behalf of our master tree, we may use an index. ; Called by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:170858,error,error,170858,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['error'],['error']
Availability,"2 of file TTree.cxx. ◆ IsA(). TClass * TTree::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 705 of file TTree.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 587 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; NoteThis function is overloaded in TChain. ; Reimplemented in TChain, and TTreeSQL.; Definition at line 6473 of file TTree.cxx. ◆ LoadTreeFriend(). Long64_t TTree::LoadTreeFriend ; (; Long64_t ; entry, . TTree * ; masterTree . ). virtual . Load entry on behalf of our master tree, we may use an index. ; Called by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:173046,error,error,173046,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['error'],['error']
Availability,"2 void MasterToLocalVect(const Double_t *master, Double_t *local) const override; 433 {; 434 memcpy(local, master, 3 * sizeof(Double_t));; 435 }; 436 void MasterToLocalBomb(const Double_t *master, Double_t *local) const override; 437 {; 438 TGeoIdentity::MasterToLocal(master, local);; 439 }; 440 ; 441 const Double_t *GetTranslation() const override { return &kNullVector[0]; }; 442 const Double_t *GetRotationMatrix() const override { return &kIdentityMatrix[0]; }; 443 const Double_t *GetScale() const override { return &kUnitScale[0]; }; 444 void SavePrimitive(std::ostream &, Option_t * = """") override {}; 445 ; 446 ClassDefOverride(TGeoIdentity, 1) // identity transformation class; 447};; 448 ; 449////////////////////////////////////////////////////////////////////////////; 450// //; 451// TGeoHMatrix - Matrix class used for computing global transformations //; 452// Should NOT be used for node definition. An instance of this class //; 453// is generally used to pile-up local transformations starting from //; 454// the top level physical node, down to the current node. //; 455// //; 456////////////////////////////////////////////////////////////////////////////; 457 ; 458class TGeoHMatrix : public TGeoMatrix {; 459private:; 460 Double_t fTranslation[3]; // translation component; 461 Double_t fRotationMatrix[9]; // rotation matrix; 462 Double_t fScale[3]; // scale component; 463 ; 464public:; 465 TGeoHMatrix();; 466 TGeoHMatrix(const TGeoHMatrix &other) : TGeoHMatrix((TGeoMatrix &)other) {}; 467 TGeoHMatrix(const TGeoMatrix &matrix);; 468 TGeoHMatrix(const char *name);; 469 ~TGeoHMatrix() override;; 470 ; 471 TGeoHMatrix &operator=(const TGeoHMatrix &other) { return TGeoHMatrix::operator=((TGeoMatrix &)other); }; 472 TGeoHMatrix &operator=(const TGeoMatrix *other);; 473 TGeoHMatrix &operator=(const TGeoMatrix &other);; 474 TGeoHMatrix &operator*=(const TGeoMatrix &other);; 475 TGeoHMatrix operator*(const TGeoMatrix &other) const;; 476 Bool_t operator==(const TGeoMatrix",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoMatrix_8h_source.html:20610,down,down,20610,doc/master/TGeoMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8h_source.html,1,['down'],['down']
Availability,"2 }; 703#endif; 704 }; 705 }; 706#ifndef R__HAS_COCOA; 707 if (!gROOT->IsBatch() && !getenv(""DISPLAY"")) {; 708 Error(""SetDisplay"", ""Can't figure out DISPLAY, set it manually\n""; 709 ""In case you run a remote ssh session, restart your ssh session with:\n""; 710 ""=========> ssh -Y"");; 711 }; 712#endif; 713 }; 714}; 715 ; 716////////////////////////////////////////////////////////////////////////////////; 717/// Return system error string.; 718 ; 719const char *TUnixSystem::GetError(); 720{; 721 Int_t err = GetErrno();; 722 if (err == 0 && GetLastErrorString() != """"); 723 return GetLastErrorString();; 724 ; 725#if defined(R__SOLARIS) || defined (R__LINUX) || defined(R__AIX) || \; 726 defined(R__FBSD) || defined(R__OBSD) || defined(R__HURD); 727 return strerror(err);; 728#else; 729 if (err < 0 || err >= sys_nerr); 730 return Form(""errno out of range %d"", err);; 731 return sys_errlist[err];; 732#endif; 733}; 734 ; 735////////////////////////////////////////////////////////////////////////////////; 736/// Return cryptographic random number; 737/// Fill provided buffer with random values; 738/// Returns number of bytes written to buffer or -1 in case of error; 739 ; 740Int_t TUnixSystem::GetCryptoRandom(void *buf, Int_t len); 741{; 742#if defined(R__ARC4_STDLIB) || defined(R__ARC4_BSDLIB); 743 arc4random_buf(buf, len);; 744 return len;; 745#elif defined(R__GETRANDOM_CLIB); 746 return getrandom(buf, len, GRND_NONBLOCK);; 747#elif defined(R__USE_URANDOM); 748 std::ifstream urandom{""/dev/urandom""};; 749 if (!urandom); 750 return -1;; 751 urandom.read(reinterpret_cast<char *>(buf), len);; 752 return len;; 753#else; 754#error ""Reliable cryptographic random function not defined""; 755 return -1;; 756#endif; 757}; 758 ; 759////////////////////////////////////////////////////////////////////////////////; 760/// Return the system's host name.; 761 ; 762const char *TUnixSystem::HostName(); 763{; 764 if (fHostname == """") {; 765 char hn[64];; 766#if defined(R__SOLARIS); 767 sysinfo(SI_H",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:22255,error,error,22255,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['error'],['error']
Availability,"2 }; 9983 ; 9984 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {; 9985 mg_send_http_error(conn,; 9986 500,; 9987 ""Error: Cannot open file\nfopen(%s): %s"",; 9988 path,; 9989 strerror(ERRNO));; 9990 return;; 9991 }; 9992 ; 9993 fclose_on_exec(&filep->access, conn);; 9994 ; 9995 /* If ""Range"" request was made: parse header, send only selected part; 9996 * of the file. */; 9997 r1 = r2 = 0;; 9998 if ((range_hdr != NULL); 9999 && ((n = parse_range_header(range_hdr, &r1, &r2)) > 0) && (r1 >= 0); 10000 && (r2 >= 0)) {; 10001 /* actually, range requests don't play well with a pre-gzipped; 10002 * file (since the range is specified in the uncompressed space) */; 10003 if (filep->stat.is_gzipped) {; 10004 mg_send_http_error(; 10005 conn,; 10006 416, /* 416 = Range Not Satisfiable */; 10007 ""%s"",; 10008 ""Error: Range requests in gzipped files are not supported"");; 10009 (void)mg_fclose(; 10010 &filep->access); /* ignore error on read only file */; 10011 return;; 10012 }; 10013 conn->status_code = 206;; 10014 cl = (n == 2) ? (((r2 > cl) ? cl : r2) - r1 + 1) : (cl - r1);; 10015 mg_snprintf(conn,; 10016 NULL, /* range buffer is big enough */; 10017 range,; 10018 sizeof(range),; 10019 ""bytes ""; 10020 ""%"" INT64_FMT ""-%"" INT64_FMT ""/%"" INT64_FMT,; 10021 r1,; 10022 r1 + cl - 1,; 10023 filep->stat.size);; 10024 ; 10025#if defined(USE_ZLIB); 10026 /* Do not compress ranges. */; 10027 allow_on_the_fly_compression = 0;; 10028#endif; 10029 }; 10030 ; 10031 /* Do not compress small files. Small files do not benefit from file; 10032 * compression, but there is still some overhead. */; 10033#if defined(USE_ZLIB); 10034 if (filep->stat.size < MG_FILE_COMPRESSION_SIZE_LIMIT) {; 10035 /* File is below the size limit. */; 10036 allow_on_the_fly_compression = 0;; 10037 }; 10038#endif; 10039 ; 10040 /* Standard CORS header */; 10041 cors_orig_cfg = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 10042 origin_hdr = mg_get_header(conn, ""Origin"");; 10043 if (cors_orig_cfg && *cors_orig_c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:287061,error,error,287061,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"2, 0.3, 0.4, 0.5};; 289 double ey[] = {1, 0.5, 1, 0.5, 1};; 290 auto ge = new TGraphErrors(5, x, y, ex, ey);; 291 ge->SetTitle(""Errors as a band"");; 292 ge->SetFillColor(4);; 293 ge->SetFillStyle(3010);; 294 ge->Draw(""a3"");; 295}; 296End_Macro; 297 ; 298The option ""4"" is similar to the option ""3"" except that the band; 299is smoothed. As the following picture shows, this option should be; 300used carefully because the smoothing algorithm may show some (huge); 301""bouncing"" effects. In some cases it looks nicer than option ""3""; 302(because it is smooth) but it can be misleading.; 303 ; 304Begin_Macro(source); 305{; 306 auto c42 = new TCanvas(""c42"",""c42"",200,10,600,400);; 307 double x[] = {0, 1, 2, 3, 4};; 308 double y[] = {0, 2, 4, 1, 3};; 309 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 310 double ey[] = {1, 0.5, 1, 0.5, 1};; 311 auto ge = new TGraphErrors(5, x, y, ex, ey);; 312 ge->SetTitle(""Errors as a smooth band"");; 313 ge->SetFillColor(6);; 314 ge->SetFillStyle(3005);; 315 ge->Draw(""a4"");; 316}; 317End_Macro; 318 ; 319The following example shows how the option ""[]"" can be used to superimpose; 320systematic errors on top of a graph with statistical errors.; 321 ; 322Begin_Macro(source); 323{; 324 auto c43 = new TCanvas(""c43"",""c43"",200,10,600,400);; 325 c43->DrawFrame(0., -0.5, 6., 2);; 326 ; 327 double x[5] = {1, 2, 3, 4, 5};; 328 double zero[5] = {0, 0, 0, 0, 0};; 329 ; 330 // data set (1) with stat and sys errors; 331 double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; 332 double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 333 double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};; 334 ; 335 // data set (2) with stat and sys errors; 336 double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; 337 double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 338 double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};; 339 ; 340 // Now draw data set (1); 341 ; 342 // We first have to draw it only with the stat errors; 343 auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; 344 graph1->SetMarkerSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:12522,error,errors,12522,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,2,['error'],['errors']
Availability,"2,y2right up corner ; [in]nx,nyarray size ; [in]icarray . Reimplemented from TVirtualX.; Definition at line 244 of file TGQuartz.mm. ◆ DrawFillArea(). void TGQuartz::DrawFillArea ; (; Int_t ; n, . TPoint * ; xy . ). overridevirtual . Fills area described by the polygon. ; Parameters. [in]nnumber of points ; [in]xylist of points. xy(2,n) . Reimplemented from TVirtualX.; Definition at line 186 of file TGQuartz.mm. ◆ DrawFTGlyphIntoPixmap(). void TGQuartz::DrawFTGlyphIntoPixmap ; (; void * ; pixmap, . FT_Bitmap * ; source, . ULong_t ; fore, . ULong_t ; back, . Int_t ; bx, . Int_t ; by . ). private . Definition at line 916 of file TGQuartz.mm. ◆ DrawLine() [1/2]. void TGCocoa::DrawLine ; (; Drawable_t ; id, . GContext_t ; gc, . Int_t ; x1, . Int_t ; y1, . Int_t ; x2, . Int_t ; y2 . ). overridevirtual . Uses the components of the specified GC to draw a line between the specified set of points (x1, y1) and (x2, y2). ; GC components in use: function, plane-mask, line-width, line-style, cap-style, fill-style, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.; GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, tile-stipple-y-origin, dash-offset, dash-list. (see also the GCValues_t structure) ; Reimplemented from TGCocoa.; Definition at line 172 of file TGCocoa.mm. ◆ DrawLine() [2/2]. void TGQuartz::DrawLine ; (; Int_t ; x1, . Int_t ; y1, . Int_t ; x2, . Int_t ; y2 . ). overridevirtual . Draws a line. ; Parameters. [in]x1,y1begin of line ; [in]x2,y2end of line . Reimplemented from TVirtualX.; Definition at line 252 of file TGQuartz.mm. ◆ DrawPolyLine(). void TGQuartz::DrawPolyLine ; (; Int_t ; n, . TPoint * ; xy . ). overridevirtual . Draws a line through all points in the list. ; Parameters. [in]nnumber of points ; [in]xylist of points . Reimplemented from TVirtualX.; Definition at line 300 of file TGQuartz.mm. ◆ DrawPolyMarker(). void TGQuartz::DrawPolyMarker ; (; Int_t ; n, . TPoint * ; xy . ). overridevirtual . Draws ""n""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGQuartz.html:56118,mask,mask,56118,doc/master/classTGQuartz.html,https://root.cern,https://root.cern/doc/master/classTGQuartz.html,2,['mask'],['mask']
Availability,"2.21831, denominator=wrap_pdf_Int[pTV]=89722.5; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.44258 cHl3=4.96668 cHq3=0.0273884; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; ... (remaining 14 messages suppressed); ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:13241,recover,recover,13241,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
