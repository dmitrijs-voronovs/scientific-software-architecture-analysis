quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Integrability,"X}gtest${CMAKE_STATIC_LIBRARY_SUFFIX}; AND EXISTS ${UNITTEST_DIR}/CMakeLists.txt); add_subdirectory(${UNITTEST_DIR} utils/unittest); endif(); else(); # Seek installed Lit.; find_program(LLVM_LIT ""lit.py"" ${LLVM_MAIN_SRC_DIR}/utils/lit; DOC ""Path to lit.py""); endif(). if(LLVM_LIT); # Define the default arguments to use with 'lit', and an option for the user; # to override.; set(LIT_ARGS_DEFAULT ""-sv""); if (MSVC OR XCODE); set(LIT_ARGS_DEFAULT ""${LIT_ARGS_DEFAULT} --no-progress-bar""); endif(); set(LLVM_LIT_ARGS ""${LIT_ARGS_DEFAULT}"" CACHE STRING ""Default options for lit""). # On Win32 hosts, provide an option to specify the path to the GnuWin32 tools.; if( WIN32 AND NOT CYGWIN ); set(LLVM_LIT_TOOLS_DIR """" CACHE PATH ""Path to GnuWin32 tools""); endif(); else(); set(LLVM_INCLUDE_TESTS OFF); endif(); endif(). set( CLING_BUILT_STANDALONE 1 ); set(BACKEND_PACKAGE_STRING ""LLVM ${LLVM_PACKAGE_VERSION}""); elseif(DEFINED CLING_ROOT_BUILD); message(STATUS ""Building Cling as part of ROOT""); # we do not need to include LLVMConfig again, already done; else(); message(STATUS ""Building Cling as part of LLVM""); set(BACKEND_PACKAGE_STRING ""${PACKAGE_STRING}""); # Try finding the LLVMConfig.cmake if we build against prebuilt LLVM; set(LLVM_CMAKE_PATH ""${LLVM_BINARY_DIR}/lib${LLVM_LIBDIR_SUFFIX}/cmake/llvm""); set(LLVMCONFIG_FILE ""${LLVM_CMAKE_PATH}/LLVMConfig.cmake""); if(EXISTS ${LLVMCONFIG_FILE}); list(APPEND CMAKE_MODULE_PATH ""${LLVM_CMAKE_PATH}""); include(${LLVMCONFIG_FILE}); endif(); if (NOT CLANG_INCLUDE_DIRS); set (CLANG_INCLUDE_DIRS ""${LLVM_MAIN_SRC_DIR}/tools/clang/include""); if (NOT EXISTS ${CLANG_INCLUDE_DIRS}); # Otherwise assume the monorepo layout.; set (CLANG_INCLUDE_DIRS ${LLVM_MAIN_SRC_DIR}/../clang/include ); endif(); set (CLANG_INCLUDE_DIRS ""${CLANG_INCLUDE_DIRS}""; ""${LLVM_BINARY_DIR}/tools/clang/include""); endif(); if (NOT LLVM_INCLUDE_DIRS); set (LLVM_INCLUDE_DIRS ""${LLVM_MAIN_SRC_DIR}/include"" ""${LLVM_BINARY_DIR}/include""); endif(); endif(). if( NOT ""NVPTX"" IN_LIST LLV",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/CMakeLists.txt:3622,message,message,3622,interpreter/cling/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/CMakeLists.txt,2,['message'],['message']
Integrability,"YS/test` in `test/stressMathCore.cxx`, allowing ROOT to find the header at runtime, whether interpreted; (`R__ADD_INCLUDE_PATH`) or compiled (`TROOT::AddExtraInterpreterArgs({""-I...""})` before interpreter construction). If you called `ROOT_GENERATE_DICTIONARY(Dict ${CMAKE_CURRENT_SOURCE_DIR}/subdir/Header1.h LINKDEF LinkDef.h)` then update that; call to `ROOT_GENERATE_DICTIONARY(Dict Header1.h OPTIONS -I subdir LINKDEF LinkDef.h)` *if* the header is usually included as; `#include ""Header1.h""`, or to `ROOT_GENERATE_DICTIONARY(Dict subdir/Header1.h LINKDEF LinkDef.h)` *if* the header is usually; included as `#include ""subdir/Header1.h""`. I.e. the general rule is: pass to `ROOT_GENERATE_DICTIONARY` (or; `ROOT_STANDARD_LIBRARY_PACKAGE`) the spelling as `#include`ed. As an important side-effect, `ROOT_GENERATE_DICTIONARY` and thus `ROOT_STANDARD_LIBRARY_PACKAGE` now *require* the header to; be found at configuration time. We have seen too many cases where the header location was mis-stated, and as a consequence,; CMake did not generate the proper dependencies. If the header should not be taken into account for dependencies and / or if; the header will not be found (e.g. the standard library's `vector`) please pass the header through the `NODEPHEADERS` option; to `ROOT_GENERATE_DICTIONARY` or `ROOT_STANDARD_LIBRARY_PACKAGE`. We believe that this simplification / regularization of behavior, and the additional checks are worth the possible changes; on the user side. ## PyROOT. If the fix or new feature is a pythonization related to a C++ class, the change is added to the respective section above. ### Current PyROOT. - Fix compatibility with Python3.7 (ROOT-9922, ROOT-9871, ROOT-9809); - Fix lookup for templated methods (ROOT-9789); - Fix lookup for templated free functions (ROOT-9836). ### Experimental PyROOT. - All pythonisations from current PyROOT already migrated (`TTree` and subclasses, `TDirectory` and subclasses,; `TCollection` and subclasses, `TObject`, `TClass`, `TS",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:25478,depend,dependencies,25478,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['depend'],['dependencies']
Integrability,"[""-""], ""fms-extensions"">,; Visibility<[ClangOption, CC1Option]>,; MarshallingInfoFlag<LangOpts<""MicrosoftExt"">>,; ImpliedByAnyOf<[fms_compatibility.KeyPath], ""true"">;. **Condition**. The option is parsed only if the expression in ``ShouldParseIf`` evaluates to; true. .. code-block:: text. def fopenmp_enable_irbuilder : Flag<[""-""], ""fopenmp-enable-irbuilder"">,; Visibility<[ClangOption, CC1Option]>,; MarshallingInfoFlag<LangOpts<""OpenMPIRBuilder"">>,; ShouldParseIf<fopenmp.KeyPath>;. The Lexer and Preprocessor Library; ==================================. The Lexer library contains several tightly-connected classes that are involved; with the nasty process of lexing and preprocessing C source code. The main; interface to this library for outside clients is the large ``Preprocessor``; class. It contains the various pieces of state that are required to coherently; read tokens out of a translation unit. The core interface to the ``Preprocessor`` object (once it is set up) is the; ``Preprocessor::Lex`` method, which returns the next :ref:`Token <Token>` from; the preprocessor stream. There are two types of token providers that the; preprocessor is capable of reading from: a buffer lexer (provided by the; :ref:`Lexer <Lexer>` class) and a buffered token stream (provided by the; :ref:`TokenLexer <TokenLexer>` class). .. _Token:. The Token class; ---------------. The ``Token`` class is used to represent a single lexed token. Tokens are; intended to be used by the lexer/preprocess and parser libraries, but are not; intended to live beyond them (for example, they should not live in the ASTs). Tokens most often live on the stack (or some other location that is efficient; to access) as the parser is running, but occasionally do get buffered up. For; example, macro definitions are stored as a series of tokens, and the C++; front-end periodically needs to buffer tokens up for tentative parsing and; various pieces of look-ahead. As such, the size of a ``Token`` matters. On a; 32-bit s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:44153,interface,interface,44153,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['interface'],['interface']
Integrability,[#9594](https://github.com/root-project/root/issues/9594)] - Systematic build failure of ROOT master in the LCG DEBUG builds since Jan 15th; * [[#9524](https://github.com/root-project/root/issues/9524)] - Failure to build/run when MACOSX_DEPLOYMENT_TARGET is set to 11 or higher; * [[#9514](https://github.com/root-project/root/issues/9514)] - Printed SVG image contains newline cutting through XML tags; * [[#9489](https://github.com/root-project/root/issues/9489)] - [RF] Cannot turn off useless messages with RooMCStudy unbinned fits + Progress bar would be better.; * [[#9292](https://github.com/root-project/root/issues/9292)] - Integer overflow in TTreeCache::FillBuffer; * [[#8959](https://github.com/root-project/root/issues/8959)] - `ninja clean` does not remove `modules.idx`; * [[#8952](https://github.com/root-project/root/issues/8952)] - Make hadd return a non-zero exit code when encountering a corrupted file; * [[#8942](https://github.com/root-project/root/issues/8942)] - cannot buid the dependent project; * [[#8794](https://github.com/root-project/root/issues/8794)] - [TGNumberEntry] centiseconds; * [[#8720](https://github.com/root-project/root/issues/8720)] - Apply TChain::SetImplicitMT() to underlying trees; * [[#8639](https://github.com/root-project/root/issues/8639)] - (RDataFrame) AsNumpy returns Boolean branches as 'object' dtype numpy arrays; * [[#8582](https://github.com/root-project/root/issues/8582)] - TThreadTimer behavior; * [[#8581](https://github.com/root-project/root/issues/8581)] - [ntuple] RNTupleModel columns ownership issue; * [[#8517](https://github.com/root-project/root/issues/8517)] - Add integer support to TVectorT; * [[#8494](https://github.com/root-project/root/issues/8494)] - cling crashes on conditional parameter in template; * [[#8260](https://github.com/root-project/root/issues/8260)] - Build system cannot detect version of oneTBB; * [[#8148](https://github.com/root-project/root/issues/8148)] - Document TMethodCall class limitations; *,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:46660,depend,dependent,46660,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['depend'],['dependent']
Integrability,"[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are verified. It is the; responsibility of the programmer to ensure that this verification was indeed; correct. Please note that `csa_mark_sanitized` function is only declared and; used during Clang Static Analysis and skipped in (production) builds. Further examples of injection vulnerabilities this checker can find. .. code-block:: c. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data used as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data used as buffer size; }. There are built-in sources, propagations and sinks even if no external taint; configuration is provided. Default sources:; ``_IO_getc``, ``fdopen``, ``fopen``, ``freopen``, ``get_current_dir_name``,; ``getch``, ``getchar``, ``getchar_unlocked``, ``getwd``, ``getcwd``,; ``getgroups``, ``gethostname``, ``getlogin``, ``getlogin_r``, ``getna",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:70225,inject,injection,70225,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['inject'],['injection']
Integrability,"[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; ```. ### Wrapper Functions. To facilitate the user to insert their own type of function in the needed function interface, helper classes, wrapping the user interface in the; `ROOT::Math` function interfaces are provided.; this will avoid the user to re-implement dedicated function classes, following the code example shown in the previous paragraphs. There is one possible wrapper for every interface explained in the previous section.; The following table indicates the wrapper for the most basic ones:. | **Interface**| **Function Wrapper** |; |------------------------------------------|------------------------|; | `ROOT::Math::IBaseFunctionOneDim` | `ROOT::Math::Functor1D` |; | `ROOT::Math::IGradientFunctionOneDim` | `ROOT::Math::GradFunctor1D` |; | `ROOT::Math::IBaseFunctionMultiDim` | `ROOT::Math::Functor` |; | `ROOT::Math::IGradientFunctionMultiDim` | `ROOT::Math::GradFunctor` |. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C function of type `double ()(double )`.; * Any C++ callable object implementation `double operator()( double )`.; * A class member function with the correct signature like `double Foo::Eval(double )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. Example:. ```{.cpp}; #include ""Math/Functor.h"". class MyFunction1D {. public:. double operator()(double x) const {; return x*x;; }. double Eval(double x) const { return x+x; }; };. double freeFunction1D(double x ) {; return 2*x;; }. int main(); {; // wrapping a free function; ROOT::Math::Functor1D f1(&freeFunction1D);. MyFunction1D myf1;. // wrapping a function object implementing operator(); ROOT::Math::Functor1D f2(myf1);. // wrapping a class member function; ROOT::Math::Functor1D f3(&myf1,&MyFunction1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:42910,wrap,wrapper,42910,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['wrap'],['wrapper']
Integrability,"[2] - fVertex[3][1]`. 20. **`tree->Draw(""fMatrix[ ][2] - fVertex[ ][ ]"")`**. This is similar to case 19. Twelve values are selected (4x3) from each; entry:. `fMatrix[0][2] - fVertex[0][0]`. `fMatrix[0][2] - fVertex[0][1]`. `fMatrix[0][2] - fVertex[0][2]`. `fMatrix[1][2] - fVertex[1][0]`. `fMatrix[1][2] - fVertex[1][1]`. `fMatrix[1][2] - fVertex[1][2]`. `fMatrix[2][2] - fVertex[2][0]`. `fMatrix[2][2] - fVertex[2][1]`. `fMatrix[2][2] - fVertex[2][2]`. `fMatrix[3][2] - fVertex[3][0]`. `fMatrix[3][2] - fVertex[3][1]`. `fMatrix[3][2] - fVertex[3][2]`. 21. **`tree->Draw(""fMatrix[ ][ ] - fVertex[ ][ ]"")`**. This is the same as case 15. The first dimension minimum is 4 (from; `fMatrix`), and the second dimension minimum is 3 (from `fVertex`).; Twelve values are selected from each entry. 22. **`tree->Draw(""fClosestDistance"")`**. This event data member `fClosestDistance` is a variable length array:. `Float_t *fClosestDistance; //[fNvertex]`. This command selects all elements, but the number per entry depends on; the number of vertices of that entry. 23. **`tree->Draw(""fClosestDistance[fNvertex/2]"")`**. With this command the element at `fNvertex/2` of the; `fClosestDistance `array is selected. Only one per entry is selected. 24. **`tree->Draw(""sqrt(fPx*fPx + fPy*fPy + fPz*fPz)"")`**. This command shows the use of a mathematical expression. It draws the; square root of the sum of the product. 25. **`tree->Draw(""TMath::BreitWigner(fPx,3,2)"")`**. The formula can contains call to a function that takes numerical; arguments and returns a numerical value. The function needs to be; declared to the dictionary and need to be available from the global; namespace. In particular, global functions and public static member; functions can be called. 26. **`tree->Draw(""fEvtHdr.fEvtNum"",""fType==""type1"" "")`**. You can compare strings, using the symbols == and !=, in the first two; parameters of the `Draw` command (`TTreeFormula`). In this case,; the event number for ‘type1' events is plotted. 27.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:85175,depend,depends,85175,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['depend'],['depends']
Integrability,"[MVA::HMatrix] [MVA::Fisher] [MVA::PDERS] [MVA::FDA] [MVA::LD] [MVA::SVM] [MVA::CFMlpANN] [MVA::KNN] [MVA::BDT] [MVA::Boost] [MVA::RuleFit] [MVA::Likelihood] [MVA::MLP] [MVA::Cuts] [MVA::PDEFoam] [MVA::TMlpANN]. [Fitter_SA] [Fitter_MC] [Fitter_Minuit] [Fitter_GA]. [DataSetFactory] [PDF] [Factory]. Configuration options for MVA method :. Configuration options reference for MVA method: HMatrix. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). Configuration options for MVA method :. Configuration options reference for MVA method: Fisher. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAP",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:2130,message,message,2130,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['message'],['message']
Integrability,"[digit]``"" sequences to specify where and how; arguments to the diagnostic are formatted. Arguments to the diagnostic are numbered according to how they are specified by; the C++ code that :ref:`produces them <internals-producing-diag>`, and are; referenced by ``%0`` .. ``%9``. If you have more than 10 arguments to your; diagnostic, you are doing something wrong :). Unlike ``printf``, there is no; requirement that arguments to the diagnostic end up in the output in the same; order as they are specified, you could have a format string with ""``%1 %0``""; that swaps them, for example. The text in between the percent and digit are; formatting instructions. If there are no instructions, the argument is just; turned into a string and substituted in. Here are some ""best practices"" for writing the English format string:. * Keep the string short. It should ideally fit in the 80 column limit of the; ``DiagnosticKinds.td`` file. This avoids the diagnostic wrapping when; printed, and forces you to think about the important point you are conveying; with the diagnostic.; * Take advantage of location information. The user will be able to see the; line and location of the caret, so you don't need to tell them that the; problem is with the 4th argument to the function: just point to it.; * Do not capitalize the diagnostic string, and do not end it with a period.; * If you need to quote something in the diagnostic string, use single quotes. Diagnostics should never take random English strings as arguments: you; shouldn't use ""``you have a problem with %0``"" and pass in things like ""``your; argument``"" or ""``your return value``"" as arguments. Doing this prevents; :ref:`translating <internals-diag-translation>` the Clang diagnostics to other; languages (because they'll get random English words in their otherwise; localized diagnostic). The exceptions to this are C/C++ language keywords; (e.g., ``auto``, ``const``, ``mutable``, etc) and C/C++ operators (``/=``).; Note that things like ""po",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:8189,wrap,wrapping,8189,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['wrap'],['wrapping']
Integrability,"[f23]: figures/TH1F_Example.png ""f23""; <a name=""f23""></a>. ![Visualisation of a histogram filled with exponentially distributed,; random numbers. \label{f23}][f23]. We use yet another new feature of ROOT to fill this histogram with data,; namely pseudo-random numbers generated with the method `TF1::GetRandom`,; which in turn uses an instance of the ROOT class `TRandom` created when; ROOT is started. Data is entered in the histogram at line *4* using the; method `TH1F::Fill` in a loop construct. As a result, the histogram is; filled with 1000 random numbers distributed according to the defined; function. The histogram is displayed using the method `TH1F::Draw()`.; You may think of this example as repeated measurements of the life time; of a quantum mechanical state, which are entered into the histogram,; thus giving a visual impression of the probability density distribution.; The plot is shown in Figure [2.3](#f23). Note that you will not obtain an identical plot when executing the lines; above, depending on how the random number generator is initialised. The class `TH1F` does not contain a convenient input format from plain; text files. The following lines of `C++` code do the job. One number per; line stored in the text file ""expo.dat"" is read in via an input stream; and filled in the histogram until end of file is reached. ``` {.cpp}; root [1] TH1F h(""h"",""example histogram"",100,0.,5.);; root [2] ifstream inp; double x;; root [3] inp.open(""expo.dat"");; root [4] while (inp >> x) { h.Fill(x); }; root [5] h.Draw();; root [6] inp.close();; ```. Histograms and random numbers are very important tools in statistical; data analysis, a whole chapter will be dedicated to this topic. ## Interactive ROOT ##. Look at one of your plots again and move the mouse across. You will; notice that this is much more than a static picture, as the mouse; pointer changes its shape when touching objects on the plot. When the; mouse is over an object, a right-click opens a pull-down menu dis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:12395,depend,depending,12395,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['depend'],['depending']
Integrability,"[tree]` indicates a; change to TTree, `[RF]` indicates a change to RooFit). If you are unsure about which scope tags to use, we are happy to; point you in the right direction! See also the [commit log](https://github.com/root-project/root/commits/master/) for; examples. The summary itself should not exceed 50 characters (excluding the scope tag), be meaningful (i.e., it; describes the change) and should be written in the; [present imperative mood](https://git.kernel.org/pub/scm/git/git.git/tree/Documentation/SubmittingPatches?id=HEAD#n239); (e.g. `Add this awesome feature` instead of `Adds this awesome feature` or `Added this awesome feature`). The commit message that follow the summary can be used to provide more context to the change.; It should describe the **why**, rather than the **what** and **how** (we can gather this from the commit summary and the; change diff, respectively).; The commit message should be wrapped at 72 characters. > [!TIP]; > We provide a commit message template to help with following the above guidelines. It can be found in the root of this; > repository as [`.git-commit-template`](https://github.com/root-project/root/blob/master/.git-commit-template),; > and can be set to automatically be used for every commit with the following command:; > ```sh; > $ git config commit.template .git-commit-template; > ```. ## Your Pull Request. > [!NOTE]; > For the mechanics on how to create pull requests, please visit; > [this page](https://root.cern/for_developers/creating_pr). The title of your PR follows the same principle as the commit summary. If your PR only involves one commit, you can; reuse this summary. For non-functional changes (e.g. to the documentation) or changes for which you want to; **temporarily** prevent Jenkins from being triggered (e.g., for a draft PR), use `[skip-CI]` as the first tag.; Note that for functional changes this tag needs to be removed and it has to pass the CI before merging to ensure; the change does not break anythi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md:3527,message,message,3527,CONTRIBUTING.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md,1,['message'],['message']
Integrability,"\; Jakob Blomer, CERN/SFT,\; Brian Bockelman, Nebraska,\; Rene Brun, CERN/SFT,\; Philippe Canal, FNAL,\; Javier Cervantes Villanueva, CERN/SFT,\; Olivier Couet, CERN/SFT,\; Alexandra Dobrescu, CERN/SFT,\; Giulio Eulisse, CERN/ALICE,\; Gerri Ganis, CERN/SFT,\; Andrei Gheata, CERN/SFT,\; Enrico Guiraud, CERN/SFT,\; Stephan Hageboeck, CERN/SFT,\; Jan Knedlik, GSI,\; Sergey Linev, GSI,\; Pere Mato, CERN/SFT,\; Lorenzo Moneta, CERN/SFT,\; Alja Mrak-Tadel, UCSD/CMS,\; Axel Naumann, CERN/SFT,\; Vincenzo Eduardo Padulano, Bicocca/SFT,\; Danilo Piparo, CERN/SFT,\; Fons Rademakers, CERN/SFT,\; Henry Schreiner, Princeton,\; Oksana Shadura, Nebraska,\; Simon Spies, GSI,\; Yuka Takahashi, Princeton and CERN/SFT,\; Enric Tejedor Saavedra, CERN/SFT,\; Matevz Tadel, UCSD/CMS,\; Vassil Vassilev, Princeton/CMS,\; Wouter Verkerke, NIKHEF/Atlas,\; Zhe Zhang, Nebraska,\; Stefan Wunsch, CERN/SFT. ## Deprecation and Removal. ### Deprecated packages. The Virtual Monte Carlo (VMC) interfaces have been deprecated for this release; and will be removed in a future release. It is no longer built by default, but; can still be enabled with the option `-Dvmc=ON` in the CMake configuration phase.; A standalone version of VMC is being developed at [https://github.com/vmc-project/vmc](https://github.com/vmc-project/vmc); to replace the deprecated version in ROOT. ### Removed packages. Support for the following optional components of ROOT has been removed:. * afdsmgrd (Dataset manager for PROOF-based analysis facilities); * bonjour (Avahi/Bonjour/Zeroconf); * castor (CERN Advanced STORage manager); * geocad (OpenCascade); * globus (Globus authentication); * hdfs (Hadoop Distributed File System); * krb5 (Kerberos 5 authentication); * ldap (OpenLDAP authentication); * memstat (legacy memory statistics utility); * qt, qtgsi, qtroot (Qt4-based GUI components); * rfio (Remote File IO for CASTOR); * table (libTable contrib library). In addition, the following deprecated parts of ROOT components have been; re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:1363,interface,interfaces,1363,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['interface'],['interfaces']
Integrability,"\addtogroup tutorial_FOAM. @{. ### What is FOAM ?. FOAM is simplified version of multi-dimensional general; purpose Monte Carlo event generator (integrator) with hyper-cubical; ""foam of cells"". Certain features of full version of FOAM are omitted.; mFOAM is intended as an easy to use tool for MC; simulation/integration in few dimensions. It relies heavily on ROOT package,; borrowing persistency of classes from ROOT. mFOAM can be easily used from; the ROOT shell. For more difficult problems the full FOAM may be better. ### How to run application programs ?. The application program can be run in two modes: it can be simply; interpreted by CLING or compiled. The first method is simpler but; results in slower execution. The second method employs ACLiC -; The Automatic Compiler of Libraries, which automatizes the; process of compilation and linking. In $(ROOTSYS)/tutorials there are 3 demonstration programs:. #### foam_kanwa.C; is a simple example how to run FOAM in interactive; mode. To run this macro issue the following simple command from the; Linux shell:. ```; root foam_kanwa.C; ```. or from CLING:. ```; root [0] .x foam_kanwa.C; ```. Simulation will start and graphical canvas with plot; of the distribution function appear. In this example; we defined the distribution function simply as a global; function function Camel2. #### foam_demo.C; shows usage of FOAM in compiled mode, which is; the preferred method. The integrand function is defined; now as a Density method from class TFDISTR inheriting from; abstract class TFoamIntegrand. User can modify interface to; integrand function according to their needs but they should; always remember to define Density method which provides the; density distribution.; Enter CLING interpreter and type:. ```; root [0] gSystem->Load(""libFoam.so""); root [1] .x foam_demo.C+; ```. to load FOAM library, compile and execute macro foam_demo.C.; A shared object foam_demo_C.so is created in the current; directory. At the end of exploration ph",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/foam/index.md:145,integrat,integrator,145,tutorials/foam/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/foam/index.md,2,['integrat'],"['integration', 'integrator']"
Integrability,"\addtogroup tutorial_dataframe. @{. [RDataFrame](classROOT_1_1RDataFrame.html) offers a high level interface for the analysis of data stored in [TTree](classTTree.html)s, [CSV files](classROOT_1_1RDF_1_1RCsvDS.html) and [other data formats](classROOT_1_1RDF_1_1RDataSource.html). In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available on their machines transparently. In a nutshell:; ~~~{.cpp}; ROOT::EnableImplicitMT(); // Enable ROOT's implicit multi-threading; ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; auto histoA = d.Histo1D(""Branch_A""); // Book the filling of a histogram; auto histoB = d.Histo1D(""Branch_B""); // Book the filling of another histogram; // Data processing is triggered by the next line, which accesses a booked result for the first time; // All booked results are evaluated during the same parallel event loop.; histoA->Draw(); // <-- event loop runs here!; histoB->Draw(); // HistoB has already been filled, no event loop is run here; ~~~. Explore the examples below or go to [RDataFrame's user guide](classROOT_1_1RDataFrame.html). @}",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/index.md:99,interface,interface,99,tutorials/dataframe/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/dataframe/index.md,1,['interface'],['interface']
Integrability,"\addtogroup tutorial_legacy. @{. Some of ROOT's tutorials demonstrate interfaces that are not recommended anymore, because; ROOT or C++ itself now offer superior ones. These have been moved here ""for the record"". @}; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/legacy/index.md:70,interface,interfaces,70,tutorials/legacy/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/legacy/index.md,1,['interface'],['interfaces']
Integrability,"\defgroup Core Core ROOT classes; \brief The Core classes of ROOT.; \defgroup Base Base ROOT classes; \ingroup Core; \brief The Base classes of ROOT. The base classes of the ROOT system provide the core of the system. They; are available to all other classes. They range from a set of abstract; interfaces (TVirtualXXXXX classes), to a wide range of basic utility; classes providing basic services like strings, regular expression,; timers, date/time, md5 checksumming, signal/slots event handling,; plugin handler, run-config resource processor, etc. etc. \defgroup StdExt std Extension classes; \brief Extension classes within libCore to backport or complement missing std:: features. \defgroup Parallelism Parallelized classes; \brief Classes implement parallelism within ROOT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/doc/index.md:295,interface,interfaces,295,core/base/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/doc/index.md,1,['interface'],['interfaces']
Integrability,"\defgroup Geometry_gdml GDML tools; \ingroup Geometry; \brief GDML tools for geometry classes. The `$ROOTSYS/gdml` directory contains a set of Python modules designed; for writing out Geometry Description Markup Language (GDML) files.; There is also a C++ implementation for the import of GDML into ROOT.; They act as a converter between the GDML geometry files and the TGeo; geometry structures (and vice versa). ### GDML->ROOT. As this binding is integrated into the ROOT installation, you need to; enable the use of the binding at the configure point of the ROOT; installation. This can be done like so:. ~~~ {.cpp}; ./configure --enable-gdml; ~~~. On doing this the libraries will be built by issuing the standard ROOT; make command. The GDML to TGeo converter uses the TXMLEngine to parse; the GDML files. This XML parser is a DOM parser and returns the DOM; tree to the class TGDMLParse. This class then interprets the GDML file; and adds the bindings in their TGeo equivalent. The GDML schema is fully supported with a few exceptions:. - Replica Volumes are not supported; - Loops are not supported; - Matrices are not supported. These will hopefully be added in the near future. Once you have enabled GDML in the configure process for ROOT, to import; a GDML file, this can be done using TGeoManager::Import. This automatically; calls the right method to parse the GDML by detecting the .gdml file; extension. Here is how to do it:. ~~~ {.cpp}; TGeoManager::Import(""test.gdml"");; ~~~. Replace test.gdml with the gdml filename you want to import. Once the; GDML file has been successfully imported, you can view the geometry by; calling:. ~~~ {.cpp}; gGeoManager->GetTopVolume()->Draw(""ogl"");; ~~~. For any questions or comments about the GDML->ROOT binding please contact ben.lloyd@cern.ch. ### ROOT->GDML. The TGeo to GDML converter allows to export ROOT geometries (TGeo; geometry trees) as GDML files. The writer module writes a GDML file; out of the 'in-memory' representation of the geome",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md:449,integrat,integrated,449,geom/gdml/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md,1,['integrat'],['integrated']
Integrability,"\defgroup Math Math; \brief The %ROOT Mathematical Libraries. They consist of the following components:. - \ref MathCore ""MathCore"": a self-consistent minimal set of tools required for the basic numerical computing.; It provides the major mathematical functions in the namespaces ROOT::Math and TMath,; classes for random number generators, TRandom, class for complex numbers, TComplex,; common interfaces for function evaluation and numerical algorithms.; Basic implementations of some of the numerical algorithms such as integration or derivation, are also provided by MathCore.; together with the core classes needed to fit any generic data set. - \ref MathMore ""MathMore"": a package incorporating advanced numerical functionality and dependent on external libraries like the GNU Scientific Library ([GSL](http://www.gnu.org/software/gsl/)). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL. - **Minimization and Fitting Libraries**; Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional; function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in %ROOT is; organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:. - \ref MinuitOld ""Minuit"": library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/index.md:395,interface,interfaces,395,math/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/index.md,4,"['depend', 'integrat', 'interface']","['dependent', 'integration', 'interfaces']"
Integrability,"\defgroup MathCore MathCore; \ingroup Math; \brief The Core Mathematical Library of %ROOT. **MathCore** provides a collection of functions and C++ classes for HEP numerical computing.; This library provides only the basic mathematical functions and algorithms and not all the; functionality required by the HEP community. More advanced mathematical functionalities is; provided by the \ref MathMore. The current set includes classes and functions for:. * \ref SpecFunc ""Basic special functions"" used in HEP like the gamma, beta and error function;; * \ref StatFunc : mathematical functions used in statistics, such as the probability density; functions and the cumulative distributions functions (lower and upper integral of the pdf's); for continuous and discrete distributions.;; * \ref CppFunctions :; * \ref GenFunc, including helper class to wrap free (static) and non-static member functions; * \ref ParamFunc; * Numerical algorithms: user classes with (in some cases) basic implementations for:; * \ref Integration; * \ref Deriv; * \ref RootFinders; * \ref Min1D and \ref MultiMin; * \ref Fit :classes for fitting and parameter estimation from a given data set. Note that in this latest release the \ref GenVector ""GenVector"" (physics and geometry vectors; for 2,3 and 4 dimensions with their transformations) is not anymore part of MathCore, but is; built as a separate library. MathCore contains instead now classes which were originally part; of _libCore_. These include:. * **TMath** : namespace with mathematical functions and basic function algorithms.; * **TComplex**: class for complex numbers.; * Random classes: base class **TRandom** and the derived classes TRandom1, TRandom2 and; TRandom3, implementing the pseudo-random number generators.; * Other classes, such as; * TKDTree for partitioning the data using a kd-Tree and TKDTreeBinning for binning data using a kdTree; * ROOT::Math::GoFTest for goodness of fit tests; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/doc/index.md:847,wrap,wrap,847,math/mathcore/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/doc/index.md,1,['wrap'],['wrap']
Integrability,"\defgroup asimage libAfterImage interface; \ingroup Graphics2D; \brief Classes interfacing to libAfterImage. - [libAfterImage Imaging Library.](http://www.afterstep.org/afterimage/index.php); - Several tutorials demonstrate how to use images in ROOT:; - rose_image.C shows how to draw an image in a pad.; - galaxy_image.C illustrates the TASImage class and an image editor.; - img2pad.C shows how to insert images in a pad.; - imgconv.C shows how to save an image in various formats: .png, .gif, .xpm and tiff.; - pad2png.C create a canvas and save as png.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/doc/index.md:32,interface,interface,32,graf2d/asimage/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/doc/index.md,1,['interface'],['interface']
Integrability,"\defgroup eg EG; \ingroup montecarlo; \brief Particle Data Group interface. These classes are interfaces to the Particle Data Group (PDG); data base, a static and dynamic particle class and a decay class framework. These classes are extensively used in the VMC (Virtual Monte Carlo).; See more details in the \ref montecarlo page.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/doc/index.md:65,interface,interface,65,montecarlo/eg/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/doc/index.md,2,['interface'],"['interface', 'interfaces']"
Integrability,"\defgroup fitpanel ROOT Fit Panel; \ingroup gui; \brief Classes forming the user interface of the Fit Panel in ROOT. ## The Fit Panel. \image html fitpanel.png. To display the Fit Panel right click on a histogram to pop up the; context menu, and then select the menu entry Fit Panel. By design, this user interface is planned to contain two tabs:; ""General"" and ""Minimization"". Currently, the ""General"" tab provides; user interface elements for setting the fit function, fit method and; different fit, draw, print options.; The ""Minimization tab"" provides the option to set the Minimizer to use in the fit and; its specific options. The fit panel is a modeless dialog, i.e. when opened, it does not; prevent users from interacting with other windows. Its first prototype; is a singleton application. When the Fit Panel is activated, users can; select an object for fitting in the usual way, i.e. by left-mouse; click on it. If the selected object is suitable for fitting, the fit; panel is connected with this object and users can perform fits by; setting different parameters and options. ### Function Choice and Settings. *‘Predefined' combo box* - contains a list of predefined functions in; ROOT. You have a choice of several polynomials, a Gaussian, a Landau,; and an Exponential function. The default one is Gaussian. *‘Operation' radio button group* defines the selected operational mode; between functions:. *Nop* - no operation (default);. *Add* - addition;. *Conv* - convolution (will be implemented in the future). Users can enter the function expression into the text entry field; below the ‘Predefined' combo box. The entered string is checked after; the Enter key was pressed and an error message shows up, if the; function string is not accepted. ‘*Set Parameters*' button opens a dialog for parameters settings,; which will be explained later. ### Fitter Settings. *‘Method' combo box* currently provides only two fit model choices:; Chi-square and Binned Likelihood. The default one i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/doc/index.md:81,interface,interface,81,gui/fitpanel/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/doc/index.md,3,['interface'],['interface']
Integrability,"\defgroup ged ROOT Graphics Editor; \ingroup gui; \brief Classes forming the Graphics Editor (GED) of ROOT and the basic classes of so-called object editors. ## The ROOT Graphics Editor (GED). Everything drawn in a ROOT canvas is an object. There are classes for; all objects, and they fall into hierarchies. In addition, the ROOT has; fully cross-platform GUI classes and provides all standard components; for an application environment with common ‘look and feel'. The; object-oriented, event-driven programming model supports the modern; signals/slots communication mechanism. It handles user interface actions; and allows total independence of interacting objects and classes. This; mechanism uses the ROOT dictionary information and the Cling the C++; Interpreter to connect signals to slots methods. Therefore, all necessary elements for an object-oriented editor design; are in place. The editor complexity can be reduced by splitting it into; discrete units of so-called *`object`* *`editors`*. Any object editor; provides an object specific GUI. The main purpose of the ROOT graphics; editor is the organization of the object editors' appearance and the; task sequence between them. ### Object Editors. Every object editor follows a simple naming convention: to have as a; name the object class name concatenated with ‘*`Editor`*' (e.g. for; **`TGraph`** objects the object editor is **`TGraphEditor`**). Thanks to; the signals/slots communication mechanism and to the method; `DistancetoPrimitive()` that computes a ‘‘distance'' to an object from; the mouse position, it was possible to implement a signal method of the; canvas that says which is the selected object and to which pad it; belongs. Having this information the graphics editor loads the; corresponding object editor and the user interface is ready for use.; This way after a click on ‘axis'—the axis editor is active; a click on a; ‘pad' activates the pad editor, etc. The algorithm in use is simple and is based on the object-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/doc/index.md:596,interface,interface,596,gui/ged/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/doc/index.md,1,['interface'],['interface']
Integrability,\defgroup gui GUI; \brief Graphical User Interface. The ROOT GUI classes support an extensive and rich set of widgets. The widget classes; interface to the underlying graphics system via a single abstract class making the ROOT GUI; fully cross-platform. \defgroup webwidgets Web Widgets; \brief A Graphical User Interface based on WEB technology; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/index.md:139,interface,interface,139,gui/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/index.md,1,['interface'],['interface']
Integrability,"\defgroup guirecorder Events recorder; \ingroup gui; \brief The event recorder. ## ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:. - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. ### Recording. 1] To start recording; ```; TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""); ```; or:; ```; TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...); ```; - `filename`: Name of ROOT file in which to save recorded events. 2] To stop recording; ```; recorder->Stop(); ```. IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. #### Example:. ```; t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording; ```. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. ### Replaying. 1] To start replaying; ```; TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""); ```; or:; ```; TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);; ```; - `filename`: A name of file with recorded events previously created with TRecorder::Start. - `showMouseCursor`: If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/doc/index.md:137,interface,interface,137,gui/recorder/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/doc/index.md,1,['interface'],['interface']
Integrability,\defgroup gviz graphviz interface; \ingroup Graphics2D; \brief Interface to the graphing package `graphviz`. - graphstruct.C is an example of the graphviz interface classes usage. ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gviz/doc/index.md:24,interface,interface,24,graf2d/gviz/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gviz/doc/index.md,2,['interface'],['interface']
Integrability,\defgroup http HTTP server; \brief THttpServer-related classes to provide HTTP protocol to ROOT application; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/index.md:79,protocol,protocol,79,net/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/index.md,1,['protocol'],['protocol']
Integrability,"\defgroup opengl OpenGL rendering; \ingroup Graphics3D; \brief OpenGL rendering and utility classes. The GL module incapsulates ROOT's interface to the OpenGL rendering; engine and provides the following functionality:. - management of system-resources;; - frequently used utility classes;; - base-classes for shapes, scenes and viewers;; - concrete implementations of shapes needed by TGeo package;; - concrete implementations of scenes and viewers including the GUI components;; - specialized plot-painters for GL rendering of TH2, TH3, TF2 and TF3 object as well as parametric surfaces. Papers describing OpenGL in ROOT:; - [ROOT 3D graphics](http://indico.cern.ch/contributionDisplay.py?contribId=93&sessionId=4&confId=048), presented at CHEP 2006.; - [3D graphics with OpenGL: recent improvements and plans](http://indico.cern.ch/contributionDisplay.py?contribId=23&confId=13356), presented at ROOT Workshop 2007; - [Next generation of OpenGL support in ROOT](http://indico.cern.ch/contributionDisplay.py?contribId=445&sessionId=28&confId=3580), presented at CHEP 2007.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/doc/index.md:135,interface,interface,135,graf3d/gl/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/doc/index.md,1,['interface'],['interface']
Integrability,"\defgroup pythia8 Pythia8; \ingroup montecarlo; \brief The Pythia8 interface. The pythia8 directory is an interface to the C++ version of Pythia 8.1 event generators, ; written by T.Sjostrand.; The user is assumed to be familiar with the Pythia8 package.; Only a basic interface to Pythia8 is provided. Because Pythia8 is; also written in C++, its functions/classes can be called directly from a; compiled C++ script. To call Pythia functions not available in this interface a dictionary must; be generated. See pythia8.C for an example of use from ROOT interpreter. See also the [complete Pythia8 documentation](http://home.thep.lu.se/~torbjorn/pythiaaux/recent.html); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/pythia8/doc/index.md:67,interface,interface,67,montecarlo/pythia8/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/pythia8/doc/index.md,4,['interface'],['interface']
Integrability,"\defgroup roofit_dev_docs_batchcompute RooBatchCompute library guide; \ingroup roofit_dev_docs; \date September 2021; \author Emmanouil Michalainas; \brief Overview of the RooBatchCompute library. ## RooBatchCompute Library; _Contains optimized computation functions for PDFs that enable significantly faster fittings._; #### Note: This library is still at an experimental stage. Tests are being conducted continuously to ensure correctness of the results, but the interfaces and the instructions on how to use might change. ### Purpose; While fitting, a significant amount of time and processing power is spent on computing the probability function for every event and PDF involved in the fitting model. To speed up this process, roofit can use the computation functions provided in this library. The functions provided here process whole data arrays (batches) instead of a single event at a time, as in the legacy evaluate() function in roofit. In addition, the code is written in a manner that allows for compiler optimizations, notably auto-vectorization. This library is compiled multiple times for different [vector instruction set architectures](https://en.wikipedia.org/wiki/SIMD) and the optimal code is executed during runtime, as a result of an automatic hardware detection mechanism that this library contains. **As a result, fits can benefit by a speedup of 3x-16x.**. As of ROOT v6.26, RooBatchComputes also provides multithread and [CUDA](https://en.wikipedia.org/wiki/CUDA) instances of the computation functions, resulting in even greater improvements for fitting times. ### How to use; This library is an internal component of RooFit, so users are not supposed to actively interact with it. Instead, they can benefit from significantly faster times for fitting by calling `fitTo()` and providing a `BatchMode(""cpu"")` or a `BatchMode(""cuda"")` option.; ``` {.cpp}; // fit using the most efficient library that the computer's CPU can support; RooMyPDF.fitTo(data, BatchMode(""cpu""));. //",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/batchcompute.md:465,interface,interfaces,465,roofit/doc/developers/batchcompute.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/batchcompute.md,1,['interface'],['interfaces']
Integrability,"\defgroup roofit_dev_docs_hs3 Implement JSON I/O for a RooFit class with RooFit HS3; \ingroup roofit_dev_docs; \date March 2023; \author Carsten Burgard; \brief Guide on how to add JSON IO for you RooFit classes. ## RooFitHS3 Library; _Contains facilities to serialize and deserialize RooWorkspaces to and from JSON and YML._; #### Note: This library is still at an experimental stage. ### Purpose. When using `RooFit`, statistical models can be conveniently handled and; stored as a `RooWorkspace`. However, for the sake of interoperability; with other statistical frameworks, and also ease of manipulation, it; may be useful to store statistical models in text form. This library; sets out to achieve exactly that, exporting to and importing from JSON; and YML. ### Backend. The default backend for this is the `nlohmann` JSON implementation,; which ships with ROOT as a builtin dependency and will import from and; export to JSON. Alternatively, the RapidYAML (`RYML`) implementation; can be used to also import from and export to YML. This implementation; can be selected at compile time with the `cmake` flag; `roofit_hs3_ryml`. ### Usage. The main class providing import from and export to JSON and YML is the; RooJSONFactoryWSTool. ### Open-world philosophy. One of the most challenging aspects of providing serialization and; deserialization for `RooFit` is the fact that `RooFit` follows an; ""open-world"" philosophy with respect to the functions and pdfs it can; handle. Over the years, `RooFit` has also accumulated a significant; number of different pre-implemented functions and pdfs. What is more,; you can easily create your own `RooFit` function by inheriting from; `RooAbsReal` or your own `RooFit` pdf by inheriting from; `RooAbsPdf`. This means that feature-complete serialization and; deserialization to and from JSON and YML will probably never be fully; achieved. However, this may not impede your usage of this library, as; it was written in such a way as to allow users (that is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_hs3.md:525,interoperab,interoperability,525,roofit/doc/developers/roofit_hs3.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_hs3.md,2,"['depend', 'interoperab']","['dependency', 'interoperability']"
Integrability,\defgroup tutorial_tmva_keras TMVA Keras tutorials; \ingroup tutorial_tmva; \brief Example code which illustrates how to use keras with the python interface of TMVA; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/keras/index.md:147,interface,interface,147,tutorials/tmva/keras/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/keras/index.md,1,['interface'],['interface']
Integrability,\defgroup tutorial_tmva_pytorch TMVA PyTorch tutorials; \ingroup tutorial_tmva; \brief Example code which illustrates how to use pytorch with the python interface of TMVA; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/pytorch/index.md:153,interface,interface,153,tutorials/tmva/pytorch/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tmva/pytorch/index.md,1,['interface'],['interface']
Integrability,"\f$r_{ij}\f$ are the 3x3 rotation matrix components; - \f$t_x\f$,\f$t_y\f$,\f$t_z\f$ are the translation components; - \f$s_x\f$, \f$s_y\f$, \f$s_z\f$ are arbitrary scale constants on each axis. The disadvantage in using this approach is that computation for 4x4; matrices is expensive. Even combining two translations would become a; multiplication of their corresponding matrices, which is quite an; undesired effect. On the other hand, it is not a good idea to store a; translation as a block of 16 numbers. We have therefore chosen to; implement each basic transformation type as a class deriving from the; same basic abstract class and handling its specific data and; point/vector transformation algorithms. The base class TGeoMatrix defines abstract methods for:. - Translation, rotation and scale getters. Every derived class stores; only its specific data, e.g. a translation stores an array of 3; doubles and a rotation an array of 9. However, getting the; TGeoTranslation rotation array through the base; TGeoMatrix interface is a legal operation. The answer in this; case is a pointer to a global constant array representing an; identity rotation. ~~~{.cpp}; Double_t *TGeoMatrix::GetTranslation() const;; Double_t *TGeoMatrix::GetRotation() const;; Double_t *TGeoMatrix::GetScale() const;; ~~~. - Master-to-local and local-to-master point and vector transformations:. ~~~{.cpp}; void TGeoMatrix::MasterToLocal(const Double_t *master,; Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local,; Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master,; Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local,; Double_t *master); ~~~. Here `master` and `local` are arrays of size 3. These methods allow; correct conversion also for reflections. - Transformation type finding:. ~~~{.cpp}; Bool_t TGeoMatrix::IsIdentity() const;; Bool_t TGeoMatrix::IsTranslation() const;; Bool_t TGeoMatrix::IsRotation() const;; Bool_t TGeoMatrix::IsSca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:54819,interface,interface,54819,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['interface'],['interface']
Integrability,];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super dealloc];; }; @end. osx.cocoa.IncompatibleMethodTypes; (ObjC); Check for an incompatible type signature when overriding an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted this attribute.). @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. osx.cocoa.NSAutoreleasePool; (ObjC); Warn for suboptimal uses of NSAutoreleasePool in Objective-C; GC mode (-fobjc-gc compiler option). void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. osx.cocoa.NSError; (ObjC); Check usage of NSError** parameters. @interface A : NSObject; - (void)foo:(NSError **)error;; @end. @implementation A; - (void)foo:(NSError **)error {; // warn: method accepting NSError** should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError **)error;; @end. @implementation A; - (BOOL)foo:(NSError **)error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. osx.cocoa.NilArg; (ObjC); Check for prohibited nil arguments in specific Objective-C method calls:; - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:16666,interface,interface,16666,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['interface'],['interface']
Integrability,"^. A member of a struct or union may be declared to have ownership-qualified; type. If the type is qualified with ``__unsafe_unretained``, the semantics; of the containing aggregate are unchanged from the semantics of an unqualified type in a non-ARC mode. If the type is qualified with ``__autoreleasing``, the program is ill-formed. Otherwise, if the type is nontrivially ownership-qualified, additional rules apply. Both Objective-C and Objective-C++ support nontrivially ownership-qualified; fields. Due to formal differences between the standards, the formal; treatment is different; however, the basic language model is intended to; be the same for identical code. .. admonition:: Rationale. Permitting ``__strong`` and ``__weak`` references in aggregate types; allows programmers to take advantage of the normal language tools of; C and C++ while still automatically managing memory. While it is; usually simpler and more idiomatic to use Objective-C objects for; secondary data structures, doing so can introduce extra allocation; and message-send overhead, which can cause to unacceptable; performance. Using structs can resolve some of this tension. ``__autoreleasing`` is forbidden because it is treacherous to rely; on autoreleases as an ownership tool outside of a function-local; contexts. Earlier releases of Clang permitted ``__strong`` and ``__weak`` only; references in Objective-C++ classes, not in Objective-C. This; restriction was an undesirable short-term constraint arising from the; complexity of adding support for non-trivial struct types to C. In Objective-C++, nontrivially ownership-qualified types are treated; for nearly all purposes as if they were class types with non-trivial; default constructors, copy constructors, move constructors, copy assignment; operators, move assignment operators, and destructors. This includes the; determination of the triviality of special members of classes with a; non-static data member of such a type. In Objective-C, the definitio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:52350,message,message-send,52350,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message-send']
Integrability,"^^. In general, there is no relative ordering among pointers. As a result,; when unordered containers like sets and maps are used with pointer keys; the iteration order is undefined. Hence, iterating such containers may; result in non-deterministic code generation. While the generated code; might work correctly, non-determinism can make it harder to reproduce bugs and; debug the compiler. In case an ordered result is expected, remember to; sort an unordered container before iteration. Or use ordered containers; like ``vector``/``MapVector``/``SetVector`` if you want to iterate pointer; keys. Beware of non-deterministic sorting order of equal elements; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``std::sort`` uses a non-stable sorting algorithm in which the order of equal; elements is not guaranteed to be preserved. Thus using ``std::sort`` for a; container having equal elements may result in non-deterministic behavior.; To uncover such instances of non-determinism, LLVM has introduced a new; llvm::sort wrapper function. For an EXPENSIVE_CHECKS build this will randomly; shuffle the container before sorting. Default to using ``llvm::sort`` instead; of ``std::sort``. Style Issues; ============. The High-Level Issues; ---------------------. Self-contained Headers; ^^^^^^^^^^^^^^^^^^^^^^. Header files should be self-contained (compile on their own) and end in ``.h``.; Non-header files that are meant for inclusion should end in ``.inc`` and be; used sparingly. All header files should be self-contained. Users and refactoring tools should; not have to adhere to special conditions to include the header. Specifically, a; header should have header guards and include all other headers it needs. There are rare cases where a file designed to be included is not; self-contained. These are typically intended to be included at unusual; locations, such as the middle of another file. They might not use header; guards, and might not include their prerequisites. Name such",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:29004,wrap,wrapper,29004,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['wrap'],['wrapper']
Integrability,"^^^^^. Conditional branch. .. code-block:: none. G_BRCOND %condition, %basicblock.<id>. G_BRINDIRECT; ^^^^^^^^^^^^. Indirect branch. .. code-block:: none. G_BRINDIRECT %src(p0). G_BRJT; ^^^^^^. Indirect branch to jump table entry. .. code-block:: none. G_BRJT %ptr(p0), %jti, %idx(s64). G_JUMP_TABLE; ^^^^^^^^^^^^. Generates a pointer to the address of the jump table specified by the source; operand. The source operand is a jump table index.; G_JUMP_TABLE can be used in conjunction with G_BRJT to support jump table; codegen with GlobalISel. .. code-block:: none. %dst:_(p0) = G_JUMP_TABLE %jump-table.0. The above example generates a pointer to the source jump table index. G_INVOKE_REGION_START; ^^^^^^^^^^^^^^^^^^^^^. A marker instruction that acts as a pseudo-terminator for regions of code that may; throw exceptions. Being a terminator, it prevents code from being inserted after; it during passes like legalization. This is needed because calls to exception; throw routines do not return, so no code that must be on an executable path must; be placed after throwing. G_INTRINSIC, G_INTRINSIC_CONVERGENT; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Call an intrinsic that has no side-effects. The _CONVERGENT variant corresponds to an LLVM IR intrinsic marked `convergent`. .. note::. Unlike SelectionDAG, there is no _VOID variant. Both of these are permitted; to have zero, one, or multiple results. G_INTRINSIC_W_SIDE_EFFECTS, G_INTRINSIC_CONVERGENT_W_SIDE_EFFECTS; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Call an intrinsic that is considered to have unknown side-effects and as such; cannot be reordered across other side-effecting instructions. The _CONVERGENT variant corresponds to an LLVM IR intrinsic marked `convergent`. .. note::. Unlike SelectionDAG, there is no _VOID variant. Both of these are permitted; to have zero, one, or multiple results. Variadic Arguments; ------------------. G_VASTART; ^^^^^^^^^. .. caution::. I found no documentation for this ins",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst:20145,rout,routines,20145,interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,1,['rout'],['routines']
Integrability,"^^^^^^^^^^^^^. The AliasSetTracker class is implemented to be as efficient as possible. It; uses the union-find algorithm to efficiently merge AliasSets when a pointer is; inserted into the AliasSetTracker that aliases multiple sets. The primary data; structure is a hash table mapping pointers to the AliasSet they are in. The AliasSetTracker class must maintain a list of all of the LLVM ``Value*``\s; that are in each AliasSet. Since the hash table already has entries for each; LLVM ``Value*`` of interest, the AliasesSets thread the linked list through; these hash-table nodes to avoid having to allocate memory unnecessarily, and to; make merging alias sets extremely efficient (the linked list merge is constant; time). You shouldn't need to understand these details if you are just a client of the; AliasSetTracker, but if you look at the code, hopefully this brief description; will help make sense of why things are designed the way they are. Using the ``AliasAnalysis`` interface directly; ----------------------------------------------. If neither of these utility class are what your pass needs, you should use the; interfaces exposed by the ``AliasAnalysis`` class directly. Try to use the; higher-level methods when possible (e.g., use mod/ref information instead of the; `alias`_ method directly if possible) to get the best precision and efficiency. Existing alias analysis implementations and clients; ===================================================. If you're going to be working with the LLVM alias analysis infrastructure, you; should know what clients and implementations of alias analysis are available.; In particular, if you are implementing an alias analysis, you should be aware of; the `the clients`_ that are useful for monitoring and evaluating different; implementations. .. _various alias analysis implementations:. Available ``AliasAnalysis`` implementations; -------------------------------------------. This section lists the various implementations of the ``Al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:22605,interface,interface,22605,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['interface'],['interface']
Integrability,"^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = inttoptr <ty> <value> to <ty2>[, !dereferenceable !<deref_bytes_node>][, !dereferenceable_or_null !<deref_bytes_node>] ; yields ty2. Overview:; """""""""""""""""". The '``inttoptr``' instruction converts an integer ``value`` to a; pointer type, ``ty2``. Arguments:; """""""""""""""""""". The '``inttoptr``' instruction takes an :ref:`integer <t_integer>` value to; cast, and a type to cast it to, which must be a :ref:`pointer <t_pointer>`; type. The optional ``!dereferenceable`` metadata must reference a single metadata; name ``<deref_bytes_node>`` corresponding to a metadata node with one ``i64``; entry.; See ``dereferenceable`` metadata. The optional ``!dereferenceable_or_null`` metadata must reference a single; metadata name ``<deref_bytes_node>`` corresponding to a metadata node with one; ``i64`` entry.; See ``dereferenceable_or_null`` metadata. Semantics:; """""""""""""""""""". The '``inttoptr``' instruction converts ``value`` to type ``ty2`` by; applying either a zero extension or a truncation depending on the size; of the integer ``value``. If ``value`` is larger than the size of a; pointer then a truncation is done. If ``value`` is smaller than the size; of a pointer then a zero extension is done. If they are the same size,; nothing is done (*no-op cast*). Example:; """""""""""""""". .. code-block:: llvm. %X = inttoptr i32 255 to ptr ; yields zero extension on 64-bit architecture; %Y = inttoptr i32 255 to ptr ; yields no-op on 32-bit architecture; %Z = inttoptr i64 0 to ptr ; yields truncation on 32-bit architecture; %Z = inttoptr <4 x i32> %G to <4 x ptr>; yields truncation of vector G to four pointers. .. _i_bitcast:. '``bitcast .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = bitcast <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``bitcast``' instruction converts ``value`` to type ``ty2`` without; changing any bits. Arguments:; """""""""""""""""""". The '``bitcast``' instruction takes a value to ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:455033,depend,depending,455033,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depending']
Integrability,"^^^^^^^^^^^^^^^^^^^. Now we combine the two previous steps into our first real tool. A more advanced; version of this example tool is also checked into the clang tree at; ``tools/clang-check/ClangCheck.cpp``. .. code-block:: c++. // Declares clang::SyntaxOnlyAction.; #include ""clang/Frontend/FrontendActions.h""; #include ""clang/Tooling/CommonOptionsParser.h""; #include ""clang/Tooling/Tooling.h""; // Declares llvm::cl::extrahelp.; #include ""llvm/Support/CommandLine.h"". using namespace clang::tooling;; using namespace llvm;. // Apply a custom category to all command-line options so that they are the; // only ones displayed.; static cl::OptionCategory MyToolCategory(""my-tool options"");. // CommonOptionsParser declares HelpMessage with a description of the common; // command-line options related to the compilation database and input files.; // It's nice to have this help message in all tools.; static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);. // A help message for this specific tool can be added afterwards.; static cl::extrahelp MoreHelp(""\nMore help text...\n"");. int main(int argc, const char **argv) {; CommonOptionsParser OptionsParser(argc, argv, MyToolCategory);; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. Running the tool on some code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When you check out and build clang, clang-check is already built and available; to you in bin/clang-check inside your build directory. You can run clang-check on a file in the llvm repository by specifying all the; needed parameters after a ""``--``"" separator:. .. code-block:: bash. $ cd /path/to/source/llvm; $ export BD=/path/to/build/llvm; $ $BD/bin/clang-check tools/clang/tools/clang-check/ClangCheck.cpp -- \; clang++ -D__STDC_CONSTANT_MACROS -D__STDC_LIMIT_MACROS \; -Itools/clang/include -I$BD/include -Iinclude \; -Itools/clang/lib/Headers -c. As an alternative, yo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst:4965,message,message,4965,interpreter/llvm-project/clang/docs/LibTooling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst,1,['message'],['message']
Integrability,"^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <integer_type> @llvm.get.fpenv(). Overview:; """""""""""""""""". The '``llvm.get.fpenv``' intrinsic returns bits of the current floating-point; environment. The return value type is platform-specific. Semantics:; """""""""""""""""""". The '``llvm.get.fpenv``' intrinsic reads the current floating-point environment; and returns it as an integer value. '``llvm.set.fpenv``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.set.fpenv(<integer_type> <val>). Overview:; """""""""""""""""". The '``llvm.set.fpenv``' intrinsic sets the current floating-point environment. Arguments:; """""""""""""""""""". The argument is an integer representing the new floating-point environment. The; integer type is platform-specific. Semantics:; """""""""""""""""""". The '``llvm.set.fpenv``' intrinsic sets the current floating-point environment; to the state specified by the argument. The state may be previously obtained by a; call to '``llvm.get.fpenv``' or synthesised in a platform-dependent way. '``llvm.reset.fpenv``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.reset.fpenv(). Overview:; """""""""""""""""". The '``llvm.reset.fpenv``' intrinsic sets the default floating-point environment. Semantics:; """""""""""""""""""". The '``llvm.reset.fpenv``' intrinsic sets the current floating-point environment; to default state. It is similar to the call 'fesetenv(FE_DFL_ENV)', except it; does not return any value. .. _int_get_fpmode:. '``llvm.get.fpmode``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". The '``llvm.get.fpmode``' intrinsic returns bits of the current floating-point; control modes. The return value type is platform-specific. ::. declare <integer_type> @llvm.get.fpmode(). Overview:; """""""""""""""""". The '``llvm.get.fpmode``' intrinsic reads the current dynamic floating-point; control modes and returns it as an integer value. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". The '``llvm.get.fpmode``' intrinsic re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:918398,depend,dependent,918398,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependent']
Integrability,"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Support for languages which allow unmanaged pointers to garbage collected; objects (i.e. pass a pointer to an object to a C routine) in the abstract; machine model. At the moment, the best idea on how to approach this; involves an intrinsic or opaque function which hides the connection between; the reference value and the raw pointer. The problem is that having a; ptrtoint or inttoptr cast (which is common for such use cases) breaks the; rules used for inferring base pointers for arbitrary references when; lowering out of the abstract model to the explicit physical model. Note; that a frontend which lowers directly to the physical model doesn't have; any problems here. Objects on the Stack; ^^^^^^^^^^^^^^^^^^^^. As noted above, the explicit lowering supports objects allocated on the; stack provided the collector can find a heap map given the stack address. The missing pieces are a) integration with rewriting (RS4GC) from the; abstract machine model and b) support for optionally decomposing on stack; objects so as not to require heap maps for them. The later is required; for ease of integration with some collectors. Lowering Quality and Representation Overhead; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The current statepoint lowering is known to be somewhat poor. In the very; long term, we'd like to integrate statepoints with the register allocator;; in the near term this is unlikely to happen. We've found the quality of; lowering to be relatively unimportant as hot-statepoints are almost always; inliner bugs. Concerns have been raised that the statepoint representation results in a; large amount of IR being produced for some examples and that this; contributes to higher than expected memory usage and compile times. There's; no immediate plans to make changes due to this, but alternate models may be; explored in the future. Relocations Along Exceptional Edges; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Relocations along exceptional pat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:35024,integrat,integration,35024,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['integrat'],['integration']
Integrability,"_35``. Note: You cannot pass ``compute_XX`` as an argument to ``--cuda-gpu-arch``;; only ``sm_XX`` is currently supported. However, clang always includes PTX in; its binaries, so e.g. a binary compiled with ``--cuda-gpu-arch=sm_30`` would be; forwards-compatible with e.g. ``sm_35`` GPUs. You can pass ``--cuda-gpu-arch`` multiple times to compile for multiple archs. The `-L` and `-l` flags only need to be passed when linking. When compiling,; you may also need to pass ``--cuda-path=/path/to/cuda`` if you didn't install; the CUDA SDK into ``/usr/local/cuda`` or ``/usr/local/cuda-X.Y``. Flags that control numerical code; ---------------------------------. If you're using GPUs, you probably care about making numerical code run fast.; GPU hardware allows for more control over numerical operations than most CPUs,; but this results in more compiler options for you to juggle. Flags you may wish to tweak include:. * ``-ffp-contract={on,off,fast}`` (defaults to ``fast`` on host and device when; compiling CUDA) Controls whether the compiler emits fused multiply-add; operations. * ``off``: never emit fma operations, and prevent ptxas from fusing multiply; and add instructions.; * ``on``: fuse multiplies and adds within a single statement, but never; across statements (C11 semantics). Prevent ptxas from fusing other; multiplies and adds.; * ``fast``: fuse multiplies and adds wherever profitable, even across; statements. Doesn't prevent ptxas from fusing additional multiplies and; adds. Fused multiply-add instructions can be much faster than the unfused; equivalents, but because the intermediate result in an fma is not rounded,; this flag can affect numerical code. * ``-fcuda-flush-denormals-to-zero`` (default: off) When this is enabled,; floating point operations may flush `denormal; <https://en.wikipedia.org/wiki/Denormal_number>`_ inputs and/or outputs to 0.; Operations on denormal numbers are often much slower than the same operations; on normal numbers. * ``-fcuda-approx-tran",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst:4177,contract,contract,4177,interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,1,['contract'],['contract']
Integrability,"_COVERAGE_COMPILE_FLAGS}"" """" CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS}""). if(LLVM_SHARED_LINKER_FLAGS); set(CMAKE_SHARED_LINKER_FLAGS ""${CMAKE_SHARED_LINKER_FLAGS} ${LLVM_SHARED_LINKER_FLAGS}""); endif(); if(LLVM_EXE_LINKER_FLAGS); set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} ${LLVM_EXE_LINKER_FLAGS}""); endif(). # Explicitly disable -Wmisleading-indentation for GCC: Some LLVM source files; # are too large.; set(cxx_flags_prev ${CMAKE_CXX_FLAGS}); if(CMAKE_CXX_COMPILER_ID STREQUAL ""GNU""); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -Wno-misleading-indentation""); endif(). if(builtin_llvm); # Since debug builds of LLVM are quite large, we want to be able; # to control the build types of ROOT and LLVM independently. The; # logic below is to make that possible. LLVM is built in Release; # mode unless a different build type is chosen via LLVM_BUILD_TYPE. if(NOT DEFINED LLVM_BUILD_TYPE); set(LLVM_BUILD_TYPE Release CACHE STRING ""Build type used for LLVM""); endif(). message(STATUS ""Building LLVM in '${LLVM_BUILD_TYPE}' mode.""). if(NOT DEFINED LLVM_ENABLE_ASSERTIONS); if(CMAKE_BUILD_TYPE MATCHES ""Debug""; OR LLVM_BUILD_TYPE MATCHES ""(Debug|RelWithDebInfo)""); set(LLVM_ENABLE_ASSERTIONS TRUE); else(); set(LLVM_ENABLE_ASSERTIONS FALSE); endif(); endif(). # Multi-configuration generators ignore CMAKE_BUILD_TYPE, so; # in that case we set the flags for all configurations to the; # flags of the build type assigned to LLVM_BUILD_TYPE. if(MSVC OR XCODE); string(TOUPPER ${LLVM_BUILD_TYPE} LLVM_BUILD_TYPE); set(LLVM_C_FLAGS ${CMAKE_C_FLAGS_${LLVM_BUILD_TYPE}}); set(LLVM_CXX_FLAGS ${CMAKE_CXX_FLAGS_${LLVM_BUILD_TYPE}}); # On Windows, use the same compiler flags than ROOT and not; # the other way around; if(NOT MSVC); foreach(CONFIG ${CMAKE_CONFIGURATION_TYPES}); string(TOUPPER ${CONFIG} CONFIG); set(CMAKE_C_FLAGS_${CONFIG} ${LLVM_C_FLAGS}); set(CMAKE_CXX_FLAGS_${CONFIG} ${LLVM_CXX_FLAGS}); endforeach(); endif(); elseif(NOT LLVM_BUILD_TYPE STREQUAL CMAKE_BUILD_TYPE); set(CMAKE_BUILD_TYPE $",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:9748,message,message,9748,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['message'],['message']
Integrability,"_CXX_STANDARD} LESS ${LLVM_REQUIRED_CXX_STANDARD}); message(WARNING ""Resetting cache value for CMAKE_CXX_STANDARD to ${LLVM_REQUIRED_CXX_STANDARD}""); unset(CMAKE_CXX_STANDARD CACHE); endif(). # if CMAKE_CXX_STANDARD is still set after the cache unset above it means that the user requested it; # and we allow it to be set to something newer than the required standard but otherwise we fail.; if(DEFINED CMAKE_CXX_STANDARD AND CMAKE_CXX_STANDARD LESS ${LLVM_REQUIRED_CXX_STANDARD}); message(FATAL_ERROR ""Requested CMAKE_CXX_STANDARD=${CMAKE_CXX_STANDARD} which is less than the required ${LLVM_REQUIRED_CXX_STANDARD}.""); endif(). set(CMAKE_CXX_STANDARD ${LLVM_REQUIRED_CXX_STANDARD} CACHE STRING ""C++ standard to conform to""); set(CMAKE_CXX_STANDARD_REQUIRED YES). if (CYGWIN); # Cygwin is a bit stricter and lack things like 'strdup', 'stricmp', etc in; # c++xx mode.; set(CMAKE_CXX_EXTENSIONS YES); else(); set(CMAKE_CXX_EXTENSIONS NO); endif(). if (NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES); message(FATAL_ERROR ""; No build type selected. You need to pass -DCMAKE_BUILD_TYPE=<type> in order to configure LLVM.; Available options are:; * -DCMAKE_BUILD_TYPE=Release - For an optimized build with no assertions or debug info.; * -DCMAKE_BUILD_TYPE=Debug - For an unoptimized build with assertions and debug info.; * -DCMAKE_BUILD_TYPE=RelWithDebInfo - For an optimized build with no assertions but with debug info.; * -DCMAKE_BUILD_TYPE=MinSizeRel - For a build optimized for size instead of speed.; Learn more about these options in our documentation at https://llvm.org/docs/CMake.html#cmake-build-type; ""); endif(). # Set default build type for cmake's try_compile module.; # CMake 3.17 or newer sets CMAKE_DEFAULT_BUILD_TYPE to one of the; # items from CMAKE_CONFIGURATION_TYPES. Logic below can be further; # simplified once LLVM's minimum CMake version is updated to 3.17.; if(CMAKE_DEFAULT_BUILD_TYPE); set(CMAKE_TRY_COMPILE_CONFIGURATION ${CMAKE_DEFAULT_BUILD_TYPE}); else(); if(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:3840,message,message,3840,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"_DIR_FOR_BUILD_TREE ""If set, use CMake's default build tree install name directory logic (Darwin only)"" OFF); mark_as_advanced(LLVM_NO_INSTALL_NAME_DIR_FOR_BUILD_TREE); if(NOT LLVM_NO_INSTALL_NAME_DIR_FOR_BUILD_TREE); set(CMAKE_BUILD_WITH_INSTALL_NAME_DIR ON); endif(). if(NOT DEFINED LLVM_VERSION_MAJOR); set(LLVM_VERSION_MAJOR 18); endif(); if(NOT DEFINED LLVM_VERSION_MINOR); set(LLVM_VERSION_MINOR 1); endif(); if(NOT DEFINED LLVM_VERSION_PATCH); set(LLVM_VERSION_PATCH 6); endif(); if(NOT DEFINED LLVM_VERSION_SUFFIX); set(LLVM_VERSION_SUFFIX); endif(). if (NOT PACKAGE_VERSION); set(PACKAGE_VERSION; ""${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}.${LLVM_VERSION_PATCH}${LLVM_VERSION_SUFFIX}""); endif(). if(NOT DEFINED LLVM_SHLIB_SYMBOL_VERSION); # ""Symbol version prefix for libLLVM.so""; set(LLVM_SHLIB_SYMBOL_VERSION ""LLVM_${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}""); endif(). if ((CMAKE_GENERATOR MATCHES ""Visual Studio"") AND (MSVC_TOOLSET_VERSION LESS 142) AND (CMAKE_GENERATOR_TOOLSET STREQUAL """")); message(WARNING ""Visual Studio generators use the x86 host compiler by ""; ""default, even for 64-bit targets. This can result in linker ""; ""instability and out of memory errors. To use the 64-bit ""; ""host compiler, pass -Thost=x64 on the CMake command line.""); endif(). if (CMAKE_GENERATOR STREQUAL ""Xcode"" AND NOT CMAKE_OSX_ARCHITECTURES); # Some CMake features like object libraries get confused if you don't; # explicitly specify an architecture setting with the Xcode generator.; set(CMAKE_OSX_ARCHITECTURES ""x86_64""); endif(). project(LLVM; VERSION ${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}.${LLVM_VERSION_PATCH}; LANGUAGES C CXX ASM). if (NOT DEFINED CMAKE_INSTALL_LIBDIR AND DEFINED LLVM_LIBDIR_SUFFIX); # Must go before `include(GNUInstallDirs)`.; set(CMAKE_INSTALL_LIBDIR ""lib${LLVM_LIBDIR_SUFFIX}""); endif(). # Must go after `DEFINED LLVM_LIBDIR_SUFFIX` check.; set(LLVM_LIBDIR_SUFFIX """" CACHE STRING ""Define suffix of library directory name (32/64)"" ). # Must go after `project(.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:1529,message,message,1529,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according to very simple laws, and an additional Gaussian smearing. This; set of variables mimics a measurement of an electrical resistance while; varying pressure and temperature. Imagine your task now consists in finding the relations among the; variables -- of course without knowing the code used to generate them.; You will see that the possibilities of the `NTuple` class enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:2486,depend,depends,2486,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['depend'],['depends']
Integrability,"_INSTALL_TOOLCHAIN_ONLY); install(DIRECTORY include/llvm include/llvm-c; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT llvm-headers; FILES_MATCHING; PATTERN ""*.def""; PATTERN ""*.h""; PATTERN ""*.td""; PATTERN ""*.inc""; PATTERN ""LICENSE.TXT""; ). install(DIRECTORY ${LLVM_INCLUDE_DIR}/llvm ${LLVM_INCLUDE_DIR}/llvm-c; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT llvm-headers; FILES_MATCHING; PATTERN ""*.def""; PATTERN ""*.h""; PATTERN ""*.gen""; PATTERN ""*.inc""; # Exclude include/llvm/CMakeFiles/intrinsics_gen.dir, matched by ""*.def""; PATTERN ""CMakeFiles"" EXCLUDE; PATTERN ""config.h"" EXCLUDE; ). if (LLVM_INSTALL_MODULEMAPS); install(DIRECTORY include; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT llvm-headers; FILES_MATCHING; PATTERN ""module.modulemap""; ); install(FILES include/module.install.modulemap; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT llvm-headers; RENAME ""module.extern.modulemap""; ); endif(LLVM_INSTALL_MODULEMAPS). # Installing the headers needs to depend on generating any public; # tablegen'd headers.; add_custom_target(llvm-headers DEPENDS intrinsics_gen omp_gen); set_target_properties(llvm-headers PROPERTIES FOLDER ""Misc""). if (NOT LLVM_ENABLE_IDE); add_llvm_install_targets(install-llvm-headers; DEPENDS llvm-headers; COMPONENT llvm-headers); endif(). # Custom target to install all libraries.; add_custom_target(llvm-libraries); set_target_properties(llvm-libraries PROPERTIES FOLDER ""Misc""). if (NOT LLVM_ENABLE_IDE); add_llvm_install_targets(install-llvm-libraries; DEPENDS llvm-libraries; COMPONENT llvm-libraries); endif(). get_property(LLVM_LIBS GLOBAL PROPERTY LLVM_LIBS); if(LLVM_LIBS); list(REMOVE_DUPLICATES LLVM_LIBS); foreach(lib ${LLVM_LIBS}); add_dependencies(llvm-libraries ${lib}); if (NOT LLVM_ENABLE_IDE); add_dependencies(install-llvm-libraries install-${lib}); add_dependencies(install-llvm-libraries-stripped install-${lib}-stripped); endif(); endforeach(); endif(); endif(). # This must be at the end of the LLVM root CMakeLists ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:52554,depend,depend,52554,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['depend'],['depend']
Integrability,"_OP_plus, 64)), !dbg !4; !3 = !DILocalVariable(name: ""i"", ...) ; int i; !4 = !DILocation(...). A frontend should generate exactly one call to ``llvm.dbg.declare`` at the point; of declaration of a source variable. Optimization passes that fully promote the; variable from memory to SSA values will replace this call with possibly multiple; calls to `llvm.dbg.value`. Passes that delete stores are effectively partial; promotion, and they will insert a mix of calls to ``llvm.dbg.value`` to track; the source variable value when it is available. After optimization, there may be; multiple calls to ``llvm.dbg.declare`` describing the program points where the; variables lives in memory. All calls for the same concrete source variable must; agree on the memory location. ``llvm.dbg.value``; ^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. void @llvm.dbg.value(metadata, metadata, metadata). This intrinsic provides information when a user source variable is set to a new; value. The first argument is the new value (wrapped as metadata). The second; argument is a `local variable <LangRef.html#dilocalvariable>`_ containing a; description of the variable. The third argument is a `complex expression; <LangRef.html#diexpression>`_. An `llvm.dbg.value` intrinsic describes the *value* of a source variable; directly, not its address. Note that the value operand of this intrinsic may; be indirect (i.e, a pointer to the source variable), provided that interpreting; the complex expression derives the direct value. ``llvm.dbg.assign``; ^^^^^^^^^^^^^^^^^^^; .. toctree::; :hidden:. AssignmentTracking. .. code-block:: llvm. void @llvm.dbg.assign(Value *Value,; DIExpression *ValueExpression,; DILocalVariable *Variable,; DIAssignID *ID,; Value *Address,; DIExpression *AddressExpression). This intrinsic marks the position in IR where a source assignment occurred. It; encodes the value of the variable. It references the store, if any, that; performs the assignment, and the destination address. The first thr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:10391,wrap,wrapped,10391,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['wrap'],['wrapped']
Integrability,"_TYPE}; -DENABLE_HTML_DOCS=OFF; -DENABLE_IPV6=OFF; -DSTATIC_LIBRARY=ON; -DSHARED_LIBRARY=OFF; -DENABLE_TOOLS=OFF; -DDAVIX_TESTS=OFF; -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}; -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}; -DCMAKE_C_FLAGS=${CMAKE_C_FLAGS}; -DCMAKE_CXX_FLAGS=${DAVIX_CXX_FLAGS}\ -fPIC; -DCMAKE_OSX_SYSROOT=${CMAKE_OSX_SYSROOT}; -DCMAKE_OSX_DEPLOYMENT_TARGET=${CMAKE_OSX_DEPLOYMENT_TARGET}; -DLIB_SUFFIX=; PATCH_COMMAND sed -i """" -e ""s|sed -i '| sed -i \""\"" '|g"" -e ""s/gcc/cc/g"" patch-curl-clock-gettime.sh; LOG_BUILD 1 LOG_CONFIGURE 1 LOG_DOWNLOAD 1 LOG_INSTALL 1; BUILD_BYPRODUCTS ${DAVIX_LIBRARIES}; TIMEOUT 600). if(builtin_openssl); add_dependencies(DAVIX OPENSSL); endif(). if(APPLE); find_library(FOUND_CoreFoundation CoreFoundation); if(NOT FOUND_CoreFoundation); message(FATAL_ERROR ""Missing macOS CoreFoundation framework!""); endif(); list(APPEND DAVIX_LIBRARIES ${FOUND_CoreFoundation}). find_library(FOUND_Security Security); if(NOT FOUND_Security); message(FATAL_ERROR ""Missing macOS Security framework!""); endif(); list(APPEND DAVIX_LIBRARIES ${FOUND_Security}); endif(). list(APPEND DAVIX_LIBRARIES uuid::uuid OpenSSL::SSL ZLIB::ZLIB ${LIBXML2_LIBRARIES} ${CMAKE_DL_LIBS}). check_cxx_symbol_exists(""clock_gettime"" ""time.h"" _have_clock_gettime). if(NOT _have_clock_gettime); check_library_exists(rt clock_gettime """" _have_rt_library); if(_have_rt_library); list(APPEND DAVIX_LIBRARIES rt); endif(); endif(). unset(DAVIX_FOUND CACHE); unset(DAVIX_FOUND PARENT_SCOPE); set(DAVIX_FOUND TRUE CACHE BOOL """" FORCE). set(DAVIX_INCLUDE_DIR ${DAVIX_PREFIX}/include/davix CACHE INTERNAL """" FORCE); set(DAVIX_INCLUDE_DIRS ${DAVIX_PREFIX}/include/davix CACHE INTERNAL """" FORCE); set(DAVIX_LIBRARY ${DAVIX_PREFIX}/lib/${DAVIX_LIBNAME} CACHE INTERNAL """" FORCE); set(DAVIX_LIBRARIES ${DAVIX_LIBRARIES} CACHE INTERNAL """" FORCE). add_library(davix INTERFACE); target_include_directories(davix SYSTEM INTERFACE $<BUILD_INTERFACE:${DAVIX_INCLUDE_DIR}>); target_link_libraries(davix INTERFACE $<BUI",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/davix/CMakeLists.txt:2504,message,message,2504,builtins/davix/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/davix/CMakeLists.txt,1,['message'],['message']
Integrability,"__nonnull id takesNonnull(__nonnull id x) {; if (x == nil) {; // Defensive backward compatible code:; ....; return nil; // Should the analyzer cover this piece of code? Should we require the cast (__nonnull)nil?; }; ....; }. There are these directions:. * We can either take the branch; this way the branch is analyzed; * Should we not warn about any nullability issues in that branch? Probably not, it is ok to break the nullability postconditions when the nullability preconditions are violated.; * We can assume that these pointers are not null and we lose coverage with the analyzer. (This can be implemented either in constraint solver or in the checker itself.). Other Issues to keep in mind/take care of:. * Messaging:. * Sending a message to a nullable pointer. * Even though the method might return a nonnull pointer, when it was sent to a nullable pointer the return type will be nullable.; 	* The result is nullable unless the receiver is known to be non null. * Sending a message to an unspecified or nonnull pointer. * If the pointer is not assumed to be nil, we should be optimistic and use the nullability implied by the method. * This will not happen automatically, since the AST will have null unspecified in this case. Inlining; --------. A symbol may need to be treated differently inside an inlined body. For example, consider these conversions from nonnull to nullable in presence of inlining:. .. code-block:: cpp. id obj = getNonnull();; takesNullable(obj);; takesNonnull(obj);. void takesNullable(nullable id obj) {; obj->ivar // we should assume obj is nullable and warn here; }. With no special treatment, when the takesNullable is inlined the analyzer will not warn when the obj symbol is dereferenced. One solution for this is to reanalyze takesNullable as a top level function to get possible violations. The alternative method, deducing nullability information from the arguments after inlining is not robust enough (for example there might be more parameters with diffe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst:3093,message,message,3093,interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst,1,['message'],['message']
Integrability,"_cast<int*>(&r) in; int n = 42;; const int &r(n);; int* p = const_cast<int*>(&r);. Matcher<Stmt>cxxConstructExprMatcher<CXXConstructExpr>...; Matches constructor call expressions (including implicit ones). Example matches string(ptr, n) and ptr within arguments of f; (matcher = cxxConstructExpr()); void f(const string &a, const string &b);; char *ptr;; int n;; f(string(ptr, n), ptr);. Matcher<Stmt>cxxDefaultArgExprMatcher<CXXDefaultArgExpr>...; Matches the value of a default argument at the call site. Example matches the CXXDefaultArgExpr placeholder inserted for the; default value of the second parameter in the call expression f(42); (matcher = cxxDefaultArgExpr()); void f(int x, int y = 0);; f(42);. Matcher<Stmt>cxxDeleteExprMatcher<CXXDeleteExpr>...; Matches delete expressions. Given; delete X;; cxxDeleteExpr(); matches 'delete X'. Matcher<Stmt>cxxDependentScopeMemberExprMatcher<CXXDependentScopeMemberExpr>...; Matches member expressions where the actual member referenced could not be; resolved because the base expression or the member name was dependent. Given; template <class T> void f() { T t; t.g(); }; cxxDependentScopeMemberExpr(); matches t.g. Matcher<Stmt>cxxDynamicCastExprMatcher<CXXDynamicCastExpr>...; Matches a dynamic_cast expression. Example:; cxxDynamicCastExpr(); matches; dynamic_cast<D*>(&b);; in; struct B { virtual ~B() {} }; struct D : B {};; B b;; D* p = dynamic_cast<D*>(&b);. Matcher<Stmt>cxxFoldExprMatcher<CXXFoldExpr>...; Matches C++17 fold expressions. Example matches `(0 + ... + args)`:; template <typename... Args>; auto sum(Args... args) {; return (0 + ... + args);; }. Matcher<Stmt>cxxForRangeStmtMatcher<CXXForRangeStmt>...; Matches range-based for statements. cxxForRangeStmt() matches 'for (auto a : i)'; int i[] = {1, 2, 3}; for (auto a : i);; for(int j = 0; j < 5; ++j);. Matcher<Stmt>cxxFunctionalCastExprMatcher<CXXFunctionalCastExpr>...; Matches functional cast expressions. Example: Matches Foo(bar);; Foo f = bar;; Foo g = (Foo) bar;; F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:28534,depend,dependent,28534,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['depend'],['dependent']
Integrability,"_host__ __device__ void inline_hd1() { host_only(); } // no error; inline __host__ __device__ void inline_hd2() { host_only(); } // error. __host__ void host_fn() { inline_hd1(); }; __device__ void device_fn() { inline_hd2(); }. // This function is not inline, so it's always codegen'ed on both the host; // and the device. Therefore, it generates an error.; __host__ __device__ void not_inline_hd() { host_only(); }. For the purposes of the wrong-side rule, templated functions also behave like; ``inline`` functions: They aren't codegen'ed unless they're instantiated; (usually as part of the process of invoking them). clang's behavior with respect to the wrong-side rule matches nvcc's, except; nvcc only emits a warning for ``not_inline_hd``; device code is allowed to call; ``not_inline_hd``. In its generated code, nvcc may omit ``not_inline_hd``'s; call to ``host_only`` entirely, or it may try to generate code for; ``host_only`` on the device. What you get seems to depend on whether or not; the compiler chooses to inline ``host_only``. Member functions, including constructors, may be overloaded using H and D; attributes. However, destructors cannot be overloaded. Using a Different Class on Host/Device; --------------------------------------. Occasionally you may want to have a class with different host/device versions. If all of the class's members are the same on the host and device, you can just; provide overloads for the class's member functions. However, if you want your class to have different members on host/device, you; won't be able to provide working H and D overloads in both classes. In this; case, clang is likely to be unhappy with you. .. code-block:: c++. #ifdef __CUDA_ARCH__; struct S {; __device__ void foo() { /* use device_only */ }; int device_only;; };; #else; struct S {; __host__ void foo() { /* use host_only */ }; double host_only;; };. __device__ void test() {; S s;; // clang generates an error here, because during host compilation, we; // have ifde",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst:15637,depend,depend,15637,interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,1,['depend'],['depend']
Integrability,"_instance_variable_invalidator. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. .. _alpha-osx-cocoa-MissingInvalidationMethod:. alpha.osx.cocoa.MissingInvalidationMethod (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidation methods are present in classes that contain invalidatable instance variables. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. .. _alpha-osx-cocoa-localizability-PluralMisuseChecker:. alpha.osx.cocoa.localizability.PluralMisuseChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns against using one vs. many plural pattern in code when generating localized strings. .. code-block:: objc. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. alpha.security; ^^^^^^^^^^^^^^. .. _alpha-secur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:59290,interface,interface,59290,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['interface'],['interface']
Integrability,"_libs} kstat socket); endif(); if( FUCHSIA ); set(system_libs ${system_libs} zircon); endif(); if ( HAIKU ); add_compile_definitions(_BSD_SOURCE); set(system_libs ${system_libs} bsd network); endif(); endif( MSVC OR MINGW ). # Delay load shell32.dll if possible to speed up process startup.; set (delayload_flags); if (MSVC); # When linking with Swift, `swiftc.exe` is used as the linker drive rather; # than invoking `link.exe` directly. In such a case, the flags should be; # marked as `-Xlinker` to pass them directly to the linker. As a temporary; # workaround simply elide the delay loading.; set (delayload_flags $<$<NOT:$<LINK_LANGUAGE:Swift>>:delayimp -delayload:shell32.dll -delayload:ole32.dll>); endif(). # Link Z3 if the user wants to build it.; if(LLVM_WITH_Z3); set(system_libs ${system_libs} ${Z3_LIBRARIES}); endif(). # Override the C runtime allocator on Windows and embed it into LLVM tools & libraries; if(LLVM_INTEGRATED_CRT_ALLOC); if (NOT CMAKE_MSVC_RUNTIME_LIBRARY OR CMAKE_MSVC_RUNTIME_LIBRARY MATCHES ""DLL$""); message(FATAL_ERROR ""LLVM_INTEGRATED_CRT_ALLOC only works with CMAKE_MSVC_RUNTIME_LIBRARY set to MultiThreaded or MultiThreadedDebug.""); endif(). string(REGEX REPLACE ""(/|\\\\)$"" """" LLVM_INTEGRATED_CRT_ALLOC ""${LLVM_INTEGRATED_CRT_ALLOC}""). if(NOT EXISTS ""${LLVM_INTEGRATED_CRT_ALLOC}""); message(FATAL_ERROR ""Cannot find the path to `git clone` for the CRT allocator! (${LLVM_INTEGRATED_CRT_ALLOC}). Currently, rpmalloc, snmalloc and mimalloc are supported.""); endif(). if(LLVM_INTEGRATED_CRT_ALLOC MATCHES ""rpmalloc$""); add_compile_definitions(ENABLE_OVERRIDE ENABLE_PRELOAD); set(ALLOCATOR_FILES ""${LLVM_INTEGRATED_CRT_ALLOC}/rpmalloc/rpmalloc.c""); elseif(LLVM_INTEGRATED_CRT_ALLOC MATCHES ""snmalloc$""); set(ALLOCATOR_FILES ""${LLVM_INTEGRATED_CRT_ALLOC}/src/snmalloc/override/new.cc""); set(system_libs ${system_libs} ""mincore.lib"" ""-INCLUDE:malloc""); elseif(LLVM_INTEGRATED_CRT_ALLOC MATCHES ""mimalloc$""); set(MIMALLOC_LIB ""${LLVM_INTEGRATED_CRT_ALLOC}/out/msvc-x6",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt:3716,message,message,3716,interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt,1,['message'],['message']
Integrability,"_strong`` local variables may be released as soon as the value in; the variable is no longer being used: either the variable stops; being used completely or a new value is stored in the variable. The intent of the third rule is to say that return values may be; released after they've been used. A computation history depends on a pointer value ``P`` if it:. * performs a pointer comparison with ``P``,; * loads from ``P``,; * stores to ``P``,; * depends on a pointer value ``Q`` derived via pointer arithmetic; from ``P`` (including an instance-variable or field access), or; * depends on a pointer value ``Q`` loaded from ``P``. Dependency applies only to values derived directly or indirectly from; a particular expression result and does not occur merely because a; separate pointer value dynamically aliases ``P``. Furthermore, this; dependency is not carried by values that are stored to objects. .. admonition:: Rationale. The restrictions on dependency are intended to make this analysis; feasible by an optimizer with only incomplete information about a; program. Essentially, dependence is carried to ""obvious"" uses of a; pointer. Merely passing a pointer argument to a function does not; itself cause dependence, but since generally the optimizer will not; be able to prove that the function doesn't depend on that parameter,; it will be forced to conservatively assume it does. Dependency propagates to values loaded from a pointer because those; values might be invalidated by deallocating the object. For; example, given the code ``__strong id x = p->ivar;``, ARC must not; move the release of ``p`` to between the load of ``p->ivar`` and the; retain of that value for storing into ``x``. Dependency does not propagate through stores of dependent pointer; values because doing so would allow dependency to outlive the; full-expression which produced the original value. For example, the; address of an instance variable could be written to some global; location and then freely accessed ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:80464,depend,dependency,80464,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['depend'],['dependency']
Integrability,"_subdirectory(tools); endif(). if( LLVM_INCLUDE_RUNTIMES ); add_subdirectory(runtimes); endif(). if( LLVM_INCLUDE_EXAMPLES ); add_subdirectory(examples); endif(). if( LLVM_INCLUDE_TESTS ); set(LLVM_GTEST_RUN_UNDER; """" CACHE STRING; ""Define the wrapper program that LLVM unit tests should be run under.""); if(EXISTS ${LLVM_MAIN_SRC_DIR}/projects/test-suite AND TARGET clang); include(LLVMExternalProjectUtils); llvm_ExternalProject_Add(test-suite ${LLVM_MAIN_SRC_DIR}/projects/test-suite; USE_TOOLCHAIN; EXCLUDE_FROM_ALL; NO_INSTALL; ALWAYS_CLEAN); endif(); add_subdirectory(utils/lit); add_subdirectory(test); add_subdirectory(unittests). if (WIN32); # This utility is used to prevent crashing tests from calling Dr. Watson on; # Windows.; add_subdirectory(utils/KillTheDoctor); endif(). umbrella_lit_testsuite_end(check-all); get_property(LLVM_ALL_LIT_DEPENDS GLOBAL PROPERTY LLVM_ALL_LIT_DEPENDS); get_property(LLVM_ALL_ADDITIONAL_TEST_DEPENDS; GLOBAL PROPERTY LLVM_ALL_ADDITIONAL_TEST_DEPENDS); add_custom_target(test-depends; DEPENDS ${LLVM_ALL_LIT_DEPENDS} ${LLVM_ALL_ADDITIONAL_TEST_DEPENDS}); set_target_properties(test-depends PROPERTIES FOLDER ""Tests""); add_dependencies(check-all test-depends); endif(). if (LLVM_INCLUDE_DOCS); add_subdirectory(docs); endif(). add_subdirectory(cmake/modules). # Do this last so that all lit targets have already been created.; if (LLVM_INCLUDE_UTILS); add_subdirectory(utils/llvm-lit); endif(). if (NOT LLVM_INSTALL_TOOLCHAIN_ONLY); install(DIRECTORY include/llvm include/llvm-c; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT llvm-headers; FILES_MATCHING; PATTERN ""*.def""; PATTERN ""*.h""; PATTERN ""*.td""; PATTERN ""*.inc""; PATTERN ""LICENSE.TXT""; ). install(DIRECTORY ${LLVM_INCLUDE_DIR}/llvm ${LLVM_INCLUDE_DIR}/llvm-c; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT llvm-headers; FILES_MATCHING; PATTERN ""*.def""; PATTERN ""*.h""; PATTERN ""*.gen""; PATTERN ""*.inc""; # Exclude include/llvm/CMakeFiles/intrinsics_gen.dir, matched by ""*.def""; PATTERN ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:51133,depend,depends,51133,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,3,['depend'],['depends']
Integrability,"_unique<RField<float>>(""f"");; // assuming we have an array of floats stored in `myFloats`:; auto [minV, maxV] = std::minmax_element(myFloats.begin(), myFloats.end());; constexpr auto nBits = 24;; field->SetQuantized(*minV, *maxV, nBits);; model->AddField(std::move(field));; auto f = model->GetDefaultEntry().GetPtr<float>(""f"");. // Now we can write our floats.; auto writer = RNTupleWriter::Recreate(std::move(model), ""myNtuple"", ""myFile.root"");; for (float val : myFloats) {; *f = val;; writer->Fill();; }; ```. Relationship to other ROOT components; -------------------------------------. The RNTuple classes have the following relationship to other parts of ROOT. The RNTuple classes use core ROOT infrastructure classes, such as error handling and logging.; When necessary, RNTuple uses a `TFile` for reading and writing.; The cases of writing to a local file and reading from a local file, a file from XRootD or from HTTP, do _not_ require `TFile`.; For these cases, RNTuple depends on the `RRawFile` class and its XRootD and Davix plugins. For user-defined classes as well as sets and maps, RNTuple uses `TClass`.; Simple types and other stdlib classes are natively supported and do not require dictionaries.; See the format specification for an exhaustive list of types supported in RNTuple.; The streamer field uses the standard ROOT streaming machinery. Integration to RDataFrame is provided through an RNTuple data source.; A universal RDataFrame constructor can create a data frame from either a TTree or an RNTuple with the same syntax. The RBrowser uses RNTuple classes to display RNTuple dataset information. Future Features; ---------------. The following features are planned for after the first RNTuple production version:; - RNTupleProcessor: advanced RNTupleReader that allows for free combination of chains and (indexed/unaligned) friends; - Horizontal merging: persistified friends, analogous to a classical merge being a persistified chain; - An interface for bulk writing; - M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:28802,depend,depends,28802,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['depend'],['depends']
Integrability,"` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning backslashes in escaped newlines. Possible values:. * ``ENAS_DontAlign`` (in configuration: ``DontAlign``); Don't align escaped newlines. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. * ``ENAS_Left`` (in configuration: ``Left``); Align escaped newlines as far left as possible. .. code-block:: c++. true:; #define A \; int aaaa; \; int b; \; int dddddddddd;. false:. * ``ENAS_Right`` (in configuration: ``Right``); Align escaped newlines in the right-most column. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AlignOperands>`; If ``true``, horizontally align operands of binary and ternary; expressions. Possible values:. * ``OAS_DontAlign`` (in configuration: ``DontAlign``); Do not align operands of binary and ternary expressions.; The wrapped lines are indented ``ContinuationIndentWidth`` spaces from; the start of the line. * ``OAS_Align`` (in configuration: ``Align``); Horizontally align operands of binary and ternary expressions. Specifically, this aligns operands of a single expression that needs; to be split over multiple lines, e.g.:. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb +; ccccccccccccccc;. When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is; aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. * ``OAS_AlignAfterOperator`` (in configuration: ``AlignAfterOperator``); Horizontally align operands of binary and ternary expressions. This is similar to ``AO_Align``, except when; ``BreakBeforeBinaryOperators`` is set, the operator is un-indented so; that the wrapped operand is aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. .. _AlignTrailingComments:. **AlignTrailingComments** (``TrailingCommentsAlignmentStyle``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:21641,wrap,wrapped,21641,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrapped']
Integrability,"` and `RooMomentMorphFuncND` were almost exactly the same,; only that one inherited from `RooAbsPdf` and the other from `RooAbsReal`. Thanks to the `RooWrapperPdf`, this code duplication in the RooFit implementation can now be avoided.; Instead of using the removed `RooMomentMorphND` (which is the pdf), you now need to use the `RooMomentMorphFuncND`,; change its behavior to exactly match the formter `RooMomentMorphND`, and then wrap it into a pdf object:. ```C++; RooMomentMorphFuncND func{<constructor args you previously passed to RooMomentMorphFunc>};. func.setPdfMode(); // change behavior to be exactly like the former RooMomentMorphND. // Pass the selfNormalized=true` flag to the wrapper because the; RooMomentMorphFuncND already normalizes itself in pdf mode.; RooWrapperPdf pdf{""pdf_name"", ""pdf_name"", func, /*selfNormalized=*/true};; ```. ### Removal of several internal classes from the public RooFit interface. Several RooFit classes of which the headers are publicly exposed in the interface were only meant as implementation details of other RooFit classes.; Some of these classes are now removed from the public interface:. 1. `RooGenProdProj`, which was an implementation detail of the `RooProdPdf`; 2. `RooScaledFunc`, which was an implementation detail of the plotting in RooFit; In the supposedly very rare case where you used this class in your own; implementations, just multiply the underlying RooAbsReal function with the; scale factor and create a RooRealBinding, e.g.:; ```c++; RooProduct scaledFunc{""scaled_func"", """", func, scaleFactor};; RooRealBinding scaleBind(scaledFunc, x) ;; ```; instead of:; ```c++; RooRealBinding binding(func, x) ;; RooScaledFunc scaledBinding(binding, scaleFactor);; ```; 3. The `RooAbsRootFinder`, which was the base class of `RooBrentRootFinder`.; The `RooAbsRootFinder` was only used as the base class of; `RooBrentRootFinder`, which is an implementation detail of several; RooFit/RooStats functions. However, polymorphism never not relevan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:14827,interface,interface,14827,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['interface'],['interface']
Integrability,"` element to initialize. Semantics:; """""""""""""""""""". The '``llvm.va_start``' intrinsic works just like the ``va_start`` macro; available in C. In a target-dependent way, it initializes the; ``va_list`` element to which the argument points, so that the next call; to ``va_arg`` will produce the first variable argument passed to the; function. Unlike the C ``va_start`` macro, this intrinsic does not need; to know the last argument of the function as the compiler can figure; that out. '``llvm.va_end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.va_end(ptr <arglist>). Overview:; """""""""""""""""". The '``llvm.va_end``' intrinsic destroys ``<arglist>``, which has been; initialized previously with ``llvm.va_start`` or ``llvm.va_copy``. Arguments:; """""""""""""""""""". The argument is a pointer to a ``va_list`` to destroy. Semantics:; """""""""""""""""""". The '``llvm.va_end``' intrinsic works just like the ``va_end`` macro; available in C. In a target-dependent way, it destroys the ``va_list``; element to which the argument points. Calls to; :ref:`llvm.va_start <int_va_start>` and; :ref:`llvm.va_copy <int_va_copy>` must be matched exactly with calls to; ``llvm.va_end``. .. _int_va_copy:. '``llvm.va_copy``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.va_copy(ptr <destarglist>, ptr <srcarglist>). Overview:; """""""""""""""""". The '``llvm.va_copy``' intrinsic copies the current argument position; from the source argument list to the destination argument list. Arguments:; """""""""""""""""""". The first argument is a pointer to a ``va_list`` element to initialize.; The second argument is a pointer to a ``va_list`` element to copy from. Semantics:; """""""""""""""""""". The '``llvm.va_copy``' intrinsic works just like the ``va_copy`` macro; available in C. In a target-dependent way, it copies the source; ``va_list`` element into the destination ``va_list`` element. This; intrinsic is necessary because the `` llvm.va_start`` intrinsic may be; arbitrarily complex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:494366,depend,dependent,494366,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependent']
Integrability,"` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The core; library (`libCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:16852,depend,depends,16852,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['depend'],['depends']
Integrability,"` or `TThreadExecutor`.; - Add `T RVec<T>::at>(size_t, T)` method to allow users to specify a default value to be returned in case the vector is shorter than the position specified. No exception is thrown.; - Add the `Concatenate` helper to merge the content of two `RVec<T>` instances.; - Generalise the `VecOps::Map` utility allowing to apply a callable on a set of RVecs and not only to one.; - Add the `DeltaR2`, `DeltaR` and `DeltaPhi` helpers for RVec.; - Add the `InvariantMass(es)` helpers computing the invariant mass from particle kinematics stored in RVecs.; - Add the `Max`, `Min`, `ArgMax`, and `ArgMin` helpers for RVec.; - Add the `Construct` helper to build an `RVec<T>` starting from N `RVec<P_i>`, where a constructor `T::T(P_0, P_1, ..., P_Nm1)` exists.; - Experimental PyROOT: Add `AsRVec` helper to adopt memory owned by numpy arrays with RVecs. ### [Clad](https://github.com/vgvassilev/clad); - Upgrade Clad to 0.5 The new release includes some improvements in both; Forward and Reverse mode:; * Extend the way to specify a dependent variables. Consider function,; `double f(double x, double y, double z) {...}`, `clad::differentiate(f, ""z"")`; is equivalent to `clad::differentiate(f, 2)`. `clad::gradient(f, ""x, y"")`; differentiates with respect to `x` and `y` but not `z`. The gradient results; are stored in a `_result` parameter in the same order as `x` and `y` were; specified. Namely, the result of `x` is stored in `_result[0]` and the result; of `y` in `_result[1]`. If we invert the arguments specified in the string to; `clad::gradient(f, ""y, x"")` the results will be stored inversely.; * Enable recursive differentiation.; * Support single- and multi-dimensional arrays -- works for arrays with constant; size like `double A[] = {1, 2, 3};`, `double A[3];` or `double A[1][2][3][4];`. ## RooFit Libraries; ### RooJohnson PDF; The Johnson SU PDF has been added to RooFit. It comes with an analytical integral and a generator function,; which make it superior (faster an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:13482,depend,dependent,13482,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['depend'],['dependent']
Integrability,"` section for more details).; - `Snapshot` now returns a `RResultPtr` like all other actions: specifically, this is a pointer to a new `RDataFrame` which will run on the snapshotted dataset.; - `RDataFrame` has been removed from tree/treeplayer and put in its own package, tree/dataframe. The library where this code can be found is `libROOTDataFrame`. This new library is included in the list provided by `root-config --libs`.; - The `TArrayBranch` class has been removed and replaced by the more powerful `RVec` (see the `New features` section for more details).; - All `RDataFrame` tutorials are now prefixed with `df` rather than `tdf`.; - Histograms and profiles returned by RDataFrame (e.g. by a Histo1D action) are now not associated to a ROOT directory (their fDirectory is a nullptr).; The following still works as expected:; ```; auto h = tdf.Histo1D(""x"");; TFile f(fname, ""RECREATE"");; h->Write(); // event loop is run here and h is written to the TFile f; ```. #### New features; - The TDataSource interface changed. The `TDataSource::SetEntry` method now returns a boolean. If true the entry is processed within the event loop managed by the tdf, skipped otherwise.; - The TLazyDS data source has been added. It allows to create a source starting from ResultProxies to vectors.; - `TDataFrameInterface<T>::Report` returns a `TCutflowReport` object which can be inspected programmatically.; - Add `Aggregate` action and implement `Reduce` in terms of it.; - Add support for a more general leafname syntax that includes pathnames with multiple dots, such as ""myBranch.mySubBranch.myLeaf"". This is available both for jitted expressions and for lists of column names.; - The CSV data source (TCsvDS) can now be constructed with a chunk size parameter, and as a result the CSV file will be read progressively, in chunks of the specified size. This can be used to prevent the whole CSV file from being read into memory at once, thus reducing the memory footprint of this data source.; - Add th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:7221,interface,interface,7221,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['interface'],['interface']
Integrability,"` to actually handle binary data (previous limited to ascii). ## Networking Libraries. * When seeing too many requested ranges, Apache 2.4 now simply sends the whole file; (MaxRanges configuration parameter). TWebFile can handle this case now, but this can; trigger multiple transmissions of the full file. TWebFile warns when Apache reacts by; sending the full file. ## GUI Libraries. * A new `Browser.ExpandDirectories` option (the default is `yes`) has been added, allowing to prevent expanding the parent directory tree in the ROOT Browser (for example on nfs). ## Language Bindings. ### PyROOT. * Added a new configuration option to disable processing of the rootlogon[.py|C] macro in addition; ro the -n option in the command arguments. To disable processing the rootlogon do the following; before any other command that will trigger initialization:; ```; >>> import ROOT; >>> ROOT.PyConfig.DisableRootLogon = True; >>> ...; ```. ### Notebook integration. * Refactoring of the Jupyter integration layer into the new package JupyROOT.; * Added ROOT [Jupyter Kernel for ROOT](https://root.cern.ch/root-has-its-jupyter-kernel); * Magics are now invoked with standard syntax ""%%"", for example ""%%cpp"".; * The methods ""toCpp"" and ""toPython"" have been removed.; * Factorise output capturing and execution in an accelerator library and use ctypes to invoke functions.; * When the ROOT kernel is used, the output is consumed progressively; * Capture unlimited output also when using an IPython Kernel (fixes [ROOT-7960]). ## JavaScript ROOT. - New geometry (TGeo) classes support:; - browsing through volumes hieararchy; - changing visibility flags; - drawing of selected volumes; - support of large (~10M volumes) models, only most significant volumes are shown; - one could activate several clip planes (only with WebGL); - interaction with object browser to change visibility flags or focus on selected volume; - support of floating browser for TGeo objects; - intensive use of HTML Worker to offloa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:25623,integrat,integration,25623,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['integrat'],['integration']
Integrability,"` to be approximated as ``x *; (1.0 / y)``. This pragma can be used to disable reciprocal; approximation when it is otherwise enabled for the translation unit; with the ``-freciprocal-math`` flag or other fast-math options. The; pragma can take two values: ``on`` and ``off``. .. code-block:: c++. float f(float x, float y); {; // Enable floating point reciprocal approximation; #pragma clang fp reciprocal(on); return x / y;; }. ``#pragma clang fp contract`` specifies whether the compiler should; contract a multiply and an addition (or subtraction) into a fused FMA; operation when supported by the target. The pragma can take three values: ``on``, ``fast`` and ``off``. The ``on``; option is identical to using ``#pragma STDC FP_CONTRACT(ON)`` and it allows; fusion as specified the language standard. The ``fast`` option allows fusion; in cases when the language standard does not make this possible (e.g. across; statements in C). .. code-block:: c++. for(...) {; #pragma clang fp contract(fast); a = b[i] * c[i];; d[i] += a;; }. The pragma can also be used with ``off`` which turns FP contraction off for a; section of the code. This can be useful when fast contraction is otherwise; enabled for the translation unit with the ``-ffp-contract=fast-honor-pragmas`` flag.; Note that ``-ffp-contract=fast`` will override pragmas to fuse multiply and; addition across statements regardless of any controlling pragmas. ``#pragma clang fp exceptions`` specifies floating point exception behavior. It; may take one of the values: ``ignore``, ``maytrap`` or ``strict``. Meaning of; these values is same as for `constrained floating point intrinsics <http://llvm.org/docs/LangRef.html#constrained-floating-point-intrinsics>`_. .. code-block:: c++. {; // Preserve floating point exceptions; #pragma clang fp exceptions(strict); z = x + y;; if (fetestexcept(FE_OVERFLOW)); ...; }. A ``#pragma clang fp`` pragma may contain any number of options:. .. code-block:: c++. void func(float *dest, float a, float",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:171854,contract,contract,171854,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['contract'],['contract']
Integrability,"` to your top-level XML's `<Measurement>` entry. This deprecation implied that the constant parameter flag in the; `RooStats:HistFactory::NormFactor` class had no effect as well. To avoid; ambiguity in the future, the possibility to set and retrieve this flag with; `NormFactor::SetConst()` and `NormFactor::GetConst()` was removed, as well as the; `Sample::AddNormFactor(std::string Name, double Val, double Low, double High, bool Const)`; overload. Also, the aforementioned deprecation warning is not printed anymore. ### Removal of `RooAbsMinimizerFcn` and `RooMinimizerFcn` from the public interface. The `RooAbsMinimizerFcn` class and its implementation `RooMinimizerFcn` were removed from the public interface.; These classes are implementation details of the RooMinimizer and should not be used in your code.; In the unlikely case that this causes any problem for you, please open a GitHub issue requesting to extend the RooMinimizer by the needed functionality. ### Vectorize `RooAbsBinning` interface for bin index lookups. The `RooAbsBinning` interface for bin index lookups was changed to enable vectorized implementations.; Instead of having the override `RooAbsBinning::binNumber()`, the binning implementations now have to override the `RooAbsBinning::binNumbers()` function to evaluate the bin indices of multiple values in one function call. ### Disable relative and absolute epsilon in `RooAbsRealLValue::inRange()`. So far, the `RooAbsRealLValue::inRange()` function used the following; undocumented convention to check whether a value `x` is in the range with; limits `a` and `b`: test if `[x - eps * x, x + eps * x]` overlaps with `[a, b]`, where the; parameter `eps` is defined as `max(epsRel * x, epsAbs)`. The values of the relative and absolute epsilons were inconsistent among the overloads:. * [RooAbsRealLValue::inRange(const char* rangeName)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#ab6050a0c3e5583b9d755a38fd7fb82f7): `epsRel = 1e-8, epsAbs = 0`; * [RooAb",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:24609,interface,interface,24609,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['interface'],['interface']
Integrability,"`' instruction is used to introduce happens-before edges; between operations. Arguments:; """""""""""""""""""". '``fence``' instructions take an :ref:`ordering <ordering>` argument which; defines what *synchronizes-with* edges they add. They can only be given; ``acquire``, ``release``, ``acq_rel``, and ``seq_cst`` orderings. Semantics:; """""""""""""""""""". A fence A which has (at least) ``release`` ordering semantics; *synchronizes with* a fence B with (at least) ``acquire`` ordering; semantics if and only if there exist atomic operations X and Y, both; operating on some atomic object M, such that A is sequenced before X, X; modifies M (either directly or through some side effect of a sequence; headed by X), Y is sequenced before B, and Y observes M. This provides a; *happens-before* dependency between A and B. Rather than an explicit; ``fence``, one (but not both) of the atomic operations X or Y might; provide a ``release`` or ``acquire`` (resp.) ordering constraint and; still *synchronize-with* the explicit ``fence`` and establish the; *happens-before* edge. A ``fence`` which has ``seq_cst`` ordering, in addition to having both; ``acquire`` and ``release`` semantics specified above, participates in; the global program order of other ``seq_cst`` operations and/or; fences. Furthermore, the global ordering created by a ``seq_cst``; fence must be compatible with the individual total orders of; ``monotonic`` (or stronger) memory accesses occurring before and after; such a fence. The exact semantics of this interaction are somewhat; complicated, see the C++ standard's `[atomics.order]; <https://wg21.link/atomics.order>`_ section for more details. A ``fence`` instruction can also take an optional; "":ref:`syncscope <syncscope>`"" argument. Example:; """""""""""""""". .. code-block:: text. fence acquire ; yields void; fence syncscope(""singlethread"") seq_cst ; yields void; fence syncscope(""agent"") seq_cst ; yields void. .. _i_cmpxchg:. '``cmpxchg``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:424572,synchroniz,synchronize-with,424572,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['synchroniz'],['synchronize-with']
Integrability,"`) is used to compile C family languages. The; command-line interface of the frontend is considered to be an implementation; detail, intentionally has no external documentation, and is subject to change; without notice. Language frontends for other languages; --------------------------------------. Clang can be provided with inputs written in non-C-family languages. In such; cases, an external tool will be used to compile the input. The; currently-supported languages are:. * Ada (``-x ada``, ``.ad[bs]``); * Fortran (``-x f95``, ``.f``, ``.f9[05]``, ``.for``, ``.fpp``, case-insensitive); * Java (``-x java``). In each case, GCC will be invoked to compile the input. Assembler; ---------. Clang can either use LLVM's integrated assembler or an external system-specific; tool (for instance, the GNU Assembler on GNU OSes) to produce machine code from; assembly.; By default, Clang uses LLVM's integrated assembler on all targets where it is; supported. If you wish to use the system assembler instead, use the; ``-fno-integrated-as`` option. Linker; ------. Clang can be configured to use one of several different linkers:. * GNU ld; * GNU gold; * LLVM's `lld <https://lld.llvm.org>`_; * MSVC's link.exe. Link-time optimization is natively supported by lld, and supported via; a `linker plugin <https://llvm.org/docs/GoldPlugin.html>`_ when using gold. The default linker varies between targets, and can be overridden via the; ``-fuse-ld=<linker name>`` flag. Runtime libraries; =================. A number of different runtime libraries are required to provide different; layers of support for C family programs. Clang will implicitly link an; appropriate implementation of each runtime library, selected based on; target defaults or explicitly selected by the ``--rtlib=`` and ``--stdlib=``; flags. The set of implicitly-linked libraries depend on the language mode. As a; consequence, you should use ``clang++`` when linking C++ programs in order; to ensure the C++ runtimes are provided. .. no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:4244,integrat,integrated-as,4244,interpreter/llvm-project/clang/docs/Toolchain.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst,1,['integrat'],['integrated-as']
Integrability,"`) or compiled (`TROOT::AddExtraInterpreterArgs({""-I...""})` before interpreter construction). If you called `ROOT_GENERATE_DICTIONARY(Dict ${CMAKE_CURRENT_SOURCE_DIR}/subdir/Header1.h LINKDEF LinkDef.h)` then update that; call to `ROOT_GENERATE_DICTIONARY(Dict Header1.h OPTIONS -I subdir LINKDEF LinkDef.h)` *if* the header is usually included as; `#include ""Header1.h""`, or to `ROOT_GENERATE_DICTIONARY(Dict subdir/Header1.h LINKDEF LinkDef.h)` *if* the header is usually; included as `#include ""subdir/Header1.h""`. I.e. the general rule is: pass to `ROOT_GENERATE_DICTIONARY` (or; `ROOT_STANDARD_LIBRARY_PACKAGE`) the spelling as `#include`ed. As an important side-effect, `ROOT_GENERATE_DICTIONARY` and thus `ROOT_STANDARD_LIBRARY_PACKAGE` now *require* the header to; be found at configuration time. We have seen too many cases where the header location was mis-stated, and as a consequence,; CMake did not generate the proper dependencies. If the header should not be taken into account for dependencies and / or if; the header will not be found (e.g. the standard library's `vector`) please pass the header through the `NODEPHEADERS` option; to `ROOT_GENERATE_DICTIONARY` or `ROOT_STANDARD_LIBRARY_PACKAGE`. We believe that this simplification / regularization of behavior, and the additional checks are worth the possible changes; on the user side. ## PyROOT. If the fix or new feature is a pythonization related to a C++ class, the change is added to the respective section above. ### Current PyROOT. - Fix compatibility with Python3.7 (ROOT-9922, ROOT-9871, ROOT-9809); - Fix lookup for templated methods (ROOT-9789); - Fix lookup for templated free functions (ROOT-9836). ### Experimental PyROOT. - All pythonisations from current PyROOT already migrated (`TTree` and subclasses, `TDirectory` and subclasses,; `TCollection` and subclasses, `TObject`, `TClass`, `TString`, `TObjString`, `TIter`, `TStyle`, `TH1`, `TFX`, `TMinuit`, `TVector3`,; `TVectorT`, `TArray`, `TCollection`, `TSeqColl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:25543,depend,dependencies,25543,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['depend'],['dependencies']
Integrability,"`). The twine delays the actual concatenation; of strings until it is actually required, at which point it can be efficiently; rendered directly into a character array. This avoids unnecessary heap; allocation involved in constructing the temporary results of string; concatenation. See ``llvm/ADT/Twine.h`` (`doxygen; <https://llvm.org/doxygen/Twine_8h_source.html>`__) and :ref:`here <dss_twine>`; for more information. As with a ``StringRef``, ``Twine`` objects point to external memory and should; almost never be stored or mentioned directly. They are intended solely for use; when defining a function which should be able to efficiently accept concatenated; strings. .. _formatting_strings:. Formatting strings (the ``formatv`` function); ---------------------------------------------; While LLVM doesn't necessarily do a lot of string manipulation and parsing, it; does do a lot of string formatting. From diagnostic messages, to llvm tool; outputs such as ``llvm-readobj`` to printing verbose disassembly listings and; LLDB runtime logging, the need for string formatting is pervasive. The ``formatv`` is similar in spirit to ``printf``, but uses a different syntax; which borrows heavily from Python and C#. Unlike ``printf`` it deduces the type; to be formatted at compile time, so it does not need a format specifier such as; ``%d``. This reduces the mental overhead of trying to construct portable format; strings, especially for platform-specific types like ``size_t`` or pointer types.; Unlike both ``printf`` and Python, it additionally fails to compile if LLVM does; not know how to format the type. These two properties ensure that the function; is both safer and simpler to use than traditional formatting methods such as; the ``printf`` family of functions. Simple formatting; ^^^^^^^^^^^^^^^^^. A call to ``formatv`` involves a single **format string** consisting of 0 or more; **replacement sequences**, followed by a variable length list of **replacement values**.; A replacemen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:11362,message,messages,11362,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['message'],['messages']
Integrability,"`** inheritance come; some methods that use Introspection to help you see the data in the; object or class. For instance:. ``` {.cpp}; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; ```. For an example of `obj->Inspect()`, see ""Inspecting Objects"". ### Collections. To store an object in a ROOT collection, it must be a descendent of; **`TObject`**. This is convenient if you want to store objects of; different classes in the same collection and execute the method of the; same name on all members of the collection. For example, the list of; graphics primitives are in a ROOT collection called **`TList`**. When; the canvas is drawn, the `Paint` method is executed on the entire; collection. Each member may be a different class, and if the `Paint`; method is not implemented, **`TObject::Paint`** will be executed. ### Input/Output. The `TObject::Write` method is the interface to the ROOT I/O system. It; streams the object into a buffer using the `Streamer` method. It; supports cycle numbers and automatic schema evolution. See; ""Input/Output"". ### Paint/Draw. These graphics methods are defaults; their implementation in; **`TObject`** does not use the graphics subsystem. The `TObject::Draw`; method is simply a call to `AppendPad`. The `Paint` method is empty. The; default is provided so that one can call `Paint` in a collection. The; method `GetDrawOption` returns the draw option that was used when the; object was drawn on the canvas. This is especially relevant with; histograms and graphs. ### Clone/DrawClone. Two useful methods are `Clone` and `DrawClone`. The `Clone` method takes; a snapshot of the object with the `Streamer` and creates a new object.; The `DrawClone` method does the same thing and in addition draws the; clone. ### Browse. This method is called if the object is browse-able and is to be; displayed in the object browser. For exampl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:2582,interface,interface,2582,documentation/users-guide/AddingaClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md,1,['interface'],['interface']
Integrability,"`,; ``Clang module map modules`` or ``Clang c++ modules``. Module and module unit; ~~~~~~~~~~~~~~~~~~~~~~. A module consists of one or more module units. A module unit is a special; translation unit. Every module unit must have a module declaration. The syntax; of the module declaration is:. .. code-block:: c++. [export] module module_name[:partition_name];. Terms enclosed in ``[]`` are optional. The syntax of ``module_name`` and ``partition_name``; in regex form corresponds to ``[a-zA-Z_][a-zA-Z_0-9\.]*``. In particular, a literal dot ``.``; in the name has no semantic meaning (e.g. implying a hierarchy). In this document, module units are classified into:. * Primary module interface unit. * Module implementation unit. * Module interface partition unit. * Internal module partition unit. A primary module interface unit is a module unit whose module declaration is; ``export module module_name;``. The ``module_name`` here denotes the name of the; module. A module should have one and only one primary module interface unit. A module implementation unit is a module unit whose module declaration is; ``module module_name;``. A module could have multiple module implementation; units with the same declaration. A module interface partition unit is a module unit whose module declaration is; ``export module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. An internal module partition unit is a module unit whose module declaration; is ``module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. In this document, we use the following umbrella terms:. * A ``module interface unit`` refers to either a ``primary module interface unit``; or a ``module interface partition unit``. * An ``importable module unit`` refers to either a ``module interface unit``; or a ``internal module partition unit``. * A ``module partition unit`` refers to either a ``module interface partition unit``; or a ``interna",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:2933,interface,interface,2933,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interface']
Integrability,"`. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim` resides; in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one. ![ROOT::Math Numerical Integrator classes](pictures/Integration.png). The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:49288,integrat,integration,49288,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integration']
Integrability,"`. A comment starting with substring `LLVM-MCA-<INSTRUMENT_TYPE>`; brings data into scope for llvm-mca to use in its analysis for; all following instructions. If a comment with the same `INSTRUMENT_TYPE` is found later in the; instruction list, then the original InstrumentRegion will be; automatically ended, and a new InstrumentRegion will begin. If there are comments containing the different `INSTRUMENT_TYPE`,; then both data sets remain available. In contrast with an AnalysisRegion,; an InstrumentRegion does not need a comment to end the region. Comments that are prefixed with `LLVM-MCA-` but do not correspond to; a valid `INSTRUMENT_TYPE` for the target cause an error, except for; `BEGIN` and `END`, since those correspond to AnalysisRegions. Comments; that do not start with `LLVM-MCA-` are ignored by :program `llvm-mca`. An instruction (a MCInst) is added to an InstrumentRegion R only; if its location is in range [R.RangeStart, R.RangeEnd]. On RISCV targets, vector instructions have different behaviour depending; on the LMUL. Code can be instrumented with a comment that takes the; following form:. .. code-block:: none. # LLVM-MCA-RISCV-LMUL <M1|M2|M4|M8|MF2|MF4|MF8>. The RISCV InstrumentManager will override the schedule class for vector; instructions to use the scheduling behaviour of its pseudo-instruction; which is LMUL dependent. It makes sense to place RISCV instrument; comments directly after `vset{i}vl{i}` instructions, although; they can be placed anywhere in the program. Example of program with no call to `vset{i}vl{i}`:. .. code-block:: none. # LLVM-MCA-RISCV-LMUL M2; vadd.vv v2, v2, v2. Example of program with call to `vset{i}vl{i}`:. .. code-block:: none. vsetvli zero, a0, e8, m1, tu, mu; # LLVM-MCA-RISCV-LMUL M1; vadd.vv v2, v2, v2. Example of program with multiple calls to `vset{i}vl{i}`:. .. code-block:: none. vsetvli zero, a0, e8, m1, tu, mu; # LLVM-MCA-RISCV-LMUL M1; vadd.vv v2, v2, v2; vsetvli zero, a0, e8, m8, tu, mu; # LLVM-MCA-RISCV-LMUL M8; v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:12065,depend,depending,12065,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['depending']
Integrability,"`.; Following the usual procedure, setting the `TF1` though the constructor, will wrap it into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `RO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:48869,integrat,integration,48869,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integration']
Integrability,`1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/c-index-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-check; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-diff; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-extdef-mapping; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-format; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-format/fuzzer; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-fuzzer; - `6`; - `4`; - `2`; - :part:`66%`; * - clang/tools/clang-fuzzer/fuzzer-initialize; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-cxx; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-llvm; - `3`; - `1`; - `2`; - :part:`33%`; * - clang/tools/clang-fuzzer/proto-to-cxx; - `5`; - `0`; - `5`; - :none:`0%`; * - clang/tools/clang-fuzzer/proto-to-llvm; - `3`; - `0`; - `3`; - :none:`0%`; * - clang/tools/clang-import-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-linker-wrapper; - `3`; - `2`; - `1`; - :part:`66%`; * - clang/tools/clang-nvlink-wrapper; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-offload-bundler; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-offload-wrapper; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-pseudo; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-refactor; - `4`; - `4`; - `0`; - :good:`100%`; * - clang/tools/clang-rename; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-repl; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-scan-deps; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-shlib; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/diagtool; - `9`; - `0`; - `9`; - :none:`0%`; * - clang/tools/driver; - `4`; - `1`; - `3`; - :part:`25%`; * - clang/tools/libclang; - `35`; - `5`; - `30`; - :part:`14%`; * - clang/tools/scan-build-py/tests/functional/src/include; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/unittests/Analysis; - `6`; - `2`; - `4,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:11878,wrap,wrapper,11878,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['wrap'],['wrapper']
Integrability,`; - `1`; - :none:`0%`; * - clang/tools/clang-check; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-diff; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-extdef-mapping; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-format; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-format/fuzzer; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-fuzzer; - `6`; - `4`; - `2`; - :part:`66%`; * - clang/tools/clang-fuzzer/fuzzer-initialize; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-cxx; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-llvm; - `3`; - `1`; - `2`; - :part:`33%`; * - clang/tools/clang-fuzzer/proto-to-cxx; - `5`; - `0`; - `5`; - :none:`0%`; * - clang/tools/clang-fuzzer/proto-to-llvm; - `3`; - `0`; - `3`; - :none:`0%`; * - clang/tools/clang-import-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-linker-wrapper; - `3`; - `2`; - `1`; - :part:`66%`; * - clang/tools/clang-nvlink-wrapper; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-offload-bundler; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-offload-wrapper; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-pseudo; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-refactor; - `4`; - `4`; - `0`; - :good:`100%`; * - clang/tools/clang-rename; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-repl; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-scan-deps; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-shlib; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/diagtool; - `9`; - `0`; - `9`; - :none:`0%`; * - clang/tools/driver; - `4`; - `1`; - `3`; - :part:`25%`; * - clang/tools/libclang; - `35`; - `5`; - `30`; - :part:`14%`; * - clang/tools/scan-build-py/tests/functional/src/include; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/unittests/Analysis; - `6`; - `2`; - `4`; - :part:`33%`; * - clang/unittests/Analysis/FlowSensitive; - `14`; - `1,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:11952,wrap,wrapper,11952,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['wrap'],['wrapper']
Integrability,"`; This is a guide to validate a new release, during the release process. Most developers can ignore it. :doc:`HowToAddABuilder`; Instructions for adding new builder to LLVM buildbot master. :doc:`Packaging`; Advice on packaging LLVM into a distribution. :doc:`Release notes for the current release <ReleaseNotes>`; This describes new features, known bugs, and other limitations. .. _lists-forums:. Forums & Mailing Lists; ----------------------. If you can't find what you need in these docs, try consulting the; Discourse forums. There are also commit mailing lists for all commits to the LLVM Project.; The :doc:`CodeOfConduct` applies to all these forums and mailing lists. `LLVM Discourse`__; The forums for all things LLVM and related sub-projects. There are categories and subcategories for a wide variety of areas within LLVM. You can also view tags or search for a specific topic. .. __: https://discourse.llvm.org/. `Commits Archive (llvm-commits)`__; This list contains all commit messages that are made when LLVM developers; commit code changes to the repository. It also serves as a forum for; patch review (i.e. send patches here). It is useful for those who want to; stay on the bleeding edge of LLVM development. This list is very high; volume. .. __: http://lists.llvm.org/pipermail/llvm-commits/. `Bugs & Patches Archive (llvm-bugs)`__; This list gets emailed every time a bug is opened and closed. It is; higher volume than the LLVM-dev list. .. __: http://lists.llvm.org/pipermail/llvm-bugs/. `LLVM Announcements`__; If you just want project wide announcements such as releases, developers meetings, or blog posts, then you should check out the Announcement category on LLVM Discourse. .. __: https://discourse.llvm.org/c/announce/46. .. _online-sync-ups:. Online Sync-Ups; ---------------. A number of regular calls are organized on specific topics. It should be; expected that the range of topics will change over time. At the time of; writing, the following sync-ups are organi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:2976,message,messages,2976,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['message'],['messages']
Integrability,"`ASTImporterSharedState`` class. ExternalASTSource; ~~~~~~~~~~~~~~~~~. The ``ExternalASTSource`` is an abstract interface associated with the; ``ASTContext`` class. It provides the ability to read the declarations stored; within a declaration context either for iteration or for name lookup. A; declaration context with an external AST source may load its declarations; on-demand. This means that the list of declarations (represented as a linked; list, the head is ``DeclContext::FirstDecl``) could be empty. However, member; functions like ``DeclContext::lookup()`` may initiate a load. Usually, external sources are associated with precompiled headers. For example,; when we load a class from a PCH then the members are loaded only if we do want; to look up something in the class' context. In case of LLDB, an implementation of the ``ExternalASTSource`` interface is; attached to the AST context which is related to the parsed expression. This; implementation of the ``ExternalASTSource`` interface is realized with the help; of the ``ASTImporter`` class. This way, LLDB can reuse Clang's parsing; machinery while synthesizing the underlying AST from the debug data (e.g. from; DWARF). From the view of the ``ASTImporter`` this means both the ""to"" and the; ""from"" context may have declaration contexts with external lexical storage. If; a ``DeclContext`` in the ""to"" AST context has external lexical storage then we; must take extra attention to work only with the already loaded declarations!; Otherwise, we would end up with an uncontrolled import process. For instance,; if we used the regular ``DeclContext::lookup()`` to find the existing; declarations in the ""to"" context then the ``lookup()`` call itself would; initiate a new import while we are in the middle of importing a declaration!; (By the time we initiate the lookup we haven't registered yet that we already; started to import the node of the ""from"" context.) This is why we use; ``DeclContext::noload_lookup()`` instead. Class Te",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:107335,interface,interface,107335,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['interface'],['interface']
Integrability,"`Action`` interface that; had virtual methods for parse events, for example ``ActOnBinOp()``. When Clang; grew C++ support, the parser stopped supporting general ``Action`` clients --; it now always talks to the :ref:`Sema library <Sema>`. However, the Parser; still accesses AST objects only through opaque types like ``ExprResult`` and; ``StmtResult``. Only :ref:`Sema <Sema>` looks at the AST node contents of these; wrappers. .. _AST:. The AST Library; ===============. .. _ASTPhilosophy:. Design philosophy; -----------------. Immutability; ^^^^^^^^^^^^. Clang AST nodes (types, declarations, statements, expressions, and so on) are; generally designed to be immutable once created. This provides a number of key; benefits:. * Canonicalization of the ""meaning"" of nodes is possible as soon as the nodes; are created, and is not invalidated by later addition of more information.; For example, we :ref:`canonicalize types <CanonicalType>`, and use a; canonicalized representation of expressions when determining whether two; function template declarations involving dependent expressions declare the; same entity.; * AST nodes can be reused when they have the same meaning. For example, we; reuse ``Type`` nodes when representing the same type (but maintain separate; ``TypeLoc``\s for each instance where a type is written), and we reuse; non-dependent ``Stmt`` and ``Expr`` nodes across instantiations of a; template.; * Serialization and deserialization of the AST to/from AST files is simpler:; we do not need to track modifications made to AST nodes imported from AST; files and serialize separate ""update records"". There are unfortunately exceptions to this general approach, such as:. * The first declaration of a redeclarable entity maintains a pointer to the; most recent declaration of that entity, which naturally needs to change as; more declarations are parsed.; * Name lookup tables in declaration contexts change after the namespace; declaration is formed.; * We attempt to maintai",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:58088,depend,dependent,58088,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['dependent']
Integrability,"`FieldDecl`` instead of the ``ClassTemplateSpecializationDecl``. .. code-block:: cpp. auto Matcher = fieldDecl(hasName(""i2""));; auto *From = getFirstDecl<FieldDecl>(Matcher, FromUnit);. In this case we can see that an error is associated (``getImportDeclErrorIfAny``) to the specialization also, not just to the field:. .. code-block:: cpp. llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // check that the ClassTemplateSpecializationDecl is also marked as; // erroneous.; auto *FromSpec = getFirstDecl<ClassTemplateSpecializationDecl>(; classTemplateSpecializationDecl(hasName(""X"")), FromUnit);; assert(Importer.getImportDeclErrorIfAny(FromSpec));; // Btw, the error is also set for the FieldDecl.; assert(Importer.getImportDeclErrorIfAny(From));; return 1;; }. Polluted AST; """""""""""""""""""""""". We may recognize an error during the import of a dependent node. However, by that time, we had already created the dependant.; In these cases we do not remove the existing erroneous node from the ""to"" context, rather we associate an error to that node.; Let's extend the previous example with another class ``Y``.; This class has a forward definition in the ""to"" context, but its definition is in the ""from"" context.; We'd like to import the definition, but it contains a member whose type conflicts with the type in the ""to"" context:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i; };. class Y;; )"",; ""to.cc"");; ToUnit->enableSourceFileDiagnostics();; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i2; };; // field mismatch: ^^. class Y { void f() { X<int> xi; } };; )"",; ""from.cc"");; FromUnit->enableSourceFi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:16500,depend,dependant,16500,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,1,['depend'],['dependant']
Integrability,"`MSAN_OPTIONS=poison_in_dtor=0` before running; the program. Handling external code; ======================. MemorySanitizer requires that all program code is instrumented. This; also includes any libraries that the program depends on, even libc.; Failing to achieve this may result in false reports.; For the same reason you may need to replace all inline assembly code that writes to memory; with a pure C/C++ code. Full MemorySanitizer instrumentation is very difficult to achieve. To; make it easier, MemorySanitizer runtime library includes 70+; interceptors for the most common libc functions. They make it possible; to run MemorySanitizer-instrumented programs linked with; uninstrumented libc. For example, the authors were able to bootstrap; MemorySanitizer-instrumented Clang compiler by linking it with; self-built instrumented libc++ (as a replacement for libstdc++). Supported Platforms; ===================. MemorySanitizer is supported on the following OS:. * Linux; * NetBSD; * FreeBSD. Limitations; ===========. * MemorySanitizer uses 2x more real memory than a native run, 3x with; origin tracking.; * MemorySanitizer maps (but not reserves) 64 Terabytes of virtual; address space. This means that tools like ``ulimit`` may not work as; usually expected.; * Static linking is not supported.; * Older versions of MSan (LLVM 3.7 and older) didn't work with; non-position-independent executables, and could fail on some Linux; kernel versions with disabled ASLR. Refer to documentation for older versions; for more details.; * MemorySanitizer might be incompatible with position-independent executables; from FreeBSD 13 but there is a check done at runtime and throws a warning; in this case. Current Status; ==============. MemorySanitizer is known to work on large real-world programs; (like Clang/LLVM itself) that can be recompiled from source, including all; dependent libraries. More Information; ================. `<https://github.com/google/sanitizers/wiki/MemorySanitizer>`_; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:7771,depend,dependent,7771,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst,1,['depend'],['dependent']
Integrability,"`TAttText::SetTextColor` to set the text color. The `color` is the; color index. The colors are described in ""Color and Color Palettes"". ``` {.cpp}; root[] la->SetTextColor(color); ```. #### Setting Text Font. Use `TAttText::SetTextFont` to set the font. The parameter font is the; font code, combining the font and precision:; `font = 10 * fontID + precision`. ``` {.cpp}; root[] la->SetTextFont(font); ```. The table below lists the available fonts. The font IDs must be between; 1 and 14. The precision can be:. - Precision = 0 fast hardware fonts (steps in the size). - Precision = 1 scalable and rotate-able hardware fonts (see below). - Precision = 2 scalable and rotate-able hardware fonts. When precision 0 is used, only the original non-scaled system fonts are; used. The fonts have a minimum (4) and maximum (37) size in pixels.; These fonts are fast and are of good quality. Their size varies with; large steps and they cannot be rotated. Precision 1 and 2 fonts have a; different behavior depending if True Type Fonts (TTF) are used or not.; If TTF are used, you always get very good quality scalable and; rotate-able fonts. However, TTF are slow. Precision 1 and 2 fonts have a; different behavior for PostScript in case of **`TLatex`** objects:. - With precision 1, the PostScript text uses the old convention (see; **`TPostScript`**) for some special characters to draw sub and; superscripts or Greek text. - With precision 2, the ""PostScript"" special characters are drawn as; such. To draw sub and superscripts it is highly recommended to use; **`TLatex`** objects instead. For example: `font = 62` is the font with ID `6` and precision `2`. ![Font's examples](pictures/030000CF.png). The available fonts are:. +-----------+--------------------------+-----------------------+---------+------------+; | Font ID | X11 | True Type name | Is | ""boldness"" |; | | | | italic | |; +-----------+--------------------------+-----------------------+---------+------------+; | 1 | times-medium-i-n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:71087,depend,depending,71087,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['depend'],['depending']
Integrability,"`__typeof`` and C++ template argument substitution. .. admonition:: Rationale. Any compiler operation which incidentally strips type ""sugar"" from a type; will yield a type without the attribute, which may result in unexpected; behavior. .. _arc.objects.retains:. Retain count semantics; ----------------------. A retainable object pointer is either a :arc-term:`null pointer` or a pointer; to a valid object. Furthermore, if it has block pointer type and is not; ``null`` then it must actually be a pointer to a block object, and if it has; ``Class`` type (possibly protocol-qualified) then it must actually be a pointer; to a class object. Otherwise ARC does not enforce the Objective-C type system; as long as the implementing methods follow the signature of the static type.; It is undefined behavior if ARC is exposed to an invalid pointer. For ARC's purposes, a valid object is one with ""well-behaved"" retaining; operations. Specifically, the object must be laid out such that the; Objective-C message send machinery can successfully send it the following; messages:. * ``retain``, taking no arguments and returning a pointer to the object.; * ``release``, taking no arguments and returning ``void``.; * ``autorelease``, taking no arguments and returning a pointer to the object. The behavior of these methods is constrained in the following ways. The term; :arc-term:`high-level semantics` is an intentionally vague term; the intent is; that programmers must implement these methods in a way such that the compiler,; modifying code in ways it deems safe according to these constraints, will not; violate their requirements. For example, if the user puts logging statements; in ``retain``, they should not be surprised if those statements are executed; more or less often depending on optimization settings. These constraints are; not exhaustive of the optimization opportunities: values held in local; variables are subject to additional restrictions, described later in this; document. It is un",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:13097,message,message,13097,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['message'],"['message', 'messages']"
Integrability,"`` also records an extra; ``Stmt*`` that represents the *terminator* of the block. A terminator is; simply the statement that caused the control-flow, and is used to identify the; nature of the conditional control-flow between blocks. For example, in the; case of an if-statement, the terminator refers to the ``IfStmt`` object in the; AST that represented the given branch. To illustrate, consider the following code example:. .. code-block:: c++. int foo(int x) {; x = x + 1;; if (x > 2); x++;; else {; x += 2;; x *= 2;; }. return x;; }. After invoking the parser+semantic analyzer on this code fragment, the AST of; the body of ``foo`` is referenced by a single ``Stmt*``. We can then construct; an instance of ``CFG`` representing the control-flow graph of this function; body by single call to a static class method:. .. code-block:: c++. Stmt *FooBody = ...; std::unique_ptr<CFG> FooCFG = CFG::buildCFG(FooBody);. Along with providing an interface to iterate over its ``CFGBlocks``, the; ``CFG`` class also provides methods that are useful for debugging and; visualizing CFGs. For example, the method ``CFG::dump()`` dumps a; pretty-printed version of the CFG to standard error. This is especially useful; when one is using a debugger such as gdb. For example, here is the output of; ``FooCFG->dump()``:. .. code-block:: text. [ B5 (ENTRY) ]; Predecessors (0):; Successors (1): B4. [ B4 ]; 1: x = x + 1; 2: (x > 2); T: if [B4.2]; Predecessors (1): B5; Successors (2): B3 B2. [ B3 ]; 1: x++; Predecessors (1): B4; Successors (1): B1. [ B2 ]; 1: x += 2; 2: x *= 2; Predecessors (1): B4; Successors (1): B1. [ B1 ]; 1: return x;; Predecessors (2): B2 B3; Successors (1): B0. [ B0 (EXIT) ]; Predecessors (1): B1; Successors (0):. For each block, the pretty-printed output displays for each block the number of; *predecessor* blocks (blocks that have outgoing control-flow to the given; block) and *successor* blocks (blocks that have control-flow that have incoming; control-flow from the given bloc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:115234,interface,interface,115234,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['interface'],['interface']
Integrability,"`` or ``\`` on Windows. ``%/s, %/S, %/t, %/T``. Act like the corresponding substitution above but replace any ``\``; character with a ``/``. This is useful to normalize path separators. Example: ``%s: C:\Desktop Files/foo_test.s.tmp``. Example: ``%/s: C:/Desktop Files/foo_test.s.tmp``. ``%{s:real}, %{S:real}, %{t:real}, %{T:real}``; ``%{/s:real}, %{/S:real}, %{/t:real}, %{/T:real}``. Act like the corresponding substitution, including with ``/``, but use; the real path by expanding all symbolic links and substitute drives. Example: ``%s: S:\foo_test.s.tmp``. Example: ``%{/s:real}: C:/SDrive/foo_test.s.tmp``. ``%:s, %:S, %:t, %:T``. Act like the corresponding substitution above but remove colons at; the beginning of Windows paths. This is useful to allow concatenation; of absolute paths on Windows to produce a legal path. Example: ``%s: C:\Desktop Files\foo_test.s.tmp``. Example: ``%:s: C\Desktop Files\foo_test.s.tmp``. ``%errc_<ERRCODE>``. Some error messages may be substituted to allow different spellings; based on the host platform. The following error codes are currently supported:; ENOENT, EISDIR, EINVAL, EACCES. Example: ``Linux %errc_ENOENT: No such file or directory``. Example: ``Windows %errc_ENOENT: no such file or directory``. ``%if feature %{<if branch>%} %else %{<else branch>%}``. Conditional substitution: if ``feature`` is available it expands to; ``<if branch>``, otherwise it expands to ``<else branch>``.; ``%else %{<else branch>%}`` is optional and treated like ``%else %{%}``; if not present. ``%(line)``, ``%(line+<number>)``, ``%(line-<number>)``. The number of the line where this substitution is used, with an; optional integer offset. These expand only if they appear; immediately in ``RUN:``, ``DEFINE:``, and ``REDEFINE:`` directives.; Occurrences in substitutions defined elsewhere are never expanded.; For example, this can be used in tests with multiple RUN lines,; which reference the test file's line numbers. **LLVM-specific substitutions:**. ``%shl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:26203,message,messages,26203,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['message'],['messages']
Integrability,"`` {.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ```. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remembering the active navigation state is; to use parallel navigation. The following paragraphs will describe the; usage of a single navigator. All setters/getters for navigation state; parameters as well as navigation queries provided by **`TGeoNavigator`**; are interfaced by **`TGeoManager`** and will act on the current; navigator. ### Initializing the Starting Point. The current point (`x,y,z`) known by the modeller is stored as; `Double_t fCurrentPoint[3]` by the navigator class. This array of the; three coordinates is defined in the current global reference system and; can be retrieved any time:. ``` {.cpp}; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; ```. Initializing this point can be done like:. ``` {.cpp}; gGeoManager->SetCurrentPoint(x,y,z);; // or:; gGeoManager->SetCurrentPoint(Double_t *point[3]);; ```. ### Initializing the Direction. In order to move inside geometry starting with the current point, the; modeller needs to know the current direction `(nx,ny,nz)`. This; direction is stored as `Double_t fCurrentDirection[3]` by the navigator; and it represents a direction in the global frame. It can be retrieved; with:. ``` {.cpp}; Const Double_t *cdir = gGeoManager->GetCurrentDirection();; ```. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:103918,interface,interfaced,103918,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interfaced']
Integrability,"`` {.cpp}; std::shared_ptr<RooFit::TestStatistics::RooAbsL> likelihood = RooFit::TestStatistics::buildLikelihood(pdf, data);; ```; `buildLikelihood` actually returns a `unique_ptr`; storing the result in a `shared_ptr` as done here is just one possible use-case. ### Usage example: Create a likelihood of a simultaneous PDF with constraint terms and global observables (and other optional arguments); The `RooAbsPdf::fitTo` or `RooAbsPdf::createNLL` interfaces could take in a set of optional parameters as `RooCmdArg` objects.; In `TestStatistics::buildLikelihood`, we have implemented 4 of these options as separate types while an additional one is supported as a simple string:; - `RooAbsL::Extended`: an enum class used to set extended term calculation `on`, `off` or use `Extended::Auto` to determine automatically based on the pdf whether to activate or not.; - `ConstrainedParameters`: Initialized with a `RooArgSet` of parameters that are constrained. Pdf components dependent on these alone are added to a subsidiary likelihood term.; - `ExternalConstraints`: Initialized with a `RooArgSet` of external constraint pdfs, i.e. constraints not necessarily in the pdf itself. These are always added to the subsidiary likelihood.; - `GlobalObservables`: Initialized with a `RooArgSet` of observables that have a constant value, independent of the dataset events. Pdf components dependent on these alone are added to the subsidiary likelihood. \note This overrides all other likelihood parameters (like those in the `ConstrainedParameters` argument) if present.; - Finally, a string argument `global_observables_tag` can be given, which should be set as attribute in any pdf component to indicate that it is a global observable. Can be used instead of or in addition to a `GlobalObservables` argument. Using these parameters, creating a likelihood of a simultaneous pdf (i.e. a `RooSimultaneous`) with constrained terms and global observables can be done with:. ``` {.cpp}; auto likelihood = RooFit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md:4019,depend,dependent,4019,roofit/doc/developers/test_statistics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md,1,['depend'],['dependent']
Integrability,"``#pragma clang fp eval_method`` allows floating-point behavior to be specified; for a section of the source code. This pragma can appear at file or namespace; scope, or at the start of a compound statement (excluding comments).; The pragma is active within the scope of the compound statement. When ``pragma clang fp eval_method(source)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=source`` is enabled. Rounds intermediate results to; source-defined precision. When ``pragma clang fp eval_method(double)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=double`` is enabled. Rounds intermediate results to; ``double`` precision. When ``pragma clang fp eval_method(extended)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-eval-method=extended`` is enabled. Rounds intermediate results to; target-dependent ``long double`` precision. In Win32 programming, for instance,; the long double data type maps to the double, 64-bit precision data type. The full syntax this pragma supports is; ``#pragma clang fp eval_method(source|double|extended)``. .. code-block:: c++. for(...) {; // The compiler will use long double as the floating-point evaluation; // method.; #pragma clang fp eval_method(extended); a = b[i] * c[i] + e;; }. Note: ``math.h`` defines the typedefs ``float_t`` and ``double_t`` based on the active; evaluation method at the point where the header is included, not where the; typedefs are used. Because of this, it is unwise to combine these typedefs with; ``#pragma clang fp eval_method``. To catch obvious bugs, Clang will emit an; error for any references to these typedefs within the scope of this pragma;; however, this is not a fool-proof protection, and programmers must take care. The ``#pragma float_control`` pragma allows precise floating-point; semantics and floating-po",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:173953,depend,dependent,173953,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['depend'],['dependent']
Integrability,"``-fmath-errno``. When ``pragma float_control(precise, off)`` is enabled, unsafe-floating point; optimizations are enabled in the section of code governed by the pragma.; Effectively ``-ffast-math`` is enabled and ``-ffp-contract=fast``. This pragma; disables ``-fmath-errno``. When ``pragma float_control(except, on)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-exception-behavior=strict`` is enabled,; when ``pragma float_control(except, off)`` is enabled, the section of code; governed by the pragma behaves as though the command-line option; ``-ffp-exception-behavior=ignore`` is enabled. The full syntax this pragma supports is; ``float_control(except|precise, on|off [, push])`` and; ``float_control(push|pop)``.; The ``push`` and ``pop`` forms, including using ``push`` as the optional; third argument, can only occur at file scope. .. code-block:: c++. for(...) {; // This block will be compiled with -fno-fast-math and -ffp-contract=on; #pragma float_control(precise, on); a = b[i] * c[i] + e;; }. Specifying an attribute for multiple declarations (#pragma clang attribute); ===========================================================================. The ``#pragma clang attribute`` directive can be used to apply an attribute to; multiple declarations. The ``#pragma clang attribute push`` variation of the; directive pushes a new ""scope"" of ``#pragma clang attribute`` that attributes; can be added to. The ``#pragma clang attribute (...)`` variation adds an; attribute to that scope, and the ``#pragma clang attribute pop`` variation pops; the scope. You can also use ``#pragma clang attribute push (...)``, which is a; shorthand for when you want to add one attribute to a new scope. Multiple push; directives can be nested inside each other. The attributes that are used in the ``#pragma clang attribute`` directives; can be written using the GNU-style syntax:. .. code-block:: c++. #pragma clang attribute push (__attribu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:176817,contract,contract,176817,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['contract'],['contract']
Integrability,"``. The Offset field is the offset in bytes; to the start of the bitcode stream in the file, and the Size field is the size; in bytes of the stream. CPUType is a target-specific value that can be used to; encode the CPU of the target. .. _native object file:. Native Object File Wrapper Format; =================================. Bitcode files for LLVM IR may also be wrapped in a native object file; (i.e. ELF, COFF, Mach-O). The bitcode must be stored in a section of the object; file named ``__LLVM,__bitcode`` for MachO or ``.llvmbc`` for the other object; formats. ELF objects additionally support a ``.llvm.lto`` section for; :doc:`FatLTO`, which contains bitcode suitable for LTO compilation (i.e. bitcode; that has gone through a pre-link LTO pipeline). The ``.llvmbc`` section; predates FatLTO support in LLVM, and may not always contain bitcode that is; suitable for LTO (i.e. from ``-fembed-bitcode``). The wrapper format is useful; for accommodating LTO in compilation pipelines where intermediate objects must; be native object files which contain metadata in other sections. . Not all tools support this format. For example, lld and the gold plugin will; ignore the ``.llvmbc`` section when linking object files, but can use; ``.llvm.lto`` sections when passed the correct command line options. .. _encoding of LLVM IR:. LLVM IR Encoding; ================. LLVM IR is encoded into a bitstream by defining blocks and records. It uses; blocks for things like constant pools, functions, symbol tables, etc. It uses; records for things like instructions, global variable descriptors, type; descriptions, etc. This document does not describe the set of abbreviations; that the writer uses, as these are fully self-described in the file, and the; reader is not allowed to build in any knowledge of this. Basics; ------. LLVM IR Magic Number; ^^^^^^^^^^^^^^^^^^^^. The magic number for LLVM IR files is:. :raw-html:`<tt><blockquote>`; ['B'\ :sub:`8`, 'C'\ :sub:`8`, 0x0\ :sub:`4`, 0xC\ :sub:`4`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:19558,wrap,wrapper,19558,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['wrap'],['wrapper']
Integrability,"``User`` is; known as a *use-def* chain. Instances of class ``Instruction`` are common; ``User`` s, so we might want to iterate over all of the values that a particular; instruction uses (that is, the operands of the particular ``Instruction``):. .. code-block:: c++. Instruction *pi = ...;. for (Use &U : pi->operands()) {; Value *v = U.get();; // ...; }. Declaring objects as ``const`` is an important tool of enforcing mutation free; algorithms (such as analyses, etc.). For this purpose above iterators come in; constant flavors as ``Value::const_use_iterator`` and; ``Value::const_op_iterator``. They automatically arise when calling; ``use/op_begin()`` on ``const Value*``\ s or ``const User*``\ s respectively.; Upon dereferencing, they return ``const Use*``\ s. Otherwise the above patterns; remain unchanged. .. _iterate_preds:. Iterating over predecessors & successors of blocks; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Iterating over the predecessors and successors of a block is quite easy with the; routines defined in ``""llvm/IR/CFG.h""``. Just use code like this to; iterate over all predecessors of BB:. .. code-block:: c++. #include ""llvm/IR/CFG.h""; BasicBlock *BB = ...;. for (BasicBlock *Pred : predecessors(BB)) {; // ...; }. Similarly, to iterate over successors use ``successors``. .. _simplechanges:. Making simple changes; ---------------------. There are some primitive transformation operations present in the LLVM; infrastructure that are worth knowing about. When performing transformations,; it's fairly common to manipulate the contents of basic blocks. This section; describes some of the common methods for doing so and gives example code. .. _schanges_creating:. Creating and inserting new ``Instruction``\ s; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. *Instantiating Instructions*. Creation of ``Instruction``\ s is straight-forward: simply call the constructor; for the kind of instruction to instantiate and provide the necessary parameters.; For ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:112876,rout,routines,112876,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['rout'],['routines']
Integrability,"```. Pads are numbered from left to right and from top to bottom. Each new; pad created by `TCanvas::Divide()` has a name, which is the name of; the canvas followed by \_1, \_2, etc. To apply the method `cd()` to; the third pad, you would write:. ``` {.cpp}; root[] MyC_3->cd(); ```. - Third pad will be selected since you called `TPad::cd()` for the; object `MyC_3`. ROOT will find the pad that was named` MyC_3 `when; you typed it on the command line (see ROOT/Cling Extensions to; C++). ### Saving the Canvas. ![The SaveAs... dialog](pictures/0300002B.png). Using the File menu / Save cascade menu users can save the canvas as; one of the files from the list. Please note that saving the canvas; this way will overwrite the file with the same name without a warning. All supported file types can be saved via File menu / SaveAs... This; dialog gives a choice to show or suppress the confirmation message for; overwriting an existing file. If the Overwrite check box is not selected, a message dialog appears; asking the user to overwrite the file (Yes/No). The user choice is; saved for the next time the Save As... dialog shows up. ### Printing the Canvas. The Print command in the canvas File menu pops-up a print dialog where; the user can specify a preferred print command and the printer name. ![](pictures/0300002D.png). Both print parameters can be set via the new Print.Command and; Print.Printer rootrc resources as follows:. ```; # Printer settings.; WinNT.*.Print.Command: AcroRd32.exe; Unix.*.Print.Command: xprint -P%p %f; Print.Printer: 32-rb205-hp; Print.Directory: .; ```. If the `%p` and `%f` are specified as a part of the print command,; they will be replaced by the specified printer name and the file name.; All other parameters will be kept as they are written. A print button; is available in the canvas toolbar (activated via View menu/Toolbar). ## The ROOT Command Line. We have briefly touched on how to use the command line. There are; different types of commands. 1. Cl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:24397,message,message,24397,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['message'],['message']
Integrability,"``clang-check``; ---------------. :doc:`ClangCheck` combines the LibTooling framework for running a; Clang tool with the basic Clang diagnostics by syntax checking specific files; in a fast, command line interface. It can also accept flags to re-display the; diagnostics in different formats with different flags, suitable for use driving; an IDE or editor. Furthermore, it can be used in fixit-mode to directly apply; fixit-hints offered by clang. See :doc:`HowToSetupToolingForLLVM` for; instructions on how to setup and used `clang-check`. ``clang-format``; ----------------. Clang-format is both a :doc:`library <LibFormat>` and a :doc:`stand-alone tool; <ClangFormat>` with the goal of automatically reformatting C++ sources files; according to configurable style guides. To do so, clang-format uses Clang's; ``Lexer`` to transform an input file into a token stream and then changes all; the whitespace around those tokens. The goal is for clang-format to serve both; as a user tool (ideally with powerful IDE integrations) and as part of other; refactoring tools, e.g. to do a reformatting of all the lines changed during a; renaming. Extra Clang Tools; =================. As various categories of Clang Tools are added to the extra repository,; they'll be tracked here. The focus of this documentation is on the scope; and features of the tools for other tool developers; each tool should; provide its own user-focused documentation. ``clang-tidy``; --------------. `clang-tidy <https://clang.llvm.org/extra/clang-tidy/>`_ is a clang-based C++; linter tool. It provides an extensible framework for building compiler-based; static analyses detecting and fixing bug-prone patterns, performance,; portability and maintainability issues. Ideas for new Tools; ===================. * C++ cast conversion tool. Will convert C-style casts (``(type) value``) to; appropriate C++ cast (``static_cast``, ``const_cast`` or; ``reinterpret_cast``).; * Non-member ``begin()`` and ``end()`` conversion tool. W",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:3686,integrat,integrations,3686,interpreter/llvm-project/clang/docs/ClangTools.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst,1,['integrat'],['integrations']
Integrability,"``lit.local.cfg`` is:. .. code-block:: python. config.suffixes = ['.ll', '.c', '.cpp', '.test']; if not 'ARM' in config.root.targets:; config.unsupported = True. Other platform-specific tests are those that depend on a specific feature; of a specific sub-architecture, for example only to Intel chips that support ``AVX2``. For instance, ``test/CodeGen/X86/psubus.ll`` tests three sub-architecture; variants:. .. code-block:: llvm. ; RUN: llc -mcpu=core2 < %s | FileCheck %s -check-prefix=SSE2; ; RUN: llc -mcpu=corei7-avx < %s | FileCheck %s -check-prefix=AVX1; ; RUN: llc -mcpu=core-avx2 < %s | FileCheck %s -check-prefix=AVX2. And the checks are different:. .. code-block:: llvm. ; SSE2: @test1; ; SSE2: psubusw LCPI0_0(%rip), %xmm0; ; AVX1: @test1; ; AVX1: vpsubusw LCPI0_0(%rip), %xmm0, %xmm0; ; AVX2: @test1; ; AVX2: vpsubusw LCPI0_0(%rip), %xmm0, %xmm0. So, if you're testing for a behaviour that you know is platform-specific or; depends on special features of sub-architectures, you must add the specific; triple, test with the specific FileCheck and put it into the specific; directory that will filter out all other architectures. Constraining test execution; ---------------------------. Some tests can be run only in specific configurations, such as; with debug builds or on particular platforms. Use ``REQUIRES``; and ``UNSUPPORTED`` to control when the test is enabled. Some tests are expected to fail. For example, there may be a known bug; that the test detect. Use ``XFAIL`` to mark a test as an expected failure.; An ``XFAIL`` test will be successful if its execution fails, and; will be a failure if its execution succeeds. .. code-block:: llvm. ; This test will be only enabled in the build with asserts.; ; REQUIRES: asserts; ; This test is disabled when running on Linux.; ; UNSUPPORTED: system-linux; ; This test is expected to fail when targeting PowerPC.; ; XFAIL: target=powerpc{{.*}}. ``REQUIRES`` and ``UNSUPPORTED`` and ``XFAIL`` all accept a comma-separated; list of boo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:19288,depend,depends,19288,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['depend'],['depends']
Integrability,"``row`` and ``col`` shall be integral constants greater than 0. **Preconditions**: ``columnStride`` is greater than or equal to ``row``. **Remarks**: The return type is a cv-unqualified matrix type with an element; type of the cv-unqualified version of ``T`` and a number of rows and columns equal; to ``row`` and ``col`` respectively. The parameter ``columnStride`` is optional; and if omitted ``row`` is used as ``columnStride``. **Returns**: A matrix ``Res`` equivalent to:. .. code-block:: c++. M Res;; for (size_t C = 0; C < col; ++C) {; for (size_t R = 0; R < row; ++K); Res[R][C] = ptr[R];; ptr += columnStride; }. ``void __builtin_matrix_column_major_store(M matrix, T *ptr, size_t columnStride)``. **Preconditions**: ``columnStride`` is greater than or equal to the number of rows in ``M``. **Remarks**: The type ``T`` is the const-unqualified version of the matrix; argument’s element type. The parameter ``columnStride`` is optional and if; omitted, the number of rows of ``M`` is used as ``columnStride``. **Effects**: Equivalent to:. .. code-block:: c++. for (size_t C = 0; C < columns in M; ++C) {; for (size_t R = 0; R < rows in M; ++K); ptr[R] = matrix[R][C];; ptr += columnStride; }. TODOs; -----. TODO: Does it make sense to allow M::element_type, M::rows, and M::columns; where M is a matrix type? We don’t support this anywhere else, but it’s; convenient. The alternative is using template deduction to extract this; information. Also add spelling for C. Future Work: Initialization syntax. Decisions for the Implementation in Clang; =========================================. This section details decisions taken for the implementation in Clang and is not; part of the draft specification. The elements of a value of a matrix type are laid out in column-major order; without padding. We propose to provide a Clang option to override this behavior and allow; contraction of those operations (e.g. *-ffp-contract=matrix*). TODO: Specify how matrix values are passed to functions.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:11297,contract,contraction,11297,interpreter/llvm-project/clang/docs/MatrixTypes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst,2,['contract'],"['contract', 'contraction']"
Integrability,"`archive`` will be thin. By default, archives are not created as thin archives; and when modifying a thin archive, it will be converted to a regular archive. .. option:: --version. Display the version of the :program:`llvm-ar` executable. .. option:: -X mode. Specifies the type of object file :program:`llvm-ar` will recognise. The mode must be; one of the following:. 32; Process only 32-bit object files.; 64; Process only 64-bit object files.; 32_64; Process both 32-bit and 64-bit object files.; any; Process all object files. The default is to process 32-bit object files (ignore 64-bit objects). The mode can also; be set with the OBJECT_MODE environment variable. For example, OBJECT_MODE=64 causes ar to; process any 64-bit objects and ignore 32-bit objects. The -X flag overrides the OBJECT_MODE; variable. .. option:: @<FILE>. Read command-line options and commands from response file ``<FILE>``. MRI SCRIPTS; -----------. :program:`llvm-ar` understands a subset of the MRI scripting interface commonly; supported by archivers following in the ar tradition. An MRI script contains a; sequence of commands to be executed by the archiver. The :option:`-M` option; allows for an MRI script to be passed to :program:`llvm-ar` through the; standard input stream. Note that :program:`llvm-ar` has known limitations regarding the use of MRI; scripts:. * Each script can only create one archive.; * Existing archives can not be modified. MRI Script Commands; ~~~~~~~~~~~~~~~~~~~. Each command begins with the command's name and must appear on its own line.; Some commands have arguments, which must be separated from the name by; whitespace. An MRI script should begin with either a :option:`CREATE` or; :option:`CREATETHIN` command and will typically end with a :option:`SAVE`; command. Any text after either '*' or ';' is treated as a comment. .. option:: CREATE archive. Begin creation of a regular archive with the specified name. Subsequent; commands act upon this ``archive``. .. option:: CRE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst:11544,interface,interface,11544,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst,1,['interface'],['interface']
Integrability,"`id objc_retainAutoreleasedReturnValue(id value);``; ----------------------------------------------------. *Precondition:* ``value`` is null or a pointer to a valid object. If ``value`` is null, this call has no effect. Otherwise, it attempts to; accept a hand off of a retain count from a call to; :ref:`objc_autoreleaseReturnValue <arc.runtime.objc_autoreleaseReturnValue>` on; ``value`` in a recently-called function or something it tail-calls. If that; fails, it performs a retain operation exactly like :ref:`objc_retain; <arc.runtime.objc_retain>`. Always returns ``value``. .. _arc.runtime.objc_retainBlock:. ``id objc_retainBlock(id value);``; ----------------------------------. *Precondition:* ``value`` is null or a pointer to a valid block object. If ``value`` is null, this call has no effect. Otherwise, if the block pointed; to by ``value`` is still on the stack, it is copied to the heap and the address; of the copy is returned. Otherwise a retain operation is performed on the; block exactly as if it had been sent the ``retain`` message. .. _arc.runtime.objc_storeStrong:. ``void objc_storeStrong(id *object, id value);``; ------------------------------------------------. *Precondition:* ``object`` is a valid pointer to a ``__strong`` object which is; adequately aligned for a pointer. ``value`` is null or a pointer to a valid; object. Performs the complete sequence for assigning to a ``__strong`` object of; non-block type [*]_. Equivalent to the following code:. .. code-block:: objc. void objc_storeStrong(id *object, id value) {; id oldValue = *object;; value = [value retain];; *object = value;; [oldValue release];; }. .. [*] This does not imply that a ``__strong`` object of block type is an; invalid argument to this function. Rather it implies that an ``objc_retain``; and not an ``objc_retainBlock`` operation will be emitted if the argument is; a block. .. _arc.runtime.objc_storeWeak:. ``id objc_storeWeak(id *object, id value);``; ----------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:115951,message,message,115951,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"`libGX11` is the low level graphics interface to the X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and vector manipulation. - `libMathCore` contains the core mathematics and physics vector; classes. - `libMathMore` contains additional functions, interfacing the GSL; math library. - `libMinuit` is the MINUIT fitter. - `libNet` contains functionality related to network transfer. - `libNew` is the special global new/delete, provides extra memory; checking and interface for shared memory (optional). - `libPhysics` contains the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProof` is the parallel ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the interactive interface to ROOT (provides command; prompt). - `libRIO` provides the functionality to write and read objects to; and from ROOT files. - `libRooFit` is the RooFit fitting framework. - `libRuby` is the interface to Ruby. - `libSpectrum` provides functionality for spectral analysis. - \*`libThread` is the interface to TThread classes. - `libTMVA` contains the multivariate analysis toolkit. - `libTree` is the TTree object container system. - `libTreePlayer` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:15212,interface,interface,15212,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['interface'],['interface']
Integrability,"`llvm.loop.parallel_accesses`` metadata refers to one or more; access group metadata nodes (see ``llvm.access.group``). It denotes that; no loop-carried memory dependence exist between it and other instructions; in the loop with this metadata. Let ``m1`` and ``m2`` be two instructions that both have the; ``llvm.access.group`` metadata to the access group ``g1``, respectively; ``g2`` (which might be identical). If a loop contains both access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ``m2`` carried by; this loop. Instructions that belong to multiple access groups are; considered having this property if at least one of the access groups; matches the ``llvm.loop.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loops that were originally parallel to be considered; sequential (if optimization passes that are unaware of the parallel semantics; insert new memory instructions into the loop body). Example of a loop that is considered parallel due to its correct use of; both ``llvm.access.group`` and ``llvm.loop.parallel_accesses``; metadata types. .. code-block:: llvm. for.body:; ...; %val0 = load i32, ptr %arrayidx, !llvm.access.group !1; ...; store i32 %val0, ptr %arrayidx1, !llvm.access.group !1; ...; br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !0. for.end:; ...; !0 = distinct !{!0, !{!""llvm.loop.parallel_accesses"", !1}}; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:312457,depend,dependences,312457,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependences']
Integrability,"`mylib.h`` in ``/Developer/SDKs/MacOSX10.4u.sdk/usr/include/mylib.h``. Relocatable precompiled headers are intended to be used in a limited; number of cases where the compilation environment is tightly controlled; and the precompiled header cannot be generated after headers have been; installed. .. _controlling-fp-behavior:. Controlling Floating Point Behavior; -----------------------------------. Clang provides a number of ways to control floating point behavior, including; with command line options and source pragmas. This section; describes the various floating point semantic modes and the corresponding options. .. csv-table:: Floating Point Semantic Modes; :header: ""Mode"", ""Values""; :widths: 15, 30, 30. ""ffp-exception-behavior"", ""{ignore, strict, maytrap}"",; ""fenv_access"", ""{off, on}"", ""(none)""; ""frounding-math"", ""{dynamic, tonearest, downward, upward, towardzero}""; ""ffp-contract"", ""{on, off, fast, fast-honor-pragmas}""; ""fdenormal-fp-math"", ""{IEEE, PreserveSign, PositiveZero}""; ""fdenormal-fp-math-fp32"", ""{IEEE, PreserveSign, PositiveZero}""; ""fmath-errno"", ""{on, off}""; ""fhonor-nans"", ""{on, off}""; ""fhonor-infinities"", ""{on, off}""; ""fsigned-zeros"", ""{on, off}""; ""freciprocal-math"", ""{on, off}""; ""allow_approximate_fns"", ""{on, off}""; ""fassociative-math"", ""{on, off}"". This table describes the option settings that correspond to the three; floating point semantic models: precise (the default), strict, and fast. .. csv-table:: Floating Point Models; :header: ""Mode"", ""Precise"", ""Strict"", ""Fast""; :widths: 25, 15, 15, 15. ""except_behavior"", ""ignore"", ""strict"", ""ignore""; ""fenv_access"", ""off"", ""on"", ""off""; ""rounding_mode"", ""tonearest"", ""dynamic"", ""tonearest""; ""contract"", ""on"", ""off"", ""fast""; ""denormal_fp_math"", ""IEEE"", ""IEEE"", ""IEEE""; ""denormal_fp32_math"", ""IEEE"",""IEEE"", ""IEEE""; ""support_math_errno"", ""on"", ""on"", ""off""; ""no_honor_nans"", ""off"", ""off"", ""on""; ""no_honor_infinities"", ""off"", ""off"", ""on""; ""no_signed_zeros"", ""off"", ""off"", ""on""; ""allow_reciprocal"", ""off"", ""off"", ""on""; ""a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:50572,contract,contract,50572,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['contract'],['contract']
Integrability,"`null``; upon entry to the function. Support for this mode in code generation is; largely a legacy detail to keep old collector implementations working. Custom lowering of intrinsics; ------------------------------. For GCs which use barriers or unusual treatment of stack roots, the; implementor is responsibly for providing a custom pass to lower the; intrinsics with the desired semantics. If you have opted in to custom; lowering of a particular intrinsic your pass **must** eliminate all; instances of the corresponding intrinsic in functions which opt in to; your GC. The best example of such a pass is the ShadowStackGC and it's; ShadowStackGCLowering pass. There is currently no way to register such a custom lowering pass; without building a custom copy of LLVM. .. _safe-points:. Generating safe points; -----------------------. LLVM provides support for associating stackmaps with the return address of; a call. Any loop or return safepoints required by a given collector design; can be modeled via calls to runtime routines, or potentially patchable call; sequences. Using gcroot, all call instructions are inferred to be possible; safepoints and will thus have an associated stackmap. .. _assembly:. Emitting assembly code: ``GCMetadataPrinter``; ---------------------------------------------. LLVM allows a plugin to print arbitrary assembly code before and after the rest; of a module's assembly code. At the end of the module, the GC can compile the; LLVM stack map into assembly code. (At the beginning, this information is not; yet computed.). Since AsmWriter and CodeGen are separate components of LLVM, a separate abstract; base class and registry is provided for printing assembly code, the; ``GCMetadaPrinter`` and ``GCMetadataPrinterRegistry``. The AsmWriter will look; for such a subclass if the ``GCStrategy`` sets ``UsesMetadata``:. .. code-block:: c++. MyGC::MyGC() {; UsesMetadata = true;; }. This separation allows JIT-only clients to be smaller. Note that LLVM does not ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:34915,rout,routines,34915,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['rout'],['routines']
Integrability,"`std::format()`` or; ``llvm::formatv()`` functions. .. code-block:: text. OS << ""#ifndef "" << NodeName << ""\n"";. OS << format(""0x%0*x, "", Digits, Value);. Instances of the following classes can be printed using the ``<<`` operator:; ``RecordKeeper``,; ``Record``,; ``RecTy``,; ``RecordVal``, and; ``Init``. The helper function ``emitSourceFileHeader()`` prints the header comment; that should be included at the top of every output file. A call to it is; included in the skeleton backend file ``TableGenBackendSkeleton.cpp``. Printing Error Messages; =======================. TableGen records are often derived from multiple classes and also often; defined through a sequence of multiclasses. Because of this, it can be; difficult for backends to report clear error messages with accurate source; file locations. To make error reporting easier, five error reporting; functions are provided, each with four overloads. * ``PrintWarning`` prints a message tagged as a warning. * ``PrintError`` prints a message tagged as an error. * ``PrintFatalError`` prints a message tagged as an error and then terminates. * ``PrintNote`` prints a note. It is often used after one of the previous; functions to provide more information. * ``PrintFatalNote`` prints a note and then terminates. Each of these five functions is overloaded four times. * ``PrintError(const Twine &Msg)``:; Prints the message with no source file location. * ``PrintError(ArrayRef<SMLoc> ErrorLoc, const Twine &Msg)``:; Prints the message followed by the specified source line,; along with a pointer to the item in error. The array of; source file locations is typically taken from a ``Record`` instance. * ``PrintError(const Record *Rec, const Twine &Msg)``:; Prints the message followed by the source line associated with the; specified record (see `Record`_). * ``PrintError(const RecordVal *RecVal, const Twine &Msg)``:; Prints the message followed by the source line associated with the; specified record field (see `RecordVal`_). Usi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:23984,message,message,23984,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,1,['message'],['message']
Integrability,"`void*`` as equal. This is just an example; more possible details are described a bit below. As another example, the reader may imagine two more functions. The first; function performs a multiplication by 2, while the second one performs an; logical left shift by 1. Possible solutions; ^^^^^^^^^^^^^^^^^^; Let's briefly consider possible options about how and what we have to implement; in order to create full-featured functions merging, and also what it would; mean for us. Equal function detection obviously supposes that a ""detector"" method to be; implemented and latter should answer the question ""whether functions are equal"".; This ""detector"" method consists of tiny ""sub-detectors"", which each answers; exactly the same question, but for function parts. As the second step, we should merge equal functions. So it should be a ""merger""; method. ""Merger"" accepts two functions *F1* and *F2*, and produces *F1F2*; function, the result of merging. Having such routines in our hands, we can process a whole module, and merge all; equal functions. In this case, we have to compare every function with every another function. As; the reader may notice, this way seems to be quite expensive. Of course we could; introduce hashing and other helpers, but it is still just an optimization, and; thus the level of O(N*N) complexity. Can we reach another level? Could we introduce logarithmical search, or random; access lookup? The answer is: ""yes"". Random-access; """"""""""""""""""""""""""; How it could this be done? Just convert each function to a number, and gather; all of them in a special hash-table. Functions with equal hashes are equal.; Good hashing means, that every function part must be taken into account. That; means we have to convert every function part into some number, and then add it; into the hash. The lookup-up time would be small, but such an approach adds some; delay due to the hashing routine. Logarithmical search; """"""""""""""""""""""""""""""""""""""""; We could introduce total ordering among the funct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:5153,rout,routines,5153,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['rout'],['routines']
Integrability,"a - `1, 2, 3 mean X, Y, Z; for `tube`, `tubs`, `cone`,; `cons - `1 means `Rxy`, 2 means `phi` and 3 means Z; for `pcon` and; `pgon` - 2 means `phi` and 3 means Z; for spheres 1 means `R `and 2; means `phi.`. In fact, the division operation has the same effect as positioning; volumes in a given order inside the divided container - the advantage; being that the navigation in such a structure is much faster. When a; volume is divided, a volume family corresponding to the slices is; created. In case all slices can be represented by a single shape, only; one volume is added to the family and positioned N times inside the; divided volume, otherwise, each slice will be represented by a distinct; volume in the family. Divisions can be also performed in a given range of one axis. For that,; one has to specify also the starting coordinate value and the step:. ~~~{.cpp}; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N,start,step);; ~~~. A check is always done on the resulting division range: if not fitting; into the container limits, an error message is posted. If we will browse; the divided volume we will notice that it will contain N nodes starting; with index 1 up to N. The first one has the lower X limit at `START`; position, while the last one will have the upper X limit at; `START+N*STEP`. The resulting slices cannot be positioned inside another; volume (they are by default positioned inside the divided one) but can; be further divided and may contain other volumes:. ~~~{.cpp}; TGeoVolume *slicey = slicex->Divide(""SLICEY"",2,N1);; slicey->AddNode(other_vol,index,some_matrix);; ~~~. When doing that, we have to remember that `SLICEY` represents a family,; therefore all members of the family will be divided on Y and the other; volume will be added as node inside all. In the example above all the resulting slices had the same shape as the; divided volume (box). This is not always the case. For instance,; dividing a volume with `TUBE` shape on `PHI `axis will create equal; slices",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:45858,message,message,45858,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['message'],['message']
Integrability,"a analysis; of experimental data recorded at CERN, but it is also used by people; doing data analysis outside CERN or outside high energy physics (HEP).; In 2002 Fred James started a project aiming to re-implement M in an; object-oriented way using . More information about recent developments, releases and installation; can be obtained from the M homepage @bib-C++MINUIT. The names of M applications are written in capital letters (e.g.; $\mbox{MIGRAD}$, $\mbox{MINOS}$, $\mbox{CONTOURS}$), the; corresponding names of the classes are written using sans-serif font; type (MnMigrad, MnMinos, MnContours). # Introduction: M basic concepts #. [sec:intro]. ## The organization of M ##. The M package acts on a multiparameter *objective function* which is; called — for historical reasons — the $\mbox{FCN}$ function (see; [howto:fcn]). This function is usually a chisquared or a log–likelihood,; but it could also be a mathematical function. The $\mbox{FCN}$; function needs to be written in for which M defines the pure abstract; base class FCNBase as interface. The user must define and implement the; $\mbox{FCN}$ function in a derived class from FCNBase. Sometimes; this is done by an intermediate program such as HippoDraw@bib-HippoDraw,; in which case M is being used under the control of such an intermediate; program[^1]. The value of the $\mbox{FCN}$ function will in general; depend on one or more variable parameters whose meaning is defined by; the user (or by the intermediate program), but whose trial values are; determined by M . To take a simple example, suppose the problem is to fit a polynomial; through a set of data points. Then the user would write a; $\mbox{FCN}$ which calculates the $\chi^2$ between a polynomial and; the data; the variable parameters of $\mbox{FCN}$ would be the; coefficients of the polynomials. Using objects for minimization from M ,; the user would request M to minimize the $\mbox{FCN}$ with respect; to the parameters, that is, find those values of the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:2079,interface,interface,2079,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interface']
Integrability,"a call to a; function that doesn't exist). And it means that we can't properly perform type; checks on some containing constructs, such as ``return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the same way it; would inside a template. In cases where we are confident about the concrete type (e.g. the return type; for a broken non-overloaded function call), the ``RecoveryExpr`` will have this; type. This allows more code to be typechecked, and produces a better AST and; more diagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new “ContainsErrors” bit to; express “Does this expression or anything within it contain errors” semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:88806,depend,dependent,88806,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['depend'],['dependent']
Integrability,"a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager *",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18045,depend,depends,18045,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['depend'],['depends']
Integrability,"a sets. These classes are provided in the namespace `ROOT::Fit`.; They are describing separately in the Fitting chapter. The sets described above is independent of ROOT libraries and can be built as a set of standalone classes.; In addition `MathCore` provides the following classes (depending on ROOT *libCore* library):. - `TMath`: namespace with mathematical functions and basic function algorithms.; - `TComplex`: class for complex numbers.; - Random classes: the base class `TRandom` and the derived classes `TRandom1`, `TRandom2` and `TRandom3`, implementing the pseudo-random number generators. A detailed description for all `MathCore` classes is available in the Doxygen; [online reference documentation](online reference documentation). ## MathMore Library. The `MathMore` library provides an advanced collection of functions and; C++ classes for numerical computing. This is an extension of the; functionality provided by the `MathCore` library.; The `MathMore` library is implemented wrapping in C++ the GNU Scientific Library (GSL).; The current set, provided in; the `ROOT::Math` namespace; include:. - Special mathematical functions (like Bessel functions, Legendre polynomials, etc.. ). - Additional mathematical functions used in statistics such as probability density; functions, cumulative distributions functions and their inverse which are not in `MathCore` but present in; the `GSL` library. - Numerical algorithms for one dimensional functions based on; implementation of the GNU Scientific Library (GSL):. - Numerical integration classes implementing the interface **`ROOT::Math::Integrator`**; which is based on the Adaptive integration algorithms of QUADPACK. - Numerical differentiation via **`ROOT::Math::GSLDerivator`**. - Root finder implementing the **`ROOT::Math::RootFinder`** interface, using different; solver algorithms from GSL. - one-dimensional Minimization implementing the interface**`ROOT::Math::IMinimizer1D`**. - Interpolation via **`ROOT::Math::Interpolati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:3288,wrap,wrapping,3288,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['wrap'],['wrapping']
Integrability,"a single JITDylib. However, clients who want to JIT code; for languages/projects that traditionally rely on ahead-of-time linking (e.g.; C++) will find that this feature makes life much easier. Symbol lookup in ORC serves two other important functions, beyond providing; addresses for symbols: (1) It triggers compilation of the symbol(s) searched for; (if they have not been compiled already), and (2) it provides the; synchronization mechanism for concurrent compilation. The pseudo-code for the; lookup process is:. .. code-block:: none. construct a query object from a query set and query handler; lock the session; lodge query against requested symbols, collect required materializers (if any); unlock the session; dispatch materializers (if any). In this context a materializer is something that provides a working definition; of a symbol upon request. Usually materializers are just wrappers for compilers,; but they may also wrap a jit-linker directly (if the program representation; backing the definitions is an object file), or may even be a class that writes; bits directly into memory (for example, if the definitions are; stubs). Materialization is the blanket term for any actions (compiling, linking,; splatting bits, registering with runtimes, etc.) that are required to generate a; symbol definition that is safe to call or access. As each materializer completes its work it notifies the JITDylib, which in turn; notifies any query objects that are waiting on the newly materialized; definitions. Each query object maintains a count of the number of symbols that; it is still waiting on, and once this count reaches zero the query object calls; the query handler with a *SymbolMap* (a map of symbol names to addresses); describing the result. If any symbol fails to materialize the query immediately; calls the query handler with an error. The collected materialization units are sent to the ExecutionSession to be; dispatched, and the dispatch behavior can be set by the client. By ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:9923,wrap,wrappers,9923,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,2,['wrap'],"['wrap', 'wrappers']"
Integrability,"a tabbed box; click on the names ontop to select a tab. Inheritance; This chart shows the inheritance hierarchy for the current class. Arrows point to; base classes. You can click the classes to get to their reference page. Inherited Members; The second chart shows a list of all members of all base classes. You can see at what; level they are defined or at what level they are defined. Members that are accessible; (public) have a green background, protected ones have a yellow background, and private; members have a red background. Members with a dark gray background are re-implemented; or hidden by a derived class. Includes; The Includes chart shows which files are indirectly included by including the class's; header. Most headers will #include some files, so by #including that header you also; #include the #included files, and so on. A illegible chart often means you should; read a bit on the C++ trick known as ""forward declaration"". Including too many headers; has some nasty consequences, like compile time, additional dependencies, etc. Libraries; Each class is assumed to be in a library. That library might depend on other libraries.; The fourth chart shows the dependencies of these libraries. You will need to link against; all of these if you write your own program. Member Function Documentation; Each function should be documented by the developer of the class. The documentation can; contain HTML, pictures, and example code. It should explain what the function does,; what it expects as parameters, what it returns, and what can make it fail. Short functions; can have their source displayed. You can click on the function name to jump to a; colored version of the function's source.  . Author: Axel Naumann; Last update: 2007-01-12; Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. This page has been hand crafted. If you have any comments or suggestions about the page layout send a mail to ROOT support, or contact the developers with any questions or problems reg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html:7926,depend,dependencies,7926,etc/html/HELP.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html,1,['depend'],['dependencies']
Integrability,"a; ---------------. Any data defined by system libraries (i.e. not defined by ``lib/Support``) must; not be exposed through the ``lib/Support`` interface, even if the header file; for that function is not exposed. As with functions, this prevents inadvertent; use of data that might not exist on all platforms. Minimize Soft Errors; --------------------. Operating system interfaces will generally provide error results for every; little thing that could go wrong. In almost all cases, you can divide these; error results into two groups: normal/good/soft and abnormal/bad/hard. That is,; some of the errors are simply information like ""file not found"", ""insufficient; privileges"", etc. while other errors are much harder like ""out of space"", ""bad; disk sector"", or ""system call interrupted"". We'll call the first group ""*soft*""; errors and the second group ""*hard*"" errors. ``lib/Support`` must always attempt to minimize soft errors. This is a design; requirement because the minimization of soft errors can affect the granularity; and the nature of the interface. In general, if you find that you're wanting to; throw soft errors, you must review the granularity of the interface because it; is likely you're trying to implement something that is too low level. The rule; of thumb is to provide interface functions that **can't** fail, except when; faced with hard errors. For a trivial example, suppose we wanted to add an ""``OpenFileForWriting``""; function. For many operating systems, if the file doesn't exist, attempting to; open the file will produce an error. However, ``lib/Support`` should not simply; throw that error if it occurs because its a soft error. The problem is that the; interface function, ``OpenFileForWriting`` is too low level. It should be; ``OpenOrCreateFileForWriting``. In the case of the soft ""doesn't exist"" error,; this function would just create it and then open it for writing. This design principle needs to be maintained in ``lib/Support`` because it; avoids the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:7954,interface,interface,7954,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interface']
Integrability,"a``; or ``afree`` to make it clear that this stack adjusting cleanup is less; powerful than a full stack save and restore. Nested Calls and Copy Elision; -----------------------------. We also want to be able to support copy elision into these argument; slots. This means we have to support multiple live argument; allocations. Consider the evaluation of:. .. code-block:: c++. // Foo is non-trivial.; struct Foo { int a; Foo(); Foo(const &Foo); ~Foo(); };; Foo bar(Foo b);; int main() {; bar(bar(Foo()));; }. In this case, we want to be able to elide copies into ``bar``'s argument; slots. That means we need to have more than one set of argument frames; active at the same time. First, we need to allocate the frame for the; outer call so we can pass it in as the hidden struct return pointer to; the middle call. Then we do the same for the middle call, allocating a; frame and passing its address to ``Foo``'s default constructor. By; wrapping the evaluation of the inner ``bar`` with stack save and; restore, we can have multiple overlapping active call frames. Callee-cleanup Calling Conventions; ----------------------------------. Another wrinkle is the existence of callee-cleanup conventions. On; Windows, all methods and many other functions adjust the stack to clear; the memory used to pass their arguments. In some sense, this means that; the allocas are automatically cleared by the call. However, LLVM; instead models this as a write of undef to all of the inalloca values; passed to the call instead of a stack adjustment. Frontends should; still restore the stack pointer to avoid a stack leak. Exceptions; ----------. There is also the possibility of an exception. If argument evaluation; or copy construction throws an exception, the landing pad must do; cleanup, which includes adjusting the stack pointer to avoid a stack; leak. This means the cleanup of the stack memory cannot be tied to the; call itself. There needs to be a separate IR-level instruction that can; perform in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InAlloca.rst:4725,wrap,wrapping,4725,interpreter/llvm-project/llvm/docs/InAlloca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InAlloca.rst,1,['wrap'],['wrapping']
Integrability,"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. .. _BitFieldColonSpacing:. **BitFieldColonSpacing** (``BitFieldColonSpacingStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BitFieldColonSpacing>`; The BitFieldColonSpacingStyle to use for bitfields. Possible values:. * ``BFCS_Both`` (in configuration: ``Both``); Add one space on each side of the ``:``. .. code-block:: c++. unsigned bf : 2;. * ``BFCS_None`` (in configuration: ``None``); Add no space around the ``:`` (except when needed for; ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf:2;. * ``BFCS_Before`` (in configuration: ``Before``); Add space before the ``:`` only. .. code-block:: c++. unsigned bf :2;. * ``BFCS_After`` (in configuration: ``After``); Add space after the ``:`` only (space may be added before if; needed for ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf: 2;. .. _BraceWrapping:. **BraceWrapping** (``BraceWrappingFlags``) :versionbadge:`clang-format 3.8` :ref:`¶ <BraceWrapping>`; Control of individual brace wrapping cases. If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how; each individual brace case should be handled. Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; BreakBeforeBraces: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: false; SplitEmptyFunction: false. Nested configuration flags:. Precise control over the wrapping of braces. .. code-block:: c++. # Should be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true:; switch (foo) { vs. switch (foo) {; case 1: { case 1:; bar(); {; break; bar();; } break;; default: { }; plop(); default:; } {; } plop();; }; }. * ``bool AfterClass`` Wrap class definitions. .. code-block:: c++. true:; class foo; {};. false:; class foo {};. * ``BraceWrappingAfterControlStatementStyle AfterControlStatement``; Wrap control statements (``if``/``for``/``while``/``switch``/..). Possib",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:38435,wrap,wrapping,38435,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrapping']
Integrability,"aavedra, CERN/IT,\; Matevz Tadel, UCSD/CMS,\; [QuillPusher](https://github.com/QuillPusher), [Compiler Research Group](https://compiler-research.org/team/),\; Vassil Vassilev, Princeton/CMS,\; Wouter Verkerke, NIKHEF/ATLAS,\; Daniel Werner, CERN/EP-SFT,\; Zef Wolffs, NIKHEF/ATLAS. ## Deprecation and Removal; - The minimum C++ standard supported by ROOT is now C++17.; - Support for Python 2 is now deprecated and it will be removed in next release 6.32.; - `ROOT::RDF::RResultHandle::GetResultPtr` has been deprecated. Please use `RResultPtr` directly instead and only cast to `RResultHandle` in order to call `ROOT::RDF::RunGraphs`.; - The RDataFrame factory functions `MakeCsvDataFrame`, `MakeArrowDataFrame`, `MakeNTupleDataFrame` and `MakeSqliteDataFrame` that were deprecated in v6.28 have been removed. Use `FromCSV`, `FromArrow`, `FromRNTuple` or `FromSqlite` instead.; - The TStorage reallocation routine without a size (`TStorage::ReAlloc(void *ovp, size_t size`) and heap related routines (`TStorage::AddToHeap`, `TStorage::IsOnHeap`, `TStorage::GetHeapBegin`, `TStorage::GetHeapEnd`) that were deprecated in v6.02/00 have been removed.; - The deprecated `Format(const char* option, int sigDigits)` option for `RooAbsPdf::paramOn()` was removed. Please use the `Format(const char* option, ...)` overload that takes command arguments.; - The deprecated `RooAbsPdf::paramOn()` overload that directly takes a formatting string was removed. Please take the overload that uses command arguments.; - The `RooCatType` class was deprecated in ROOT 6.22 and its original `RooCatType.h` header is now removed. If you still need access to this class, please include `RooFitLegacy/RooCatTypeLegacy.h`.; - The `RooAbsString` that was only an alias for `RooStringVar` got removed.; - The `RooDataWeightedAverage` is now deprecated and will be removed in 6.32. It was only supposed to be an implementation detail of RooFits plotting that is now not necessary anymore.; - The `RooSpan` class was removed a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:2679,rout,routine,2679,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,2,['rout'],"['routine', 'routines']"
Integrability,"able plotting of component p.d.f.s using same scheme as RooAddPdf, i.e. just use the Components() specified in plotOn().; RooExpensiveObjectCache - New cache manager for sharing and storing of expensive components cached by operator p.d.f.s ; RooMCStudy - Add Silence() argument to constructor to request minimal verbosity during running; RooMinuit - Improve contour() method to return RooPlots rather than drawing TGraphs straight on a canvas; RooWorkspace - Add private expensive object cache to workspace; RooBinningCategory - New real-to-category function that maps values of input RooRealVar to categories with labels that correspond to bins of input RooRealVar. See rf405_realtocatfuncs.C for details . RooStats; This is a new package introduced in this version for statistical tools built on top of RooFit. It is a joint effort between the LHC experiments and the ROOT team (see the RooStats Wiki page).; ; This version contains the interfaces for performing the statistical calculations and dealing with the obtained results and concrete classes implementing the statistical methods.; ; All the classes and functions in RooStats are provided in the namespace RooStats.; ; RooStats interfaces. ConfInterval: interface for describing a confidence interval. ; IntervalCalculator: interface for a statistical tool producing confidence intervals (class ConfInterval).; HypoTestResult: interface for representing results of a hypothesis test; HypoTestCalculator: interface for a statistical tool performing an hypothesis test. ; CombinedCalculator: interface for a statistical tool which can produce both hypothesis test results and confidence intervals. ; RooStats concrete classes. The concrete classes describing statistical tools implementing the above interfaces are:; ; ProfileLikelihoodCalculator: it is an implementation of a CombinedCalculator using the profile likelihood ratio as a test statistics. After configuring the calculator, one only needs to ask GetHypoTest() (which will return ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:9566,interface,interfaces,9566,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['interface'],['interfaces']
Integrability,"able; to retrieve the geometry in a ready state, ignoring what the state; variables that can be always re-initialized. When the code is generated; for a given TGeoVolume in the geometry, just the branch starting; with that volume will be saved in the file. Executing the generated code; will create a geometry that has `MyVolume` as top volume. In this case,; only the materials/media/matrices used effectively in the `MyVolume`; branch are exported to file. Volumes can be made persistent in the same way the full geometry is.; Exporting is straightforward (module1, 2 are pointers to; TGeoVolume objects):. ~~~{.cpp}; module1->Export(""file.root"");; // by default file is overwritten; module2->Export(""file.root"","""",""update"");; // to the same file; ~~~. Importing will append the volume to the current TGeoManager or will; create one:. ~~~{.cpp}; TGeoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; ~~~. \anchor GP06a; ### GDML. Few lines above word GDML was used. GDML stands for Geometry; Description Markup Language. It is an application-independent; geometry description format based on XML. It is mainly used for geometry; interchange between %ROOT and Geant4 framework. More details about this; project can be found http://gdml.web.cern.ch. This feature; (importing/exporting from/to gdml file format) is disabled by default in; %ROOT installation. To enable this feature add `--enable-gdml` option to; `./configure` script call. \anchor GP07; ## Navigation Algorithms. This section will describe the main methods and algorithms used for; implementing the navigation",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:114179,depend,depending,114179,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['depend'],['depending']
Integrability,acOSX/CFBundle.h; lldb/tools/debugserver/source/MacOSX/CFString.cpp; lldb/tools/debugserver/source/MacOSX/CFString.h; lldb/tools/debugserver/source/MacOSX/CFUtils.h; lldb/tools/debugserver/source/MacOSX/Genealogy.cpp; lldb/tools/debugserver/source/MacOSX/Genealogy.h; lldb/tools/debugserver/source/MacOSX/GenealogySPI.h; lldb/tools/debugserver/source/MacOSX/MachException.h; lldb/tools/debugserver/source/MacOSX/MachThread.cpp; lldb/tools/debugserver/source/MacOSX/MachThread.h; lldb/tools/debugserver/source/MacOSX/MachThreadList.h; lldb/tools/debugserver/source/MacOSX/MachVMMemory.h; lldb/tools/debugserver/source/MacOSX/MachVMRegion.cpp; lldb/tools/debugserver/source/MacOSX/MachVMRegion.h; lldb/tools/debugserver/source/MacOSX/OsLogger.h; lldb/tools/debugserver/source/MacOSX/arm/DNBArchImpl.h; lldb/tools/debugserver/source/MacOSX/arm64/DNBArchImplARM64.h; lldb/tools/driver/Driver.cpp; lldb/tools/driver/Driver.h; lldb/tools/driver/Platform.cpp; lldb/tools/driver/Platform.h; lldb/tools/intel-features/cli-wrapper.cpp; lldb/tools/intel-features/intel-mpx/cli-wrapper-mpxtable.h; lldb/tools/lldb-instr/Instrument.cpp; lldb/tools/lldb-server/Acceptor.h; lldb/tools/lldb-server/LLDBServerUtilities.cpp; lldb/tools/lldb-server/SystemInitializerLLGS.cpp; lldb/tools/lldb-server/SystemInitializerLLGS.h; lldb/tools/lldb-test/SystemInitializerTest.cpp; lldb/tools/lldb-test/SystemInitializerTest.h; lldb/tools/lldb-vscode/BreakpointBase.cpp; lldb/tools/lldb-vscode/BreakpointBase.h; lldb/tools/lldb-vscode/ExceptionBreakpoint.cpp; lldb/tools/lldb-vscode/ExceptionBreakpoint.h; lldb/tools/lldb-vscode/FifoFiles.cpp; lldb/tools/lldb-vscode/FifoFiles.h; lldb/tools/lldb-vscode/FunctionBreakpoint.cpp; lldb/tools/lldb-vscode/FunctionBreakpoint.h; lldb/tools/lldb-vscode/IOStream.cpp; lldb/tools/lldb-vscode/IOStream.h; lldb/tools/lldb-vscode/JSONUtils.cpp; lldb/tools/lldb-vscode/JSONUtils.h; lldb/tools/lldb-vscode/lldb-vscode.cpp; lldb/tools/lldb-vscode/LLDBUtils.cpp; lldb/tools/lldb-vscode/LLDBUtils.h,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:226662,wrap,wrapper,226662,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['wrap'],['wrapper']
Integrability,"accepts executable lines.; Example::. >>> cppyy.cppexec(r""""""std::string hello = ""Hello, World!"";""""""); True; >>> cppyy.cppexec(""std::cout << hello << std::endl;""); Hello, World!; True; >>> . * ``include``: load declarations into the interpreter.; This function accepts C++ declarations from a file, typically a header.; Files are located through include paths given to the Cling.; Example::. >>> cppyy.include(""vector"") # equivalent to ""#include <vector>""; True; >>> . * ``c_include``: load declarations into the interpreter.; This function accepts C++ declarations from a file, typically a header.; Name mangling is an important difference between C and C++ code.; The use of ``c_include`` instead of ``include`` prevents mangling. * ``load_library``: load compiled C++ into the interpreter.; This function takes the name of a shared library and loads it into current; process, exposing all external symbols to Cling.; Libraries are located through load paths given to Cling, either through the; ""-L"" compiler flag or the dynamic search path environment variable (system; dependent).; Any method that brings symbols into the process (including normal linking,; e.g. when embedding Python in a C++ application) is suitable to expose; symbols.; An alternative for ``load_library`` is for example ``ctypes.CDLL``, but; that function does not respect dynamic load paths on all platforms. If a compilation error occurs during JITing of C++ code in any of the above; helpers, a Python ``SyntaxError`` exception is raised.; If a compilation warning occurs, a Python warning is issued. `Configuring Cling`; -------------------. It is often convenient to add additional search paths for Cling to find; headers and libraries when loading a module (Python does not have standard; locations to place headers and libraries, but their locations can usually; be inferred from the location of the module, i.e. it's ``__file__``; attribute).; cppyy provides the following two helpers:. * ``add_include_path``: add add",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/toplevel.rst:2908,depend,dependent,2908,bindings/pyroot/cppyy/cppyy/doc/source/toplevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/toplevel.rst,1,['depend'],['dependent']
Integrability,"access the cycle counter register (or; a similar low-latency, high-accuracy clock) on those targets that support it. **Syntax**:. .. code-block:: c++. __builtin_readcyclecounter(). **Example of Use**:. .. code-block:: c++. unsigned long long t0 = __builtin_readcyclecounter();; do_something();; unsigned long long t1 = __builtin_readcyclecounter();; unsigned long long cycles_to_do_something = t1 - t0; // assuming no overflow. **Description**:. The ``__builtin_readcyclecounter()`` builtin returns the cycle counter value,; which may be either global or process/thread-specific depending on the target.; As the backing counters often overflow quickly (on the order of seconds) this; should only be used for timing small intervals. When not supported by the; target, the return value is always zero. This builtin takes no arguments and; produces an unsigned long long result. Query for this feature with ``__has_builtin(__builtin_readcyclecounter)``. Note; that even if present, its use may depend on run-time privilege or other OS; controlled state. ``__builtin_dump_struct``; -------------------------. **Syntax**:. .. code-block:: c++. __builtin_dump_struct(&some_struct, some_printf_func, args...);. **Examples**:. .. code-block:: c++. struct S {; int x, y;; float f;; struct T {; int i;; } t;; };. void func(struct S *s) {; __builtin_dump_struct(s, printf);; }. Example output:. .. code-block:: none. struct S {; int x = 100; int y = 42; float f = 3.141593; struct T t = {; int i = 1997; }; }. .. code-block:: c++. #include <string>; struct T { int a, b; };; constexpr void constexpr_sprintf(std::string &out, const char *format,; auto ...args) {; // ...; }; constexpr std::string dump_struct(auto &x) {; std::string s;; __builtin_dump_struct(&x, constexpr_sprintf, s);; return s;; }; static_assert(dump_struct(T{1, 2}) == R""(struct T {; int a = 1; int b = 2; }; )"");. **Description**:. The ``__builtin_dump_struct`` function is used to print the fields of a simple; structure and their values f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:103880,depend,depend,103880,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['depend'],['depend']
Integrability,"accessed as MTYPE CC (cache coherent) and; so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC (non-coherent). Since the private address space is only accessed; by a single thread, and is always write-before-read, there is never a need to; invalidate these entries from the L0 or L1 caches. Wavefronts are executed in native mode with in-order reporting of loads and; sample instructions. In this mode vmcnt reports completion of load, atomic with; return and sample instructions in order, and the vscnt reports the completion of; store and atomic without return in order. See ``MEM_ORDERED`` field in; :ref:`amdgpu-amdhsa-compute_pgm_rsrc1-gfx6-gfx12-table`. Wavefronts can be executed in WGP or CU wavefront execution mode:. * In WGP wavefront execution mode the wavefronts of a work-group are executed; on the SIMDs of both CUs of the WGP. Therefore, explicit management of the per; CU L0 caches is required for work-group synchronization. Also accesses to L1; at work-group scope need to be explicitly ordered as the accesses from; different CUs are not ordered.; * In CU wavefront execution mode the wavefronts of a work-group are executed on; the SIMDs of a single CU of the WGP. Therefore, all global memory access by; the work-group access the same L0 which in turn ensures L1 accesses are; ordered and so do not require explicit management of the caches for; work-group synchronization. See ``WGP_MODE`` field in; :ref:`amdgpu-amdhsa-compute_pgm_rsrc1-gfx6-gfx12-table` and; :ref:`amdgpu-target-features`. The code sequences used to implement the memory model for GFX10-GFX11 are defined in; table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx10-gfx11-table`. .. table:: AMDHSA Memory Model Code Sequences GFX10-GFX11; :name: amdgpu-amdhsa-memory-model-code-sequences-gfx10-gfx11-table. ============ ============ ============== ========== ================================; LLVM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:342453,synchroniz,synchronization,342453,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronization']
Integrability,"ace MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. .. _osx-cocoa-Loops:. osx.cocoa.Loops; """"""""""""""""""""""""""""""; Improved modeling of loops using Cocoa collection types. .. _osx-cocoa-MissingSuperCall:. osx.cocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a necessary call to super. .. code-block:: objc. @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. .. _osx-cocoa-NSAutoreleasePool:. osx.cocoa.NSAutoreleasePool (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn for suboptimal uses of NSAutoreleasePool in Objective-C GC mode. .. code-block:: objc. void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. .. _osx-cocoa-NSError:. osx.cocoa.NSError (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Check usage of NSError parameters. .. code-block:: objc. @interface A : NSObject; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; // warn: method accepting NSError"""""""""""""""""""""""""""""""""""""""""""""""" should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. .. _osx-cocoa-NilArg:. osx.cocoa.NilArg (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for prohibited nil arguments to ObjC method calls. - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. .. code-block:: objc. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. .. _osx-cocoa-NonNil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:38343,interface,interface,38343,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['interface'],['interface']
Integrability,"ace and time by specifying:. ``` {.cpp}; MyClass::Class()->IgnoreTObjectStreamer();; ```. This sets a bit in the **`TClass`** object. If the file is compressed,; the savings are minimal since most values are zero; however, it saves; some space when the file is not compressed. A call; to` IgnoreTObjectStreamer` also prevents the creation of two additional; branches when splitting the object. If left alone, two branches called; `fBits` and `fUniqueID` will appear. ## Motivation. If you want to integrate and use your classes with ROOT, to enjoy; features like, extensive RTTI (Run Time Type Information) and ROOT; object I/O and inspection, you have to add the following line to your; class header files:. ``` {.cpp}; ClassDef(ClassName,ClassVersionID); //The class title; ```. For example in `TLine.h` we have:. ``` {.cpp}; ClassDef(TLine,1); //A line segment; ```. The **`ClassVersionID`** is used by the ROOT I/O system. It is written; on the output stream and during reading you can check this version ID; and take appropriate action depending on the value of the ID. See; ""Streamers"". Every time you change the data members of a class, you; should increase its `ClassVersionID` by one. The `ClassVersionID` should; be `>=1`. Set `ClassVersionID=0` in case you don't need object I/O. To; be able to generate properly documentation for your classes using; **`THtml`** you must add the statement:. ``` {.cpp}; ClassImp(ClassName); ```. For example in `TLine.cxx`:. ``` {.cpp}; ClassImp(TLine); ```. Note that you should provide a default constructor for your classes,; i.e. a constructor with zero parameters or with one or more parameters; all with default values in case you want to use object I/O. If do not; provide such a default constructor, you MUST implement an I/O; constructor. If not you will get a compile time error. See the ""The; Default Constructor"" paragraph in this chapter. The `ClassDef` and; `ClassImp` macros are defined in the file `Rtypes.h`. This file is; referenced by a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:8308,depend,depending,8308,documentation/users-guide/AddingaClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md,1,['depend'],['depending']
Integrability,"ace the standard `ClassImp` macro by `ClassImpQ`. Signals are currently implemented for all ROOT GUI classes and the [TTimer](https://root.cern/doc/master/classTTimer.html) and [TCanvas](https://root.cern/doc/master/classTCanvas.html) classes (to find quickly all defined signals do for example: `grep '*SIGNAL*' $ROOTSYS/include/*.h`). ## Examples. ### A First Time Example ([rqfirst.C](http://root.cern.ch/root/rqex/rqfirst.C)). This example shows:. * How to create interpreted class with signals with different types/number of arguments.; * How to connect signals to slots.; * How to activate signals. ### Histogram Filling with Dynamic State Reported via Signals ([rqsimple.C](http://root.cern.ch/root/rqex/rqsimple.C)). Based on hsimple this example demonstrates:. * All features of the hsimple example.; * How to create an interpreted class with signals which will report about dynamic state of the histogram processing.; * How to use the [TTimer](https://root.cern/doc/master/classTTimer.html) class for emulation of ""multithreading"".; * How to use signals for the concurrent update of pad, file, benchmark facility, etc. ### An Example on How to Use Canvas Event Signals ([rqfiller.C](http://root.cern.ch/root/rqex/rqfiller.C)). This example shows:. * How the object communication mechanism can be used for handling the [TCanvas](https://root.cern/doc/master/classTCanvas.html)'s mouse/key events in an interpreted class. With this demo you can fill histograms by hand:. * Click the left button or move mouse with button pressed to fill histograms.; * Use the right button of the mouse to reset the histograms. ### Complex GUI Using Signals and Slots ([guitest.C](https://root.cern.ch/doc/master/guitest_8C.html)). Based on `$ROOTSYS/test/guitest.cxx` this example demonstrates:. * All features of the original compiled guitest.cxx program.; * Sophisticated use of signals and slots to build a complete user interface that can be executed either in the interpreter or as a compiled program.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md:9059,interface,interface,9059,documentation/users-guide/SignalSlot.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md,1,['interface'],['interface']
Integrability,"ace, please do so with your own code as demonstrated in the `hf001` tutorial. ### Deprecations. * The `RooStats::MarkovChain::GetAsDataSet` and `RooStats::MarkovChain::GetAsDataHist` functions are deprecated and will be removed in ROOT 6.36. The same functionality can be implemented by calling `RooAbsData::reduce` on the Markov Chain's `RooDataSet*` (obtained using `MarkovChain::GetAsConstDataSet`) and then obtaining its binned clone(for `RooDataHist`). An example in Python would be:. ```py; mcInt = mc.GetInterval() # Obtain the MCMCInterval from a configured MCMCCalculator; mkc = mcInt.GetChain() # Obtain the MarkovChain; mkcData = mkc.GetAsConstDataSet(); mcIntParams = mcInt.GetParameters(). chainDataset = mkcData.reduce(SelectVars=mcIntParams, EventRange=(mcInt.GetNumBurnInSteps(), mkc.Size())); chainDataHist = chainDataset.binnedClone(); ```. * The following methods related to the RooAbsArg interface are deprecated and will be removed in ROOT 6.36.; They should be replaced with the suitable alternatives interfaces:. - `RooAbsArg::getDependents()`: use `getObservables()`; - `RooAbsArg::dependentOverlaps()`: use `observableOverlaps()`; - `RooAbsArg::checkDependents()`: use `checkObservables()`; - `RooAbsArg::recursiveCheckDependents()`: use `recursiveCheckObservables()`. ## Graphics Backends. ## 2D Graphics Libraries. ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## PyROOT. ### Typesafe `TTree::SetBranchAddress()` for array inputs. If you call `TTree::SetBranchAddress` with NumPy array or `array.array` inputs, ROOT will now check if the array type matches with the column type.; If it doesn't, `SetBranchAddress()` will return a negative status code and print an error.; Take for example this code snippet:; ```python; arr = array.array(typecode, ""d""); status = t.SetBranchAddress(""name"", arr); print(""Status = %s"" % (status, )); ```; If the branch type is al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md:6456,interface,interfaces,6456,README/ReleaseNotes/v634/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md,1,['interface'],['interfaces']
Integrability,"achine code from; assembly.; By default, Clang uses LLVM's integrated assembler on all targets where it is; supported. If you wish to use the system assembler instead, use the; ``-fno-integrated-as`` option. Linker; ------. Clang can be configured to use one of several different linkers:. * GNU ld; * GNU gold; * LLVM's `lld <https://lld.llvm.org>`_; * MSVC's link.exe. Link-time optimization is natively supported by lld, and supported via; a `linker plugin <https://llvm.org/docs/GoldPlugin.html>`_ when using gold. The default linker varies between targets, and can be overridden via the; ``-fuse-ld=<linker name>`` flag. Runtime libraries; =================. A number of different runtime libraries are required to provide different; layers of support for C family programs. Clang will implicitly link an; appropriate implementation of each runtime library, selected based on; target defaults or explicitly selected by the ``--rtlib=`` and ``--stdlib=``; flags. The set of implicitly-linked libraries depend on the language mode. As a; consequence, you should use ``clang++`` when linking C++ programs in order; to ensure the C++ runtimes are provided. .. note::. There may exist other implementations for these components not described; below. Please let us know how well those other implementations work with; Clang so they can be added to this list!. .. FIXME: Describe Objective-C runtime libraries; .. FIXME: Describe profiling runtime library; .. FIXME: Describe cuda/openmp/opencl/... runtime libraries. Compiler runtime; ----------------. The compiler runtime library provides definitions of functions implicitly; invoked by the compiler to support operations not natively supported by; the underlying hardware (for instance, 128-bit integer multiplications),; and where inline expansion of the operation is deemed unsuitable. The default runtime library is target-specific. For targets where GCC is; the dominant compiler, Clang currently defaults to using libgcc_s. On most; other targ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:5066,depend,depend,5066,interpreter/llvm-project/clang/docs/Toolchain.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst,1,['depend'],['depend']
Integrability,"ack and continues execution; at a point in the existing call stack that includes the current invocation.; Annotated functions may still raise an exception, i.a., ``nounwind`` is not implied.; If an invocation of an annotated function does not return control back; to a point in the call stack, the behavior is undefined.; ``nosync``; This function attribute indicates that the function does not communicate; (synchronize) with another thread through memory or other well-defined means.; Synchronization is considered possible in the presence of `atomic` accesses; that enforce an order, thus not ""unordered"" and ""monotonic"", `volatile` accesses,; as well as `convergent` function calls. Note that `convergent` operations can involve communication that is; considered to be not through memory and does not necessarily imply an; ordering between threads for the purposes of the memory model. Therefore,; an operation can be both `convergent` and `nosync`. If a `nosync` function does ever synchronize with another thread,; the behavior is undefined.; ``nounwind``; This function attribute indicates that the function never raises an; exception. If the function does raise an exception, its runtime; behavior is undefined. However, functions marked nounwind may still; trap or generate asynchronous exceptions. Exception handling schemes; that are recognized by LLVM to handle asynchronous exceptions, such; as SEH, will still provide their implementation defined semantics.; ``nosanitize_bounds``; This attribute indicates that bounds checking sanitizer instrumentation; is disabled for this function.; ``nosanitize_coverage``; This attribute indicates that SanitizerCoverage instrumentation is disabled; for this function.; ``null_pointer_is_valid``; If ``null_pointer_is_valid`` is set, then the ``null`` address; in address-space 0 is considered to be a valid address for memory loads and; stores. Any analysis or optimization should not treat dereferencing a; pointer to ``null`` as undefined behav",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:94128,synchroniz,synchronize,94128,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['synchroniz'],['synchronize']
Integrability,"ackProtocolList:. **ObjCBinPackProtocolList** (``BinPackStyle``) :versionbadge:`clang-format 7` :ref:`¶ <ObjCBinPackProtocolList>`; Controls bin-packing Objective-C protocol conformance list; items into as few lines as possible when they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conformance; list items into as few lines as possible whenever they go over; ``ColumnLimit``. If ``Never``, lays out Objective-C protocol conformance list items; onto individual lines whenever they go over ``ColumnLimit``. .. code-block:: objc. Always (or Auto, if BinPackParameters=true):; @interface ccccccccccccc () <; ccccccccccccc, ccccccccccccc,; ccccccccccccc, ccccccccccccc> {; }. Never (or Auto, if BinPackParameters=false):; @interface ddddddddddddd () <; ddddddddddddd,; ddddddddddddd,; ddddddddddddd,; ddddddddddddd> {; }. Possible values:. * ``BPS_Auto`` (in configuration: ``Auto``); Automatically determine parameter bin-packing behavior. * ``BPS_Always`` (in configuration: ``Always``); Always bin-pack parameters. * ``BPS_Never`` (in configuration: ``Never``); Never bin-pack parameters. .. _ObjCBlockIndentWidth:. **ObjCBlockIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCBlockIndentWidth>`; The number of characters to use for indentation of ObjC blocks. .. code-block:: objc. ObjCBlockIndentWidth: 4. [operation setCompletionBlock:^{; [self onOperationDone];; }];. .. _ObjCBreakBeforeNestedBlockParam:. **ObjCBreakBeforeNestedBlockParam** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <ObjCBreakBeforeNestedBlockParam>`; Break parameters list into lines when there is nested block; parameters in a function call. .. code-block:: c++. false:; - (void)_aMethod; {; [self.test1 t:self w:self callback:^(typeo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:88934,interface,interface,88934,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['interface'],['interface']
Integrability,acks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super dealloc];; }; @end. osx.cocoa.IncompatibleMethodTypes; (ObjC); Check for an incompatible type signature when overriding an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. osx.cocoa.MissingSuperCall; (ObjC); Warn about Objective-C methods that lack a necessary call to super. (Note: The; compiler now has a warning for methods annotated with objc_requires_super; attribute. The checker exists to check methods in the Cocoa frameworks; that haven't yet adopted this attribute.). @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. osx.cocoa.NSAutoreleasePool; (ObjC); Warn for suboptimal uses of NSAutoreleasePool in Objective-C; GC mode (-fobjc-gc compiler option). void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. osx.cocoa.NSError; (ObjC); Check usage of NSError** parameters. @interface A : NSObject; - (void)foo:(NSError **)error;; @end. @implementation A; - (void)foo:(NSError **)error {; // warn: method accepting NSError** should have a non-void; // return value;,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:16237,interface,interface,16237,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['interface'],['interface']
Integrability,"acterLiteral>...; Matches character literals (also matches wchar_t). Not matching Hex-encoded chars (e.g. 0x1234, which is a IntegerLiteral),; though. Example matches 'a', L'a'; char ch = 'a';; wchar_t chw = L'a';. Matcher<Stmt>chooseExprMatcher<ChooseExpr>...; Matches GNU __builtin_choose_expr. Matcher<Stmt>coawaitExprMatcher<CoawaitExpr>...; Matches co_await expressions. Given; co_await 1;; coawaitExpr(); matches 'co_await 1'. Matcher<Stmt>compoundLiteralExprMatcher<CompoundLiteralExpr>...; Matches compound (i.e. non-scalar) literals. Example match: {1}, (1, 2); int array[4] = {1};; vector int myvec = (vector int)(1, 2);. Matcher<Stmt>compoundStmtMatcher<CompoundStmt>...; Matches compound statements. Example matches '{}' and '{{}}' in 'for (;;) {{}}'; for (;;) {{}}. Matcher<Stmt>conditionalOperatorMatcher<ConditionalOperator>...; Matches conditional operator expressions. Example matches a ? b : c; (a ? b : c) + 42. Matcher<Stmt>constantExprMatcher<ConstantExpr>...; Matches a constant expression wrapper. Example matches the constant in the case statement:; (matcher = constantExpr()); switch (a) {; case 37: break;; }. Matcher<Stmt>continueStmtMatcher<ContinueStmt>...; Matches continue statements. Given; while (true) { continue; }; continueStmt(); matches 'continue'. Matcher<Stmt>convertVectorExprMatcher<ConvertVectorExpr>...; Matches builtin function __builtin_convertvector. Matcher<Stmt>coreturnStmtMatcher<CoreturnStmt>...; Matches co_return statements. Given; while (true) { co_return; }; coreturnStmt(); matches 'co_return'. Matcher<Stmt>coroutineBodyStmtMatcher<CoroutineBodyStmt>...; Matches coroutine body statements. coroutineBodyStmt() matches the coroutine below; generator<int> gen() {; co_return;; }. Matcher<Stmt>coyieldExprMatcher<CoyieldExpr>...; Matches co_yield expressions. Given; co_yield 1;; coyieldExpr(); matches 'co_yield 1'. Matcher<Stmt>cudaKernelCallExprMatcher<CUDAKernelCallExpr>...; Matches CUDA kernel call expression. Example matches,; kernel<<<i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:25809,wrap,wrapper,25809,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['wrap'],['wrapper']
Integrability,"actory; rf513_wsfactory_tools.C - Advanced example using interfaced high level tools. A formal transaction model is used to commit composite objects into; the workspace. If an error is detected in the expression, no objects; will be committed to the workspace, thus leaving no 'partial builds'. Compact demo of several new major features. The macro below demonstrates in a couple of lines a number of major new features in RooFit 3.00: Use of. workspace factory to quickly create and store (compiled) models; workspace CINT interface to easily access contents in a typesafe way; new adaptive ND numeric integration technique to normalize arbitrary p.d.f. in fast; and reliable way; new adaptive TFoam sampling technique to efficiently generate toy MC data from strongly; peaked datasets; parallel processing in likelihood construction and use of profile likelihood operator; to represent profile likelihoods as regular RooFit functions. void demo(); {; // Construct compiled 2-D model that requires numeric integration for normalization; RooWorkspace w(""w"",1) ;; w.factory(""CEXPR::model('1/((x-a)*(x-a)+0.001)+1/((y-b)*(y-b)+0.001)',x[-1,1],y[-1,1],a[-5,5],b[-5,5])"") ;. // Generate data from model (using TFoam adaptive sampling algorithm); RooDataSet* d = w::model.generate(RooArgSet(w::x,w::y),1000) ;; w::model.fitTo(*d) ;. // Make 2D plot on (x,y); TH2* hh = w::model.createHistogram(""x,y"",40,40) ;; hh->SetLineColor(kBlue) ;. // Make Projection on x (integrate over y); RooPlot* framex = w::x.frame(Title(""Data and p.d.f. projected on X"")) ;; d->plotOn(framex) ;; w::model.plotOn(framex) ;. // Construct likelihood, profile likelihood in a, and draw the latter; RooAbsReal* nll = w::model.createNLL(*d,NumCPU(2)) ;; RooAbsReal* pll = nll->createProfile(w::a) ;; RooPlot* framea = w::a.frame(Title(""Profile likelihood in parameter a"")) ;; pll->plotOn(framea) ;. // Construct 2D cumulative distribution function from p.d.f.; RooAbsReal* cdfxy = w::model.createCdf(RooArgSet(w::x,w::y),ScanNoCdf())",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:22494,integrat,integration,22494,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['integrat'],['integration']
Integrability,"ad local, i.e. all modifications direct or indirect of gDirectory will not be seen by the other thread. In particular this means that several I/O operations (including TDirectory::Write) are thread safe (as long as all the required TClass and TStreamerInfo has been previously setup).; Note: This model does not support sharing TFile amongst threads (i.e. a TFile must be accessed from exactly one thread). This means that whenever a TFile's control is passed from a thread to another, the code must explicitly reset gDirectory to another value or there is a risk for this gDirectory to point to a stale pointer if the other thread deletes the TFile object. A TFile deletion will only affect the value of the local gDirectory and gFile. TMemFile; Introduce TMemFile and update TFileMerger to support incremental merges. Add new tutorials (net/treeClient.C + net/fastMergeServer.C); demonstrating how a TMemFile can be used to do parallel merge; from many clients. (TMemFile still needs to be better integrated; with TMessage and TSocket). The new TMemFile class support the TFile interface but only store; the information in memory. This version is limited to 32MB. TMessage mess;; ...; mess->ReadFastArray(scratch,length);; transient = new TMemFile(""hsimple.memroot"",scratch,length);. will copy the content of 'scratch' into the in-memory buffer; created by/for the TMemFile. TMemFile *file = new TMemFile(""hsimple.memroot"",""RECREATE"");. Will create an empty in-memory of (currently fixed) size 32MB. file->ResetAfterMerge(0);. Will reset the objects in the TDirectory list of objects; so that they are ready for more data accumulations (i.e.; returns the data to 0 but keep the customizations). TFile::MakeProject. New option 'par' in to pack in a PAR file the generated; code. The first argument defines the directory and the name of the package.; For example, the following generates a PAR package equivalent to; tutorials/proof/event.par:. root [] TFile *f = TFile::Open(""http://root.cern/files/d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html:4203,integrat,integrated,4203,io/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html,1,['integrat'],['integrated']
Integrability,"ad their versions updated for this release:. * VecCore 0.5.2; * Vc 1.4.1; * XRootD 4.8.5; * OpenSSL 1.0.2q; * PCRE 8.42. ### Header location and `ROOT_GENERATE_DICTIONARY` / `ROOT_STANDARD_LIBRARY_PACKAGE`. A change in the argument handling of `ROOT_GENERATE_DICTIONARY` and `ROOT_STANDARD_LIBRARY_PACKAGE` might need your attention:; these macros now respect whether a header file was passed with its full relative path (the common case), or with a full path.; The latter allows to find headers at runtime - at the cost of a loss of relocatability: you cannot move the library containing; that dictionary to a different directory, because the header location is stored in the dictionary. This case is used by roottest; but should likely not be used by anything but test suites. Instead pass relative paths, together with a `-I` option to find the headers, plus setting `ROOT_INCLUDE_PATH` for finding the; headers back at runtime. The ROOT stress suite is now updated to follow this behavior; see for instance the injection of; `$ROOTSYS/test` in `test/stressMathCore.cxx`, allowing ROOT to find the header at runtime, whether interpreted; (`R__ADD_INCLUDE_PATH`) or compiled (`TROOT::AddExtraInterpreterArgs({""-I...""})` before interpreter construction). If you called `ROOT_GENERATE_DICTIONARY(Dict ${CMAKE_CURRENT_SOURCE_DIR}/subdir/Header1.h LINKDEF LinkDef.h)` then update that; call to `ROOT_GENERATE_DICTIONARY(Dict Header1.h OPTIONS -I subdir LINKDEF LinkDef.h)` *if* the header is usually included as; `#include ""Header1.h""`, or to `ROOT_GENERATE_DICTIONARY(Dict subdir/Header1.h LINKDEF LinkDef.h)` *if* the header is usually; included as `#include ""subdir/Header1.h""`. I.e. the general rule is: pass to `ROOT_GENERATE_DICTIONARY` (or; `ROOT_STANDARD_LIBRARY_PACKAGE`) the spelling as `#include`ed. As an important side-effect, `ROOT_GENERATE_DICTIONARY` and thus `ROOT_STANDARD_LIBRARY_PACKAGE` now *require* the header to; be found at configuration time. We have seen too many cases where",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:24399,inject,injection,24399,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['inject'],['injection']
Integrability,"ad, loads it and returns the control to cling. ### Performance; This section compares ROOT PCH technology with C++ Modules which is important but; unfair comparison. As we noted earlier, PCH is very efficient, it cannot be; extended to the experiments’ software stacks because of its design constraints.; On the contrary, the C++ Modules can be used in third-party code where the PCH; is not available. The comparisons are to give a good metric when we are ready to switch ROOT to use; C++ Modules by default. However, since it is essentially the same technology,; optimizations of C++ Modules also affect the PCH. We have a few tricks up in; the sleeves to but they come with given trade-offs. #### Preloading of C++ Modules. The main focus for the technology preview was not in performance until recently.; We have invested some resources in optimizations and we would like to show you; (probably outdated) performance results:. * Memory footprint -- mostly due to importing all C++ Modules at startup; we see overhead which depends on the number of preloaded modules. For; ROOT it is between 40-60 MB depending on the concrete configuration.; When the workload increases we notice that the overall memory performance; decreases in number of cases.; * Execution times -- likewise we have an execution overhead. For ; workflows which take ms the slowdown can be 2x. Increasing of the work; to seconds shows 50-60% slowdowns. The performance is dependent on many factors such as configuration of ROOT and; workflow. You can read more at our Intel IPCC-ROOT Showcase presentation; here (pp 25-33)[[8]]. #### Loading C++ Modules on Demand. In long term, we should optimize the preloading of modules to be a no-op and; avoid recursive behavior based on identifier lookup callbacks. Unfortunately,; at the moment the loading of C++ modules on demand shows significantly better; performance results. You can visit our continuous performance monitoring tool where we compare; the performance of ROOT agains",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:18272,depend,depends,18272,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['depend'],['depends']
Integrability,"ad.info``; metadata node to pass this information device compilation stage. Accessing Entries on the Device; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Accessing the entries in the device is done using the address field in the; :ref:`offload entry<table-tgt_offload_entry_structure>`. The runtime will set; the address to the pointer associated with the device image during runtime; initialization. This is used to call the corresponding kernel function when; entering a ``#pragma omp target`` region. For variables, the runtime maintains a; table mapping host pointers to device pointers. Global variables inside a; ``#pragma omp target declare`` directive are first initialized to the host's; address. Once the device address is initialized we insert it into the table to; map the host address to the device address. Debugging Information; ^^^^^^^^^^^^^^^^^^^^^. We generate structures to hold debugging information that is passed to; ``libomptarget``. This allows the front-end to generate information the runtime; library uses for more informative error messages. This is done using the; standard :ref:`identifier structure <table-ident_t_structure>` used in; ``libomp`` and ``libomptarget``. This is used to pass information and source; locations to the runtime. .. table:: ident_t Structure; :name: table-ident_t_structure. +---------+------------+-----------------------------------------------------------------------------+; | Type | Identifier | Description |; +=========+============+=============================================================================+; | int32_t | reserved | Reserved, to be used by the runtime library. |; +---------+------------+-----------------------------------------------------------------------------+; | int32_t | flags | Flags used to indicate some features, mostly unused. |; +---------+------------+-----------------------------------------------------------------------------+; | int32_t | reserved | Reserved, to be used by the runtime library. |; +---------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:8357,message,messages,8357,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst,1,['message'],['messages']
Integrability,"added that can represent the derivative of any p.d.f or function w.r.t. any; parameter or observable. To construct e.g. a first order derivative of a Gaussian p.d.f, do. RooAbsReal* dgdx = gauss.derivative(x,1) ;. A more complete example is available in the new tutorial macro rf111_derivatives.C. Improved handling of chi-squared fits; Chi-squared fits can now be performed through the same style of interface as likelihood fits,; through the newly added method RooAbsReal::chi2FitTo(const RooDataHist&,...). Functions that can be fitted with chi-squared minimization are any RooAbsReal based function; as well as RooAbsPdf based p.d.f.s. In case of non-extended p.d.f.s the probability density; calculated by the p.d.f. is multiplied with the number of events in the histogram to adjust; the scale of the function. In case of extended p.d.f.s, the adjustment is made with the expected; number of events, rather than the observed number of events. Tutorial macro rf602_chi2fit.C has been updated to use this new interface. Chi-squared fits to X-Y datasets now possible; In addition to the ability to perform chi-squared fits to histograms it is now also possible; to perform chi-squared fits to unbinned datasets containing a series of X and Y values; with associated errors on Y and optionally on X. These 'X-Y' chi-squared fits are interfaced through newly added method; RooAbsReal::chi2FitTo(const RooDataSet&,...). By default the event weight is; interpreted as the 'Y' value, but an YVar() argument can designate any other; dataset column as Y value. If X errors are defined, one can choose to integrate the fitted; function over the range of the X errors, rather than taking the central value by adding; an Integrate(true) argument to chi2FitTo(); Two new arguments, StoreError(const RooArgSet&) and StoreAsymError(const RooArgSet&); have been added to the RooDataSet constructor to simplify the process of storing the errors; of X and Y variables along with their values in a dataset. The newl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:8142,interface,interface,8142,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['interface'],['interface']
Integrability,"additional headers or libraries are needed), as Clang will find; all binaries it needs (assembler, linker, etc) in there. #. When you have installed via a package manager (modern Linux; distributions have cross-compiler packages available), make; sure the target triple you set is *also* the prefix of your; cross-compiler toolchain. In this case, Clang will find the other binaries (assembler,; linker), but not always where the target headers and libraries; are. People add system-specific clues to Clang often, but as; things change, it's more likely that it won't find than the; other way around. So, here, you'll be a lot safer if you specify the include/library; directories manually (via ``-I`` and ``-L``). Target-Specific Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMak",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:7758,depend,dependencies,7758,interpreter/llvm-project/clang/docs/CrossCompilation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst,1,['depend'],['dependencies']
Integrability,"adhere to a set of; portability rules associated with the Support Library. Adherence to these rules; should help the Support Library achieve its goal of shielding LLVM from the; variations in operating system interfaces and doing so efficiently. The; following sections define the rules needed to fulfill this objective. Don't Include System Headers; ----------------------------. Except in ``lib/Support``, no LLVM source code should directly ``#include`` a; system header. Care has been taken to remove all such ``#includes`` from LLVM; while ``lib/Support`` was being developed. Specifically this means that header; files like ""``unistd.h``"", ""``windows.h``"", ""``stdio.h``"", and ""``string.h``""; are forbidden to be included by LLVM source code outside the implementation of; ``lib/Support``. To obtain system-dependent functionality, existing interfaces to the system; found in ``include/llvm/Support`` should be used. If an appropriate interface is; not available, it should be added to ``include/llvm/Support`` and implemented in; ``lib/Support`` for all supported platforms. Don't Expose System Headers; ---------------------------. The Support Library must shield LLVM from **all** system headers. To obtain; system level functionality, LLVM source must; ``#include ""llvm/Support/Thing.h""`` and nothing else. This means that; ``Thing.h`` cannot expose any system header files. This protects LLVM from; accidentally using system specific functionality and only allows it via; the ``lib/Support`` interface. Use Standard C Headers; ----------------------. The **standard** C headers (the ones beginning with ""c"") are allowed to be; exposed through the ``lib/Support`` interface. These headers and the things they; declare are considered to be platform agnostic. LLVM source files may include; them directly or obtain their inclusion through ``lib/Support`` interfaces. Use Standard C++ Headers; ------------------------. The **standard** C++ headers from the standard C++ library and standard; te",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:2584,interface,interface,2584,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interface']
Integrability,"adient calculation using:; ``` {.cpp}; std::shared_ptr<RooAbsL> likelihood = /* see examples above */;; RooMinimizer m(likelihood);; ```. By default, `RooFit::MultiProcess` spins up as many workers as there are cores in the system (as detected by `std::thread::hardware_concurrency()`).; To change the number of workers, call `RooFit::MultiProcess::Config::setDefaultNWorkers(desired_N_workers)` **before** creating the `RooMinimizer`. As noted above, offsetting is purely a function of the `RooMinimizer` when using `TestStatistics` classes.; Whereas with `fitTo` we can pass in a `RooFit::Offset(true)` optional `RooCmdArg` argument to activate offsetting, here we must do it on the minimizer as follows:; ``` {.cpp}; m.setOffsetting(true);; ```. All existing functionality of the `RooMinimizer` can be used on `TestStatistics` likelihoods as well.; For instance, running a `migrad` fit:; ``` {.cpp}; m.migrad(); ```. ## Constant term optimization; The `RooAbsTestStatistic` based classes not only combine statistics and calculation, but also constant term optimization routines.; These can be run on PDFs and datasets before starting a fit.; They search the calculation graph for parts that are independent of the fit parameters, precalculates them, and adds them to (a clone of) the dataset so that these values can be used during calculation. In `RooFit::TestStatistics`, we separated this functionality out into the `ConstantTermsOptimizer` class.; In fact, it is not so much a class, as it is a collection of static functions that can be applied to any combination of pdf and dataset.; This class does essentially the same as `constOptimizeTestStatistic` did on a `RooNLLVar`, except that it has been factored out into a separate class. ### Usage example: apply constant term optimization on pdf and dataset inside a likelihood; Applying the default `ConstantTermsOptimizer` optimization routines on the pdf and dataset inside a `RooAbsL` likelihood is as simple as:. ``` {.cpp}; likelihood.co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md:9609,rout,routines,9609,roofit/doc/developers/test_statistics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md,1,['rout'],['routines']
Integrability,"adio buttons, menu bars and popup menus,; scroll bars, list boxes, combo boxes, group frames, text entry; widgets, tab widgets, progress bars, sliders, tool tips. - Complex widgets: shutter, toolbar, status bar, list view, list tree. - Common dialogs: File Open/Save, File Properties, Font Selection,; Color Selection, About. - The widgets are shown in frames:. - frame, composite frame, main frame, transient frame, group frame. - Arranged by layout managers:. - horizontal layout, vertical layout, row layout, list layout, tile; layout, matrix layout. Using a combination of layout hints:. - left, right, center x, center y, top, bottom, expand x, expand y,; fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. - in response to actions widgets send messages and emit signals. - associated frames process these messages or the slot methods; connected to the signals are executed. ## TVirtualX. The GUI classes interface to the platform dependent low level graphics; system via the semi-abstract graphics base class **`TVirtualX`**.; Currently concrete implementations exist for X11 and Win32 (MacOS X is; fully supported via Apple's X11 implementation). Thanks to this single; graphics interface, porting the ROOT GUI to a new platform requires only; the implementation of **`TVirtualX`**. ![](pictures/02000201.jpg). ## A Simple Example. We will start with a simple example that builds a small application; containing a canvas and two buttons: Draw and Exit. Its functionality; will be very simple: every time you click on Draw button, the graphics; of the function `sin(x)/x` will be drawn in randomly chosen interval in; the canvas window, if you click on Exit - you close the application.; This example shows the basic concepts for almost any GUI-application in; ROOT and it is important to understand how it is constructed. The; example program is written as a named script. See ""Cling the C++; Interpreter"". Remember that the named script can be executed v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:2289,interface,interface,2289,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,2,"['depend', 'interface']","['dependent', 'interface']"
Integrability,"after the node is created. For example, in case of a; ``FunctionDecl`` we first import the declaration context in which the function; is declared, then we create the ``FunctionDecl`` and only then we import the; body of the function. This means there are implicit dependencies between AST; nodes. These dependencies determine the order in which we visit nodes in the; ""from"" context. As with the regular graph traversal algorithms like DFS, we; keep track which nodes we have already visited in; ``ASTImporter::ImportedDecls``. Whenever we create a node then we immediately; add that to the ``ImportedDecls``. We must not start the import of any other; declarations before we keep track of the newly created one. This is essential,; otherwise, we would not be able to handle circular dependencies. To enforce; this, we wrap all constructor calls of all AST nodes in; ``GetImportedOrCreateDecl()``. This wrapper ensures that all newly created; declarations are immediately marked as imported; also, if a declaration is; already marked as imported then we just return its counterpart in the ""to""; context. Consequently, calling a declaration's ``::Create()`` function directly; would lead to errors, please don't do that!. Even with the use of ``GetImportedOrCreateDecl()`` there is still a; probability of having an infinite import recursion if things are imported from; each other in wrong way. Imagine that during the import of ``A``, the import of; ``B`` is requested before we could create the node for ``A`` (the constructor; needs a reference to ``B``). And the same could be true for the import of ``B``; (``A`` is requested to be imported before we could create the node for ``B``).; In case of the :ref:`templated-described swing <templated>` we take; extra attention to break the cyclical dependency: we import and set the; described template only after the ``CXXRecordDecl`` is created. As a best; practice, before creating the node in the ""to"" context, avoid importing of; other nodes whic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:99087,wrap,wrapper,99087,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['wrap'],['wrapper']
Integrability,"age adheres to the prescribed ROOT; naming convention, with some (approved) exceptions, as described here:. - Every class and function is in the **`ROOT::Math`** namespace. - Member function names start with upper-case letter, apart some; exceptions (see the next section about CLHEP compatibility). #### Compatibility with CLHEP Vector Classes. - For backward compatibility with CLHEP the vector classes can be; constructed from a CLHEP `HepVector` or **`HepLorentzVector`**, by; using a template constructor, which requires only that the classes; implement the accessors` x()`, `y()`, and `z()` (and `t()` for the; 4D). - We provide vector member function with the same naming convention as; CLHEP for the most used functions like `x()`, `y()` and `z()`. #### Connection to Linear Algebra Package. In some use cases, like in track reconstruction, it is needed to use the; content of the vector and rotation classes in conjunction with linear; algebra operations. We prefer to avoid any direct dependency to any; linear algebra package. However, we provide some hooks to convert to and; from linear algebra classes. The vector and the transformation classes; have methods which allow to get and set their data members (like; `SetCoordinates` and `GetCoordinates`) passing either a generic iterator; or a pointer to a contiguous set of data, like a C array. This allows an; easy connection with the linear algebra package, which in turn, allows; creation of matrices using C arrays (like the ROOT **`TMatrix`**; classes) or iterators (`SMatrix` classes). Multiplication between linear; algebra matrices and `GenVector` vectors is possible by using the; template free functions `ROOT::Math::VectorUtil::Mult`. This function; works for any linear algebra matrix, which implements the operator; (`i,j`) and with first matrix element at `i=j=0`. ### Example: 3D Vector Classes. To avoid exposing template parameter to the users, typedef's are defined; for all types of vectors based on double's and float'",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:76613,depend,dependency,76613,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['depend'],['dependency']
Integrability,"age operations) for all address spaces; (except private, or generic that accesses private); provided the other operation's sync scope is:. - ``system``, ``agent``, ``workgroup`` or; ``wavefront`` and executed by a thread in the; same wavefront. ``singlethread`` Only synchronizes with and participates in; modification and seq_cst total orderings with,; other operations (except image operations) running; in the same thread for all address spaces (for; example, in signal handlers). ``one-as`` Same as ``system`` but only synchronizes with other; operations within the same address space. ``agent-one-as`` Same as ``agent`` but only synchronizes with other; operations within the same address space. ``workgroup-one-as`` Same as ``workgroup`` but only synchronizes with; other operations within the same address space. ``wavefront-one-as`` Same as ``wavefront`` but only synchronizes with; other operations within the same address space. ``singlethread-one-as`` Same as ``singlethread`` but only synchronizes with; other operations within the same address space.; ======================= ===================================================. LLVM IR Intrinsics; ------------------. The AMDGPU backend implements the following LLVM IR intrinsics. *This section is WIP.*. .. table:: AMDGPU LLVM IR Intrinsics; :name: amdgpu-llvm-ir-intrinsics-table. ============================================== ==========================================================; LLVM Intrinsic Description; ============================================== ==========================================================; llvm.amdgcn.sqrt Provides direct access to v_sqrt_f64, v_sqrt_f32 and v_sqrt_f16; (on targets with half support). Performs sqrt function. llvm.amdgcn.log Provides direct access to v_log_f32 and v_log_f16; (on targets with half support). Performs log2 function. llvm.amdgcn.exp2 Provides direct access to v_exp_f32 and v_exp_f16; (on targets with half support). Performs exp2 function. :ref:`llvm.frexp <int_frex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:35211,synchroniz,synchronizes,35211,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronizes']
Integrability,"age: rootcling [-v][-v0-4] [-f] [out.cxx] [opts] file1.h[+][-][!] file2.h[+][-][!] ...[Linkdef.h]; For more extensive help type: /usr/local/lib/python2.7/dist-packages/cppyy_backend/bin/rootcling -h. Rather than providing command line options, the main steering of; ``rootcling`` behavior is done through; `#pragmas in a Linkdef.h <https://root.cern.ch/root/html/guides/users-guide/AddingaClass.html#the-linkdef.h-file>`_; file, with most pragmas dedicated to selecting/excluding (parts of) classes; and functions.; Additionally, the Linkdef.h file may contain preprocessor macros. The output consists of a dictionary file (to be compiled into a shared; library), a C++ module, and an optional mapping file, as described above. genreflex; """""""""""""""""". The second interface is called ``genreflex``::. $ genreflex; Generates dictionary sources and related ROOT pcm starting from an header.; Usage: genreflex headerfile.h [opts] [preproc. opts]; ... ``genreflex`` has a richer command line interface than ``rootcling`` as can; be seen from the full help message. .. _selection-files:. Selection/exclusion is driven through a `selection file`_ using an XML format; that allows both exact and pattern matching to namespace, class, enum,; function, and variable names. .. _`selection file`: https://linux.die.net/man/1/genreflex. Example; """""""""""""". Consider the following basic example code, living in a header ""MyClass.h"":. .. code-block:: C++. class MyClass {; public:; MyClass(int i) : fInt(i) {}; int get_int() { return fInt; }. private:; int fInt;; };. and a corresponding ""Linkdef.h"" file, selecting only ``MyClass``::. #ifdef __ROOTCLING__; #pragma link off all classes;; #pragma link off all functions;; #pragma link off all globals;; #pragma link off all typedef;. #pragma link C++ class MyClass;. #endif. For more pragmas, see the `rootcling manual`_.; E.g., a commonly useful pragma is one that selects all C++ entities that are; declared in a specific header file::. #pragma link C++ defined_in ""My",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:4869,interface,interface,4869,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,2,"['interface', 'message']","['interface', 'message']"
Integrability,"age; collection. By now, these mechanisms are well proven with commercial java; implementation with a fully relocating collector having shipped using them.; There are a couple places where bugs might still linger; these are called out; below. They are still listed as ""experimental"" to indicate that no forward or backward; compatibility guarantees are offered across versions. If your use case is such; that you need some form of forward compatibility guarantee, please raise the; issue on the llvm-dev mailing list. LLVM still supports an alternate mechanism for conservative garbage collection; support using the ``gcroot`` intrinsic. The ``gcroot`` mechanism is mostly of; historical interest at this point with one exception - its implementation of; shadow stacks has been used successfully by a number of language frontends and; is still supported. Overview & Core Concepts; ========================. To collect dead objects, garbage collectors must be able to identify; any references to objects contained within executing code, and,; depending on the collector, potentially update them. The collector; does not need this information at all points in code - that would make; the problem much harder - but only at well-defined points in the; execution known as 'safepoints' For most collectors, it is sufficient; to track at least one copy of each unique pointer value. However, for; a collector which wishes to relocate objects directly reachable from; running code, a higher standard is required. One additional challenge is that the compiler may compute intermediate; results (""derived pointers"") which point outside of the allocation or; even into the middle of another allocation. The eventual use of this; intermediate value must yield an address within the bounds of the; allocation, but such ""exterior derived pointers"" may be visible to the; collector. Given this, a garbage collector can not safely rely on the; runtime value of an address to indicate the object it is associated; wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:1278,depend,depending,1278,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['depend'],['depending']
Integrability,"ageclass:. DLL Storage Classes; -------------------. All Global Variables, Functions and Aliases can have one of the following; DLL storage class:. ``dllimport``; ""``dllimport``"" causes the compiler to reference a function or variable via; a global pointer to a pointer that is set up by the DLL exporting the; symbol. On Microsoft Windows targets, the pointer name is formed by; combining ``__imp_`` and the function or variable name.; ``dllexport``; On Microsoft Windows targets, ""``dllexport``"" causes the compiler to provide; a global pointer to a pointer in a DLL, so that it can be referenced with the; ``dllimport`` attribute. the pointer name is formed by combining ``__imp_``; and the function or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------------------. A variable may be defined as ``thread_local``, which means that it will; not be shared by threads (each thread will have a separated copy of the; variable). Not all targets support thread-local variables. Optionally, a; TLS model may be specified:. ``localdynamic``; For variables that are only used within the current shared library.; ``initialexec``; For variables in modules that will not be loaded dynamically.; ``localexec``; For variables defined in the executable and only used within it. If no explicit model is given, the ""general dynamic"" model is used. The models correspond to the ELF TLS models; see `ELF Handling For; Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for; more information on under which circumstances the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:25341,interface,interface,25341,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['interface'],['interface']
Integrability,"ager (modern Linux; distributions have cross-compiler packages available), make; sure the target triple you set is *also* the prefix of your; cross-compiler toolchain. In this case, Clang will find the other binaries (assembler,; linker), but not always where the target headers and libraries; are. People add system-specific clues to Clang often, but as; things change, it's more likely that it won't find than the; other way around. So, here, you'll be a lot safer if you specify the include/library; directories manually (via ``-I`` and ``-L``). Target-Specific Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have mult",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:7993,depend,dependency,7993,interpreter/llvm-project/clang/docs/CrossCompilation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst,1,['depend'],['dependency']
Integrability,"ager->FindNode();; ~~~. In order to have more flexibility, there are in fact several alternative; ways of initializing a modeller state:. ~~~{.cpp}; // Setting the point and finding the state in one step:; gGeoManager->FindNode(Double_t x,Double_t y,Double_t z);; gGeoManager->FindNode(Double_t *point[3]);; // Setting both initial point and direction and finding the state:; gGeoManager->InitTrack(Double_t x,Double_t y,Double_t z,; Double_t nx, Double_t ny, Double_t nz);; gGeoManager->InitTrack(Double_t *point[3],Double_t *dir[3]);; ~~~. Note that the current point coordinates can be changed and the state; re-initialized at any time. This represents the `‘Where am I?'`; geometrical query representing the basic navigation functionality; provided by the modeller. \anchor GP02e; ### Checking the Current State. The current state and all variables related to this are essential during; tracking and have to be checked several times. Besides the current point; and direction, the following additional information can be retrieved; from TGeoManager interface:. - The `current path`. This represents a string containing the names; and copy numbers of all positioned objects in the current `branch`; written in the /folder/folder/.../folder/file fashion. The final node; pointed by the path is the deepest object containing the current; point and is representative for the current state. All intermediate; `folders` in the path are in fact also nodes ""touched"" by the; current point, but having some ""touched"" containment. The current; path can be retrieved only after the state was initialized and is; useful for getting an idea of the current point location. ~~~{.cpp}; const char *path = gGeoManager->GetPath();; cout << ""Current path is: "" << path << endl;; /A_1/B_34/C_3/D_1; ~~~. - The `current node`, `volume` and `material`. In order to; take decisions on post-step or further stepping actions, one has to; know these. In order to get a pointer to the current node one can; do:. ~~~{.cpp}; T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:67917,interface,interface,67917,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['interface'],['interface']
Integrability,"ailed description for all `MathCore` classes is available in the Doxygen; [online reference documentation](online reference documentation). ## MathMore Library. The `MathMore` library provides an advanced collection of functions and; C++ classes for numerical computing. This is an extension of the; functionality provided by the `MathCore` library.; The `MathMore` library is implemented wrapping in C++ the GNU Scientific Library (GSL).; The current set, provided in; the `ROOT::Math` namespace; include:. - Special mathematical functions (like Bessel functions, Legendre polynomials, etc.. ). - Additional mathematical functions used in statistics such as probability density; functions, cumulative distributions functions and their inverse which are not in `MathCore` but present in; the `GSL` library. - Numerical algorithms for one dimensional functions based on; implementation of the GNU Scientific Library (GSL):. - Numerical integration classes implementing the interface **`ROOT::Math::Integrator`**; which is based on the Adaptive integration algorithms of QUADPACK. - Numerical differentiation via **`ROOT::Math::GSLDerivator`**. - Root finder implementing the **`ROOT::Math::RootFinder`** interface, using different; solver algorithms from GSL. - one-dimensional Minimization implementing the interface**`ROOT::Math::IMinimizer1D`**. - Interpolation via **`ROOT::Math::Interpolation`**. All the GSL; interpolation types are supported. - Function approximation based on Chebyshev polynomials via the class; **`ROOT::Math::Chebyshev`**. - Random number generators and distributions based on GSL using the `ROOT::Math::Random<Engine_type>` class. - Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in; the namespace **`ROOT::Math`**. The naming used for the special; functions is the same proposed for the C++ standard (see C++ standard; extension [proposal document](proposal document)).The `MathMore` library; is implemented w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:3834,integrat,integration,3834,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,3,"['integrat', 'interface']","['integration', 'interface']"
Integrability,"ain(int argc, char **argv) {; A* a = new A();; A* b = new A();; a->Connect(""SetValue(Int_t)"", ""A"", b, ""SetValue(Int_t)"");; printf(""n******* Test of SetValue(Int_t) signal *******n"");; b->SetValue(10);; printf(""nt***** b before ******n"");; b->PrintValue();; a->SetValue(20);; printf(""t***** b after a->SetValue(20) ******n"");; b->PrintValue();; return 0;; }; #endif; ```. ACLiC simplifies this procedure and allows the dictionary generation by:. ``` {.cpp}; root[] .L tst.C++; ```. It will create the shared library `tst_C.so.`. The next line will create an executable:. **`` g++ -otst tst.C `root-config --cflags --libs` ./tst_C.so -DSTANDALONE ``**. The library `tst_C.so` is a dynamically loaded library and should be; located in `$LD_LIBRARY_PATH`. The current working directory should be; added to `$LD_LIBRARY_PATH` via:. **`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./`**. To run it, you just do:. **`./tst`**. ## Widgets in Detail. ### Buttons. Buttons are a popular group of widgets designed to provide specific; interfaces for user interaction. **`TGButton`** is an abstract class; defining the general button behavior: width, height, state, its group,; tool tip text, etc. There are two main groups of buttons: command buttons with a text or; graphics inside that indicate the action to be accomplished and option; buttons well known as radio and check buttons that select or change; properties. The first group is presented in ROOT by; **`TGPictureButton`** and **`TGTextButton`** classes. They yield an; action as soon as they are clicked. It can be opening/closing a dialog; box or invoking a specific function in an application. Remember the Draw; button from the example. The radio and check buttons from the second; group are used to select an option. There is a visual difference between; these two groups: the text buttons appear ""pressed in"" only while they; are clicked, while the radio and check buttons change their appearance; when they are selected and keep that appearance afte",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:54038,interface,interfaces,54038,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['interface'],['interfaces']
Integrability,"aining references to the; header locations used when building (and any additional locations provided),; a set of forward declarations to reduce the need of loading header files, and; a few I/O helper functions.; The name ""dictionary"" is historic: before ``cling`` was used, it contained; the complete generated C++ reflection information, whereas now that is; derived at run-time from the header files.; It is still possible to fully embed header files rather than only storing; their names and search locations, to make the dictionary more self-contained. After generating the dictionary, it should be compiled into a shared library.; This provides additional dependency control: by linking it directly with any; further libraries needed, you can use standard mechanisms such as ``rpath``; to locate those library dependencies.; Alternatively, you can add the additional libraries to load to the mapping; files of the class loader (see below). .. note::. The JIT needs to resolve linker symbols in order to call them through; generated wrappers.; Thus, any classes, functions, and data that will be used in Python need; to be exported.; This is the default behavior on Mac and Linux, but not on Windows.; On that platform, use ``__declspec(dllexport)`` to explicitly export the; classes and function you expect to call.; CMake has simple `support for exporting all`_ C++ symbols. In tandem with any dictionary, a pre-compiled module (.pcm) file will be; generated.; C++ modules are still on track for inclusion in the C++20 standard and most; modern C++ compilers, ``clang`` among them, already have implementations.; The benefits for cppyy include faster bindings generation, lower memory; footprint, and isolation from preprocessor macros and compiler flags.; The use of modules is transparent, other than the requirement that they; need to be co-located with the compiled dictionary shared library. Optionally, the dictionary generation process also produces a mapping file,; which lists the libra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:2109,wrap,wrappers,2109,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,1,['wrap'],['wrappers']
Integrability,"ains a number of ; Experimental (Alpha) Checkers. Writeups with examples of some of the bugs that the analyzer finds. Bug Finding With Clang: 5 Resources To Get You Started; Finding Memory Leaks With The LLVM/Clang Static Analyzer; Under the Microscope - The Clang Static Analyzer; Mike Ash - Using the Clang Static Analyzer. Default Checkers. Core Checkers model core language features and perform general-purpose checks such as division by zero, null pointer dereference, usage of uninitialized values, etc.; C++ Checkers perform C++-specific checks; Dead Code Checkers check for unused code; Nullability Checkers ; Optin Checkers ; OS X Checkers perform Objective-C-specific checks and check the use of Apple's SDKs (OS X and iOS); Security Checkers check for insecure API usage and perform checks based on the CERT Secure Coding Standards; Unix Checkers check the use of Unix and POSIX APIs. Core Checkers. Name, DescriptionExample. core.CallAndMessage; (C, C++, ObjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:1374,message,message,1374,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['message'],['message']
Integrability,"airly simple and there is little code reuse opportunity anyway. .. _implementation-details:. Implementation Details; ======================. The current implementation of DDG differs slightly from the dependence; graph described in [1]_ in the following ways:. 1. The graph nodes in the paper represent three main program components, namely *assignment statements*, *for loop headers* and *while loop headers*. In this implementation, DDG nodes naturally represent LLVM IR instructions. An assignment statement in this implementation typically involves a node representing the ``store`` instruction along with a number of individual nodes computing the right-hand-side of the assignment that connect to the ``store`` node via a def-use edge. The loop header instructions are not represented as special nodes in this implementation because they have limited uses and can be easily identified, for example, through ``LoopAnalysis``.; 2. The paper describes five types of dependency edges between nodes namely *loop dependency*, *flow-*, *anti-*, *output-*, and *input-* dependencies. In this implementation *memory* edges represent the *flow-*, *anti-*, *output-*, and *input-* dependencies. However, *loop dependencies* are not made explicit, because they mainly represent association between a loop structure and the program elements inside the loop and this association is fairly obvious in LLVM IR itself.; 3. The paper describes two types of pi-blocks; *recurrences* whose bodies are SCCs and *IN* nodes whose bodies are not part of any SCC. In this implementation, pi-blocks are only created for *recurrences*. *IN* nodes remain as simple DDG nodes in the graph. References; ----------; .. [1] ""D. J. Kuck, R. H. Kuhn, D. A. Padua, B. Leasure, and M. Wolfe (1981). DEPENDENCE GRAPHS AND COMPILER OPTIMIZATIONS.""; .. [2] ""J. FERRANTE (IBM), K. J. OTTENSTEIN (Michigan Technological University) and JOE D. WARREN (Rice University), 1987. The Program Dependence Graph and Its Use in Optimization.""; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:5679,depend,dependency,5679,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,5,['depend'],"['dependencies', 'dependency']"
Integrability,"aive mathematical formulas for complex; multiplication and enables application of Smith's algorithm for complex; division. See SMITH, R. L. Algorithm 116: Complex division. Commun.; ACM 5, 8 (1962). The default is ``-fno-cx-fortran-rules``. .. _floating-point-environment:. Accessing the floating point environment; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; Many targets allow floating point operations to be configured to control things; such as how inexact results should be rounded and how exceptional conditions; should be handled. This configuration is called the floating point environment.; C and C++ restrict access to the floating point environment by default, and the; compiler is allowed to assume that all operations are performed in the default; environment. When code is compiled in this default mode, operations that depend; on the environment (such as floating-point arithmetic and `FLT_ROUNDS`) may have; undefined behavior if the dynamic environment is not the default environment; for; example, `FLT_ROUNDS` may or may not simply return its default value for the target; instead of reading the dynamic environment, and floating-point operations may be; optimized as if the dynamic environment were the default. Similarly, it is undefined; behavior to change the floating point environment in this default mode, for example; by calling the `fesetround` function.; C provides two pragmas to allow code to dynamically modify the floating point environment:. - ``#pragma STDC FENV_ACCESS ON`` allows dynamic changes to the entire floating; point environment. - ``#pragma STDC FENV_ROUND FE_DYNAMIC`` allows dynamic changes to just the floating; point rounding mode. This may be more optimizable than ``FENV_ACCESS ON`` because; the compiler can still ignore the possibility of floating-point exceptions by default. Both of these can be used either at the start of a block scope, in which case; they cover all code in that scope (unless they're turned off in a child scope),; or at the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:69517,depend,depend,69517,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['depend'],['depend']
Integrability,"ake this the default for all; ``unsigned`` options. To start out, we declare our new ``FileSizeParser`` class:. .. code-block:: c++. struct FileSizeParser : public cl::parser<unsigned> {; // parse - Return true on error.; bool parse(cl::Option &O, StringRef ArgName, const std::string &ArgValue,; unsigned &Val);; };. Our new class inherits from the ``cl::parser`` template class to fill in; the default, boiler plate code for us. We give it the data type that we parse; into, the last argument to the ``parse`` method, so that clients of our custom; parser know what object type to pass in to the parse method. (Here we declare; that we parse into '``unsigned``' variables.). For most purposes, the only method that must be implemented in a custom parser; is the ``parse`` method. The ``parse`` method is called whenever the option is; invoked, passing in the option itself, the option name, the string to parse, and; a reference to a return value. If the string to parse is not well-formed, the; parser should output an error message and return true. Otherwise it should; return false and set '``Val``' to the parsed value. In our example, we; implement ``parse`` as:. .. code-block:: c++. bool FileSizeParser::parse(cl::Option &O, StringRef ArgName,; const std::string &Arg, unsigned &Val) {; const char *ArgStart = Arg.c_str();; char *End;. // Parse integer part, leaving 'End' pointing to the first non-integer char; Val = (unsigned)strtol(ArgStart, &End, 0);. while (1) {; switch (*End++) {; case 0: return false; // No error; case 'i': // Ignore the 'i' in KiB if people use that; case 'b': case 'B': // Ignore B suffix; break;. case 'g': case 'G': Val *= 1024*1024*1024; break;; case 'm': case 'M': Val *= 1024*1024; break;; case 'k': case 'K': Val *= 1024; break;. default:; // Print an error message if unrecognized character!; return O.error(""'"" + Arg + ""' value invalid for file size argument!"");; }; }; }. This function implements a very simple parser for the kinds of strings we are; int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:64286,message,message,64286,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['message'],['message']
Integrability,"aking Changes`` section of; the notes with sufficient information and examples to demonstrate the; potential disruption. Additionally, any new entries to this section should be; announced in the `Announcements <https://discourse.llvm.org/c/announce/>`_; channel on Discourse. See :ref:`breaking` for more details. Code reviewers are encouraged to request a release note if they think one is; warranted when performing a code review. Quality; -------. The minimum quality standards that any change must satisfy before being; committed to the main development branch are:. #. Code must adhere to the `LLVM Coding Standards <CodingStandards.html>`_. #. Code must compile cleanly (no errors, no warnings) on at least one platform. #. Bug fixes and new features should `include a testcase`_ so we know if the; fix/feature ever regresses in the future. #. Code must pass the ``llvm/test`` test suite. #. The code must not cause regressions on a reasonable subset of llvm-test,; where ""reasonable"" depends on the contributor's judgement and the scope of; the change (more invasive changes require more testing). A reasonable subset; might be something like ""``llvm-test/MultiSource/Benchmarks``"". #. Ensure that links in source code and test files point to publicly available; resources and are used primarily to add additional information rather than; to supply critical context. The surrounding comments should be sufficient; to provide the context behind such links. Additionally, the committer is responsible for addressing any problems found in; the future that the change is responsible for. For example:. * The code should compile cleanly on all supported platforms. * The changes should not cause any correctness regressions in the ``llvm-test``; suite and must not cause any major performance regressions. * The change set should not cause performance or correctness regressions for the; LLVM tools. * The changes should not cause performance or correctness regressions in code; compiled by LLVM on ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:12855,depend,depends,12855,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['depend'],['depends']
Integrability,"aking into account meta data and rounding up to next 512 bytes, ensuring a complete cluster fits into a single basket. ### Fast Cloning. We added a cache specifically for the fast option of the TTreeCloner to significantly reduce the run-time when fast-cloning remote files to address [ROOT-5078]. It can be controlled from the `TTreeCloner`, `TTree::CopyEntries` or `hadd` interfaces. The new cache is enabled by default, to update the size of the cache or disable it from `TTreeCloner` use: `TTreeCloner::SetCacheSize`. To do the same from `TTree::CopyEntries` add to the option string ""cachesize=SIZE"". To update the size of the cache or disable it from `hadd`, use the command line option `-cachesize SIZE`. `SIZE` shouyld be given in number bytes and can be expressed in 'human readable form' (number followed by size unit like MB, MiB, GB or GiB, etc. or SIZE can be set zero to disable the cache. ### Other Changes. * Update `TChain::LoadTree` so that the user call back routine is actually called for each input file even those containing `TTree` objects with no entries.; * Repair setting the branch address of a leaflist style branch taking directly the address of the struct. (Note that leaflist is nonetheless still deprecated and declaring the struct to the interpreter and passing the object directly to create the branch is much better).; * Provide an implicitly parallel implementation of `TTree::GetEntry`. The approach is based on creating a task per top-level branch in order to do the reading, unzipping and deserialisation in parallel. In addition, a getter and a setter methods are provided to check the status and enable/disable implicit multi-threading for that tree (see Parallelisation section for more information about implicit multi-threading).; * Properly support `std::cin` (and other stream that can not be rewound) in `TTree::ReadStream`. This fixes [ROOT-7588].; * Prevent `TTreeCloner::CopyStreamerInfos()` from causing an autoparse on an abstract base class. ## His",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:10323,rout,routine,10323,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['rout'],['routine']
Integrability,"al arithmetic conversions are applied to ``M1`` and ``M2``.; * The type of ``M1`` shall have the same number of columns as the type of ``M2`` has; rows. The element types of ``M1`` and ``M2`` shall be the same type.; * The resulting type, ``MTy``, is a matrix type with the common element type,; the number of rows of ``M1`` and the number of columns of ``M2``.; * The result is equivalent to ``Res`` in the following where ``EltTy`` is the; element type of ``MTy``, ``col`` is the number of columns, ``row`` is the; number of rows in ``MTy`` and ``inner`` is the number of columns of ``M1``:. .. code-block:: c++. MTy Res;; for (int C = 0; C < col; ++C) {; for (int R = 0; R < row; ++R) {; EltTy Elt = 0;; for (int K = 0; K < inner; ++K) {; Elt += M1[R][K] * M2[K][C];; }; Res[R][C] = Elt;; }. All operations on matrix types match the behavior of the element type with; respect to signed overflows. With respect to floating-point contraction, rounding and environment rules,; operations on matrix types match the behavior of the elementwise operations; in the corresponding expansions provided above. Operations on floating-point matrices have the same rounding and floating-point; environment behavior as ordinary floating-point operations in the expression's; context. For the purposes of floating-point contraction, all calculations done; as part of a matrix operation are considered intermediate operations, and their; results need not be rounded to the format of the element type until the final; result in the containing expression. This is subject to the normal restrictions; on contraction, such as ``#pragma STDC FP_CONTRACT``. For the ``+=``, ``-=`` and ``*=`` operators the semantics match their expanded; variants. Matrix Type Builtin Operations; ------------------------------. Each matrix type supports a collection of builtin expressions that look like; function calls but do not form an overload set. Here they are described as; function declarations with rules for how to construct ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:7391,contract,contraction,7391,interpreter/llvm-project/clang/docs/MatrixTypes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst,1,['contract'],['contraction']
Integrability,"al calculation of the alias analysis results (the ""run""; method) is only performed once, but many (perhaps duplicate) queries may be; performed. Because of this, try to move as much computation to the run method; as possible (within reason). Limitations; -----------. The AliasAnalysis infrastructure has several limitations which make writing a; new ``AliasAnalysis`` implementation difficult. There is no way to override the default alias analysis. It would be very useful; to be able to do something like ""``opt -my-aa -O2``"" and have it use ``-my-aa``; for all passes which need AliasAnalysis, but there is currently no support for; that, short of changing the source code and recompiling. Similarly, there is; also no way of setting a chain of analyses as the default. There is no way for transform passes to declare that they preserve; ``AliasAnalysis`` implementations. The ``AliasAnalysis`` interface includes; ``deleteValue`` and ``copyValue`` methods which are intended to allow a pass to; keep an AliasAnalysis consistent, however there's no way for a pass to declare; in its ``getAnalysisUsage`` that it does so. Some passes attempt to use; ``AU.addPreserved<AliasAnalysis>``, however this doesn't actually have any; effect. Similarly, the ``opt -p`` option introduces ``ModulePass`` passes between each; pass, which prevents the use of ``FunctionPass`` alias analysis passes. The ``AliasAnalysis`` API does have functions for notifying implementations when; values are deleted or copied, however these aren't sufficient. There are many; other ways that LLVM IR can be modified which could be relevant to; ``AliasAnalysis`` implementations which can not be expressed. The ``AliasAnalysisDebugger`` utility seems to suggest that ``AliasAnalysis``; implementations can expect that they will be informed of any relevant ``Value``; before it appears in an alias query. However, popular clients such as ``GVN``; don't support this, and are known to trigger errors when run with the; ``AliasAna",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:17549,interface,interface,17549,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['interface'],['interface']
Integrability,"al function describing the relation between the independent variables **`X`** and the single dependent variable `Y`.; We can have an arbitrary number `k` of independent variables. For example, when fitting a `k`-dimensional histogram,; the independent variables **`X`** are the bin center coordinates and `Y` is the bin weight. The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe; the observed data. We can use the ROOT **`TF1`** class, the parametric function class, to describe the model function. However the `ROOT::Fit::Fitter` class, to be independent of the ROOT *`Hist`* library,; takes as input a more general parametric function object, the interface (abstract) class `ROOT::Math::IParametricFunctionMultiDim`, which describe a generic one or multi-dimensional function; with parameters. This interface extends the abstract class `ROOT::Math::IBaseFunctionMultiDim`, with methods to set/retrieve parameter values and to evaluate the function given the; independent vector of values **`X`** and vector of parameters `P`.; More information about the different `ROOT::Math` function interfaces is available in the Mathematical Library chapter. An end-user can convert a **`TF1`** object in a `ROOT::Math::IParametricFunctionMultiDim`, using the wrapper class `ROOT::Math::WrapperMultiTF1`:. ``` {.cpp}; TF1 * f1 = new TF1(""f1"",""gaus"");; ROOT::Math::WrappedMultiTF1 fitFunction(f1, f1->GetNdim() );; ROOT::Fit::Fitter fitter;; fitter.SetFunction( fitFunction, false);; ```. When creating the wrapper, the parameter values stored in **`TF1`** will be copied in the `ROOT::Math::WrappedMultiTF1` object.; The function object representing the model function is given to the `ROOT::Fitter` class using the `Fitter::SetFunction` method. The user has also the possibility to provide a function object, which implements the derivatives of the function with respect; to the parameters.; This information might be us",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:36265,interface,interface,36265,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['interface'],['interface']
Integrability,"al functions, interfacing the GSL; math library. - `libMinuit` is the MINUIT fitter. - `libNet` contains functionality related to network transfer. - `libNew` is the special global new/delete, provides extra memory; checking and interface for shared memory (optional). - `libPhysics` contains the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProof` is the parallel ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the interactive interface to ROOT (provides command; prompt). - `libRIO` provides the functionality to write and read objects to; and from ROOT files. - `libRooFit` is the RooFit fitting framework. - `libRuby` is the interface to Ruby. - `libSpectrum` provides functionality for spectral analysis. - \*`libThread` is the interface to TThread classes. - `libTMVA` contains the multivariate analysis toolkit. - `libTree` is the TTree object container system. - `libTreePlayer` is the TTree drawing classes. - `libTreeViewer` is the graphical TTree query interface. #### Library Dependencies. ![ROOT libraries dependencies](pictures/03000005.png). The libraries are designed and organized to minimize dependencies,; such that you can load just enough code for the task at hand rather; than having to load all libraries or one monolithic chunk. The core; library (`libCore.so`) contains the essentials; it is a part of all; ROOT applications. In the Figure 1-2 you see that libCore.so is made; up of base classes, container classes, meta information classes,; operating system specific classes, and the ZIP algorithm used for; compression of the ROOT files. The Cling library (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:15697,interface,interface,15697,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['interface'],['interface']
Integrability,"al is not intended to explain what; LLVM is, how it works, and what LLVM code looks like. It assumes that you know; the basics of LLVM and are interested in writing transformations or otherwise; analyzing or manipulating the code. This document should get you oriented so that you can find your way in the; continuously growing source code that makes up the LLVM infrastructure. Note; that this manual is not intended to serve as a replacement for reading the; source code, so if you think there should be a method in one of these classes to; do something, but it's not listed, check the source. Links to the `doxygen; <https://llvm.org/doxygen/>`__ sources are provided to make this as easy as; possible. The first section of this document describes general information that is useful; to know when working in the LLVM infrastructure, and the second describes the; Core LLVM classes. In the future this manual will be extended with information; describing how to use extension libraries, such as dominator information, CFG; traversal routines, and useful utilities like the ``InstVisitor`` (`doxygen; <https://llvm.org/doxygen/InstVisitor_8h_source.html>`__) template. .. _general:. General Information; ===================. This section contains general information that is useful if you are working in; the LLVM source-base, but that isn't specific to any particular API. .. _stl:. The C++ Standard Template Library; ---------------------------------. LLVM makes heavy use of the C++ Standard Template Library (STL), perhaps much; more than you are used to, or have seen before. Because of this, you might want; to do a little background reading in the techniques used and capabilities of the; library. There are many good pages that discuss the STL, and several books on; the subject that you can get, so it will not be discussed in this document. Here are some useful links:. #. `cppreference.com; <https://en.cppreference.com/w/>`_ - an excellent; reference for the STL and other parts of the s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:1359,rout,routines,1359,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['rout'],['routines']
Integrability,"al of deprecated HistFactory functionality. #### Removal of HistoToWorkspaceFactory (non-Fast version). The original `HistoToWorkspaceFactory` produced models that consisted of a; Poisson term for each bin. In this ""number counting form"" the dataset has one; row and the collumns corresponded to the number of events for each bin. This; led to severe performance problems in statistical tools that generated; pseudo-experiments and evaluated likelihood ratio test statistics. Nowadays, everyone uses the faster `HistoToWorkspaceFactoryFast` implementation that; produces a model in the ""standard form"" where the dataset has one row for each; event, and the column corresponds to the value of the observable in the; histogram. Therefore, the original `HistoToWorkspaceFactory` is now removed to avoid; confusion and maintainance burden. #### Removing constant parameter flag from RooStats:HistFactory::NormFactor. As printed out by the HistFactory in a warning message for a long time already,; setting the `Const` attribute to the `<NormFactor>` tag is deprecated and it; will be ignored. Instead, add `<ParamSetting Const=""True""> myparam </ParamSetting>` to your top-level XML's `<Measurement>` entry. This deprecation implied that the constant parameter flag in the; `RooStats:HistFactory::NormFactor` class had no effect as well. To avoid; ambiguity in the future, the possibility to set and retrieve this flag with; `NormFactor::SetConst()` and `NormFactor::GetConst()` was removed, as well as the; `Sample::AddNormFactor(std::string Name, double Val, double Low, double High, bool Const)`; overload. Also, the aforementioned deprecation warning is not printed anymore. ### Removal of `RooAbsMinimizerFcn` and `RooMinimizerFcn` from the public interface. The `RooAbsMinimizerFcn` class and its implementation `RooMinimizerFcn` were removed from the public interface.; These classes are implementation details of the RooMinimizer and should not be used in your code.; In the unlikely case that thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:23415,message,message,23415,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['message'],['message']
Integrability,"al pointer aliasing rules. It's invalid to take a GEP; from one object, address into a different separately allocated object, and; dereference it. IR producers (front-ends) must follow this rule, and consumers; (optimizers, specifically alias analysis) benefit from being able to rely on; it. See the `Rules`_ section for more information. And, GEP is more concise in common cases. However, for the underlying integer computation implied, there is no; difference. I'm writing a backend for a target which needs custom lowering for GEP. How do I do this?; -----------------------------------------------------------------------------------------. You don't. The integer computation implied by a GEP is target-independent.; Typically what you'll need to do is make your backend pattern-match expressions; trees involving ADD, MUL, etc., which are what GEP is lowered into. This has the; advantage of letting your code work correctly in more cases. GEP does use target-dependent parameters for the size and layout of data types,; which targets can customize. If you require support for addressing units which are not 8 bits, you'll need to; fix a lot of code in the backend, with GEP lowering being only a small piece of; the overall picture. How does VLA addressing work with GEPs?; ---------------------------------------. GEPs don't natively support VLAs. LLVM's type system is entirely static, and GEP; address computations are guided by an LLVM type. VLA indices can be implemented as linearized indices. For example, an expression; like ``X[a][b][c]``, must be effectively lowered into a form like; ``X[a*m+b*n+c]``, so that it appears to the GEP as a single-dimensional array; reference. This means if you want to write an analysis which understands array indices and; you want to support VLAs, your code will have to be prepared to reverse-engineer; the linearization. One way to solve this problem is to use the ScalarEvolution; library, which always presents VLA and non-VLA indexing in the sa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:11276,depend,dependent,11276,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['depend'],['dependent']
Integrability,"al to a; * checksum - A list of checksums of the source class that can be an input for this; rule. The list has to be enclosed in a square brackets and is a; comma-separated list of integers.; * targetClass - The field is obligatory and defines the name of the in-memory class that; this rule can be applied to.; * target - A semicolon-separated list of target class data member names that this rule; is capable of calculating.; * embed - This property tells the system if the rule should be written in the output; file is some objects of this class are serialized.; * include - A list of header files that should be included in order to provide the func-; tionality used in the code snippet; the list is comma delimited.; * code - An user specified code snippet. The user can assume that in the provided code snippet the following variables; will be defined:. The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to; facilitate the rule definitions. The user can expect the following variables being predeclared:. * newObj - variable representing the target in-memory object, it’s type is that of the; target object; * oldObj - in normal conversion rules, an object of TVirtualObject class representing the; input data, guaranteed to hold the data members declared in the source property; of the rule; * buffer - in raw conversion rules, an object of TBuﬀer class holding the data member; declared in source property of the rule; * names of the data members of the target object declared in the target property of the; rule declared to be the appropriate type; * onfile.xxx - in normal conversion rules, names of the variables of basic types declared; in the source property of the rule. 3. The C++ API. The schema evolution C++ API consists of two classes: ROOT::TSchemaRuleSet and ROOT::TSchemaRule.; Objects of the TSchemaRule class represent the rules and their fields hav",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/DataModelEvolution.txt:4904,wrap,wrapping,4904,io/doc/DataModelEvolution.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/DataModelEvolution.txt,1,['wrap'],['wrapping']
Integrability,"al to a; * checksum; - A list of checksums of the source class that can be an input for this; rule. The list has to be enclosed in a square brackets and is a; comma-separated list of integers.; * targetClass; - The field is obligatory and defines the name of the in-memory class that; this rule can be applied to.; * target; - A comma-separated list of target class data member names that this rule; is capable of calculating.; * embed; - This property tells the system if the rule should be written in the output; file is some objects of this class are serialized.; * include; - A list of header files that should be included in order to provide the; functionality used in the code snippet; the list is comma delimited.; * code; - An user specified code snippet. The user can assume that in the provided code snippet the following variables; will be defined:. The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to; facilitate the rule definitions. The user can expect the following variables being predeclared:. * newObj; - variable representing the target in-memory object, its type is that of the; target object; * oldObj; - in normal conversion rules, an object of TVirtualObject class representing the; input data, guaranteed to hold the data members declared in the source property; of the rule; * buffer; - in raw conversion rules, an object of TBuffer class holding the data member; declared in source property of the rule; * names of the data members of the target object declared in the target property of the; rule declared to be the appropriate type; * onfile.xxx; - in normal conversion rules, names of the variables of basic types declared; in the source property of the rule. #### The C++ API. The schema evolution C++ API consists of two classes: `ROOT::TSchemaRuleSet` and; `ROOT::TSchemaRule`. Objects of the TSchemaRule class represent the rules and their ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:81491,wrap,wrapping,81491,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['wrap'],['wrapping']
Integrability,"al; compilation. It supports interactive programming for C++ in a; read-evaluate-print-loop (REPL) style. It uses Clang as a library to compile the; high level programming language into LLVM IR. Then the LLVM IR is executed by; the LLVM just-in-time (JIT) infrastructure. Clang-Repl is suitable for exploratory programming and in places where time; to insight is important. Clang-Repl is a project inspired by the work in; `Cling <https://github.com/root-project/cling>`_, a LLVM-based C/C++ interpreter; developed by the field of high energy physics and used by the scientific data; analysis framework `ROOT <https://root.cern/>`_. Clang-Repl allows to move parts; of Cling upstream, making them useful and available to a broader audience. Clang-Repl Basic Data Flow; ==========================. .. image:: ClangRepl_design.png; :align: center; :alt: ClangRepl design. Clang-Repl data flow can be divided into roughly 8 phases:. 1. Clang-Repl controls the input infrastructure by an interactive prompt or by; an interface allowing the incremental processing of input. 2. Then it sends the input to the underlying incremental facilities in Clang; infrastructure. 3. Clang compiles the input into an AST representation. 4. When required the AST can be further transformed in order to attach specific; behavior. 5. The AST representation is then lowered to LLVM IR. 6. The LLVM IR is the input format for LLVM’s JIT compilation infrastructure.; The tool will instruct the JIT to run specified functions, translating them; into machine code targeting the underlying device architecture (eg. Intel; x86 or NVPTX). 7. The LLVM JIT lowers the LLVM IR to machine code. 8. The machine code is then executed. Build Instructions:; ===================. .. code-block:: console. $ cd llvm-project; $ mkdir build; $ cd build; $ cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DLLVM_ENABLE_PROJECTS=clang -G ""Unix Makefiles"" ../llvm. **Note here**, above RelWithDebInfo - Debug / Release. .. code-block:: console. cmake -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:1125,interface,interface,1125,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['interface'],['interface']
Integrability,"al_locks`, below. .. _limitations:. Known Limitations; =================. Lexical scope; -------------. Thread safety attributes contain ordinary C++ expressions, and thus follow; ordinary C++ scoping rules. In particular, this means that mutexes and other; capabilities must be declared before they can be used in an attribute.; Use-before-declaration is okay within a single class, because attributes are; parsed at the same time as method bodies. (C++ delays parsing of method bodies; until the end of the class.) However, use-before-declaration is not allowed; between classes, as illustrated below. .. code-block:: c++. class Foo;. class Bar {; void bar(Foo* f) REQUIRES(f->mu); // Error: mu undeclared.; };. class Foo {; Mutex mu;; };. Private Mutexes; ---------------. Good software engineering practice dictates that mutexes should be private; members, because the locking mechanism used by a thread-safe class is part of; its internal implementation. However, private mutexes can sometimes leak into; the public interface of a class.; Thread safety attributes follow normal C++ access restrictions, so if ``mu``; is a private member of ``c``, then it is an error to write ``c.mu`` in an; attribute. One workaround is to (ab)use the ``RETURN_CAPABILITY`` attribute to provide a; public *name* for a private mutex, without actually exposing the underlying; mutex. For example:. .. code-block:: c++. class MyClass {; private:; Mutex mu;. public:; // For thread safety analysis only. Does not need to be defined.; Mutex* getMu() RETURN_CAPABILITY(mu);. void doSomething() REQUIRES(mu);; };. void doSomethingTwice(MyClass& c) REQUIRES(c.getMu()) {; // The analysis thinks that c.getMu() == c.mu; c.doSomething();; c.doSomething();; }. In the above example, ``doSomethingTwice()`` is an external routine that; requires ``c.mu`` to be locked, which cannot be declared directly because ``mu``; is private. This pattern is discouraged because it; violates encapsulation, but it is sometimes necessary,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:20150,interface,interface,20150,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['interface'],['interface']
Integrability,"alculated), 1 (approximated), 2 (matrix was made pos def) , 3 (accurate); ; bool Hesse(): to perform a full calculation of the Hessian matrix; . TMath. Fix a numerical problem in TMath::ErfcInverse for small input values. Now the normal quantile function is used for implementing it.; . MathMore. Fix 2 bugs in the quartic equation solver (see issue #49031).; ; A protection has been added against numerical errors which could cause NaN due to wrong inputs to an acos function. This problem appears also in the GSL cubic solver. A new GSL patched cubic function has been then added in MathMore.; ; A wrong statement (coming from the original CERNLIB code but not applicable in this case) has been removed.; . Add support for limited and fixed variables for all the GSL minimizers (""GSLMultiMin""), including the simulated annealing (""GSLSimAn"") and the non-linear least square fit methods (""GSLMultiFit"").; . SMatrix. Remove an unneeded check on the element value in the factorization routines used for inverting the matrices (both for the LU and for the Bunch-Kaufmann factorization). The check was preventing to inverting matrices when some of the matrix elements (like the diagonal) were smaller than an epsilon value set to ~ 10-15. This is not needed since it is enough to check that the values are not zero (i.e. when the matrix is singular). This bug was causing several failures in the CMS code when inverting matrices.; ; Add the Cholesky decomposition method for symmetric positive defined matrices (thanks to Manuel Schiller). A class has been introduced,; ROOT::Math::CholeskyDecomp which provaids methods for decomposing or inverting a matrix and also for solving a linear system.; . New methods have also been added in SMatrix: bool SMatrix::InvertChol() and SMatrix & SMatrix::InverseChol(ifail) for the inversion of a symmetric positive defined matrix. New specialized implementation exists up to matrices with sizes 6x6. The speed is comparable to the Cramer method (SMatrix::InvertFa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html:3311,rout,routines,3311,math/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v524/index.html,1,['rout'],['routines']
Integrability,"algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; ```. The interface to set the function and to minimize is the same as in the case of the `BrentMinimizer1D`. #### Using the TF1 class. It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, `TF1` of the *Hist* library.; The minmization is implemented in `TF1` using the BrentMInimizer1D and available with the class member functions; * `TF1::GetMinimum`/`TF1::GetMaximum` to find the function minimum/maximum value; * `TF1::GetMinimumX`/`TF1::GetMaximumX` to find the x value corresponding at the function minimum. The interval to search for the minimum (the default is the `TF1` range), tolerance and maximum iterations can be provided as optional parameters of the; `TF1::GetMinimum/Maximum` functions. ### Multi-Dimensional Minimization. All the algorithms for multi-dimensional minimization are implementing the `ROOT::Math::Minimizer`; interface and they can be used in the same way and one can switch between minimizer at run-time.; The minimizer concrete class can be in different ROOT libraries and they can be instantiate using the ROOT; plug-in manager.; More information on multi-dimensional minimization is provided in the Fitting Histogram chapter. ## ROOT Finder Algorithms. The function must be given to the class implementing the algorithm as a; `ROOT::Math::IBaseFunctionOneDim` object.; Some of the algorithm requires the derivatives of the function.; In that case a `ROOT::Math::IGradientFunctionOneDim` object must be provided. ## Generic Vectors for 2, 3 and 4 Dimensions (GenVector). `GenVector` is a package intended to represent vectors and their; operations and transformations, such as rotations and Lorentz; transformations, in 3 and 4 dimensions. The 3D space is used to describe; the geometry vectors and points, while the 4D space-time is used for; physics vectors representing relativistic particles. These 3",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:66611,interface,interface,66611,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interface']
Integrability,"alias mechanism that; meets the needs of your instruction, because it will allow a more concise; description. Mnemonic Aliases; ^^^^^^^^^^^^^^^^. The first phase of alias processing is simple instruction mnemonic remapping for; classes of instructions which are allowed with two different mnemonics. This; phase is a simple and unconditionally remapping from one input mnemonic to one; output mnemonic. It isn't possible for this form of alias to look at the; operands at all, so the remapping must apply for all forms of a given mnemonic.; Mnemonic aliases are defined simply, for example X86 has:. ::. def : MnemonicAlias<""cbw"", ""cbtw"">;; def : MnemonicAlias<""smovq"", ""movsq"">;; def : MnemonicAlias<""fldcww"", ""fldcw"">;; def : MnemonicAlias<""fucompi"", ""fucomip"">;; def : MnemonicAlias<""ud2a"", ""ud2"">;. ... and many others. With a MnemonicAlias definition, the mnemonic is remapped; simply and directly. Though MnemonicAlias's can't look at any aspect of the; instruction (such as the operands) they can depend on global modes (the same; ones supported by the matcher), through a Requires clause:. ::. def : MnemonicAlias<""pushf"", ""pushfq"">, Requires<[In64BitMode]>;; def : MnemonicAlias<""pushf"", ""pushfl"">, Requires<[In32BitMode]>;. In this example, the mnemonic gets mapped into a different one depending on; the current instruction set. Instruction Aliases; ^^^^^^^^^^^^^^^^^^^. The most general phase of alias processing occurs while matching is happening:; it provides new forms for the matcher to match along with a specific instruction; to generate. An instruction alias has two parts: the string to match and the; instruction to generate. For example:. ::. def : InstAlias<""movsx $src, $dst"", (MOVSX16rr8W GR16:$dst, GR8 :$src)>;; def : InstAlias<""movsx $src, $dst"", (MOVSX16rm8W GR16:$dst, i8mem:$src)>;; def : InstAlias<""movsx $src, $dst"", (MOVSX32rr8 GR32:$dst, GR8 :$src)>;; def : InstAlias<""movsx $src, $dst"", (MOVSX32rr16 GR32:$dst, GR16 :$src)>;; def : InstAlias<""movsx $src, $dst"", (M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:83008,depend,depend,83008,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['depend'],['depend']
Integrability,alized static data member; Unknown. 885; NAD; Partial ordering of function templates with unordered parameter pairs; Unknown. 886; CD2; Member initializers and aggregates; Unknown. 887; CD2; Move construction of thrown object; Unknown. 888; CD2; Union member initializers; Unknown. 891; CD2; const_cast to rvalue reference from objectless rvalue; Unknown. 892; C++11; Missing requirements for constexpr constructors; Unknown. 893; NAD; Brace syntax for enumerator-definitions; Unknown. 896; CD2; Rvalue references and rvalue-reference conversion functions; Unknown. 897; open; _Pragma and extended string-literals; Not resolved. 898; C++11; Declarations in constexpr functions; Unknown. 899; CD2; Explicit conversion functions in direct class initialization; Unknown. 900; C++23; Lifetime of temporaries in range-based for; Unknown. 901; drafting; Deleted operator delete; Not resolved. 902; NAD; In-class initialization of non-constant static data members; Unknown. 903; CD3; Value-dependent integral null pointer constants; Unknown. 904; CD2; Parameter packs in lambda-captures; Unknown. 905; CD2; Explicit defaulted copy constructors and trivial copyability; Unknown. 906; CD2; Which special member functions can be defaulted?; Unknown. 908; CD2; Deleted global allocation and deallocation functions; Unknown. 909; NAD; Old-style casts with conversion functions; Unknown. 910; CD2; Move constructors and implicitly-declared copy constructors; Unknown. 912; CD3; Character literals and universal-character-names; Unknown. 913; CD2; Deduction rules for array- and function-type conversion functions; Unknown. 914; open; Value-initialization of array types; Not resolved. 915; CD2; Deleted specializations of member function templates; Unknown. 919; CD2; Contradictions regarding inline namespaces; Unknown. 920; CD2; Interaction of inline namespaces and using-declarations; Unknown. 921; CD2; Unclear specification of inline namespaces; Unknown. 922; CD2; Implicit default constructor definitions an,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:59543,depend,dependent,59543,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"all <i_call>`; may use the following flags to enable otherwise unsafe; floating-point transformations. ``nnan``; No NaNs - Allow optimizations to assume the arguments and result are not; NaN. If an argument is a nan, or the result would be a nan, it produces; a :ref:`poison value <poisonvalues>` instead. ``ninf``; No Infs - Allow optimizations to assume the arguments and result are not; +/-Inf. If an argument is +/-Inf, or the result would be +/-Inf, it; produces a :ref:`poison value <poisonvalues>` instead. ``nsz``; No Signed Zeros - Allow optimizations to treat the sign of a zero; argument or zero result as insignificant. This does not imply that -0.0; is poison and/or guaranteed to not exist in the operation. ``arcp``; Allow Reciprocal - Allow optimizations to use the reciprocal of an; argument rather than perform division. ``contract``; Allow floating-point contraction (e.g. fusing a multiply followed by an; addition into a fused multiply-and-add). This does not enable reassociating; to form arbitrary contractions. For example, ``(a*b) + (c*d) + e`` can not; be transformed into ``(a*b) + ((c*d) + e)`` to create two fma operations. .. _fastmath_afn:. ``afn``; Approximate functions - Allow substitution of approximate calculations for; functions (sin, log, sqrt, etc). See floating-point intrinsic definitions; for places where this can apply to LLVM's intrinsic math functions. ``reassoc``; Allow reassociation transformations for floating-point instructions.; This may dramatically change results in floating-point. ``fast``; This flag implies all of the others. .. _uselistorder:. Use-list Order Directives; -------------------------. Use-list directives encode the in-memory order of each use-list, allowing the; order to be recreated. ``<order-indexes>`` is a comma-separated list of; indexes that are assigned to the referenced value's uses. The referenced; value's use-list is immediately sorted by these indexes. Use-list directives may appear at function scope or global",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:162740,contract,contractions,162740,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['contract'],['contractions']
Integrability,"all analysis paths.; There are more debug checkers available. To see all available debug checkers:. $ clang -cc1 -analyzer-checker-help | grep ""debug"". Debug Prints and Tricks; To view ""half-baked"" ExplodedGraph while debugging, jump to a frame; that has clang::ento::ExprEngine object and execute:. (gdb) p ViewGraph(0). To see the ProgramState while debugging use the following command. (gdb) p State->dump(). To see clang::Expr while debugging use the following command. If you; pass in a SourceManager object, it will also dump the corresponding line in the; source code. (gdb) p E->dump(). To dump AST of a method that the current ExplodedNode belongs; to:. (gdb) p C.getPredecessor()->getCodeDecl().getBody()->dump(). Making Your Checker Better. User facing documentation is important for adoption! Make sure the checker list is updated; at the homepage of the analyzer. Also ensure the description is clear to; non-analyzer-developers in Checkers.td.; Warning and note messages should be clear and easy to understand, even if a bit long. Messages should start with a capital letter (unlike Clang warnings!) and should not; end with ..; Articles are usually omitted, eg. Dereference of a null pointer ->; Dereference of null pointer.; Introduce BugReporterVisitors to emit additional notes that explain the warning; to the user better. There are some existing visitors that might be useful for your check,; e.g. trackNullOrUndefValue. For example, SimpleStreamChecker should highlight; the event of opening the file when reporting a file descriptor leak. If the check tracks anything in the program state, it needs to implement the; checkDeadSymbolscallback to clean the state up.; The check should conservatively assume that the program is correct when a tracked symbol; is passed to a function that is unknown to the analyzer.; checkPointerEscape callback could help you handle that case.; Use safe and convenient APIs!. Always use CheckerContext::generateErrorNode and; CheckerContext::genera",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:23134,message,messages,23134,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['message'],['messages']
Integrability,"all our plugin:; OLL->addPlugin(std::make_unique<MyPlugin>());. return OLL;; }); .create());. // Add an object to the JIT. Nothing happens here: linking isn't triggered; // until we look up some symbol in our object.; ExitOnErr(J->addObject(loadFromDisk(""main.o"")));. // Plugin triggers here when our lookup of main triggers linking of main.o; auto MainSym = J->lookup(""main"");. LinkGraph; =========. JITLink maps all relocatable object formats to a generic ``LinkGraph`` type; that is designed to make linking fast and easy (``LinkGraph`` instances can; also be created manually. See :ref:`constructing_linkgraphs`). Relocatable object formats (e.g. COFF, ELF, MachO) differ in their details,; but share a common goal: to represent machine level code and data with; annotations that allow them to be relocated in a virtual address space. To; this end they usually contain names (symbols) for content defined inside the; file or externally, chunks of content that must be moved as a unit (sections; or subsections, depending on the format), and annotations describing how to; patch content based on the final address of some target symbol/section; (relocations). At a high level, the ``LinkGraph`` type represents these concepts as a decorated; graph. Nodes in the graph represent symbols and content, and edges represent; relocations. Each of the elements of the graph is listed here:. * ``Addressable`` -- A node in the link graph that can be assigned an address; in the executor process's virtual address space. Absolute and external symbols are represented using plain ``Addressable``; instances. Content defined inside the object file is represented using the; ``Block`` subclass. * ``Block`` -- An ``Addressable`` node that has ``Content`` (or is marked as; zero-filled), a parent ``Section``, a ``Size``, an ``Alignment`` (and an; ``AlignmentOffset``), and a list of ``Edge`` instances. Blocks provide a container for binary content which must remain contiguous in; the target address space (a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:7214,depend,depending,7214,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['depend'],['depending']
Integrability,"all projects. .. _build_single_project:. Building a single sub-project; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Even though there is a single source tree, you are not required to build; all sub-projects together. It is trivial to configure builds for a single; sub-project. For example::. mkdir build && cd build; # Configure only LLVM (default); cmake path/to/monorepo; # Configure LLVM and lld; cmake path/to/monorepo -DLLVM_ENABLE_PROJECTS=lld; # Configure LLVM and clang; cmake path/to/monorepo -DLLVM_ENABLE_PROJECTS=clang. .. _git-svn-mirror:. Outstanding Questions; ---------------------. Read-only sub-project mirrors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. With the Monorepo, it is undecided whether the existing single-subproject; mirrors (e.g. https://git.llvm.org/git/compiler-rt.git) will continue to; be maintained. Read/write SVN bridge; ^^^^^^^^^^^^^^^^^^^^^. GitHub supports a read/write SVN bridge for its repositories. However,; there have been issues with this bridge working correctly in the past,; so it's not clear if this is something that will be supported going forward. Monorepo Drawbacks; ------------------. * Using the monolithic repository may add overhead for those contributing to a; standalone sub-project, particularly on runtimes like libcxx and compiler-rt; that don't rely on LLVM; currently, a fresh clone of libcxx is only 15MB (vs.; 1GB for the monorepo), and the commit rate of LLVM may cause more frequent; `git push` collisions when upstreaming. Affected contributors may be able to; use the SVN bridge or the single-subproject Git mirrors. However, it's; undecided if these projects will continue to be maintained.; * Using the monolithic repository may add overhead for those *integrating* a; standalone sub-project, even if they aren't contributing to it, due to the; same disk space concern as the point above. The availability of the; sub-project Git mirrors would addresses this.; * Preservation of the existing read/write SVN-based workflows relies on the; GitHub SV",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:10909,bridg,bridge,10909,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['bridg'],['bridge']
Integrability,"allows an intrinsic; function which accepts multiple arguments, but needs all of them to be; of the same type, to only be overloaded with respect to a single; argument or the result. Overloaded intrinsics will have the names of its overloaded argument; types encoded into its function name, each preceded by a period. Only; those types which are overloaded result in a name suffix. Arguments; whose type is matched against another type do not. For example, the; ``llvm.ctpop`` function can take an integer of any width and returns an; integer of exactly the same integer width. This leads to a family of; functions such as ``i8 @llvm.ctpop.i8(i8 %val)`` and; ``i29 @llvm.ctpop.i29(i29 %val)``. Only one type, the return type, is; overloaded, and only one type suffix is required. Because the argument's; type is matched against the return type, it does not require its own; name suffix. :ref:`Unnamed types <t_opaque>` are encoded as ``s_s``. Overloaded intrinsics; that depend on an unnamed type in one of its overloaded argument types get an; additional ``.<number>`` suffix. This allows differentiating intrinsics with; different unnamed types as arguments. (For example:; ``llvm.ssa.copy.p0s_s.2(%42*)``) The number is tracked in the LLVM module and; it ensures unique names in the module. While linking together two modules, it is; still possible to get a name clash. In that case one of the names will be; changed by getting a new number. For target developers who are defining intrinsics for back-end code; generation, any intrinsic overloads based solely the distinction between; integer or floating point types should not be relied upon for correct; code generation. In such cases, the recommended approach for target; maintainers when defining intrinsics is to create separate integer and; FP intrinsics rather than rely on overloading. For example, if different; codegen is required for ``llvm.target.foo(<4 x i32>)`` and; ``llvm.target.foo(<4 x float>)`` then these should be split into; d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:490387,depend,depend,490387,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depend']
Integrability,"ally, if RWX pages are not permitted but dual-virtual-mappings of; physical memory pages are, then the memory manager can dual map physical pages; as RW- in the JITLink process and R-X in the executor process, allowing; modification from the JITLink process but not from the executor (at the cost of; extra administrative overhead for the dual mapping). Error Handling; --------------. JITLink makes extensive use of the ``llvm::Error`` type (see the error handling; section of :doc:`ProgrammersManual` for details). The link process itself, all; passes, the memory manager interface, and operations on the ``JITLinkContext``; are all permitted to fail. Link graph construction utilities (especially parsers; for object formats) are encouraged to validate input, and validate fixups; (e.g. with range checks) before application. Any error will halt the link process and notify the context of failure. In ORC,; reported failures are propagated to queries pending on definitions provided by; the failing link, and also through edges of the dependence graph to any queries; waiting on dependent symbols. .. _connection_to_orc_runtime:. Connection to the ORC Runtime; =============================. The ORC Runtime (currently under development) aims to provide runtime support; for advanced JIT features, including object format features that require; non-trivial action in the executor (e.g. running initializers, managing thread; local storage, registering with language runtimes, etc.). ORC Runtime support for object format features typically requires cooperation; between the runtime (which executes in the executor process) and JITLink (which; runs in the JIT process and can inspect LinkGraphs to determine what actions; must be taken in the executor). For example: Execution of MachO static; initializers in the ORC runtime is performed by the ``jit_dlopen`` function,; which calls back to the JIT process to ask for the list of address ranges of; ``__mod_init`` sections to walk. This list is co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:32550,depend,dependence,32550,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,2,['depend'],"['dependence', 'dependent']"
Integrability,"als; \brief Examples showing how to use TMatrix. \defgroup tutorial_mc Monte Carlo tutorials; \ingroup Tutorials; \brief Monte Carlo examples. \defgroup tutorial_multicore Multicore tutorials; \ingroup Tutorials; \brief These examples aim to illustrate the multicore features of ROOT, such as thread awareness and safety, multithreading and multiprocessing. \defgroup tutorial_net Net tutorials; \ingroup Tutorials; \brief Examples showing the net classes. \defgroup tutorial_physics Physics tutorials; \ingroup Tutorials; \brief Physics examples. \defgroup tutorial_pyroot PyRoot tutorials; \ingroup Tutorials; \brief Selected examples illustrating how to use ROOT's Python interface: PyROOT. \defgroup tutorial_pythia Pythia tutorials; \ingroup Tutorials; \brief Examples showing the pythia usage. \defgroup tutorial_quadp Quadratic programming package.; \ingroup Tutorials; \brief Example showing the usage of the quadratic programming package quadp. \defgroup tutorial_r R tutorials; \ingroup Tutorials; \brief Examples showing the R interface. \defgroup tutorial_roostats RooStats Tutorials; \ingroup Tutorials; \brief These tutorials illustrate the main features of RooStats. \defgroup tutorial_spectrum Spectrum tutorials; \ingroup Tutorials; \brief Examples showing the TSpectrum and TSpectrumPainter usage. \defgroup tutorial_splot TSPlot tutorials; \ingroup Tutorials; \brief This tutorial illustrates the use of class TSPlot. \defgroup tutorial_sql SQL tutorials; \ingroup Tutorials; \brief Examples showing the SQL classes. \defgroup tutorial_tmva TMVA tutorials; \ingroup Tutorials; \brief Example code which illustrates how to use the TMVA toolkit. \defgroup tutorial_unfold TUnfold tutorials; \ingroup Tutorials; \brief Test programs for the classes TUnfold and related. \defgroup tutorial_unuran Unuran tutorials; \ingroup Tutorials; \brief Examples showing unuran capabilities. \defgroup tutorial_vecops VecOps tutorials; \ingroup Tutorials; \brief These examples show the functionali",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/index.md:4976,interface,interface,4976,tutorials/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/index.md,1,['interface'],['interface']
Integrability,"alse − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). Gamma No 1 − RBF kernel parameter: Gamma (size of the Kernel). C No 1 − Cost parameter. Tol No 0.01 − Tolerance parameter. MaxIter No 1000 − Maximum number of training loops. Configuration options for MVA method :. Configuration options reference for MVA method: CFMlpANN. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). NCycles No 3000 − Number of training cycles. HiddenLayers No N,N-1 − Specification of hidden layer architecture. Configuration options for MVA method :. Configuration options reference for MVA method: KNN. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:9054,message,message,9054,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['message'],['message']
Integrability,"also provided by MathCore.; together with the core classes needed to fit any generic data set. - \ref MathMore ""MathMore"": a package incorporating advanced numerical functionality and dependent on external libraries like the GNU Scientific Library ([GSL](http://www.gnu.org/software/gsl/)). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL. - **Minimization and Fitting Libraries**; Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional; function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in %ROOT is; organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:. - \ref MinuitOld ""Minuit"": library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits.; - \ref Minuit2Page ""Minuit2"": new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions.; - **Fumili**: library providing the implementation of the original Fumili fitting algorithm (class TFumili). - **Linear algebra**. Two libraries are contained in %ROOT for describing linear algebra mat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/index.md:1636,interface,interface,1636,math/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/index.md,1,['interface'],['interface']
Integrability,"alues. During symbolic execution, SVal; objects are used to represent the semantic evaluation of expressions.; They can represent things like concrete; integers, symbolic values, or memory locations (which are memory regions).; They are a discriminated union of ""values"", symbolic and otherwise.; If a value isn't symbolic, usually that means there is no symbolic; information to track. For example, if the value was an integer, such as; 42, it would be a ConcreteInt,; and the checker doesn't usually need to track any state with the concrete; number. In some cases, SVal is not a symbol, but it really should be; a symbolic value. This happens when the analyzer cannot reason about something; (yet). An example is floating point numbers. In such cases, the; SVal will evaluate to UnknownVal.; This represents a case that is outside the realm of the analyzer's reasoning; capabilities. SVals are value objects and their values can be viewed; using the .dump() method. Often they wrap persistent objects such as; symbols or regions.; . SymExpr (symbol); is meant to represent abstract, but named, symbolic value. Symbols represent; an actual (immutable) value. We might not know what its specific value is, but; we can associate constraints with that value as we analyze a path. For; example, we might record that the value of a symbol is greater than; 0, etc.; . MemRegion is similar to a symbol.; It is used to provide a lexicon of how to describe abstract memory. Regions can; layer on top of other regions, providing a layered approach to representing memory.; For example, a struct object on the stack might be represented by a VarRegion,; but a FieldRegion which is a subregion of the VarRegion could; be used to represent the memory associated with a specific field of that object.; So how do we represent symbolic memory regions? That's what; SymbolicRegion; is for. It is a MemRegion that has an associated symbol. Since the; symbol is unique and has a unique name; that symbol names the reg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:4675,wrap,wrap,4675,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['wrap'],['wrap']
Integrability,"always get it right the first time, but we fix any problems; when we realize we made a mistake. Integration with IDEs. We believe that Integrated Development Environments (IDE's) are a great way; to pull together various pieces of the development puzzle, and aim to make clang; work well in such an environment. The chief advantage of an IDE is that they; typically have visibility across your entire project and are long-lived; processes, whereas stand-alone compiler tools are typically invoked on each; individual file in the project, and thus have limited scope.; There are many implications of this difference, but a significant one has to; do with efficiency and caching: sharing an address space across different files; in a project, means that you can use intelligent caching and other techniques to; dramatically reduce analysis/compilation time.; A further difference between IDEs and batch compiler is that they often; impose very different requirements on the front-end: they depend on high; performance in order to provide a ""snappy"" experience, and thus really want; techniques like ""incremental compilation"", ""fuzzy parsing"", etc. Finally, IDEs; often have very different requirements than code generation, often requiring; information that a codegen-only frontend can throw away. Clang is; specifically designed and built to capture this information. Use the LLVM 'Apache 2' License. We actively intend for clang (and LLVM as a whole) to be used for; commercial projects, not only as a stand-alone compiler but also as a library; embedded inside a proprietary application. We feel that the license encourages; contributors to pick up the source and work with it, and believe that those; individuals and organizations will contribute back their work if they do not; want to have to maintain a fork forever (which is time consuming and expensive; when merges are involved). Further, nobody makes money on compilers these days,; but many people need them to get bigger goals accomplished",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:10010,depend,depend,10010,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['depend'],['depend']
Integrability,"alysis should; flag an error here with the attempt to call the destructor.; * Inspect the generated AST by printing it using ``clang -cc1 -ast-print``,; to make sure you're capturing all of the important information about how; the AST was written.; * Inspect the generated AST under ``clang -cc1 -ast-dump`` to verify that; all of the types in the generated AST line up the way you want them.; Remember that clients of the AST should never have to ""think"" to; understand what's going on. For example, all implicit conversions should; show up explicitly in the AST.; * Write tests that use your expression as a subexpression of other,; well-known expressions. Can you call a function using your expression as; an argument? Can you use the ternary operator?. #. Teach code generation to create IR to your AST node. This step is the first; (and only) that requires knowledge of LLVM IR. There are several things to; keep in mind:. * Code generation is separated into scalar/aggregate/complex and; lvalue/rvalue paths, depending on what kind of result your expression; produces. On occasion, this requires some careful factoring of code to; avoid duplication.; * ``CodeGenFunction`` contains functions ``ConvertType`` and; ``ConvertTypeForMem`` that convert Clang's types (``clang::Type*`` or; ``clang::QualType``) to LLVM types. Use the former for values, and the; latter for memory locations: test with the C++ ""``bool``"" type to check; this. If you find that you are having to use LLVM bitcasts to make the; subexpressions of your expression have the type that your expression; expects, STOP! Go fix semantic analysis and the AST so that you don't; need these bitcasts.; * The ``CodeGenFunction`` class has a number of helper functions to make; certain operations easy, such as generating code to produce an lvalue or; an rvalue, or to initialize a memory location with a given value. Prefer; to use these functions rather than directly writing loads and stores,; because these functions take care of s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:150837,depend,depending,150837,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['depending']
Integrability,"alysis`` command line option enables the analysis of; performance bottlenecks. This analysis is potentially expensive. It attempts to correlate increases in; backend pressure (caused by pipeline resource pressure and data dependencies) to; dynamic dispatch stalls. Below is an example of ``-bottleneck-analysis`` output generated by; :program:`llvm-mca` for 500 iterations of the dot-product example on btver2. .. code-block:: none. Cycles with backend pressure increase [ 48.07% ]; Throughput Bottlenecks:; Resource Pressure [ 47.77% ]; - JFPA [ 47.77% ]; - JFPU0 [ 47.77% ]; Data Dependencies: [ 0.30% ]; - Register Dependencies [ 0.30% ]; - Memory Dependencies [ 0.00% ]. Critical sequence based on the simulation:. Instruction Dependency Information; +----< 2. vhaddps %xmm3, %xmm3, %xmm4; |; | < loop carried >; |; | 0. vmulps %xmm0, %xmm1, %xmm2; +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 74% ]; +----> 2. vhaddps %xmm3, %xmm3, %xmm4 ## REGISTER dependency: %xmm3; |; | < loop carried >; |; +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 74% ]. According to the analysis, throughput is limited by resource pressure and not by; data dependencies. The analysis observed increases in backend pressure during; 48.07% of the simulated run. Almost all those pressure increase events were; caused by contention on processor resources JFPA/JFPU0. The `critical sequence` is the most expensive sequence of instructions according; to the simulation. It is annotated to provide extra information about critical; register dependencies and resource interferences between instructions. Instructions from the critical sequence are expected to significantly impact; performance. By construction, the accuracy of this analysis is strongly; dependent on the simulation and (as always) by the quality of the processor; model in llvm. Bottleneck analysis is currently not supported for processors with an in-order; backend. Extra Statis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:27546,depend,dependency,27546,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['dependency']
Integrability,"ame functionality as the base function plus the calculation of the derivative.; It only adds the `double Derivative(double* x, uint ivar)` method for the user to implement. This method must implement the derivative of the function with respect to the variable indicated with the; second parameter. Example of implementing a multi-dimensional gradient function. ```{.cpp}; #include ""Math/IFunction.h"". class MyGradientFunction: public ROOT::Math::IGradientFunctionMultiDim; {; public:; double DoEval(const double* x) const; {; return x[0] + sin(x[1]);; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IGradientFunctionMultiDim* Clone() const; {; return new MyGradientFunction();; }. double DoDerivative(const double* x, unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]);; else; return x[0] + x[1] * cos(x[1]);; }. };; ```. ### Parametric Function Interfaces. These interfaces, for evaluating multi-dimensional functions are used for fitting. These interfaces are defined in the header file; `Math/IParamFunction.h`.; See also the documentation of the `ROOT::Fit` classes in the Fitting chapter for more information. * **`ROOT::Math::IParametricFunctionMultiDim`**: Describes a multi dimensional parametric function. Similarly to the one dimensional version, the user needs to provide the; method `void SetParameters(double* p)` as well as the getter methods `const double * Parameters()` and `uint NPar()`.; Example of creating a parametric function:. ```{.cpp}; #include ""Math/IFunction.h""; #include ""Math/IParamFunction.h"". class MyParametricFunction: public ROOT::Math::IParametricFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricFunctionMultiDim* Clone() const; {; return new MyParametricFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:39648,interface,interfaces,39648,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interfaces']
Integrability,"ame, source file name, or; library name in the symbolized stack trace of the leak report. See; `full documentation; <https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer#suppressions>`_; for more details. Code generation control; =======================. Instrumentation code outlining; ------------------------------. By default AddressSanitizer inlines the instrumentation code to improve the; run-time performance, which leads to increased binary size. Using the; (clang flag ``-fsanitize-address-outline-instrumentation` default: ``false``); flag forces all code instrumentation to be outlined, which reduces the size; of the generated code, but also reduces the run-time performance. Limitations; ===========. * AddressSanitizer uses more real memory than a native run. Exact overhead; depends on the allocations sizes. The smaller the allocations you make the; bigger the overhead is.; * AddressSanitizer uses more stack memory. We have seen up to 3x increase.; * On 64-bit platforms AddressSanitizer maps (but not reserves) 16+ Terabytes of; virtual address space. This means that tools like ``ulimit`` may not work as; usually expected.; * Static linking of executables is not supported. Supported Platforms; ===================. AddressSanitizer is supported on:. * Linux i386/x86\_64 (tested on Ubuntu 12.04); * macOS 10.7 - 10.11 (i386/x86\_64); * iOS Simulator; * Android ARM; * NetBSD i386/x86\_64; * FreeBSD i386/x86\_64 (tested on FreeBSD 11-current); * Windows 8.1+ (i386/x86\_64). Ports to various other platforms are in progress. Current Status; ==============. AddressSanitizer is fully functional on supported platforms starting from LLVM; 3.1. The test suite is integrated into CMake build and can be run with ``make; check-asan`` command. The Windows port is functional and is used by Chrome and Firefox, but it is not; as well supported as the other ports. More Information; ================. `<https://github.com/google/sanitizers/wiki/AddressSanitizer>`_; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:13195,integrat,integrated,13195,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['integrat'],['integrated']
Integrability,"amerFieldSelection.xml . COPYONLY); add_custom_command(OUTPUT StreamerFieldXMLDict.cxx StreamerFieldXMLDict_rdict.pcm; COMMAND ${command} StreamerFieldXML.h -o StreamerFieldXMLDict.cxx -s StreamerFieldSelection.xml; DEPENDS rootcling StreamerFieldXML.h StreamerFieldSelection.xml); add_library(StreamerFieldXMLDict OBJECT StreamerFieldXMLDict.cxx); set_target_properties(StreamerFieldXMLDict PROPERTIES POSITION_INDEPENDENT_CODE TRUE); target_sources(rfield_streamer PRIVATE $<TARGET_OBJECTS:StreamerFieldXMLDict>); target_compile_options(StreamerFieldXMLDict PRIVATE $<TARGET_PROPERTY:rfield_streamer,COMPILE_OPTIONS>); target_compile_definitions(StreamerFieldXMLDict PRIVATE $<TARGET_PROPERTY:rfield_streamer,COMPILE_DEFINITIONS>); target_compile_features(StreamerFieldXMLDict PRIVATE $<TARGET_PROPERTY:rfield_streamer,COMPILE_FEATURES>); target_include_directories(StreamerFieldXMLDict PRIVATE $<TARGET_PROPERTY:rfield_streamer,INCLUDE_DIRECTORIES>); if(MSVC); add_custom_command(TARGET rfield_streamer POST_BUILD; COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_BINARY_DIR}/librfield_streamer_rdict.pcm; ${CMAKE_CURRENT_BINARY_DIR}/$<CONFIG>/librfield_streamer_rdict.pcm; COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_BINARY_DIR}/StreamerFieldXMLDict_rdict.pcm; ${CMAKE_CURRENT_BINARY_DIR}/$<CONFIG>/StreamerFieldXMLDict_rdict.pcm); endif(). if(daos OR daos_mock); # Label of the DAOS pool used for testing, if not provided (may be any for libdaos_mock).; if(NOT daos_test_pool); set(daos_test_pool ntuple-daos-test-pool); endif(). ROOT_ADD_GTEST(ntuple_storage_daos ntuple_storage_daos.cxx ntuple_test.cxx LIBRARIES ROOTNTuple MathCore CustomStruct); target_compile_definitions(ntuple_storage_daos PRIVATE R__DAOS_TEST_POOL=""${daos_test_pool}""). if(daos_mock); set_property(SOURCE ntuple_storage_daos.cxx; APPEND PROPERTY COMPILE_DEFINITIONS R__DAOS_TEST_MOCK=1); endif(); endif(). # RNTuple Python interface tests; if(pyroot); ROOT_ADD_PYUNITTEST(ntuple_py_model ntuple_model.py); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CMakeLists.txt:7203,interface,interface,7203,tree/ntuple/v7/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CMakeLists.txt,1,['interface'],['interface']
Integrability,"ameter type adjustment in dependent parameter types; Not resolved. 1002; NAD; Pack expansion for function arguments; Unknown. 1003; CD3; Acceptable definitions of main; Unknown. 1004; C++11; Injected-class-names as arguments for template template parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression; Unknown. 1011; C++11; Standard conversions that cannot be inverted; Unknown. 1012; C++11; Undeprecating static; Unknown. 1013; CD3; Uninitialized std::nullptr_t objects; Unknown. 1014; NAD; Overload resolution between const T& and T&&; Unknown. 1015; C++11; Template arguments and argument-dependent lookup; Unknown. 1016; C++11; Overloadable declarations, function templates, and references; Unknown. 1017; C++11; Member access transformation in unevaluated operands; Unknown. 1018; C++11; Ambiguity between simple-declaration and attribute-declaration; Unknown. 1019; dup; Dependent simple-template-ids in base-specifiers and mem-initializers; Unknown. 1020; C++11; Implicitly-defined copy constructors and explicit base class constructors; Unknown. 1021; CD4; Definitions of namespace members; Unknown. 1022; C++11; Can an enumeration variable have values outside the values of the enumeration?; Unknown. 1023; dup; thread_local objects as non-type template arguments; Unknown. 1024; CD3; Limits on multicharacter literals; Unknown. 1025; C++11; Use of a reference as a non-type template argument; Unknown. 1026; NAD; Cv-qualified non-class rvalues; Unknown. 1027; review; Type consistency and reallocation of scalar types; Not resolved. 1028; CD6; Dependent names in non-defin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:66915,depend,dependent,66915,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"ameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly to the; ROOT package. This goal will be accomplished using concrete examples, according; to the ""learning by doing"" principle. Also because of this reason, this guide; cannot cover all the complexity of the ROOT package. Nevertheless, once you feel; confident with the concepts presented in the following chapters, you will be; able to appreciate the ROOT Users Guide [@ROOT_Users_Guide] and navigate through; the Class Reference [@ROOT_Class_Reference] to find all the details you might be; interested in. You",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:3204,interface,interface,3204,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,2,['interface'],['interface']
Integrability,"ameters:. Indirect parameters; ^^^^^^^^^^^^^^^^^^^. If a function or method parameter has type ``T*``, where ``T`` is an; ownership-unqualified retainable object pointer type, then:. * if ``T`` is ``const``-qualified or ``Class``, then it is implicitly; qualified with ``__unsafe_unretained``;; * otherwise, it is implicitly qualified with ``__autoreleasing``. .. admonition:: Rationale. ``__autoreleasing`` exists mostly for this case, the Cocoa convention for; out-parameters. Since a pointer to ``const`` is obviously not an; out-parameter, we instead use a type more useful for passing arrays. If the; user instead intends to pass in a *mutable* array, inferring; ``__autoreleasing`` is the wrong thing to do; this directs some of the; caution in the following rules about writeback. Such a type written anywhere else would be ill-formed by the general rule; requiring ownership qualifiers. This rule does not apply in Objective-C++ if a parameter's type is dependent in; a template pattern and is only *instantiated* to a type which would be a; pointer to an unqualified retainable object pointer type. Such code is still; ill-formed. .. admonition:: Rationale. The convention is very unlikely to be intentional in template code. .. _arc.ownership.inference.template.arguments:. Template arguments; ^^^^^^^^^^^^^^^^^^. If a template argument for a template type parameter is an retainable object; owner type that does not have an explicit ownership qualifier, it is adjusted; to have ``__strong`` qualification. This adjustment occurs regardless of; whether the template argument was deduced or explicitly specified. .. admonition:: Rationale. ``__strong`` is a useful default for containers (e.g., ``std::vector<id>``),; which would otherwise require explicit qualification. Moreover, unqualified; retainable object pointer types are unlikely to be useful within templates,; since they generally need to have a qualifier applied to the before being; used. .. _arc.method-families:. Method famili",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:66154,depend,dependent,66154,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['depend'],['dependent']
Integrability,"aming)); -----------------------------------------------------. If a function is marked as ``arm_locally_streaming``, then the runtime SVE; vector length in the prologue/epilogue may be different from the vector length; in the function's body. This happens because we invoke smstart after setting up; the stack-frame and similarly invoke smstop before deallocating the stack-frame. To ensure we use the correct SVE vector length to allocate the locals with, we; can use the streaming vector-length to allocate the stack-slots through the; ``ADDSVL`` instruction, even when the CPU is not yet in streaming mode. This only works for locals and not callee-save slots, since LLVM doesn't support; mixing two different scalable vector lengths in one stack frame. That means that the; case where a function is marked ``arm_locally_streaming`` and needs to spill SVE; callee-saves in the prologue is currently unsupported. However, it is unlikely; for this to happen without user intervention, because ``arm_locally_streaming``; functions cannot take or return vector-length-dependent values. This would otherwise; require forcing both the SVE PCS using '``aarch64_sve_pcs``' combined with using; ``arm_locally_streaming`` in order to encounter this problem. This combination; can be prevented in Clang through emitting a diagnostic. An example of how the prologue/epilogue would look for a function that is; attributed with ``arm_locally_streaming``:. .. code-block:: c++. #define N 64. void __attribute__((arm_streaming_compatible)) some_use(svfloat32_t *);. // Use a float argument type, to check the value isn't clobbered by smstart.; // Use a float return type to check the value isn't clobbered by smstop.; float __attribute__((noinline, arm_locally_streaming)) foo(float arg) {; // Create local for SVE vector to check local is created with correct; // size when not yet in streaming mode (ADDSVL).; float array[N];; svfloat32_t vector;. some_use(&vector);; svst1_f32(svptrue_b32(), &array[0], vector",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:12083,depend,dependent,12083,interpreter/llvm-project/llvm/docs/AArch64SME.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst,1,['depend'],['dependent']
Integrability,"aml. .. _remarkssection:. Emitting remark diagnostics in the object file; ==============================================. A section containing metadata on remark diagnostics will be emitted for the; following formats:. * ``yaml-strtab``; * ``bitstream``. This can be overridden by using the flag ``-remarks-section=<bool>``. The section is named:. * ``__LLVM,__remarks`` (MachO). C API; =====. LLVM provides a library that can be used to parse remarks through a shared; library named ``libRemarks``. The typical usage through the C API is like the following:. .. code-block:: c. LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);; LLVMRemarkEntryRef Remark = NULL;; while ((Remark = LLVMRemarkParserGetNext(Parser))) {; // use Remark; LLVMRemarkEntryDispose(Remark); // Release memory.; }; bool HasError = LLVMRemarkParserHasError(Parser);; LLVMRemarkParserDispose(Parser);. Remark streamers; ================. The ``RemarkStreamer`` interface is used to unify the serialization; capabilities of remarks across all the components that can generate remarks. All remark serialization should go through the main remark streamer, the; ``llvm::remarks::RemarkStreamer`` set up in the ``LLVMContext``. The interface; takes remark objects converted to ``llvm::remarks::Remark``, and takes care of; serializing it to the requested format, using the requested type of metadata,; etc. Typically, a specialized remark streamer will hold a reference to the one set; up in the ``LLVMContext``, and will operate on its own type of diagnostics. For example, LLVM IR passes will emit ``llvm::DiagnosticInfoOptimization*``; that get converted to ``llvm::remarks::Remark`` objects. Then, clang could set; up its own specialized remark streamer that takes ``clang::Diagnostic``; objects. This can allow various components of the frontend to emit remarks; using the same techniques as the LLVM remarks. This gives us the following advantages:. * Composition: during the compilation pipeline, multiple co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:16974,interface,interface,16974,interpreter/llvm-project/llvm/docs/Remarks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst,1,['interface'],['interface']
Integrability,"ample 2. Matches [I foo] with; objcMessageExpr(callee(objcMethodDecl(hasName(""foo"")))). @interface I: NSObject; +(void)foo;; @end; ...; [I foo]. Matcher<ObjCMessageExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<ObjCMessageExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<ObjCMessageExpr>hasReceiverMatcher<Expr> InnerMatcher; Matches if the Objective-C message is sent to an instance,; and the inner matcher matches on that instance. For example the method call in; NSString *x = @""hello"";; [x containsString:@""h""];; is matched by; objcMessageExpr(hasReceiver(declRefExpr(to(varDecl(hasName(""x"")))))). Matcher<ObjCMessageExpr>hasReceiverTypeMatcher<QualType> InnerMatcher; Matches on the receiver of an ObjectiveC Message expression. Example; matcher = objCMessageExpr(hasReceiverType(asString(""UIWebView *"")));; matches the [webView ...] message invocation.; NSString *webViewJavaScript = ...; UIWebView *webView = ...; [webView stringByEvaluatingJavaScriptFromString:webViewJavascript];. Matcher<ObjCMethodDecl>hasAnyParameterMatcher<ParmVarDecl> InnerMatcher; Matches any parameter of a function or an ObjC method declaration or a; block. Does not match the 'this' parameter of a method. Given; class X { void f(int x, int y, int z) {} };; cxxMethodDecl(hasAnyParameter(hasName(""y""))); matches f(int x, int y, int z) {}; with hasAnyParameter(...",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:221506,message,message,221506,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['message'],['message']
Integrability,"ample"", ""sample"", {""Sample1"": 1, ""Sample2"": 2, ""Sample3"": 3}); ```. #### RooWorkspace accessors. In Python, you can now get objects stored in a [RooWorkspace](https://root.cern/doc/v626/classRooWorkspace.html) with the item retrieval operator, and the return value is also always downcasted to the correct type. That means in Python you don't have to use [RooWorkspace::var()](https://root.cern/doc/v626/classRooWorkspace.html#acf5f9126ee264c234721a4ed1f9bf837) to access variables or [RooWorkspace::pdf()](https://root.cern/doc/v626/classRooWorkspace.html#afa7384cece424a1a94a644bb05549eee) to access pdfs, but you can always get any object using square brackets. For example:; ```Python; # w is a RooWorkspace instance that contains the variables `x`, `y`, and `z` for which we want to generate toy data:; model.generate({w[""x""], w[""y""], w[""z""]}, 1000); ```. ### New PyROOT functions for interoperability with NumPy and Pandas. New member functions of RooFit classes were introduced exclusively to PyROOT for better interoperability between RooFit and Numpy and Pandas:. - `RooDataSet.from_numpy`: Import a RooDataSet from a dictionary of numpy arrays (static method); - `RooDataSet.to_numpy`: Export a RooDataSet to a dictionary of numpy arrays; - `RooDataSet.from_pandas`: Import a RooDataSet from a Pandas dataframe (static method); - `RooDataSet.to_pandas`: Export a RooDataSet to a Pandas dataframe; - `RooDataHist.from_numpy`: Import a RooDataHist from numpy arrays with histogram counts and bin edges (static method); - `RooDataHist.to_numpy`: Export a RooDataHist to numpy arrays with histogram counts and bin edges; - `RooRealVar.bins`: Get bin boundaries for a `RooRealVar` as a NumPy array. For more details, consult the tutorial [rf409_NumPyPandasToRooFit.py](https://root.cern/doc/v626/rf409__NumPyPandasToRooFit_8C.html). ### Modeling Effective Field Theory distributions with RooLadgrangianMorphFunc. The [**RooLagrangianMorphFunc**](https://root.cern/doc/v626/classRooLagrangianMorph",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:22765,interoperab,interoperability,22765,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['interoperab'],['interoperability']
Integrability,"ams written in languages other than C or C++ to take advantage of the LLVM; infrastructure.; LLVM project provides language bindings for OCaml and Python. ``llvm/projects``; -----------------. Projects not strictly part of LLVM but shipped with LLVM. This is also the; directory for creating your own LLVM-based projects which leverage the LLVM; build system. ``llvm/test``; -------------. Feature and regression tests and other sanity checks on LLVM infrastructure. These; are intended to run quickly and cover a lot of territory without being exhaustive. ``test-suite``; --------------. A comprehensive correctness, performance, and benchmarking test suite; for LLVM. This comes in a ``separate git repository; <https://github.com/llvm/llvm-test-suite>``, because it contains a; large amount of third-party code under a variety of licenses. For; details see the :doc:`Testing Guide <TestingGuide>` document. .. _tools:. ``llvm/tools``; --------------. Executables built out of the libraries; above, which form the main part of the user interface. You can always get help; for a tool by typing ``tool_name -help``. The following is a brief introduction; to the most important tools. More detailed information is in; the `Command Guide <CommandGuide/index.html>`_. ``bugpoint``. ``bugpoint`` is used to debug optimization passes or code generation backends; by narrowing down the given test case to the minimum number of passes and/or; instructions that still cause a problem, whether it is a crash or; miscompilation. See `<HowToSubmitABug.html>`_ for more information on using; ``bugpoint``. ``llvm-ar``. The archiver produces an archive containing the given LLVM bitcode files,; optionally with an index for faster lookup. ``llvm-as``. The assembler transforms the human readable LLVM assembly to LLVM bitcode. ``llvm-dis``. The disassembler transforms the LLVM bitcode to human readable LLVM assembly. ``llvm-link``. ``llvm-link``, not surprisingly, links multiple LLVM modules into a single; prog",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:38635,interface,interface,38635,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['interface'],['interface']
Integrability,"an 21 Bits are a Constraint Violation r0; N2828; Clang 3.6. Identifier Syntax using Unicode Standard Annex 31; N2836; Clang 15. No function declarators without prototypes; N2841; Clang 15. Remove default argument promotions for _FloatN types; N2844; No. Revised Suggestions of Change for Numerically Equal/Equivalent; N2847; Yes. 5.2.4.2.2 Cleanup, Again Again (N2806 update); N2879; Yes. char8_t: A type for UTF-8 characters and strings; N2653; No. Clarification for max exponent macros-update; N2882; Unknown. Consistent, Warningless, and Intuitive Initialization with {}. ; N2900; Clang 17. ; N3011; Clang 17. Not-so-magic: typeof. ; N2927; Clang 16. ; N2930; Clang 16. Type annex tgmath narrowing macros with integer args v2; N2931; Unknown. Revise spelling of keywords v7; N2934; Clang 17. Make false and true first-class language features v8; N2935; Clang 15. Properly define blocks as part of the grammar v3; N2937; Yes. Annex X (replacing Annex H) for IEC 60559 interchange; N2601; No. Indeterminate Values and Trap Representations; N2861; Yes. Remove ATOMIC_VAR_INIT v2; N2886; Clang 17. Require exact-width integer type interfaces v2; N2888; Yes. Wording Change for Variably-Modified Types; N2992; Yes. Identifier syntax fixes; N2939; Clang 15. Remove trigraphs??!; N2940; Clang 18. Improved normal enumerations; N3029; Unknown. Relax requirements for va_start; N2975; Clang 16. Enhanced enumerations; N3030; Unknown. Freestanding C and IEC 60559 conformance scope reduction; N2951; Unknown. Unsequenced functions; N2956; No. Comma ommission and deletion (__VA_OPT__); N3033; Unknown. Underspecified object definitions; N3006; No. Type inference for object declarations; N3007; Clang 18. constexpr for object definitions; N3018; No. Introduce storage class specifiers for compound literals; N3038; No. Identifier primary expressions; N3034; Yes. Introduce the nullptr constant; N3042; Clang 17. Memory layout of unions; N2929; Yes. Improved tag compatibility; N3037; No. #embed; N3017; No. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html:12495,interface,interfaces,12495,interpreter/llvm-project/clang/www/c_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_status.html,1,['interface'],['interfaces']
Integrability,"an algorithm is based on a paper or is described in another source,; provide a reference. Header Guard; """""""""""""""""""""""". The header file's guard should be the all-caps path that a user of this header; would #include, using '_' instead of path separator and extension marker.; For example, the header file; ``llvm/include/llvm/Analysis/Utils/Local.h`` would be ``#include``-ed as; ``#include ""llvm/Analysis/Utils/Local.h""``, so its guard is; ``LLVM_ANALYSIS_UTILS_LOCAL_H``. Class overviews; """""""""""""""""""""""""""""". Classes are a fundamental part of an object-oriented design. As such, a; class definition should have a comment block that explains what the class is; used for and how it works. Every non-trivial class is expected to have a; ``doxygen`` comment block. Method information; """""""""""""""""""""""""""""""""""". Methods and global functions should also be documented. A quick note about; what it does and a description of the edge cases is all that is necessary here.; The reader should be able to understand how to use interfaces without reading; the code itself. Good things to talk about here are what happens when something unexpected; happens, for instance, does the method return null?. Comment Formatting; ^^^^^^^^^^^^^^^^^^. In general, prefer C++-style comments (``//`` for normal comments, ``///`` for; ``doxygen`` documentation comments). There are a few cases when it is; useful to use C-style (``/* */``) comments however:. #. When writing C code to be compatible with C89. #. When writing a header file that may be ``#include``\d by a C source file. #. When writing a source file that is used by a tool that only accepts C-style; comments. #. When documenting the significance of constants used as actual parameters in; a call. This is most helpful for ``bool`` parameters, or passing ``0`` or; ``nullptr``. The comment should contain the parameter name, which ought to be; meaningful. For example, it's not clear what the parameter means in this call:. .. code-block:: c++. Object.emitName(nullptr);. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:9859,interface,interfaces,9859,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['interface'],['interfaces']
Integrability,"an_veto math/testrandom.C unuran/unuranDemo.C unuran/unuranFoamTest.C; math/multidimSampling.C); endif(). if(NOT ROOT_xml_FOUND); set(xml_veto xml/*.C; histfactory/*.C # histfactory requires xml; histfactory/*.py; roostats/*.C # most roostats tutorials require xml too,; roostats/*.py) # because they create test data with histfactory; endif(). if(NOT ROOT_unfold_FOUND); list(APPEND xml_veto unfold/*.C); endif(). if(NOT ROOT_mpi_FOUND); set(mpi_veto io/testTMPIFile.C); endif(). if(NOT xrootd); set(xrootd_veto dataframe/df101_h1Analysis.C; dataframe/df102_NanoAODDimuonAnalysis.C; dataframe/df103_NanoAODHiggsAnalysis.C; dataframe/df106_HiggsToFourLeptons.C; tmva/tmva103_Application.C; dataframe/df033_Describe.py; dataframe/df102_NanoAODDimuonAnalysis.py; dataframe/df103_NanoAODHiggsAnalysis.py; dataframe/df104_HiggsToTwoPhotons.py; dataframe/df105_WBosonAnalysis.py; dataframe/df106_HiggsToFourLeptons.py; dataframe/df107_SingleTopAnalysis.py; roofit/rf618_mixture_models.py # depends on df106_HiggsToFourLeptons.py; rcanvas/df104.py; rcanvas/df105.py; ); endif(). # variables identifying the package must have the package name in lower case (it corresponds to the CMake option name); if(NOT ROOT_r_FOUND); set(r_veto r/*.C); endif(). set(histfactory_veto histfactory/makeExample.C). if(NOT ROOT_fitsio_FOUND); set(fitsio_veto fitsio/*.C); endif(). if(NOT ROOT_mathmore_FOUND); set(mathmore_veto; math/quasirandom.C; math/exampleMultiRoot.C; math/Bessel.C; math/LegendreAssoc.C; math/Legendre.C; math/mathmoreIntegration.C; math/multivarGaus.C; math/tStudent.C; math/normalDist.C; roostats/TestNonCentral.C; roostats/TestNonCentral.py; math/Legendre.py; math/Bessel.py; math/tStudent.py); endif(). if(NOT ROOT_fftw3_FOUND); set(fftw3_veto roofit/rf208_convolution.C; roofit/rf210_angularconv.C; roofit/rf211_paramconv.C; roofit/rf512_wsfactory_oper.C; roofit/rf208_convolution.py; roofit/rf210_angularconv.py; roofit/rf211_paramconv.py; roofit/rf512_wsfactory_oper.py; fft/FFT.C; fit/fitConvol",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:7500,depend,depends,7500,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['depend'],['depends']
Integrability,"and additional `primarily initial`; memory overheads at run-time.; Whether this is onerous depends strongly not only on the application, but; also on the rest of the software stack. The initial cost of loading cppyy, and thus starting the Cling interpreter,; is about 45MB (platform dependent).; Initial uses of standard (e.g. STL) C++ results in deserialization of the; precompiled header at another eventual total cost of about 25MB (again,; platform dependent).; The actual bindings of course also carry overheads.; As a rule of thumb, you should budget for ~100MB all-in for the overhead; caused by the bindings. Other binders do not have this initial memory overhead, but do of course; occur an overhead per module, class, function, etc.; At scale, however, cppyy has some advantages: all binding is lazy (including; the option of automatic loading), standard classes are never duplicated, and; there is no additional ""per-module"" overhead.; Thus, eventually (depending on the number of classes bound, across how many; modules, what use fraction, etc.), this initial cost is recouped when; compared to other binders.; As a rule of thumb, if about 10% of classes are used, it takes several; hundreds of bound classes before the cppyy-approach is beneficial.; In High Energy Physics, from which it originated, cppyy is regularly used in; software stacks of many thousands of classes, where this advantage is very; important. `Distributing headers`; ----------------------. cppyy requires C/C++ headers to be available at run-time, which was never a; problem in the developer-centric world from which it originated: software; always had supported C++ APIs already, made available through header files,; and Python simply piggy-backed onto those.; JIT-ing code in those headers, which potentially picked up system headers; that were configured differently, was thus also never a problem.; Or rather, the same problem exists for C++, and configuration for C++ to; resolve potential issues translates t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:9134,depend,depending,9134,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['depend'],['depending']
Integrability,"and finally; the actual dispatch.; As a practical matter, overload resolution is the most costly part, followed; by the unboxing and conversion.; Best performance is achieved by specialization of the paths through the; run-time: recognize early the case at hand and select an optimized path.; For that reason, `PyPy`_ is so fast: JIT-ed traces operate on unboxed objects; and resolved overloads are baked into the trace, incurring no further cost.; Similarly, this is why pybind11 is so slow: its code generation is the C++; compiler's template engine, so complex path selection and specialization is; very hard to do in a performance-portable way. In cppyy, a great deal of attention has gone into built-in specialization; paths, which drives its performance.; For example, basic inheritance sequentially lines up classes, whereas; multiple (virtual) inheritance usually requires thunks.; Thus, when calling base class methods on a derived instance, the latter; requires offset calculations that depend on that instance, whereas the former; has fixed offsets fully determined by the class definitions themselves.; By labeling classes appropriately, single inheritance classes (by far the; most common case) do not incur the overhead in PyPy's JIT-ed traces that is; otherwise unavoidable for multiple virtual inheritance.; As another example, consider that the C++ standard does not allow modifying; a ``std::vector`` while looping over it, whereas Python has no such; restriction, complicating loops.; Thus, cppyy has specialized ``std::vector`` iteration for both PyPy and; CPython, easily outperforming looping over an equivalent numpy array. In CPython, the performance of `non-overloaded` function calls depends; greatly on the Python interpreter's internal specializations; and Python3; has many specializations specific to basic extension modules (C function; pointer calls), gaining a performance boost of more than 30% over Python2.; Only since Python3.8 is there also better support for clo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:3024,depend,depend,3024,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['depend'],['depend']
Integrability,"and has the usual semantics for a ``__strong``; variable. However, it is undefined behavior and the program is ill-formed, no; diagnostic required, if an ``init`` method attempts to use the previous value; of ``self`` after the completion of a delegate init call. It is conventional,; but not required, for an ``init`` method to return ``self``. It is undefined behavior for a program to cause two or more calls to ``init``; methods on the same object, except that each ``init`` method invocation may; perform at most one delegate init call. .. _arc.family.semantics.result_type:. Related result types; ^^^^^^^^^^^^^^^^^^^^. Certain methods are candidates to have :arc-term:`related result types`:. * class methods in the ``alloc`` and ``new`` method families; * instance methods in the ``init`` family; * the instance method ``self``; * outside of ARC, the instance methods ``retain`` and ``autorelease``. If the formal result type of such a method is ``id`` or protocol-qualified; ``id``, or a type equal to the declaring class or a superclass, then it is said; to have a related result type. In this case, when invoked in an explicit; message send, it is assumed to return a type related to the type of the; receiver:. * if it is a class method, and the receiver is a class name ``T``, the message; send expression has type ``T*``; otherwise; * if it is an instance method, and the receiver has type ``T``, the message; send expression has type ``T``; otherwise; * the message send expression has the normal result type of the method. This is a new rule of the Objective-C language and applies outside of ARC. .. admonition:: Rationale. ARC's automatic code emission is more prone than most code to signature; errors, i.e. errors where a call was emitted against one method signature,; but the implementing method has an incompatible signature. Having more; precise type information helps drastically lower this risk, as well as; catching a number of latent bugs. .. _arc.optimization:. Optimizati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:74462,protocol,protocol-qualified,74462,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['protocol'],['protocol-qualified']
Integrability,"and the implications of interpreting C++ and the One Definition Rule (ODR) in C++; * - `Cling – The New Interactive Interpreter for ROOT 6 <https://iopscience.iop.org/article/10.1088/1742-6596/396/5/052071>`_; - *V Vasilev et al* 2012 J. Phys.: Conf. Ser. 396 052071; - This paper describes the link between Cling and ROOT. The concepts of REPL and JIT compilation. Cling’s methods for handling errors, expression evaluation, streaming out of execution results, runtime dynamism.; * - `Interactive, Introspected C++ at CERN <https://www.youtube.com/watch?v=K2KqEV866Ro>`_; - *V Vasilev*, CERN PH-SFT, 2013; - Vassil Vasilev (Princeton University) explains how Cling enables interactivity in C++, and illustrates the type introspection mechanism provided by the interpreter.; * - `Introducing Cling, a C++ Interpreter Based on Clang/LLVM <https://www.youtube.com/watch?v=f9Xfh8pv3Fs>`_; - *Axel Naumann* 2012 Googletechtalks; - Axel Naumann (CERN) discusses Cling’s most relevant features: abstract syntax tree (AST) production, wrapped functions, global initialization of a function, delay expression evaluation at runtime, and dynamic scopes.; * - `Creating Cling, an interactive interpreter interface <https://www.youtube.com/watch?v=BjmGOMJWeAo>`_; - *Axel Naumann* 2010 LLVM Developers’ meeting; - This presentation introduces Cling, an ahead-of-time compiler that extends C++ for ease of use as an interpreter.; . ; .. list-table:: Demos, tutorials, Cling’s ecosystem:; :widths: 25 25 50; :header-rows: 1. * - Link; - Info ; - Description; * - `Cling integration | CLion <https://www.jetbrains.com/help/clion/cling-integration.html#install-cling>`_; - 2022.2 Version; - CLion uses Cling to integrate the `Quick Documentation <https://www.jetbrains.com/help/clion/2022.2/viewing-inline-documentation.html>`_ popup by allowing you to view the value of the expressions evaluated at compile time.; * - `Interactive C++ for Data Science <https://www.youtube.com/watch?v=23E0S3miWB0&t=2716s>`_; - *Vass",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst:1438,wrap,wrapped,1438,interpreter/cling/docs/chapters/references.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst,1,['wrap'],['wrapped']
Integrability,"and the various; global constants.`. An unbridged conversion to a retainable object pointer type from a type other; than a retainable object pointer type is ill-formed, as discussed above, unless; the operand of the cast has a syntactic form which is known retained, known; unretained, or known retain-agnostic. An expression is :arc-term:`known retain-agnostic` if it is:. * an Objective-C string literal,; * a load from a ``const`` system global variable of :ref:`C retainable pointer; type <arc.misc.c-retainable>`, or; * a null pointer constant. An expression is :arc-term:`known unretained` if it is an rvalue of :ref:`C; retainable pointer type <arc.misc.c-retainable>` and it is:. * a direct call to a function, and either that function has the; ``cf_returns_not_retained`` attribute or it is an :ref:`audited; <arc.misc.c-retainable.audit>` function that does not have the; ``cf_returns_retained`` attribute and does not follow the create/copy naming; convention,; * a message send, and the declared method either has the; ``cf_returns_not_retained`` attribute or it has neither the; ``cf_returns_retained`` attribute nor a :ref:`selector family; <arc.method-families>` that implies a retained result, or; * :when-revised:`[beginning LLVM 3.6]` :revision:`a load from a` ``const``; :revision:`non-system global variable.`. An expression is :arc-term:`known retained` if it is an rvalue of :ref:`C; retainable pointer type <arc.misc.c-retainable>` and it is:. * a message send, and the declared method either has the; ``cf_returns_retained`` attribute, or it does not have the; ``cf_returns_not_retained`` attribute but it does have a :ref:`selector; family <arc.method-families>` that implies a retained result. Furthermore:. * a comma expression is classified according to its right-hand side,; * a statement expression is classified according to its result expression, if; it has one,; * an lvalue-to-rvalue conversion applied to an Objective-C property lvalue is; classified according to th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:26698,message,message,26698,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"and y in the example above). Running integrals and Cumulative distribution functions. It is now possible to create running integrals from any RooAbsReal function and; to create cumulative distribution functions from any RooAbsPdf using the following; methods:. // Create int[xlo,x] f(x') dx' from f(x); RooAbsReal* runInt = func.createRunningIntegral(x) ;. // Create int[xlo,x] f(x') dx' from p.d.f f(x) normalized over x; RooAbsReal* cdf = pdf.createCdf(x) ;. // Create int[xlo,x] f(x',y) dx' from p.d.f f(x,y) normalized over (x,y); RooAbsReal* cdf = pdf.createCdf(x,y) ;. ; As with the similarly styled function createIntegral running integrals and c.d.f. can be created; over any number of observables, e.g createCdf(RooArgSet(x,y,z)) will create a three-dimensional; cumulative distribution function. C.d.f and running integrals that are calculated from p.d.fs that have; support for analytical integration are constructed from an appropriately reconnected RooRealIntegral.; If numeric integration is required, the c.d.f or running integral is calculated by a dedicated class; RooRunningIntegral that precalculates results for all observable values, which is more efficient; in most use cases. Cumulative distributions functions that are calculated numerically are handled slightly differently; that standard running integrals: their values is constructed to converge to exactly zero at the lower bound; and exactly 1 at the upper bound so that algorithms that make use of that property of c.d.f can do so reliably. Constraints management. New tools have been added to simplify studies with fits involving (external) constraints on parameters.; The general philosophy is that constraints on parameters can be represented as probability density functions; and can thus be modeled by RooAbsPdf classes (e.g. a RooGaussian for a simple Gaussian constraint on a parameter).; There are two modes of operation: you can add parameter constraints to your problem definition by multiplying; the constrain",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:6049,integrat,integration,6049,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['integrat'],['integration']
Integrability,"ands are always immediately promoted to ``float``, the; common real type of ``__fp16`` and ``_Float16`` for the purposes of the usual; arithmetic conversions is ``float``. A literal can be given ``_Float16`` type using the suffix ``f16``. For example,; ``3.14f16``. Because default argument promotion only applies to the standard floating-point; types, ``_Float16`` values are not promoted to ``double`` when passed as variadic; or untyped arguments. As a consequence, some caution must be taken when using; certain library facilities with ``_Float16``; for example, there is no ``printf`` format; specifier for ``_Float16``, and (unlike ``float``) it will not be implicitly promoted to; ``double`` when passed to ``printf``, so the programmer must explicitly cast it to; ``double`` before using it with an ``%f`` or similar specifier. Messages on ``deprecated`` and ``unavailable`` Attributes; =========================================================. An optional string message can be added to the ``deprecated`` and; ``unavailable`` attributes. For example:. .. code-block:: c++. void explode(void) __attribute__((deprecated(""extremely unsafe, use 'combust' instead!!!"")));. If the deprecated or unavailable declaration is used, the message will be; incorporated into the appropriate diagnostic:. .. code-block:: none. harmless.c:4:3: warning: 'explode' is deprecated: extremely unsafe, use 'combust' instead!!!; [-Wdeprecated-declarations]; explode();; ^. Query for this feature with; ``__has_extension(attribute_deprecated_with_message)`` and; ``__has_extension(attribute_unavailable_with_message)``. Attributes on Enumerators; =========================. Clang allows attributes to be written on individual enumerators. This allows; enumerators to be deprecated, made unavailable, etc. The attribute must appear; after the enumerator name and before any initializer, like so:. .. code-block:: c++. enum OperationMode {; OM_Invalid,; OM_Normal,; OM_Terrified __attribute__((deprecated)),; OM_Abor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:35795,message,message,35795,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['message'],['message']
Integrability,"ands of classes, where this advantage is very; important. `Distributing headers`; ----------------------. cppyy requires C/C++ headers to be available at run-time, which was never a; problem in the developer-centric world from which it originated: software; always had supported C++ APIs already, made available through header files,; and Python simply piggy-backed onto those.; JIT-ing code in those headers, which potentially picked up system headers; that were configured differently, was thus also never a problem.; Or rather, the same problem exists for C++, and configuration for C++ to; resolve potential issues translates transparently to Python. There are only two alternatives: precompile headers into LLVM bitcode and; distribute those or provide a restricted set of headers.; Precompiled headers (and modules) were never designed to be portable and; relocatable, however, thus that may not be the panacea it seems.; A restricted set of headers is some work, but cppyy can operate on abstract; interface classes just fine (including Python-side cross-inheritance). `Large deployment`; ------------------. The single biggest headache in maintaining an installation of Python; extension modules is that Python patch releases can break them.; The two typical solutions are to either restrict the choice of Python; interpreter and version that are supported (common in HPC) or to provide; binaries (wheels) for a large range of different interpreters and versions; (as e.g. done for conda). In the case of cppyy, only CPython/CPyCppyy and PyPy/_cppyy (an internal; module) depend on the Python interpreter (see:; :ref:`Package Structure <package-structure>`).; The user-facing ``cppyy`` module is pure Python and the backend (Cling) is; Python-independent.; Most importantly, since all bindings are generated at run-time, there are no; extension modules to regenerate and/or recompile. Thus, the end-user only needs to rebuild/reinstall CPyCppyy for each relevant; version of Python (and nothin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:10544,interface,interface,10544,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['interface'],['interface']
Integrability,"ang modules builds depend; # header-wise on it as they ship all headers from the umbrella folders. Building; # an entire module might include header, which depends on intrinsics_gen.; if(LLVM_ENABLE_MODULES); list(APPEND LLVM_COMMON_DEPENDS intrinsics_gen); endif(). add_subdirectory(lib); add_subdirectory(tools); add_subdirectory(runtime). option(CLANG_BUILD_EXAMPLES ""Build CLANG example programs by default."" OFF); add_subdirectory(examples). if(APPLE); # this line is needed as a cleanup to ensure that any CMakeCaches with the old; # default value get updated to the new default.; if(CLANG_ORDER_FILE STREQUAL """"); unset(CLANG_ORDER_FILE CACHE); unset(CLANG_ORDER_FILE); endif(). set(CLANG_ORDER_FILE ${CMAKE_CURRENT_BINARY_DIR}/clang.order CACHE FILEPATH; ""Order file to use when compiling clang in order to improve startup time (Darwin Only - requires ld64).""). if(NOT EXISTS ${CLANG_ORDER_FILE}); string(FIND ""${CLANG_ORDER_FILE}"" ""${CMAKE_CURRENT_BINARY_DIR}"" PATH_START); if(PATH_START EQUAL 0); file(WRITE ${CLANG_ORDER_FILE} ""\n""); else(); message(FATAL_ERROR ""Specified order file '${CLANG_ORDER_FILE}' does not exist.""); endif(); endif(); endif(). if( CLANG_INCLUDE_TESTS ); add_subdirectory(unittests); list(APPEND CLANG_TEST_DEPS ClangUnitTests); list(APPEND CLANG_TEST_PARAMS; clang_unit_site_config=${CMAKE_CURRENT_BINARY_DIR}/test/Unit/lit.site.cfg; ); add_subdirectory(test); add_subdirectory(bindings/python/tests). if(CLANG_BUILT_STANDALONE); umbrella_lit_testsuite_end(check-all); endif(); add_subdirectory(utils/perf-training); endif(). option(CLANG_INCLUDE_DOCS ""Generate build targets for the Clang docs.""; ${LLVM_INCLUDE_DOCS}); if( CLANG_INCLUDE_DOCS ); add_subdirectory(docs); endif(). # Custom target to install all clang libraries.; add_custom_target(clang-libraries); set_target_properties(clang-libraries PROPERTIES FOLDER ""Misc""). if(NOT LLVM_ENABLE_IDE); add_llvm_install_targets(install-clang-libraries; DEPENDS clang-libraries; COMPONENT clang-libraries); endif()",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:18608,message,message,18608,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['message'],['message']
Integrability,"ang status can be found here. At the moment, there are use cases only for C++ that's why cling is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward to having more use-cases and extend our tool in that direction.; Cling has internal commands, which can change its behavior at runtime. Those commands usually start with dot (.):; .I <path> - Adds an include path;; .x <filename> - #include-s the filename; and calls function called filename(); ; .L <libname> - Loads libname or #include-s the libname if libname is file;; .@ - Cancels the multiline input;; .printAST - (DEBUG ONLY) Turns on the printing of the compiler's abstract syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:2861,integrat,integrate,2861,interpreter/cling/www/old/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html,1,['integrat'],['integrate']
Integrability,"ang supports; interacts with constant evaluation:. * ``__extension__``: The expression form of this extension causes any; evaluatable subexpression to be accepted as an integer constant expression.; * ``__builtin_constant_p``: This returns true (as an integer constant; expression) if the operand evaluates to either a numeric value (that is, not; a pointer cast to integral type) of integral, enumeration, floating or; complex type, or if it evaluates to the address of the first character of a; string literal (possibly cast to some other type). As a special case, if; ``__builtin_constant_p`` is the (potentially parenthesized) condition of a; conditional operator expression (""``?:``""), only the true side of the; conditional operator is considered, and it is evaluated with full constant; folding.; * ``__builtin_choose_expr``: The condition is required to be an integer; constant expression, but we accept any constant as an ""extension of an; extension"". This only evaluates one operand depending on which way the; condition evaluates.; * ``__builtin_classify_type``: This always returns an integer constant; expression.; * ``__builtin_inf, nan, ...``: These are treated just like a floating-point; literal.; * ``__builtin_abs, copysign, ...``: These are constant folded as general; constant expressions.; * ``__builtin_strlen`` and ``strlen``: These are constant folded as integer; constant expressions if the argument is a string literal. .. _Sema:. The Sema Library; ================. This library is called by the :ref:`Parser library <Parser>` during parsing to; do semantic analysis of the input. For valid programs, Sema builds an AST for; parsed constructs. .. _CodeGen:. The CodeGen Library; ===================. CodeGen takes an :ref:`AST <AST>` as input and produces `LLVM IR code; <//llvm.org/docs/LangRef.html>`_ from it. How to change Clang; ===================. How to add an attribute; -----------------------; Attributes are a form of metadata that can be attached to a program ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:123964,depend,depending,123964,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['depending']
Integrability,"ang-repl> welcome();; Welcome to REPL. Using Dynamic Library:; ======================. .. code-block:: text. clang-repl> %lib print.so; clang-repl> #include""print.hpp""; clang-repl> print(9);; 9. **Generation of dynamic library**. .. code-block:: text. // print.cpp; #include <iostream>; #include ""print.hpp"". void print(int a); {; std::cout << a << std::endl;; }. // print.hpp; void print (int a);. // Commands; clang++-17 -c -o print.o print.cpp; clang-17 -shared print.o -o print.so. Comments:; =========. .. code-block:: text. clang-repl> // Comments in Clang-Repl; clang-repl> /* Comments in Clang-Repl */. Closure or Termination:; =======================. .. code-block:: text. clang-repl>%quit. Just like Clang, Clang-Repl can be integrated in existing applications as a library; (using the clangInterpreter library). This turns your C++ compiler into a service that; can incrementally consume and execute code. The **Compiler as A Service** (**CaaS**); concept helps support advanced use cases such as template instantiations on demand and; automatic language interoperability. It also helps static languages such as C/C++ become; apt for data science. Execution Results Handling in Clang-Repl; ========================================. Execution Results Handling features discussed below help extend the Clang-Repl; functionality by creating an interface between the execution results of a; program and the compiled program. 1. **Capture Execution Results**: This feature helps capture the execution results; of a program and bring them back to the compiled program. 2. **Dump Captured Execution Results**: This feature helps create a temporary dump; for Value Printing/Automatic Printf, that is, to display the value and type of; the captured data. 1. Capture Execution Results; ============================. In many cases, it is useful to bring back the program execution result to the; compiled program. This result can be stored in an object of type **Value**. How Execution Results are ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:5545,interoperab,interoperability,5545,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['interoperab'],['interoperability']
Integrability,"ang/include/clang/Basic/DiagnosticSemaKinds.td. Find the message (it should be under; ``warn_infinite_recursive_function``). Change the message to ""in order to; understand recursion, you must first understand recursion"". Test again; ----------. To verify our change, we can build clang and manually check that it; works. .. code:: console. $ ninja clang; $ bin/clang -Wall ~/test.cc; /path/test.cc:1:124: warning: in order to understand recursion, you must; first understand recursion [-Winfinite-recursion]. We should also run the tests to make sure we didn't break something. .. code:: console. $ ninja check-clang. Notice that it is much faster to build this time, but the tests take; just as long to run. Ninja doesn't know which tests might be affected,; so it runs them all. .. code:: console. ********************; Testing Time: 408.84s; ********************; Failing Tests (1):; Clang :: SemaCXX/warn-infinite-recursion.cpp. Well, that makes sense… and the test output suggests it's looking for; the old string ""call itself"" and finding our new message instead.; Note that more tests may fail in a similar way as new tests are; added time to time. Let's fix it by updating the expectation in the test. .. code:: console. $ vi ../clang/test/SemaCXX/warn-infinite-recursion.cpp. Everywhere we see `// expected-warning{{call itself}}` (or something similar; from the original warning text), let's replace it with; `// expected-warning{{to understand recursion}}`. Now we could run **all** the tests again, but this is a slow way to; iterate on a change! Instead, let's find a way to re-run just the; specific test. There are two main types of tests in LLVM:. - **lit tests** (e.g. SemaCXX/warn-infinite-recursion.cpp). These are fancy shell scripts that run command-line tools and verify the; output. They live in files like; clang/**test**/FixIt/dereference-addressof.c. Re-run like this:. .. code:: console. $ bin/llvm-lit -v ../clang/test/SemaCXX/warn-infinite-recursion.cpp. - **unit tests** ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:6902,message,message,6902,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['message'],['message']
Integrability,"ang; if (MSVC_VERSION GREATER_EQUAL 1924 AND MSVC_VERSION LESS 1929); string(REPLACE ""-O2"" ""-O1 -Oi"" CMAKE_CXX_FLAGS_RELEASE ""${CMAKE_CXX_FLAGS_RELEASE}""); string(REPLACE ""-O2"" ""-O1 -Oi"" CMAKE_CXX_FLAGS_RELWITHDEBINFO ""${CMAKE_CXX_FLAGS_RELWITHDEBINFO}""); endif(); # replace dashes in the -EH* and -GR* flags with slashes (/EH* /GR*); string(REPLACE "" -EH"" "" /EH"" CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS}""); string(REPLACE "" -GR"" "" /GR"" CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS}""); set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} /ignore:4049,4206,4217,4221""); set(CMAKE_SHARED_LINKER_FLAGS ""${CMAKE_SHARED_LINKER_FLAGS} /ignore:4049,4206,4217,4221""); set(CMAKE_MODULE_LINKER_FLAGS ""${CMAKE_MODULE_LINKER_FLAGS} /ignore:4049,4206,4217,4221""); endif(). set(LLVM_TARGETS_TO_BUILD ${ROOT_CLING_TARGET} CACHE STRING ""Semicolon-separated list of targets to build, or \""all\"".""). if(clingtest); message(""-- cling test suite enabled: llvm / clang symbols in libCling will be visible!""); set(CLING_INCLUDE_TESTS ON CACHE BOOL """" FORCE); # The path to cling passed through environment variable only relevant when building; # against external llvm. In that case, cling's testsuite cannot deduce the binary; # of cling relatively to the llvm tools folder.; if (NOT builtin_llvm); set(CLINGTEST_EXECUTABLE CLING=${CMAKE_CURRENT_BINARY_DIR}/llvm-project/llvm/${CMAKE_CFG_INTDIR}/bin/cling); endif(); ROOT_ADD_TEST(clingtest-check-cling COMMAND ${CMAKE_COMMAND} --build ${CMAKE_BINARY_DIR} --target check-cling; ENVIRONMENT ${CLINGTEST_EXECUTABLE}); else(); #---Build LLVM/Clang with symbol visibility=hidden--------------------------------------------------; set(CMAKE_CXX_VISIBILITY_PRESET hidden); set(CMAKE_C_VISIBILITY_PRESET hidden); endif(); if (NOT MSVC AND NOT APPLE); # Requires the linker to resolve the symbol internally and prevents; # conflicts when linked with another software using also LLVM like in; # the problem reported for Julia in; # https://github.com/JuliaHEP/ROOT.jl/issues/17#issuecomment-8827",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:6383,message,message,6383,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['message'],['message']
Integrability,"ange things, and; it doesn't seem to be very necessary right now. It would seem to; complicate flow control analysis a LOT in the virtual machine. I would; tend to prefer that a predicated architecture like IA64 convert from a; ""basic block"" representation to a predicated rep as part of it's dynamic; complication phase. Also, if a basic block contains ONLY a move, then; that can be trivally translated into a conditional move... > I agree that we need a static data space. Otherwise, emulating global; > data gets unnecessarily complex. Definitely. Also a later item though. :). > We once talked about adding a symbolic thread-id field to each; > ..; > Instead, it could a great topic for a separate study. Agreed. :). > What is the semantics of the IA64 stop bit?. Basically, the IA64 writes instructions like this:; mov ...; add ...; sub ...; op xxx; op xxx; ;;; mov ...; add ...; sub ...; op xxx; op xxx; ;;. Where the ;; delimits a group of instruction with no dependencies between; them, which can all be executed concurrently (to the limits of the; available functional units). The ;; gets translated into a bit set in one; of the opcodes. The advantages of this representation is that you don't have to do some; kind of 'thread id scheduling' pass by having to specify ahead of time how; many threads to use, and the representation doesn't have a per instruction; overhead... > And finally, another thought about the syntax for arrays :-); > Although this syntax:; > array <dimension-list> of <type>; > is verbose, it will be used only in the human-readable assembly code so; > size should not matter. I think we should consider it because I find it; > to be the clearest syntax. It could even make arrays of function; > pointers somewhat readable. My only comment will be to give you an example of why this is a bad; idea. :). Here is an example of using the switch statement (with my recommended; syntax):. switch uint %val, label %otherwise, ; [%3 x {uint, label}] [ { uint %57, label %l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt:7386,depend,dependencies,7386,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-09-AdveCommentsResponse.txt,1,['depend'],['dependencies']
Integrability,"anges are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. \anchor GP08d; ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection of components before creating the object. \anchor GP08e; ### Editing Volumes. Volumes are hierarchical components in the geometry, therefore their; editor is more complex. It provides the following functionalities:. - *General*. This category allows changing the name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""Position"" allows editing the; positioning matrix of a given node. \image html geometry022.jpg width=600px; \image html geometry023.jpg ""Setting volume properties and modifying volume hierarchy"" width=600px. - *Visualization*. This category allows changing the visibility of the; edited volume or for its daughters, as well as other visualization; settings. The radio button ""All"" allows viewing all volumes down; to the selected depth. ""Leaves"" will draw only the deepest nodes; that have the selected depth or lower level ones that have no; daught",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:132095,interface,interface,132095,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['interface'],['interface']
Integrability,"anonicalize.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare float @llvm.canonicalize.f32(float %a); declare double @llvm.canonicalize.f64(double %b). Overview:; """""""""""""""""". The '``llvm.canonicalize.*``' intrinsic returns the platform specific canonical; encoding of a floating-point number. This canonicalization is useful for; implementing certain numeric primitives such as frexp. The canonical encoding is; defined by IEEE-754-2008 to be:. ::. 2.1.8 canonical encoding: The preferred encoding of a floating-point; representation in a format. Applied to declets, significands of finite; numbers, infinities, and NaNs, especially in decimal formats. This operation can also be considered equivalent to the IEEE-754-2008; conversion of a floating-point value to the same format. NaNs are handled; according to section 6.2. Examples of non-canonical encodings:. - x87 pseudo denormals, pseudo NaNs, pseudo Infinity, Unnormals. These are; converted to a canonical representation per hardware-specific protocol.; - Many normal decimal floating-point numbers have non-canonical alternative; encodings.; - Some machines, like GPUs or ARMv7 NEON, do not support subnormal values.; These are treated as non-canonical encodings of zero and will be flushed to; a zero of the same sign by this operation. Note that per IEEE-754-2008 6.2, systems that support signaling NaNs with; default exception handling must signal an invalid exception, and produce a; quiet NaN result. This function should always be implementable as multiplication by 1.0, provided; that the compiler does not constant fold the operation. Likewise, division by; 1.0 and ``llvm.minnum(x, x)`` are possible implementations. Addition with; -0.0 is also sufficient provided that the rounding mode is not -Infinity. ``@llvm.canonicalize`` must preserve the equality relation. That is:. - ``(@llvm.canonicalize(x) == x)`` is equivalent to ``(x == x)``; - ``(@llvm.canonicalize(x) == @llvm.canonicalize(y))`` is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:639474,protocol,protocol,639474,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['protocol'],['protocol']
Integrability,"ant bits for big-endian. Example:; """""""""""""""". .. code-block:: text. %X = bitcast i8 255 to i8 ; yields i8 :-1; %Y = bitcast i32* %x to i16* ; yields i16*:%x; %Z = bitcast <2 x i32> %V to i64; ; yields i64: %V (depends on endianness); %Z = bitcast <2 x i32*> %V to <2 x i64*> ; yields <2 x i64*>. .. _i_addrspacecast:. '``addrspacecast .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = addrspacecast <pty> <ptrval> to <pty2> ; yields pty2. Overview:; """""""""""""""""". The '``addrspacecast``' instruction converts ``ptrval`` from ``pty`` in; address space ``n`` to type ``pty2`` in address space ``m``. Arguments:; """""""""""""""""""". The '``addrspacecast``' instruction takes a pointer or vector of pointer value; to cast and a pointer type to cast it to, which must have a different; address space. Semantics:; """""""""""""""""""". The '``addrspacecast``' instruction converts the pointer value; ``ptrval`` to type ``pty2``. It can be a *no-op cast* or a complex; value modification, depending on the target and the address space; pair. Pointer conversions within the same address space must be; performed with the ``bitcast`` instruction. Note that if the address; space conversion produces a dereferenceable result then both result; and operand refer to the same memory location. The conversion must; have no side effects, and must not capture the value of the pointer. If the source is :ref:`poison <poisonvalues>`, the result is; :ref:`poison <poisonvalues>`. If the source is not :ref:`poison <poisonvalues>`, and both source and; destination are :ref:`integral pointers <nointptrtype>`, and the; result pointer is dereferenceable, the cast is assumed to be; reversible (i.e. casting the result back to the original address space; should yield the original bit pattern). Example:; """""""""""""""". .. code-block:: llvm. %X = addrspacecast ptr %x to ptr addrspace(1); %Y = addrspacecast ptr addrspace(1) %y to ptr addrspace(2); %Z = addrspacecast <4 x ptr> %z to <4 x ptr addrspace(3",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:458300,depend,depending,458300,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depending']
Integrability,ant; Unknown. 984; CD2; “Deduced type” is unclear in auto type deduction; Unknown. 985; C++11; Alternative tokens and user-defined literals; Unknown. 986; CD2; Transitivity of using-directives versus qualified lookup; Unknown. 987; CD4; Which declarations introduce namespace members?; Unknown. 988; CD2; Reference-to-reference collapsing with decltype; Unknown. 989; CD2; Misplaced list-initialization example; Unknown. 990; CD2; Value initialization with multiple initializer-list constructors; Clang 3.5. 991; CD2; Reference parameters of constexpr functions and constructors; Unknown. 992; NAD; Inheriting explicitness; Unknown. 993; C++11; Freedom to perform instantiation at the end of the translation unit; Unknown. 994; C++11; braced-init-list as a default argument; Unknown. 995; CD2; Incorrect example for using-declaration and explicit instantiation; Unknown. 996; C++11; Ambiguous partial specializations of member class templates; Unknown. 997; C++11; Argument-dependent lookup and dependent function template parameter types; Unknown. 998; dup; Function parameter transformations and template functions; Unknown. 999; CD2; “Implicit” or “implied” object argument/parameter?; Unknown. 1000; CD2; Mistaking member typedefs for constructors; Unknown. 1001; drafting; Parameter type adjustment in dependent parameter types; Not resolved. 1002; NAD; Pack expansion for function arguments; Unknown. 1003; CD3; Acceptable definitions of main; Unknown. 1004; C++11; Injected-class-names as arguments for template template parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression;,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:65598,depend,dependent,65598,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['depend'],['dependent']
Integrability,"anteed to be uniqued by the runtime, but nor are they guaranteed to; be newly-allocated. As such, the result of performing direct comparisons; against the location of an object literal (using ``==``, ``!=``, ``<``,; ``<=``, ``>``, or ``>=``) is not well-defined. This is usually a simple; mistake in code that intended to call the ``isEqual:`` method (or the; ``compare:`` method). This caveat applies to compile-time string literals as well.; Historically, string literals (using the ``@""...""`` syntax) have been; uniqued across translation units during linking. This is an; implementation detail of the compiler and should not be relied upon. If; you are using such code, please use global string constants instead; (``NSString * const MyConst = @""...""``) or use ``isEqual:``. Grammar Additions; =================. To support the new syntax described above, the Objective-C; ``@``-expression grammar has the following new productions:. ::. objc-at-expression : '@' (string-literal | encode-literal | selector-literal | protocol-literal | object-literal); ;. object-literal : ('+' | '-')? numeric-constant; | character-constant; | boolean-constant; | array-literal; | dictionary-literal; ;. boolean-constant : '__objc_yes' | '__objc_no' | 'true' | 'false' /* boolean keywords. */; ;. array-literal : '[' assignment-expression-list ']'; ;. assignment-expression-list : assignment-expression (',' assignment-expression-list)?; | /* empty */; ;. dictionary-literal : '{' key-value-list '}'; ;. key-value-list : key-value-pair (',' key-value-list)?; | /* empty */; ;. key-value-pair : assignment-expression ':' assignment-expression; ;. Note: ``@true`` and ``@false`` are only supported in Objective-C++. Availability Checks; ===================. Programs test for the new features by using clang's \_\_has\_feature; checks. Here are examples of their use:. .. code-block:: objc. #if __has_feature(objc_array_literals); // new way.; NSArray *elements = @[ @""H"", @""He"", @""O"", @""C"" ];; #else; // old way (",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:18175,protocol,protocol-literal,18175,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['protocol'],['protocol-literal']
Integrability,"any package is missing; when `-Dfail-on-missing=ON` is passed to CMake; - The `-Dall=ON` now switches the default value of all optional packages to `ON`; - The options `astiff`, `cling`, `pch`, `thread`, and `explicitlink` have been; removed and are now ignored. They either had no effect (their value was not; being used in the build system), or could not be disabled (like `cling` and; `explicitlink`).; - ROOT library targets now export which C++ standard they were built with via; the target compile features `cxx_std_11`, `cxx_std_14`, and `cxx_std_17`.; - The file `RootNewMacros.cmake` has been renamed to `RootMacros.cmake`.; Including the old file by name is deprecated and will generate a warning.; Including `RootMacros.cmake` is not necessary, as now it is already included; when calling `find_package(ROOT)`. If you still need to inherit ROOT's compile; options, however, you may use `include(${ROOT_USE_FILE})` as before.; - ROOT's internal CMake modules (e.g. CheckCompiler.cmake, SetUpLinux.cmake, etc); are no longer installed with `make install`. Only the necessary files by; dependent projects are installed by default now, and they are installed; directly into the cmake/ directory, not cmake/modules/ as before.; - The macro `ROOT_GENERATE_DICTIONARY()` can now attach the generated source; file directly to a library target by using the option `MODULE <library>`, where; `<library>` is an existing library target. This allows the dictionary to inherit; target properties such as compile options and include directories from the library; target, even when they are added after the call to `ROOT_GENERATE_DICTIONARY()`.; - The macros `REFLEX_GENERATE_DICTIONARY()` and `ROOT_GENERATE_DICTIONARY()` can; now have custom extra dependencies added with the options `DEPENDS` and; `EXTRA_DEPENDENCIES`, respectively. The following builtins have been updated:. - FFTW3 3.3.8; - GSL 2.5; - Intel TBB 2019 U8; - PCRE 8.43; - OpenSSL 1.0.2s; - Vdt 0.4.3; - VecCore 0.6.0; - XRootD 4.10.0; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md:9123,depend,dependent,9123,README/ReleaseNotes/v620/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md,2,['depend'],"['dependencies', 'dependent']"
Integrability,"any text lines on the master log. Logs are now sent only after Exec, Print; requests and in case an error (level >= kError) occured. Of course, the full; logs can always be retrieved via TProofMgr::GetSessionLogs; . Log retrieval:. for 'grep' operations, use the system 'grep' command; via 'popen'; instead of a handmade filtering; this implies that the full grep; functionality is now available; set the default number of displayed lines to 100; instead of 10. Improve diagnostic in case of worker death: clients will; now; receive a message containing the low level reason for the failure and a; hint for getting more informationIn; TProofOutputFile, support the ""<user>"" and ""<group>""; placeholders in the output file name to automatically re-direct the; output to an area specific to the logged user.; Addition of a new class TProofProgressStatus, which is used to keep; the query progress stauts in all the TProofPlayer objects and in the; TPacketizerAdaptive. It is also send in kPROOF_GETPACKET and; kPROOF_STOPPROCESS messages. ; The class TPacketizerProgressive is removed. . Fixes. Enable; the max number of sessions ('mxsess' parameter in the xpd.schedparam; directive); users are just refused to start a session if this limit is; reached.Make sure to collect consistently input messages when running in asynchronous modeFix; a few problems with TProof::SendFile (used by UploadPackage, Load); appearing when a rapid sequence of these commands was submitted Invalidate the TProofMgr when the physical connection is; closed; avoids; crashing when trying to get the logs after a failure. ; Fix a memory leak in log retrieval (the TProofLog object; was never; deleted); Add protections for the cases the manager cannot be; initialized; Fix a race condition possibly affecting the handling of; workers death; Avoid duplicating worker logs in the master log file; unless; when explicitly needed by the request (Exec(...), Print(...)) or when; an error occuredFix; problem with the determination",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html:5873,message,messages,5873,proof/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html,1,['message'],['messages']
Integrability,"anyway. Optimization passes may make conditions that this pass checks for more or less; obvious. If an optimization pass appears to be introducing a warning, it may; be that the optimization pass is merely exposing an existing condition in the; code. This code may be run before :ref:`instcombine <passes-instcombine>`. In many; cases, instcombine checks for the same kinds of things and turns instructions; with undefined behavior into unreachable (or equivalent). Because of this,; this pass makes some effort to look through bitcasts and so on. ``loops``: Natural Loop Information; -----------------------------------. This analysis is used to identify natural loops and determine the loop depth of; various nodes of the CFG. Note that the loops identified may actually be; several natural loops that share the same header node... not just a single; natural loop. ``memdep``: Memory Dependence Analysis; --------------------------------------. An analysis that determines, for a given memory operation, what preceding; memory operations it depends on. It builds on alias analysis information, and; tries to provide a lazy, caching interface to a common kind of alias; information query. ``module-debuginfo``: Decodes module-level debug info; -----------------------------------------------------. This pass decodes the debug info metadata in a module and prints in a; (sufficiently-prepared-) human-readable form. For example, run this pass from ``opt`` along with the ``-analyze`` option, and; it'll print to standard output. ``postdomtree``: Post-Dominator Tree Construction; -------------------------------------------------. This pass is a simple post-dominator construction algorithm for finding; post-dominators. ``print-alias-sets``: Alias Set Printer; ---------------------------------------. Yet to be written. ``print-callgraph``: Print a call graph; ---------------------------------------. This pass, only available in ``opt``, prints the call graph to standard error; in a human-reada",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:8177,depend,depends,8177,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['depend'],['depends']
Integrability,"ape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of properties related to tracking); - *Matrices.* Allows creation of translations, rotations or combined; transformations. Existing matrices can also be browser/edited. \anchor GP08c; ### Editing Existing Objects. For editing an existing object from one of the categories described; above, the interface imposes first a selection among all objects of the; corresponding type stored in the geometry. This can be done by clicking; the button next to the blue label *Select \<object\>*. The dialog; interfaces are generally different for different types of objects. The; volume selection dialog offers the possibility to select either a volume; already connected to the geometry hierarchy or non-connected ones.; Selection for shapes and matrices is split into categories represented; by top-level list tree items for: boxes, tubes, translations, rotations,; etc. \image html geometry020.png ""Selection dialogs for different TGeo objects"". Once a selection is made and the dialog is closed, the selected item; name will appear in the corresponding label and the button Edit will; start the object editor in a transient frame. Closing these transient; frames will not delete, but just hide existing opened editors for later; reuse. Their lifetime is determined by the canvas to which the manager; editor is attached to, since these will be destroyed together. \image html geometry021.png ""Editors for shapes, materials, media, matrices"" width=600px. For most editors, the functionalities Apply and Undo are provided. For shapes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:129467,interface,interfaces,129467,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['interface'],['interfaces']
Integrability,aph.C; graphs/graphstruct.C; hist/ContourList.C; hist/hbars.C; hist/th2polyBoxes.C; hist/statsEditing.C; hist/cumulative.C; hist/hlabels1.C; hist/hlabels2.C; tree/h1analysis.C; math/chi2test.C; r/SimpleFitting.C); #---Dependencies------------------------------------------------------; set(unfold-testUnfold5d-depends tutorial-unfold-testUnfold5c); set(unfold-testUnfold5c-depends tutorial-unfold-testUnfold5b); set(unfold-testUnfold5b-depends tutorial-unfold-testUnfold5a); set(unfold-testUnfold7d-depends tutorial-unfold-testUnfold7c); set(unfold-testUnfold7c-depends tutorial-unfold-testUnfold7b); set(unfold-testUnfold7b-depends tutorial-unfold-testUnfold7a); set(xml-xmlmodifyfile-depends tutorial-xml-xmlnewfile); set(xml-xmlreadfile-depends tutorial-xml-xmlnewfile); set(roofit-rf503_wspaceread-depends tutorial-roofit-rf502_wspacewrite); set(io-readCode-depends tutorial-io-importCode); set(fit-fit1-depends tutorial-hist-fillrandom); set(fit-myfit-depends tutorial-fit-fitslicesy); set(foam-foam_demopers-depends tutorial-foam-foam_demo); set(tree-staff-depends tutorial-tree-cernbuild); set(tree-cernstaff-depends tutorial-tree-cernbuild); set(hist-hbars-depends tutorial-tree-cernbuild); set(benchmarks-depends tutorial-hsimple; tutorial-fit-fit1; tutorial-fit-myfit; tutorial-hist-h1ReadAndDraw; tutorial-hist-FirstContour; tutorial-geom-na49view; tutorial-tree-ntuple1; tutorial-tree-spider; tutorial-io-hadd; tutorial-io-loopdir; tutorial-io-copyFiles); set(geom-na49view-depends tutorial-geom-geometry); set(multicore-mt102_readNtuplesFillHistosAndFit-depends tutorial-multicore-mt101_fillNtuples); set(multicore-mp102_readNtuplesFillHistosAndFit-depends tutorial-multicore-mp101_fillNtuples); set(multicore-mp105_processEntryList-depends tutorial-multicore-mp104_processH1). #--many histfactory and roostats tutorials depending on having creating the file first with histfactory and example_combined_GaussExample_model.root; foreach(tname histfactory-hf001_example; roostats-ModelInsp,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:16731,depend,depends,16731,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,21,['depend'],['depends']
Integrability,"appears to be introducing a warning, it may; be that the optimization pass is merely exposing an existing condition in the; code. This code may be run before :ref:`instcombine <passes-instcombine>`. In many; cases, instcombine checks for the same kinds of things and turns instructions; with undefined behavior into unreachable (or equivalent). Because of this,; this pass makes some effort to look through bitcasts and so on. ``loops``: Natural Loop Information; -----------------------------------. This analysis is used to identify natural loops and determine the loop depth of; various nodes of the CFG. Note that the loops identified may actually be; several natural loops that share the same header node... not just a single; natural loop. ``memdep``: Memory Dependence Analysis; --------------------------------------. An analysis that determines, for a given memory operation, what preceding; memory operations it depends on. It builds on alias analysis information, and; tries to provide a lazy, caching interface to a common kind of alias; information query. ``module-debuginfo``: Decodes module-level debug info; -----------------------------------------------------. This pass decodes the debug info metadata in a module and prints in a; (sufficiently-prepared-) human-readable form. For example, run this pass from ``opt`` along with the ``-analyze`` option, and; it'll print to standard output. ``postdomtree``: Post-Dominator Tree Construction; -------------------------------------------------. This pass is a simple post-dominator construction algorithm for finding; post-dominators. ``print-alias-sets``: Alias Set Printer; ---------------------------------------. Yet to be written. ``print-callgraph``: Print a call graph; ---------------------------------------. This pass, only available in ``opt``, prints the call graph to standard error; in a human-readable form. ``print-callgraph-sccs``: Print SCCs of the Call Graph; ------------------------------------------------------. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:8268,interface,interface,8268,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['interface'],['interface']
Integrability,"ar source file is being edited by the user. To minimize the amount; of reparsing required after a change to the file, a form of precompiled header; --- called a precompiled *preamble* --- is automatically generated by parsing; all of the headers in the source file, up to and including the last; ``#include``. When only the source file changes (and none of the headers it; depends on), reparsing of that source file can use the precompiled preamble and; start parsing after the ``#include``\ s, so parsing time is proportional to the; size of the source file (rather than all of its includes). However, the; compilation of that translation unit may already use a precompiled header: in; this case, Clang will create the precompiled preamble as a chained precompiled; header that refers to the original precompiled header. This drastically; reduces the time needed to serialize the precompiled preamble for use in; reparsing. Chained precompiled headers get their name because each precompiled header can; depend on one other precompiled header, forming a chain of dependencies. A; translation unit will then include the precompiled header that starts the chain; (i.e., nothing depends on it). This linearity of dependencies is important for; the semantic model of chained precompiled headers, because the most-recent; precompiled header can provide information that overrides the information; provided by the precompiled headers it depends on, just like a header file; ``B.h`` that includes another header ``A.h`` can modify the state produced by; parsing ``A.h``, e.g., by ``#undef``'ing a macro defined in ``A.h``. There are several ways in which chained precompiled headers generalize the AST; file model:. Numbering of IDs; Many different kinds of entities --- identifiers, declarations, types, etc.; --- have ID numbers that start at 1 or some other predefined constant and; grow upward. Each precompiled header records the maximum ID number it has; assigned in each category. Then, when a new pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:24757,depend,depend,24757,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,2,['depend'],"['depend', 'dependencies']"
Integrability,"ar(); }; 3 |; 4 | void Test(int *res, int *c, int *d, int *p, int n) {; 5 | int i;; 6 |; 7 | #pragma clang loop vectorize(assume_safety); 8 V4,1 | for (i = 0; i < 1600; i++) {; 9 | res[i] = (p[i] == 0) ? res[i] : res[i] + d[i];; 10 | }; 11 |; 12 U16 | for (i = 0; i < 16; i++) {; 13 | res[i] = (p[i] == 0) ? res[i] : res[i] + d[i];; 14 | }; 15 |; 16 I | foo();; 17 |; 18 | foo(); bar(); foo();; I | ^; I | ^; 19 | }; 20 |. Symbols printed on the left side of the program indicate what kind of optimization was performed.; The meanings of the symbols are as follows:. - I: The function is inlined.; - U: The loop is unrolled. The following number indicates the unroll factor.; - V: The loop is vectorized. The following numbers indicate the vector length and the interleave factor. .. note:: . If a specific line of code is output twice, it means that the same optimization pass was applied to that ; line of code twice, and the pass was able to further optimize the code on the second iteration. OPTIONS; -------. If ``input`` is ""``-``"" or omitted, :program:`llvm-opt-report` reads from standard; input. Otherwise, it will read from the specified filename. If the :option:`-o` option is omitted, then :program:`llvm-opt-report` will send its output; to standard output. If the :option:`-o` option specifies ""``-``"", then the output will also; be sent to standard output. .. option:: --help. Display available options. .. option:: --version. Display the version of this program. .. option:: --format=<string>. The format of the optimization record file.; The Argument is one of the following:. - yaml; - yaml-strtab; - bitstream. .. option:: --no-demangle. Do not demangle function names. .. option:: -o=<string>. Output file. .. option:: -r=<string>. Root for relative input paths. .. option:: -s. Do not include vectorization factors, etc. EXIT STATUS; -----------. :program:`llvm-opt-report` returns 0 on success. Otherwise, an error message is printed; to standard error, and the tool returns 1. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-opt-report.rst:2892,message,message,2892,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-opt-report.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-opt-report.rst,1,['message'],['message']
Integrability,"arameter interaction by the user. An instance of MnMigrad is; specific to the current $\mbox{FCN}$ and user parameters. Any; parameter interaction of the user between two minimization steps will; make use of the result of the preceeding minimization in an optimal way.; The interface for parameters (see [api:parameters], [api:covariance] and; [api:state]) is forwardedin MnMigrad. ### Subsequent minimizations ###. M takes care that all information is treated in an optimal and correct; way if the user interacts with the parameters between two minimizations.; MnMigrad retains the result of the last minimization and uses this as; input for the next step. Between two minimization requests to MnMigrad; the user can fix or release parameters, put limits on them or remove; limits from them. Each instance of a MnMigrad object maintains its own; state and one can have multiple instances of MnMigrad objects. ### M fails to find a minimum ###. If M fails to find a minimum, the user is notified by a warning message; issued by M when running into troubles. Problems can be:. - a bug in M. - an error in the $\mbox{FCN}$. - a highly difficult problem (usually strong correlations among; parameters). - floating–point precision. ## The output from minimization ##. ### The FunctionMinimum ###. The output of the minimizers is the FunctionMinimum. The FunctionMinimum; contains the result of the minimization in both internal parameter; representation and external parameter representation. ### User representable format: MnUserParameterState ###. On request, the result of the minimization is transformed into a user; representable format for parameters and errors, the; MnUserParameterState. ### Access values, errors, covariance ###. The result can be accessed via methods like; MnUserParameterState::value(unsigned int n) and; MnUserParameterState::error(unsigned int n), where $n$ is the index of; the parameter in the list of parameters defined by the user. ### Printout of the result ###. The Fun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:35372,message,message,35372,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['message'],['message']
Integrability,"arations. In other word, for a translation unit, it will compile slower if the; translation unit itself and its importing module units contains a lot duplicated; declarations. For example,. .. code-block:: c++. // M-partA.cppm; module;; #include ""big.header.h""; export module M:partA;; ... // M-partB.cppm; module;; #include ""big.header.h""; export module M:partB;; ... // other partitions; ... // M-partZ.cppm; module;; #include ""big.header.h""; export module M:partZ;; ... // M.cppm; export module M;; export import :partA;; export import :partB;; ...; export import :partZ;. // use.cpp; import M;; ... // use declarations from module M. When ``big.header.h`` is big enough and there are a lot of partitions,; the compilation of ``use.cpp`` may be slower than; the following style significantly:. .. code-block:: c++. module;; #include ""big.header.h""; export module m:big.header.wrapper;; export ... // export the needed declarations. // M-partA.cppm; export module M:partA;; import :big.header.wrapper;; ... // M-partB.cppm; export module M:partB;; import :big.header.wrapper;; ... // other partitions; ... // M-partZ.cppm; export module M:partZ;; import :big.header.wrapper;; ... // M.cppm; export module M;; export import :partA;; export import :partB;; ...; export import :partZ;. // use.cpp; import M;; ... // use declarations from module M. The key part of the tip is to reduce the duplications from the text includes. Known Problems; --------------. The following describes issues in the current implementation of modules.; Please see https://github.com/llvm/llvm-project/labels/clang%3Amodules for more issues; or file a new issue if you don't find an existing one.; If you're going to create a new issue for standard C++ modules,; please start the title with ``[C++20] [Modules]`` (or ``[C++23] [Modules]``, etc); and add the label ``clang:modules`` (if you have permissions for that). For higher level support for proposals, you could visit https://clang.llvm.org/cxx_status.html. Including ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:20679,wrap,wrapper,20679,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['wrap'],['wrapper']
Integrability,"arc-term:`known unretained` if it is an rvalue of :ref:`C; retainable pointer type <arc.misc.c-retainable>` and it is:. * a direct call to a function, and either that function has the; ``cf_returns_not_retained`` attribute or it is an :ref:`audited; <arc.misc.c-retainable.audit>` function that does not have the; ``cf_returns_retained`` attribute and does not follow the create/copy naming; convention,; * a message send, and the declared method either has the; ``cf_returns_not_retained`` attribute or it has neither the; ``cf_returns_retained`` attribute nor a :ref:`selector family; <arc.method-families>` that implies a retained result, or; * :when-revised:`[beginning LLVM 3.6]` :revision:`a load from a` ``const``; :revision:`non-system global variable.`. An expression is :arc-term:`known retained` if it is an rvalue of :ref:`C; retainable pointer type <arc.misc.c-retainable>` and it is:. * a message send, and the declared method either has the; ``cf_returns_retained`` attribute, or it does not have the; ``cf_returns_not_retained`` attribute but it does have a :ref:`selector; family <arc.method-families>` that implies a retained result. Furthermore:. * a comma expression is classified according to its right-hand side,; * a statement expression is classified according to its result expression, if; it has one,; * an lvalue-to-rvalue conversion applied to an Objective-C property lvalue is; classified according to the underlying message send, and; * a conditional operator is classified according to its second and third; operands, if they agree in classification, or else the other if one is known; retain-agnostic. If the cast operand is known retained, the conversion is treated as a; ``__bridge_transfer`` cast. If the cast operand is known unretained or known; retain-agnostic, the conversion is treated as a ``__bridge`` cast. .. admonition:: Rationale. Bridging casts are annoying. Absent the ability to completely automate the; management of CF objects, however, we are left ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:27192,message,message,27192,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"arc.ownership.restrictions.weak:. Weak-unavailable types; ^^^^^^^^^^^^^^^^^^^^^^. It is explicitly permitted for Objective-C classes to not support ``__weak``; references. It is undefined behavior to perform an operation with weak; assignment semantics with a pointer to an Objective-C object whose class does; not support ``__weak`` references. .. admonition:: Rationale. Historically, it has been possible for a class to provide its own; reference-count implementation by overriding ``retain``, ``release``, etc.; However, weak references to an object require coordination with its class's; reference-count implementation because, among other things, weak loads and; stores must be atomic with respect to the final release. Therefore, existing; custom reference-count implementations will generally not support weak; references without additional effort. This is unavoidable without breaking; binary compatibility. A class may indicate that it does not support weak references by providing the; ``objc_arc_weak_reference_unavailable`` attribute on the class's interface declaration. A; retainable object pointer type is **weak-unavailable** if; is a pointer to an (optionally protocol-qualified) Objective-C class ``T`` where; ``T`` or one of its superclasses has the ``objc_arc_weak_reference_unavailable``; attribute. A program is ill-formed if it applies the ``__weak`` ownership; qualifier to a weak-unavailable type or if the value operand of a weak; assignment operation has a weak-unavailable type. .. _arc.ownership.restrictions.autoreleasing:. Storage duration of ``__autoreleasing`` objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A program is ill-formed if it declares an ``__autoreleasing`` object of; non-automatic storage duration. A program is ill-formed if it captures an; ``__autoreleasing`` object in a block or, unless by reference, in a C++11; lambda. .. admonition:: Rationale. Autorelease pools are tied to the current thread and scope by their nature.; While it is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:42015,interface,interface,42015,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['interface'],['interface']
Integrability,"architecture of clang makes it straight-forward to time and; profile the cost of each layer of the stack, and the driver has a number of; options for performance analysis. Many detailed benchmarks can be found online.; Compile time performance is important, but when using clang as an API, often; memory use is even more so: the less memory the code takes the more code you can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong in the program,; highlighting related information so that it is easy to understand at a glance,; and making the wording as clear as possible.; Here is one simple example that illustrates the quality of Clang diagnostic:. $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / 42 + SomeA.X : SomeA.X);; ~~~~~~~~~~~~~~ ^ ~~~~~. Here you can see that you don't even need to see the original source code to; understand what is wrong based on the Clang error: Because Clang prints a; caret, you know exactly which plus it is complaining about. The range; information highlights the left and right side of the plus which makes it; immediately obvious what the compiler is talking about, which is very useful for; cases",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:1835,message,messages,1835,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['message'],['messages']
Integrability,"archives and file members greater than 2 and 4 GB, respectively. MakeProject. Add support for the case when the requested project/files in path that in not under the current directory; Generate the code/dictonary only for pair type that do not already have a dictionary. Object Merging; We introduced a new explicit interface for providing merging; capability. If a class has a method with the name and; signature:. Long64_t Merge(TCollection *input, TFileMergeInfo*);. it will be used by a TFileMerger (and thus by PROOF) to merge one or more; other objects into the current object. Merge should; return a negative value if the merging failed. If this method does not exist, the TFileMerger will use; a method with the name and signature:. Long64_t Merge(TCollection *input);. TClass now provides a quick access to these merging; function via TClass::GetMerge. The wrapper function; is automatically created by rootcint and can be installed; via TClass::SetMerge. The wrapper function should have; the signature/type ROOT::MergeFunc_t:. Long64_t (*)(void *thisobj, TCollection *input, TFileMergeInfo*);. We added the new Merge function to TTree and THStack.; We also added the new Merge function to TQCommand as the; existing TQCommand::Merge does not have the right; semantic (in part because TQCommand is a collection). In TFileMerger, we added a PrintLevel to allow hadd to request; more output than regular TFileMerger. We removed all hard dependencies of TFileMerger on TH1 and TTree.; (Soft dependencies still exist to be able to disable the; merging of TTrees and to be able to disable the AutoAdd; behavior of TH1). The object TFileMergeInfo can be used inside the Merge; function to pass information between runs of the Merge; (see below). In particular it contains:. TDirectory *fOutputDirectory; // Target directory where the merged object will be written.; Bool_t fIsFirst; // True if this is the first call to Merge for this series of object.; TString fOptions; // Additional text based ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v530/index.html:3258,wrap,wrapper,3258,io/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v530/index.html,1,['wrap'],['wrapper']
Integrability,"are Value_\ s, because they are; referenced by instructions like branches and can go in the switch tables.; ``BasicBlock``\ s have type ``label``. .. _m_BasicBlock:. Important Public Members of the ``BasicBlock`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``BasicBlock(const std::string &Name = """", Function *Parent = 0)``. The ``BasicBlock`` constructor is used to create new basic blocks for; insertion into a function. The constructor optionally takes a name for the; new block, and a :ref:`Function <c_Function>` to insert it into. If the; ``Parent`` parameter is specified, the new ``BasicBlock`` is automatically; inserted at the end of the specified :ref:`Function <c_Function>`, if not; specified, the BasicBlock must be manually inserted into the :ref:`Function; <c_Function>`. * | ``BasicBlock::iterator`` - Typedef for instruction list iterator; | ``BasicBlock::const_iterator`` - Typedef for const_iterator.; | ``begin()``, ``end()``, ``front()``, ``back()``,; ``size()``, ``empty()``, ``splice()``; STL-style functions for accessing the instruction list. These methods and typedefs are forwarding functions that have the same; semantics as the standard library methods of the same names. These methods; expose the underlying instruction list of a basic block in a way that is easy; to manipulate. * ``Function *getParent()``. Returns a pointer to :ref:`Function <c_Function>` the block is embedded into,; or a null pointer if it is homeless. * ``Instruction *getTerminator()``. Returns a pointer to the terminator instruction that appears at the end of the; ``BasicBlock``. If there is no terminator instruction, or if the last; instruction in the block is not a terminator, then a null pointer is returned. .. _Argument:. The ``Argument`` class; ----------------------. This subclass of Value defines the interface for incoming formal arguments to a; function. A Function maintains a list of its formal arguments. An argument has; a pointer to the parent Function.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:163408,interface,interface,163408,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['interface'],['interface']
Integrability,"are needed, they are space separated.; For example:. .. code-block:: llvm. declare i32 @printf(ptr noalias nocapture, ...); declare i32 @atoi(i8 zeroext); declare signext i8 @returns_signed_char(). Note that any attributes for the function result (``nonnull``,; ``signext``) come before the result type. Currently, only the following parameter attributes are defined:. ``zeroext``; This indicates to the code generator that the parameter or return; value should be zero-extended to the extent required by the target's; ABI by the caller (for a parameter) or the callee (for a return value).; ``signext``; This indicates to the code generator that the parameter or return; value should be sign-extended to the extent required by the target's; ABI (which is usually 32-bits) by the caller (for a parameter) or; the callee (for a return value).; ``inreg``; This indicates that this parameter or return value should be treated; in a special target-dependent fashion while emitting code for; a function call or return (usually, by putting it in a register as; opposed to memory, though some targets use it to distinguish between; two different kinds of registers). Use of this attribute is; target-specific.; ``byval(<ty>)``; This indicates that the pointer parameter should really be passed by; value to the function. The attribute implies that a hidden copy of; the pointee is made between the caller and the callee, so the callee; is unable to modify the value in the caller. This attribute is only; valid on LLVM pointer arguments. It is generally used to pass; structs and arrays by value, but is also valid on pointers to; scalars. The copy is considered to belong to the caller not the; callee (for example, ``readonly`` functions should not write to; ``byval`` parameters). This is not a valid attribute for return; values. The byval type argument indicates the in-memory value type, and; must be the same as the pointee type of the argument. The byval attribute also supports specifying an alignm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:51133,depend,dependent,51133,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependent']
Integrability,"are parameter limits. Users; should however realize that the transformation is only a linear; approximation, and that it cannot give a meaningful result if one or; more parameters is very close to a limit, where; $\frac{\partial Pext}{\partial Pint} \neq 0$. Therefore, it is; recommended that:. - Limits on variable parameters should be used only when needed in; order to prevent the parameter from taking on unphysical values. - When a satisfactory minimum has been found using limits, the; limits should then be removed if possible, in order to perform or; re-perform the error analysis without limits. ### How to Get the Right Answer from Minuit. `Minuit` offers the user a choice of several minimization algorithms.; The `MIGRAD` algorithm is in general the best minimized for nearly all; functions. It is a variable-metric method with inexact line search, a; stable metric updating scheme, and checks for positive-definiteness.; Its main weakness is that it depends heavily on knowledge of the first; derivatives, and fails miserably if they are very inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. #### Getting the Right Minimum with Limits. If MIGRAD converges normally to a point where no parameter is near one; of its limits, then the existence of limits has probably not prevented; `Minuit` from finding the right minimum. On the other hand, if one or; more parameters is near its limit at the minimum, this may be because; the true minimum is indeed at a limit, or it may be because the; minimized has become ''blocked'' at a limit. This may normally happen; only if the parameter is so close to a limit (internal value at an odd; multiple of $\pm \frac{\pi}{2}$ that `Minuit` prints a warning to this; effect when it prints the parameter values. The minimized can become; blocked at a limit, because at a limit the derivative seen by the; minimized $\frac{\part",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:57793,depend,depends,57793,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['depend'],['depends']
Integrability,"are parsing is a string. The second and third parameters (which are optional) are used to specify what to; output for the ""``-help``"" option. In this case, we get a line that looks like; this:. ::. USAGE: compiler [options]. OPTIONS:; -h - Alias for -help; -help - display available options (-help-hidden for more); -o <filename> - Specify output filename. Because we specified that the command line option should parse using the; ``string`` data type, the variable declared is automatically usable as a real; string in all contexts that a normal C++ string object may be used. For; example:. .. code-block:: c++. ...; std::ofstream Output(OutputFilename.c_str());; if (Output.good()) ...; ... There are many different options that you can use to customize the command line; option handling library, but the above example shows the general interface to; these options. The options can be specified in any order, and are specified; with helper functions like `cl::desc(...)`_, so there are no positional; dependencies to remember. The available options are discussed in detail in the; `Reference Guide`_. Continuing the example, we would like to have our compiler take an input; filename as well as an output filename, but we do not want the input filename to; be specified with a hyphen (ie, not ``-filename.c``). To support this style of; argument, the CommandLine library allows for `positional`_ arguments to be; specified for the program. These positional arguments are filled with command; line parameters that are not in option form. We use this feature like this:. .. code-block:: c++. cl::opt<string> InputFilename(cl::Positional, cl::desc(""<input file>""), cl::init(""-""));. This declaration indicates that the first positional argument should be treated; as the input filename. Here we use the `cl::init`_ option to specify an initial; value for the command line option, which is used if the option is not specified; (if you do not specify a `cl::init`_ modifier for an option, then the defau",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:6454,depend,dependencies,6454,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['depend'],['dependencies']
Integrability,"are printed in the appropriate style, rather than printing to; stderr directly. When using ``report_fatal_error``, follow the same standards for the message as; regular error messages. Assertion messages and ``llvm_unreachable`` calls do not; necessarily need to follow these same styles as they are automatically; formatted, and thus these guidelines may not be suitable. ``#include`` Style; ^^^^^^^^^^^^^^^^^^. Immediately after the `header file comment`_ (and include guards if working on a; header file), the `minimal list of #includes`_ required by the file should be; listed. We prefer these ``#include``\s to be listed in this order:. .. _Main Module Header:; .. _Local/Private Headers:. #. Main Module Header; #. Local/Private Headers; #. LLVM project/subproject headers (``clang/...``, ``lldb/...``, ``llvm/...``, etc); #. System ``#include``\s. and each category should be sorted lexicographically by the full path. The `Main Module Header`_ file applies to ``.cpp`` files which implement an; interface defined by a ``.h`` file. This ``#include`` should always be included; **first** regardless of where it lives on the file system. By including a; header file first in the ``.cpp`` files that implement the interfaces, we ensure; that the header does not have any hidden dependencies which are not explicitly; ``#include``\d in the header, but should be. It is also a form of documentation; in the ``.cpp`` file to indicate where the interfaces it implements are defined. LLVM project and subproject headers should be grouped from most specific to least; specific, for the same reasons described above. For example, LLDB depends on; both clang and LLVM, and clang depends on LLVM. So an LLDB source file should; include ``lldb`` headers first, followed by ``clang`` headers, followed by; ``llvm`` headers, to reduce the possibility (for example) of an LLDB header; accidentally picking up a missing include due to the previous inclusion of that; header in the main source file or some earl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:16351,interface,interface,16351,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['interface'],['interface']
Integrability,"argetLowering::; lowerJumpTable(SDValue Op, SelectionDAG &DAG) const. calls. template <class NodeTy> // lib/Target/Mips/MipsISelLowering.h; SDValue getAddrLocal(NodeTy *N, const SDLoc &DL, EVT Ty,; SelectionDAG &DAG, bool IsN32OrN64) const. which calls the overloaded function:. // lib/Target/Mips/MipsISelLowering.h; SDValue getTargetNode(JumpTableSDNode *N, EVT Ty, SelectionDAG &DAG,; unsigned Flag) const;. 2. Generic address nodes are lowered to some combination of target; independent and machine specific SDNodes (for example:; MipsISD::{Highest, Higher, Hi, Lo}) depending upon relocation model,; ABI, and compilation options. The choice of specific instructions that are to be used is delegated; to ISel which in turn relies on TableGen patterns to choose subtarget; specific instructions. For example, in getAddrLocal, the pseudo-code; generated is:. (add (load (wrapper $gp, %got(sym)), %lo(sym)). where ""%lo"" represents an instance of an SDNode with opcode; ""MipsISD::Lo"", ""wrapper"" indicates one with opcode ""MipsISD::Wrapper"",; and ""%got"" the global table pointer ""getGlobalReg(...)"". The ""add"" is; ""ISD::ADD"", not a target dependent one. 3. A TableGen multiclass pattern ""MipsHiLoRelocs"" is used to define a; template pattern parameterized over the load upper immediate; instruction, add operation, the zero register, and register class.; Here the instantiation of MipsHiLoRelocs in MipsInstrInfo.td is used; to MIPS32 to compute addresses for the static relocation model. // lib/Target/Mips/MipsInstrInfo.td; multiclass MipsHiLoRelocs<Instruction Lui, Instruction Addiu,; Register ZeroReg, RegisterOperand GPROpnd> {; def : MipsPat<(MipsHi tglobaladdr:$in), (Lui tglobaladdr:$in)>;; ...; def : MipsPat<(MipsLo tglobaladdr:$in), (Addiu ZeroReg, tglobaladdr:$in)>;; ...; def : MipsPat<(add GPROpnd:$hi, (MipsLo tglobaladdr:$lo)),; (Addiu GPROpnd:$hi, tglobaladdr:$lo)>;; ...; }; defm : MipsHiLoRelocs<LUi, ADDiu, ZERO, GPR32Opnd>;. // lib/Target/Mips/Mips64InstrInfo.td; defm : MipsHiLoR",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt:1649,wrap,wrapper,1649,interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Relocation.txt,1,['wrap'],['wrapper']
Integrability,"argument can be either ""READ"" or; ""UPDATE"". The method returns:. - 0 in case the mode was successfully modified;. - 1 in case the mode did not change (it was already as requested or; there were wrong input arguments);. - -1 in case of failure. In the last case the file cannot be used; anymore. ## Remotely Access to ROOT Files. ROOT files can be accessed remotely in many ways, on the base of the protocol; URL. Among the most popular are XRootD (protocols 'root://' and 'xrd://') and; a Web server (protocl 'http://' or 'https://'). The rootd daemon is deprecated and has been removed in version 6.16/00. Please refer to the XRootD documentation for starting and ensuring that such a; daemon is running. Reading and writing ROOT files over the net can be done by creating a; **`TFile`** object using the static method **`TFile::Open()`** object.; This will instantiate the appropriate derivation of **`TFile`** to handle the; request. Inheriting from the **`TFile`** class, the returned instance will have; exactly the same interface and behavior of **`TFile`**. The only difference; is that it reads and writes from a remote service.; In the example below the file is read via a web server through the TDavixFile plug-in. ### A Simple Session. ``` {.cpp}; root[] TFile *f1 = TFile::Open(""local/file.root"",""update""); root[] TFile *f2 = TFile::Open(""root://my.server.org/data/file.root"",""new""); root[] TFile *f3 = TFile::Open(""http://root.cern.ch/files/hsimple.root""); root[] f3.ls(); TDavixFile** http://root.cern.ch/files/hsimple.root; TDavixFile* http://root.cern.ch/files/hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; root[] hpx.Draw(); ```. ## XML Interface. A new module `xml` as implemented by Sergey Linev (GSI). It is an; optional package that can be used to save a canvas into `file.xml` file; format instead of `file.root`. XML files do not have any advantages; com",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:96229,interface,interface,96229,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['interface'],['interface']
Integrability,"arguments; so that ADL applies.; For more information about argument-dependent lookup, see; [basic.lookup.argdep]. For more information about the ordering of; lookup in templates, see [temp.dep.candidate]. Unqualified lookup into dependent bases of class templates. Some versions of GCC accept the following invalid code:. template <typename T> struct Base {; void DoThis(T x) {}; static void DoThat(T x) {}; };. template <typename T> struct Derived : public Base<T> {; void Work(T x) {; DoThis(x); // Invalid!; DoThat(x); // Invalid!; }; };. Clang correctly rejects it with the following errors; (when Derived is eventually instantiated):. my_file.cpp:8:5: error: use of undeclared identifier 'DoThis'; DoThis(x);; ^; this->; my_file.cpp:2:8: note: must qualify identifier to find this declaration in dependent base class; void DoThis(T x) {}; ^; my_file.cpp:9:5: error: use of undeclared identifier 'DoThat'; DoThat(x);; ^; this->; my_file.cpp:3:15: note: must qualify identifier to find this declaration in dependent base class; static void DoThat(T x) {}. Like we said above, unqualified names like; DoThis and DoThat are looked up when the template; Derived is defined, not when it's instantiated. When we look; up a name used in a class, we usually look into the base classes.; However, we can't look into the base class Base<T>; because its type depends on the template argument T, so the; standard says we should just ignore it. See [temp.dep]p3 for details. The fix, as Clang tells you, is to tell the compiler that we want a; class member by prefixing the calls with this->:. void Work(T x) {; this->DoThis(x);; this->DoThat(x);; }. Alternatively, you can tell the compiler exactly where to look:. void Work(T x) {; Base<T>::DoThis(x);; Base<T>::DoThat(x);; }. This works whether the methods are static or not, but be careful:; if DoThis is virtual, calling it this way will bypass virtual; dispatch!. Incomplete types in templates. The following code is invalid, but compilers are allowed t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:16693,depend,dependent,16693,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['depend'],['dependent']
Integrability,"ariables set in macros will bleed out into the calling; scope. That makes macros suitable for defining very small bits of functionality; only. The other difference between CMake functions and macros is how arguments are; passed. Arguments to macros are not set as variables, instead dereferences to; the parameters are resolved across the macro before executing it. This can; result in some unexpected behavior if using unreferenced variables. For example:. .. code-block:: cmake. macro(print_list my_list); foreach(var IN LISTS my_list); message(""${var}""); endforeach(); endmacro(). set(my_list a b c d); set(my_list_of_numbers 1 2 3 4); print_list(my_list_of_numbers); # prints:; # a; # b; # c; # d. Generally speaking this issue is uncommon because it requires using; non-dereferenced variables with names that overlap in the parent scope, but it; is important to be aware of because it can lead to subtle bugs. LLVM Project Wrappers; =====================. LLVM projects provide lots of wrappers around critical CMake built-in commands.; We use these wrappers to provide consistent behaviors across LLVM components; and to reduce code duplication. We generally (but not always) follow the convention that commands prefaced with; ``llvm_`` are intended to be used only as building blocks for other commands.; Wrapper commands that are intended for direct use are generally named following; with the project in the middle of the command name (i.e. ``add_llvm_executable``; is the wrapper for ``add_executable``). The LLVM ``add_*`` wrapper functions are; all defined in ``AddLLVM.cmake`` which is installed as part of the LLVM; distribution. It can be included and used by any LLVM sub-project that requires; LLVM. .. note::. Not all LLVM projects require LLVM for all use cases. For example compiler-rt; can be built without LLVM, and the compiler-rt sanitizer libraries are used; with GCC. Useful Built-in Commands; ========================. CMake has a bunch of useful built-in commands. This do",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:13161,wrap,wrappers,13161,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['wrap'],['wrappers']
Integrability,"ary instead. For example, a RooCategory can be created like this:; ```Python; sample = ROOT.RooCategory(""sample"", ""sample"", {""Sample1"": 1, ""Sample2"": 2, ""Sample3"": 3}); ```. #### RooWorkspace accessors. In Python, you can now get objects stored in a [RooWorkspace](https://root.cern/doc/v626/classRooWorkspace.html) with the item retrieval operator, and the return value is also always downcasted to the correct type. That means in Python you don't have to use [RooWorkspace::var()](https://root.cern/doc/v626/classRooWorkspace.html#acf5f9126ee264c234721a4ed1f9bf837) to access variables or [RooWorkspace::pdf()](https://root.cern/doc/v626/classRooWorkspace.html#afa7384cece424a1a94a644bb05549eee) to access pdfs, but you can always get any object using square brackets. For example:; ```Python; # w is a RooWorkspace instance that contains the variables `x`, `y`, and `z` for which we want to generate toy data:; model.generate({w[""x""], w[""y""], w[""z""]}, 1000); ```. ### New PyROOT functions for interoperability with NumPy and Pandas. New member functions of RooFit classes were introduced exclusively to PyROOT for better interoperability between RooFit and Numpy and Pandas:. - `RooDataSet.from_numpy`: Import a RooDataSet from a dictionary of numpy arrays (static method); - `RooDataSet.to_numpy`: Export a RooDataSet to a dictionary of numpy arrays; - `RooDataSet.from_pandas`: Import a RooDataSet from a Pandas dataframe (static method); - `RooDataSet.to_pandas`: Export a RooDataSet to a Pandas dataframe; - `RooDataHist.from_numpy`: Import a RooDataHist from numpy arrays with histogram counts and bin edges (static method); - `RooDataHist.to_numpy`: Export a RooDataHist to numpy arrays with histogram counts and bin edges; - `RooRealVar.bins`: Get bin boundaries for a `RooRealVar` as a NumPy array. For more details, consult the tutorial [rf409_NumPyPandasToRooFit.py](https://root.cern/doc/v626/rf409__NumPyPandasToRooFit_8C.html). ### Modeling Effective Field Theory distributions with Ro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:22637,interoperab,interoperability,22637,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['interoperab'],['interoperability']
Integrability,"as been successfully imported, you can view the geometry by; calling:. ~~~ {.cpp}; gGeoManager->GetTopVolume()->Draw(""ogl"");; ~~~. For any questions or comments about the GDML->ROOT binding please contact ben.lloyd@cern.ch. ### ROOT->GDML. The TGeo to GDML converter allows to export ROOT geometries (TGeo; geometry trees) as GDML files. The writer module writes a GDML file; out of the 'in-memory' representation of the geometry. The actual; application-specific (ROOT) binding is implemented in ROOTwriter; module. It contains 'binding methods' for TGeo geometry classes which; can be exported in GDML format. Please refere to the comment part of; the ROOTwriter.py file for the list of presently supported TGeo; classes. The ROOTwriter class contains also three methods,; dumpMaterials, dumpSolids and examineVol which need to be called in; order to export materials, solids and geometry tree respectively. The TGeo to GDML converter is now interfaced to the; TGeoManager::Export method which automatically calls the appropriate; Python scripts whenever the geometry output file has the .gdml; extension. Alternatively, one can also use the ROOT->GDML converter directly from; the Python prompt (assuming the TGeo geometry has already been loaded; into memory in one or another way), for example:. ~~~ {.cpp}; from math import *. import ROOT; import writer; import ROOTwriter. # get TGeoManager and; # get the top volume of the existing (in-memory) geometry tree; geomgr = ROOT.gGeoManager; topV = geomgr.GetTopVolume(). # instanciate writer; gdmlwriter = writer.writer('mygeo.gdml'); binding = ROOTwriter.ROOTwriter(gdmlwriter). # dump materials; matlist = geomgr.GetListOfMaterials(); binding.dumpMaterials(matlist). # dump solids; shapelist = geomgr.GetListOfShapes(); binding.dumpSolids(shapelist). # dump geo tree; print 'Traversing geometry tree'; gdmlwriter.addSetup('default', '1.0', topV.GetName()); binding.examineVol(topV). # write file; gdmlwriter.writeFile(); ~~~. For all other funct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md:2519,interface,interfaced,2519,geom/gdml/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/doc/index.md,1,['interface'],['interfaced']
Integrability,"as by using the statement:. ``` {.cpp}; object.Draw(); ```. This instructs the object ""`object`"" to draw itself. If no canvas is; opened, a default one (named ""`c1`"") is created. In the next example,; the first statement defines a function and the second one draws it. A; default canvas is created since there was no opened one. You should; see the picture as shown in the next figure. ``` {.cpp}; root[] TF1 f1(""func1"",""sin(x)/x"",0,10); root[] f1.Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; ```. ![A canvas with drawing](pictures/0300000A.png). The following components comprise the canvas window:. - Menu bar - contains main menus for global operations with files,; print, clear canvas, inspect, etc. - Tool bar - has buttons for global and drawing operations; such as; arrow, ellipse, latex, pad, etc. - Canvas - an area to draw objects. - Status bar - displays descriptive messages about the selected; object. - Editor frame - responds dynamically and presents the user; interface according to the selected object in the canvas. ### Main Menus and Toolbar. At the top of the canvas window are File, Edit, View, Options,; Inspect, Classes and Help menus. #### File Menu. - *New Canvas*: creates a new canvas window in the current ROOT; session. - *Open...*: popup a dialog to open a file. - *Close Canvas*: close the canvas window. - *Save*: save the drawing of the current canvas in a format; selectable from the submenu. The current canvas name is used as a; file name for various formats such as PostScript, GIF, JPEG, C; macro file, root file. - *Save As...*: popup a dialog for saving the current canvas drawing; in a new filename. - *Print*: popup a dialog to print the current canvas drawing. - *Quit ROOT*: exit the ROOT session. ![](pictures/0300000B.png). #### Edit Menu. There is only one active menu entry in the Edit menu. The others menu; entries will be implemented and will become active in the near future. - *Clear:* delete all objects in the canvas; o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:7369,interface,interface,7369,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['interface'],['interface']
Integrability,"as de facto disactivating the cache; the; other was causing a std::bad_alloc exception to be thrown on workers; when opening a remote file after a local one.    ; Fix several problems in TChain::Draw including. drawing into an existing histogram, i.e.; chain->Draw(""var>>myhist"");. treatment of histogram merging in case of small; statistics, i.e. when; the autobinning is not or only partially active;. usage of existing canvases when different histogram; names are specified;. Fix a problem causing a duplication of the final feedback; object. Fix problem with determining the subdir name in; TFileMerger::MergeRecursive on Windows; Make sure that the default sandbox is under $HOME/.proof; Fix a problem with dataset validation in multi-level; master setups; Fix a problem with ordinal numbers in multi-master setups; Fix a problem with defining the internal paths for; executables when configuring with '--prefix'; Fix backward-incompatibility issue giving the error; message  ""unknown action code: 5112""; Fix a few problems with file retrieval from the cache; Fix a problem with iteration of a std::list occasionally; causing seg-violations in TXSocket; Fix a few problems preventing correct usage of entry; lists in PROOF; Fix a problem with the permissions of the credentials; files created under <sandbox>/.creds; Fix a potential problem while determining the log paths; in log retrieval. Do not use vnsprintf in the XrdProofd plug-in, potential; source of deadlocks.; Fix a problem overwriting the local environment settings; for the xrootd sec modules; In XrdProofdProofServMgr::Destroy, fix segv in message; creation when all sessions are destroyed at once; Fix a problem determining the relative time order of old; sessions for log retrieval; In TProof::HandleInputMessage, fix possible double delete; after kPROOF_STOPPROCESS; Fix a couple of issues on reconnection to a running; session (some dialog buttons not in the correct state; logs not; correctly redirected); Fix a problem creati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:9691,message,message,9691,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['message'],['message']
Integrability,"as. Dump additional information from the TPI stream, such as hashes and the type; index offsets array. .. option:: -type-data. For each type record dumped, display the full bytes of the record in binary as; well. .. option:: -type-index=<uint>. Only dump types with the specified type index. .. option:: -ids. Dump CodeView type records from IPI stream. .. option:: -id-extras. Dump additional information from the IPI stream, such as hashes and the type; index offsets array. .. option:: -id-data. For each ID record dumped, display the full bytes of the record in binary as; well. .. option:: -id-index=<uint>. only dump ID records with the specified hexadecimal type index. .. option:: -dependents. When used in conjunction with :option:`-type-index` or :option:`-id-index`,; dumps the entire dependency graph for the specified index instead of just the; single record with the specified index. For example, if type index 0x4000 is; a function whose return type has index 0x3000, and you specify; `-dependents=0x4000`, then this would dump both records (as well as any other; dependents in the tree). Miscellaneous Options; +++++++++++++++++++++. .. option:: -all. Implies most other options. .. option:: -section-contribs. Dump section contributions. .. option:: -section-headers. Dump image section headers. .. option:: -section-map. Dump section map. .. option:: -string-table. Dump PDB string table. .. _bytes_subcommand:. bytes; ~~~~~. USAGE: :program:`llvm-pdbutil` bytes [*options*] <input PDB file>. .. program:: llvm-pdbutil bytes. Summary; ^^^^^^^. Like the **dump** subcommand, the **bytes** subcommand displays low level; information about the structure of a PDB file, but it is used for even deeper; forensics. The **bytes** subcommand finds various structures in a PDB file; based on the command line options specified, and dumps them in hex. Someone; working on support for emitting PDBs would use this heavily, for example, to; compare one PDB against another PDB to ensure byte-fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst:10284,depend,dependents,10284,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,2,['depend'],['dependents']
Integrability,"ase that a distributed computation graph could be defined with; code that was not yet available on the user's local application, but that would only become available in the; distributed worker. Now a call such as `df.Define(""mycol"", ""return run_my_fun();"")` needs to be at least declarable; to the interpreter also locally so that the column can be properly tracked. ## Histogram Libraries. ### Upgrade TUnfold to version 17.9. The [TUnfold package](https://www.desy.de/~sschmitt/tunfold.html) inside ROOT is upgraded from version 17.6 to version 17.9. ## Math Libraries. ### Usage of `std::span<const double>` in Minuit 2 interfaces. To avoid forcing the user to do manual memory allocations via `std::vector`, the interfaces of Minuit 2 function adapter classes like `ROOT::Minuit2::FCNBase` or `ROOT::Minuit2::FCNGradientBase` were changed to accept `std::span<const double>` arguments instead of `std::vector<double> const&`.; This should have minimal impact on users, since one should usual use Minuit 2 via the `ROOT::Math::Minimizer` interface, which is unchanged. ## RooFit Libraries. ### Miscellaneous. * Setting `useHashMapForFind(true)` is not supported for RooArgLists anymore, since hash-assisted finding by name hash can be ambiguous: a RooArgList is allowed to have different elements with the same name. If you want to do fast lookups by name, convert your RooArgList to a RooArgSet. * The function `RooFit::bindFunction()` now supports arbitrary many input variables when binding a Python function. * The `ExportOnly()` attribute of the `RooStats::HistFactory::Measurement` object is now switched on by default, and the associated getter and setter functions are deprecated. They will be removed in ROOT 6.36. If you want to fit the model as well instead of just exporting it to a RooWorkspace, please do so with your own code as demonstrated in the `hf001` tutorial. ### Deprecations. * The `RooStats::MarkovChain::GetAsDataSet` and `RooStats::MarkovChain::GetAsDataHist` functions ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md:4667,interface,interface,4667,README/ReleaseNotes/v634/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md,1,['interface'],['interface']
Integrability,"aseWrite; """"""""""""""""""""""""""""""""""""""""""""""""""""; Warn about potentially crashing writes to autoreleasing objects from different autoreleasing pools in Objective-C. .. _osx-cocoa-ClassRelease:. osx.cocoa.ClassRelease (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for sending 'retain', 'release', or 'autorelease' directly to a Class. .. code-block:: objc. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. .. _osx-cocoa-Dealloc:. osx.cocoa.Dealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C classes that lack a correct implementation of -dealloc. .. literalinclude:: checkers/dealloc_example.m; :language: objc. .. _osx-cocoa-IncompatibleMethodTypes:. osx.cocoa.IncompatibleMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C method signatures with type incompatibilities. .. code-block:: objc. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. .. _osx-cocoa-Loops:. osx.cocoa.Loops; """"""""""""""""""""""""""""""; Improved modeling of loops using Cocoa collection types. .. _osx-cocoa-MissingSuperCall:. osx.cocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a necessary call to super. .. code-block:: objc. @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. .. _osx-cocoa-NSAutoreleasePool:. osx.cocoa.NSAutoreleasePool (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn for suboptimal uses of NSAutoreleasePool in Objective-C GC mode. .. code-block:: objc. void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. .. _osx-cocoa-NSError:. osx.cocoa.NSError (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Check usage of NSError parameters. .. code-block:: objc. @interface A : NSObject; - (void)foo:(NSError """"""""""""""""""""""""""""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:37377,interface,interface,37377,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['interface'],['interface']
Integrability,"asic support for C++ and Objective-C++ that is ready to be tried out; by general users. It is still in its infancy, but establishes a baseline for things to come. The main hope is that it can find some; issues and have a reasonable false positive rate.; Please file bugs when you see issues of any kind so we can assess; where development on C++ analysis support needs to be focused.; To try out C++ analysis support, it should work out of the box using scan-build. If you are using this checker build; as a replacement to the analyzer bundled with Xcode, first use the set-xcode-analyzer script to change Xcode to use; your version of the analyzer. You will then need to modify one configuration file in Xcode to enable C++ analysis support. This can; be done with the following steps:. Find the clang .xcspec file:; $ cd /Developer/Library; $ find . | grep xcspec | grep Clang; ./Xcode/<SNIP>/Clang LLVM 1.0.xcplugin/Contents/Resources/Clang LLVM 1.0.xcspec. The exact location of the file may vary depending on your installation of Xcode. Edit that file, and look for the string ""--analyze"":. SourceFileOption = ""--analyze"";; FileTypes = (; ""sourcecode.c.c"",; ""sourcecode.c.objc"",; );; ... Change the ""FileTypes"" entry to:. FileTypes = (; ""sourcecode.c.c"",; ""sourcecode.c.objc"",; ""sourcecode.cpp.cpp"",; ""sourcecode.cpp.objcpp"",; );. Restart Xcode. checker-255; built: February 11, 2011; highlights:. Mac OS X builds are now Intel i386 and x86_64 only (no ppc support); Turns on new -init method checker by default; Reduces memory usage of analyzer by 10%; Misc. fixes to reduce false positives on dead stores and idempotent operations. checker-254; built: January 27, 2011; highlights:. Introduces new -init method checker to check if a super class's init method is properly called.; Objective-C retain/release checker now reasons about calls to property accessor methods (setter/getter).; Introduces new attribute ns_consumes_self to educate the Objective-C retain/release checker about custom ""in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html:12382,depend,depending,12382,interpreter/llvm-project/clang/www/analyzer/release_notes.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html,1,['depend'],['depending']
Integrability,"asis but are allowed to; replace the intrinsic with its first argument without breaking semantics and the; intrinsic is completely dropped during instruction selection. '``llvm.codeview.annotation``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This annotation emits a label at its program point and an associated; ``S_ANNOTATION`` codeview record with some additional string metadata. This is; used to implement MSVC's ``__annotation`` intrinsic. It is marked; ``noduplicate``, so calls to this intrinsic prevent inlining and should be; considered expensive. ::. declare void @llvm.codeview.annotation(metadata). Arguments:; """""""""""""""""""". The argument should be an MDTuple containing any number of MDStrings. '``llvm.trap``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.trap() cold noreturn nounwind. Overview:; """""""""""""""""". The '``llvm.trap``' intrinsic. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic is lowered to the target dependent trap instruction. If; the target does not have a trap instruction, this intrinsic will be; lowered to a call of the ``abort()`` function. '``llvm.debugtrap``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.debugtrap() nounwind. Overview:; """""""""""""""""". The '``llvm.debugtrap``' intrinsic. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". This intrinsic is lowered to code which is intended to cause an; execution trap with the intention of requesting the attention of a; debugger. '``llvm.ubsantrap``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.ubsantrap(i8 immarg) cold noreturn nounwind. Overview:; """""""""""""""""". The '``llvm.ubsantrap``' intrinsic. Arguments:; """""""""""""""""""". An integer describing the kind of failure detected. Semantics:; """""""""""""""""""". This intrinsic is lowered to code which is intended to cause an execution trap,; embedding the argument into encoding of that trap somehow to discriminate;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:928470,depend,dependent,928470,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependent']
Integrability,"ask.distributed import Client; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame. # In a Python script the Dask client needs to be initalized in a context; # Jupyter notebooks / Python session don't need this; if __name__ == ""__main__"":; client = Client(""SCHEDULER_ADDRESS""); df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); # Proceed as usual; df.Define(""x"",""someoperation"").Histo1D(""x""); ```. Other notable additions and improvements include:. - Enable triggering multiple distributed computation graphs through `RunGraphs`. This also allows sending both Spark and Dask jobs at the same time through a single function call.; - Greatly reduce distributed tasks processing overhead in TTree-based analyses by refactoring the translation from task metadata to RDataFrame object on the workers.; - Refactor triggering of the computation graph in the distributed tasks, so that it now runs with the Python GIL released. This allows interoperability with frameworks like Dask that run different Python threads along the main processing one.; - Set minimum Python version to use this tool to 3.7. This allows using more modern Python functionality in distributed RDataFrame code and is in line with the Python support provided by Spark and Dask.; - Add support for the following operations:; - `DefinePerSample`; - `HistoND`; - `Redefine`; - Make sure a user-provided `npartitions` parameter to a distributed RDataFrame constructor always takes precedence over the value computed by default.; - Improve support for friend trees in distributed executions, now any kind of friendship layout between the main tree and the friend tree(s) is expected to work.; - Add support for TChain data sources with no tree name and multiple different tree subnames.; - Creating a distributed RDataFrame with an in-memory-only tree is prohibited, thus such usage now raises an error at runtime. ## Histogram Libraries. - Implement the `SetStats` method for `TGraph` to turn ON or OFF the statistics",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:11547,interoperab,interoperability,11547,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['interoperab'],['interoperability']
Integrability,ass prvalues in reference initialization; Unknown. 1651; NAD; Lifetime extension of temporary via reference to subobject; Unknown. 1652; CD4; Object addresses in constexpr expressions; Clang 3.6. 1653; CD4; Removing deprecated increment of bool; Clang 4 (C++17 onwards). 1654; dup; Literal types and constexpr defaulted constructors; Unknown. 1655; drafting; Line endings in raw string literals; Not resolved. 1656; CD6; Encoding of numerically-escaped characters; Unknown. 1657; CD4; Attributes for namespaces and enumerators; Unknown. 1658; C++14; Deleted default constructor for abstract class via destructor; Clang 5. 1659; open; Initialization order of thread_local template static data members; Not resolved. 1660; C++14; member-declaration requirements and unnamed bit-fields; Unknown. 1661; NAD; Preservation of infinite loops; Unknown. 1662; C++14; Capturing function parameter packs; Unknown. 1663; NAD; Capturing an empty pack expansion; Unknown. 1664; C++14; Argument-dependent lookup of lambdas used in default arguments; Unknown. 1665; drafting; Declaration matching in explicit instantiations; Not resolved. 1666; C++14; Address constant expressions; Unknown. 1667; NAD; Function exiting via exception called by destructor during unwinding; Unknown. 1668; drafting; Parameter type determination still not clear enough; Not resolved. 1669; C++14; auto return type for main; Unknown. 1670; drafting; auto as conversion-type-id; Not resolved. 1671; NAD; Unclear rules for deduction with cv-qualification; Unknown. 1672; CD4; Layout compatibility with multiple empty bases; Clang 7. 1673; C++14; Clarifying overload resolution for the second step of copy-initialization; Unknown. 1674; C++14; Return type deduction for address of function; Unknown. 1675; NAD; Size limit for automatic array object; Unknown. 1676; drafting; auto return type for allocation and deallocation functions; Not resolved. 1677; C++17; Constant initialization via aggregate initialization; Unknown. 1678; NAD; Nami,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:112505,depend,dependent,112505,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"ass which is intended to run as part of the main loop pass; pipeline needs to preserve all of the same *function* analyses that the other; loop passes in its pipeline require. To make that easier,; a ``getLoopAnalysisUsage`` function is provided by ``LoopUtils.h``. It can be; called within the subclass's ``getAnalysisUsage`` override to get consistent; and correct behavior. Analogously, ``INITIALIZE_PASS_DEPENDENCY(LoopPass)``; will initialize this set of function analyses. The ``doInitialization(Loop *, LPPassManager &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(Loop *, LPPassManager &LPM);. The ``doInitialization`` method is designed to do simple initialization type of; stuff that does not depend on the functions being processed. The; ``doInitialization`` method call is not scheduled to overlap with any other; pass executions (thus it should be very fast). ``LPPassManager`` interface; should be used to access ``Function`` or ``Module`` level analysis information. .. _writing-an-llvm-pass-runOnLoop:. The ``runOnLoop`` method; ^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnLoop(Loop *, LPPassManager &LPM) = 0;. The ``runOnLoop`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a ``true`` value; should be returned if the function is modified. ``LPPassManager`` interface; should be used to update loop nest. The ``doFinalization()`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization();. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnLoop; <writing-an-llvm-pass-runOnLoop>` for every loop in the program being compiled. .. _writing-an-llvm-pass-RegionPass:. The ``RegionPass`` class; ------------------------. ``RegionPass`` is similar to :ref:`LoopPass <writing-an-llvm-pass-LoopPass>`,; but execute",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:21797,interface,interface,21797,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['interface'],['interface']
Integrability,"ass, which is a direct conversion from FORTRAN to C++,; `Minuit2` is a complete redesign and re-implementation of the package.; This new version provides all the functionality present in the old; FORTRAN version, with almost equivalent numerical accuracy and; computational performances.; Furthermore, it contains some fixes and small improvements and this new functionality:; * The possibility to set single side parameter limits; * the FUMILI algorithm (see the next paragraph ""FUMILI Minimization Package""),; which is an optimized method for least square and log; likelihood minimizations. Minuit2 has been originally developed by M.; Winkler and F. James in the SEAL project. More information can be found; on the [MINUIT Web Site](MINUIT Web Site) and in particular at the; following documentation page at; <http://www.cern.ch/minuit/doc/doc.html>. A detailed User Guide for Minuit2 exists, describing the API of the internal classes.; ROOT uses `Minuit2` for fitting via the `Minuit2Minimizer` class which implements; the `ROOT::Math::Minimizer` interface. `Minuit2` is also distributed as an independent package of ROOT and can be built; without any other dependency on the ROOT libraries. Examples on how to use the `Minuit2` and `Fumili2` plug-ins are provided; in the tutorials' directory `$ROOTSYS/tutorials/fit`:; `minuit2FitBench.C`, `minuit2FitBench2D.C` and `minuit2GausFit.C`.; More information on the classes and functions present in `Minuit2` is; available at; [online reference documentation](online reference documentation). Useful information on MINUIT and minimization in general is provided in the; following documents:. F. James, *Minuit Tutorial on Function Minimization* (; <http://seal.cern.ch/documents/minuit/mntutorial.pdf>); F. James, *The; Interpretation of Errors in Minuit* (; <http://seal.cern.ch/documents/minuit/mnerror.pdf>);. ## FUMILI Minimization Package. FUMILI is used to minimize Chi-square function or to search maximum of; likelihood function. Experimenta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:65810,interface,interface,65810,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['interface'],['interface']
Integrability,ass-depends}). # Test RModelParser_PyTorch. ROOT_ADD_GTEST(TestRModelParserPyTorch TestRModelParserPyTorch.C; LIBRARIES; ROOTTMVASofie; TMVA; Python3::NumPy; Python3::Python; INCLUDE_DIRS; SYSTEM; ${CMAKE_CURRENT_BINARY_DIR}; ); target_link_libraries(TestRModelParserPyTorch ${BLAS_LINKER_FLAGS} ${BLAS_LIBRARIES}). endif(PY_TORCH_FOUND). if((PY_KERAS_FOUND AND PY_THEANO_FOUND) OR (PY_KERAS_FOUND AND PY_TENSORFLOW_FOUND)); configure_file(generateKerasModels.py generateKerasModels.py COPYONLY); configure_file(scale_by_2_op.hxx scale_by_2_op.hxx COPYONLY). if (PY_TORCH_FOUND); set(PyMVA-Keras-Classification-depends PyMVA-Torch-Classification); set(PyMVA-Keras-Regression-depends PyMVA-Torch-Regression); set(PyMVA-Keras-Multiclass-depends PyMVA-Torch-Multiclass); endif(). # Test PyKeras: Binary classification; ROOT_EXECUTABLE(testPyKerasClassification testPyKerasClassification.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Keras-Classification COMMAND testPyKerasClassification DEPENDS ${PyMVA-Keras-Classification-depends}). # Test PyKeras: Regression; if (NOT ROOT_ARCHITECTURE MATCHES macosx); #veto also keras tutorial on macos due to issue in disabling eager execution on macos; ROOT_EXECUTABLE(testPyKerasRegression testPyKerasRegression.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Keras-Regression COMMAND testPyKerasRegression DEPENDS ${PyMVA-Keras-Regression-depends}); endif(). # Test PyKeras: Multi-class classification; ROOT_EXECUTABLE(testPyKerasMulticlass testPyKerasMulticlass.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Keras-Multiclass COMMAND testPyKerasMulticlass DEPENDS ${PyMVA-Keras-Multiclass-depends}). ROOT_ADD_GTEST(TestRModelParserKeras TestRModelParserKeras.C; LIBRARIES; ROOTTMVASofie; PyMVA; Python3::NumPy; Python3::Python; INCLUDE_DIRS; SYSTEM; ${CMAKE_CURRENT_BINARY_DIR}; ); target_link_libraries(TestRModelParserKeras ${BLAS_LINKER_FLAGS} ${BLAS_LIBRARIES}). endif((PY_KERAS_FOUND AND PY_THEANO_FOUND) OR (PY_KERAS_FOUND AND PY_TENSORFLOW_FOUND)); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/CMakeLists.txt:4849,depend,depends,4849,tmva/pymva/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/CMakeLists.txt,2,['depend'],['depends']
Integrability,"ass. An analysis group may have one or more implementations, one of which is; the ""default"" implementation. Analysis groups are used by client passes just like other passes are: the; ``AnalysisUsage::addRequired()`` and ``Pass::getAnalysis()`` methods. In order; to resolve this requirement, the :ref:`PassManager; <writing-an-llvm-pass-passmanager>` scans the available passes to see if any; implementations of the analysis group are available. If none is available, the; default implementation is created for the pass to use. All standard rules for; :ref:`interaction between passes <writing-an-llvm-pass-interaction>` still; apply. Although :ref:`Pass Registration <writing-an-llvm-pass-registration>` is; optional for normal passes, all analysis group implementations must be; registered, and must use the :ref:`INITIALIZE_AG_PASS; <writing-an-llvm-pass-RegisterAnalysisGroup>` template to join the; implementation pool. Also, a default implementation of the interface **must**; be registered with :ref:`RegisterAnalysisGroup; <writing-an-llvm-pass-RegisterAnalysisGroup>`. As a concrete example of an Analysis Group in action, consider the; `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`_; analysis group. The default implementation of the alias analysis interface; (the `basic-aa <https://llvm.org/doxygen/structBasicAliasAnalysis.html>`_ pass); just does a few simple checks that don't require significant analysis to; compute (such as: two different globals can never alias each other, etc).; Passes that use the `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`_ interface (for; example the `gvn <https://llvm.org/doxygen/classllvm_1_1GVN.html>`_ pass), do not; care which implementation of alias analysis is actually provided, they just use; the designated interface. From the user's perspective, commands work just like normal. Issuing the; command ``opt -gvn ...`` will cause the ``basic-aa`` class to be instantiated; and added to the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:36866,interface,interface,36866,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['interface'],['interface']
Integrability,"ass. Call it; `SClassDict.cxx`. The `rootcling` utility generates the methods; `Streamer`, **`TBuffer`** &operator\>\>() and `ShowMembers `for ROOT; classes. ``` {.cpp}; gmake -f Makefile; ```. Load the shared library:. ``` {.cpp}; root[] .L SClass.so; root[] SClass *sc = new SClass(); root[] TFile *f = new TFile(""Afile.root"",""UPDATE"");; root[] sc->Write();; ```. For more information on `rootcling` see the `$ROOTSYS/test` directory; `Makefile`, `Event.cxx`, and `Event.h` for an example, or follow this; link: <http://root.cern.ch/root/RootCintMan.html>. ## genreflex: A Comfortable Interface to rootcling. Version 5 supported both `Cint` and `Reflex` dictionaries. The tool to create; `Reflex` dictionaries was a Python script called `genreflex` and was very; successful in the user community.; Even if version 6 has only one type of dictionaries, `cling` dictionaries,; a re-implementation of `genreflex` is provided.; More precisely, in ROOT6, `genreflex` is nothing but a wrapper around; `rootcling`, which offers an identical CLI and behaviour to the old Python; tool.; The input to `genreflex` is a C++ header file, a set of switches and a; *selection XML file*. The output, as for `rootcling`, is a C++ dictionary; source and a `pcm` files.; An exhaustive documentation of the CLI switches of `genreflex` can be; inspected with the `genreflex --help` command. The entity corresponding to the `LinkDef` file for `genreflex` is the; *selection XML file*, also called *selection XML* or simply *selection file*.; A *selection XML file* allows to describe a list of classes for which; the dictionaries are to be created. In addition, it allows to specify; properties of classes or data members, without the need to add comments in; the source code. This is of primary importance when dictionaries must be; created for classes residing in code which cannot be modified.; For a complete description of the structure of the *selection XML files*; and the way in which attributes can be set, refer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:34051,wrap,wrapper,34051,documentation/users-guide/AddingaClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md,1,['wrap'],['wrapper']
Integrability,"ass:. ``nofpclass(<test mask>)``; This attribute applies to parameters and return values with; floating-point and vector of floating-point types, as well as; arrays of such types. The test mask has the same format as the; second argument to the :ref:`llvm.is.fpclass <llvm.is.fpclass>`,; and indicates which classes of floating-point values are not; permitted for the value. For example a bitmask of 3 indicates; the parameter may not be a NaN. If the value is a floating-point class indicated by the; ``nofpclass`` test mask, a :ref:`poison value <poisonvalues>` is; passed or returned instead. .. code-block:: text; :caption: The following invariants hold. @llvm.is.fpclass(nofpclass(test_mask) %x, test_mask) => false; @llvm.is.fpclass(nofpclass(test_mask) %x, ~test_mask) => true; nofpclass(all) => poison; .. In textual IR, various string names are supported for readability; and can be combined. For example ``nofpclass(nan pinf nzero)``; evaluates to a mask of 547. This does not depend on the floating-point environment. For; example, a function parameter marked ``nofpclass(zero)`` indicates; no zero inputs. If this is applied to an argument in a function; marked with :ref:`\""denormal-fp-math\"" <denormal_fp_math>`; indicating zero treatment of input denormals, it does not imply the; value cannot be a denormal value which would compare equal to 0. .. table:: Recognized test mask names. +-------+----------------------+---------------+; | Name | floating-point class | Bitmask value |; +=======+======================+===============+; | nan | Any NaN | 3 |; +-------+----------------------+---------------+; | inf | +/- infinity | 516 |; +-------+----------------------+---------------+; | norm | +/- normal | 26 |; +-------+----------------------+---------------+; | sub | +/- subnormal | 144 |; +-------+----------------------+---------------+; | zero | +/- 0 | 96 |; +-------+----------------------+---------------+; | all | All values | 1023 |; +-------+----------------------+-----",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:65841,depend,depend,65841,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depend']
Integrability,"asses on the second function in the module, and so on.; This is better for cache locality around LLVM data structures. This similarly; applies for the other IR types, and in some cases can even affect the quality; of optimization. For example, running all loop passes on a loop may cause a; later loop to be able to be optimized more than if each loop pass were run; separately. Inserting Passes into Default Pipelines; =======================================. Rather than manually adding passes to a pass manager, the typical way of; creating a pass manager is to use a ``PassBuilder`` and call something like; ``PassBuilder::buildPerModuleDefaultPipeline()`` which creates a typical; pipeline for a given optimization level. Sometimes either frontends or backends will want to inject passes into the; pipeline. For example, frontends may want to add instrumentation, and target; backends may want to add passes that lower custom intrinsics. For these; cases, ``PassBuilder`` exposes callbacks that allow injecting passes into; certain parts of the pipeline. For example,. .. code-block:: c++. PassBuilder PB;; PB.registerPipelineStartEPCallback([&](ModulePassManager &MPM,; PassBuilder::OptimizationLevel Level) {; MPM.addPass(FooPass());; };. will add ``FooPass`` near the very beginning of the pipeline for pass; managers created by that ``PassBuilder``. See the documentation for; ``PassBuilder`` for the various places that passes can be added. If a ``PassBuilder`` has a corresponding ``TargetMachine`` for a backend, it; will call ``TargetMachine::registerPassBuilderCallbacks()`` to allow the; backend to inject passes into the pipeline. Clang's ``BackendUtil.cpp`` shows examples of a frontend adding (mostly; sanitizer) passes to various parts of the pipeline.; ``AMDGPUTargetMachine::registerPassBuilderCallbacks()`` is an example of a; backend adding passes to various parts of the pipeline. Pass plugins can also add passes into default pipelines. Different tools have; different ways of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:5571,inject,injecting,5571,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['inject'],['injecting']
Integrability,"assllvm_1_1AliasAnalysis.html>`__ class is the; primary interface used by clients and implementations of alias analyses in the; LLVM system. This class is the common interface between clients of alias; analysis information and the implementations providing it, and is designed to; support a wide range of implementations and clients (but currently all clients; are assumed to be flow-insensitive). In addition to simple alias analysis; information, this class exposes Mod/Ref information from those implementations; which can provide it, allowing for powerful analyses and transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. The; ``AliasAnalysis`` interface also exposes some helper methods which allow you to; get mod/ref information for arbitrary instructions. All ``AliasAnalysis`` interfaces require that in queries involving multiple; values, values which are not :ref:`constants <constants>` are all; defined within the same function. Representation of Pointers; --------------------------. Most importantly, the ``AliasAnalysis`` class provides several methods which are; used to query whether or not two memory o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:1855,interface,interface,1855,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['interface'],['interface']
Integrability,"ast review in the series (the most recent).; * Click ""Edit Related Revisions"" then ""Edit Parent Revisions"".; * This will open a dialog where you will enter the patch number of the parent patch; (or patches). The patch number is of the form D<number> and you can find it by; looking at the URL for the review e.g. reviews.llvm/org/D12345.; * Click ""Save Parent Revisions"" after entering them.; * You should now see a ""Stack"" tab in the ""Revision Contents"" section of the web; interface, showing the parent patch that you added. Repeat this with each previous review until you reach the first in the series. This; one won't have a parent since it's the start of the series. If you prefer to start with the first in the series and go forward, you can use the; ""Edit Child Revisions"" option instead. .. _using-patch-summaries:. Using patch summaries; ^^^^^^^^^^^^^^^^^^^^^. This applies to new and existing reviews, uploaded with `arc` or the web interface. * Upload the first review and note its patch number, either with the web interface; or `arc`.; * For each commit after that, add the following line to the commit message or patch; summary: ""Depends on D<num>"", where ""<num>"" is the patch number of the previous review.; This must be entirely on its own line, with a blank line before it.; For example::. [llvm] Example commit. Depends on D12345. * If you want a single review to have multiple parent reviews then; add more with ""and"", for example: ""Depends on D12344 and D12345"".; * Upload the commit with the web interface or `arc`; (``arc diff --verbatim`` to update an existing review).; * You will see a ""Stack"" tab in the ""Revision Contents"" section of the review; in the web interface, showing the parent review.; * Repeat these steps until you've uploaded or updated all the patches in; your series. When you push the patches, please remove the ""Depends on"" lines from the; commit messages, since they add noise and duplicate git's implicit ordering. One frequently used workflow for creati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:6682,interface,interface,6682,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['interface'],['interface']
Integrability,"at ``store i8 0, ptr %p1`` is a definition,; and its reaching definition before it is ``6``, or the ``MemoryPhi`` after; ``while.cond``. (See the `Use and Def optimization`_ and `Precision`_; sections below for why this ``MemoryDef`` isn't linked to a separate,; disambiguated ``MemoryPhi``.); - ``3 = MemoryDef(6)`` notes that ``store i8 0, ptr %p2`` is a definition; its; reaching definition is also ``6``.; - ``5 = MemoryPhi({if.then,2},{if.else,3})`` notes that the clobber before; this block could either be ``2`` or ``3``.; - ``MemoryUse(5)`` notes that ``load i8, ptr %p1`` is a use of memory, and that; it's clobbered by ``5``.; - ``4 = MemoryDef(5)`` notes that ``store i8 2, ptr %p2`` is a definition; its; reaching definition is ``5``.; - ``MemoryUse(1)`` notes that ``load i8, ptr %p3`` is just a user of memory,; and the last thing that could clobber this use is above ``while.cond`` (e.g.; the store to ``%p3``). In memory versioning parlance, it really only depends on; the memory version 1, and is unaffected by the new memory versions generated since; then. As an aside, ``MemoryAccess`` is a ``Value`` mostly for convenience; it's not; meant to interact with LLVM IR. Design of MemorySSA; ===================. ``MemorySSA`` is an analysis that can be built for any arbitrary function. When; it's built, it does a pass over the function's IR in order to build up its; mapping of ``MemoryAccess``\ es. You can then query ``MemorySSA`` for things; like the dominance relation between ``MemoryAccess``\ es, and get the; ``MemoryAccess`` for any given ``Instruction`` . When ``MemorySSA`` is done building, it also hands you a ``MemorySSAWalker``; that you can use (see below). The walker; ----------. A structure that helps ``MemorySSA`` do its job is the ``MemorySSAWalker``, or; the walker, for short. The goal of the walker is to provide answers to clobber; queries beyond what's represented directly by ``MemoryAccess``\ es. For example,; given:. .. code-block:: llvm. define void @",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:8020,depend,depends,8020,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['depend'],['depends']
Integrability,"at the structurally equivalent nodes in the different translation units are not getting duplicated in the merged AST.; E.g. if we include the definition of the vector template (``#include <vector>``) in two translation units, then their merged AST should have only one node which represents the template.; Also, we have to discover *one definition rule* (ODR) violations.; For instance, if there is a class definition with the same name in both translation units, but one of the definition contains a different number of fields.; So, we look up existing definitions, and then we check the structural equivalency on those nodes.; The following pseudo-code demonstrates the basics of the import mechanism:. .. code-block:: cpp. // Pseudo-code(!) of import:; ErrorOrDecl Import(Decl *FromD) {; Decl *ToDecl = nullptr;; FoundDeclsList = Look up all Decls in the ""to"" Ctx with the same name of FromD;; for (auto FoundDecl : FoundDeclsList) {; if (StructurallyEquivalentDecls(FoundDecl, FromD)) {; ToDecl = FoundDecl;; Mark FromD as imported;; break;; } else {; Report ODR violation;; return error;; }; }; if (FoundDeclsList is empty) {; Import dependent declarations and types of ToDecl;; ToDecl = create a new AST node in ""to"" Ctx;; Mark FromD as imported;; }; return ToDecl;; }. Two AST nodes are *structurally equivalent* if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and their types are structurally equivalent. We could extend the definition of structural equivalency to templates similarly. If A and B are AST nodes and *A depends on B*, then we say that A is a **dependant** of B and B is a **dependency** of A.; The words ""dependant"" and ""depend",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:3505,depend,dependent,3505,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,1,['depend'],['dependent']
Integrability,"ata types"");; tree->Branch(""floatVal"", &floatVal, ""floatVal/f""); // Float16_t value with default settings; tree->Branch(""floatArray"", floatArray, ""floatArray[7]/f[0,100]""); // Float16_t array with range from 0 to 100; tree->Branch(""doubleVal"", &doubleVal, ""doubleVal/d[0,1000,20]""); // Double32_t value with range from 0 to 1000 and 20 bits; tree->Branch(""doubleArray"", doubleArray, ""doubleArray[5]/d[0,0,18]""); // Double32_t array without range and 18 bits; ~~~. ### Bulk I/O; - The new `TBulkBranchRead` class (inside the `ROOT::Experimental::Internal` namespace) provides; a mechanism for reading, in a single library call, many events' worth of simple data (primitive types,; arrays of primitives, split structures) stored in a `TTree`. This allows for extremely fast delivery; of event data to the process. This is meant as an internal interface that allows the ROOT team to; implement faster high-level interface.; - The `TTreeReaderFast ` class (inside the `ROOT::Experimental::Internal` namespace) provides a simple; mechanism for reading ntuples with the bulk IO interface. ## Histogram Libraries. ### TH1; - Add a search range to the `TH1::FindFirstBinAbove(..)` and `TH1::FindLastBinAvove(..)` functions. ### TH2Poly; - Add implementation of `SetBinError` and fix a bug in `GetBinError` in case of weighted events. ### TF1; - The implementation of `TF1::GetX` has been improved. In case of the presence of multiple roots, the function will return the root with the lower x value. In case of no-roots a NaN will be returned instead of returning a random incorrect value. ### TKDE; - Add support for I/O. ## Math Libraries; - Add `TComplex` value printer for printing the value of object at the root prompt and in python; - Add to the documentation of `TLorentzVector` a link to `ROOT::Math::LorentzVector`, which is a superior tool.; - Add new implementation of `TStatistic::Merge` able to deal silently with empty TStatistic objects. This implementation is useful when filling TStatistics w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:11436,interface,interface,11436,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['interface'],['interface']
Integrability,"ata. A function may have prefix data but no body. This has similar semantics; to the ``available_externally`` linkage in that the data may be used by the; optimizers but will not be emitted in the object file. .. _prologuedata:. Prologue Data; -------------. The ``prologue`` attribute allows arbitrary code (encoded as bytes) to; be inserted prior to the function body. This can be used for enabling; function hot-patching and instrumentation. To maintain the semantics of ordinary function calls, the prologue data must; have a particular format. Specifically, it must begin with a sequence of; bytes which decode to a sequence of machine instructions, valid for the; module's target, which transfer control to the point immediately succeeding; the prologue data, without performing any other visible action. This allows; the inliner and other passes to reason about the semantics of the function; definition without needing to reason about the prologue data. Obviously this; makes the format of the prologue data highly target dependent. A trivial example of valid prologue data for the x86 architecture is ``i8 144``,; which encodes the ``nop`` instruction:. .. code-block:: text. define void @f() prologue i8 144 { ... }. Generally prologue data can be formed by encoding a relative branch instruction; which skips the metadata, as in this example of valid prologue data for the; x86_64 architecture, where the first two bytes encode ``jmp .+10``:. .. code-block:: text. %0 = type <{ i8, i8, ptr }>. define void @f() prologue %0 <{ i8 235, i8 8, ptr @md}> { ... }. A function may have prologue data but no body. This has similar semantics; to the ``available_externally`` linkage in that the data may be used by the; optimizers but will not be emitted in the object file. .. _personalityfn:. Personality Function; --------------------. The ``personality`` attribute permits functions to specify what function; to use for exception handling. .. _attrgrp:. Attribute Groups; ----------------. Attri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:74755,depend,dependent,74755,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependent']
Integrability,"atabase Libraries. * Fix `TPgSQLStatement::SetBinary` to actually handle binary data (previous limited to ascii). ## Networking Libraries. * When seeing too many requested ranges, Apache 2.4 now simply sends the whole file; (MaxRanges configuration parameter). TWebFile can handle this case now, but this can; trigger multiple transmissions of the full file. TWebFile warns when Apache reacts by; sending the full file. ## GUI Libraries. * A new `Browser.ExpandDirectories` option (the default is `yes`) has been added, allowing to prevent expanding the parent directory tree in the ROOT Browser (for example on nfs). ## Language Bindings. ### PyROOT. * Added a new configuration option to disable processing of the rootlogon[.py|C] macro in addition; ro the -n option in the command arguments. To disable processing the rootlogon do the following; before any other command that will trigger initialization:; ```; >>> import ROOT; >>> ROOT.PyConfig.DisableRootLogon = True; >>> ...; ```. ### Notebook integration. * Refactoring of the Jupyter integration layer into the new package JupyROOT.; * Added ROOT [Jupyter Kernel for ROOT](https://root.cern.ch/root-has-its-jupyter-kernel); * Magics are now invoked with standard syntax ""%%"", for example ""%%cpp"".; * The methods ""toCpp"" and ""toPython"" have been removed.; * Factorise output capturing and execution in an accelerator library and use ctypes to invoke functions.; * When the ROOT kernel is used, the output is consumed progressively; * Capture unlimited output also when using an IPython Kernel (fixes [ROOT-7960]). ## JavaScript ROOT. - New geometry (TGeo) classes support:; - browsing through volumes hieararchy; - changing visibility flags; - drawing of selected volumes; - support of large (~10M volumes) models, only most significant volumes are shown; - one could activate several clip planes (only with WebGL); - interaction with object browser to change visibility flags or focus on selected volume; - support of floating browser for TG",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:25581,integrat,integration,25581,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['integrat'],['integration']
Integrability,"atches 'int i;' and 'unsigned i'.; unless(stmt(isInTemplateInstantiation())); will NOT match j += 42; as it's shared between the template definition and; instantiation. Matcher<StringLiteral>hasSizeunsigned N; Matches nodes that have the specified size. Given; int a[42];; int b[2 * 21];; int c[41], d[43];; char *s = ""abcd"";; wchar_t *ws = L""abcd"";; char *w = ""a"";; constantArrayType(hasSize(42)); matches ""int a[42]"" and ""int b[2 * 21]""; stringLiteral(hasSize(4)); matches ""abcd"", L""abcd"". Matcher<TagDecl>isClass; Matches TagDecl object that are spelled with ""class."". Example matches C, but not S, U or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<TagDecl>isEnum; Matches TagDecl object that are spelled with ""enum."". Example matches E, but not C, S or U.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isStruct; Matches TagDecl object that are spelled with ""struct."". Example matches S, but not C, U or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TagDecl>isUnion; Matches TagDecl object that are spelled with ""union."". Example matches U, but not C, S or E.; struct S {};; class C {};; union U {};; enum E {};. Matcher<TemplateArgument>equalsIntegralValuestd::string Value; Matches a TemplateArgument of integral type with a given value. Note that 'Value' is a string as the template argument's value is; an arbitrary precision integer. 'Value' must be euqal to the canonical; representation of that integral value in b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:117903,interface,interface,117903,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['interface'],['interface']
Integrability,"ate <typename T> T Squared(T x) {; return Multiply(x, x);; }. int Multiply(int x, int y) {; return x * y;; }. int main() {; Squared(5);; }. Clang complains:. my_file.cpp:2:10: error: call to function 'Multiply' that is neither visible in the template definition nor found by argument-dependent lookup; return Multiply(x, x);; ^; my_file.cpp:10:3: note: in instantiation of function template specialization 'Squared<int>' requested here; Squared(5);; ^; my_file.cpp:5:5: note: 'Multiply' should be declared prior to the call site; int Multiply(int x, int y) {; ^. The C++ standard says that unqualified names like Multiply; are looked up in two ways. First, the compiler does unqualified lookup in the scope; where the name was written. For a template, this means the lookup is; done at the point where the template is defined, not where it's; instantiated. Since Multiply hasn't been declared yet at; this point, unqualified lookup won't find it. Second, if the name is called like a function, then the compiler; also does argument-dependent lookup (ADL). (Sometimes; unqualified lookup can suppress ADL; see [basic.lookup.argdep]p3 for; more information.) In ADL, the compiler looks at the types of all the; arguments to the call. When it finds a class type, it looks up the; name in that class's namespace; the result is all the declarations it; finds in those namespaces, plus the declarations from unqualified; lookup. However, the compiler doesn't do ADL until it knows all the; argument types. In our example, Multiply is called with dependent; arguments, so ADL isn't done until the template is instantiated. At; that point, the arguments both have type int, which doesn't; contain any class types, and so ADL doesn't look in any namespaces.; Since neither form of lookup found the declaration; of Multiply, the code doesn't compile. Here's another example, this time using overloaded operators,; which obey very similar rules. #include <iostream>. template<typename T>; void Dump(const T& valu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:12868,depend,dependent,12868,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['depend'],['dependent']
Integrability,"ath::MatRepSym<double,3>> SMatrixSym3;; typedef ROOT::Math::SVector>double,2> SVector2;; typedef ROOT::Math::SVector>double,3> SVector3;; typedef ROOT::Math::SVector>double,6> SVector6;; SMatrix33 m0; // create a zero 3x3 matrix; // create an 3x3 identity matrix; SMatrix33 i = ROOT::Math::SMatrixIdentity();; double a[9] = {1,2,3,4,5,6,7,8,9}; // input matrix data; // create a matrix using the a[] data; SMatrix33 m(a,9); // this will produce the 3x3 matrix; // ( 1 2 3 ); // ( 4 5 6 ); // ( 7 8 9 ); ```. Example to fill a symmetric matrix from an `std::vector`:. ``` {.cpp}; std::vector<double> v(6);; for (int i = 0; i<6; ++i) v[i] = double(i+1);; SMatrixSym3 s(v.begin(),v.end()) // this will produce the; // symmetric matrix; // ( 1 2 4 ); // ( 2 3 5 ); // ( 4 5 6 ); //create a general matrix from a symmetric matrix (the opposite; // will not compile); SMatrix33 m2 = s;; ```. #### Accessing and Setting Methods. The matrix elements can be set using the `operator()(irow,icol)`, where; `irow` and `icol` are the row and column indexes or by using the; iterator interface. Notice that the indexes start from zero and not from; one as in FORTRAN. Furthermore, all the matrix elements can be set also; by using the SetElements function passing a generic iterator. The; elements can be accessed by the same methods as well as by using the; function `ROOT::Math::SMatrix::apply`. The `apply(i)` has exactly the; same behavior for general and symmetric matrices; in contrast to the; iterator access methods which behave differently (it follows the data; order). ``` {.cpp}; SMatrix33 m;; m(0,0) = 1; // set the element in first row and first column; *(m.begin()+1) = 2; // set the second element (0,1); double d[9]={1,2,3,4,5,6,7,8,9};; m.SetElements(d,d+9); // set the d[] values in m; double x = m(2,1); // return the element in 3; x = m.apply(7); // return the 8-th element (row=2,col=1); x = *(m.begin()+7); // return the 8-th element (row=2,col=1); // symmetric matrices; //(note the differenc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:109009,interface,interface,109009,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interface']
Integrability,"ating-a-patch-series:. Creating a patch series; -----------------------. Chaining reviews together requires some manual work. There are two ways to do it; (these are also described `here <https://moz-conduit.readthedocs.io/en/latest/arcanist-user.html#series-of-commits>`_; along with some screenshots of what to expect). .. _using-the-web-interface:. Using the web interface; ^^^^^^^^^^^^^^^^^^^^^^^. This assumes that you've already created a Phabricator review for each commit,; using `arc` or the web interface. * Go to what will be the last review in the series (the most recent).; * Click ""Edit Related Revisions"" then ""Edit Parent Revisions"".; * This will open a dialog where you will enter the patch number of the parent patch; (or patches). The patch number is of the form D<number> and you can find it by; looking at the URL for the review e.g. reviews.llvm/org/D12345.; * Click ""Save Parent Revisions"" after entering them.; * You should now see a ""Stack"" tab in the ""Revision Contents"" section of the web; interface, showing the parent patch that you added. Repeat this with each previous review until you reach the first in the series. This; one won't have a parent since it's the start of the series. If you prefer to start with the first in the series and go forward, you can use the; ""Edit Child Revisions"" option instead. .. _using-patch-summaries:. Using patch summaries; ^^^^^^^^^^^^^^^^^^^^^. This applies to new and existing reviews, uploaded with `arc` or the web interface. * Upload the first review and note its patch number, either with the web interface; or `arc`.; * For each commit after that, add the following line to the commit message or patch; summary: ""Depends on D<num>"", where ""<num>"" is the patch number of the previous review.; This must be entirely on its own line, with a blank line before it.; For example::. [llvm] Example commit. Depends on D12345. * If you want a single review to have multiple parent reviews then; add more with ""and"", for example: ""Depends",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:6130,interface,interface,6130,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['interface'],['interface']
Integrability,"ating-point environment. This is a; comma separated pair. The elements may be one of ``""ieee""``,; ``""preserve-sign""``, ``""positive-zero""``, or ``""dynamic""``. The; first entry indicates the flushing mode for the result of floating; point operations. The second indicates the handling of denormal inputs; to floating point instructions. For compatibility with older; bitcode, if the second value is omitted, both input and output; modes will assume the same mode. If this is attribute is not specified, the default is ``""ieee,ieee""``. If the output mode is ``""preserve-sign""``, or ``""positive-zero""``,; denormal outputs may be flushed to zero by standard floating-point; operations. It is not mandated that flushing to zero occurs, but if; a denormal output is flushed to zero, it must respect the sign; mode. Not all targets support all modes. If the mode is ``""dynamic""``, the behavior is derived from the; dynamic state of the floating-point environment. Transformations; which depend on the behavior of denormal values should not be; performed. While this indicates the expected floating point mode the function; will be executed with, this does not make any attempt to ensure; the mode is consistent. User or platform code is expected to set; the floating point mode appropriately before function entry. If the input mode is ``""preserve-sign""``, or ``""positive-zero""``,; a floating-point operation must treat any input denormal value as; zero. In some situations, if an instruction does not respect this; mode, the input may need to be converted to 0 as if by; ``@llvm.canonicalize`` during lowering for correctness. ``""denormal-fp-math-f32""``; Same as ``""denormal-fp-math""``, but only controls the behavior of; the 32-bit float type (or vectors of 32-bit floats). If both are; are present, this overrides ``""denormal-fp-math""``. Not all targets; support separately setting the denormal mode per type, and no; attempt is made to diagnose unsupported uses. Currently this; attribute is respected by ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:107146,depend,depend,107146,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depend']
Integrability,"ating-point math. These include:. * Floating-point math obeys regular algebraic rules for real numbers (e.g.; ``+`` and ``*`` are associative, ``x/y == x * (1/y)``, and; ``(a + b) * c == a * c + b * c``),; * Operands to floating-point operations are not equal to ``NaN`` and; ``Inf``, and; * ``+0`` and ``-0`` are interchangeable. ``-ffast-math`` also defines the ``__FAST_MATH__`` preprocessor; macro. Some math libraries recognize this macro and change their behavior.; With the exception of ``-ffp-contract=fast``, using any of the options; below to disable any of the individual optimizations in ``-ffast-math``; will cause ``__FAST_MATH__`` to no longer be set.; ``-ffast-math`` enables ``-fcx-limited-range``. This option implies:. * ``-fno-honor-infinities``. * ``-fno-honor-nans``. * ``-fapprox-func``. * ``-fno-math-errno``. * ``-ffinite-math-only``. * ``-fassociative-math``. * ``-freciprocal-math``. * ``-fno-signed-zeros``. * ``-fno-trapping-math``. * ``-fno-rounding-math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:52904,contract,contract,52904,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['contract'],['contract']
Integrability,"ation Specification; ==================================. .. contents::; :local:. History; =======. * 2008/7/14 - created.; * 2008/8/21 - revised, C++.; * 2008/9/24 - add ``NULL`` ``isa`` field to ``__block`` storage.; * 2008/10/1 - revise block layout to use a ``static`` descriptor structure.; * 2008/10/6 - revise block layout to use an unsigned long int flags.; * 2008/10/28 - specify use of ``_Block_object_assign`` and; ``_Block_object_dispose`` for all ""Object"" types in helper functions.; * 2008/10/30 - revise new layout to have invoke function in same place.; * 2008/10/30 - add ``__weak`` support.; * 2010/3/16 - rev for stret return, signature field.; * 2010/4/6 - improved wording.; * 2013/1/6 - improved wording and converted to rst. This document describes the Apple ABI implementation specification of Blocks. The first shipping version of this ABI is found in Mac OS X 10.6, and shall be; referred to as 10.6.ABI. As of 2010/3/16, the following describes the ABI; contract with the runtime and the compiler, and, as necessary, will be referred; to as ABI.2010.3.16. Since the Apple ABI references symbols from other elements of the system, any; attempt to use this ABI on systems prior to SnowLeopard is undefined. High Level; ==========. The ABI of ``Blocks`` consist of their layout and the runtime functions required; by the compiler. A ``Block`` of type ``R (^)(P...)`` consists of a structure of; the following form:. .. code-block:: c. struct Block_literal_1 {; void *isa; // initialized to &_NSConcreteStackBlock or &_NSConcreteGlobalBlock; int flags;; int reserved;; R (*invoke)(struct Block_literal_1 *, P...);; struct Block_descriptor_1 {; unsigned long int reserved; // NULL; unsigned long int size; // sizeof(struct Block_literal_1); // optional helper functions; void (*copy_helper)(void *dst, void *src); // IFF (1<<25); void (*dispose_helper)(void *src); // IFF (1<<25); // required ABI.2010.3.16; const char *signature; // IFF (1<<30); } *descriptor;; // imported vari",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:1031,contract,contract,1031,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['contract'],['contract']
Integrability,"ation database with Clang Tooling. One caveat is that because; there are indirect settings obtained through the environment variables,; you may need to run any Clang Tooling executables through a command prompt; window created for use with Visual Studio as described above. An; alternative, e.g. for using the Visual Studio debugger on a Clang Tooling; executable, is to ensure that the environment variables are also visible; to the debugger settings. This can be done locally in Visual Studio's; debugger configuration locally or globally by launching the Visual Studio; IDE from a suitable command-prompt window. Using Clang Tools; =================. After you completed the previous steps, you are ready to run clang tools. If; you have a recent clang installed, you should have ``clang-check`` in; ``$PATH``. Try to run it on any ``.cpp`` file inside the LLVM source tree:. .. code-block:: console. $ clang-check tools/clang/lib/Tooling/CompilationDatabase.cpp. If you're using vim, it's convenient to have clang-check integrated. Put; this into your ``.vimrc``:. ::. function! ClangCheckImpl(cmd); if &autowrite | wall | endif; echo ""Running "" . a:cmd . "" ...""; let l:output = system(a:cmd); cexpr l:output; cwindow; let w:quickfix_title = a:cmd; if v:shell_error != 0; cc; endif; let g:clang_check_last_cmd = a:cmd; endfunction. function! ClangCheck(); let l:filename = expand('%'); if l:filename =~ '\.\(cpp\|cxx\|cc\|c\)$'; call ClangCheckImpl(""clang-check "" . l:filename); elseif exists(""g:clang_check_last_cmd""); call ClangCheckImpl(g:clang_check_last_cmd); else; echo ""Can't detect file's compilation arguments and no previous clang-check invocation!""; endif; endfunction. nmap <silent> <F5> :call ClangCheck()<CR><CR>. When editing a .cpp/.cxx/.cc/.c file, hit F5 to reparse the file. In; case the current file has a different extension (for example, .h), F5; will re-run the last clang-check invocation made from this vim instance; (if any). The output will go into the error window, whi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:4917,integrat,integrated,4917,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,1,['integrat'],['integrated']
Integrability,"ation of global variables and local ``static`` variables. Floating-point operations in these contexts will be rounded using ``FE_TONEAREST``. - The option ``-fno-rounding-math`` allows the compiler to assume that the rounding mode is set to ``FE_TONEAREST``. This is the default.; - The option ``-frounding-math`` forces the compiler to honor the dynamically-set rounding mode. This prevents optimizations which might affect results if the rounding mode changes or is different from the default; for example, it prevents floating-point operations from being reordered across most calls and prevents constant-folding when the result is not exactly representable. .. option:: -ffp-model=<value>. Specify floating point behavior. ``-ffp-model`` is an umbrella; option that encompasses functionality provided by other, single; purpose, floating point options. Valid values are: ``precise``, ``strict``,; and ``fast``.; Details:. * ``precise`` Disables optimizations that are not value-safe on; floating-point data, although FP contraction (FMA) is enabled; (``-ffp-contract=on``). This is the default behavior. This value resets; ``-fmath-errno`` to its target-dependent default.; * ``strict`` Enables ``-frounding-math`` and; ``-ffp-exception-behavior=strict``, and disables contractions (FMA). All; of the ``-ffast-math`` enablements are disabled. Enables; ``STDC FENV_ACCESS``: by default ``FENV_ACCESS`` is disabled. This option; setting behaves as though ``#pragma STDC FENV_ACCESS ON`` appeared at the; top of the source file.; * ``fast`` Behaves identically to specifying both ``-ffast-math`` and; ``ffp-contract=fast``. Note: If your command line specifies multiple instances; of the ``-ffp-model`` option, or if your command line option specifies; ``-ffp-model`` and later on the command line selects a floating point; option that has the effect of negating part of the ``ffp-model`` that; has been selected, then the compiler will issue a diagnostic warning; that the override has occurred. .. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:62435,contract,contraction,62435,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,2,['contract'],"['contract', 'contraction']"
Integrability,"ation over spilling. If all; the load / store instructions would be folded then spilling is cheaper because; it won't require new live intervals / registers. See 2003-05-31-LongShifts for; an example. //===---------------------------------------------------------------------===//. With a copying garbage collector, derived pointers must not be retained across; collector safe points; the collector could move the objects and invalidate the; derived pointer. This is bad enough in the first place, but safe points can; crop up unpredictably. Consider:. %array = load { i32, [0 x %obj] }** %array_addr; %nth_el = getelementptr { i32, [0 x %obj] }* %array, i32 0, i32 %n; %old = load %obj** %nth_el; %z = div i64 %x, %y; store %obj* %new, %obj** %nth_el. If the i64 division is lowered to a libcall, then a safe point will (must); appear for the call site. If a collection occurs, %array and %nth_el no longer; point into the correct object. The fix for this is to copy address calculations so that dependent pointers; are never live across safe point boundaries. But the loads cannot be copied; like this if there was an intervening store, so may be hard to get right. Only a concurrent mutator can trigger a collection at the libcall safe point.; So single-threaded programs do not have this requirement, even with a copying; collector. Still, LLVM optimizations would probably undo a front-end's careful; work. //===---------------------------------------------------------------------===//. The ocaml frametable structure supports liveness information. It would be good; to support it. //===---------------------------------------------------------------------===//. The FIXME in ComputeCommonTailLength in BranchFolding.cpp needs to be; revisited. The check is there to work around a misuse of directives in inline; assembly. //===---------------------------------------------------------------------===//. It would be good to detect collector/target compatibility instead of silently; doing the w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt:3421,depend,dependent,3421,interpreter/llvm-project/llvm/lib/CodeGen/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/README.txt,1,['depend'],['dependent']
Integrability,"ation settings and division interface for volumes](pictures/020001F8.jpg). - *Division*. Allows dividing the edited volume according a given; pattern. The division axes that are allowed are presented in a; radio-button group. The number entries labeled ""*From*"", ""*Step*""; and ""*Nslices*"" correspond to the divisioning parameters on the; selected axis. The range of the division is between `start` and; `start+ndiv*step` values and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by typing a number, press; ENTER at the end to validate. This applies for taking into account and; validation of any number change in the geometry editors. ### How to Create a Valid Geometry with Geometry Editors. 1. Create a new geometry manager and start the editor as described at; the beginning. 2. Create at least one material from the ""*Materials*"" shutter item; category. Generally, for creating objects, the interface is always in; the **`TGeoManagerEditor`** in different categories - one should just; provide a name and requested parameters. 3. Create a shape that will be used for the top volume within the; ""*Shapes*"" category. For the moment, the shapes that have editors are; Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype,; Pcon, Torus and Sphere. 4. Create a medium from one of the existing materials from the; ""*Medium*"" category. You will notice that some categories as ""*Volume*""; and ""*Medium*"" are inactive at the beginning because at that time there; is no material yet (for making a medium) and no shape (for making a; volume). These categories are dynamically activated once all the; required components are defined. 5. Create a volume from the ""*Volumes*"" category. You will notice that; contrary to the other editors, the volume editor is opened in a tab, not; transient - this is because it is more complex. 6. Go back to ""*General*"" category and select the newly created volume; as the top one (you can do it also fr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:174439,interface,interface,174439,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability,"ation unit. * Module interface partition unit. * Internal module partition unit. A primary module interface unit is a module unit whose module declaration is; ``export module module_name;``. The ``module_name`` here denotes the name of the; module. A module should have one and only one primary module interface unit. A module implementation unit is a module unit whose module declaration is; ``module module_name;``. A module could have multiple module implementation; units with the same declaration. A module interface partition unit is a module unit whose module declaration is; ``export module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. An internal module partition unit is a module unit whose module declaration; is ``module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. In this document, we use the following umbrella terms:. * A ``module interface unit`` refers to either a ``primary module interface unit``; or a ``module interface partition unit``. * An ``importable module unit`` refers to either a ``module interface unit``; or a ``internal module partition unit``. * A ``module partition unit`` refers to either a ``module interface partition unit``; or a ``internal module partition unit``. Built Module Interface file; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. A ``Built Module Interface file`` stands for the precompiled result of an importable module unit.; It is also called the acronym ``BMI`` generally. Global module fragment; ~~~~~~~~~~~~~~~~~~~~~~. In a module unit, the section from ``module;`` to the module declaration is called the global module fragment. How to build projects using modules; -----------------------------------. Quick Start; ~~~~~~~~~~~. Let's see a ""hello world"" example that uses modules. .. code-block:: c++. // Hello.cppm; module;; #include <iostream>; export module Hello;; export void hello() {; std::cout << ""Hello World!\n"";; }. // use.cpp; import Hello;;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:3582,interface,interface,3582,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,3,['interface'],['interface']
Integrability,"ation:. * :doc:`Contributing`; * :doc:`MyFirstTypoFix`. Example Pull Request with git; ====================================. Instead of using the GitHub CLI to create a PR, you can push your code to a; remote branch on your fork and create the PR to upstream using the GitHub web; interface. Here is an example of making a PR using git and the GitHub web interface:. First follow the instructions to [fork the repository](https://docs.github.com/en/get-started/quickstart/fork-a-repo?tool=webui#forking-a-repository). Next follow the instructions to [clone your forked repository](https://docs.github.com/en/get-started/quickstart/fork-a-repo?tool=webui#cloning-your-forked-repository). Once you've cloned your forked repository,. ::. # Switch to the forked repo; cd llvm-project. # Create a new branch; git switch -c my_change. # Create your changes; $EDITOR file.cpp. # Don't forget clang-format; git clang-format. # and don't forget running your tests; ninja check-llvm. # Commit, use a good commit message; git commit file.cpp. # Push your changes to your fork branch, be mindful of; # your remotes here, if you don't remember what points to your; # fork, use git remote -v to see. Usually origin points to your; # fork and upstream to llvm/llvm-project; git push origin my_change. Navigate to the URL printed to the console from the git push command in the last step.; Create a pull request from your branch to llvm::main. ::. # If you get any review comments, come back to the branch and; # adjust them.; git switch my_change; $EDITOR file.cpp. # Commit your changes; git commit file.cpp -m ""Code Review adjustments"". # Format changes; git clang-format HEAD~. # Recommit if any formatting changes; git commit -a --amend. # Re-run tests and make sure nothing broke.; ninja check. # Push your changes to your fork branch, be mindful of; # your remotes here, if you don't remember what points to your; # fork, use git remote -v to see. Usually origin points to your; # fork and upstream to llvm/ll",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:10322,message,message,10322,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['message'],['message']
Integrability,"ation; of the fit contains a linear dependence. If this is the case, then; `Minuit` (or any other program) cannot solve your problem uniquely.; The error matrix will necessarily be largely meaningless, so the user; must remove the under determinedness by reformulating the; parameterization. `Minuit` cannot do this itself. #### Numerical Inaccuracies. It is possible that the apparent lack of positive-definiteness is due; to excessive round off errors in numerical calculations (in the user; function), or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or; if the parameters are badly scaled (not all of the same order of; magnitude), and correlations are large. In any case, whether the; non-positive-definiteness is real or only numerical is largely; irrelevant, since in both cases the error matrix will be unreliable; and the minimum suspicious. #### An Ill-posed Problem. For questions of parameter dependence, see the discussion above on; positive-definiteness. Possible other mathematical problems are the; following:. - Excessive numerical round off - be especially careful of; exponential and factorial functions which get big very quickly and; lose accuracy. - Starting too far from the solution - the function may have; unphysical local minima, especially at infinity in some variables. ## Minuit2 Package. `Minuit2` is a new object-oriented implementation, written in C++, of; the popular `MINUIT` minimization package. Compared with the; **`TMinuit`** class, which is a direct conversion from FORTRAN to C++,; `Minuit2` is a complete redesign and re-implementation of the package.; This new version provides all the functionality present in the old; FORTRAN version, with almost equivalent numerical accuracy and; computational performances.; Furthermore, it contains some fixes and small improvements and this new functionality:; * The possibility to set single side parameter limits; * the FUMILI algorithm ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:64195,depend,dependence,64195,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['depend'],['dependence']
Integrability,"ation; rf02_composite.C - How to construct composite p.d.fs (sig plus bkg etc); rf03_multidim.C - How to construct multi-dimensional p.d.f.s; rf04_composition.C - Using composition techniques to adjust p.d.f building blocks; rf05_conditional.C - Construction of productions with conditional p.d.f.s; rf06_convolution.C - Convolution of p.d.fs f(x) (X) g(x); rf07_bphysics.C - B physics p.d.f.s with analytical convolution; rf08_intminuit.C - Interactive MINUIT demonstration; rf09_constraints.C - How to specify and use parameter constraints in fits; rf10_ranges.C - Working with sub ranges in observables in fitting and plotting; rf11_plotbinning.C - Variable and other non-uniform binnign specifications; rf12_mcstudy.C - Managing toy Monte Carlo studie; rf13_wspacewrite.C - Creating and persisting workspaces; rf14_wspaceread.C - Reading and using workspaces; rf15_simwstool.C - Automated tools for building of simulateneous p.d.f.s; rf16_normandint.C - Normalization, integration and cumulative distribution functions (1d); rf16_normandint2d.C - Normalization, integration and cumulative distribution functions (1d); ; Update of class documentation; ; The documentation in the code itself that is extracted by THtml to construct; the online class documentation has been updated for all classes. Now all classes; have (again) a short class description, as well as a (short) description of each member function; and most data members. An update to the users manual is foreseen shortly after the 5.20; release. RooWorkspace. A new feature has been added that allows to persist source code of RooFit classes that; are not in ROOT distribution inside a RooWorkspace to facilitate sharing; of custom code with others. To import code of custom classes call. RooWorkspace::importClassCode(). after importing the objects themselves into the workspace. For all classes; that are compiled with ACliC RooWorkspace can automatically find the source; code using the ROOT TClass interface. For custom classes th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:1153,integrat,integration,1153,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['integrat'],['integration']
Integrability,"ations are required to be instantiated separately (this; includes default arguments and exception specifications), and such; instantiations update the existing declaration. These cases tend to be fragile; mutable AST state should be avoided where; possible. As a consequence of this design principle, we typically do not provide setters; for AST state. (Some are provided for short-term modifications intended to be; used immediately after an AST node is created and before it's ""published"" as; part of the complete AST, or where language semantics require after-the-fact; updates.). Faithfulness; ^^^^^^^^^^^^. The AST intends to provide a representation of the program that is faithful to; the original source. We intend for it to be possible to write refactoring tools; using only information stored in, or easily reconstructible from, the Clang AST.; This means that the AST representation should either not desugar source-level; constructs to simpler forms, or -- where made necessary by language semantics; or a clear engineering tradeoff -- should desugar minimally and wrap the result; in a construct representing the original source form. For example, ``CXXForRangeStmt`` directly represents the syntactic form of a; range-based for statement, but also holds a semantic representation of the; range declaration and iterator declarations. It does not contain a; fully-desugared ``ForStmt``, however. Some AST nodes (for example, ``ParenExpr``) represent only syntax, and others; (for example, ``ImplicitCastExpr``) represent only semantics, but most nodes; will represent a combination of syntax and associated semantics. Inheritance; is typically used when representing different (but related) syntaxes for nodes; with the same or similar semantics. .. _Type:. The ``Type`` class and its subclasses; -------------------------------------. The ``Type`` class (and its subclasses) are an important part of the AST.; Types are accessed through the ``ASTContext`` class, which implicitly creates",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:60361,wrap,wrap,60361,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['wrap'],['wrap']
Integrability,"ations. The builds are; executed on different *workers*. Builders and workers are configured and; provided by community members. The Buildbot tracks the commits on the main branch and the release branches.; This means that patches are built and tested after they are merged to the these; branches (aka post-merge testing). This also means it's okay to break the build; occasionally, as it's unreasonable to expect contributors to build and test; their patch with every possible configuration. *If your commit broke the build:*. * Fix the build as soon as possible as this might block other contributors or; downstream users.; * If you need more time to analyze and fix the bug, please revert your change to; unblock others. *If someone else broke the build and this blocks your work*. * Comment on the code review in `GitHub <https://github.com/llvm/llvm-project/pulls>`_; (if available) or email the author, explain the problem and how this impacts; you. Add a link to the broken build and the error message so folks can; understand the problem.; * Revert the commit if this blocks your work, see revert_policy_ . *If a build/worker is permanently broken*. * 1st step: contact the owner of the worker. You can find the name and contact; information for the *Admin* of worker on the page of the build in the; *Worker* tab:. .. image:: buildbot_worker_contact.png. * 2nd step: If the owner does not respond or fix the worker, please escalate; to Galina Kostanova, the maintainer of the BuildBot master.; * 3rd step: If Galina could not help you, please escalate to the; `Infrastructure Working Group <mailto:iwg@llvm.org>`_. .. _new-llvm-components:. Introducing New Components into LLVM; ====================================. The LLVM community is a vibrant and exciting place to be, and we look to be; inclusive of new projects and foster new communities, and increase; collaboration across industry and academia. That said, we need to strike a balance between being inclusive of new ideas and; peopl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:37082,message,message,37082,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['message'],['message']
Integrability,"atomic with respect to calls to ``objc_storeWeak`` on ``object``. .. _arc.runtime.objc_moveWeak:. ``void objc_moveWeak(id *dest, id *src);``; ------------------------------------------. *Precondition:* ``src`` is a valid pointer which either contains a null pointer; or has been registered as a ``__weak`` object. ``dest`` is a valid pointer; which has not been registered as a ``__weak`` object. ``dest`` is initialized to be equivalent to ``src``, potentially registering it; with the runtime. ``src`` may then be left in its original state, in which; case this call is equivalent to :ref:`objc_copyWeak; <arc.runtime.objc_copyWeak>`, or it may be left as null. Must be atomic with respect to calls to ``objc_storeWeak`` on ``src``. .. _arc.runtime.objc_release:. ``void objc_release(id value);``; --------------------------------. *Precondition:* ``value`` is null or a pointer to a valid object. If ``value`` is null, this call has no effect. Otherwise, it performs a; release operation exactly as if the object had been sent the ``release``; message. .. _arc.runtime.objc_retain:. ``id objc_retain(id value);``; -----------------------------. *Precondition:* ``value`` is null or a pointer to a valid object. If ``value`` is null, this call has no effect. Otherwise, it performs a retain; operation exactly as if the object had been sent the ``retain`` message. Always returns ``value``. .. _arc.runtime.objc_retainAutorelease:. ``id objc_retainAutorelease(id value);``; ----------------------------------------. *Precondition:* ``value`` is null or a pointer to a valid object. If ``value`` is null, this call has no effect. Otherwise, it performs a retain; operation followed by an autorelease operation. Equivalent to the following; code:. .. code-block:: objc. id objc_retainAutorelease(id value) {; return objc_autorelease(objc_retain(value));; }. Always returns ``value``. .. _arc.runtime.objc_retainAutoreleaseReturnValue:. ``id objc_retainAutoreleaseReturnValue(id value);``; ------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:113386,message,message,113386,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"ators using ``lto_codegen_compile()`` which returns a; native object file creating by merging the LLVM bitcode files and applying; various optimization passes. Phase 4 : Symbol Resolution after optimization; ----------------------------------------------. In this phase, the linker reads optimized a native object file and updates the; internal global symbol table to reflect any changes. The linker also collects; information about any changes in use of external symbols by LLVM bitcode; files. In the example above, the linker notes that ``foo4()`` is not used any; more. If dead code stripping is enabled then the linker refreshes the live; symbol information appropriately and performs dead code stripping. After this phase, the linker continues linking as if it never saw LLVM bitcode; files. .. _libLTO:. ``libLTO``; ==========. ``libLTO`` is a shared object that is part of the LLVM tools, and is intended; for use by a linker. ``libLTO`` provides an abstract C interface to use the LLVM; interprocedural optimizer without exposing details of LLVM's internals. The; intention is to keep the interface as stable as possible even when the LLVM; optimizer continues to evolve. It should even be possible for a completely; different compilation technology to provide a different libLTO that works with; their object files and the standard linker tool. ``lto_module_t``; ----------------. A non-native object file is handled via an ``lto_module_t``. The following; functions allow the linker to check if a file (on disk or in a memory buffer) is; a file which libLTO can process:. .. code-block:: c. lto_module_is_object_file(const char*); lto_module_is_object_file_for_target(const char*, const char*); lto_module_is_object_file_in_memory(const void*, size_t); lto_module_is_object_file_in_memory_for_target(const void*, size_t, const char*). If the object file can be processed by ``libLTO``, the linker creates a; ``lto_module_t`` by using one of:. .. code-block:: c. lto_module_create(const char",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst:8165,interface,interface,8165,interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst,1,['interface'],['interface']
Integrability,"atrix for input if one is available. The covariance matrix can be; supplied in form of a std::vector$<$double$>$ in packed storage format; (upper triangular), or in a more user-friendly way by using the; interface provided by the MnUserCovariance. ## Running a M minimization ##. Two use cases are addressed for minimization:. - The user just wants the function to be minimized in one go. - The user wants to minimize the $\mbox{FCN}$ in several; minimization steps, re-using the result of the preceeding; minimization in the next step and change parameters in between; (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main]. ### Direct usage of minimizers ###. Minimizers such as the VariableMetricMinimizer are designed as; state-less minimization engines, which means that they do not depend on; the current function and its parameters. Any $\mbox{FCN}$ function; can be minimized with the same minimizer. The interface is restricted to; minimization and no parameter interaction is possible. ### Using an application (MnMigrad) ###. MnMigrad uses the VariableMetricMinimizer for minimization but allows as; well for parameter interaction by the user. An instance of MnMigrad is; specific to the current $\mbox{FCN}$ and user parameters. Any; parameter interaction of the user between two minimization steps will; make use of the result of the preceeding minimization in an optimal way.; The interface for parameters (see [api:parameters], [api:covariance] and; [api:state]) is forwardedin MnMigrad. ### Subsequent minimizations ###. M takes care that all information is treated in an optimal and correct; way if the user interacts with the parameters between two minimizations.; MnMigrad retains the result of the last minimization and uses this as; input for the next step. Between two minimization requests to MnMigrad; the user can fix or release parameters, put limits on them or remove; limits from them. Each instance of a MnMigrad object mai",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:34155,interface,interface,34155,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interface']
Integrability,"ature & bug fix:; # 3.15: Added $<REMOVE_DUPLICATES:list> generator expression; # 3.16: Bug fix with CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS: the auto-generated exports; # are now updated only when the object files providing the symbols are updated; cmake_minimum_required(VERSION 3.16 FATAL_ERROR); # Set CMP0091 (MSVC runtime library flags are selected by an abstraction) to OLD; # to keep the old way of selecting the runtime library with the -MD/-MDd compiler flag; cmake_policy(SET CMP0091 OLD); else(); cmake_minimum_required(VERSION 3.10 FATAL_ERROR); endif(). SET(LIB_NAME libAfterImage). # Microsoft Visual Studio:; IF(MSVC); # Define; ADD_DEFINITIONS(-D_CRT_SECURE_NO_DEPRECATE); SET(CMAKE_C_FLAGS ""${CMAKE_C_FLAGS} /DNO_DEBUG_OUTPUT /D_MBCS /D_LIB /wd4996 /wd4267 /wd4018 /wd4244""); ENDIF(). set(FREETYPE_INCLUDE_DIR """" CACHE PATH ""Path to Freetype include dir""); set(ZLIB_INCLUDE_DIR """" CACHE PATH ""Path to zlib include dir""). if(NOT EXISTS ""${FREETYPE_INCLUDE_DIR}/ft2build.h""); message(ERROR ""Can't find ft2build.h in ${FREETYPE_INCLUDE_DIR}""); endif(). if(NOT EXISTS ""${ZLIB_INCLUDE_DIR}/zlib.h""); message(ERROR ""Can't find zlib.h in ${ZLIB_INCLUDE_DIR}""); endif(). INCLUDE_DIRECTORIES(${FREETYPE_INCLUDE_DIR} ${ZLIB_INCLUDE_DIR}). set (LIB_DESTINATION ""${CMAKE_INSTALL_PREFIX}/lib${LIB_SUFFIX}""). FILE(GLOB H_FILES ""*.h""). SET(SRC_FILES; libpng/png.c libpng/pngmem.c libpng/pngrio.c libpng/pngset.c libpng/pngwio.c libpng/pngwutil.c; libpng/pngerror.c libpng/pngpread.c libpng/pngrtran.c libpng/pngtest.c libpng/pngwrite.c; libpng/pngget.c libpng/pngread.c libpng/pngrutil.c libpng/pngtrans.c libpng/pngwtran.c; libjpeg/jcapimin.c libjpeg/jcapistd.c libjpeg/jccoefct.c libjpeg/jccolor.c libjpeg/jcdctmgr.c libjpeg/jchuff.c libjpeg/jcinit.c; libjpeg/jcmainct.c libjpeg/jcmarker.c libjpeg/jcmaster.c libjpeg/jcomapi.c libjpeg/jcparam.c libjpeg/jcphuff.c libjpeg/jcprepct.c; libjpeg/jcsample.c libjpeg/jctrans.c libjpeg/jdapimin.c libjpeg/jdapistd.c libjpeg/jdatadst.c libjpeg/jdatasrc.c libjpe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/CMakeLists.txt:1079,message,message,1079,graf2d/asimage/src/libAfterImage/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/libAfterImage/CMakeLists.txt,1,['message'],['message']
Integrability,"auto &LibA = ES.createJITDylib(""A"");; CXXLayer.add(LibA, MemoryBuffer::getFile(""a1.cpp""));; CXXLayer.add(LibA, MemoryBuffer::getFile(""a2.cpp""));. // Create JITDylib ""B"" and add code to it using the CXX layer.; auto &LibB = ES.createJITDylib(""B"");; CXXLayer.add(LibB, MemoryBuffer::getFile(""b1.cpp""));; CXXLayer.add(LibB, MemoryBuffer::getFile(""b2.cpp""));. // Create and specify the search order for the main JITDylib. This is; // equivalent to a ""links against"" relationship in a command-line link.; auto &MainJD = ES.createJITDylib(""main"");; MainJD.addToLinkOrder(&LibA);; MainJD.addToLinkOrder(&LibB);; CXXLayer.add(MainJD, MemoryBuffer::getFile(""main.cpp""));. // Look up the JIT'd main, cast it to a function pointer, then call it.; auto MainSym = ExitOnErr(ES.lookup({&MainJD}, ""main""));; auto *Main = MainSym.getAddress().toPtr<int(*)(int, char *[])>();. int Result = Main(...);. This example tells us nothing about *how* or *when* compilation will happen.; That will depend on the implementation of the hypothetical CXXCompilingLayer.; The same linker-based symbol resolution rules will apply regardless of that; implementation, however. For example, if a1.cpp and a2.cpp both define a; function ""foo"" then ORCv2 will generate a duplicate definition error. On the; other hand, if a1.cpp and b1.cpp both define ""foo"" there is no error (different; dynamic libraries may define the same symbol). If main.cpp refers to ""foo"", it; should bind to the definition in LibA rather than the one in LibB, since; main.cpp is part of the ""main"" dylib, and the main dylib links against LibA; before LibB. Many JIT clients will have no need for this strict adherence to the usual; ahead-of-time linking rules, and should be able to get by just fine by putting; all of their code in a single JITDylib. However, clients who want to JIT code; for languages/projects that traditionally rely on ahead-of-time linking (e.g.; C++) will find that this feature makes life much easier. Symbol lookup in ORC serves two oth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:8234,depend,depend,8234,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['depend'],['depend']
Integrability,"available to other users, type in; a value for protecting the context with an encryption password. You will have to create a profile for the **master** and the **slave**. Since; most of the configuration variables are the same (like the *HTCondor; shared secret*) you can create one, clone it and change only what's; needed to change. Deploy it on the cloud; ----------------------. Provided you have access to a certain cloud API, you'll need to; instantiate a certain number of CernVM batch images with proper; contextualization: one for the master, as many as you want as slaves. CernVM supports contextualization through the ""user data"" field; supported by all cloud infrastructures. Each cloud infrastructure has a different method of setting the ""user; data"". The following description will focus on:. - [OpenNebula](http://opennebula.org/). - OpenStack (such as the [CERN Agile; infrastructure](https://openstack.cern.ch/)). - [Amazon EC2](http://aws.amazon.com/ec2/)-compatible interfaces via; the open [Eucalyptus](http://www.eucalyptus.com/); [Euca2ools](http://www.eucalyptus.com/eucalyptus-cloud/tools): many popular; clouds support such interface and tools. ### Download the CernVM Online contextualizations. Go to the CernVM Online Dashboard page where you have previously; customized the contexts for your master and your slaves. Click on the rightmost button on the line of the desired context and; select **Get rendered context** from the dropdown: save the output to a; text file (such as `my_vaf_context.txt`, the name we will use in the; examples that follow). This file will be subsequently passed as the so; called ""user-data"" file to the cloud API. > Repeat the operation for both the master context and the slave; > context. ### OpenStack API: nova. Example of a CernVM instantiation using `nova`:. ``` {.bash}; nova boot \; --flavor m1.xlarge \; --image cernvm-batch-node-2.6.0-4-1-x86_64 \; --key-name my_default_keyparir \; --user-data my_vaf_context.txt \; Name-Of-My-New-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md:4183,interface,interfaces,4183,proof/doc/confman/DeployVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md,1,['interface'],['interfaces']
Integrability,"available. .. code-block:: c++. void foo(float *f) {; for (int i = 0; i != 1024; ++i); f[i] = floorf(f[i]);; }. Partial unrolling during vectorization; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Modern processors feature multiple execution units, and only programs that contain a; high degree of parallelism can fully utilize the entire width of the machine.; The Loop Vectorizer increases the instruction level parallelism (ILP) by; performing partial-unrolling of loops. In the example below the entire array is accumulated into the variable 'sum'.; This is inefficient because only a single execution port can be used by the processor.; By unrolling the code the Loop Vectorizer allows two or more execution ports; to be used simultaneously. .. code-block:: c++. int foo(int *A, int n) {; unsigned sum = 0;; for (int i = 0; i < n; ++i); sum += A[i];; return sum;; }. The Loop Vectorizer uses a cost model to decide when it is profitable to unroll loops.; The decision to unroll the loop depends on the register pressure and the generated code size. Epilogue Vectorization; ^^^^^^^^^^^^^^^^^^^^^^. When vectorizing a loop, often a scalar remainder (epilogue) loop is necessary; to execute tail iterations of the loop if the loop trip count is unknown or it; does not evenly divide the vectorization and unroll factors. When the; vectorization and unroll factors are large, it's possible for loops with smaller; trip counts to end up spending most of their time in the scalar (rather than; the vector) code. In order to address this issue, the inner loop vectorizer is; enhanced with a feature that allows it to vectorize epilogue loops with a; vectorization and unroll factor combination that makes it more likely for small; trip count loops to still execute in vectorized code. The diagram below shows; the CFG for a typical epilogue vectorized loop with runtime checks. As; illustrated the control flow is structured in a way that avoids duplicating the; runtime pointer checks and optimizes the path",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst:11148,depend,depends,11148,interpreter/llvm-project/llvm/docs/Vectorizers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst,1,['depend'],['depends']
Integrability,"ave this restriction. Can I do type-based alias analysis on LLVM IR?; ----------------------------------------------. You can't do type-based alias analysis using LLVM's built-in type system,; because LLVM has no restrictions on mixing types in addressing, loads or stores. LLVM's type-based alias analysis pass uses metadata to describe a different type; system (such as the C type system), and performs type-based aliasing on top of; that. Further details are in the; `language reference <LangRef.html#tbaa-metadata>`_. What happens if a GEP computation overflows?; --------------------------------------------. If the GEP lacks the ``inbounds`` keyword, the value is the result from; evaluating the implied two's complement integer computation. However, since; there's no guarantee of where an object will be allocated in the address space,; such values have limited meaning. If the GEP has the ``inbounds`` keyword, the result value is ``poison``; if the GEP overflows (i.e. wraps around the end of the address space). As such, there are some ramifications of this for inbounds GEPs: scales implied; by array/vector/pointer indices are always known to be ""nsw"" since they are; signed values that are scaled by the element size. These values are also; allowed to be negative (e.g. ""``gep i32, ptr %P, i32 -1``"") but the pointer; itself is logically treated as an unsigned value. This means that GEPs have an; asymmetric relation between the pointer base (which is treated as unsigned) and; the offset applied to it (which is treated as signed). The result of the; additions within the offset calculation cannot have signed overflow, but when; applied to the base pointer, there can be signed overflow. How can I tell if my front-end is following the rules?; ------------------------------------------------------. There is currently no checker for the getelementptr rules. Currently, the only; way to do this is to manually check each place in your front-end where; GetElementPtr operators are cre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:17778,wrap,wraps,17778,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['wrap'],['wraps']
Integrability,"avior can be set by the client. By default each; materializer is run on the calling thread. Clients are free to create new; threads to run materializers, or to send the work to a work queue for a thread; pool (this is what LLJIT/LLLazyJIT do). Top Level APIs; ==============. Many of ORC's top-level APIs are visible in the example above:. - *ExecutionSession* represents the JIT'd program and provides context for the; JIT: It contains the JITDylibs, error reporting mechanisms, and dispatches the; materializers. - *JITDylibs* provide the symbol tables. - *Layers* (ObjLinkingLayer and CXXLayer) are wrappers around compilers and; allow clients to add uncompiled program representations supported by those; compilers to JITDylibs. - *ResourceTrackers* allow you to remove code. Several other important APIs are used explicitly. JIT clients need not be aware; of them, but Layer authors will use them:. - *MaterializationUnit* - When XXXLayer::add is invoked it wraps the given; program representation (in this example, C++ source) in a MaterializationUnit,; which is then stored in the JITDylib. MaterializationUnits are responsible for; describing the definitions they provide, and for unwrapping the program; representation and passing it back to the layer when compilation is required; (this ownership shuffle makes writing thread-safe layers easier, since the; ownership of the program representation will be passed back on the stack,; rather than having to be fished out of a Layer member, which would require; synchronization). - *MaterializationResponsibility* - When a MaterializationUnit hands a program; representation back to the layer it comes with an associated; MaterializationResponsibility object. This object tracks the definitions; that must be materialized and provides a way to notify the JITDylib once they; are either successfully materialized or a failure occurs. Absolute Symbols, Aliases, and Reexports; ========================================. ORC makes it easy to define",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:11962,wrap,wraps,11962,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['wrap'],['wraps']
Integrability,"avoid this behaviour. This is useful; when drawing a `THStack` on top of an other plot. If the patterns used to; draw the histograms in the stack are transparents, then the plot behind; will be visible. ### TH2Poly. - Implement a simple version of ""Scale"". ### TF1. - Change `TF1::Integral(double a, double b, double * params = 0, double eps = 1.E-12)` to; `TF1::Integral(doubnle a, double b, double epsrel=1.E-12)`. One should use `TF1::SetParameters` to; set the function parameters before computing the integral. - Add a new function `TF1::IntegralOneDim(Double_t a, Double_t b, Double_t epsrel, Double_t epsabs, Double_t &err)`; that returns as last argument the error in the integration. `TF1::Integral` is implemented using `Tf1::IntegralOneDim`. - The one-dim and multi-dim integral functions are now implemented using the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim`; classes. This allows to change the integration algorithm used in `TF1` using the static methods of the classes; `ROOT::Math::IntegratorOneDimOptions` and `ROOT::Math::IntegratorMultiDimOptions`. The default algorithm used are; `ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType()` and `ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType()`.; For example, if ROOT has been built with mathmore the default one-dim integration type is the GSL AdaptiveSingular integration algorithm. - Implement the possibility to save a `TF1` as C code indenpant from; ROOT. It is enough to save the function as a "".cc"" file. \; Example:. ``` {.cpp}; root [0] TF1 *f1 = new TF1(""f1"",""x*x"",-10,10); root [1] f1->SaveAs(""f1.cc"");; Info in <TF1::SaveAs>: cc file: f1.cc has been generated; root [2] .x f1.cc(9.); (double)8.10019368181367980e+01; ```. ### TF2, TF3. - Implement `TF2::GetMinimumXY` and `TF3::GetMinimumXYZ` using the `ROOT::Math::Minimizer` class instead of `TFitter`. The methods return now the function value at the minimum. - Implement also a `TF2::GetMaximumXY` and `TF3::GetMaximumXYZ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md:13027,integrat,integration,13027,hist/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md,1,['integrat'],['integration']
Integrability,"ax No 200 − nEventsMax for adaptive volume range. MaxVIterations No 150 − MaxVIterations for adaptive volume range. InitialScale No 0.99 − InitialScale for adaptive volume range. GaussSigma No 0.1 − Width (wrt volume size) of Gaussian kernel estimator. NormTree No False − Normalize binary search tree. Configuration options for MVA method :. Configuration options reference for MVA method: FDA. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). Formula No (0) − The discrimination formula. ParRanges No () − Parameter ranges. FitMethod No MINUIT MC, GA, SA, MINUIT Optimisation Method. Converger No None None, MINUIT FitMethod uses Converger to improve result. Configuration options for MVA method :. Configuration options reference for MVA method: LD. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:5773,message,message,5773,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['message'],['message']
Integrability,"ayload of the ``SDNode`` is its operation code; (Opcode) that indicates what operation the node performs and the operands to the; operation. The various operation node types are described at the top of the; ``include/llvm/CodeGen/ISDOpcodes.h`` file. Although most operations define a single value, each node in the graph may; define multiple values. For example, a combined div/rem operation will define; both the dividend and the remainder. Many other situations require multiple; values as well. Each node also has some number of operands, which are edges to; the node defining the used value. Because nodes may define multiple values,; edges are represented by instances of the ``SDValue`` class, which is a; ``<SDNode, unsigned>`` pair, indicating the node and result value being used,; respectively. Each value produced by an ``SDNode`` has an associated ``MVT``; (Machine Value Type) indicating what the type of the value is. SelectionDAGs contain two different kinds of values: those that represent data; flow and those that represent control flow dependencies. Data values are simple; edges with an integer or floating point value type. Control edges are; represented as ""chain"" edges which are of type ``MVT::Other``. These edges; provide an ordering between nodes that have side effects (such as loads, stores,; calls, returns, etc). All nodes that have side effects should take a token; chain as input and produce a new one as output. By convention, token chain; inputs are always operand #0, and chain results are always the last value; produced by an operation. However, after instruction selection, the; machine nodes have their chain after the instruction's operands, and; may be followed by glue nodes. A SelectionDAG has designated ""Entry"" and ""Root"" nodes. The Entry node is; always a marker node with an Opcode of ``ISD::EntryToken``. The Root node is; the final side-effecting node in the token chain. For example, in a single basic; block function it would be the return node. On",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:35355,depend,dependencies,35355,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['depend'],['dependencies']
Integrability,"ays is of variable length, and in particular; that the second array is jagged. **Example:** Suppose a hypothetical PDB file with a 4KiB block size, and 4; streams of lengths {1000 bytes, 8000 bytes, 16000 bytes, 9000 bytes}. Stream 0: ceil(1000 / 4096) = 1 block. Stream 1: ceil(8000 / 4096) = 2 blocks. Stream 2: ceil(16000 / 4096) = 4 blocks. Stream 3: ceil(9000 / 4096) = 3 blocks. In total, 10 blocks are used. Let's see what the stream directory might look; like:. .. code-block:: c++. struct StreamDirectory {; ulittle32_t NumStreams = 4;; ulittle32_t StreamSizes[] = {1000, 8000, 16000, 9000};; ulittle32_t StreamBlocks[][] = {; {4},; {5, 6},; {11, 9, 7, 8},; {10, 15, 12}; };; };. In total, this occupies ``15 * 4 = 60`` bytes, so; ``SuperBlock->NumDirectoryBytes`` would equal ``60``, and; ``SuperBlock->BlockMapAddr`` would be an array of one ``ulittle32_t``, since; ``60 <= SuperBlock->BlockSize``. Note also that the streams are discontiguous, and that part of stream 3 is in the; middle of part of stream 2. You cannot assume anything about the layout of the; blocks!. Alignment and Block Boundaries; ==============================; As may be clear by now, it is possible for a single field (whether it be a high; level record, a long string field, or even a single ``uint16``) to begin and; end in separate blocks. For example, if the block size is 4096 bytes, and a; ``uint16`` field begins at the last byte of the current block, then it would; need to end on the first byte of the next block. Since blocks are not; necessarily contiguously laid out in the file, this means that both the consumer; and the producer of an MSF file must be prepared to split data apart; accordingly. In the aforementioned example, the high byte of the ``uint16``; would be written to the last byte of block N, and the low byte would be written; to the first byte of block N+1, which could be tens of thousands of bytes later; (or even earlier!) in the file, depending on what the stream directory says.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst:7672,depend,depending,7672,interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst,1,['depend'],['depending']
Integrability,"bage collection intrinsics; <gc_intrinsics>` that offer support for a broad class of collector models. For; instance, the intrinsics permit:. * semi-space collectors. * mark-sweep collectors. * generational collectors. * incremental collectors. * concurrent collectors. * cooperative collectors. * reference counting. We hope that the support built into the LLVM IR is sufficient to support a; broad class of garbage collected languages including Scheme, ML, Java, C#,; Perl, Python, Lua, Ruby, other scripting languages, and more. Note that LLVM **does not itself provide a garbage collector** --- this should; be part of your language's runtime library. LLVM provides a framework for; describing the garbage collectors requirements to the compiler. In particular,; LLVM provides support for generating stack maps at call sites, polling for a; safepoint, and emitting load and store barriers. You can also extend LLVM -; possibly through a loadable :ref:`code generation plugins <plugin>` - to; generate code and data structures which conforms to the *binary interface*; specified by the *runtime library*. This is similar to the relationship between; LLVM and DWARF debugging info, for example. The difference primarily lies in; the lack of an established standard in the domain of garbage collection --- thus; the need for a flexible extension mechanism. The aspects of the binary interface with which LLVM's GC support is; concerned are:. * Creation of GC safepoints within code where collection is allowed to execute; safely. * Computation of the stack map. For each safe point in the code, object; references within the stack frame must be identified so that the collector may; traverse and perhaps update them. * Write barriers when storing object references to the heap. These are commonly; used to optimize incremental scans in generational collectors. * Emission of read barriers when loading object references. These are useful; for interoperating with concurrent collectors. There are add",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:6147,interface,interface,6147,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['interface'],['interface']
Integrability,"base offset). The ``RelocationType`` enum; for that target is defined in the short target-specific ``XXXRelocations.h``; file. The ``RelocationType`` is used by the ``relocate`` method defined in; ``XXXJITInfo.cpp`` to rewrite addresses for referenced global symbols. For example, ``X86Relocations.h`` specifies the following relocation types for; the X86 addresses. In all four cases, the relocated value is added to the; value already in memory. For ``reloc_pcrel_word`` and ``reloc_picrel_word``,; there is an additional initial adjustment. .. code-block:: c++. enum RelocationType {; reloc_pcrel_word = 0, // add reloc value after adjusting for the PC loc; reloc_picrel_word = 1, // add reloc value after adjusting for the PIC base; reloc_absolute_word = 2, // absolute relocation; no additional adjustment; reloc_absolute_dword = 3 // absolute relocation; no additional adjustment; };. Target JIT Info; ---------------. ``XXXJITInfo.cpp`` implements the JIT interfaces for target-specific; code-generation activities, such as emitting machine code and stubs. At; minimum, a target-specific version of ``XXXJITInfo`` implements the following:. * ``getLazyResolverFunction`` --- Initializes the JIT, gives the target a; function that is used for compilation. * ``emitFunctionStub`` --- Returns a native function with a specified address; for a callback function. * ``relocate`` --- Changes the addresses of referenced globals, based on; relocation types. * Callback function that are wrappers to a function stub that is used when the; real target is not initially known. ``getLazyResolverFunction`` is generally trivial to implement. It makes the; incoming parameter as the global ``JITCompilerFunction`` and returns the; callback function that will be used a function wrapper. For the Alpha target; (in ``AlphaJITInfo.cpp``), the ``getLazyResolverFunction`` implementation is; simply:. .. code-block:: c++. TargetJITInfo::LazyResolverFn AlphaJITInfo::getLazyResolverFunction(; JITCompilerFn F) {; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:82106,interface,interfaces,82106,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['interface'],['interfaces']
Integrability,"bclang library""); mark_as_advanced(CLANG_EXECUTABLE_VERSION LIBCLANG_LIBRARY_VERSION). option(CLANG_INCLUDE_TESTS; ""Generate build targets for the Clang unit tests.""; ${LLVM_INCLUDE_TESTS}). option(CLANG_ENABLE_HLSL ""Include HLSL build products"" Off); # While HLSL support is experimental this should stay hidden.; mark_as_advanced(CLANG_ENABLE_HLSL). add_subdirectory(utils/TableGen). # Export CLANG_TABLEGEN_EXE for use by flang docs.; set(CLANG_TABLEGEN_EXE ""${CLANG_TABLEGEN_EXE}"" CACHE INTERNAL """"). add_subdirectory(include). # All targets below may depend on all tablegen'd files.; get_property(CLANG_TABLEGEN_TARGETS GLOBAL PROPERTY CLANG_TABLEGEN_TARGETS); add_custom_target(clang-tablegen-targets; DEPENDS; omp_gen; ClangDriverOptions; ${CLANG_TABLEGEN_TARGETS}); set_target_properties(clang-tablegen-targets PROPERTIES FOLDER ""Misc""); list(APPEND LLVM_COMMON_DEPENDS clang-tablegen-targets). # Force target to be built as soon as possible. Clang modules builds depend; # header-wise on it as they ship all headers from the umbrella folders. Building; # an entire module might include header, which depends on intrinsics_gen.; if(LLVM_ENABLE_MODULES); list(APPEND LLVM_COMMON_DEPENDS intrinsics_gen); endif(). add_subdirectory(lib); add_subdirectory(tools); add_subdirectory(runtime). option(CLANG_BUILD_EXAMPLES ""Build CLANG example programs by default."" OFF); add_subdirectory(examples). if(APPLE); # this line is needed as a cleanup to ensure that any CMakeCaches with the old; # default value get updated to the new default.; if(CLANG_ORDER_FILE STREQUAL """"); unset(CLANG_ORDER_FILE CACHE); unset(CLANG_ORDER_FILE); endif(). set(CLANG_ORDER_FILE ${CMAKE_CURRENT_BINARY_DIR}/clang.order CACHE FILEPATH; ""Order file to use when compiling clang in order to improve startup time (Darwin Only - requires ld64).""). if(NOT EXISTS ${CLANG_ORDER_FILE}); string(FIND ""${CLANG_ORDER_FILE}"" ""${CMAKE_CURRENT_BINARY_DIR}"" PATH_START); if(PATH_START EQUAL 0); file(WRITE ${CLANG_ORDER_FILE} ""\n""); els",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:17574,depend,depend,17574,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['depend'],['depend']
Integrability,"bclang_rt.builtins.*.a""). .. option:: -print-prog-name=<name>. Print the full program path of name. .. option:: -print-search-dirs. Print the paths used for finding libraries and programs. .. option:: -save-temps. Save intermediate compilation results. .. option:: -save-stats, -save-stats=cwd, -save-stats=obj. Save internal code generation (LLVM) statistics to a file in the current; directory (:option:`-save-stats`/""-save-stats=cwd"") or the directory; of the output file (""-save-state=obj""). You can also use environment variables to control the statistics reporting.; Setting ``CC_PRINT_INTERNAL_STAT`` to ``1`` enables the feature, the report; goes to stdout in JSON format. Setting ``CC_PRINT_INTERNAL_STAT_FILE`` to a file path makes it report; statistics to the given file in the JSON format. Note that ``-save-stats`` take precedence over ``CC_PRINT_INTERNAL_STAT``; and ``CC_PRINT_INTERNAL_STAT_FILE``. .. option:: -integrated-as, -no-integrated-as. Used to enable and disable, respectively, the use of the integrated; assembler. Whether the integrated assembler is on by default is target; dependent. .. option:: -time. Time individual commands. .. option:: -ftime-report. Print timing summary of each stage of compilation. .. option:: -v. Show commands to run and use verbose output. Diagnostics Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -fshow-column, -fshow-source-location, -fcaret-diagnostics, -fdiagnostics-fixit-info, -fdiagnostics-parseable-fixits, -fdiagnostics-print-source-range-info, -fprint-source-range-info, -fdiagnostics-show-option, -fmessage-length. These options control how Clang prints out information about diagnostics; (errors and warnings). Please see the Clang User's Manual for more information. Preprocessor Options; ~~~~~~~~~~~~~~~~~~~~. .. option:: -D<macroname>=<value>. Adds an implicit #define into the predefines buffer which is read before the; source file is preprocessed. .. option:: -U<macroname>. Adds an implicit #undef into the predefines buffer wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:18163,integrat,integrated,18163,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,1,['integrat'],['integrated']
Integrability,"be independent of the ROOT *`Hist`* library,; takes as input a more general parametric function object, the interface (abstract) class `ROOT::Math::IParametricFunctionMultiDim`, which describe a generic one or multi-dimensional function; with parameters. This interface extends the abstract class `ROOT::Math::IBaseFunctionMultiDim`, with methods to set/retrieve parameter values and to evaluate the function given the; independent vector of values **`X`** and vector of parameters `P`.; More information about the different `ROOT::Math` function interfaces is available in the Mathematical Library chapter. An end-user can convert a **`TF1`** object in a `ROOT::Math::IParametricFunctionMultiDim`, using the wrapper class `ROOT::Math::WrapperMultiTF1`:. ``` {.cpp}; TF1 * f1 = new TF1(""f1"",""gaus"");; ROOT::Math::WrappedMultiTF1 fitFunction(f1, f1->GetNdim() );; ROOT::Fit::Fitter fitter;; fitter.SetFunction( fitFunction, false);; ```. When creating the wrapper, the parameter values stored in **`TF1`** will be copied in the `ROOT::Math::WrappedMultiTF1` object.; The function object representing the model function is given to the `ROOT::Fitter` class using the `Fitter::SetFunction` method. The user has also the possibility to provide a function object, which implements the derivatives of the function with respect; to the parameters.; This information might be useful for some types of fits. In this case he needs to provide the function object as a class deriving from the; `ROOT::Math::IParametricGradFunctionMultiDim` interface.; Note that the wrapper class `ROOT::Math::WrappedMultiTF1` implements also the gradient interface, using internally `TF1::GradientPar`,; which is based on numerical differentiation, apart for the case of linear functions (i.e. when `TF1::IsLinear()` is `true`).; The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili.; However, in general is better to leave the minimization algorithm (e.g. Minuit) to com",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:36960,wrap,wrapper,36960,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['wrap'],['wrapper']
Integrability,"be used to access ``Function`` or ``Module`` level analysis information. .. _writing-an-llvm-pass-runOnRegion:. The ``runOnRegion`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnRegion(Region *, RGPassManager &RGM) = 0;. The ``runOnRegion`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a true value should be; returned if the region is modified. ``RGPassManager`` interface should be used to; update region tree. The ``doFinalization()`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization();. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnRegion; <writing-an-llvm-pass-runOnRegion>` for every region in the program being; compiled. The ``MachineFunctionPass`` class; ---------------------------------. A ``MachineFunctionPass`` is a part of the LLVM code generator that executes on; the machine-dependent representation of each LLVM function in the program. Code generator passes are registered and initialized specially by; ``TargetMachine::addPassesToEmitFile`` and similar routines, so they cannot; generally be run from the :program:`opt` or :program:`bugpoint` commands. A ``MachineFunctionPass`` is also a ``FunctionPass``, so all the restrictions; that apply to a ``FunctionPass`` also apply to it. ``MachineFunctionPass``\ es; also have additional restrictions. In particular, ``MachineFunctionPass``\ es; are not allowed to do any of the following:. #. Modify or create any LLVM IR ``Instruction``\ s, ``BasicBlock``\ s,; ``Argument``\ s, ``Function``\ s, ``GlobalVariable``\ s,; ``GlobalAlias``\ es, or ``Module``\ s.; #. Modify a ``MachineFunction`` other than the one currently being processed.; #. Maintain state across invocations of :ref:`runOnMachineFunction; <writing-an-llvm-pass-runOnMachineFunction>` (including global data). .. _writing-an-llvm-pass-runOnMac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:24823,depend,dependent,24823,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['depend'],['dependent']
Integrability,"be; downhill only if the covariance matrix is positive–definite, so in case; this is not true, it makes a positive–definite approximation by adding; an appropriate constant along the diagonal as determined by the; eigenvalues of the matrix. Theoretically, the covariance matrix for a; ""physical"" function must be positive–definite at the minimum, although; it may not be so for all points far away from the minimum, even for a; well–determined physical problem. Therefore, if $\mbox{MIGRAD}$; reports that it has found a non-positive–definite covariance matrix,; this may be a sign of one or more of the following:. - **A non–physical region.** On its way to the minimum,; $\mbox{MIGRAD}$ may have traversed a region which has unphysical; behaviour, which is of course not a serious problem as long as it; recovers and leaves such a region. - **An underdetermined problem.** If the matrix is not; positive–definite even at the minimum, this may mean that the; solution is not well–defined, for example that there are more; unknowns than there are data points, or that the parametrization of; the fit contains a linear dependence. If this is the case, then M; (or any other program) cannot solve your problem uniquely, and the; error matrix will necessarily be largely meaningless, so the user; must remove the under-determinedness by reformulating the; parametrization. M cannot do this itself, but it can provide some; hints (contours, global correlation coefficients, eigenvalues) which; can help the clever user to find out what is wrong. - **Numerical inaccuracies.** It is possible that the apparent lack of; positive–definiteness is in fact only due to excessive roundoff; errors in numerical calculations, either in $\mbox{FCN}$ or in M; . This is unlikely in general, but becomes more likely if the number; of free parameters is very large, or if the parameters are badly; scaled (not all of the same order of magnitude), and correlations; are also large. In any case, whether the non–positive",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:72507,depend,dependence,72507,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['depend'],['dependence']
Integrability,"ber function will be; called first. It will return an ``Expected<SourceRange>``. #. If the return value is an error the initiation will fail and the error; will be reported to the client. Note that the client may not report the; error to the user. #. Otherwise the source range return value will be used to construct the; ``DeleteSelectedRange`` rule. The rule will then be invoked as the initiation; succeeded (all requirements were evaluated successfully). The same series of steps applies to any refactoring rule. Firstly, the engine; will evaluate all of the requirements. Then it will check if these requirements; are satisfied (they should not produce an error). Then it will construct the; rule and invoke it. The separation of requirements, their evaluation and the invocation of the; refactoring action rule allows the refactoring clients to:. - Disable refactoring action rules whose requirements are not supported. - Gather the set of options and define a command-line / visual interface; that allows users to input these options without ever invoking the; action. Selection Requirements; ^^^^^^^^^^^^^^^^^^^^^^. The refactoring rule requirements that require some form of source selection; are listed below:. - ``SourceRangeSelectionRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range will contain the cursor's location in; that case). .. FIXME: Future selection requirements. .. FIXME: Maybe mention custom selection requirements?. Other Requirements; ^^^^^^^^^^^^^^^^^^. There are several other requirements types that can be used when creating; a refactoring rule:. - The ``RefactoringOptionsRequirement`` requirement is an abstract class that; should be subclassed by requirements working with options. The more; concrete ``OptionRequirement`` requirement is a simple implementation of the; afore",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:8565,interface,interface,8565,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['interface'],['interface']
Integrability,"bility R, ThreadSafeModule TSM) override;. private:; IRLayer &BaseLayer;; TransformFunction Transform;; };. // From IRTransformLayer.cpp:. IRTransformLayer::IRTransformLayer(ExecutionSession &ES,; IRLayer &BaseLayer,; TransformFunction Transform); : IRLayer(ES), BaseLayer(BaseLayer), Transform(std::move(Transform)) {}. void IRTransformLayer::emit(MaterializationResponsibility R,; ThreadSafeModule TSM) {; assert(TSM.getModule() && ""Module must not be null"");. if (auto TransformedTSM = Transform(std::move(TSM), R)); BaseLayer.emit(std::move(R), std::move(*TransformedTSM));; else {; R.failMaterialization();; getExecutionSession().reportError(TransformedTSM.takeError());; }; }. This is the whole definition of IRTransformLayer, from; ``llvm/include/llvm/ExecutionEngine/Orc/IRTransformLayer.h`` and; ``llvm/lib/ExecutionEngine/Orc/IRTransformLayer.cpp``. This class is concerned; with two very simple jobs: (1) Running every IR Module that is emitted via this; layer through the transform function object, and (2) implementing the ORC; ``IRLayer`` interface (which itself conforms to the general ORC Layer concept,; more on that below). Most of the class is straightforward: a typedef for the; transform function, a constructor to initialize the members, a setter for the; transform function value, and a default no-op transform. The most important; method is ``emit`` as this is half of our IRLayer interface. The emit method; applies our transform to each module that it is called on and, if the transform; succeeds, passes the transformed module to the base layer. If the transform; fails, our emit function calls; ``MaterializationResponsibility::failMaterialization`` (this JIT clients who; may be waiting on other threads know that the code they were waiting for has; failed to compile) and logs the error with the execution session before bailing; out. The other half of the IRLayer interface we inherit unmodified from the IRLayer; class:. .. code-block:: c++. Error IRLayer::add(JITDyli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:8102,interface,interface,8102,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['interface'],['interface']
Integrability,"bin smaller than nevent). The optimization is also exact: the likelihood of a binned ; data using a binned pdf is identical to that of an unbinned dataset with a binned pdf. Nevertheless you can ; switch off this feature by passing AutoBinned(false) to RooAbsPdf::generate(). Mixed binned/unbinned generation from simultaneous pdf. For a RooSimultaneous consisting of exclusively; extended terms it is now possible to generate a mixed binned/unbinned datasets. Components defined; by a binned pdf at the top level are automatically generated binned (unless AutoBinned(false) is set); but it is also possible to generate other component pdfs forcibly binned by adding GenBinned(tagname); to generate(). In that case all component pdfs labeled with pdf->setAttribute(tagname) will be generated; binned. To generate all component binned, the shorthand method AllBinned() can be used. All binned; datasets made by generate are represented as weighted unbinned datasets (of type RooDataSet) rather; than binned datasets of type RooDataHist so that mixed binned/unbinned data is always represented; through a uniform interface. Fix in the optimization strategy of likelihoods constructed from simultaneous pdf. In the parameter; dependency analysis of the components of a simultaneous pdfs parameters originating from 'irrelevant'; constraint terms (i.e. those that don't relate to any of the parameters of that likelihood component) were; not ignored, which could result in a substantial loss of computational efficiency as likelihood; terms were erroneously recalculated even if no relevant parameters was changed. General performance tuning of RooFit to reduce computational overhead. Extensive profiling of; CPU times in call graphas and analysis heap memory use have been performed and many small ; changes have been made to make the code more efficient and use less memory. RooStats Package; AsymptoticCalculator. New Class for doing an hypothesis tests using the asymptotic likelihood formulae, descr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html:6154,interface,interface,6154,roofit/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html,1,['interface'],['interface']
Integrability,bitcode file. Lower ``#pragma; omp target`` declarations to :ref:`offloading entries <Generating Offloading; Entries>` and create metadata to indicate which entries are on the device.; * Compile the input file for the target :ref:`device <Device Compilation>` using; the :ref:`offloading entry <Generating Offloading Entries>` metadata created; by the host.; * Link the OpenMP device runtime library and run the backend to create a device; object file.; * Run the backend on the host bitcode file and create a :ref:`fat object file; <Creating Fat Objects>` using the device object file.; * Pass the fat object file to the :ref:`linker wrapper tool <Device Linking>`; and extract the device objects. Run the device linking action on the extracted; objects.; * :ref:`Wrap <Device Binary Wrapping>` the :ref:`device images <Device linking>`; and :ref:`offload entries <Generating Offloading Entries>` in a symbol that; can be accessed by the host.; * Add the :ref:`wrapped binary <Device Binary Wrapping>` to the linker input and; run the host linking action. Link with ``libomptarget`` to register and; execute the images. .. _Generating Offloading Entries:. Generating Offloading Entries; -----------------------------. The first step in compilation is to generate offloading entries for the host.; This information is used to identify function kernels or global values that will; be provided by the device. Blocks contained in a ``#pragma omp target`` or; symbols inside a ``#pragma omp declare target`` directive will have offloading; entries generated. The following table shows the :ref:`offload entry structure; <table-tgt_offload_entry_structure>`. .. table:: __tgt_offload_entry Structure; :name: table-tgt_offload_entry_structure. +---------+------------+------------------------------------------------------------------------+; | Type | Identifier | Description |; +=========+============+========================================================================+; | void* | addr | Address of,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:2841,wrap,wrapped,2841,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst,1,['wrap'],['wrapped']
Integrability,"bjC); Check for logical errors for function calls and Objective-C message expressions; (e.g., uninitialized arguments, null function pointers). // C; struct S {; int x;; };. void f(struct S s);. void test() {; struct S s;; f(s); // warn: passed-by-value arg contain uninitialized data; }. // C; void test() {; void (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1.x; // warn: uninitialized object pointer; }. // Objective-C; @interface Subscriptable : NSObject; - (id)objectAtIndexedSubscript:(unsigned int)index;; @end. @interface MyClass : Subscriptable; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1[0]; // warn: uninitialized object pointer; }. core.DivideZero; (C, C++, ObjC); Check for division by zero.co. void test(int z) {; if (z == 0); int x = 1 / z; // warn; }. void test() {; int x = 1;; int y = x % 0; // warn; }. core.NonNullParamChecker; (C, C++, ObjC); Check for null pointers passed as arguments to a function whose arguments are; marked with the nonnull attribute. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. core.NullDereference; (C, C++, ObjC); Check for dereferences of null pointers. // C; void test(int *p) {; if (p); return;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:2267,interface,interface,2267,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['interface'],['interface']
Integrability,"bjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matches Objective-C instance variable declarations. Example matches _enabled; @implementation Foo {; BOOL _enabled;; }; @end. Matcher<Decl>objcMethodDeclMatcher<ObjCMethodDecl>...; Matches Objective-C method declarations. Example matches both declaration and definition of -[Foo method]; @interface Foo; - (void)method;; @end. @implementation Foo; - (void)method {}; @end. Matcher<Decl>objcPropertyDeclMatcher<ObjCPropertyDecl>...; Matches Objective-C property declarations. Example matches enabled; @interface Foo; @property BOOL enabled;; @end. Matcher<Decl>objcProtocolDeclMatcher<ObjCProtocolDecl>...; Matches Objective-C protocol declarations. Example matches FooDelegate; @protocol FooDelegate; @end. Matcher<Decl>parmVarDeclMatcher<ParmVarDecl>...; Matches parameter variable declarations. Given; void f(int x);; parmVarDecl(); matches int x. Matcher<Decl>recordDeclMatcher<RecordDecl>...; Matches class, struct, and union declarations. Example matches X, Z, U, and S; class X;; template<class T> class Z {};; struct S {};; union U {};. Matcher<Decl>staticAssertDeclMatcher<StaticAssertDecl>...; Matches a C++ static_assert declaration. Example:; staticAssertDecl(); matches; static_assert(sizeof(S) == sizeof(int)); in; struct S {; int x;; };; static_assert(sizeof(S) == sizeof(int));. Matcher<Decl>tagDeclMatcher<TagDecl>...; Matches tag declarations. Example matches X, Z, U, S, E; class X;; template<class T> class Z {};; struct S {};; union U {};; enum E {; A, B, C; };. Matcher<Decl>templateTemplateParmDeclMatcher<TemplateTemplateParmDecl>...; Matches template template parameter declarations. Given; template <template <typename> class Z, int N> struct C {};; te",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:16352,protocol,protocol,16352,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['protocol'],['protocol']
Integrability,"bjCMessageExpr(hasKeywordSelector()) matches the generated setFrame; message expression in. UIWebView *webView = ...;; CGRect bodyFrame = webView.frame;; bodyFrame.size.height = self.bodyContentHeight;; webView.frame = bodyFrame;; // ^---- matches here. Matcher<ObjCMessageExpr>hasNullSelector; Matches when the selector is the empty selector. Matches only when the selector of the objCMessageExpr is NULL. This may; represent an error condition in the tree!. Matcher<ObjCMessageExpr>hasSelectorstd::string BaseName; Matches when BaseName == Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""loadHTMLString:baseURL:""));; matches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>hasUnarySelector; Matches when the selector is a Unary Selector. matcher = objCMessageExpr(matchesSelector(hasUnarySelector());; matches self.bodyView in the code below, but NOT the outer message; invocation of ""loadHTMLString:baseURL:"".; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>isClassMessage; Returns true when the Objective-C message is sent to a class. Example; matcher = objcMessageExpr(isClassMessage()); matches; [NSString stringWithFormat:@""format""];; but not; NSString *x = @""hello"";; [x containsString:@""h""];. Matcher<ObjCMessageExpr>isInstanceMessage; Returns true when the Objective-C message is sent to an instance. Example; matcher = objcMessageExpr(isInstanceMessage()); matches; NSString *x = @""hello"";; [x containsString:@""h""];; but not; [NSString stringWithFormat:@""format""];. Matcher<ObjCMessageExpr>matchesSelectorStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches ObjC selectors whose name contains; a substring matched by the given RegExp.; matcher = objCMessageExpr(matchesSelector(""loadHTMLStringmatches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTML",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:107129,message,message,107129,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['message'],['message']
Integrability,"bjects, run the device linking step, and embed the final image in a symbol the; host runtime library can use to register the library and access the symbols on; the device. Compilation Process; ^^^^^^^^^^^^^^^^^^^. The compiler performs the following high-level actions to generate OpenMP; offloading code:. * Compile the input file for the host to produce a bitcode file. Lower ``#pragma; omp target`` declarations to :ref:`offloading entries <Generating Offloading; Entries>` and create metadata to indicate which entries are on the device.; * Compile the input file for the target :ref:`device <Device Compilation>` using; the :ref:`offloading entry <Generating Offloading Entries>` metadata created; by the host.; * Link the OpenMP device runtime library and run the backend to create a device; object file.; * Run the backend on the host bitcode file and create a :ref:`fat object file; <Creating Fat Objects>` using the device object file.; * Pass the fat object file to the :ref:`linker wrapper tool <Device Linking>`; and extract the device objects. Run the device linking action on the extracted; objects.; * :ref:`Wrap <Device Binary Wrapping>` the :ref:`device images <Device linking>`; and :ref:`offload entries <Generating Offloading Entries>` in a symbol that; can be accessed by the host.; * Add the :ref:`wrapped binary <Device Binary Wrapping>` to the linker input and; run the host linking action. Link with ``libomptarget`` to register and; execute the images. .. _Generating Offloading Entries:. Generating Offloading Entries; -----------------------------. The first step in compilation is to generate offloading entries for the host.; This information is used to identify function kernels or global values that will; be provided by the device. Blocks contained in a ``#pragma omp target`` or; symbols inside a ``#pragma omp declare target`` directive will have offloading; entries generated. The following table shows the :ref:`offload entry structure; <table-tgt_offload_entry_s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:2514,wrap,wrapper,2514,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst,1,['wrap'],['wrapper']
Integrability,"ble * mat) and Minimizer::GetCovMatrix(double * mat) to return the full; matrices by filling the passed C arrays, which must have a dimension of at least n x n, where n is the; total number of parameters. The elements for the fixed parameters will be filled with zeros.; These methods are currently implemented by only Minuit and Minuit2. Change default tolerance in ROOT::Math::MinimizerOptions to be 0.01 from 0.0001. MathMore. New class ROOT::Math::GSLMultiRootFinder for finding the root of system of functions.; The class is based on the GSL multi-root algorithm; (see the GSL online; manual) and it is used to solve a non-linear system of equations:; ; f1(x1,....xn) = 0; f2(x1,....xn) = 0; ..................; fn(x1,....xn) = 0. The available GSL algorithms require the derivatives of the supplied functions or not (they are; computed internally by GSL). In the first case the user needs to provide a list of multidimensional functions implementing the; gradient interface (ROOT::Math::IMultiGradFunction) while in the second case it is enough to supply a list of; functions implementing the ROOT::Math::IMultiGenFunction interface.; The available algorithms requiring derivatives (see also the GSL; documentation ); are the followings:; ; ROOT::Math::GSLMultiRootFinder::kHybridSJ with name ""HybridSJ"": modified Powell's hybrid; method as implemented in HYBRJ in MINPACK; ROOT::Math::GSLMultiRootFinder::kHybridJ with name ""HybridJ"": unscaled version of the; previous algorithm; ROOT::Math::GSLMultiRootFinder::kNewton with name ""Newton"": Newton method ; ROOT::Math::GSLMultiRootFinder::kGNewton with name ""GNewton"": modified Newton method . The algorithms without derivatives (see also the GSL; documentation ); are the followings:; ; ROOT::Math::GSLMultiRootFinder::kHybridS with name ""HybridS"": same as HybridSJ but using; finate difference approximation for the derivatives; ROOT::Math::GSLMultiRootFinder::kHybrid with name ""Hybrid"": unscaled version of the; previous algorithm; ROOT::Ma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v530/index.html:3451,interface,interface,3451,math/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v530/index.html,2,['interface'],['interface']
Integrability,"ble to provide working H and D overloads in both classes. In this; case, clang is likely to be unhappy with you. .. code-block:: c++. #ifdef __CUDA_ARCH__; struct S {; __device__ void foo() { /* use device_only */ }; int device_only;; };; #else; struct S {; __host__ void foo() { /* use host_only */ }; double host_only;; };. __device__ void test() {; S s;; // clang generates an error here, because during host compilation, we; // have ifdef'ed away the __device__ overload of S::foo(). The __device__; // overload must be present *even during host compilation*.; S.foo();; }; #endif. We posit that you don't really want to have classes with different members on H; and D. For example, if you were to pass one of these as a parameter to a; kernel, it would have a different layout on H and D, so would not work; properly. To make code like this compatible with clang, we recommend you separate it out; into two classes. If you need to write code that works on both host and; device, consider writing an overloaded wrapper function that returns different; types on host and device. .. code-block:: c++. struct HostS { ... };; struct DeviceS { ... };. __host__ HostS MakeStruct() { return HostS(); }; __device__ DeviceS MakeStruct() { return DeviceS(); }. // Now host and device code can call MakeStruct(). Unfortunately, this idiom isn't compatible with nvcc, because it doesn't allow; you to overload based on the H/D attributes. Here's an idiom that works with; both clang and nvcc:. .. code-block:: c++. struct HostS { ... };; struct DeviceS { ... };. #ifdef __NVCC__; #ifndef __CUDA_ARCH__; __host__ HostS MakeStruct() { return HostS(); }; #else; __device__ DeviceS MakeStruct() { return DeviceS(); }; #endif; #else; __host__ HostS MakeStruct() { return HostS(); }; __device__ DeviceS MakeStruct() { return DeviceS(); }; #endif. // Now host and device code can call MakeStruct(). Hopefully you don't have to do this sort of thing often. Optimizations; =============. Modern CPUs and GPUs are archi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst:17235,wrap,wrapper,17235,interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,1,['wrap'],['wrapper']
Integrability,"ble which should foster its actual use and adoption. No Duplicate Implementations; ----------------------------. The implementation of a function for a given platform must be written exactly; once. This implies that it must be possible to apply a function's; implementation to multiple operating systems if those operating systems can; share the same implementation. This rule applies to the set of operating; systems supported for a given class of operating system (e.g. Unix, Win32). No Virtual Methods; ------------------. The Support Library interfaces can be called quite frequently by LLVM. In order; to make those calls as efficient as possible, we discourage the use of virtual; methods. There is no need to use inheritance for implementation differences, it; just adds complexity. The ``#include`` mechanism works just fine. No Exposed Functions; --------------------. Any functions defined by system libraries (i.e. not defined by ``lib/Support``); must not be exposed through the ``lib/Support`` interface, even if the header; file for that function is not exposed. This prevents inadvertent use of system; specific functionality. For example, the ``stat`` system call is notorious for having variations in the; data it provides. ``lib/Support`` must not declare ``stat`` nor allow it to be; declared. Instead it should provide its own interface to discovering; information about files and directories. Those interfaces may be implemented in; terms of ``stat`` but that is strictly an implementation detail. The interface; provided by the Support Library must be implemented on all platforms (even; those without ``stat``). No Exposed Data; ---------------. Any data defined by system libraries (i.e. not defined by ``lib/Support``) must; not be exposed through the ``lib/Support`` interface, even if the header file; for that function is not exposed. As with functions, this prevents inadvertent; use of data that might not exist on all platforms. Minimize Soft Errors; -------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:6256,interface,interface,6256,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interface']
Integrability,"ble* --- is automatically generated by parsing; all of the headers in the source file, up to and including the last; ``#include``. When only the source file changes (and none of the headers it; depends on), reparsing of that source file can use the precompiled preamble and; start parsing after the ``#include``\ s, so parsing time is proportional to the; size of the source file (rather than all of its includes). However, the; compilation of that translation unit may already use a precompiled header: in; this case, Clang will create the precompiled preamble as a chained precompiled; header that refers to the original precompiled header. This drastically; reduces the time needed to serialize the precompiled preamble for use in; reparsing. Chained precompiled headers get their name because each precompiled header can; depend on one other precompiled header, forming a chain of dependencies. A; translation unit will then include the precompiled header that starts the chain; (i.e., nothing depends on it). This linearity of dependencies is important for; the semantic model of chained precompiled headers, because the most-recent; precompiled header can provide information that overrides the information; provided by the precompiled headers it depends on, just like a header file; ``B.h`` that includes another header ``A.h`` can modify the state produced by; parsing ``A.h``, e.g., by ``#undef``'ing a macro defined in ``A.h``. There are several ways in which chained precompiled headers generalize the AST; file model:. Numbering of IDs; Many different kinds of entities --- identifiers, declarations, types, etc.; --- have ID numbers that start at 1 or some other predefined constant and; grow upward. Each precompiled header records the maximum ID number it has; assigned in each category. Then, when a new precompiled header is generated; that depends on (chains to) another precompiled header, it will start; counting at the next available ID number. This way, one can determine, given;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:24929,depend,depends,24929,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['depend'],['depends']
Integrability,"block_byref_obj),; .byref_keep=_block_byref_obj_keep, .byref_dispose=_block_byref_obj_dispose,; .captured_obj = <initialization expression> )};. truct __block_literal_5 _block_literal = {; &_NSConcreteStackBlock,; (1<<25)|(1<<29), <uninitialized>,; __block_invoke_5,; &__block_descriptor_5,; &obj, // a reference to the on-stack structure containing ""captured_obj""; };. functioncall(_block_literal->invoke(&_block_literal));. C++ Support; ===========. Within a block stack based C++ objects are copied into ``const`` copies using; the copy constructor. It is an error if a stack based C++ object is used within; a block if it does not have a copy constructor. In addition both copy and; destroy helper routines must be synthesized for the block to support the; ``Block_copy()`` operation, and the flags work marked with the (1<<26) bit in; addition to the (1<<25) bit. The copy helper should call the constructor using; appropriate offsets of the variable within the supplied stack based block source; and heap based destination for all ``const`` constructed copies, and similarly; should call the destructor in the destroy routine. As an example, suppose a C++ class ``FOO`` existed with a copy constructor.; Within a code block a stack version of a ``FOO`` object is declared and used; within a ``Block`` literal expression:. .. code-block:: c++. {; FOO foo;; void (^block)(void) = ^{ printf(""%d\n"", foo.value()); };; }. The compiler would synthesize:. .. code-block:: c++. struct __block_literal_10 {; void *isa;; int flags;; int reserved;; void (*invoke)(struct __block_literal_10 *);; struct __block_descriptor_10 *descriptor;; const FOO foo;; };. void __block_invoke_10(struct __block_literal_10 *_block) {; printf(""%d\n"", _block->foo.value());; }. void __block_copy_10(struct __block_literal_10 *dst, struct __block_literal_10 *src) {; FOO_ctor(&dst->foo, &src->foo);; }. void __block_dispose_10(struct __block_literal_10 *src) {; FOO_dtor(&src->foo);; }. static struct __block_descriptor_10 {",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:24159,rout,routine,24159,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['rout'],['routine']
Integrability,"blocks). The ``MachineBasicBlock`` class has a ""``getBasicBlock``"" method,; which returns the LLVM basic block that it comes from. .. _MachineFunction:. The ``MachineFunction`` class; -----------------------------. The ``MachineFunction`` class contains a list of machine basic blocks; (:raw-html:`<tt>` `MachineBasicBlock`_ :raw-html:`</tt>` instances). It; corresponds one-to-one with the LLVM function input to the instruction selector.; In addition to a list of basic blocks, the ``MachineFunction`` contains a; ``MachineConstantPool``, a ``MachineFrameInfo``, a ``MachineFunctionInfo``, and; a ``MachineRegisterInfo``. See ``include/llvm/CodeGen/MachineFunction.h`` for; more information. ``MachineInstr Bundles``; ------------------------. LLVM code generator can model sequences of instructions as MachineInstr; bundles. A MI bundle can model a VLIW group / pack which contains an arbitrary; number of parallel instructions. It can also be used to model a sequential list; of instructions (potentially with data dependencies) that cannot be legally; separated (e.g. ARM Thumb2 IT blocks). Conceptually a MI bundle is a MI with a number of other MIs nested within:. ::. --------------; | Bundle | ---------; -------------- \; | ----------------; | | MI |; | ----------------; | |; | ----------------; | | MI |; | ----------------; | |; | ----------------; | | MI |; | ----------------; |; --------------; | Bundle | --------; -------------- \; | ----------------; | | MI |; | ----------------; | |; | ----------------; | | MI |; | ----------------; | |; | ...; |; --------------; | Bundle | --------; -------------- \; |; ... MI bundle support does not change the physical representations of; MachineBasicBlock and MachineInstr. All the MIs (including top level and nested; ones) are stored as sequential list of MIs. The ""bundled"" MIs are marked with; the 'InsideBundle' flag. A top level MI with the special BUNDLE opcode is used; to represent the start of a bundle. It's legal to mix BUNDLE M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:23522,depend,dependencies,23522,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['depend'],['dependencies']
Integrability,"blocks. High-Level Design; =================. The DDG and the PDG are both directed graphs and they extend the; ``DirectedGraph`` class. Each implementation extends its corresponding; node and edge types resulting in the inheritance relationship depicted; in the UML diagram below:. .. image:: uml_nodes_and_edges.png. Graph Construction; ------------------. The graph build algorithm considers dependencies between elements of; a given set of instructions or basic blocks. Any dependencies coming; into or going out of instructions that do not belong to that range; are ignored. The steps in the build algorithm for the DDG are very; similar to the steps in the build algorithm for the PDG. As such,; one of the design goals is to reuse the build algorithm code to; allow creation of both DDG and PDG representations while allowing; the two implementations to define their own distinct and independent; node and edge types. This is achieved by using the well-known builder; design pattern to isolate the construction of the dependence graph; from its concrete representation. The following UML diagram depicts the overall structure of the design; pattern as it applies to the dependence graph implementation. .. image:: uml_builder_pattern.png. Notice that the common code for building the two types of graphs are; provided in the ``DependenceGraphBuilder`` class, while the ``DDGBuilder``; and ``PDGBuilder`` control some aspects of how the graph is constructed; by the way of overriding virtual methods defined in ``DependenceGraphBuilder``. Note also that the steps and the names used in this diagram are for; illustrative purposes and may be different from those in the actual; implementation. Design Trade-offs; -----------------. Advantages:; ^^^^^^^^^^^; - Builder allows graph construction code to be reused for DDG and PDG.; - Builder allows us to create DDG and PDG as separate graphs.; - DDG nodes and edges are completely disjoint from PDG nodes and edges allowing them to change easily ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:3423,depend,dependence,3423,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,1,['depend'],['dependence']
Integrability,"bosity during running; RooMinuit - Improve contour() method to return RooPlots rather than drawing TGraphs straight on a canvas; RooWorkspace - Add private expensive object cache to workspace; RooBinningCategory - New real-to-category function that maps values of input RooRealVar to categories with labels that correspond to bins of input RooRealVar. See rf405_realtocatfuncs.C for details . RooStats; This is a new package introduced in this version for statistical tools built on top of RooFit. It is a joint effort between the LHC experiments and the ROOT team (see the RooStats Wiki page).; ; This version contains the interfaces for performing the statistical calculations and dealing with the obtained results and concrete classes implementing the statistical methods.; ; All the classes and functions in RooStats are provided in the namespace RooStats.; ; RooStats interfaces. ConfInterval: interface for describing a confidence interval. ; IntervalCalculator: interface for a statistical tool producing confidence intervals (class ConfInterval).; HypoTestResult: interface for representing results of a hypothesis test; HypoTestCalculator: interface for a statistical tool performing an hypothesis test. ; CombinedCalculator: interface for a statistical tool which can produce both hypothesis test results and confidence intervals. ; RooStats concrete classes. The concrete classes describing statistical tools implementing the above interfaces are:; ; ProfileLikelihoodCalculator: it is an implementation of a CombinedCalculator using the profile likelihood ratio as a test statistics. After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer).; LikelihoodInterval: concrete implementation of a ConfInterval interface. It implements connected N-dimensional intervals based on the contour of a likelihood ratio. The boundary of the interval is equivalent to a MINUIT/MINOS ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:9911,interface,interface,9911,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['interface'],['interface']
Integrability,"branch buffer sizes to optimize time and memory.; The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed.; This function may also be called on an existing Tree to figure out the best values; given the information in the Tree header. TFile f(""myfile.root"");; TTree *T = (TTree*)f.Get(""mytreename"");; T->Print(); //show the branch buffer sizes before optimization; T->OptimizeBaskets(10000000,1,""d"");; T->Print(); //show the branch buffer sizes after optimization. New interface functions to customize the TreeCache; virtual void AddBranchToCache(const char *bname, Bool_t subbranches = kFALSE);; virtual void AddBranchToCache(TBranch *branch, Bool_t subbranches = kFALSE);; virtual void PrintCacheStats(Option_t* option = """") const;; virtual void SetParallelUnzip(Bool_t opt=kTRUE);; virtual void SetCacheEntryRange(Long64_t first, Long64_t last);; virtual void SetCacheLearnEntries(Int_t n=10);; virtual void StopCacheLearningPhase();; New functionality AutoFlush (and changes to AutoSave). Implement a new member fAutoFlush in TTree with its getter and setter:. void TTree::SetAutoFlush(Long64_t autof). The logic of the AutoFlush mechanism is optimized such that the TreeCache; will read always up to the point where FlushBaskets has been called.; This minimizes the number of cases where one has to seek backward when reading. This function may be called at the start of a program to change; the default value for fAutoFlush. CASE 1 : autof > 0. autof is the number of consecutive entries after which TTree::Fill will; flush all branch buffers to disk. CASE 2 : autof < 0. When filling the Tree the branch buffers will be flushed to disk when; more than autof bytes have been written to the file. At the first FlushBaskets;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v526/index.html:5306,interface,interface,5306,tree/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v526/index.html,1,['interface'],['interface']
Integrability,"bricator has a tool called *Arcanist* to upload patches from; the command line. To get you set up, follow the; `Arcanist Quick Start`_ instructions. You can learn more about how to use arc to interact with; Phabricator in the `Arcanist User Guide`_.; The basic way of creating a revision for the current commit in your local; repository is to run:. ::. arc diff HEAD~. Sometime you may want to create a draft revision to show the proof of concept; or for experimental purposes, In that case you can use the `--draft` option. It; will create a new draft revision. The good part is: it will not send mail to; llvm-commit mailing list, patch reviewers, and all other subscribers, buildbot; will also run on every patch update:. ::. arc diff --draft HEAD~. If you later update your commit message, you need to add the `--verbatim`; option to have `arc` update the description on Phabricator:. ::. arc diff --edit --verbatim. .. _phabricator-request-review-web:. Requesting a review via the web interface; -----------------------------------------. The tool to create and review patches in Phabricator is called; *Differential*. Note that you can upload patches created through git, but using `arc` on the; command line (see previous section) is preferred: it adds more metadata to; Phabricator which are useful for the pre-merge testing system and for; propagating attribution on commits when someone else has to push it for you. To make reviews easier, please always include **as much context as; possible** with your diff! Don't worry, Phabricator; will automatically send a diff with a smaller context in the review; email, but having the full file in the web interface will help the; reviewer understand your code. To get a full diff, use one of the following commands (or just use Arcanist; to upload your patch):. * ``git show HEAD -U999999 > mypatch.patch``; * ``git diff -U999999 @{u} > mypatch.patch``; * ``git diff HEAD~1 -U999999 > mypatch.patch``. Before uploading your patch, please make sur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:2494,interface,interface,2494,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['interface'],['interface']
Integrability,"bs: (1) Running every IR Module that is emitted via this; layer through the transform function object, and (2) implementing the ORC; ``IRLayer`` interface (which itself conforms to the general ORC Layer concept,; more on that below). Most of the class is straightforward: a typedef for the; transform function, a constructor to initialize the members, a setter for the; transform function value, and a default no-op transform. The most important; method is ``emit`` as this is half of our IRLayer interface. The emit method; applies our transform to each module that it is called on and, if the transform; succeeds, passes the transformed module to the base layer. If the transform; fails, our emit function calls; ``MaterializationResponsibility::failMaterialization`` (this JIT clients who; may be waiting on other threads know that the code they were waiting for has; failed to compile) and logs the error with the execution session before bailing; out. The other half of the IRLayer interface we inherit unmodified from the IRLayer; class:. .. code-block:: c++. Error IRLayer::add(JITDylib &JD, ThreadSafeModule TSM, VModuleKey K) {; return JD.define(std::make_unique<BasicIRLayerMaterializationUnit>(; *this, std::move(K), std::move(TSM)));; }. This code, from ``llvm/lib/ExecutionEngine/Orc/Layer.cpp``, adds a; ThreadSafeModule to a given JITDylib by wrapping it up in a; ``MaterializationUnit`` (in this case a ``BasicIRLayerMaterializationUnit``).; Most layers that derived from IRLayer can rely on this default implementation; of the ``add`` method. These two operations, ``add`` and ``emit``, together constitute the layer; concept: A layer is a way to wrap a part of a compiler pipeline (in this case; the ""opt"" phase of an LLVM compiler) whose API is opaque to ORC with an; interface that ORC can call as needed. The add method takes an; module in some input program representation (in this case an LLVM IR module); and stores it in the target ``JITDylib``, arranging for it to be passed",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:8944,interface,interface,8944,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['interface'],['interface']
Integrability,"bsL` class is implemented for four kinds of likelihoods: binned, unbinned, ""subsidiary"" (an optimization for numerical stability that gathers components like global observables) and ""sum"" (over multiple components of the other types), in the correspondingly named classes `RooBinnedL`, `RooUnbinnedL`, `RooSubsidiaryL` and `RooSumL`.; These classes provide a `evaluatePartition` function that allows for computing them in parallelizable chunks that can be used by the calculator classes as they see fit. On top of the likelihood classes, we also provide for convenience a likelihood builder `buildLikelihood`, as a free function in the namespace.; This function analyzes the `pdf` and automatically constructs the proper likelihood, built; up from the available `RooAbsL` subclasses. The new classes are not per se meant to be used outside of `RooMinimizer`, although they can be.; The main reason is that they do not behave as regular `RooAbsReal` objects, but have their own interface which was kept to the minimum necessary for interacting with `RooMinimizer` as an object that encodes purely the statistics concepts.; However, we do provide the `RooRealL` class, which holds a `RooAbsL` object, but does inherit from `RooAbsReal` as well, so that it can be used in contexts where you would normally use a `RooAbsReal` (like for plotting). ### Usage example: Create an unbinned likelihood object; It is possible to directly create `RooAbsL` based likelihood objects from a pdf and dataset, in this example a `RooUnbinnedL` type:; ``` {.cpp}; RooAbsPdf *pdf;; RooDataSet *data;; std::tie(pdf, data) = generate_some_unbinned_pdf_and_dataset(with, some, parameters);. RooFit::TestStatistics::RooUnbinnedL likelihood(pdf, data);; ```. However, most of the time, the user will not need **or want** such direct control over the type, but rather just let RooFit figure out what exact likelihood type (`RooAbsL` derived class) is best.; For this situation, the `buildLikelihood` function was created that ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md:1988,interface,interface,1988,roofit/doc/developers/test_statistics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md,1,['interface'],['interface']
Integrability,"buf`` and ``sbuf->count`` are updated side by side; without any side effects in between the assignments. Furthermore, the compiler inserts additional run-time checks to ensure the new; ``buf`` has at least as many elements as the new ``count`` indicates as shown in; the transformed pseudo code of function ``alloc_buf()`` in the example below. .. code-block:: c. typedef struct {; int *__counted_by(count) buf;; size_t count;; } sized_buf_t;. void alloc_buf(sized_buf_t *sbuf, sized_t nelems) {; sbuf->buf = (int *)malloc(sizeof(int) * nelems);; sbuf->count = nelems;; }. // Transformed pseudo code:; void alloc_buf(sized_buf_t *sbuf, sized_t nelems) {; // Materialize RHS values:; int *tmp_ptr = (int *)malloc(sizeof(int) * nelems);; int tmp_count = nelems;; // Inserted check:; // - checks to ensure that `lower <= tmp_ptr <= upper`; // - if (upper(tmp_ptr) - tmp_ptr < tmp_count) trap();; sbuf->buf = tmp_ptr;; sbuf->count = tmp_count;; }. Whether the compiler can optimize such run-time checks depends on how the upper; bound of the pointer is derived. If the source pointer has ``__sized_by``,; ``__counted_by``, or a variant of such, the compiler assumes that the upper; bound calculation doesn't overflow, e.g., ``ptr + size`` (where the type of; ``ptr`` is ``void *__sized_by(size)``), because when the ``__sized_by`` pointer; is initialized, ``-fbounds-safety`` inserts run-time checks to ensure that ``ptr; + size`` doesn't overflow and that ``size >= 0``. Assuming the upper bound calculation doesn't overflow, the compiler can simplify; the trap condition ``upper(tmp_ptr) - tmp_ptr < tmp_count`` to ``size <; tmp_count`` so if both ``size`` and ``tmp_count`` values are known at compile; time such that ``0 <= tmp_count <= size``, the optimizer can remove the check. ``ptr + size`` may still overflow if the ``__sized_by`` pointer is created from; code that doesn't enable ``-fbounds-safety``, which is undefined behavior. In the previous code example with the transformed ``alloc_buf()",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:37593,depend,depends,37593,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['depend'],['depends']
Integrability,"bugpoint - automatic test case reduction tool; =============================================. .. program:: bugpoint. SYNOPSIS; --------. **bugpoint** [*options*] [*input LLVM ll/bc files*] [*LLVM passes*] **--args**; *program arguments*. DESCRIPTION; -----------. **bugpoint** narrows down the source of problems in LLVM tools and passes. It; can be used to debug three types of failures: optimizer crashes, miscompilations; by optimizers, or bad native code generation (including problems in the static; and JIT compilers). It aims to reduce large test cases to small, useful ones.; For more information on the design and inner workings of **bugpoint**, as well as; advice for using bugpoint, see :doc:`/Bugpoint` in the LLVM; distribution. OPTIONS; -------. **--additional-so** *library*. Load the dynamic shared object *library* into the test program whenever it is; run. This is useful if you are debugging programs which depend on non-LLVM; libraries (such as the X or curses libraries) to run. **--append-exit-code**\ =\ *{true,false}*. Append the test programs exit code to the output file so that a change in exit; code is considered a test failure. Defaults to false. **--args** *program args*. Pass all arguments specified after **--args** to the test program whenever it runs.; Note that if any of the *program args* start with a ""``-``"", you should use:. .. code-block:: bash. bugpoint [bugpoint args] --args -- [program args]. The ""``--``"" right after the **--args** option tells **bugpoint** to consider; any options starting with ""``-``"" to be part of the **--args** option, not as; options to **bugpoint** itself. **--tool-args** *tool args*. Pass all arguments specified after **--tool-args** to the LLVM tool under test; (**llc**, **lli**, etc.) whenever it runs. You should use this option in the; following way:. .. code-block:: bash. bugpoint [bugpoint args] --tool-args -- [tool args]. The ""``--``"" right after the **--tool-args** option tells **bugpoint** to; consider any optio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst:926,depend,depend,926,interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,1,['depend'],['depend']
Integrability,"builds require a lot of time and disk space. An LLVM-only build; will need about 1-3 GB of space. A full build of LLVM and Clang will need around; 15-20 GB of disk space. The exact space requirements will vary by system. (It; is so large because of all the debugging information and the fact that the; libraries are statically linked into multiple tools). If you are space-constrained, you can build only selected tools or only; selected targets. The Release build requires considerably less space. The LLVM suite *may* compile on other platforms, but it is not guaranteed to do; so. If compilation is successful, the LLVM utilities should be able to; assemble, disassemble, analyze, and optimize LLVM bitcode. Code generation; should work as well, although the generated native code may not work on your; platform. Software; --------. Compiling LLVM requires that you have several software packages installed. The; table below lists those required packages. The Package column is the usual name; for the software package that LLVM depends on. The Version column provides; ""known to work"" versions of the package. The Notes column describes how LLVM; uses the package and provides other details. =========================================================== ============ ==========================================; Package Version Notes; =========================================================== ============ ==========================================; `CMake <http://cmake.org/>`__ >=3.20.0 Makefile/workspace generator; `python <http://www.python.org/>`_ >=3.6 Automated test suite\ :sup:`1`; `zlib <http://zlib.net>`_ >=1.2.3.4 Compression library\ :sup:`2`; `GNU Make <http://savannah.gnu.org/projects/make>`_ 3.79, 3.79.1 Makefile/build processor\ :sup:`3`; =========================================================== ============ ==========================================. .. note::. #. Only needed if you want to run the automated test suite in the; ``llvm/test`` directory.; #. Optional, adds",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:10264,depend,depends,10264,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['depend'],['depends']
Integrability,"but allows; tools like clang-tidy, clang-query, and clangd to work in your source; tree). Build and test; --------------. Finally, we can build the code! It's important to do this first, to; ensure we're in a good state before making changes. But what to build?; In ninja, you specify a **target**. If we just want to build the clang; binary, our target name is ""clang"" and we run:. .. code:: console. $ ninja clang. The first time we build will be very slow - Clang + LLVM is a lot of; code. But incremental builds are fast: ninja will only rebuild the parts; that have changed. When it finally finishes you should have a working; clang binary. Try running:. .. code:: console. $ bin/clang --version. There's also a target for building and running all the clang tests:. .. code:: console. $ ninja check-clang. This is a common pattern in LLVM: check-llvm is all the checks for core,; other projects have targets like check-lldb. Making changes; ==============. Edit; ----. We need to find the file containing the error message. .. code:: console. $ git grep ""all paths through this function"" ..; ../clang/include/clang/Basic/DiagnosticSemaKinds.td: ""all paths through this function will call itself"">,. The string that appears in DiagnosticSemaKinds.td is the one that is; printed by Clang. \*.td files define tables - in this case it's a list; of warnings and errors clang can emit and their messages. Let's update; the message in your favorite editor:. .. code:: console. $ vi ../clang/include/clang/Basic/DiagnosticSemaKinds.td. Find the message (it should be under; ``warn_infinite_recursive_function``). Change the message to ""in order to; understand recursion, you must first understand recursion"". Test again; ----------. To verify our change, we can build clang and manually check that it; works. .. code:: console. $ ninja clang; $ bin/clang -Wall ~/test.cc; /path/test.cc:1:124: warning: in order to understand recursion, you must; first understand recursion [-Winfinite-recursion]. We shou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:5384,message,message,5384,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['message'],['message']
Integrability,"but; that is twisted along the Z-axis. The twist is defined as the rotation; angle between the lower and the higher Z faces. ``` {.cpp}; TGeoGtra(Double_t dz,Double_t theta,Double_t phi,Double_t twist,; Double_t h1,Double_t bl1,Double_t tl1,Double_t alpha1,; Double_t h2,Double_t bl2,Double_t tl2,Double_t alpha2 );; ```. ![TGeoGtra class](pictures/060001BB.png). #### Arbitrary 8 vertices shapes - TGeoArb8 class. An `Arb8` is defined by two quadrilaterals sitting on parallel planes,; at `dZ`. These are defined each by 4 vertices having the coordinates; `(Xi,Yi,+/-dZ)`,` i=0`,` 3`. The lateral surface of the `Arb8` is; defined by the 4 pairs of edges corresponding to vertices (`i,i+1`) on; both `-dZ` and `+dZ`. If M and M' are the middles of the segments; `(i,i+1)` at `-dZ` and `+dZ`, a lateral surface is obtained by sweeping; the edge at `-dZ` along MM' so that it will match the corresponding one; at `+dZ`. Since the points defining the edges are arbitrary, the lateral; surfaces are not necessary planes - but twisted planes having a twist; angle linear-dependent on Z. ``` {.cpp}; TGeoArb8::TGeoArb8(Double_t dz,Double_t ivert);; ```. - `dz:` half-length in Z;; - `ivert = [0,7]`. Vertices have to be defined clockwise in the XY pane, both at `+dz` and; `-dz`. The quadrilateral at `-dz` is defined by indices [0,3], whereas; the one at `+dz` by vertices [4,7]. The vertex with `index=7` has to be; defined last, since it triggers the computation of the bounding box of; the shape. Any two or more vertices in each Z plane can have the same; (X,Y) coordinates. It this case, the top and bottom quadrilaterals; become triangles, segments or points. The lateral surfaces are not; necessary defined by a pair of segments, but by pair segment-point; (making a triangle) or point-point (making a line). Any choice is valid; as long as at one of the end-caps is at least a triangle. ![TGeoArb8 class](pictures/080001BC.png). #### Tubes - TGeoTube Class. Tubes have Z as their symmetry axis. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:30996,depend,dependent,30996,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['depend'],['dependent']
Integrability,"buted under the terms of; this Lesser General Public License (also called ""this License"").; Each licensee is addressed as ""you"". A ""library"" means a collection of software functions and/or data; prepared so as to be conveniently linked with application programs; (which use some of those functions and data) to form executables. The ""Library"", below, refers to any such software library or work; which has been distributed under these terms. A ""work based on the; Library"" means either the Library or any derivative work under; copyright law: that is to say, a work containing the Library or a; portion of it, either verbatim or with modifications and/or translated; straightforwardly into another language. (Hereinafter, translation is; included without limitation in the term ""modification"".). ""Source code"" for a work means the preferred form of the work for; making modifications to it. For a library, complete source code means; all the source code for all modules it contains, plus any associated; interface definition files, plus the scripts used to control compilation; and installation of the library. Activities other than copying, distribution and modification are not; covered by this License; they are outside its scope. The act of; running a program using the Library is not restricted, and output from; such a program is covered only if its contents constitute a work based; on the Library (independent of the use of the Library in a tool for; writing it). Whether that is true depends on what the Library does; and what the program that uses the Library does. 1. You may copy and distribute verbatim copies of the Library's; complete source code as you receive it, in any medium, provided that; you conspicuously and appropriately publish on each copy an; appropriate copyright notice and disclaimer of warranty; keep intact; all the notices that refer to this License and to the absence of any; warranty; and distribute a copy of this License along with the; Library. You may charge ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/LICENSE.TXT:9510,interface,interface,9510,interpreter/cling/LICENSE.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/LICENSE.TXT,1,['interface'],['interface']
Integrability,"buted under the terms of; this Lesser General Public License (also called ""this License"").; Each licensee is addressed as ""you"". A ""library"" means a collection of software functions and/or data; prepared so as to be conveniently linked with application programs; (which use some of those functions and data) to form executables. The ""Library"", below, refers to any such software library or work; which has been distributed under these terms. A ""work based on the; Library"" means either the Library or any derivative work under; copyright law: that is to say, a work containing the Library or a; portion of it, either verbatim or with modifications and/or translated; straightforwardly into another language. (Hereinafter, translation is; included without limitation in the term ""modification"".). ""Source code"" for a work means the preferred form of the work for; making modifications to it. For a library, complete source code means; all the source code for all modules it contains, plus any associated; interface definition files, plus the scripts used to control compilation; and installation of the library. Activities other than copying, distribution and modification are not; covered by this License; they are outside its scope. The act of; running a program using the Library is not restricted, and output from; such a program is covered only if its contents constitute a work based; on the Library (independent of the use of the Library in a tool for; writing it). Whether that is true depends on what the Library does; and what the program that uses the Library does.; ; 1. You may copy and distribute verbatim copies of the Library's; complete source code as you receive it, in any medium, provided that; you conspicuously and appropriately publish on each copy an; appropriate copyright notice and disclaimer of warranty; keep intact; all the notices that refer to this License and to the absence of any; warranty; and distribute a copy of this License along with the; Library. You may char",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt:7231,interface,interface,7231,LGPL2_1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt,1,['interface'],['interface']
Integrability,"by a debug info; consumer to provide support that goes beyond showing the internal structure of; the wide pointer. There are no DWARF extensions needed to support wide pointers.; In our implementation, LLDB recognizes wide pointer types by name and; reconstructs them as wide pointer Clang AST types for use in the expression; evaluator. External bounds annotations; ---------------------------. Similar to internal bounds annotations, external bound annotations are described; as a typedef to their underlying pointer type in the debug info, and the bounds; are encoded as strings in the typedef’s name (e.g.,; ``__bounds_safety$counted_by:N``). Recognizing ``-fbounds-safety`` traps; -------------------------------------. Clang emits debug info for ``-fbounds-safety`` traps as inlined functions, where; the function name encodes the error message. LLDB implements a frame recognizer; to surface a human-readable error cause to the end user. A debug info consumer; that is unaware of this sees an inlined function whose name encodes an error; message (e.g., : ``__bounds_safety$Bounds check failed``). Expression Parsing; ------------------. In our implementation, LLDB’s expression evaluator does not enable the; ``-fbounds-safety`` language option because it’s currently unable to fully; reconstruct the pointers with external bounds annotations, and also because the; evaluator operates in C++ mode, utilizing C++ reference types, while; ``-fbounds-safety`` does not currently support C++. This means LLDB’s expression; evaluator can only evaluate a subset of the ``-fbounds-safety`` language model.; Specifically, it’s capable of evaluating the wide pointers that already exist in; the source code. All other expressions are evaluated according to C/C++; semantics. C++ support; ===========. C++ has multiple options to write code in a bounds-safe manner, such as; following the bounds-safety core guidelines and/or using hardened libc++ along; with the `C++ Safe Buffer model; <https://discour",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:9682,message,message,9682,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['message'],['message']
Integrability,"by a module-import-declaration. All of the 3 options ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/BMI>``; and ``-fmodule-file=<module-name>=<path/to/BMI>`` may occur multiple times.; For example, the command line to compile ``M.cppm`` in; the above example could be rewritten into:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -fmodule-file=M:interface_part=M-interface_part.pcm -fmodule-file=M:impl_part=M-impl_part.pcm -o M.pcm. When there are multiple ``-fmodule-file=<module-name>=`` options for the same; ``<module-name>``, the last ``-fmodule-file=<module-name>=`` will override the previous; ``-fmodule-file=<module-name>=`` options. ``-fprebuilt-module-path`` is more convenient and ``-fmodule-file`` is faster since; it saves time for file lookup. Remember that module units still have an object counterpart to the BMI; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. It is easy to forget to compile BMIs at first since we may envision module interfaces like headers.; However, this is not true.; Module units are translation units. We need to compile them to object files; and link the object files like the example shows. For example, the traditional compilation processes for headers are like:. .. code-block:: text. src1.cpp -+> clang++ src1.cpp --> src1.o ---,; hdr1.h --' +-> clang++ src1.o src2.o -> executable; hdr2.h --, |; src2.cpp -+> clang++ src2.cpp --> src2.o ---'. And the compilation process for module units are like:. .. code-block:: text. src1.cpp ----------------------------------------+> clang++ src1.cpp -------> src1.o -,; (header unit) hdr1.h -> clang++ hdr1.h ... -> hdr1.pcm --' +-> clang++ src1.o mod1.o src2.o -> executable; mod1.cppm -> clang++ mod1.cppm ... -> mod1.pcm --,--> clang++ mod1.pcm ... -> mod1.o -+; src2.cpp ----------------------------------------+> clang++ src2.cpp -------> src2.o -'. As the diagrams show, we need to compile the BMI from module units to object files an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:13975,interface,interfaces,13975,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interfaces']
Integrability,"c++. static SDValue LowerFP_TO_SINT(SDValue Op, SelectionDAG &DAG) {; assert(Op.getValueType() == MVT::i32);; Op = DAG.getNode(SPISD::FTOI, MVT::f32, Op.getOperand(0));; return DAG.getNode(ISD::BITCAST, MVT::i32, Op);; }. Legal; ^^^^^. The ``Legal`` ``LegalizeAction`` enum value simply indicates that an operation; **is** natively supported. ``Legal`` represents the default condition, so it; is rarely used. In ``SparcISelLowering.cpp``, the action for ``CTPOP`` (an; operation to count the bits set in an integer) is natively supported only for; SPARC v9. The following code enables the ``Expand`` conversion technique for; non-v9 SPARC implementations. .. code-block:: c++. setOperationAction(ISD::CTPOP, MVT::i32, Expand);; ...; if (TM.getSubtarget<SparcSubtarget>().isV9()); setOperationAction(ISD::CTPOP, MVT::i32, Legal);. Calling Conventions; -------------------. To support target-specific calling conventions, ``XXXGenCallingConv.td`` uses; interfaces (such as ``CCIfType`` and ``CCAssignToReg``) that are defined in; ``lib/Target/TargetCallingConv.td``. TableGen can take the target descriptor; file ``XXXGenCallingConv.td`` and generate the header file; ``XXXGenCallingConv.inc``, which is typically included in; ``XXXISelLowering.cpp``. You can use the interfaces in; ``TargetCallingConv.td`` to specify:. * The order of parameter allocation. * Where parameters and return values are placed (that is, on the stack or in; registers). * Which registers may be used. * Whether the caller or callee unwinds the stack. The following example demonstrates the use of the ``CCIfType`` and; ``CCAssignToReg`` interfaces. If the ``CCIfType`` predicate is true (that is,; if the current argument is of type ``f32`` or ``f64``), then the action is; performed. In this case, the ``CCAssignToReg`` action assigns the argument; value to the first available register: either ``R0`` or ``R1``. .. code-block:: text. CCIfType<[f32,f64], CCAssignToReg<[R0, R1]>>. ``SparcCallingConv.td`` contains definitio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:61723,interface,interfaces,61723,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['interface'],['interfaces']
Integrability,"c++20 Impl.cpp -c -o Impl.o"",; ""file"": ""Impl.cpp"",; ""output"": ""Impl.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o"",; ""file"": ""impl_part.cppm"",; ""output"": ""impl_part.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 interface_part.cppm -c -o interface_part.o"",; ""file"": ""interface_part.cppm"",; ""output"": ""interface_part.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 User.cpp -c -o User.o"",; ""file"": ""User.cpp"",; ""output"": ""User.o""; }; ]. And we can get the dependency information in P1689 format by:. .. code-block:: console. $ clang-scan-deps -format=p1689 -compilation-database P1689.json. And we will get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""Impl.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ]; },; {; ""primary-output"": ""M.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:35179,interface,interface,35179,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interface']
Integrability,"c-assemble-fuzzer`` for details. .. |generic fuzzer| replace:: :ref:`generic fuzzer <fuzzing-llvm-generic>`; .. |protobuf fuzzer|; replace:: :ref:`libprotobuf-mutator based fuzzer <fuzzing-llvm-protobuf>`; .. |LLVM IR fuzzer|; replace:: :ref:`structured LLVM IR fuzzer <fuzzing-llvm-ir>`. lldb-target-fuzzer; ---------------------. A |generic fuzzer| that interprets inputs as object files and uses them to; create a target in lldb. Mutators and Input Generators; =============================. The inputs for a fuzz target are generated via random mutations of a; :ref:`corpus <libfuzzer-corpus>`. There are a few options for the kinds of; mutations that a fuzzer in LLVM might want. .. _fuzzing-llvm-generic:. Generic Random Fuzzing; ----------------------. The most basic form of input mutation is to use the built in mutators of; LibFuzzer. These simply treat the input corpus as a bag of bits and make random; mutations. This type of fuzzer is good for stressing the surface layers of a; program, and is good at testing things like lexers, parsers, or binary; protocols. Some of the in-tree fuzzers that use this type of mutator are `clang-fuzzer`_,; `clang-format-fuzzer`_, `llvm-as-fuzzer`_, `llvm-dwarfdump-fuzzer`_,; `llvm-mc-assemble-fuzzer`_, and `llvm-mc-disassemble-fuzzer`_. .. _fuzzing-llvm-protobuf:. Structured Fuzzing using ``libprotobuf-mutator``; ------------------------------------------------. We can use libprotobuf-mutator_ in order to perform structured fuzzing and; stress deeper layers of programs. This works by defining a protobuf class that; translates arbitrary data into structurally interesting input. Specifically, we; use this to work with a subset of the C++ language and perform mutations that; produce valid C++ programs in order to exercise parts of clang that are more; interesting than parser error handling. To build this kind of fuzzer you need `protobuf`_ and its dependencies; installed, and you need to specify some extra flags when configuring the buil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst:6106,protocol,protocols,6106,interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,1,['protocol'],['protocols']
Integrability,"c-toolchain --sysroot=/path/to/gcc-toolchain/arm-linux-gnueabihf/libc helloworld.c``. Clang uses the host header files; --------------------------------; On debian based systems it is possible to install multiarch support for; arm-linux-gnueabi and arm-linux-gnueabihf. In many cases clang can successfully; use this multiarch support when ``--gcc-toolchain=`` and ``--sysroot=`` are not supplied.; Unfortunately clang adds ``/usr/local/include`` before; ``/usr/include/arm-linux-gnueabihf`` leading to errors when compiling the hosts; header files. The multiarch support is not sufficient to build the builtins you will need to; use a separate arm-linux-gnueabihf toolchain. No target passed to clang; -------------------------; If clang is not given a target it will typically use the host target, this will; not understand the Arm assembly language files resulting in error messages such; as ``error: unknown directive .syntax unified``. You can check the clang invocation in the error message to see if there is no; ``--target`` or if it is set incorrectly. The cause is usually; ``CMAKE_ASM_FLAGS`` not containing ``--target`` or ``CMAKE_ASM_COMPILER_TARGET`` not being present. Arm architecture not given; --------------------------; The ``--target=arm-linux-gnueabihf`` will default to arm architecture v4t which; cannot assemble the barrier instructions used in the synch_and_fetch source; files. The cause is usually a missing ``-march=armv7a`` from the ``CMAKE_ASM_FLAGS``. Compiler-rt builds but the tests fail to build; ----------------------------------------------; The flags used to build the tests are not the same as those used to build the; builtins. The c flags are provided by ``COMPILER_RT_TEST_COMPILE_CFLAGS`` and; the ``CMAKE_C_COMPILER_TARGET``, ``CMAKE_ASM_COMPILER_TARGET``,; ``CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN`` and ``CMAKE_SYSROOT`` flags are not; applied. Make sure that ``COMPILER_RT_TEST_COMPILE_CFLAGS`` contains all the necessary; information. Modifications for ot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst:7336,message,message,7336,interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,1,['message'],['message']
Integrability,"c:28:8: <span style=""color:magenta"">warning</span>: extra tokens at end of #endif directive [-Wextra-tokens]</span></b>; #endif bad; <span style=""color:green"">^</span>; <span style=""color:green"">//</span>; </pre>. When this is disabled, Clang will just print:. ::. test.c:2:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. If the ``NO_COLOR`` environment variable is defined and not empty; (regardless of value), color diagnostics are disabled. If ``NO_COLOR`` is; defined and ``-fcolor-diagnostics`` is passed on the command line, Clang; will honor the command line argument. .. option:: -fansi-escape-codes. Controls whether ANSI escape codes are used instead of the Windows Console; API to output colored diagnostics. This option is only used on Windows and; defaults to off. .. option:: -fdiagnostics-format=clang/msvc/vi. Changes diagnostic output format to better match IDEs and command line tools. This option controls the output format of the filename, line number,; and column printed in diagnostic messages. The options, and their; affect on formatting a simple conversion diagnostic, follow:. **clang** (default); ::. t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int'. **msvc**; ::. t.c(3,11) : warning: conversion specifies type 'char *' but the argument has type 'int'. **vi**; ::. t.c +3:11: warning: conversion specifies type 'char *' but the argument has type 'int'. .. _opt_fdiagnostics-show-option:. .. option:: -f[no-]diagnostics-show-option. Enable ``[-Woption]`` information in diagnostic line. This option, which defaults to on, controls whether or not Clang; prints the associated :ref:`warning group <cl_diag_warning_groups>`; option name when outputting a warning diagnostic. For example, in; this output:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. Passing **-fno-diagnostics-show-option** will prevent Clang from; printing the [:option:`-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:8568,message,messages,8568,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['message'],['messages']
Integrability,"c:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoParameterDerivative(const double* x, const double* p,; unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; ```. ### Wrapper Functions. To facilitate the user to insert their own type of function in the needed function interface, helper classes, wrapping the user interface in the; `ROOT::Math` function interfaces are provided.; this will avoid the user to re-implement dedicated function classes, following the code example shown in the previous paragraphs. There is one possible wrapper for every interface explained in the previous section.; The following table indicates the wrapper for the most basic ones:. | **Interface**| **Function Wrapper** |; |------------------------------------------|------------------------|; | `ROOT::Math::IBaseFunctionOneDim` | `ROOT::Math::Functor1D` |; | `ROOT::Math::IGradientFunctionOneDim` | `ROOT::Math::GradFunctor1D` |; | `ROOT::Math::IBaseFunctionMultiDim` | `ROOT::Math::Functor` |; | `ROOT::Math::IGradientFunctionMultiDim` | `ROOT::Math::GradFunctor` |. Thee functor wrapper are defined in the header file `Math/Functor.h`. #### Wrapping One Dimensional Functions. The `ROOT::Math::Functor1D` is used to wrap one-dimensional functions It can wrap all the following types:; * A free C function of type `double ()(double )`.; * Any C++ callable object implementation `double operator()( double )`.; * A class member function with the correct signature like `double Foo::Eval(double )`. In this case one pass the object pointer and a pointer to the member f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:42377,wrap,wrapper,42377,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,"cal function entry. |; +---------------+--------------+-----------------------------------------------+; | Exit | ``1`` | Typical function exit. |; +---------------+--------------+-----------------------------------------------+; | Tail_Exit | ``2`` | An exit from a function due to tail call |; | | | optimization. |; +---------------+--------------+-----------------------------------------------+; | Entry_Args | ``3`` | A function entry that records arguments. |; +---------------+--------------+-----------------------------------------------+. Entry_Args records do not contain the arguments themselves. Instead, metadata; records for each of the logged args follow the function record in the stream. Metadata Records; ----------------. Interspersed throughout the buffer are 16 byte Metadata records. For typically; instrumented binaries, they will be sparser than Function records, and they; provide a fuller picture of the binary execution state. Metadata record layout is partially record dependent, but they share a common; structure. The same bit field rules described for function records apply to the first byte; of MetadataRecords. Within this byte, little endian machines use lsb to msb; ordering and big endian machines use msb to lsb ordering. +---------------+--------------+-----------------------------------------------+; | Field | Size | Description |; +===============+==============+===============================================+; | discriminant | ``1 bit`` | Indicates whether a reader should read a |; | | | Function or Metadata record. Set to ``1`` for |; | | | Metadata records. |; +---------------+--------------+-----------------------------------------------+; | record_kind | ``7 bits`` | The type of Metadata record. |; +---------------+--------------+-----------------------------------------------+; | data | ``15 bytes`` | A data field used differently for each record |; | | | type. |; +---------------+--------------+------------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRayFDRFormat.rst:8272,depend,dependent,8272,interpreter/llvm-project/llvm/docs/XRayFDRFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRayFDRFormat.rst,1,['depend'],['dependent']
Integrability,"calar integer value; if (photoCount > 0) {; [self displayPhotos];; }. .. _osx-SecKeychainAPI:. osx.SecKeychainAPI (C); """"""""""""""""""""""""""""""""""""""""""""; Check for proper uses of Secure Keychain APIs. .. literalinclude:: checkers/seckeychainapi_example.m; :language: objc. .. _osx-cocoa-AtSync:. osx.cocoa.AtSync (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for nil pointers used as mutexes for @synchronized. .. code-block:: objc. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. .. _osx-cocoa-AutoreleaseWrite:. osx.cocoa.AutoreleaseWrite; """"""""""""""""""""""""""""""""""""""""""""""""""""; Warn about potentially crashing writes to autoreleasing objects from different autoreleasing pools in Objective-C. .. _osx-cocoa-ClassRelease:. osx.cocoa.ClassRelease (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for sending 'retain', 'release', or 'autorelease' directly to a Class. .. code-block:: objc. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. .. _osx-cocoa-Dealloc:. osx.cocoa.Dealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C classes that lack a correct implementation of -dealloc. .. literalinclude:: checkers/dealloc_example.m; :language: objc. .. _osx-cocoa-IncompatibleMethodTypes:. osx.cocoa.IncompatibleMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C method signatures with type incompatibilities. .. code-block:: objc. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. .. _osx-cocoa-Loops:. osx.cocoa.Loops; """"""""""""""""""""""""""""""; Improved modeling of loops using Cocoa collection types. .. _osx-cocoa-MissingSuperCall:. osx.cocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a nece",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:36745,interface,interface,36745,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['interface'],['interface']
Integrability,"call SetFixedScan(npoints, xmin, xmax), while for running an autoscan use; the function SetAutoScan. The result is returned in the GetInterval function as an; HypoTestInverterResult class. If a fixed grid is used the upper limit is obtained by using a interpolation on; the scanned points. The interpolation can be linear or a spline (if; result.SetInterpolationOption(HypoTestInverterResult::kSpline) is called).; The upper limit, the expected P value distributions and also the upper limit distributions can be obtained from the; result class. . HypoTestInverterResult * result = inverter.GetInterval();; double upperLimit = result->UpperLimit();; double expectedLimit = result->GetExpectedUpperLimit(0);. The limit values, p values and bands can be drawn using the HypoTestInverterPlot class. Example:. HypoTestInverterPlot * plot = new HypoTestInverterPlot(""Result"",""POI Scan Result"",result);; plot->Draw(""2CL CLb"");. Where the Draw option ""2CL CLb"" draws in addition to the observed limit and bands, the observed CLs+b and CLb.; The result is shown in this figure:. FrequentistCalculator; This is a HypoTestCalculator that returns a HypoTestResult similar to the HybridCalculator. The primary difference is that this tool profiles the nuisance parameters for the null model and uses those fixed values of the nuisance parameters for generating the pseudo-experiments, where the HybridCalculator smears/randomizes/marginalizes the nuisance parameters. BayesianCalculator; Several improvements have been put in the class. In particular the possibility to set different integration types. One; can set the different integration types available in the ROOT integration routines; (ADAPTIVE, VEGAS, MISER, PLAIN for multi-dimension). In addition one can use an integration types by generating nuisance; toy MC (method TOYMC). If the nuisance parameters are uncorrelated, this last method can scale up for a large number of; nuisance parameters. It has been tested to work up to 50-100 parameters. ; ; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html:6608,integrat,integration,6608,roofit/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html,5,"['integrat', 'rout']","['integration', 'routines']"
Integrability,"callee to a caller. The; most common scenario this models is the retained return from ``init``,; ``alloc``, ``new``, and ``copy`` methods, but there are other cases in the; frameworks. After optimization there are typically no extra retains and; releases required. Methods in the ``alloc``, ``copy``, ``init``, ``mutableCopy``, and ``new``; :ref:`families <arc.method-families>` are implicitly marked; ``__attribute__((ns_returns_retained))``. This may be suppressed by explicitly; marking the method ``__attribute__((ns_returns_not_retained))``. It is undefined behavior if the method to which an Objective-C message send; statically resolves has different retain semantics on its result from the; method it dynamically resolves to. It is undefined behavior if a block or; function call is made through a static type with different retain semantics on; its result from the implementation of the called block or function. .. admonition:: Rationale. Mismatches with returned results will cause over-retains or over-releases,; depending on the direction. Again, the rule about function calls is really; just an application of the existing C/C++ rule about calling functions; through an incompatible function type. .. _arc.objects.operands.unretained-returns:. Unretained return values; ^^^^^^^^^^^^^^^^^^^^^^^^. A method or function which returns a retainable object type but does not return; a retained value must ensure that the object is still valid across the return; boundary. When returning from such a function or method, ARC retains the value at the; point of evaluation of the return statement, then leaves all local scopes, and; then balances out the retain while ensuring that the value lives across the; call boundary. In the worst case, this may involve an ``autorelease``, but; callers must not assume that the value is actually in the autorelease pool. ARC performs no extra mandatory work on the caller side, although it may elect; to do something to shorten the lifetime of the returne",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:21054,depend,depending,21054,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['depend'],['depending']
Integrability,"case of; concurrency. **`Thread-specific data`** (**`TSD`**) is also known as thread-local; storage (TLS). Normally, any data that has lifetime beyond the local; variables on the thread's private stack are shared among all threads; within the process. Thread-specific data is a form of static or global; data that is maintained on a per-thread basis. That is, each thread gets; its own private copy of the data. Left to their own devices, threads execute independently.; **`Synchronization`** is the work that must be done when there are, in; fact, interdependencies that require some form of communication among; threads. Synchronization tools include mutexes, semaphores, condition; variables, and other variations on locking. A **`critical section`** is a section of code that accesses a; non-sharable resource. To ensure correct code, only one thread at a time; may execute in a critical section. In other words, the section is not; reentrant. A **`mutex`**, or mutual exclusion lock, is a synchronization object; with two states locked and unlocked. A mutex is usually used to ensure; that only one thread at a time executes some critical section of code.; Before entering a critical section, a thread will attempt to lock the; mutex, which guards that section. If the mutex is already locked, the; thread will block until the mutex is unlocked, at which time it will; lock the mutex, execute the critical section, and unlock the mutex upon; leaving the critical section. A **`semaphore`** is a synchronization mechanism that starts out; initialized to some positive value. A thread may ask to wait on a; semaphore in which case the thread blocks until the value of the; semaphore is positive. At that time the semaphore count is decremented; and the thread continues. When a thread releases semaphore, the; semaphore count is incremented. Counting semaphores are useful for; coordinating access to a limited pool of some resource. **`Readers/Writer Lock`** - a multiple-reader, single-writer loc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:21818,synchroniz,synchronization,21818,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['synchroniz'],['synchronization']
Integrability,"cate state and then reset it on; return:; ```; other_function:; # prolog; callq other_function; movq %rsp, %rax; sarq 63, %rax # Sign extend the high bit to all bits.; # ... .LBB0_N:; cmovneq %r8, %rax # Conditionally update predicate state.; shlq $47, %rax; orq %rax, %rsp; retq; ```. This approach is effective when all code is mitigated in this fashion, and can; even survive very limited reaches into unmitigated code (the state will; round-trip in and back out of an unmitigated function, it just won't be; updated). But it does have some limitations. There is a cost to merging the; state into `%rsp` and it doesn't insulate mitigated code from misspeculation in; an unmitigated caller. There is also an advantage to using this form of interprocedural mitigation: by; forming these invalid stack pointer addresses we can prevent speculative; returns from successfully reading speculatively written values to the actual; stack. This works first by forming a data-dependency between computing the; address of the return address on the stack and our predicate state. And even; when satisfied, if a misprediction causes the state to be poisoned the; resulting stack pointer will be invalid. ##### Rewrite API of internal functions to directly propagate predicate state. (Not yet implemented.). We have the option with internal functions to directly adjust their API to; accept the predicate as an argument and return it. This is likely to be; marginally cheaper than embedding into `%rsp` for entering functions. ##### Use `lfence` to guard function transitions. An `lfence` instruction can be used to prevent subsequent loads from; speculatively executing until all prior mispredicted predicates have resolved.; We can use this broader barrier to speculative loads executing between; functions. We emit it in the entry block to handle calls, and prior to each; return. This approach also has the advantage of providing the strongest degree; of mitigation when mixed with unmitigated code by halting",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:40678,depend,dependency,40678,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['depend'],['dependency']
Integrability,"cation, Prolog/Epilog Code; Insertion, Late Machine Code Optimizations, and Code Emission. * :doc:`TableGen/index` --- a document that describes the TableGen; (``tblgen``) application that manages domain-specific information to support; LLVM code generation. TableGen processes input from a target description; file (``.td`` suffix) and generates C++ code that can be used for code; generation. * :doc:`WritingAnLLVMPass` --- The assembly printer is a ``FunctionPass``, as; are several ``SelectionDAG`` processing steps. To follow the SPARC examples in this document, have a copy of `The SPARC; Architecture Manual, Version 8 <http://www.sparc.org/standards/V8.pdf>`_ for; reference. For details about the ARM instruction set, refer to the `ARM; Architecture Reference Manual <http://infocenter.arm.com/>`_. For more about; the GNU Assembler format (``GAS``), see `Using As; <http://sourceware.org/binutils/docs/as/index.html>`_, especially for the; assembly printer. ""Using As"" contains a list of target machine dependent; features. Basic Steps; -----------. To write a compiler backend for LLVM that converts the LLVM IR to code for a; specified target (machine or other language), follow these steps:. * Create a subclass of the ``TargetMachine`` class that describes; characteristics of your target machine. Copy existing examples of specific; ``TargetMachine`` class and header files; for example, start with; ``SparcTargetMachine.cpp`` and ``SparcTargetMachine.h``, but change the file; names for your target. Similarly, change code that references ""``Sparc``"" to; reference your target. * Describe the register set of the target. Use TableGen to generate code for; register definition, register aliases, and register classes from a; target-specific ``RegisterInfo.td`` input file. You should also write; additional code for a subclass of the ``TargetRegisterInfo`` class that; represents the class register file data used for register allocation and also; describes the interactions between re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:2897,depend,dependent,2897,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['depend'],['dependent']
Integrability,cation-depends tutorial-tmva-TMVAClassification); set (tmva-TMVAClassificationCategory-depends tutorial-tmva-TMVAClassification); set (tmva-TMVAClassificationCategoryApplication-depends tutorial-tmva-TMVAClassificationCategory); set (tmva-TMVAMulticlass-depends tutorial-tmva-TMVAMultipleBackgroundExample); set (tmva-TMVAMulticlassApplication-depends tutorial-tmva-TMVAMulticlass); set (tmva-TMVARegressionApplication-depends tutorial-tmva-TMVARegression); set (tmva-TMVACrossValidationRegression-depends tutorial-tmva-TMVARegressionApplication); set (tmva-TMVACrossValidationApplication-depends tutorial-tmva-TMVACrossValidation); set (tmva-tmva101_Training-depends tutorial-tmva-tmva100_DataPreparation-py); set (tmva-tmva102_Testing-depends tutorial-tmva-tmva101_Training-py); set (tmva-tmva003_RReader-depends tutorial-tmva-TMVAClassification); set (tmva-tmva004_RStandardScaler-depends tutorial-tmva-tmva003_RReader); if (PY_TORCH_FOUND); set (tmva-pytorch-ApplicationClassificationPyTorch-depends tutorial-tmva-pytorch-ClassificationPyTorch-py); set (tmva-pytorch-RegressionPyTorch-depends tutorial-tmva-pytorch-ApplicationClassificationPyTorch-py); set (tmva-pytorch-ApplicationRegressionPyTorch-depends tutorial-tmva-pytorch-RegressionPyTorch-py); endif(); if (PY_KERAS_FOUND); set (tmva-TMVA_SOFIE_RSofieReader-depends tutorial-tmva-TMVA_Higgs_Classification); set (tmva-TMVA_SOFIE_RDataFrame_JIT-depends tutorial-tmva-TMVA_SOFIE_RSofieReader); set (tmva-TMVA_SOFIE_Keras_HiggsModel-depends tutorial-tmva-TMVA_SOFIE_RDataFrame_JIT); set (tmva-TMVA_SOFIE_RDataFrame-depends tutorial-tmva-TMVA_SOFIE_Keras_HiggsModel); set (tmva-TMVA_SOFIE_Inference-depends tutorial-tmva-TMVA_SOFIE_RDataFrame); if (PY_TORCH_FOUND); set (tmva-keras-RegressionKeras-depends tutorial-tmva-pytorch-RegressionPyTorch-py); set (tmva-keras-ClassificationKeras-depends tutorial-tmva-pytorch-ClassificationPyTorch-py); endif(); set (tmva-keras-ApplicationRegressionKeras-depends tutorial-tmva-keras-RegressionKeras-p,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:20161,depend,depends,20161,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['depend'],['depends']
Integrability,"cc"", ""dd""}, {""ee"", ""ff""}};'); True; >>> type(cppyy.gbl.str_array[0][1]); <class cppyy.gbl.std.string at 0x7fd650ccb650>; >>> cppyy.gbl.str_array[0][1]; 'bb'; >>> cppyy.gbl.str_array[4][0]; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; IndexError: tuple index out of range; >>>. `Pointers`; """""""""""""""""""". When the C++ code takes a pointer or reference type to a specific builtin; type (such as an ``unsigned int`` for example), then types need to match; exactly.; ``cppyy`` supports the types provided by the standard modules ``ctypes`` and; ``array`` for those cases.; Example of using a reference to builtin:. .. code-block:: python. >>> from ctypes import c_uint; >>> u = c_uint(0); >>> c.uint_ref_assign(u, 42); >>> u.value; 42; >>>. For objects, an object, a pointer to an object, and a smart pointer to an; object are represented the same way, with the necessary (de)referencing; applied automatically.; Pointer variables are also bound by reference, so that updates on either the; C++ or Python side are reflected on the other side as well. `Enums`; """""""""""""". Named, anonymous, and class enums are supported.; The Python-underlying type of an enum is implementation dependent and may even; be different for different enums on the same compiler.; Typically, however, the types are ``int`` or ``unsigned int``, which; translates to Python's ``int`` or ``long`` on Python2 or class ``int`` on; Python3.; Separate from the underlying, all enums have their own Python type to allow; them to be used in template instantiations:. .. code-block:: python. >>> from cppyy.gbl import kBanana # classic enum, globally available; >>> print(kBanana); 29; >>> cppyy.gbl.EFruit; <class '__main__.EFruit'>; >>> print(cppyy.gbl.EFruit.kApple); 78; >>> cppyy.gbl.E1 # C++11 class enum, scoped; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; AttributeError: <namespace cppyy.gbl at 0x7ff2766a4af0> has no attribute 'E1'.; >>> cppyy.gbl.NamedClassEnum.E1; 42; >>>. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst:5554,depend,dependent,5554,bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,1,['depend'],['dependent']
Integrability,"cceptance) efficiency and a p.d.f as p.d.f.; rf704_amplitudefit.C - Using a p.d.f defined by a sum of real-valued amplitude components; rf705_linearmorph.C - Linear interpolation between p.d.f shapes using the 'Alex Read' algorithm; rf706_histpdf.C - Histogram based p.d.f.s and functions; rf707_kernelestimation.C - Using non-parametric (multi-dimensional) kernel estimation p.d.f.s; rf708_bphysics.C - Special decay pdf for B physics with mixing and/or CP violation; ; VALIDATION AND MC STUDIES. rf801_mcstudy.C - A Toy Monte Carlo study that perform cycles of event generation and fittting; rf802_mcstudy_addons.C - RooMCStudy: using separate fit and generator models, using the chi^2 calculator model; rf803_mcstudy_addons2.C - RooMCStudy: Using the randomizer and profile likelihood add-on models; rf804_mcstudy_constr.C - Using RooMCStudy on models with constrains; ; Miscellaneous small improvements. A very large number of small fixes and interface improvements have been made in the context of the systematic review of all methods for the new tutorial macros and updated Users Manual.; Listed below are the most significant functionality upgrades that were introduced in the process. ; Runtime binding of C++ functions - You can now trivially bind at run time any C++ functions as a RooFit function or p.d.f. objects, e.g. RooAbsReal* erfx = bindFunction(""erfx"",TMath::erf,x). See rf105_funcbinding.C for details; Runtime binding of TFx functions - You can now trivially bind at run time any ROOT TFx function as a RooFit function or p.d.f. objects, e.g. RooAbsReal* myFunc = bindFunction(myTF1,x). See rf105_funcbinding.C for details; RooAbsReal - The handling of -log(L) evaluation errors in plotting is now explicitly controllable, just like in fitting. See rf606_nllerrorhandling.C for details; RooDataHist - Add new named argument constructor that can collate multiple ROOT THn histgrams into a n+1 dimensional RooDataHist; RooDataSet - Add new named argument constructor that can colla",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:6476,interface,interface,6476,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['interface'],['interface']
Integrability,"ccesses are each one byte. In this case, the Loop Invariant Code Motion; (LICM) pass can use store motion to remove the stores from the loop. In; contrast, the following code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; ((short*)C)[0] = A[i]; /* Two byte store! */; C[1] = A[9-i]; /* One byte store */; }. In this case, the two stores to C do alias each other, because the access to the; ``&C[0]`` element is a two byte access. If size information wasn't available in; the query, even the first case would have to conservatively assume that the; accesses alias. .. _alias:. The ``alias`` method; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` interfaces, the ``alias`` method requires that either; the two pointer values be defined within the same function, or at least one of; the values is a :ref:`constant <constants>`. .. _Must, May, or No:. Must, May, and No Alias Responses; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``NoAlias`` response may be used when there is never an immediate dependence; between any memory reference *based* on one pointer and any memory reference; *based* the other. The most obvious example is when the two pointers point to; non-overlapping memory ranges. Another is when the two pointers are only ever; used for reading memory. Another is when the memory is freed and reallocated; between accesses through one pointer and accesses through the other --- in this; case, there is a dependence, but it's mediated by the free and reallocation. As an exception to this is with the :ref:`noalias <noalias>` keyword;; the ""irrelevant"" dependencies are ignored. The ``MayAlias`` response is used whenever the two pointers might refer to the; same object. The ``PartialAlias`` response is used when",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:4536,interface,interfaces,4536,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['interface'],['interfaces']
Integrability,"ce cache. Then we instrument that code. The process is similar for; generating the final optimized trace; we copy the same basic blocks; because we might need to put in fixup code for exit BBs. LLVM basic blocks are not typically used in the Reoptimizer except; for the mapping information. We are restricted to using single instructions to branch between the; original code, trace, and instrumented code. So we have to keep the; code copies in memory near the original code (they can't be far enough; away that a single pc-relative branch would not work.) Malloc() or; data region space is too far away. this impacts the design of the ; trace cache. We use a dummy function that is full of a bunch of for loops which we; overwrite with trace-cache code. The trace manager keeps track of; whether or not we have enough space in the trace cache, etc. The trace insertion routine takes an original start address, a vector; of machine instructions representing the trace, index of branches and; their corresponding absolute targets, and index of calls and their; corresponding absolute targets. The trace insertion routine is responsible for inserting branches from; the beginning of the original code to the beginning of the optimized; trace. This is because at some point the trace cache may run out of; space and it may have to evict a trace, at which point the branch to; the trace would also have to be removed. It uses a round-robin; replacement policy; we have found that this is almost as good as LRU; and better than random (especially because of problems fitting the new; trace in.). We cannot deal with discontiguous trace cache areas. The trace cache; is supposed to be cache-line-aligned, but it is not page-aligned. We generate instrumentation traces and optimized traces into separate; trace caches. We keep the instrumented code around because you don't; want to delete a trace when you still might have to return to it; (i.e., return from an llvm_first_trigger() or countPath() call.). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2003-06-25-Reoptimizer1.txt:5183,rout,routine,5183,interpreter/llvm-project/llvm/docs/HistoricalNotes/2003-06-25-Reoptimizer1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2003-06-25-Reoptimizer1.txt,1,['rout'],['routine']
Integrability,"cess any memory.; - ``memory(read)``: May read (but not write) any memory.; - ``memory(write)``: May write (but not read) any memory.; - ``memory(readwrite)``: May read or write any memory.; - ``memory(argmem: read)``: May only read argument memory.; - ``memory(argmem: read, inaccessiblemem: write)``: May only read argument; memory and only write inaccessible memory.; - ``memory(read, argmem: readwrite)``: May read any memory (default mode); and additionally write argument memory.; - ``memory(readwrite, argmem: none)``: May access any memory apart from; argument memory. The supported memory location kinds are:. - ``argmem``: This refers to accesses that are based on pointer arguments; to the function.; - ``inaccessiblemem``: This refers to accesses to memory which is not; accessible by the current module (before return from the function -- an; allocator function may return newly accessible memory while only; accessing inaccessible memory itself). Inaccessible memory is often used; to model control dependencies of intrinsics.; - The default access kind (specified without a location prefix) applies to; all locations that haven't been specified explicitly, including those that; don't currently have a dedicated location kind (e.g. accesses to globals; or captured pointers). If the ``memory`` attribute is not specified, then ``memory(readwrite)``; is implied (all memory effects are possible). The memory effects of a call can be computed as; ``CallSiteEffects & (FunctionEffects | OperandBundleEffects)``. Thus, the; call-site annotation takes precedence over the potential effects described; by either the function annotation or the operand bundles.; ``minsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function as small; as possible and perform optimizations that may sacrifice runtime; performance in order to minimize the size of the generated code.; This attribute is incompatible with the ``opt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:86043,depend,dependencies,86043,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependencies']
Integrability,"cess to different parts of; objects hierarchy or even fully 'hide' them from the client.; Restriction based on user account name, which is applied; when htdigest authentication is configured.; One also able to allow execution of selected methods. Implement multi.bin and multi.json requests.; One could request many items with single HTTP request.; Let optimize communication between server and client. With *SNIFF* tag in ClassDef() comments one could expose different properties,; which than exposed by the TRootSniffer to the client with h.json requests.; Such possibility ease implementation of client-side code for custom classes. Allow to bind http port with loopback address.; This restrict access to http server only from localhost.; One could either specify 'loopback' option in constructor:; new THttpServer(""http:8080?loopback""); or in clear text specify IP address to which http socket should be bind:; new THttpServer(""http:127.0.0.1:8080""); If host has several network interfaces, one could select one for binding:; new THttpServer(""http:192.168.1.17:8080""). ### TNetXNGFileStager; Fixed ROOT-7703. This restores the behavior of Locate() to that found with; TXNetFileStager: Rather than return only the xrootd server's reply, the endpoint; hostname is looked up and Locate() returns the full url, including the path. ### TWebFile; Fixed ROOT-7809. Returns an error for a redirect which does not specify the new; URI, rather than going into a loop. Fixed ROOT-7817. Avoid a crash under some circumstances when trying to open an; invalid path. ## GUI Libraries. ## Montecarlo Libraries. ## Multi-processing. With this version we introduce a new module, core/multiproc, for multi-processing on multi-core machines. This module is based on fork technology and offers an interface inspired from Python multiprocessor module. The new interface, implemented in the class TProcPool, provides the possibility to perform in parallel a very generic set of tasks, described by macros, functions or l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:20359,interface,interfaces,20359,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['interface'],['interfaces']
Integrability,"ch ROOT to use; C++ Modules by default. However, since it is essentially the same technology,; optimizations of C++ Modules also affect the PCH. We have a few tricks up in; the sleeves to but they come with given trade-offs. #### Preloading of C++ Modules. The main focus for the technology preview was not in performance until recently.; We have invested some resources in optimizations and we would like to show you; (probably outdated) performance results:. * Memory footprint -- mostly due to importing all C++ Modules at startup; we see overhead which depends on the number of preloaded modules. For; ROOT it is between 40-60 MB depending on the concrete configuration.; When the workload increases we notice that the overall memory performance; decreases in number of cases.; * Execution times -- likewise we have an execution overhead. For ; workflows which take ms the slowdown can be 2x. Increasing of the work; to seconds shows 50-60% slowdowns. The performance is dependent on many factors such as configuration of ROOT and; workflow. You can read more at our Intel IPCC-ROOT Showcase presentation; here (pp 25-33)[[8]]. #### Loading C++ Modules on Demand. In long term, we should optimize the preloading of modules to be a no-op and; avoid recursive behavior based on identifier lookup callbacks. Unfortunately,; at the moment the loading of C++ modules on demand shows significantly better; performance results. You can visit our continuous performance monitoring tool where we compare; the performance of ROOT against ROOT with a PCH [[9]].; *Note: if you get error 400, clean your cache or open a private browser session.*. ## How to use; C++ Modules in ROOT are default since v6.20 (Unix) and v6.22 (OSX). Enjoy. To disable C++ Modules in ROOT use `-Druntime_cxxmodules=Off`. ## Citing ROOT's C++ Modules; ```latex; % Peer-Reviewed Publication; %; % 22nd International Conference on Computing in High Energy and Nuclear Physics (CHEP); % 8-14 October, 2016, San Francisco, USA; %; @in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:18690,depend,dependent,18690,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['depend'],['dependent']
Integrability,"ch an argument, ARC retains the argument prior to making the; call. When receiving such an argument, ARC releases the argument at the end of the; function, subject to the usual optimizations for local values. .. admonition:: Rationale. This formalizes direct transfers of ownership from a caller to a callee. The; most common scenario here is passing the ``self`` parameter to ``init``, but; it is useful to generalize. Typically, local optimization will remove any; extra retains and releases: on the caller side the retain will be merged with; a +1 source, and on the callee side the release will be rolled into the; initialization of the parameter. The implicit ``self`` parameter of a method may be marked as consumed by adding; ``__attribute__((ns_consumes_self))`` to the method declaration. Methods in; the ``init`` :ref:`family <arc.method-families>` are treated as if they were; implicitly marked with this attribute. It is undefined behavior if an Objective-C message send to a method with; ``ns_consumed`` parameters (other than self) is made with a null receiver. It; is undefined behavior if the method to which an Objective-C message send; statically resolves to has a different set of ``ns_consumed`` parameters than; the method it dynamically resolves to. It is undefined behavior if a block or; function call is made through a static type with a different set of; ``ns_consumed`` parameters than the implementation of the called block or; function. .. admonition:: Rationale. Consumed parameters with null receiver are a guaranteed leak. Mismatches; with consumed parameters will cause over-retains or over-releases, depending; on the direction. The rule about function calls is really just an; application of the existing C/C++ rule about calling functions through an; incompatible function type, but it's useful to state it explicitly. .. _arc.object.operands.retained-return-values:. Retained return values; ^^^^^^^^^^^^^^^^^^^^^^. A function or method which returns a retainable o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:18129,message,message,18129,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"ch can be displayed in the browser. ```{.cpp}. auto win = ROOT::RWebWindow::Create();. // set HTML page which is showed when window displayed; win->SetDefaultPage(""file:page.html""); // set. // allow unlimitted user connections to the window (default only 1); win->SetConnLimit(0);. // configure predefined geometry; win->SetGeometry(300, 300);. ```. ## Communication. To receive data from the browser, data callback should be assigned.; Callback is invoked when data received from the client or when connection is established.; Normally lambda function is used:. ```{.cpp}. win->SetDataCallBack([](unsigned connid, const std::string &msg) {. printf(""Msg:%s from connection:%u\n"", msg.c_str(), connid);. });. ```. Here **connid** is unique identifier, which assign to each connection when it is established.; There are several predefined messages kinds: **""CONN_READY""** when new connection established and; **""CONN_CLOSED""** when connection is closed by client.; The connection identifier should be used when sending message to the client:. ```{.cpp}. // get connection id for the first connection in the list. if (win->NumConnections() > 0) {; unsigned connid = win->GetConnectionId();; std::string msg = ""Hello, world"";; win->Send(msg, connid);; }. ```. ## Display window. To display window in the browser, one should call `win->Show()` method.; This will starts new window (or new tab) in the default browser and show content of HTML page,; configured for the window. As argument of `Show()` method one can specify browser kind like; ""chromium"" or ""firefox"" or just full path to the program which should be invoked.; With the method `win->GetUrl()` one obtains URL string, which can be typed in the browser address string directly. Same window can be displayed several times in different browsers or different browser tabs - one only; must allow appropriate number of connections calling `win->SetConnLimit(3)`. For the local displays **Chromium Embeded Framework (CEF)** is used. It provides funct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md:1444,message,message,1444,documentation/users-guide/WebDisplay.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md,1,['message'],['message']
Integrability,"ch can be inspected programmatically.; - Add `Aggregate` action and implement `Reduce` in terms of it.; - Add support for a more general leafname syntax that includes pathnames with multiple dots, such as ""myBranch.mySubBranch.myLeaf"". This is available both for jitted expressions and for lists of column names.; - The CSV data source (TCsvDS) can now be constructed with a chunk size parameter, and as a result the CSV file will be read progressively, in chunks of the specified size. This can be used to prevent the whole CSV file from being read into memory at once, thus reducing the memory footprint of this data source.; - Add the `ROOT::Experimental::TAdoptAllocator<T>`, an allocator which allows to adopt existing memory. If memory is adopted, upon allocation a copy is performed in the new, potentially more extended, memory region.; - Add `ROOT::Experimental::VecOps::TVec<T>` a class which represents a contiguous array, inspired by Numpy arrays. `TVec` offer a convenient interface, almost identical to the one of `std::vector`. It can own or adopt its memory. As well as a set of tools which make analysis of collections easier, avoiding to loop over the individual elements of the collections. Basic arithmetic operations such as +,-,*,/,% between TVecs and scalars and TVecs are supported. Most popular math functions which act on TVecs are provided. Helpers to calculate basic quantities such as sum, mean, variance or standard deviation of TVecs are provided.; A powerful and concise syntax for expressing cuts is available:; ```; // mu_pts_tvec and mu_etas_tvec are two equally sized TVecs holding kinematic properties of muons; // a filter on muons pseudorapidities is applied considering a range in pseudo rapidity.; filtered_mu_pts_tvec = mu_pts_tvec[abs(mu_etas_tvec) < 2)];; ```; - The `TArrayBranch` class has been removed and replaced by the more powerful `TVec`.; - Columns on disk stored as C arrays should be read as `TVec`s, `std::vector` columns can be read as `TVec`s ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:8561,interface,interface,8561,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['interface'],['interface']
Integrability,"ch chained precompiled headers generalize the AST; file model:. Numbering of IDs; Many different kinds of entities --- identifiers, declarations, types, etc.; --- have ID numbers that start at 1 or some other predefined constant and; grow upward. Each precompiled header records the maximum ID number it has; assigned in each category. Then, when a new precompiled header is generated; that depends on (chains to) another precompiled header, it will start; counting at the next available ID number. This way, one can determine, given; an ID number, which AST file actually contains the entity. Name lookup; When writing a chained precompiled header, Clang attempts to write only; information that has changed from the precompiled header on which it is; based. This changes the lookup algorithm for the various tables, such as the; :ref:`identifier table <pchinternals-ident-table>`: the search starts at the; most-recent precompiled header. If no entry is found, lookup then proceeds; to the identifier table in the precompiled header it depends on, and so one.; Once a lookup succeeds, that result is considered definitive, overriding any; results from earlier precompiled headers. Update records; There are various ways in which a later precompiled header can modify the; entities described in an earlier precompiled header. For example, later; precompiled headers can add entries into the various name-lookup tables for; the translation unit or namespaces, or add new categories to an Objective-C; class. Each of these updates is captured in an ""update record"" that is; stored in the chained precompiled header file and will be loaded along with; the original entity. .. _pchinternals-modules:. Modules; -------. Modules generalize the chained precompiled header model yet further, from a; linear chain of precompiled headers to an arbitrary directed acyclic graph; (DAG) of AST files. All of the same techniques used to make chained; precompiled headers work --- ID number, name lookup, update rec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:26436,depend,depends,26436,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['depend'],['depends']
Integrability,"ch employed by many compilers to reduce compilation; time. The underlying motivation of the approach is that it is common for; the same (and often large) header files to be included by multiple; source files. Consequently, compile times can often be greatly improved; by caching some of the (redundant) work done by a compiler to process; headers. Precompiled header files, which represent one of many ways to; implement this optimization, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:46747,interface,interface,46747,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['interface'],['interface']
Integrability,"ch harder like ""out of space"", ""bad; disk sector"", or ""system call interrupted"". We'll call the first group ""*soft*""; errors and the second group ""*hard*"" errors. ``lib/Support`` must always attempt to minimize soft errors. This is a design; requirement because the minimization of soft errors can affect the granularity; and the nature of the interface. In general, if you find that you're wanting to; throw soft errors, you must review the granularity of the interface because it; is likely you're trying to implement something that is too low level. The rule; of thumb is to provide interface functions that **can't** fail, except when; faced with hard errors. For a trivial example, suppose we wanted to add an ""``OpenFileForWriting``""; function. For many operating systems, if the file doesn't exist, attempting to; open the file will produce an error. However, ``lib/Support`` should not simply; throw that error if it occurs because its a soft error. The problem is that the; interface function, ``OpenFileForWriting`` is too low level. It should be; ``OpenOrCreateFileForWriting``. In the case of the soft ""doesn't exist"" error,; this function would just create it and then open it for writing. This design principle needs to be maintained in ``lib/Support`` because it; avoids the propagation of soft error handling throughout the rest of LLVM.; Hard errors will generally just cause a termination for an LLVM tool so don't; be bashful about throwing them. Rules of thumb:. #. Don't throw soft errors, only hard errors. #. If you're tempted to throw a soft error, re-think the interface. #. Handle internally the most common normal/good/soft error conditions; so the rest of LLVM doesn't have to. No throw Specifications; -----------------------. None of the ``lib/Support`` interface functions may be declared with C++; ``throw()`` specifications on them. This requirement makes sure that the; compiler does not insert additional exception handling code into the interface; functions. This ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:8593,interface,interface,8593,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interface']
Integrability,"chain provides a good reference for what it accepts:. * Clang: https://clang.llvm.org/cxx_status.html. * libc++: https://libcxx.llvm.org/Status/Cxx17.html. * GCC: https://gcc.gnu.org/projects/cxx-status.html#cxx17. * libstdc++: https://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html#status.iso.2017. * MSVC: https://msdn.microsoft.com/en-us/library/hh567368.aspx. C++ Standard Library; --------------------. Instead of implementing custom data structures, we encourage the use of C++; standard library facilities or LLVM support libraries whenever they are; available for a particular task. LLVM and related projects emphasize and rely; on the standard library facilities and the LLVM support libraries as much as; possible. LLVM support libraries (for example, `ADT; <https://github.com/llvm/llvm-project/tree/main/llvm/include/llvm/ADT>`_); implement specialized data structures or functionality missing in the standard; library. Such libraries are usually implemented in the ``llvm`` namespace and; follow the expected standard interface, when there is one. When both C++ and the LLVM support libraries provide similar functionality, and; there isn't a specific reason to favor the C++ implementation, it is generally; preferable to use the LLVM library. For example, ``llvm::DenseMap`` should; almost always be used instead of ``std::map`` or ``std::unordered_map``, and; ``llvm::SmallVector`` should usually be used instead of ``std::vector``. We explicitly avoid some standard facilities, like the I/O streams, and instead; use LLVM's streams library (raw_ostream_). More detailed information on these; subjects is available in the :doc:`ProgrammersManual`. For more information about LLVM's data structures and the tradeoffs they make,; please consult `that section of the programmer's manual; <https://llvm.org/docs/ProgrammersManual.html#picking-the-right-data-structure-for-a-task>`_. Python version and Source Code Formatting; -----------------------------------------. The current min",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:3697,interface,interface,3697,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['interface'],['interface']
Integrability,"chains; # export TOOLCHAINS=org.llvm.3.8.0svn. # `xcrun -find clang` should return the installed clang, and `clang --version`; # should show 3.8.0svn. if(NOT APPLE); return(); endif(). option(LLVM_CREATE_XCODE_TOOLCHAIN ""Create a target to install LLVM into an Xcode toolchain"" Off). if(NOT LLVM_CREATE_XCODE_TOOLCHAIN); return(); endif(). # XCODE_VERSION is set by CMake when using the Xcode generator, otherwise we need; # to detect it manually here.; if(NOT XCODE_VERSION); execute_process(; COMMAND xcodebuild -version; OUTPUT_VARIABLE xcodebuild_version; OUTPUT_STRIP_TRAILING_WHITESPACE; ERROR_FILE /dev/null; ); string(REGEX MATCH ""Xcode ([0-9][0-9]?([.][0-9])+)"" version_match ${xcodebuild_version}); if(version_match); message(STATUS ""Identified Xcode Version: ${CMAKE_MATCH_1}""); set(XCODE_VERSION ${CMAKE_MATCH_1}); else(); # If detecting Xcode version failed, set a crazy high version so we default; # to the newest.; set(XCODE_VERSION 99); message(WARNING ""Failed to detect the version of an installed copy of Xcode, falling back to highest supported version. Set XCODE_VERSION to override.""); endif(); endif(). # Xcode 8 requires CompatibilityVersion 2; set(COMPAT_VERSION 2); if(XCODE_VERSION VERSION_LESS 8.0.0); # Xcode 7.3 (the first version supporting external toolchains) requires; # CompatibilityVersion 1; set(COMPAT_VERSION 1); endif(). execute_process(; COMMAND xcrun -find otool; OUTPUT_VARIABLE clang_path; OUTPUT_STRIP_TRAILING_WHITESPACE; ERROR_FILE /dev/null; ); string(REGEX MATCH ""(.*/Toolchains)/.*"" toolchains_match ${clang_path}); if(NOT toolchains_match); message(FATAL_ERROR ""Could not identify toolchain dir""); endif(); set(toolchains_dir ${CMAKE_MATCH_1}). set(LLVMToolchainDir ""${CMAKE_INSTALL_PREFIX}/Toolchains/LLVM${PACKAGE_VERSION}.xctoolchain/""). add_custom_command(OUTPUT ${LLVMToolchainDir}; COMMAND ${CMAKE_COMMAND} -E make_directory ${LLVMToolchainDir}). add_custom_command(OUTPUT ${LLVMToolchainDir}/Info.plist; DEPENDS ${LLVMToolchainDir}; COMMAND ${",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt:2435,message,message,2435,interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt,1,['message'],['message']
Integrability,"change, and you can reply. Some; comments are attached to specific lines, and appear interleaved with the; code. You can either reply to these, or address them and mark them as; ""done"". Note that in-line replies are **not** sent straight away! They; become ""draft"" comments and you must click ""Submit"" at the bottom of the; page. Updating your change; ~~~~~~~~~~~~~~~~~~~~. If you make changes in response to a reviewer's comments, simply update; your branch with more commits and push to your fork. It may be a good; idea to answer the comments from the reviewer explicitly. Accepting a revision; ~~~~~~~~~~~~~~~~~~~~. When the reviewer is happy with the change, they will **Accept** the; revision. They may leave some more minor comments that you should; address, but at this point the review is complete. It's time to get it; merged!. Commit by proxy; ---------------. As this is your first change, you won't have access to merge it; yourself yet. The reviewer **doesn't know this**, so you need to tell; them! Leave a message on the review like:. Thanks @somellvmdev. I don't have commit access, can you land this; patch for me?. The pull-request will be closed and you will be notified by GitHub. Review expectations; -------------------. In order to make LLVM a long-term sustainable effort, code needs to be; maintainable and well tested. Code reviews help to achieve that goal.; Especially for new contributors, that often means many rounds of reviews; and push-back on design decisions that do not fit well within the; overall architecture of the project. For your first patches, this means:. - be kind, and expect reviewers to be kind in return - LLVM has a `Code; of Conduct <https://llvm.org/docs/CodeOfConduct.html>`__;. - be patient - understanding how a new feature fits into the; architecture of the project is often a time consuming effort, and; people have to juggle this with other responsibilities in their; lives; **ping the review once a week** when there is no response;. - if ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:11371,message,message,11371,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['message'],['message']
Integrability,"changed. General performance tuning of RooFit to reduce computational overhead. Extensive profiling of; CPU times in call graphas and analysis heap memory use have been performed and many small ; changes have been made to make the code more efficient and use less memory. RooStats Package; AsymptoticCalculator. New Class for doing an hypothesis tests using the asymptotic likelihood formulae, described in the paper from; G. Cowan, K. Cranmer, E. Gross and O. Vitells, Asymptotic formulae for likelihood- based tests of new physics,; Eur. Phys. J., C71 (1), 2011.; The class computes the p-value for the null and also for the alternate using the Asimov data set. In this; differs form the ProfileLikelihoodCalculator which computes only the p-values for the null hypothesis.; The Asimov data set is generated with the utility function AsymptoticCalculator::MakeAsimovData and then; it is used to evaluate the likelihood. ; ; This class implements the HypoTestCalculatorGeneric interface and can be used as an alternative Hypothesis test; calculator in the HypoTestInverter class. It can then plugged in the HypoTestInverter for computing asymptotic CLs and CLs+b; limits. In this way the limits will be computed by just performing a fit for each test parameter value and without; generating any toys. . The class can be used via the StandardHypothesisTest.C tutorial passing a value of 2 for the; calculator type. . RooStats Utils. Add a utility function (from G. Petrucciani), RooStats::MakeNuisancePdf, which given a model configuration (or the global pdf and the; observables), factorizes from the model pdf the constraint probability density functions for the nuisance parameters; and builds a global nuisance pdf. This function can then be used in the HybridCalculator or in the BayesianCalculator; with the option ""TOYMC"".; . HypotestInverter and HypoTestInverterResult. Several improvements and bug fixes in merging results and in computing the observed and expected limits.; Provide support n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html:7623,interface,interface,7623,roofit/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html,1,['interface'],['interface']
Integrability,"cially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first instruction: because the first; instruction uses the 8-bit %al register as an operand, it is clear that; it is an 8-bit add. The second instruction is accepted by both because the ""w""; suffix indicates that it is a 16-bit add. The last instruction is accepted by; GAS even though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: err",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7464,integrat,integrated,7464,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,2,['integrat'],['integrated']
Integrability,"ciently comprehensive; library of serializers and deserializers will emerge over time. For more details, consult the tutorial [rf515_hfJSON](https://root.cern/doc/v626/rf515__hfJSON_8py.html). ### Creating RooFit datasets from RDataFrame; RooFit now contains two RDataFrame action helpers, `RooDataSetHelper` and `RooDataHistHelper`, which allow for creating RooFit datasets by booking an action:; ```c++; RooRealVar x(""x"", ""x"", -5., 5.);; RooRealVar y(""y"", ""y"", -50., 50.);; auto myDataSet = rdataframe.Book<double, double>(; RooDataSetHelper{""dataset"", // Name (directly forwarded to RooDataSet::RooDataSet()); ""Title of dataset"", // Title ( ~ "" ~ ); RooArgSet(x, y) }, // Variables to create in dataset; {""x"", ""y""} // Column names from RDataFrame; );; ```; For more details, consult the tutorial [rf408_RDataFrameToRooFit](https://root.cern/doc/v626/rf408__RDataFrameToRooFit_8C.html). ### Storing global observables in RooFit datasets. RooFit groups model variables into *observables* and *parameters*, depending on if their values are stored in the dataset.; For fits with parameter constraints, there is a third kind of variables, called *global observables*.; These represent the results of auxiliary measurements that constrain the nuisance parameters.; In the RooFit implementation, a likelihood is generally the sum of two terms:; * the likelihood of the data given the parameters, where the normalization set is the set of observables (implemented by `RooNLLVar`); * the constraint term, where the normalization set is the set of *global observables* (implemented by `RooConstraintSum`). Before this release, the global observable values were always taken from the model/pdf.; With this release, a mechanism is added to store a snapshot of global observables in any `RooDataSet` or `RooDataHist`.; For toy studies where the global observables assume a different values for each toy, the bookkeeping of the set of global observables and in particular their values is much easier with this ch",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:26866,depend,depending,26866,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['depend'],['depending']
Integrability,"cies. To enforce; this, we wrap all constructor calls of all AST nodes in; ``GetImportedOrCreateDecl()``. This wrapper ensures that all newly created; declarations are immediately marked as imported; also, if a declaration is; already marked as imported then we just return its counterpart in the ""to""; context. Consequently, calling a declaration's ``::Create()`` function directly; would lead to errors, please don't do that!. Even with the use of ``GetImportedOrCreateDecl()`` there is still a; probability of having an infinite import recursion if things are imported from; each other in wrong way. Imagine that during the import of ``A``, the import of; ``B`` is requested before we could create the node for ``A`` (the constructor; needs a reference to ``B``). And the same could be true for the import of ``B``; (``A`` is requested to be imported before we could create the node for ``B``).; In case of the :ref:`templated-described swing <templated>` we take; extra attention to break the cyclical dependency: we import and set the; described template only after the ``CXXRecordDecl`` is created. As a best; practice, before creating the node in the ""to"" context, avoid importing of; other nodes which are not needed for the constructor of node ``A``. Error Handling; ^^^^^^^^^^^^^^. Every import function returns with either an ``llvm::Error`` or an; ``llvm::Expected<T>`` object. This enforces to check the return value of the; import functions. If there was an error during one import then we return with; that error. (Exception: when we import the members of a class, we collect the; individual errors with each member and we concatenate them in one Error; object.) We cache these errors in cases of declarations. During the next import; call if there is an existing error we just return with that. So, clients of the; library receive an Error object, which they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we rec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:99982,depend,dependency,99982,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['dependency']
Integrability,"cies: [ 0.30% ]; - Register Dependencies [ 0.30% ]; - Memory Dependencies [ 0.00% ]. Critical sequence based on the simulation:. Instruction Dependency Information; +----< 2. vhaddps %xmm3, %xmm3, %xmm4; |; | < loop carried >; |; | 0. vmulps %xmm0, %xmm1, %xmm2; +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 74% ]; +----> 2. vhaddps %xmm3, %xmm3, %xmm4 ## REGISTER dependency: %xmm3; |; | < loop carried >; |; +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 74% ]. According to the analysis, throughput is limited by resource pressure and not by; data dependencies. The analysis observed increases in backend pressure during; 48.07% of the simulated run. Almost all those pressure increase events were; caused by contention on processor resources JFPA/JFPU0. The `critical sequence` is the most expensive sequence of instructions according; to the simulation. It is annotated to provide extra information about critical; register dependencies and resource interferences between instructions. Instructions from the critical sequence are expected to significantly impact; performance. By construction, the accuracy of this analysis is strongly; dependent on the simulation and (as always) by the quality of the processor; model in llvm. Bottleneck analysis is currently not supported for processors with an in-order; backend. Extra Statistics to Further Diagnose Performance Issues; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; The ``-all-stats`` command line option enables extra statistics and performance; counters for the dispatch logic, the reorder buffer, the retire control unit,; and the register file. Below is an example of ``-all-stats`` output generated by :program:`llvm-mca`; for 300 iterations of the dot-product example discussed in the previous; sections. .. code-block:: none. Dynamic Dispatch Stall Cycles:; RAT - Register unavailable: 0; RCU - Retire tokens unavailable: 0; SCHEDQ - Scheduler fu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:28147,depend,dependencies,28147,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['dependencies']
Integrability,"cific extensions, if; possible. Defaults to ON. **LLVM_ENABLE_PIC**:BOOL; Add the ``-fPIC`` flag to the compiler command-line, if the compiler supports; this flag. Some systems, like Windows, do not need this flag. Defaults to ON. **LLVM_ENABLE_PROJECTS**:STRING; Semicolon-separated list of projects to build, or *all* for building all; (clang, lldb, lld, polly, etc) projects. This flag assumes that projects; are checked out side-by-side and not nested, i.e. clang needs to be in; parallel of llvm instead of nested in `llvm/tools`. This feature allows; to have one build for only LLVM and another for clang+llvm using the same; source checkout.; The full list is:; ``clang;clang-tools-extra;cross-project-tests;libc;libclc;lld;lldb;openmp;polly;pstl``. **LLVM_ENABLE_RUNTIMES**:STRING; Build libc++, libc++abi, libunwind or compiler-rt using the just-built compiler.; This is the correct way to build runtimes when putting together a toolchain.; It will build the builtins separately from the other runtimes to preserve; correct dependency ordering. If you want to build the runtimes using a system; compiler, see the `libc++ documentation <https://libcxx.llvm.org/BuildingLibcxx.html>`_.; Note: the list should not have duplicates with `LLVM_ENABLE_PROJECTS`.; The full list is:; ``compiler-rt;libc;libcxx;libcxxabi;libunwind;openmp``; To enable all of them, use:; ``LLVM_ENABLE_RUNTIMES=all``. **LLVM_ENABLE_RTTI**:BOOL; Build LLVM with run-time type information. Defaults to OFF. **LLVM_ENABLE_SPHINX**:BOOL; If specified, CMake will search for the ``sphinx-build`` executable and will make; the ``SPHINX_OUTPUT_HTML`` and ``SPHINX_OUTPUT_MAN`` CMake options available.; Defaults to OFF. **LLVM_ENABLE_THREADS**:BOOL; Build with threads support, if available. Defaults to ON. **LLVM_ENABLE_UNWIND_TABLES**:BOOL; Enable unwind tables in the binary. Disabling unwind tables can reduce the; size of the libraries. Defaults to ON. **LLVM_ENABLE_WARNINGS**:BOOL; Enable all compiler warnings. Defaul",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:24750,depend,dependency,24750,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['depend'],['dependency']
Integrability,"cified, the archive is not; modified. .. option:: m [abi]. Move files from one location in the ``archive`` to another. The :option:`a`,; :option:`b`, and :option:`i` modifiers apply to this operation. The *files*; will all be moved to the location given by the modifiers. If no modifiers are; used, the files will be moved to the end of the archive. If no *files* are; specified, the archive is not modified. .. option:: p [v]. Print *files* to the standard output stream. If no *files* are specified, the; entire ``archive`` is printed. With the :option:`v` modifier,; :program:`llvm-ar` also prints out the name of the file being output. Printing; binary files is ill-advised as they might confuse your terminal settings. The; :option:`p` operation never modifies the archive. .. option:: q [LT]. Quickly append files to the end of the ``archive`` without removing; duplicates. If no *files* are specified, the archive is not modified. The; behavior when appending one archive to another depends upon whether the; :option:`L` and :option:`T` modifiers are used:. * Appending a regular archive to a regular archive will append the archive; file. If the :option:`L` modifier is specified the members will be appended; instead. * Appending a regular archive to a thin archive requires the :option:`T`; modifier and will append the archive file. The :option:`L` modifier is not; supported. * Appending a thin archive to a regular archive will append the archive file.; If the :option:`L` modifier is specified the members will be appended; instead. * Appending a thin archive to a thin archive will always quick append its; members. .. option:: r [abTu]. Replace existing *files* or insert them at the end of the ``archive`` if; they do not exist. The :option:`a`, :option:`b`, :option:`T` and :option:`u`; modifiers apply to this operation. If no *files* are specified, the archive; is not modified. t[v]; .. option:: t [vO]. Print the table of contents. Without any modifiers, this operation just prin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst:4177,depend,depends,4177,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ar.rst,1,['depend'],['depends']
Integrability,"cing a new one as; a stopgap measure. ``createStringError`` can take ``printf`` style format specifiers to provide a; formatted message:. .. code-block:: c++. createStringError(errc::executable_format_error,; ""Bad executable: %s"", FileName);. Interoperability with std::error_code and ErrorOr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Many existing LLVM APIs use ``std::error_code`` and its partner ``ErrorOr<T>``; (which plays the same role as ``Expected<T>``, but wraps a ``std::error_code``; rather than an ``Error``). The infectious nature of error types means that an; attempt to change one of these functions to return ``Error`` or ``Expected<T>``; instead often results in an avalanche of changes to callers, callers of callers,; and so on. (The first such attempt, returning an ``Error`` from; MachOObjectFile's constructor, was abandoned after the diff reached 3000 lines,; impacted half a dozen libraries, and was still growing). To solve this problem, the ``Error``/``std::error_code`` interoperability requirement was; introduced. Two pairs of functions allow any ``Error`` value to be converted to a; ``std::error_code``, any ``Expected<T>`` to be converted to an ``ErrorOr<T>``, and vice; versa:. .. code-block:: c++. std::error_code errorToErrorCode(Error Err);; Error errorCodeToError(std::error_code EC);. template <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> TOrErr);; template <typename T> Expected<T> errorOrToExpected(ErrorOr<T> TOrEC);. Using these APIs it is easy to make surgical patches that update individual; functions from ``std::error_code`` to ``Error``, and from ``ErrorOr<T>`` to; ``Expected<T>``. Returning Errors from error handlers; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Error recovery attempts may themselves fail. For that reason, ``handleErrors``; actually recognises three different forms of handler signature:. .. code-block:: c++. // Error must be handled, no new errors produced:; void(UserDefinedError &E);. // Error must be handled, new e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:28959,interoperab,interoperability,28959,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['interoperab'],['interoperability']
Integrability,"cing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or; agreed to in writing, Licensor provides the Work (and each; Contributor provides its Contributions) on an ""AS IS"" BASIS,; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or; implied, including, without limitation, any warranties or conditions; of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A; PARTICULAR PURPOSE. You are solely responsible for determining the; appropriateness of using or redistributing the Work and assume any; risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory,; whether in tort (including negligence), contract, or otherwise,; unless required by applicable law (such as deliberate and grossly; negligent acts) or agreed to in writing, shall any Contributor be; liable to You for damages, including any direct, indirect, special,; incidental, or consequential damages of any character arising as a; result of this License or out of the use or inability to use the; Work (including but not limited to damages for loss of goodwill,; work stoppage, computer failure or malfunction, or any and all; other commercial damages or losses), even if such Contributor; has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing; the Work or Derivative Works thereof, You may choose to offer,; and charge a fee for, acceptance of support, warranty, indemnity,; or other liability obligations and/or rights consistent with this; License. However, in accepting such obligations, You may act only; on Your own behalf and on Your sole responsibility, not on behalf; of any other Contributor, and only if You agree to indemnify,; defend, and hold each Contributor harmless for any liability; incurred by, or claims asserted against, such Contributor by reason; of your accepting any such warranty or additional liability.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/LICENSE.TXT:8201,contract,contract,8201,interpreter/llvm-project/clang/LICENSE.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/LICENSE.TXT,4,['contract'],['contract']
Integrability,"cingBitVector container is similar in principle to a SparseBitVector,; but is optimized to represent large contiguous ranges of set bits compactly. It; does this by coalescing contiguous ranges of set bits into intervals. Searching; for a bit in a CoalescingBitVector is O(log(gaps between contiguous ranges)). CoalescingBitVector is a better choice than BitVector when gaps between ranges; of set bits are large. It's a better choice than SparseBitVector when find(); operations must have fast, predictable performance. However, it's not a good; choice for representing sets which have lots of very short ranges. E.g. the set; `{2*x : x \in [0, n)}` would be a pathological input. .. _utility_functions:. Useful Utility Functions; ========================. LLVM implements a number of general utility functions used across the; codebase. You can find the most common ones in ``STLExtras.h``; (`doxygen <https://llvm.org/doxygen/STLExtras_8h.html>`__). Some of these wrap; well-known C++ standard library functions, while others are unique to LLVM. .. _uf_iteration:. Iterating over ranges; ---------------------. Sometimes you may want to iterate over more than range at a time or know the; index of the index. LLVM provides custom utility functions to make that easier,; without having to manually manage all iterators and/or indices:. .. _uf_zip:. The ``zip``\ * functions; ^^^^^^^^^^^^^^^^^^^^^^^^. ``zip``\ * functions allow for iterating over elements from two or more ranges; at the same time. For example:. .. code-block:: c++. SmallVector<size_t> Counts = ...;; char Letters[26] = ...;; for (auto [Letter, Count] : zip_equal(Letters, Counts)); errs() << Letter << "": "" << Count << ""\n"";. Note that the elements are provided through a 'reference wrapper' proxy type; (tuple of references), which combined with the structured bindings declaration; makes ``Letter`` and ``Count`` references to range elements. Any modification; to these references will affect the elements of ``Letters`` or ``C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:99809,wrap,wrap,99809,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['wrap'],['wrap']
Integrability,"ciple needs to be maintained in ``lib/Support`` because it; avoids the propagation of soft error handling throughout the rest of LLVM.; Hard errors will generally just cause a termination for an LLVM tool so don't; be bashful about throwing them. Rules of thumb:. #. Don't throw soft errors, only hard errors. #. If you're tempted to throw a soft error, re-think the interface. #. Handle internally the most common normal/good/soft error conditions; so the rest of LLVM doesn't have to. No throw Specifications; -----------------------. None of the ``lib/Support`` interface functions may be declared with C++; ``throw()`` specifications on them. This requirement makes sure that the; compiler does not insert additional exception handling code into the interface; functions. This is a performance consideration: ``lib/Support`` functions are; at the bottom of many call chains and as such can be frequently called. We; need them to be as efficient as possible. However, no routines in the system; library should actually throw exceptions. Code Organization; -----------------. Implementations of the Support Library interface are separated by their general; class of operating system. Currently only Unix and Win32 classes are defined; but more could be added for other operating system classifications. To; distinguish which implementation to compile, the code in ``lib/Support`` uses; the ``LLVM_ON_UNIX`` and ``_WIN32`` ``#defines``. Each source file in; ``lib/Support``, after implementing the generic (operating system independent); functionality needs to include the correct implementation using a set of; ``#if defined(LLVM_ON_XYZ)`` directives. For example, if we had; ``lib/Support/Path.cpp``, we'd expect to see in that file:. .. code-block:: c++. #if defined(LLVM_ON_UNIX); #include ""Unix/Path.inc""; #endif; #if defined(_WIN32); #include ""Windows/Path.inc""; #endif. The implementation in ``lib/Support/Unix/Path.inc`` should handle all Unix; variants. The implementation in ``lib/Support/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:9803,rout,routines,9803,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['rout'],['routines']
Integrability,"ck syntax check, over a bunch of code. Parsing a code snippet in memory; --------------------------------. If you ever wanted to run a ``FrontendAction`` over some sample code, for; example to unit test parts of the Clang AST, ``runToolOnCode`` is what you; looked for. Let me give you an example:. .. code-block:: c++. #include ""clang/Tooling/Tooling.h"". TEST(runToolOnCode, CanSyntaxCheckCode) {; // runToolOnCode returns whether the action was correctly run over the; // given code.; EXPECT_TRUE(runToolOnCode(std::make_unique<clang::SyntaxOnlyAction>(), ""class X {};""));; }. Writing a standalone tool; -------------------------. Once you unit tested your ``FrontendAction`` to the point where it cannot; possibly break, it's time to create a standalone tool. For a standalone tool; to run clang, it first needs to figure out what command line arguments to use; for a specified file. To that end we create a ``CompilationDatabase``. There; are different ways to create a compilation database, and we need to support all; of them depending on command-line options. There's the ``CommonOptionsParser``; class that takes the responsibility to parse command-line parameters related to; compilation databases and inputs, so that all tools share the implementation. Parsing common tools options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``CompilationDatabase`` can be read from a build directory or the command line.; Using ``CommonOptionsParser`` allows for explicit specification of a compile; command line, specification of build path using the ``-p`` command-line option,; and automatic location of the compilation database using source files paths. .. code-block:: c++. #include ""clang/Tooling/CommonOptionsParser.h""; #include ""llvm/Support/CommandLine.h"". using namespace clang::tooling;. // Apply a custom category to all command-line options so that they are the; // only ones displayed.; static llvm::cl::OptionCategory MyToolCategory(""my-tool options"");. int main(int argc, const char **argv) {; // Common",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst:1618,depend,depending,1618,interpreter/llvm-project/clang/docs/LibTooling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst,1,['depend'],['depending']
Integrability,"ck that is also in allocated storage; (that it is the result of a ``Block_copy`` operation). Despite this; there is no provision to do a ``Block_copy`` or a ``Block_release`` if; an implementation provides initial automatic storage for Blocks. This; is due to the inherent race condition of potentially several threads; trying to update the shared variable and the need for synchronization; around disposing of older values and copying new ones. Such; synchronization is beyond the scope of this language specification. Control Flow; ============. The compound statement of a Block is treated much like a function body; with respect to control flow in that goto, break, and continue do not; escape the Block. Exceptions are treated *normally* in that when; thrown they pop stack frames until a catch clause is found. Objective-C Extensions; ======================. Objective-C extends the definition of a Block reference type to be; that also of id. A variable or expression of Block type may be; messaged or used as a parameter wherever an id may be. The converse is; also true. Block references may thus appear as properties and are; subject to the assign, retain, and copy attribute logic that is; reserved for objects. All Blocks are constructed to be Objective-C objects regardless of; whether the Objective-C runtime is operational in the program or; not. Blocks using automatic (stack) memory are objects and may be; messaged, although they may not be assigned into ``__weak`` locations; if garbage collection is enabled. Within a Block literal expression within a method definition; references to instance variables are also imported into the lexical; scope of the compound statement. These variables are implicitly; qualified as references from self, and so self is imported as a const; copy. The net effect is that instance variables can be mutated. The :block-term:`Block_copy` operator retains all objects held in; variables of automatic storage referenced within the Block expression; (o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:8790,message,messaged,8790,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['message'],['messaged']
Integrability,"ck:: c++. Inst->replaceAllUsesWith(ConstVal);. .. _User:. The ``User`` class; ------------------. ``#include ""llvm/IR/User.h""``. header source: `User.h <https://llvm.org/doxygen/User_8h_source.html>`_. doxygen info: `User Class <https://llvm.org/doxygen/classllvm_1_1User.html>`_. Superclass: Value_. The ``User`` class is the common base class of all LLVM nodes that may refer to; ``Value``\ s. It exposes a list of ""Operands"" that are all of the ``Value``\ s; that the User is referring to. The ``User`` class itself is a subclass of; ``Value``. The operands of a ``User`` point directly to the LLVM ``Value`` that it refers; to. Because LLVM uses Static Single Assignment (SSA) form, there can only be; one definition referred to, allowing this direct connection. This connection; provides the use-def information in LLVM. .. _m_User:. Important Public Members of the ``User`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``User`` class exposes the operand list in two ways: through an index access; interface and through an iterator based interface. * | ``Value *getOperand(unsigned i)``; | ``unsigned getNumOperands()``. These two methods expose the operands of the ``User`` in a convenient form for; direct access. * | ``User::op_iterator`` - Typedef for iterator over the operand list; | ``op_iterator op_begin()`` - Get an iterator to the start of the operand; list.; | ``op_iterator op_end()`` - Get an iterator to the end of the operand list. Together, these methods make up the iterator based interface to the operands; of a ``User``. .. _Instruction:. The ``Instruction`` class; -------------------------. ``#include ""llvm/IR/Instruction.h""``. header source: `Instruction.h; <https://llvm.org/doxygen/Instruction_8h_source.html>`_. doxygen info: `Instruction Class; <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_. Superclasses: User_, Value_. The ``Instruction`` class is the common base class for all LLVM instructions.; It provides only a few methods, but is a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:145628,interface,interface,145628,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,2,['interface'],['interface']
Integrability,"ck:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. struct Stuff {; ...; };. template <>; struct MappingTraits<Stuff> {; static void mapping(IO &io, Stuff &stuff) {; ...; }; static std::string validate(IO &io, Stuff &stuff) {; // Look at all fields in 'stuff' and if there; // are any bad values return a string describing; // the error. Otherwise return an empty string.; return std::string{};; }; };. Flow Mapping; ------------; A YAML ""flow mapping"" is a mapping that uses the inline notation; (e.g { x: 1, y: 0 } ) when written to YAML. To specify that a type should be; written in YAML using flow mapping, your MappingTraits specialization should; add ""static const bool flow = true;"". For instance:. .. code-block:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. struct Stuff {; ...; };. template <>; struct MappingTraits<Stuff> {; static void mapping(IO &io, Stuff &stuff) {; ...; }. static const bool flow = true;; }. Flow mappings are subject to line wrapping according to the Output object; configuration. Sequence; ========. To be translated to or from a YAML sequence for your type T you must specialize; llvm::yaml::SequenceTraits on T and implement two methods:; ``size_t size(IO &io, T&)`` and; ``T::value_type& element(IO &io, T&, size_t indx)``. For example:. .. code-block:: c++. template <>; struct SequenceTraits<MySeq> {; static size_t size(IO &io, MySeq &list) { ... }; static MySeqEl &element(IO &io, MySeq &list, size_t index) { ... }; };. The size() method returns how many elements are currently in your sequence.; The element() method returns a reference to the i'th element in the sequence.; When parsing YAML, the element() method may be called with an index one bigger; than the current size. Your element() method should allocate space for one; more element (using default constructor if element is a C++ object) and returns; a reference to that new allocated space. Flow Sequence; -------------; A YAML ""flow sequence"" is a sequence that ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:24803,wrap,wrapping,24803,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['wrap'],['wrapping']
Integrability,"ck_descriptor_5 = { 0, sizeof(struct __block_literal_5), __block_copy_5, __block_dispose_5 };. and within the compound statement:. .. code-block:: c. truct _block_byref_obj obj = {( .forwarding=&obj, .flags=(1<<25), .size=sizeof(struct _block_byref_obj),; .byref_keep=_block_byref_obj_keep, .byref_dispose=_block_byref_obj_dispose,; .captured_obj = <initialization expression> )};. truct __block_literal_5 _block_literal = {; &_NSConcreteStackBlock,; (1<<25)|(1<<29), <uninitialized>,; __block_invoke_5,; &__block_descriptor_5,; &obj, // a reference to the on-stack structure containing ""captured_obj""; };. functioncall(_block_literal->invoke(&_block_literal));. C++ Support; ===========. Within a block stack based C++ objects are copied into ``const`` copies using; the copy constructor. It is an error if a stack based C++ object is used within; a block if it does not have a copy constructor. In addition both copy and; destroy helper routines must be synthesized for the block to support the; ``Block_copy()`` operation, and the flags work marked with the (1<<26) bit in; addition to the (1<<25) bit. The copy helper should call the constructor using; appropriate offsets of the variable within the supplied stack based block source; and heap based destination for all ``const`` constructed copies, and similarly; should call the destructor in the destroy routine. As an example, suppose a C++ class ``FOO`` existed with a copy constructor.; Within a code block a stack version of a ``FOO`` object is declared and used; within a ``Block`` literal expression:. .. code-block:: c++. {; FOO foo;; void (^block)(void) = ^{ printf(""%d\n"", foo.value()); };; }. The compiler would synthesize:. .. code-block:: c++. struct __block_literal_10 {; void *isa;; int flags;; int reserved;; void (*invoke)(struct __block_literal_10 *);; struct __block_descriptor_10 *descriptor;; const FOO foo;; };. void __block_invoke_10(struct __block_literal_10 *_block) {; printf(""%d\n"", _block->foo.value());; }. void __bl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:23737,rout,routines,23737,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['rout'],['routines']
Integrability,"cking that ``expr`` is a non-member; static call expression. The call to that expression is made while using ``ptr``; as a function pointer stored in a dedicated register to implement *static chain*; calling convention, as used by some language to implement closures or nested; functions. Query for this feature with ``__has_builtin(__builtin_call_with_static_chain)``. ``__builtin_readcyclecounter``; ------------------------------. ``__builtin_readcyclecounter`` is used to access the cycle counter register (or; a similar low-latency, high-accuracy clock) on those targets that support it. **Syntax**:. .. code-block:: c++. __builtin_readcyclecounter(). **Example of Use**:. .. code-block:: c++. unsigned long long t0 = __builtin_readcyclecounter();; do_something();; unsigned long long t1 = __builtin_readcyclecounter();; unsigned long long cycles_to_do_something = t1 - t0; // assuming no overflow. **Description**:. The ``__builtin_readcyclecounter()`` builtin returns the cycle counter value,; which may be either global or process/thread-specific depending on the target.; As the backing counters often overflow quickly (on the order of seconds) this; should only be used for timing small intervals. When not supported by the; target, the return value is always zero. This builtin takes no arguments and; produces an unsigned long long result. Query for this feature with ``__has_builtin(__builtin_readcyclecounter)``. Note; that even if present, its use may depend on run-time privilege or other OS; controlled state. ``__builtin_dump_struct``; -------------------------. **Syntax**:. .. code-block:: c++. __builtin_dump_struct(&some_struct, some_printf_func, args...);. **Examples**:. .. code-block:: c++. struct S {; int x, y;; float f;; struct T {; int i;; } t;; };. void func(struct S *s) {; __builtin_dump_struct(s, printf);; }. Example output:. .. code-block:: none. struct S {; int x = 100; int y = 42; float f = 3.141593; struct T t = {; int i = 1997; }; }. .. code-block:: c++. #inc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:103468,depend,depending,103468,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['depend'],['depending']
Integrability,"cking the previously; mentioned properties, we have to check for equivalent template; parameters/arguments, etc. The structural equivalent check can be and is used independently from the; ASTImporter, e.g. the ``clang::Sema`` class uses it also. The equivalence of nodes may depend on the equivalency of other pairs of nodes.; Thus, the check is implemented as a parallel graph traversal. We traverse; through the nodes of both graphs at the same time. The actual implementation is; similar to breadth-first-search. Let's say we start the traverse with the <A,B>; pair of nodes. Whenever the traversal reaches a pair <X,Y> then the following; statements are true:. - A and X are nodes from the same ASTContext.; - B and Y are nodes from the same ASTContext.; - A and B may or may not be from the same ASTContext.; - if A == X and B == Y (pointer equivalency) then (there is a cycle during the; traverse). - A and B are structurally equivalent if and only if. - All dependent nodes on the path from <A,B> to <X,Y> are structurally; equivalent. When we compare two classes or enums and one of them is incomplete or has; unloaded external lexical declarations then we cannot descend to compare their; contained declarations. So in these cases they are considered equal if they; have the same names. This is the way how we compare forward declarations with; definitions. .. TODO Should we elaborate the actual implementation of the graph traversal,; .. which is a very weird BFS traversal?. Redeclaration Chains; ^^^^^^^^^^^^^^^^^^^^. The early version of the ``ASTImporter``'s merge mechanism squashed the; declarations, i.e. it aimed to have only one declaration instead of maintaining; a whole redeclaration chain. This early approach simply skipped importing a; function prototype, but it imported a definition. To demonstrate the problem; with this approach let's consider an empty ""to"" context and the following; ``virtual`` function declarations of ``f`` in the ""from"" context:. .. code-block:: c+",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:93646,depend,dependent,93646,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['dependent']
Integrability,"cl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<VarDecl>isConstinit; Matches constinit variable declarations. Given:; constinit int foo = 42;; constinit const char* bar = ""bar"";; int baz = 42;; [[clang::require_constant_initialization]] int xyz = 42;; varDecl(isConstinit()); matches the declaration of `foo` and `bar`, but not `baz` and `xyz`. Matcher<VarDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<VarDecl>isExceptionVariable; Matches a variable declaration that is an exception variable from; a C++ catch block, or an Objective-C statement. Example matches x (matcher = varDecl(isExceptionVariable()); void f(int y) {; try {; } catch (int x) {; }; }. Matcher<VarDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<VarDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; ext",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:126471,interface,interface,126471,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['interface'],['interface']
Integrability,"clang - the Clang C, C++, and Objective-C compiler; ==================================================. SYNOPSIS; --------. :program:`clang` [*options*] *filename ...*. DESCRIPTION; -----------. :program:`clang` is a C, C++, and Objective-C compiler which encompasses; preprocessing, parsing, optimization, code generation, assembly, and linking.; Depending on which high-level mode setting is passed, Clang will stop before; doing a full link. While Clang is highly integrated, it is important to; understand the stages of compilation, to understand how to invoke it. These; stages are:. Driver; The clang executable is actually a small driver which controls the overall; execution of other tools such as the compiler, assembler and linker.; Typically you do not need to interact with the driver, but you; transparently use it to run the other tools. Preprocessing; This stage handles tokenization of the input source file, macro expansion,; #include expansion and handling of other preprocessor directives. The; output of this stage is typically called a "".i"" (for C), "".ii"" (for C++),; "".mi"" (for Objective-C), or "".mii"" (for Objective-C++) file. Parsing and Semantic Analysis; This stage parses the input file, translating preprocessor tokens into a; parse tree. Once in the form of a parse tree, it applies semantic; analysis to compute types for expressions as well and determine whether; the code is well formed. This stage is responsible for generating most of; the compiler warnings as well as parse errors. The output of this stage is; an ""Abstract Syntax Tree"" (AST). Code Generation and Optimization; This stage translates an AST into low-level intermediate code (known as; ""LLVM IR"") and ultimately to machine code. This phase is responsible for; optimizing the generated code and handling target-specific code generation.; The output of this stage is typically called a "".s"" file or ""assembly"" file. Clang also supports the use of an integrated assembler, in which the code; generator pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:467,integrat,integrated,467,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,1,['integrat'],['integrated']
Integrability,"clang-format` for NORMAL and VISUAL mode, the; second line adds support for INSERT mode. Change ""C-K"" to another binding if; you need :program:`clang-format` on a different key (C-K stands for Ctrl+k). With this integration you can press the bound key and clang-format will; format the current line in NORMAL and INSERT mode or the selected region in; VISUAL mode. The line or region is extended to the next bigger syntactic; entity. It operates on the current, potentially unsaved buffer and does not create; or save any files. To revert a formatting, just undo. An alternative option is to format changes when saving a file and thus to; have a zero-effort integration into the coding workflow. To do this, add this to; your `.vimrc`:. .. code-block:: vim. function! Formatonsave(); let l:formatdiff = 1; pyf <path-to-this-file>/clang-format.py; endfunction; autocmd BufWritePre *.h,*.cc,*.cpp call Formatonsave(). Emacs Integration; =================. Similar to the integration for :program:`vim`, there is an integration for; :program:`emacs`. It can be found at `clang/tools/clang-format/clang-format.el`; and used by adding this to your `.emacs`:. .. code-block:: common-lisp. (load ""<path-to-clang>/tools/clang-format/clang-format.el""); (global-set-key [C-M-tab] 'clang-format-region). This binds the function `clang-format-region` to C-M-tab, which then formats the; current line or selected region. BBEdit Integration; ==================. :program:`clang-format` cannot be used as a text filter with BBEdit, but works; well via a script. The AppleScript to do this integration can be found at; `clang/tools/clang-format/clang-format-bbedit.applescript`; place a copy in; `~/Library/Application Support/BBEdit/Scripts`, and edit the path within it to; point to your local copy of :program:`clang-format`. With this integration you can select the script from the Script menu and; :program:`clang-format` will format the selection. Note that you can rename the; menu item by renaming the script",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:8015,integrat,integration,8015,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,2,['integrat'],['integration']
Integrability,"clang`` (not ``ld``) for the final link step. When linking; shared libraries, the AddressSanitizer run-time is not linked, so; ``-Wl,-z,defs`` may cause link errors (don't use it with AddressSanitizer). To; get a reasonable performance add ``-O1`` or higher. To get nicer stack traces; in error messages add ``-fno-omit-frame-pointer``. To get perfect stack traces; you may need to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat example_UseAfterFree.cc; int main(int argc, char **argv) {; int *array = new int[100];; delete [] array;; return array[argc]; // BOOM; }. # Compile and link; % clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer example_UseAfterFree.cc. or:. .. code-block:: console. # Compile; % clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer -c example_UseAfterFree.cc; # Link; % clang++ -g -fsanitize=address example_UseAfterFree.o. If a bug is detected, the program will print an error message to stderr and; exit with a non-zero exit code. AddressSanitizer exits on the first detected error.; This is by design:. * This approach allows AddressSanitizer to produce faster and smaller generated code; (both by ~5%).; * Fixing bugs becomes unavoidable. AddressSanitizer does not produce; false alarms. Once a memory corruption occurs, the program is in an inconsistent; state, which could lead to confusing results and potentially misleading; subsequent reports. If your process is sandboxed and you are running on OS X 10.10 or earlier, you; will need to set ``DYLD_INSERT_LIBRARIES`` environment variable and point it to; the ASan library that is packaged with the compiler used to build the; executable. (You can find the library by searching for dynamic libraries with; ``asan`` in their name.) If the environment variable is not set, the process will; try to re-exec. Also keep in mind that when moving the executable to another machine,; the ASan library will also need to be copied",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:2384,message,message,2384,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['message'],['message']
Integrability,"claration of a namespace. Given; namespace {}; namespace test {}; namespaceDecl(); matches ""namespace {}"" and ""namespace test {}"". Matcher<Decl>nonTypeTemplateParmDeclMatcher<NonTypeTemplateParmDecl>...; Matches non-type template parameter declarations. Given; template <typename T, int N> struct C {};; nonTypeTemplateParmDecl(); matches 'N', but not 'T'. Matcher<Decl>objcCategoryDeclMatcher<ObjCCategoryDecl>...; Matches Objective-C category declarations. Example matches Foo (Additions); @interface Foo (Additions); @end. Matcher<Decl>objcCategoryImplDeclMatcher<ObjCCategoryImplDecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matches Objective-C instance variable declarations. Example matches _enabled; @implementation Foo {; BOOL _enabled;; }; @end. Matcher<Decl>objcMethodDeclMatcher<ObjCMethodDecl>...; Matches Objective-C method declarations. Example matches both declaration and definition of -[Foo method]; @interface Foo; - (void)method;; @end. @implementation Foo; - (void)method {}; @end. Matcher<Decl>objcPropertyDeclMatcher<ObjCPropertyDecl>...; Matches Objective-C property declarations. Example matches enabled; @interface Foo; @property BOOL enabled;; @end. Matcher<Decl>objcProtocolDeclMatcher<ObjCProtocolDecl>...; Matches Objective-C protocol declarations. Example matches FooDelegate; @protocol FooDelegate; @end. Matcher<Decl>parmVarDeclMatcher<ParmVarDecl>...; Matches parameter variable declarations. Given; void f(int x);; parmVarDecl(); matches int x. Matcher<Decl>recordDeclMatcher<RecordDecl>...; Matches class, struct, and uni",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:15601,interface,interface,15601,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['interface'],['interface']
Integrability,"class can scan the CLs+b values (default) or alternatively CLs (if the; method HypoTestInverter::UseCLs has been called).; The estimated error due to the MC toys statistics from the HybridCalculator is propagated into the limits obtained from the HypoTestResult; A new tutorial rs801_HypoTestInverter.C has been added in the tutorials/roostats directory to show the usage of this class. New class BayesianCalculator. New class for calculating Bayesian interval using numerical integration. It implements the IntervalCalculator interface and returns as result a SimpleInterval. . The BayesianCalculator::GetInterval() method returns a SimpleInterval which contains the lower and upper value of the bayesian interval obtained from the posterior probability for the given confidence level.; The class return also the posterior pdf (BayesianCalculator::GetPosteriorPdf()) obtained from integrating (marginalizing) on the nuisance parameters.; It works currently only for one-dimensional problems by relying on RooFit for performing analytical or numerical integration.; A plot of the posterior and the desired interval can be obtained using BayesianCalculator::GetPosteriorPlot().; A new tutorial rs701_BayesianCalculator.C has been added in the tutorials/roostats directory to show the usage of this class. MCMCCalculator. Add possibility to specify the prior function in the constructor of the class to have a signature similar to the BayesianCalculator class. When no prior is specified it is assumed is part of the global model (pdf) passed to the class. Improvements and Bug fixes. Various improvements and fixes have been applied also to all the calculator classes. Internally now the RooArgSet objects are used by value instead of a pointer.; All the calculator have a consistent way for being constructed, either by passing pdf pointers and the set defining the parameters or by passing a reference to a ModelConfig class.; The result classes are now more consistent and have similar constructors.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:16584,integrat,integration,16584,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,1,['integrat'],['integration']
Integrability,"classes for HEP numerical; computing. This is an extension of the functionality provided by the \ref MathCore. The; current set includes classes and functions for:. * \ref SpecFunc, with all the major functions (Bessel functions, Legendre polynomial, etc..); * \ref StatFunc, Mathematical functions used in statistics such as probability density; functions, cumulative distributions functions and their inverse (quantiles).; * Numerical algorithms:; * \ref Integration; * \ref MCIntegration; * \ref Deriv; * \ref RootFinders; * \ref Min1D; * \ref MultiMin; * \ref Interpolation; * \ref FuncApprox, based on Chebyshev polynomials; * \ref Random. The mathematical functions are implemented as a set of free functions in the namespace \em; ROOT::Math. The naming used for the special functions is the same proposed for the C++; standard (see C++ standard extension [proposal document](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1687.pdf)).; The MathMore library is implemented wrapping in C++ the GNU Scientific Library; ([GSL](http://www.gnu.org/software/gsl)). To build MathMore you need to have first GSL; installed somewhere in your system. A version of GSL larger or equal 1.8 is required. A tar; file of GSL can be downloaded from the [GSL Web site](http://www.gnu.org/software/gsl/#downloading),; or (for version 1.8) from [here](http://seal.web.cern.ch/seal/MathLibs/gsl-1.8.tar.gz).; Windows binaries, compiled using Visual Studio 7.1 can be downloaded from; [this location](http://seal.web.cern.ch/seal/MathLibs/GSL-1.8.zip). MathMore (and its %ROOT CINT dictionary) can be built within %ROOT whenever a GSL library; is found in the system. Optionally the GSL library and header file location can be specified; in the %ROOT configure script with _configure --with-gsl-incdir=... --with-gsl-libdir=..._; MathMore links with the GSL static libraries. On some platform (like Linux x86-64) GSL; needs to be compiled with the option _--with-pic_.; The source code of MathMore is distr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/doc/index.md:1186,wrap,wrapping,1186,math/mathmore/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/doc/index.md,1,['wrap'],['wrapping']
Integrability,"client takes care of setting up passwordless SSH from your client node; to the VAF master. ### Getting the credentials. > You can skip this paragraph if the remote server wasn't configured for; > HTTPS+SSH authentication. In our example we will assume that the remote server's name is; `cloud-gw-213.to.infn.it`: substitute it with your remote endpoint. First, check that you have your Grid certificate and private key; installed both in your browser and in the home directory of your; client. Point your browser to `https://cloud-gw-213.to.infn.it/auth/`: you'll; probably be asked for a certificate to choose for authentication. Pick; one and you'll be presented with the following web page:. ![Web authentication with sshcertauth](img/sshcertauth-web.png). The webpage clearly explains you what to do next. ### Customizing user's configuration. Before entering the VAF environment, you should customize the user's; configuration. How to do so depends on your experiment, but usually you; should essentially specify the version of the experiment's software you; need. For instance, in the CMS use case, only one file is needed:; `~/.vaf/common.before`, which contains something like:. ``` {.bash}; # Version of CMSSW (as reported by ""scram list""); export VafCmsswVersion='CMSSW_5_3_9_sherpa2beta2'; ```. ### Entering the VAF environment. Open a terminal on your client machine (can be either your local; computer or a remote user interface) and type:. vaf-enter <username>@cloud-gw-213.to.infn.it. You'll substitute `<username>` with the username that either your system; administrator or the web authentication (if you used it) provided you. You'll be presented with a neat shell which looks like the following:. Entering VAF environment: dberzano@cloud-gw-213.to.infn.it; Remember: you are still in a shell on your local computer!; pod://dberzano@cloud-gw-213.to.infn.it [~] >. This shell runs on your local computer and it has the environment; properly set up. PoD and PROOF workflow; -----------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:9298,depend,depends,9298,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['depend'],['depends']
Integrability,"cluding Darwin. .. option:: -f[no-]trapping-math. Control floating point exception behavior. ``-fno-trapping-math`` allows optimizations that assume that floating point operations cannot generate traps such as divide-by-zero, overflow and underflow. - The option ``-ftrapping-math`` behaves identically to ``-ffp-exception-behavior=strict``.; - The option ``-fno-trapping-math`` behaves identically to ``-ffp-exception-behavior=ignore``. This is the default. .. option:: -ffp-contract=<value>. Specify when the compiler is permitted to form fused floating-point; operations, such as fused multiply-add (FMA). Fused operations are; permitted to produce more precise results than performing the same; operations separately. The C standard permits intermediate floating-point results within an; expression to be computed with more precision than their type would; normally allow. This permits operation fusing, and Clang takes advantage; of this by default. This behavior can be controlled with the ``FP_CONTRACT``; and ``clang fp contract`` pragmas. Please refer to the pragma documentation; for a description of how the pragmas interact with this option. Valid values are:. * ``fast`` (fuse across statements disregarding pragmas, default for CUDA); * ``on`` (fuse in the same statement unless dictated by pragmas, default for languages other than CUDA/HIP); * ``off`` (never fuse); * ``fast-honor-pragmas`` (fuse across statements unless dictated by pragmas, default for HIP). .. option:: -f[no-]honor-infinities. Allow floating-point optimizations that assume arguments and results are; not +-Inf.; Defaults to ``-fhonor-infinities``. If both ``-fno-honor-infinities`` and ``-fno-honor-nans`` are used,; has the same effect as specifying ``-ffinite-math-only``. .. option:: -f[no-]honor-nans. Allow floating-point optimizations that assume arguments and results are; not NaNs.; Defaults to ``-fhonor-nans``. If both ``-fno-honor-infinities`` and ``-fno-honor-nans`` are used,; has the same effect as ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:57263,contract,contract,57263,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['contract'],['contract']
Integrability,"code-name=ADD64rr. The output is a YAML document (the default is to write to stdout, but you can; redirect the output to a file using `--benchmarks-file`):. .. code-block:: none. ---; key:; opcode_name: ADD64rr; mode: latency; config: ''; cpu_name: haswell; llvm_triple: x86_64-unknown-linux-gnu; num_repetitions: 10000; measurements:; - { key: latency, value: 1.0058, debug_string: '' }; error: ''; info: 'explicit self cycles, selecting one aliasing configuration.; Snippet:; ADD64rr R8, R8, R10; '; ... To measure the latency of all instructions for the host architecture, run:. .. code-block:: bash. $ llvm-exegesis --mode=latency --opcode-index=-1. EXAMPLE 2: benchmarking a custom code snippet; ---------------------------------------------. To measure the latency/uops of a custom piece of code, you can specify the; `snippets-file` option (`-` reads from standard input). .. code-block:: bash. $ echo ""vzeroupper"" | llvm-exegesis --mode=uops --snippets-file=-. Real-life code snippets typically depend on registers or memory.; :program:`llvm-exegesis` checks the liveliness of registers (i.e. any register; use has a corresponding def or is a ""live in""). If your code depends on the; value of some registers, you need to use snippet annotations to ensure setup; is performed properly. For example, the following code snippet depends on the values of XMM1 (which; will be set by the tool) and the memory buffer passed in RDI (live in). .. code-block:: none. # LLVM-EXEGESIS-LIVEIN RDI; # LLVM-EXEGESIS-DEFREG XMM1 42; vmulps	(%rdi), %xmm1, %xmm2; vhaddps	%xmm2, %xmm2, %xmm3; addq $0x10, %rdi. Example 3: benchmarking with memory annotations; -----------------------------------------------. Some snippets require memory setup in specific places to execute without; crashing. Setting up memory can be accomplished with the `LLVM-EXEGESIS-MEM-DEF`; and `LLVM-EXEGESIS-MEM-MAP` annotations. To execute the following snippet:. .. code-block:: none. movq $8192, %rax; movq (%rax), %rdi. We need to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:6169,depend,depend,6169,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,1,['depend'],['depend']
Integrability,"collapsed; list of options, is chosen so that the IR encoding can use multiple option; strings to specify e.g., a single library, while still having that specifier be; preserved as an atomic element that can be recognized by a target specific; assembly writer or object file emitter. Each individual option is required to be either a valid option for the target's; linker, or an option that is reserved by the target specific assembly writer or; object file emitter. No other aspect of these options is defined by the IR. Dependent Libs Named Metadata; =============================. Some targets support embedding of strings into object files to indicate; a set of libraries to add to the link. Typically this is used in conjunction; with language extensions which allow source files to explicitly declare the; libraries they depend on, and have these automatically be transmitted to the; linker via object files. The list is encoded in the IR using named metadata with the name; ``!llvm.dependent-libraries``. Each operand is expected to be a metadata node; which should contain a single string operand. For example, the following metadata section contains two library specifiers::. !0 = !{!""a library specifier""}; !1 = !{!""another library specifier""}; !llvm.dependent-libraries = !{ !0, !1 }. Each library specifier will be handled independently by the consuming linker.; The effect of the library specifiers are defined by the consuming linker. .. _summary:. ThinLTO Summary; ===============. Compiling with `ThinLTO <https://clang.llvm.org/docs/ThinLTO.html>`_; causes the building of a compact summary of the module that is emitted into; the bitcode. The summary is emitted into the LLVM assembly and identified; in syntax by a caret ('``^``'). The summary is parsed into a bitcode output, along with the Module; IR, via the ""``llvm-as``"" tool. Tools that parse the Module IR for the purposes; of optimization (e.g. ""``clang -x ir``"" and ""``opt``""), will ignore the; summary entries (just as th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:338152,depend,dependent-libraries,338152,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependent-libraries']
Integrability,"column names in the RDataFrame object is now also; usable from a node of a distributed computation graph. This makes the generation of said computation graph slightly; less lazy than before. Notably, it used to be the case that a distributed computation graph could be defined with; code that was not yet available on the user's local application, but that would only become available in the; distributed worker. Now a call such as `df.Define(""mycol"", ""return run_my_fun();"")` needs to be at least declarable; to the interpreter also locally so that the column can be properly tracked. ## Histogram Libraries. ### Upgrade TUnfold to version 17.9. The [TUnfold package](https://www.desy.de/~sschmitt/tunfold.html) inside ROOT is upgraded from version 17.6 to version 17.9. ## Math Libraries. ### Usage of `std::span<const double>` in Minuit 2 interfaces. To avoid forcing the user to do manual memory allocations via `std::vector`, the interfaces of Minuit 2 function adapter classes like `ROOT::Minuit2::FCNBase` or `ROOT::Minuit2::FCNGradientBase` were changed to accept `std::span<const double>` arguments instead of `std::vector<double> const&`.; This should have minimal impact on users, since one should usual use Minuit 2 via the `ROOT::Math::Minimizer` interface, which is unchanged. ## RooFit Libraries. ### Miscellaneous. * Setting `useHashMapForFind(true)` is not supported for RooArgLists anymore, since hash-assisted finding by name hash can be ambiguous: a RooArgList is allowed to have different elements with the same name. If you want to do fast lookups by name, convert your RooArgList to a RooArgSet. * The function `RooFit::bindFunction()` now supports arbitrary many input variables when binding a Python function. * The `ExportOnly()` attribute of the `RooStats::HistFactory::Measurement` object is now switched on by default, and the associated getter and setter functions are deprecated. They will be removed in ROOT 6.36. If you want to fit the model as well instead of just ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md:4342,interface,interfaces,4342,README/ReleaseNotes/v634/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md,2,"['adapter', 'interface']","['adapter', 'interfaces']"
Integrability,"column numbers, includes 'caret diagnostics', and they; highlight regions of interesting code (e.g. the LHS and RHS of a binop).; * Full diagnostic customization by client (can format diagnostics however they; like, e.g. in an IDE or refactoring tool) through DiagnosticClient interface.; * Built as a framework, can be reused by multiple tools.; * All languages supported linked into same library (no cc1,cc1obj, ...).; * mmap's code in read-only, does not dirty the pages like GCC (mem footprint).; * LLVM License, can be linked into non-GPL projects.; * Full diagnostic control, per diagnostic. Diagnostics are identified by ID.; * Significantly faster than GCC at semantic analysis, parsing, preprocessing; and lexing.; * Defers exposing platform-specific stuff to as late as possible, tracks use of; platform-specific features (e.g. #ifdef PPC) to allow 'portable bytecodes'.; * The lexer doesn't rely on the ""lexer hack"": it has no notion of scope and; does not categorize identifiers as types or variables -- this is up to the; parser to decide. Potential Future Features:. * Fine grained diag control within the source (#pragma enable/disable warning).; * Better token tracking within macros? (Token came from this line, which is; a macro argument instantiated here, recursively instantiated here).; * Fast #import with a module system.; * Dependency tracking: change to header file doesn't recompile every function; that texually depends on it: recompile only those functions that need it.; This is aka 'incremental parsing'. IV. Missing Functionality / Improvements. Lexer:; * Source character mapping. GCC supports ASCII and UTF-8.; See GCC options: -ftarget-charset and -ftarget-wide-charset.; * Universal character support. Experimental in GCC, enabled with; -fextended-identifiers.; * -fpreprocessed mode. Preprocessor:; * #assert/#unassert; * MSExtension: ""L#param"" stringizes to a wide string literal.; * Add support for -M*. Traditional Preprocessor:; * Currently, we have none. :). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt:7164,depend,depends,7164,interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,1,['depend'],['depends']
Integrability,"com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests); model of github. A pull request (PR) should contain a set focused changes; organized in one or more [atomic commits](https://en.wikipedia.org/wiki/Atomic_commit#Revision_control).; PRs should be well-documented and well-tested in order to allow other community; members to use, maintain and modify. If the PR contains performance-critical; code consider writing a benchmark against the [rootbench repository](https://github.com/root-project/rootbench). ## Quality Assurance. Each contribution should contain developer documentation in the form of code; comments and sufficient amount of tests in the form of unit and/or integration; tests. Unit tests are relatively small and quick programs focused to check if; small pieces of code and API work as expected. Integration tests are checks; which ensure the synergy between different (unit tested) components. Put in; practice, unit tests verify (member) function behavior whereas integration tests; check classes and their cooperation. The boundary between both kinds of testing; is blurred. ROOT has support for both kinds of tests in the [roottest repository](https://github.com/root-project/roottest); and supports ""inline"" unit tests in each component's `test` folder. Unit testing; uses the [GTest and GMock](https://github.com/google/googletest) infrastructure; along with small ROOT-specific extensions located in; [TestSupport](../core/test_support/). The documentation of GTest; and GMock is rather extensive and we will describe some of the features of; ROOT::TestSupport. In order to write an inline unit test, add a new file in the; nearest to the tested component's `test` folder and call `ROOT_ADD_GTEST` in the; `CMakeLists.txt` file. In many cases using standard GTest facility is sufficient to write a good test.; However, we disallow error messages in gtests, or sometimes we want to test the; error conditions of an interface and its diagnostics. For ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/DEVELOPMENT.md:1147,integrat,integration,1147,README/DEVELOPMENT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/DEVELOPMENT.md,1,['integrat'],['integration']
Integrability,"com/pdd-dibg-cwv>`__; - English. Guidance for office hours hosts; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * If you're interested in becoming an office hours host, please add your; information to the list above. Please create a calendar event for it and; invite calendar@llvm.org to the event so that it'll show up on the; :ref:`llvm-community-calendar`.; Please see :ref:`llvm-community-calendar-host-guidance` for more guidance on; what to add to your calendar invite.; * When starting an office hours session, consider typing something like ""*Hi,; I'm available for chats in the next half hour at* video chat URL. *I'm; looking forward to having conversations on the video chat or here.*"" on the; LLVM chat channels that you are already on. These could include:. * the `#office-hours Discord channel; <https://discord.com/channels/636084430946959380/976196303681896538>`__.; * :ref:`IRC`. Doing this can help:; * overcome potential anxiety to call in for a first time,; * people who prefer to first exchange a few messages through text chat; before dialing in, and; * remind the wider community that office hours do exist.; * If you decide to no longer host office hours, please do remove your entry; from the list above. .. _IRC:. IRC; ---. Users and developers of the LLVM project (including subprojects such as Clang); can be found in #llvm on `irc.oftc.net <irc://irc.oftc.net/llvm>`_. The channel; is actively moderated. The #llvm-build channel has a bot for; `LLVM buildbot <http://lab.llvm.org/buildbot/#/console>`_ status changes. The; bot will post a message with a link to a build bot and a blamelist when a build; goes from passing to failing and again (without the blamelist) when the build; goes from failing back to passing. It is a good channel for actively monitoring; build statuses, but it is a noisy channel due to the automated messages. The; channel is not actively moderated. In addition to the traditional IRC there is a; `Discord <https://discord.com/channels/636084430946959380/63",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:16637,message,messages,16637,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['message'],['messages']
Integrability,"comment; to the correct declaration. Avoid:. .. code-block:: c++. // Example.h:. // example - Does something important.; void example();. // Example.cpp:. // example - Does something important.; void example() { ... }. Preferred:. .. code-block:: c++. // Example.h:. /// Does something important.; void example();. // Example.cpp:. /// Builds a B-tree in order to do foo. See paper by...; void example() { ... }. Error and Warning Messages; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Clear diagnostic messages are important to help users identify and fix issues in; their inputs. Use succinct but correct English prose that gives the user the; context needed to understand what went wrong. Also, to match error message; styles commonly produced by other tools, start the first sentence with a; lower-case letter, and finish the last sentence without a period, if it would; end in one otherwise. Sentences which end with different punctuation, such as; ""did you forget ';'?"", should still do so. For example this is a good error message:. .. code-block:: none. error: file.o: section header 3 is corrupt. Size is 10 when it should be 20. This is a bad message, since it does not provide useful information and uses the; wrong style:. .. code-block:: none. error: file.o: Corrupt section header. As with other coding standards, individual projects, such as the Clang Static; Analyzer, may have preexisting styles that do not conform to this. If a; different formatting scheme is used consistently throughout the project, use; that style instead. Otherwise, this standard applies to all LLVM tools,; including clang, clang-tidy, and so on. If the tool or project does not have existing functions to emit warnings or; errors, use the error and warning handlers provided in ``Support/WithColor.h``; to ensure they are printed in the appropriate style, rather than printing to; stderr directly. When using ``report_fatal_error``, follow the same standards for the message as; regular error messages. Assertion messages and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:14567,message,message,14567,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['message'],['message']
Integrability,"compilation database; from the ``compile_commands.json`` file, generated by CMake. When; invoking clang tools, you can either specify a path to a build directory; using a command line parameter ``-p`` or let Clang Tooling find this; file in your source tree. In either case you need to configure your; build using CMake to use clang tools. Setup Clang Tooling Using CMake and Make; ========================================. If you intend to use make to build LLVM, you should have CMake 2.8.6 or; later installed (can be found `here <https://cmake.org>`_). First, you need to generate Makefiles for LLVM with CMake. You need to; make a build directory and run CMake from it:. .. code-block:: console. $ mkdir your/build/directory; $ cd your/build/directory; $ cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. If you want to use clang instead of GCC, you can add; ``-DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using make:. .. code-block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, the Visual Studio project generators in CMake do; not support `CMAKE_EXPORT_COMPILE_COMMANDS; <https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html>`_.; However, the Ninja generator does support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:1588,interface,interface,1588,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,1,['interface'],['interface']
Integrability,"compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DATA_SOURCE_DIR=<path to llvm-test-suite> \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DEPS=runtimes. The BOOTSTRAP\_ prefixes tells CMake to pass the variables on to the instrumented; stage two build. And the CLANG_PGO_TRAINING_DEPS option let's you specify; additional build targets to build before building the external project. The; LLVM Test Suite requires compiler-rt to build, so we need to add the; `runtimes` target as a dependency. After configuration, building the stage2-instrumented-generate-profdata target; will automatically build the stage1 compiler, build the instrumented compiler; with the stage1 compiler, and then run the instrumented compiler against the; perf training data:. .. code-block:: console. $ ninja stage2-instrumented-generate-profdata. If you let that run for a few hours or so, it will place a profdata file in your; build directory. This takes a really long time because it builds clang twice,; and you *must* have compiler-rt in your build tree. This process uses any source files under the perf-training directory as training; data as long as the source files are marked up with LIT-style RUN lines. After it finishes you can use :code:`find . -name clang.profdata` to find it, but it; should be at a path something like:. .. code-block:: console. <build dir>/tools/clang/stage2-instrumented-bins/utils/perf-training/clang.profdata. You can feed ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:7288,depend,dependency,7288,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['depend'],['dependency']
Integrability,"config: ''; cpu_name: haswell; llvm_triple: x86_64-unknown-linux-gnu; num_repetitions: 10000; measurements:; - { key: latency, value: 1.0058, debug_string: '' }; error: ''; info: 'explicit self cycles, selecting one aliasing configuration.; Snippet:; ADD64rr R8, R8, R10; '; ... To measure the latency of all instructions for the host architecture, run:. .. code-block:: bash. $ llvm-exegesis --mode=latency --opcode-index=-1. EXAMPLE 2: benchmarking a custom code snippet; ---------------------------------------------. To measure the latency/uops of a custom piece of code, you can specify the; `snippets-file` option (`-` reads from standard input). .. code-block:: bash. $ echo ""vzeroupper"" | llvm-exegesis --mode=uops --snippets-file=-. Real-life code snippets typically depend on registers or memory.; :program:`llvm-exegesis` checks the liveliness of registers (i.e. any register; use has a corresponding def or is a ""live in""). If your code depends on the; value of some registers, you need to use snippet annotations to ensure setup; is performed properly. For example, the following code snippet depends on the values of XMM1 (which; will be set by the tool) and the memory buffer passed in RDI (live in). .. code-block:: none. # LLVM-EXEGESIS-LIVEIN RDI; # LLVM-EXEGESIS-DEFREG XMM1 42; vmulps	(%rdi), %xmm1, %xmm2; vhaddps	%xmm2, %xmm2, %xmm3; addq $0x10, %rdi. Example 3: benchmarking with memory annotations; -----------------------------------------------. Some snippets require memory setup in specific places to execute without; crashing. Setting up memory can be accomplished with the `LLVM-EXEGESIS-MEM-DEF`; and `LLVM-EXEGESIS-MEM-MAP` annotations. To execute the following snippet:. .. code-block:: none. movq $8192, %rax; movq (%rax), %rdi. We need to have at least eight bytes of memory allocated starting `0x2000`.; We can create the necessary execution environment with the following; annotations added to the snippet:. .. code-block:: none. # LLVM-EXEGESIS-MEM-DEF test1 409",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:6342,depend,depends,6342,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,1,['depend'],['depends']
Integrability,"considered to be platform agnostic.; LLVM source files may include them or obtain their inclusion through; ``lib/Support`` interfaces. High Level Interface; --------------------. The entry points specified in the interface of ``lib/Support`` must be aimed at; completing some reasonably high level task needed by LLVM. We do not want to; simply wrap each operating system call. It would be preferable to wrap several; operating system calls that are always used in conjunction with one another by; LLVM. For example, consider what is needed to execute a program, wait for it to; complete, and return its result code. On Unix, this involves the following; operating system calls: ``getenv``, ``fork``, ``execve``, and ``wait``. The; correct thing for ``lib/Support`` to provide is a function, say; ``ExecuteProgramAndWait``, that implements the functionality completely. what; we don't want is wrappers for the operating system calls involved. There must **not** be a one-to-one relationship between operating system; calls and the Support library's interface. Any such interface function will be; suspicious. No Unused Functionality; -----------------------. There must be no functionality specified in the interface of ``lib/Support``; that isn't actually used by LLVM. We're not writing a general purpose operating; system wrapper here, just enough to satisfy LLVM's needs. And, LLVM doesn't; need much. This design goal aims to keep the ``lib/Support`` interface small and; understandable which should foster its actual use and adoption. No Duplicate Implementations; ----------------------------. The implementation of a function for a given platform must be written exactly; once. This implies that it must be possible to apply a function's; implementation to multiple operating systems if those operating systems can; share the same implementation. This rule applies to the set of operating; systems supported for a given class of operating system (e.g. Unix, Win32). No Virtual Methods; -------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:4810,interface,interface,4810,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interface']
Integrability,"constant parameter flag in the; `RooStats:HistFactory::NormFactor` class had no effect as well. To avoid; ambiguity in the future, the possibility to set and retrieve this flag with; `NormFactor::SetConst()` and `NormFactor::GetConst()` was removed, as well as the; `Sample::AddNormFactor(std::string Name, double Val, double Low, double High, bool Const)`; overload. Also, the aforementioned deprecation warning is not printed anymore. ### Removal of `RooAbsMinimizerFcn` and `RooMinimizerFcn` from the public interface. The `RooAbsMinimizerFcn` class and its implementation `RooMinimizerFcn` were removed from the public interface.; These classes are implementation details of the RooMinimizer and should not be used in your code.; In the unlikely case that this causes any problem for you, please open a GitHub issue requesting to extend the RooMinimizer by the needed functionality. ### Vectorize `RooAbsBinning` interface for bin index lookups. The `RooAbsBinning` interface for bin index lookups was changed to enable vectorized implementations.; Instead of having the override `RooAbsBinning::binNumber()`, the binning implementations now have to override the `RooAbsBinning::binNumbers()` function to evaluate the bin indices of multiple values in one function call. ### Disable relative and absolute epsilon in `RooAbsRealLValue::inRange()`. So far, the `RooAbsRealLValue::inRange()` function used the following; undocumented convention to check whether a value `x` is in the range with; limits `a` and `b`: test if `[x - eps * x, x + eps * x]` overlaps with `[a, b]`, where the; parameter `eps` is defined as `max(epsRel * x, epsAbs)`. The values of the relative and absolute epsilons were inconsistent among the overloads:. * [RooAbsRealLValue::inRange(const char* rangeName)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#ab6050a0c3e5583b9d755a38fd7fb82f7): `epsRel = 1e-8, epsAbs = 0`; * [RooAbsRealLValue::inRange(double value, const char* rangeName, double* clippedValPtr)](",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:24662,interface,interface,24662,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['interface'],['interface']
Integrability,"content}""); configure_file(""${CMAKE_BINARY_DIR}/include/module.modulemap.extra.tmp""; ""${CMAKE_BINARY_DIR}/include/module.modulemap.extra""; COPYONLY). # From now on we handled all exposed module and want to make all new modulemaps private to ROOT.; set(ROOT_CXXMODULES_WRITE_TO_CURRENT_DIR ON). set (CMAKE_CXX_FLAGS_SEPARATE ""${CMAKE_CXX_FLAGS}""). string(REGEX REPLACE ""[ ]-"" "";-"" CMAKE_CXX_FLAGS_SEPARATE ""${CMAKE_CXX_FLAGS_SEPARATE}""); if(MSVC); string(REPLACE ""-Zc:__cplusplus"" """" CMAKE_CXX_FLAGS_SEPARATE ""${CMAKE_CXX_FLAGS_SEPARATE}""); string(REPLACE ""-nologo"" """" CMAKE_CXX_FLAGS_SEPARATE ""${CMAKE_CXX_FLAGS_SEPARATE}""); string(REPLACE ""-EHsc-"" """" CMAKE_CXX_FLAGS_SEPARATE ""${CMAKE_CXX_FLAGS_SEPARATE}""); string(REPLACE ""-GR"" """" CMAKE_CXX_FLAGS_SEPARATE ""${CMAKE_CXX_FLAGS_SEPARATE}""); string(REPLACE ""-MDd"" """" CMAKE_CXX_FLAGS_SEPARATE ""${CMAKE_CXX_FLAGS_SEPARATE}""); endif(). if(runtime_cxxmodules); # Dummy target that does nothing, we don't need a PCH for modules.; # Onepcm target has all dependencies needed for allDict.cxx.pch, which allow; # to test hsimple.C after all C++ modules are updated.; add_custom_target(onepcm); foreach(target_dependency ${ROOT_LIBRARY_TARGETS}); add_dependencies(onepcm ${target_dependency}); endforeach(); unset(ROOT_LIBRARY_TARGETS CACHE); else(); get_property(incdirs DIRECTORY PROPERTY INCLUDE_DIRECTORIES). if(WIN32); list(APPEND incdirs; ${CMAKE_SOURCE_DIR}/graf2d/win32gdk/gdk/src; ${CMAKE_SOURCE_DIR}/graf2d/win32gdk/gdk/src/gdk; ${CMAKE_SOURCE_DIR}/graf2d/win32gdk/gdk/src/glib; ); endif(). foreach(d ${incdirs}); if(NOT ""${d}"" MATCHES ""AFTER|BEFORE|INTERFACE|PRIVATE|PUBLIC|SYSTEM""); set(__allIncludes ${__allIncludes} -I${d}); endif(); endforeach(). get_property(__cling_pch GLOBAL PROPERTY CLINGETCPCH); get_property(__pch_dependencies GLOBAL PROPERTY ROOT_PCH_DEPENDENCIES); get_property(__pch_dictionaries GLOBAL PROPERTY ROOT_PCH_DICTIONARIES). add_custom_command(OUTPUT etc/allDict.cxx.pch; BYPRODUCTS; etc/dictpch/allCppflags.txt; etc/dictpch/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:19409,depend,dependencies,19409,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,1,['depend'],['dependencies']
Integrability,"continuation lowering, ``llvm.coro.end`` fully destroys the; coroutine frame. If the second argument is `false`, it also returns from; the coroutine with a null continuation pointer, and the next instruction; will be unreachable. If the second argument is `true`, it falls through; so that the following logic can resume unwinding. In a yield-once; coroutine, reaching a non-unwind ``llvm.coro.end`` without having first; reached a ``llvm.coro.suspend.retcon`` has undefined behavior. The remainder of this section describes the behavior under switched-resume; lowering. This intrinsic is lowered when a coroutine is split into; the start, resume and destroy parts. In the start part, it is a no-op,; in resume and destroy parts, it is replaced with `ret void` instruction and; the rest of the block containing `coro.end` instruction is discarded.; In landing pads it is replaced with an appropriate instruction to unwind to; caller. The handling of coro.end differs depending on whether the target is; using landingpad or WinEH exception model. For landingpad based exception model, it is expected that frontend uses the; `coro.end`_ intrinsic as follows:. .. code-block:: llvm. ehcleanup:; %InResumePart = call i1 @llvm.coro.end(ptr null, i1 true, token none); br i1 %InResumePart, label %eh.resume, label %cleanup.cont. cleanup.cont:; ; rest of the cleanup. eh.resume:; %exn = load ptr, ptr %exn.slot, align 8; %sel = load i32, ptr %ehselector.slot, align 4; %lpad.val = insertvalue { ptr, i32 } undef, ptr %exn, 0; %lpad.val29 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1; resume { ptr, i32 } %lpad.val29. The `CoroSpit` pass replaces `coro.end` with ``True`` in the resume functions,; thus leading to immediate unwind to the caller, whereas in start function it; is replaced with ``False``, thus allowing to proceed to the rest of the cleanup; code that is only needed during initial invocation of the coroutine. For Windows Exception handling model, a frontend should attach a funclet bund",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:44560,depend,depending,44560,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['depend'],['depending']
Integrability,"contributions. This policy covers all llvm.org subprojects, including Clang,; LLDB, libc++, etc. This policy is also designed to accomplish the following objectives:. #. Attract both users and developers to the LLVM project. #. Make life as simple and easy for contributors as possible. #. Keep the top of tree as stable as possible. #. Establish awareness of the project's :ref:`copyright, license, and patent; policies <copyright-license-patents>` with contributors to the project. This policy is aimed at frequent contributors to LLVM. People interested in; contributing one-off patches can do so in an informal way by sending them to the; `llvm-commits mailing list; <http://lists.llvm.org/mailman/listinfo/llvm-commits>`_ and engaging another; developer to see it through the process. Developer Policies; ==================. This section contains policies that pertain to frequent LLVM developers. We; always welcome `one-off patches`_ from people who do not routinely contribute to; LLVM, but we expect more from frequent contributors to keep the system as; efficient as possible for everyone. Frequent LLVM contributors are expected to; meet the following requirements in order for LLVM to maintain a high standard of; quality. Stay Informed; -------------. Developers should stay informed by reading the `LLVM Discourse forums`_ and subscribing; to the categories of interest for notifications. Paying attention to changes being made by others is a good way to see what other people; are interested in and watching the flow of the project as a whole. Contibutions to the project are made through :ref:`GitHub Pull Requests <github-reviews>`.; You can subscribe to notification for areas of the codebase by joining; one of the `pr-subscribers-* <https://github.com/orgs/llvm/teams?query=pr-subscribers>`_; GitHub teams. This `mapping <https://github.com/llvm/llvm-project/blob/main/.github/new-prs-labeler.yml>`_; indicates which team is associated with a particular paths in the repository. Yo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:1484,rout,routinely,1484,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['rout'],['routinely']
Integrability,"cppyy-backend; =============. A repackaging of Cling, the interactive C++ interpreter, including a version; of LLVM patched for interactive use, and C/C++ wrappers that expose no further; external headers or types. Cling documentation is here:; https://root.cern.ch/cling. ----. Find the cppyy documentation here:; http://cppyy.readthedocs.io/. Please report bugs in the `cppyy issue tracker <https://bitbucket.org/wlav/cppyy/issues>`_.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/README.rst:155,wrap,wrappers,155,bindings/pyroot/cppyy/cppyy-backend/README.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/README.rst,1,['wrap'],['wrappers']
Integrability,"cppyy-backend; =============. C/C++ wrapper around Cling, the LLVM-based interactive C++ interpreter, for; use by cppyy, providing stable C and C++ Reflection APIs. The compilation of cppyy-backend is very fast, but it will pull in; cppyy-cling, which takes a long time to install if there is no matching wheel; for your platform, forcing a build from source. By default, all cores will be; used, but it is also recommended to add the verbose flag to see progress:. $ python -m pip install --verbose cppyy-backend. For further details, see cppyy's installation instructions:; https://cppyy.readthedocs.io/en/latest/installation.html. Cling documentation is here:; https://root.cern.ch/cling. ----. Find the cppyy documentation here:; http://cppyy.readthedocs.io. Change log:; https://cppyy.readthedocs.io/en/latest/changelog.html. Bug reports/feedback:; https://bitbucket.org/wlav/cppyy/issues?status=new&status=open; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/README.rst:36,wrap,wrapper,36,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/README.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/README.rst,1,['wrap'],['wrapper']
Integrability,"cpp}; enum EObjBits {; kCanDelete = BIT(0), // if can be deleted; kMustCleanup = BIT(3), // if destructor must call RecursiveRemove(); kObjInCanvas = BIT(3), // for backward compatibility only; kIsReferenced = BIT(4), // if referenced by TRef or TRefArray; kHasUUID = BIT(5), // if has a TUUID, fUniqueID=UUIDNumber; kCannotPick = BIT(6), // if cannot be picked in a pad; kNoContextMenu = BIT(8), // if does not want a context menu; kInvalidObject = BIT(13) // object ctor succeeded but the object should not be used; };; ```. For example, the bits `kMustCleanup` and `kCanDelete` are used in; **`TObject`**. See ""The kCanDelete Bit"" and ""The kMustCleanup Bit"". They; can be set by any object and should not be reused. Make sure not; to overlap them in any given hierarchy. The bit 13 (`kInvalidObject`) is; set when an object could not be read from a ROOT file. It will check; this bit and will skip to the next object on the file. The **`TObject`** constructor initializes the `fBits` to zero depending; if the object is created on the stack or allocated on the heap. When the; object is created on the stack, the `kCanDelete` bit is set to false to; protect from deleting objects on the stack. The high 8 bits are reserved; for the system usage; the low 24 bits are user settable. `fUniqueID` is; a data member used to give a unique identification number to an object.; It is initialized to zero by the **`TObject`** constructor. ROOT does; not use this data member. The two data members (`fBits` and `fUniqueID`); are streamed out when writing an object to disk. If you do not use them,; you can save some space and time by specifying:. ``` {.cpp}; MyClass::Class()->IgnoreTObjectStreamer();; ```. This sets a bit in the **`TClass`** object. If the file is compressed,; the savings are minimal since most values are zero; however, it saves; some space when the file is not compressed. A call; to` IgnoreTObjectStreamer` also prevents the creation of two additional; branches when splitting the obj",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:6650,depend,depending,6650,documentation/users-guide/AddingaClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md,1,['depend'],['depending']
Integrability,"create `RooAbsL` based likelihood objects from a pdf and dataset, in this example a `RooUnbinnedL` type:; ``` {.cpp}; RooAbsPdf *pdf;; RooDataSet *data;; std::tie(pdf, data) = generate_some_unbinned_pdf_and_dataset(with, some, parameters);. RooFit::TestStatistics::RooUnbinnedL likelihood(pdf, data);; ```. However, most of the time, the user will not need **or want** such direct control over the type, but rather just let RooFit figure out what exact likelihood type (`RooAbsL` derived class) is best.; For this situation, the `buildLikelihood` function was created that can be used (for instance) as:; ``` {.cpp}; std::shared_ptr<RooFit::TestStatistics::RooAbsL> likelihood = RooFit::TestStatistics::buildLikelihood(pdf, data);; ```; `buildLikelihood` actually returns a `unique_ptr`; storing the result in a `shared_ptr` as done here is just one possible use-case. ### Usage example: Create a likelihood of a simultaneous PDF with constraint terms and global observables (and other optional arguments); The `RooAbsPdf::fitTo` or `RooAbsPdf::createNLL` interfaces could take in a set of optional parameters as `RooCmdArg` objects.; In `TestStatistics::buildLikelihood`, we have implemented 4 of these options as separate types while an additional one is supported as a simple string:; - `RooAbsL::Extended`: an enum class used to set extended term calculation `on`, `off` or use `Extended::Auto` to determine automatically based on the pdf whether to activate or not.; - `ConstrainedParameters`: Initialized with a `RooArgSet` of parameters that are constrained. Pdf components dependent on these alone are added to a subsidiary likelihood term.; - `ExternalConstraints`: Initialized with a `RooArgSet` of external constraint pdfs, i.e. constraints not necessarily in the pdf itself. These are always added to the subsidiary likelihood.; - `GlobalObservables`: Initialized with a `RooArgSet` of observables that have a constant value, independent of the dataset events. Pdf components dependent on ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md:3494,interface,interfaces,3494,roofit/doc/developers/test_statistics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md,1,['interface'],['interfaces']
Integrability,create_subdirectory_options(CLANG TOOL). add_clang_subdirectory(diagtool); add_clang_subdirectory(driver); add_clang_subdirectory(apinotes-test); add_clang_subdirectory(clang-diff); add_clang_subdirectory(clang-format); add_clang_subdirectory(clang-format-vs); add_clang_subdirectory(clang-fuzzer); add_clang_subdirectory(clang-import-test); add_clang_subdirectory(clang-linker-wrapper); add_clang_subdirectory(clang-offload-packager); add_clang_subdirectory(clang-offload-bundler); add_clang_subdirectory(clang-scan-deps); if(HAVE_CLANG_REPL_SUPPORT); add_clang_subdirectory(clang-repl); endif(). add_clang_subdirectory(c-index-test). add_clang_subdirectory(clang-rename); add_clang_subdirectory(clang-refactor); # For MinGW we only enable shared library if LLVM_LINK_LLVM_DYLIB=ON.; # Without that option resulting library is too close to 2^16 DLL exports limit.; if(UNIX OR (MINGW AND LLVM_LINK_LLVM_DYLIB)); add_clang_subdirectory(clang-shlib); endif(). if(CLANG_ENABLE_ARCMT); add_clang_subdirectory(arcmt-test); add_clang_subdirectory(c-arcmt-test); endif(). if(CLANG_ENABLE_STATIC_ANALYZER); add_clang_subdirectory(clang-check); add_clang_subdirectory(clang-extdef-mapping); add_clang_subdirectory(scan-build); add_clang_subdirectory(scan-build-py); add_clang_subdirectory(scan-view); endif(). # We support checking out the clang-tools-extra repository into the 'extra'; # subdirectory. It contains tools developed as part of the Clang/LLVM project; # on top of the Clang tooling platform. We keep them in a separate repository; # to keep the primary Clang repository small and focused.; # It also may be included by LLVM_EXTERNAL_CLANG_TOOLS_EXTRA_SOURCE_DIR.; add_llvm_external_project(clang-tools-extra extra). # libclang may require clang-tidy in clang-tools-extra.; add_clang_subdirectory(libclang). add_clang_subdirectory(amdgpu-arch); add_clang_subdirectory(nvptx-arch); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/CMakeLists.txt:378,wrap,wrapper,378,interpreter/llvm-project/clang/tools/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/CMakeLists.txt,1,['wrap'],['wrapper']
Integrability,"created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should not had been created, but; that time we did not know about the error, the error happened later. Since the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::ImportErrors``. Note that, there may; be several ASTImporter objects which import into the same ""to"" context but from; different ""from"" contexts; in this case, they have to share the associated; errors of the ""to"" context. When an error happens, that propagates through the call stack, through all the; dependant nodes. However, in case of dependency cycles, this is not enough,; because we strive to mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track of the errors for those nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we visit during an Import; call. If node ``A`` depends on node ``B`` then the path contains an ``A->B``; edge. From the call stack of the import functions, we can read the very same; path. Now imagine the following AST, where the ``->`` represents dependency in terms; of the import (all nodes are declarations). .. code-block:: text. A->B->C->D; `->E. We would like to import A.; The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.; During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for E, then as; the call stack shrinks for B, then for A:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE // Err",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:101912,depend,dependency,101912,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['dependency']
Integrability,"cribe for a delayed warning when the symbol that represents the value of; the argument is garbage-collected by the analyzer. When calling 'clang_analyzer_warnOnDeadSymbol(x)', if value of 'x' is a; symbol, then this symbol is marked by the ExprInspection checker. Then,; during each garbage collection run, the checker sees if the marked symbol is; being collected and issues the 'SYMBOL DEAD' warning if it does.; This way you know where exactly, up to the line of code, the symbol dies. It is unlikely that you call this function after the symbol is already dead,; because the very reference to it as the function argument prevents it from; dying. However, if the argument is not a symbol but a concrete value,; no warning would be issued. Example usage::. do {; int x = generate_some_integer();; clang_analyzer_warnOnDeadSymbol(x);; } while(0); // expected-warning{{SYMBOL DEAD}}. - ``void clang_analyzer_explain(a single argument of any type);``. This function explains the value of its argument in a human-readable manner; in the warning message. You can make as many overrides of its prototype; in the test code as necessary to explain various integral, pointer,; or even record-type values. To simplify usage in C code (where overloading; the function declaration is not allowed), you may append an arbitrary suffix; to the function name, without affecting functionality. Example usage::. void clang_analyzer_explain(int);; void clang_analyzer_explain(void *);. // Useful in C code; void clang_analyzer_explain_int(int);. void foo(int param, void *ptr) {; clang_analyzer_explain(param); // expected-warning{{argument 'param'}}; clang_analyzer_explain_int(param); // expected-warning{{argument 'param'}}; if (!ptr); clang_analyzer_explain(ptr); // expected-warning{{memory address '0'}}; }. - ``void clang_analyzer_dump( /* a single argument of any type */);``. Similar to clang_analyzer_explain, but produces a raw dump of the value,; same as SVal::dump(). Example usage::. void clang_analyzer_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:6543,message,message,6543,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,1,['message'],['message']
Integrability,"criptions make use of the components; provided by LLVM, and can optionally provide custom target-specific passes,; to build complete code generators for a specific target. Target descriptions; live in ``lib/Target/``. 6. The target-independent JIT components. The LLVM JIT is completely target; independent (it uses the ``TargetJITInfo`` structure to interface for; target-specific issues. The code for the target-independent JIT lives in; ``lib/ExecutionEngine/JIT``. Depending on which part of the code generator you are interested in working on,; different pieces of this will be useful to you. In any case, you should be; familiar with the `target description`_ and `machine code representation`_; classes. If you want to add a backend for a new target, you will need to; `implement the target description`_ classes for your new target and understand; the :doc:`LLVM code representation <LangRef>`. If you are interested in; implementing a new `code generation algorithm`_, it should only depend on the; target-description and machine code representation classes, ensuring that it is; portable. Required components in the code generator; -----------------------------------------. The two pieces of the LLVM code generator are the high-level interface to the; code generator and the set of reusable components that can be used to build; target-specific backends. The two most important interfaces (:raw-html:`<tt>`; `TargetMachine`_ :raw-html:`</tt>` and :raw-html:`<tt>` `DataLayout`_; :raw-html:`</tt>`) are the only ones that are required to be defined for a; backend to fit into the LLVM system, but the others must be defined if the; reusable code generator components are going to be used. This design has two important implications. The first is that LLVM can support; completely non-traditional code generation targets. For example, the C backend; does not require register allocation, instruction selection, or any of the other; standard components provided by the system. As such, it on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:3152,depend,depend,3152,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['depend'],['depend']
Integrability,"cross files; - `rootprint`: to plot content (histograms, graphs) of files; - `rootrm`: to remove content from files; These utilities took inspiration from the well known *nix commands and all offer the `-h` switch which provides documentation for all options available and example invocation lines. ### TBufferFile. We updated TBuffer::Expand to properly shrink the buffer when requested, hence reducing memory usage in some cases. ### I/O New functionalities. We added support for template parameter packs in class name involved in the I/O. ## TTree Libraries. ### Improvement of handling of default number of entries. A new const expression value: `TTree::kMaxEntries` has been introduced to; express the largest possible entry number in a `TTree`. This is used in; two main cases:. - as the default value for the requested number of entries a routine should be; applied to; for example this is used for `TTree::Draw` and `TTree::Process`.; Previously the default was only 1 billions entries, causing those routines to; end early in case of very large trees. - as the default value for the number of entries returned by TChain::GetEntriesFast.; The previous value was kBigNumber (set to 1234567890) and internally (but somewhat; inconsistently, see [ROOT-6885]) a larger value was used (named theBigNumber). Now; `TTree::kMaxEntries` is used throughout TChain. `TChain::kBigNumber` is deprecated and its value has been changed to be equal; to `TTree::kMaxEntries`. ### MakeSelector. `TTree::MakeSelector` has been update to generate a code skeleton based on the `TTreeReader` rather than the old style relying on numeric data members replacements for the user objects. The main advantage is the lifting of the problem related to the fact that the old style was using fixed size array to represent variable size collection. `TTree::MakeSelector` takes an option parameter that can be used to specify the branches that will have a data member.; - If option is `""=legacy""`, a pre-ROOT6 selector will be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:8941,rout,routines,8941,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['rout'],['routines']
Integrability,"ct dir>/CMakeLists.txt``:. .. code-block:: cmake. find_package(LLVM REQUIRED CONFIG). separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS}); add_definitions(${LLVM_DEFINITIONS_LIST}); include_directories(${LLVM_INCLUDE_DIRS}). add_subdirectory(<pass name>). Contents of ``<project dir>/<pass name>/CMakeLists.txt``:. .. code-block:: cmake. add_library(LLVMPassname MODULE Pass.cpp). Note if you intend for this pass to be merged into the LLVM source tree at some; point in the future it might make more sense to use LLVM's internal; ``add_llvm_library`` function with the MODULE argument instead by... Adding the following to ``<project dir>/CMakeLists.txt`` (after; ``find_package(LLVM ...)``). .. code-block:: cmake. list(APPEND CMAKE_MODULE_PATH ""${LLVM_CMAKE_DIR}""); include(AddLLVM). And then changing ``<project dir>/<pass name>/CMakeLists.txt`` to. .. code-block:: cmake. add_llvm_library(LLVMPassname MODULE; Pass.cpp; ). When you are done developing your pass, you may wish to integrate it; into the LLVM source tree. You can achieve it in two easy steps:. #. Copying ``<pass name>`` folder into ``<LLVM root>/lib/Transforms`` directory. #. Adding ``add_subdirectory(<pass name>)`` line into; ``<LLVM root>/lib/Transforms/CMakeLists.txt``. Compiler/Platform-specific topics; =================================. Notes for specific compilers and/or platforms. Windows; -------. **LLVM_COMPILER_JOBS**:STRING; Specifies the maximum number of parallel compiler jobs to use per project; when building with msbuild or Visual Studio. Only supported for the Visual; Studio 2010 CMake generator. 0 means use all processors. Default is 0. **CMAKE_MT**:STRING; When compiling with clang-cl, recent CMake versions will default to selecting; `llvm-mt` as the Manifest Tool instead of Microsoft's `mt.exe`. This will; often cause errors like:. .. code-block:: console. -- Check for working C compiler: [...]clang-cl.exe - broken; [...]; MT: command [...] failed (exit code 0x1) with t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:46297,integrat,integrate,46297,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['integrat'],['integrate']
Integrability,"ct r;; NSValue *bad_rect = @(r); // error. typedef struct __attribute__((objc_boxable)) _Rect Rect;. NSValue *good_rect = @(r); // ok. Container Literals; ==================. Objective-C now supports a new expression syntax for creating immutable; array and dictionary container objects. Examples; --------. Immutable array expression:. .. code-block:: objc. NSArray *array = @[ @""Hello"", NSApp, [NSNumber numberWithInt:42] ];. This creates an ``NSArray`` with 3 elements. The comma-separated; sub-expressions of an array literal can be any Objective-C object; pointer typed expression. Immutable dictionary expression:. .. code-block:: objc. NSDictionary *dictionary = @{; @""name"" : NSUserName(),; @""date"" : [NSDate date],; @""processInfo"" : [NSProcessInfo processInfo]; };. This creates an ``NSDictionary`` with 3 key/value pairs. Value; sub-expressions of a dictionary literal must be Objective-C object; pointer typed, as in array literals. Key sub-expressions must be of an; Objective-C object pointer type that implements the; ``<NSCopying>`` protocol. Discussion; ----------. Neither keys nor values can have the value ``nil`` in containers. If the; compiler can prove that a key or value is ``nil`` at compile time, then; a warning will be emitted. Otherwise, a runtime error will occur. Using array and dictionary literals is safer than the variadic creation; forms commonly in use today. Array literal expressions expand to calls; to ``+[NSArray arrayWithObjects:count:]``, which validates that all; objects are non-``nil``. The variadic form,; ``+[NSArray arrayWithObjects:]`` uses ``nil`` as an argument list; terminator, which can lead to malformed array objects. Dictionary; literals are similarly created with; ``+[NSDictionary dictionaryWithObjects:forKeys:count:]`` which validates; all objects and keys, unlike; ``+[NSDictionary dictionaryWithObjectsAndKeys:]`` which also uses a; ``nil`` parameter as an argument list terminator. Object Subscripting; ===================. Objective-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:9970,protocol,protocol,9970,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['protocol'],['protocol']
Integrability,"ct))``. Other pointer types, such as ``int*`` and ``CFStringRef``, are not subject to; ARC's semantics and restrictions. .. admonition:: Rationale. We are not at liberty to require all code to be recompiled with ARC;; therefore, ARC must interoperate with Objective-C code which manages retains; and releases manually. In general, there are three requirements in order for; a compiler-supported reference-count system to provide reliable; interoperation:. * The type system must reliably identify which objects are to be managed. An; ``int*`` might be a pointer to a ``malloc``'ed array, or it might be an; interior pointer to such an array, or it might point to some field or local; variable. In contrast, values of the retainable object pointer types are; never interior. * The type system must reliably indicate how to manage objects of a type.; This usually means that the type must imply a procedure for incrementing; and decrementing retain counts. Supporting single-ownership objects; requires a lot more explicit mediation in the language. * There must be reliable conventions for whether and when ""ownership"" is; passed between caller and callee, for both arguments and return values.; Objective-C methods follow such a convention very reliably, at least for; system libraries on macOS, and functions always pass objects at +0. The; C-based APIs for Core Foundation objects, on the other hand, have much more; varied transfer semantics. The use of ``__attribute__((NSObject))`` typedefs is not recommended. If it's; absolutely necessary to use this attribute, be very explicit about using the; typedef, and do not assume that it will be preserved by language features like; ``__typeof`` and C++ template argument substitution. .. admonition:: Rationale. Any compiler operation which incidentally strips type ""sugar"" from a type; will yield a type without the attribute, which may result in unexpected; behavior. .. _arc.objects.retains:. Retain count semantics; ----------------------. A reta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:11435,mediat,mediation,11435,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['mediat'],['mediation']
Integrability,"ct; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters; Unknown. 1482; CD3; Point of declaration of enumeration; Clang 3.0. 1483; NAD; Non-dependent static_assert-declarations; Unknown. 1484; CD4; Unused local classes of function templates; Unknown. 1485; drafting; Out-of-class definition of member unscoped opaque enumeration; Not resolved. 1486; drafting; Base-derived conversion in member pointer deduction; Not resolved. 1487; CD3; When are inheriting constructors declared?; Unknown. 1488; drafting; abstract-pack-declarators in type-ids; Not resolved. 1489; CD3; Is value-initialization of an array constant initialization?; Unknown. 1490; CD4; List-initialization from a string literal; Clang 3.7 (C++11 onwards). 1491; CD3; Move construction and rvalue reference members; Unknown. 1492; CD4; Exception specifications on template destructors; Unknown. 1493; C++14; Criteria for move-construction; Unknown. 1494; CD3; Temporary initialization for reference binding in list-initialization; Unknown. 1495; CD3; Partial specialization of variadic class template; Clang 4. 1496; CD4; Triviality with deleted and missing default constructors; No. 1497;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:99604,depend,dependent,99604,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"ct``' directory in the current directory and; fully populate it with all of the source code, test directories, and local; copies of documentation files for LLVM and all the related subprojects. Note; that unlike the tarballs, which contain each subproject in a separate file, the; git repository contains all of the projects together. If you want to get a specific release (as opposed to the most recent revision),; you can check out a tag after cloning the repository. E.g., `git checkout; llvmorg-6.0.1` inside the ``llvm-project`` directory created by the above; command. Use `git tag -l` to list all of them. Sending patches; ^^^^^^^^^^^^^^^. See :ref:`Contributing <submit_patch>`. Bisecting commits; ^^^^^^^^^^^^^^^^^. See `Bisecting LLVM code <GitBisecting.html>`_ for how to use ``git bisect``; on LLVM. Reverting a change; ^^^^^^^^^^^^^^^^^^. When reverting changes using git, the default message will say ""This reverts; commit XYZ"". Leave this at the end of the commit message, but add some details; before it as to why the commit is being reverted. A brief explanation and/or; links to bots that demonstrate the problem are sufficient. Local LLVM Configuration; ------------------------. Once checked out repository, the LLVM suite source code must be configured; before being built. This process uses CMake. Unlinke the normal ``configure``; script, CMake generates the build files in whatever format you request as well; as various ``*.inc`` files, and ``llvm/include/llvm/Config/config.h.cmake``. Variables are passed to ``cmake`` on the command line using the format; ``-D<variable name>=<value>``. The following variables are some common options; used by people developing LLVM. +-------------------------+----------------------------------------------------+; | Variable | Purpose |; +=========================+====================================================+; | CMAKE_C_COMPILER | Tells ``cmake`` which C compiler to use. By |; | | default, this will be /usr/bin/cc. |; +-------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:23301,message,message,23301,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['message'],['message']
Integrability,"cted by the ""Advanced Drawing Tool"" panel that pops up when clicking the ""Advanced"" button, are:. * *Contour*: to plot the confidence contour of two chosen parameters. One can select the number of points to draw the contour; (more points might require more time to compute it), the parameters and the desired confidence level . * *Scan* : to plot a scan of the minimization function (likelihood or chi-squared) around the minimum as function of the chosen parameter. * *Conf Interval* : to plot the confidence interval of the fitted function as a filled coloured band around its central value.; One can select the desired confidence level for the band to be plotted. ### Print Options. This set of options specifies the amount of feedback printed on the; root command line after performed fits. *‘Verbose'* - prints fit results after each iteration. *‘Quiet'* - no fit information is printed. *‘Default'* - between Verbose and Quiet. ### Command Buttons. *Fit button* - performs a fit taking different option settings via the; Fit Panel interface. *Reset* - sets the GUI elements and related fit settings to the; default ones. *Close* - closes the Fit panel window. ### Minimization Options. With this tab one can select specific options for minimization. These include. * The minimizer library ( *Minuit*, *Minuit2*, *Fumili*, *GSL*, *Genetics* ); * The method (algorithm) for minimization. For example for Minuit one can choose between (*Migrad*, *Simplex* or *Scan*); * Error definition; * Minimization tolerance; * Number of iterations/function calls; * Print Level: (*Default*, *Verbose* or *Quiet*). ## New ROOT::Fit classes. The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes,; which are defined in the `ROOT::Fit` namespace.; These classes can be classified in the following groups:. * User classes driving the fit: `ROOT::Fit::Fitter` for executing the fit, `ROOT::Fit::FitConfig` for configuring the fit,; 	`ROOT::Fit::ParameterSettings",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:25734,interface,interface,25734,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['interface'],['interface']
Integrability,"ction and any load of the; pointer. The ``-gvn``, ``-memcpyopt``, and ``-dse`` passes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These passes use AliasAnalysis information to reason about loads and stores. .. _the clients:. Clients for debugging and evaluation of implementations; -------------------------------------------------------. These passes are useful for evaluating the various alias analysis; implementations. You can use them with commands like:. .. code-block:: bash. % opt -ds-aa -aa-eval foo.bc -disable-output -stats. The ``-print-alias-sets`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-print-alias-sets`` pass is exposed as part of the ``opt`` tool to print; out the Alias Sets formed by the `AliasSetTracker`_ class. This is useful if; you're using the ``AliasSetTracker`` class. To use it, use something like:. .. code-block:: bash. % opt -ds-aa -print-alias-sets -disable-output. The ``-aa-eval`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-aa-eval`` pass simply iterates through all pairs of pointers in a; function and asks an alias analysis whether or not the pointers alias. This; gives an indication of the precision of the alias analysis. Statistics are; printed indicating the percent of no/may/must aliases found (a more precise; algorithm will have a lower number of may aliases). Memory Dependence Analysis; ==========================. .. note::. We are currently in the process of migrating things from; ``MemoryDependenceAnalysis`` to :doc:`MemorySSA`. Please try to use; that instead. If you're just looking to be a client of alias analysis information, consider; using the Memory Dependence Analysis interface instead. MemDep is a lazy,; caching layer on top of alias analysis that is able to answer the question of; what preceding memory operations a given instruction depends on, either at an; intra- or inter-block level. Because of its laziness and caching policy, using; MemDep can be a significant performance win over accessing alias analysis; directly.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:30261,interface,interface,30261,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,2,"['depend', 'interface']","['depends', 'interface']"
Integrability,"ction#1``, ``section#2``, ..., ``section#N`` in the; metadata causes the backend to emit the PC for the associated instruction or; function to all named sections. For each emitted PC in a section #N, the; constants ``aux-consts#N`` in the tuple ``!N`` will be emitted after the PC.; Multiple tuples with constant data may be provided after a section name string; (e.g. ``!0 = !{""s1"", !1, !2}``), and a single constant tuple may be reused for; different sections (e.g. ``!0 = !{""s1"", !1, ""s2"", !1}``). Binary Encoding; ===============. *Instructions* result in emitting a single PC, and *functions* result in; emission of the start of the function and a 32-bit size. This is followed by; the auxiliary constants that followed the respective section name in the; ``MD_pcsections`` metadata. To avoid relocations in the final binary, each PC address stored at ``entry``; is a relative relocation, computed as ``pc - entry``. To decode, a user has to; compute ``entry + *entry``. The size of each entry depends on the code model. With large and medium sized; code models, the entry size matches pointer size. For any smaller code model; the entry size is just 32 bits. Encoding Options; ----------------. Optional encoding options can be passed in the first ``MDString`` operator:; ``<section>!<options>``. The following options are available:. * ``C`` -- Compress constant integers of size 2-8 bytes as ULEB128; this; includes the function size (but excludes the PC entry). For example, ``foo!C`` will emit into section ``foo`` with all constants; encoded as ULEB128. Guarantees on Code Generation; =============================. Attaching ``!pcsections`` metadata to LLVM IR instructions *shall not* affect; optimizations or code generation outside the requested PC sections. While relying on LLVM IR metadata to request PC sections makes the above; guarantee relatively trivial, propagation of metadata through the optimization; and code generation pipeline has the following guarantees. Metadata Prop",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PCSectionsMetadata.rst:2009,depend,depends,2009,interpreter/llvm-project/llvm/docs/PCSectionsMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PCSectionsMetadata.rst,1,['depend'],['depends']
Integrability,"ction, no base address entry is needed. *End-of-list*. This kind of location list entry marks the end of the location list; expression. The address ranges defined by the bounded location description entries of a; location list expression may overlap. When they do, they describe a situation in; which an object exists simultaneously in more than one place. If all of the address ranges in a given location list expression do not; collectively cover the entire range over which the object in question is; defined, and there is no following default location description entry, it is; assumed that the object is not available for the portion of the range that is; not covered. The result of the evaluation of a DWARF location list expression is:. * If the current program location is not specified, then it is an evaluation; error. .. note::. If the location list only has a single default entry, should that be; considered a match if there is no program location? If there are non-default; entries then it seems it has to be an evaluation error when there is no; program location as that indicates the location depends on the program; location which is not known. * If there are no matching location list entries, then the result is a location; description that comprises one undefined location description. * Otherwise, the operation expression E of each matching location list entry is; evaluated with the current context, except that the result kind is a location; description, the object is unspecified, and the initial stack is empty. The; location list entry result is the location description returned by the; evaluation of E. The result is a location description that is comprised of the union of the; single location descriptions of the location description result of each; matching location list entry. A location list expression can only be used as the value of a debugger; information entry attribute that is encoded using class ``loclist`` or; ``loclistsptr`` (see :ref:`amdgpu-dwarf-class",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:145841,depend,depends,145841,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['depend'],['depends']
Integrability,"ction:. ```{.cpp}; #include ""Math/IFunction.h"". class MyGradientFunction: public ROOT::Math::IGradientFunctionOneDim; {; public:; double DoEval(double x) const; {; return sin(x);; }. ROOT::Math::IBaseFunctionOneDim* Clone() const; {; return new MyGradientFunction();; }. double DoDerivative(double x) const; {; return -cos(x);; }. };; ```. ### Multi-dimensional Function Interfaces. The most generic case of a multidimensional function has similar approach. Some examples will be shown next. It is important to notice, that one dimensional functions can be also implemented through; the interfaces that will be presented here. Nevertheless, the user needs to implement those following the indications of the previous chapter, for algorithm working exclusivly on one-dimensional; functions. For algorithms working on both one-dimensional and multi-dimensional functions they should instead use this interface. * `ROOT::Math::IBaseFunctionMultiDim`: This interface provides the `double operator() (const double*)` that takes an array of doubles with all the values for the different dimensions. In this case,; the user has to provide the functionality for two different functions: `double DoEval(const double*)` and `unsigned int NDim()`. The first ones evaluates the function given the array that represents; the multiple variables. The second returns the number of dimensions of the function. Example of implementing a basic multi-dimensional function:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionMultiDim; {; public:; double DoEval(const double* x) const; {; return x[0] + sin(x[1]);; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IBaseFunctionMultiDim* Clone() const; {; return new MyFunction();; }. };; ```. * `ROOT::Math::IGradientFunctionMultiDim`: This interface offers the same functionality as the base function plus the calculation of the derivative.; It only adds the `double Derivative(double* x, uint ivar)` method for the user ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:37788,interface,interface,37788,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interface']
Integrability,"ctionality present in the old Fortran version, with almost equivalent numerical accuracy and computational performances. Furthermore, it contains new functionality, like the possibility to set single side parameter limits or the FUMILI algorithm, which is an optimized method for least square and log likelihood minimizations. The package has been originally developed by M. Winkler and F. James. More information on the new C++ version can be found on the <a href=""http://www.cern.ch/minuit"">MINUIT Web Site</a> and in particular the online doc can be found here <a href=""http://www.cern.ch/mathlibs/sw/html/Minuit2.html"">here</a>.<p>; Minuit2, originally developed in the SEAL project, is now distributed within ROOT. The API has been then changed in this new version to follow the ROOT coding convention (function names starting with capital letters) and the classes have been moved inside the namespace <em>ROOT::Minuit2</em>. In addition, the ROOT distribution contains classes like TFitterMinuit and TFitterFumili needed to integrate Minuit2 in the ROOT framework. <p>; In the latest version (from 5.17.08) a new class has been introduced, ROOT::Minuit2::Minuit2Minimizer, which implements the interface; ROOT::Math::Minimizer from <a href=""http://www.cern.ch/mathlibs/sw/html/MathCore.html"">MathCore</a>.; . It can be instantiates also using the ROOT plug-in manager. It is a convenient entry point for using Minuit2. <h3>References</h3>; <p>; <ol>; <li>; F. James, <em>Fortran MINUIT Reference Manual</em> (<a href=""https://cern-tex.web.cern.ch/cern-tex/minuit/minmain.html"">html</a>); </li>; <li>; F. James and M. Winkler, <em>C++ MINUIT User's Guide</em> (<a href=""http://seal.cern.ch/documents/minuit/mnusersguide.pdf"">pdf</a>); </li>; <li>; F. James, <em>Minuit Tutorial on Function Minimization</em> (<a href=""http://seal.cern.ch/documents/minuit/mntutorial.pdf"">pdf</a>); </li>; <li>; F. James, <em>The Interpretation of Errors in Minuit</em> (<a href=""http://seal.cern.ch/documents/min",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/index.txt:1238,integrat,integrate,1238,math/minuit2/doc/index.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/index.txt,1,['integrat'],['integrate']
Integrability,"ctions used across the; codebase. You can find the most common ones in ``STLExtras.h``; (`doxygen <https://llvm.org/doxygen/STLExtras_8h.html>`__). Some of these wrap; well-known C++ standard library functions, while others are unique to LLVM. .. _uf_iteration:. Iterating over ranges; ---------------------. Sometimes you may want to iterate over more than range at a time or know the; index of the index. LLVM provides custom utility functions to make that easier,; without having to manually manage all iterators and/or indices:. .. _uf_zip:. The ``zip``\ * functions; ^^^^^^^^^^^^^^^^^^^^^^^^. ``zip``\ * functions allow for iterating over elements from two or more ranges; at the same time. For example:. .. code-block:: c++. SmallVector<size_t> Counts = ...;; char Letters[26] = ...;; for (auto [Letter, Count] : zip_equal(Letters, Counts)); errs() << Letter << "": "" << Count << ""\n"";. Note that the elements are provided through a 'reference wrapper' proxy type; (tuple of references), which combined with the structured bindings declaration; makes ``Letter`` and ``Count`` references to range elements. Any modification; to these references will affect the elements of ``Letters`` or ``Counts``. The ``zip``\ * functions support temporary ranges, for example:. .. code-block:: c++. for (auto [Letter, Count] : zip(SmallVector<char>{'a', 'b', 'c'}, Counts)); errs() << Letter << "": "" << Count << ""\n"";. The difference between the functions in the ``zip`` family is how they behave; when the supplied ranges have different lengths:. * ``zip_equal`` -- requires all input ranges have the same length.; * ``zip`` -- iteration stops when the end of the shortest range is reached.; * ``zip_first`` -- requires the first range is the shortest one.; * ``zip_longest`` -- iteration continues until the end of the longest range is; reached. The non-existent elements of shorter ranges are replaced with; ``std::nullopt``. The length requirements are checked with ``assert``\ s. As a rule of thumb, prefe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:100596,wrap,wrapper,100596,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['wrap'],['wrapper']
Integrability,"ctor length, so this operation; may map to multiple SelectionDAG nodes including ``shuffle_vector``,; ``concat_vectors``, ``insert_subvector``, and ``extract_subvector``. Prior to the existence of the Legalize passes, we required that every target; `selector`_ supported and handled every operator and type even if they are not; natively supported. The introduction of the Legalize phases allows all of the; canonicalization patterns to be shared across targets, and makes it very easy to; optimize the canonicalized code because it is still in the form of a DAG. .. _optimizations:; .. _Optimize SelectionDAG:; .. _selector:. SelectionDAG Optimization Phase: the DAG Combiner; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The SelectionDAG optimization phase is run multiple times for code generation,; immediately after the DAG is built and once after each legalization. The first; run of the pass allows the initial code to be cleaned up (e.g. performing; optimizations that depend on knowing that the operators have restricted type; inputs). Subsequent runs of the pass clean up the messy code generated by the; Legalize passes, which allows Legalize to be very simple (it can focus on making; code legal instead of focusing on generating *good* and legal code). One important class of optimizations performed is optimizing inserted sign and; zero extension instructions. We currently use ad-hoc techniques, but could move; to more rigorous techniques in the future. Here are some good papers on the; subject:. ""`Widening integer arithmetic <http://www.eecs.harvard.edu/~nr/pubs/widen-abstract.html>`_"" :raw-html:`<br>`; Kevin Redwine and Norman Ramsey :raw-html:`<br>`; International Conference on Compiler Construction (CC) 2004. ""`Effective sign extension elimination <http://portal.acm.org/citation.cfm?doid=512529.512552>`_"" :raw-html:`<br>`; Motohiro Kawahito, Hideaki Komatsu, and Toshio Nakatani :raw-html:`<br>`; Proceedings of the ACM SIGPLAN 2002 Conference on Programming Language",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:45482,depend,depend,45482,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['depend'],['depend']
Integrability,"ctor of 1.5x-2x on top; of the usual MemorySanitizer slowdown and increases memory overhead. Clang option ``-fsanitize-memory-track-origins=1`` enables a slightly; faster mode when MemorySanitizer collects only allocation points but; not intermediate stores. Use-after-destruction detection; ===============================. MemorySanitizer includes use-after-destruction detection. After invocation of; the destructor, the object will be considered no longer readable, and using; underlying memory will lead to error reports in runtime. Refer to the standard; for `lifetime <https://eel.is/c++draft/basic.life#1>`_ definition. This feature can be disabled with either:. #. Pass addition Clang option ``-fno-sanitize-memory-use-after-dtor`` during; compilation.; #. Set environment variable `MSAN_OPTIONS=poison_in_dtor=0` before running; the program. Handling external code; ======================. MemorySanitizer requires that all program code is instrumented. This; also includes any libraries that the program depends on, even libc.; Failing to achieve this may result in false reports.; For the same reason you may need to replace all inline assembly code that writes to memory; with a pure C/C++ code. Full MemorySanitizer instrumentation is very difficult to achieve. To; make it easier, MemorySanitizer runtime library includes 70+; interceptors for the most common libc functions. They make it possible; to run MemorySanitizer-instrumented programs linked with; uninstrumented libc. For example, the authors were able to bootstrap; MemorySanitizer-instrumented Clang compiler by linking it with; self-built instrumented libc++ (as a replacement for libstdc++). Supported Platforms; ===================. MemorySanitizer is supported on the following OS:. * Linux; * NetBSD; * FreeBSD. Limitations; ===========. * MemorySanitizer uses 2x more real memory than a native run, 3x with; origin tracking.; * MemorySanitizer maps (but not reserves) 64 Terabytes of virtual; address space. This mean",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:6116,depend,depends,6116,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst,1,['depend'],['depends']
Integrability,"cts could provide this service but there is a snag:; as there is only one collection object per collection there would only; be one cursor. Instead, to permit the use of as many cursors as; required, they are made separate classes called iterator. For each; collection class there is an associated iterator class that knows how to; sequentially retrieve each member in turn. The relationship between a; collection and its iterator is very close and may require that the; iterator has full access to the collection (i.e. it is a friend class).; In general iterator will be used via the **`TIter`** wrapper class. For; example:. - **`TList`** **`TListIter`**. - **`TMap`** **`TMapIter`**. ## Foundation Classes. All collections are based on the fundamental classes: **`TCollection`**; and **`TIterator`**. They are so generic that it is not possible to; create objects from them; they are only used as base classes for other; classes (i.e. they are abstract base classes). The **`TCollection`** class provides the basic protocol (i.e. the; minimum set of member functions) that all collection classes have to; implement. These include:. - `Add` `Adds another object to the collection.`. - `GetSize` `Returns the number of objects in the collection.`. - `Clear`; `Clears out the collection, but does not delete the removed objects.`. - `Delete`; `Clears out the collection and deletes the removed objects. This should only `; `be used if the collection owns its objects (which are not normally the case).`. - `FindObject` `Finds an object given either its name or address.`. - `MakeIterator` `Returns an iterator associated with the collection.`. - `Remove` `Removes an object from the collection.`. The code example below shows a class containing three lists, where the; `fTracks` list is the owning collection and the other two lists are used; to store a sub-set of the track objects. In the destructor of the class,; the method `Delete` is called for the owning collection to delete; correctly its en",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:6576,protocol,protocol,6576,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['protocol'],['protocol']
Integrability,"cts).; - Introduced support for type safe range-for-loop for ROOT collection. The typical use is:. ```; for(auto bcl : TRangeDynCast<TBaseClass>( * cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; for(auto bcl : TRangeDynCast<TBaseClass>( cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; ```; - ClassDefInline has been enhanced even for some compiled class (without a dictionary). ClassDefInline can still not be used for class template instance using Double32_t or Float16_t as a template parameter or for class or class template that do not have a public default constructor.; - ROOT's backport of `std::string_view` has been updated to follow what's available in C++17, notably its `to_string` member function has been removed. ### Thread safety. Resolved the race conditions inherent to the use of the RecursiveRemove mechanism. - Introduced ```ROOT::TReentrantRWLock```, an implementation of a reentrant read-write lock with a configurable internal mutex/lock and a condition variable to synchronize readers and writers when necessary. The implementation allows a single reader to take the write lock without releasing the reader lock. It also allows the writer to take a read lock. In other word, the lock is re-entrant for both reading and writing. The implementation tries to make faster the scenario when readers come and go but there is no writer. In that case, readers will not pay the price of taking the internal lock.; Moreover, this RW lock tries to be fair with writers, giving them the possibility to claim the lock and wait for only the remaining readers, thus preventing starvation. - Switched the ROOT global to be a ```ROOT::TReentrantRWLock``` and renamed it ROOT::gCoreMutex. The old name ```gROOTMutex``` and ```gInterpreterMutex``` are deprecated and may be removed in future releases.; - Added ```TReadLockGuard```,```TWriteLockGuard```, ```R__READ_LOCKGUARD``` and```R__WRITE_LOCKGUARD``` to take advantage of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:4544,synchroniz,synchronize,4544,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['synchroniz'],['synchronize']
Integrability,"cts; Unknown. 2222; drafting; Additional contexts where instantiation is not required; Not resolved. 2223; drafting; Multiple alignas specifiers; Not resolved. 2224; C++17; Member subobjects and base-class casts; Unknown. 2225; NAD; reinterpret_cast to same floating-point type; Unknown. 2226; CD5; Xvalues vs lvalues in conditional expressions; Unknown. 2227; CD5; Destructor access and default member initializers; Unknown. 2228; open; Ambiguity resolution for cast to function type; Not resolved. 2229; CD5; Volatile unnamed bit-fields; Clang 7. 2230; NAD; Linkage of extern ""C"" function in unnamed namespace; Unknown. 2231; NAD; Class member access to static data member template; Unknown. 2232; open; thread_local anonymous unions; Not resolved. 2233; CD5; Function parameter packs following default arguments; Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-dependent types; Unknown. 2236; drafting; When is an alias template specialization dependent?; Not resolved. 2237; CD5; Can a template-id name a constructor?; Unknown. 2238; NAD; Contradictory alignment requirements for allocation; Unknown. 2239; NAD; Sized deallocation with a trivial destructor; Unknown. 2240; NAD; this is not odr-used in a constant expression; Unknown. 2241; CD5; Overload resolution is not invoked with a single function; Unknown. 2242; C++23; ODR violation with constant initialization possibly omitted; Unknown. 2243; drafting; Incorrect use of implicit conversion sequence; Not resolved. 2244; open; Base class access in aggregate initialization; Not resolved. 2245; drafting; Point of instantiation of incomplete class template; Not resolved. 2246; drafting; Access of indirect virtual base class constructors; Not resolved. 2247; C++17; Lambda capture and variable argument list; Unknown. 2248; C++17; Problems with sized delete; Unknown. 2249; CD5; identifiers and id-expressions; Unknown. 2250; open; Implicit instantiation, destruction, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:152369,depend,dependent,152369,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"d **`TVectorF`**.; Copy constructors exist to transform these into their double precision; equivalent, thereby allowing easy access to decomposition and eigenvalue; classes, only available in double precision. The choice was made not to provide the less frequently used complex; matrix classes. If necessary, users can always reformulate the; calculation in 2 parts, a real one and an imaginary part. Although, a; linear equation involving complex numbers will take about a factor of 8; more computations, the alternative of introducing a set of complex; classes in this non-template library would create a major maintenance; challenge. Another choice was to fill in both the upper-right corner and the; bottom-left corner of a symmetric matrix. Although most algorithms use; only the upper-right corner, implementation of the different matrix; views was more straightforward this way. When stored only the; upper-right part is written to file. For a detailed description of the interface, the user should look at the; root reference guide at: <http://root.cern.ch/root/Reference.html>. ## Overview of Matrix Classes. The figure below shows an overview of the classes available in the; linear algebra library,` libMatrix.so`. At the center is the base class; **`TMatrixDBase`** from which three different matrix classes,; **`TMatrixD`**, **`TMatrixDSym`** and **`TMatrixDFSparse`** derive. The; user can define customized matrix operations through the classes; **`TElementActionD`** and **`TElementsPosActionD`**. ![Overview of matrix classes](pictures/0300012D.png). Reference to different views of the matrix can be created through the; classes on the right-hand side, see ""Matrix Views"". These references; provide a natural connection to vectors. Matrix decompositions (used in equation solving and matrix inversion); are available through the classes on the left-hand side (see ""Matrix; Decompositions""). They inherit from the **`TDecompBase`** class. The; Eigen Analysis is performed through the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:1337,interface,interface,1337,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['interface'],['interface']
Integrability,"d Fortran version,; with almost equivalent numerical accuracy and computational performances.; Furthermore, it contains new functionality, like the possibility to set single side parameter limits or; the FUMILI algorithm, which is an optimized method for least square and log likelihood minimizations.; The package has been originally developed by M. Winkler and F. James.; More information on the new C++ version can be found on the; MINUIT Web Site. Minuit2, originally developed in the SEAL project, is now distributed within %ROOT.; The API has been then changed in this new version to follow the %ROOT coding convention (function names starting with capital letters) and the classes have been moved inside the namespace ROOT::Minuit2.; In addition, the %ROOT distribution contains classes needed to integrate Minuit2 in the %ROOT framework. A new class has been introduced, ROOT::Minuit2::Minuit2Minimizer, which implements the interface; ROOT::Math::Minimizer. Within %ROOT, it can be instantiates also using the %ROOT plug-in manager. This class provides a convenient entry point for using Minuit2. An example of using this interface is; the %ROOT tutorial tutorials/fit/NumericalMinimization.C or; the Minuit2 test program testMinimize.cxx. A standalone version of Minuit2 (independent of %ROOT) can be downloaded from here. It does not contain the %ROOT interface and it is therefore totally independent of external packages and can be simply build using the configure script and then make. Example tests are provided in the directory test/MnSim and test/MnTutorial and they can be built with the make check command. The Minuit2 User Guide provides all the information needed for using directly (without add-on packages like %ROOT) Minuit2. References. F. James, Fortran MINUIT Reference Manual (html);; F. James and M. Winkler, C++ MINUIT User's Guide (html and; pdf);; F. James, Minuit Tutorial on Function Minimization (pdf);; F. James, The Interpretation of Errors in Minuit (pdf);. */; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.html:1398,interface,interface,1398,math/minuit2/doc/Minuit2.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.html,2,['interface'],['interface']
Integrability,"d `RY` allow to; change this order. The option `RX` allows to draw the X-axis with increasing values; from right to left and the `RY` option allows to draw the Y-axis with increasing; values from top to bottom.; ~~~ {.cpp}; g->Draw(""APL"");; g->Draw(""A RX RY PL"");; ~~~. ![New box option for 3D histograms](ReverseAxis.png). ## 3D Graphics Libraries; - In `TMarker3DBox::PaintH3` the boxes' sizes was not correct.; - The option `BOX`and `GLBOX` now draw boxes with a volume proportional to the; bin content to be conform to the 2D case where the surface of the boxes is; proportional to the bin content. ## Geometry Libraries. ## Dictionaries; - Stop dictionary generation early, during AST scanning, if a union is selected for I/O as this is not supported (triggered by [ROOT-8492](https://sft.its.cern.ch/jira/browse/ROOT-8492)); - Allow inclusion of headers in linkdef files [ROOT-7765](https://sft.its.cern.ch/jira/browse/ROOT-7765); - More expressive error messages when trying to directly select std::arrays; - rootcling now `#define`s `__PIC__` when parsing input headers [ROOT-8719]. ## I/O Libraries; - [[ROOT-8478](https://sft.its.cern.ch/jira/browse/ROOT-8478)] - Prompt error when building streamer info and a data member is a vector<T> w/o dictionary; - Fix ROOT-8686 and ROOT-8595 which led to error when persistifying classes which featured std::arrays as data members in TTrees.; - TDavixFile: Added support for bucket name in path; - Fix error sometimes prompted when trying to write std::array column-wise. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## Parallelism and PROOF; - Add ROOT::GetImplicitMTPoolSize function to get the size of the pool used to enable implicit multi threading; - Add the TThreadExecutor::Foreach method for parallelising functions featuring void return type; - Add TBufferMerger and TBufferMergerFile classes. TBufferMerger is a class to facilitate writing data in; parallel from multiple threads, while writ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:15373,message,messages,15373,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['message'],['messages']
Integrability,"d ``__dfsan_retval_tls``. The main advantage of the TLS ABI is that it is more tolerant of ABI mismatches; (TLS storage is not shared with any other form of storage, whereas extra; arguments may be stored in registers which under the native ABI are not used; for parameter passing and thus could contain arbitrary values). On the other; hand the args ABI is more efficient and allows ABI mismatches to be more easily; identified by checking for nonzero labels in nominally unlabelled programs. Implementing the ABI list; -------------------------. The `ABI list <DataFlowSanitizer.html#abi-list>`_ provides a list of functions; which conform to the native ABI, each of which is callable from an instrumented; program. This is implemented by replacing each reference to a native ABI; function with a reference to a function which uses the instrumented ABI.; Such functions are automatically-generated wrappers for the native functions.; For example, given the ABI list example provided in the user manual, the; following wrappers will be generated under the args ABI:. .. code-block:: llvm. define linkonce_odr { i8*, i16 } @""dfsw$malloc""(i64 %0, i16 %1) {; entry:; %2 = call i8* @malloc(i64 %0); %3 = insertvalue { i8*, i16 } undef, i8* %2, 0; %4 = insertvalue { i8*, i16 } %3, i16 0, 1; ret { i8*, i16 } %4; }. define linkonce_odr { i32, i16 } @""dfsw$tolower""(i32 %0, i16 %1) {; entry:; %2 = call i32 @tolower(i32 %0); %3 = insertvalue { i32, i16 } undef, i32 %2, 0; %4 = insertvalue { i32, i16 } %3, i16 %1, 1; ret { i32, i16 } %4; }. define linkonce_odr { i8*, i16 } @""dfsw$memcpy""(i8* %0, i8* %1, i64 %2, i16 %3, i16 %4, i16 %5) {; entry:; %labelreturn = alloca i16; %6 = call i8* @__dfsw_memcpy(i8* %0, i8* %1, i64 %2, i16 %3, i16 %4, i16 %5, i16* %labelreturn); %7 = load i16* %labelreturn; %8 = insertvalue { i8*, i16 } undef, i8* %6, 0; %9 = insertvalue { i8*, i16 } %8, i16 %7, 1; ret { i8*, i16 } %9; }. As an optimization, direct calls to native ABI functions will call the; native ABI func",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst:11348,wrap,wrappers,11348,interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizerDesign.rst,1,['wrap'],['wrappers']
Integrability,"d a ROOT tree. In general we; discourage the use of C structures`,` we recommend using a class; instead. However, we do support them for legacy applications written in; C or FORTRAN. The example `struct` holds simple variables and arrays. It; maps to a Geant3 common block `/gctrak/. `This is the definition of the; common block/structure:. ``` {.cpp}; const Int_t MAXMEC = 30;; // PARAMETER (MAXMEC=30); // COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7); // + ,NMEC,LMEC(MAXMEC); // + ,NAMEC(MAXMEC),NSTEP; // + ,PID,DESTEP,DESTEL,SAFETY,SLENG; // + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT. typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; ```. When using Geant3, the common block is filled by Geant3 routines at each; step and only the `TTree::Fill` method needs to be called. In this; example we emulate the Geant3 step routine with the `helixStep`; function. We also emulate the filling of the particle values. The calls; to the `Branch` methods are the same as if Geant3 were used. ``` {.cpp}; void helixStep(Float_t step, Float_t *vect, Float_t *vout); {; // extrapolate track in constant field; Float_t field = 20; // field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];. Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t*vect[kPZ];. vout[kX] = vect[kX] + (f1*vect[kPX] - f2*vect[kPY]);; vout[kY] = vect[kY] + (f1*vect[kPY] + f2*vect[kPX]);; vout[kZ] = vect[kZ] + (f1*vect[k",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:44245,rout,routines,44245,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['rout'],['routines']
Integrability,"d an object (in our case on the client side*) it has to derive; from **`TObject`** class because it uses the `Streamers` to fill a; buffer that is then sent over the connection. On the receiving side, the; `Streamers` are used to read the object from the message sent via the; socket. For network communication, we have a specialized **`TBuffer`**,; a descendant of **`TBuffer`** called **`TMessage`**. In the following; example, we create a **`TMessage`** with the intention to store an; object, hence the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closing the Connection. Once we are done sending objects, we close the connection by closing the; sockets at both ends. ``` {.cpp}; Socket->Close();; ```. This diagram summarizes the steps we just covered:. ![Server - Client setting-up and closing the connection](pictures/080001FF.png). ## A Server with Multiple Sockets. Chances are that your server has to be able to receive data from; multiple clients. The class we nee",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:1989,message,message,1989,documentation/users-guide/Networking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md,2,['message'],['message']
Integrability,"d are; subject to the assign, retain, and copy attribute logic that is; reserved for objects. All Blocks are constructed to be Objective-C objects regardless of; whether the Objective-C runtime is operational in the program or; not. Blocks using automatic (stack) memory are objects and may be; messaged, although they may not be assigned into ``__weak`` locations; if garbage collection is enabled. Within a Block literal expression within a method definition; references to instance variables are also imported into the lexical; scope of the compound statement. These variables are implicitly; qualified as references from self, and so self is imported as a const; copy. The net effect is that instance variables can be mutated. The :block-term:`Block_copy` operator retains all objects held in; variables of automatic storage referenced within the Block expression; (or form strong references if running under garbage collection).; Object variables of ``__block`` storage type are assumed to hold; normal pointers with no provision for retain and release messages. Foundation defines (and supplies) ``-copy`` and ``-release`` methods for; Blocks. In the Objective-C and Objective-C++ languages, we allow the; ``__weak`` specifier for ``__block`` variables of object type. If; garbage collection is not enabled, this qualifier causes these; variables to be kept without retain messages being sent. This; knowingly leads to dangling pointers if the Block (or a copy) outlives; the lifetime of this object. In garbage collected environments, the ``__weak`` variable is set to; nil when the object it references is collected, as long as the; ``__block`` variable resides in the heap (either by default or via; ``Block_copy()``). The initial Apple implementation does in fact; start ``__block`` variables on the stack and migrate them to the heap; only as a result of a ``Block_copy()`` operation. It is a runtime error to attempt to assign a reference to a; stack-based Block into any storage marked `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:9980,message,messages,9980,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['message'],['messages']
Integrability,"d be concise, but explanatory, including a complete; reasoning. Unless it is required to understand the change, examples,; code snippets and gory details should be left to bug comments, web; review or the mailing list. * Text formatting and spelling should follow the same rules as documentation; and in-code comments, ex. capitalization, full stop, etc. * If the commit is a bug fix on top of another recently committed patch, or a; revert or reapply of a patch, include the git commit hash of the prior; related commit. This could be as simple as ""Revert commit NNNN because it; caused PR#"". * If the patch has been reviewed, add a link to its review page, as shown; `here <https://www.llvm.org/docs/Phabricator.html#committing-a-change>`__.; If the patch fixes a bug in GitHub Issues, we encourage adding a reference to; the issue being closed, as described; `here <https://llvm.org/docs/BugLifeCycle.html#resolving-closing-bugs>`__. * It is also acceptable to add other metadata to the commit message to automate; processes, including for downstream consumers. This metadata can include; links to resources that are not available to the entire community. However,; such links and/or metadata should not be used in place of making the commit; message self-explanatory. Note that such non-public links should not be; included in the submitted code. For minor violations of these recommendations, the community normally favors; reminding the contributor of this policy over reverting. Minor corrections and; omissions can be handled by sending a reply to the commits mailing list. .. _revert_policy:. Patch reversion policy; ----------------------. As a community, we strongly value having the tip of tree in a good state while; allowing rapid iterative development. As such, we tend to make much heavier; use of reverts to keep the tree healthy than some other open source projects,; and our norms are a bit different. How should you respond if someone reverted your change?. * Remember, it is norm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:17862,message,message,17862,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['message'],['message']
Integrability,"d browser websockets are used. ## Creating web-window. **`ROOT::RWebWindow`** class is represent window instance, which can be displayed in the browser. ```{.cpp}. auto win = ROOT::RWebWindow::Create();. // set HTML page which is showed when window displayed; win->SetDefaultPage(""file:page.html""); // set. // allow unlimitted user connections to the window (default only 1); win->SetConnLimit(0);. // configure predefined geometry; win->SetGeometry(300, 300);. ```. ## Communication. To receive data from the browser, data callback should be assigned.; Callback is invoked when data received from the client or when connection is established.; Normally lambda function is used:. ```{.cpp}. win->SetDataCallBack([](unsigned connid, const std::string &msg) {. printf(""Msg:%s from connection:%u\n"", msg.c_str(), connid);. });. ```. Here **connid** is unique identifier, which assign to each connection when it is established.; There are several predefined messages kinds: **""CONN_READY""** when new connection established and; **""CONN_CLOSED""** when connection is closed by client.; The connection identifier should be used when sending message to the client:. ```{.cpp}. // get connection id for the first connection in the list. if (win->NumConnections() > 0) {; unsigned connid = win->GetConnectionId();; std::string msg = ""Hello, world"";; win->Send(msg, connid);; }. ```. ## Display window. To display window in the browser, one should call `win->Show()` method.; This will starts new window (or new tab) in the default browser and show content of HTML page,; configured for the window. As argument of `Show()` method one can specify browser kind like; ""chromium"" or ""firefox"" or just full path to the program which should be invoked.; With the method `win->GetUrl()` one obtains URL string, which can be typed in the browser address string directly. Same window can be displayed several times in different browsers or different browser tabs - one only; must allow appropriate number of connections c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md:1264,message,messages,1264,documentation/users-guide/WebDisplay.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md,1,['message'],['messages']
Integrability,"d execution one could automatically reload hierarchy (_hreload property) or; update view of displayed object (_update_item property); 5. Use HierarchyPainter for implementing draw.htm. This let us handle; all different kinds of extra attributes in central place; 6. Fix problem in tabs layout - new tab should be add to direct child; 7. When drawing several tabs, activate frame before drawing - only then; real frame size will be set; 8. Fix problem with GetBBox - it only can be used for visible elements in mozilla.; 9. Support drawing of fit parameters in stat box, use (as far as possible) stat and; fit format for statistic display; 10. Implement 'g' formatting kind for stat box output - one need to checks; significant digits when producing output.; 11. Support new draw options for TGraph: 'C', 'B1', '0', '2', '3', '4', '[]'; 12. Primary support for STL containers in IO part. Allows to read ROOT6 TF1.; 13. Full support of TGraphBentErrors; 14. Support objects drawing from JSON files in default user interface, including; monitoring. One could open file from link like: https://root.cern.ch/js/dev/?json=demo/canvas_tf1.json; 15. Introduce JSROOT.FFormat function to convert numeric values into string according; format like 6.4g or 5.7e. Used for statistic display. ## Changes in 3.5; 1. Fix error in vertical text alignment; 2. Many improvements in TPaletteAxis drawing - draw label, avoid too large ticks.; 3. Fix error with col drawing - bin with maximum value got wrong color; 4. Test for existing jquery.js, jquery-ui.js and d3.js libraries, reuse when provided; 5. Fix several I/O problems; now one could read files, produced in Geant4; 6. Implement 'e2' drawing option for TH1 class,; use by default 'e' option when TH1 has non-empty fSumw2; 7. Reuse statistic from histogram itself, when no axis selection done; 8. Support log/lin z scale for color drawing; 9. Implement interactive z-scale selection on TPaletteAxis; 10. Allow to redraw item with other draw options (before one ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:65113,interface,interface,65113,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['interface'],['interface']
Integrability,"d for LLVM.; if (NOT LLVM_ENABLE_PEDANTIC); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -pedantic -Wno-long-long""); endif (). check_cxx_compiler_flag(""-Werror -Wnested-anon-types"" CXX_SUPPORTS_NO_NESTED_ANON_TYPES_FLAG); if( CXX_SUPPORTS_NO_NESTED_ANON_TYPES_FLAG ); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -Wno-nested-anon-types"" ); endif(); endif (). # Determine HOST_LINK_VERSION on Darwin.; set(HOST_LINK_VERSION); if (APPLE AND NOT CMAKE_LINKER MATCHES "".*lld.*""); set(LD_V_OUTPUT); execute_process(; COMMAND sh -c ""${CMAKE_LINKER} -v 2>&1 | head -1""; RESULT_VARIABLE HAD_ERROR; OUTPUT_VARIABLE LD_V_OUTPUT; ); if (HAD_ERROR); message(FATAL_ERROR ""${CMAKE_LINKER} failed with status ${HAD_ERROR}""); endif(); if (""${LD_V_OUTPUT}"" MATCHES "".*ld64-([0-9.]+).*""); string(REGEX REPLACE "".*ld64-([0-9.]+).*"" ""\\1"" HOST_LINK_VERSION ${LD_V_OUTPUT}); elseif (""${LD_V_OUTPUT}"" MATCHES ""[^0-9]*([0-9.]+).*""); string(REGEX REPLACE ""[^0-9]*([0-9.]+).*"" ""\\1"" HOST_LINK_VERSION ${LD_V_OUTPUT}); endif(); message(STATUS ""Host linker version: ${HOST_LINK_VERSION}""); endif(). include(CMakeParseArguments); include(AddClang). set(CMAKE_INCLUDE_CURRENT_DIR ON). include_directories(BEFORE; ${CMAKE_CURRENT_BINARY_DIR}/include; ${CMAKE_CURRENT_SOURCE_DIR}/include; ). if (NOT LLVM_INSTALL_TOOLCHAIN_ONLY); install(DIRECTORY include/clang include/clang-c; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT clang-headers; FILES_MATCHING; PATTERN ""*.def""; PATTERN ""*.h""; PATTERN ""config.h"" EXCLUDE; ). install(DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/include/clang; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT clang-headers; FILES_MATCHING; PATTERN ""CMakeFiles"" EXCLUDE; PATTERN ""*.inc""; PATTERN ""*.h""; ). # Installing the headers needs to depend on generating any public; # tablegen'd headers.; add_custom_target(clang-headers DEPENDS clang-tablegen-targets); set_target_properties(clang-headers PROPERTIES FOLDER ""Misc""); if(NOT LLVM_ENABLE_IDE); add_llvm_install_targets(install-clang-headers; DEPENDS clang-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:13488,message,message,13488,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['message'],['message']
Integrability,"d have gone in case the bindings; were done fully manually.; It is therefore important to consider what manual tools an automatic binder; offers and to make sure they fit your work style and needs, because you are; going to spend a significant amount of time with them. `LLVM dependency`; -----------------. cppyy depends on `LLVM`_, through Cling.; LLVM is properly internalized, so that it doesn't conflict with other uses;; and in particular it is fine to mix `Numba`_ and cppyy code.; It does mean a download cost of about 20MB for the binary wheel (exact size; differs per platform) on installation, and additional `primarily initial`; memory overheads at run-time.; Whether this is onerous depends strongly not only on the application, but; also on the rest of the software stack. The initial cost of loading cppyy, and thus starting the Cling interpreter,; is about 45MB (platform dependent).; Initial uses of standard (e.g. STL) C++ results in deserialization of the; precompiled header at another eventual total cost of about 25MB (again,; platform dependent).; The actual bindings of course also carry overheads.; As a rule of thumb, you should budget for ~100MB all-in for the overhead; caused by the bindings. Other binders do not have this initial memory overhead, but do of course; occur an overhead per module, class, function, etc.; At scale, however, cppyy has some advantages: all binding is lazy (including; the option of automatic loading), standard classes are never duplicated, and; there is no additional ""per-module"" overhead.; Thus, eventually (depending on the number of classes bound, across how many; modules, what use fraction, etc.), this initial cost is recouped when; compared to other binders.; As a rule of thumb, if about 10% of classes are used, it takes several; hundreds of bound classes before the cppyy-approach is beneficial.; In High Energy Physics, from which it originated, cppyy is regularly used in; software stacks of many thousands of classes, where th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:8622,depend,dependent,8622,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['depend'],['dependent']
Integrability,"d in ``DependenceGraphBuilder``. Note also that the steps and the names used in this diagram are for; illustrative purposes and may be different from those in the actual; implementation. Design Trade-offs; -----------------. Advantages:; ^^^^^^^^^^^; - Builder allows graph construction code to be reused for DDG and PDG.; - Builder allows us to create DDG and PDG as separate graphs.; - DDG nodes and edges are completely disjoint from PDG nodes and edges allowing them to change easily and independently. Disadvantages:; ^^^^^^^^^^^^^^; - Builder may be perceived as over-engineering at first.; - There are some similarities between DDG nodes and edges compared to PDG nodes and edges, but there is little reuse of the class definitions. - This is tolerable given that the node and edge types are fairly simple and there is little code reuse opportunity anyway. .. _implementation-details:. Implementation Details; ======================. The current implementation of DDG differs slightly from the dependence; graph described in [1]_ in the following ways:. 1. The graph nodes in the paper represent three main program components, namely *assignment statements*, *for loop headers* and *while loop headers*. In this implementation, DDG nodes naturally represent LLVM IR instructions. An assignment statement in this implementation typically involves a node representing the ``store`` instruction along with a number of individual nodes computing the right-hand-side of the assignment that connect to the ``store`` node via a def-use edge. The loop header instructions are not represented as special nodes in this implementation because they have limited uses and can be easily identified, for example, through ``LoopAnalysis``.; 2. The paper describes five types of dependency edges between nodes namely *loop dependency*, *flow-*, *anti-*, *output-*, and *input-* dependencies. In this implementation *memory* edges represent the *flow-*, *anti-*, *output-*, and *input-* dependencies. However, *",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:4911,depend,dependence,4911,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,1,['depend'],['dependence']
Integrability,"d in a root file but its base; class(es) is(are). The reason can be that this class has no data members; worth saving or all real info is in the base classes. The version number; is written to the file in the `Streamer` by the call; `TBuffer::WriteVersion`. You, as the designer of the class, do not need; to do any manual modification in the `Streamer`. ROOT schema evolution; mechanism is automatic and handled by the `StreamerInfo`. ### Manual Data Model Evolution Capabilities. The automatic data model schema evolution implemented in ROOT makes it possible; to read back the serialized data object in the situation when the definition of; the classes those objects represent changed slightly (some of the data members were; removed or some new ones added). It is also possible to manually specify the rules; for more sophisticated data transformations done while reading to load the serialized; objects into data structures that changed quite significantly. ROOT provides two interface enabling users to specify the conversion rules. The; first way is to define a rule in the dictionary file and the second way is to insert; it to the TClass object using the C++ API. There are two types of conversion rules. The first of them, the normal rules, are; the ones that should be used in the most of the cases. They provide a buffered input; data and an address of the in-memory target object and allow user to specify the; conversion function mapping the data being read to the output format. The second type; of the rules, the raw rules, also provide the pointer to the target object but the; input is a raw TBuffer object containing the input data member declared as an input; to the rule. This type of a rule is provided mainly to handle the file format changes; that couldn't have been handled otherwise and in general should not be used unless there; is no other option. #### The dictionaries. The most convenient place to specify the conversion rules is a dictionary. One can; do that either i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:77112,interface,interface,77112,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['interface'],['interface']
Integrability,"d in the `ROOT::Math` namespace are:. - Basic special functions like the gamma, beta and error function. - Mathematical functions used in statistics, such as the probability; density functions and the cumulative distributions functions (lower; and upper integral of the pdf's). - Generic function classes and interfaces; for evaluating one-dimensional (`ROOT::Math::IBaseFunctiononeDim`) and multi-dimensional functions; (`ROOT::Math::IBaseFunctionMultiDim`) and parametric function interfaces for evaluating functions with parameters in one; (`ROOT::Math::IParametricFunctionOneDim`) or multi dimensions (`ROOT::Math::IParametricFunctionMultiDim`).; 	A set of user convenient wrapper classes, such as `ROOT::Math::Functor` is provided for wrapping user-classes in the needed interface,; 	required to use the algorithms of the `ROOT` Mathematical libraries. - Numerical algorithms interfaces and in same cases default implementations for:; - numerical integration;; - numerical differentiation;; 	- one dimensional root-finding;; 	- one-dimensional minimization;; 	- multi-dimensional minimization (only the `ROOT::Math::Minimizer` interface). - Fitting classes: set of classes for fitting generic data sets. These classes are provided in the namespace `ROOT::Fit`.; They are describing separately in the Fitting chapter. The sets described above is independent of ROOT libraries and can be built as a set of standalone classes.; In addition `MathCore` provides the following classes (depending on ROOT *libCore* library):. - `TMath`: namespace with mathematical functions and basic function algorithms.; - `TComplex`: class for complex numbers.; - Random classes: the base class `TRandom` and the derived classes `TRandom1`, `TRandom2` and `TRandom3`, implementing the pseudo-random number generators. A detailed description for all `MathCore` classes is available in the Doxygen; [online reference documentation](online reference documentation). ## MathMore Library. The `MathMore` library provides",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:1972,interface,interfaces,1972,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,3,"['integrat', 'interface']","['integration', 'interface', 'interfaces']"
Integrability,"d in working on,; different pieces of this will be useful to you. In any case, you should be; familiar with the `target description`_ and `machine code representation`_; classes. If you want to add a backend for a new target, you will need to; `implement the target description`_ classes for your new target and understand; the :doc:`LLVM code representation <LangRef>`. If you are interested in; implementing a new `code generation algorithm`_, it should only depend on the; target-description and machine code representation classes, ensuring that it is; portable. Required components in the code generator; -----------------------------------------. The two pieces of the LLVM code generator are the high-level interface to the; code generator and the set of reusable components that can be used to build; target-specific backends. The two most important interfaces (:raw-html:`<tt>`; `TargetMachine`_ :raw-html:`</tt>` and :raw-html:`<tt>` `DataLayout`_; :raw-html:`</tt>`) are the only ones that are required to be defined for a; backend to fit into the LLVM system, but the others must be defined if the; reusable code generator components are going to be used. This design has two important implications. The first is that LLVM can support; completely non-traditional code generation targets. For example, the C backend; does not require register allocation, instruction selection, or any of the other; standard components provided by the system. As such, it only implements these; two interfaces, and does its own thing. Note that C backend was removed from the; trunk since LLVM 3.1 release. Another example of a code generator like this is a; (purely hypothetical) backend that converts LLVM to the GCC RTL form and uses; GCC to emit machine code for a target. This design also implies that it is possible to design and implement radically; different code generators in the LLVM system that do not make use of any of the; built-in components. Doing so is not recommended at all, but could be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:3549,interface,interfaces,3549,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['interface'],['interfaces']
Integrability,"d integer specified in bytes, and must be; power of two;; - ``<target-specific>`` is either true or false. Example:. .. code-block:: text. constants:; - id: 0; value: 'double 3.250000e+00'; alignment: 8; - id: 1; value: 'g-(LPC0+8)'; alignment: 4; isTargetSpecific: true. Global Value Operands; ^^^^^^^^^^^^^^^^^^^^^. The global value machine operands reference the global values from the; :ref:`embedded LLVM IR module <embedded-module>`.; The example below shows an instance of the X86 ``MOV64rm`` instruction that has; a global value operand named ``G``:. .. code-block:: text. $rax = MOV64rm $rip, 1, _, @G, _. The named global values are represented using an identifier with the '@' prefix.; If the identifier doesn't match the regular expression; `[-a-zA-Z$._][-a-zA-Z$._0-9]*`, then this identifier must be quoted. The unnamed global values are represented using an unsigned numeric value with; the '@' prefix, like in the following examples: ``@0``, ``@989``. Target-dependent Index Operands; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A target index operand is a target-specific index and an offset. The; target-specific index is printed using target-specific names and a positive or; negative offset. For example, the ``amdgpu-constdata-start`` is associated with the index ``0``; in the AMDGPU backend. So if we have a target index operand with the index 0; and the offset 8:. .. code-block:: text. $sgpr2 = S_ADD_U32 _, target-index(amdgpu-constdata-start) + 8, implicit-def _, implicit-def _. Jump-table Index Operands; ^^^^^^^^^^^^^^^^^^^^^^^^^. A jump-table index operand with the index 0 is printed as following:. .. code-block:: text. tBR_JTr killed $r0, %jump-table.0. A machine jump-table entry contains a list of ``MachineBasicBlocks``. When serializing all the function's jump-table entries, the following format is used:. .. code-block:: text. jumpTable:; kind: <kind>; entries:; - id: <index>; blocks: [ <bbreference>, <bbreference>, ... ]. where ``<kind>`` is describing how the jump ta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:18672,depend,dependent,18672,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['depend'],['dependent']
Integrability,"d links them together; into a single LLVM bitcode file. It writes the output file to standard output,; unless the :option:`-o` option is used to specify a filename. OPTIONS; -------. .. option:: -f. Enable binary output on terminals. Normally, :program:`llvm-link` will refuse; to write raw bitcode output if the output stream is a terminal. With this; option, :program:`llvm-link` will write raw bitcode regardless of the output; device. .. option:: -o filename. Specify the output file name. If ``filename`` is ""``-``"", then; :program:`llvm-link` will write its output to standard output. .. option:: -S. Write output in LLVM intermediate language (instead of bitcode). .. option:: -d. If specified, :program:`llvm-link` prints a human-readable version of the; output bitcode file to standard error. .. option:: --help. Print a summary of command line options. .. option:: -v. Verbose mode. Print information about what :program:`llvm-link` is doing.; This typically includes a message for each bitcode file linked in and for each; library found. .. option:: --override <filename>. Adds the passed-in file to the link and overrides symbols that have already; been declared with the definitions in the file that is passed in. This flag; can be specified multiple times to have multiple files act as overrides. If; a symbol is declared more than twice, the definition from the file declared; last takes precedence. .. option:: --import <function:filename>. Specify a function that should be imported from the specified file for; linking with ThinLTO. This option can be specified multiple times to import; multiple functions. .. option:: --summary-index <filename>. Specify the path to a file containing the module summary index with the; results of an earlier ThinLTO link. This option is required when ; `--import` is used. .. option:: --internalize. Internalize the linked symbols. .. option:: --disable-debug-info-type-map. Disables the use of a uniquing type map for debug info. .. option:: --on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-link.rst:1221,message,message,1221,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-link.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-link.rst,1,['message'],['message']
Integrability,"d merge the ``subgroupAdd`` above the if-statement, it; would sum up the ``delta`` across *all* threads instead. The compiler frontend can emit IR that expresses the convergence constraints; as follows:. .. code-block:: llvm. define void @example_kernel() convergent {; %entry = call token @llvm.experimental.convergence.entry(); %delta = ...; %cc = icmp sgt i32 %delta, 0; br i1 %cc, label %then, label %else. then:; %total_gains = call i32 @subgroupAdd(i32 %delta) [ ""convergencectrl""(token %entry) ]; ...; br label %end. else:; %total_losses = call i32 @subgroupAdd(i32 %delta) [ ""convergencectrl""(token %entry) ]; ...; br label %end. end:; ...; }. The entry intrinsic behaves like in the previous example: assuming that; ``@example_kernel`` is an OpenCL kernel (as hinted at by the ""subgroup""; terminology), we expect it to communicate among all threads within the; ""subgroup"". This typically maps to a SIMD vector on GPU hardware. The calls to ``@subgroupAdd`` use the token produced by the entry intrinsic,; but they also have an additional control dependency. According to the rules; defined in this document, they only communicate among the subset of threads; that actually end up executing the respective (static) call site. Hoisting them would remove the control dependency and cause them to communicate; among the full set of threads that the entry intrinsic communicated with.; Again, hoisting is allowed if it can be proven that ``%cc`` is always uniform; among the relevant set of threads: in that case, the ``@subgroupAdd`` already; communicates among the full set of threads in the original program. Motivating Examples of Convergence Control; ==========================================. (This section is informative.). Unstructured control flow; -------------------------. Consider an example of how jump threading removes structure in a way that can; make semantics non-obvious without the convergence intrinsics described in this; document:. .. code-block:: llvm. void example_origi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:8193,depend,dependency,8193,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['depend'],['dependency']
Integrability,"d profit; from an increased flexibility and functionality and make it also; extendable (recursiveness, new algorithms, new functionality). What M does not:. - histogramming. - data handling. - graphics. M is kept as a low-level package with optimal performance. The main usages of M are. - from a user's program (such as int main()...). - from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. - its numerical accuracy (equivalent to its Fortran version). - its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a; two-way strategy was imposed:. - a minimal required interface with minimum interaction with M objects; and with appropriate usage of the standard library (STL): the user's; implementation of the FCNBase class, initial parameter values and; uncertainties are provided by the to M user via std::vectors. - a rich interface which provides the user with more functionality; such as interaction with parameters. The core of the minimization functionality and related tools (the kernel; of M ) should be clearly separated from the user, who is interfacing via; defined user interfaces (the API). ## Internal and external parameters ##. Each of the parameters to the $\mbox{FCN}$ is defined by the user as; belonging to one of the following types:. - Freely variable: allowed to take on any value. - Variable with double sided limits: allowed to vary only between two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:4710,interface,interface,4710,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interface']
Integrability,"d punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup in parameters; Unknown. 193; TC1; Order of destruction of local automatics of destructor; Unknown. 194; TC1; Identifying constructors; Yes. 195; CD1; Converting between function and object pointers; Yes. 196; open; Arguments to deallocation functions; Not resolved. 197; CD1; Issues with two-stage lookup of dependent names; Yes. 198; CD1; Definition of ""use"" in local and nested classes; Yes. 199; CD1; Order of destruction of temporaries; Unknown. 200; dup; Partial ordering and explicit arguments; Duplicate of 214. 201; CD1; Order of destruction of temporaries in initializers; Unknown. 202; TC1; Use of overloaded function name; Clang 3.1. 203; NAD; Type of address-of-member expression; Unknown. 204; CD1; Exported class templates; No. 205; drafting; Templates and static data members; Not resolved. 206; TC1; Semantic constraints on non-dependent names; Yes. 207; CD1; using-declarations and protected access; Yes. 208; CD1; Rethrowing exceptions in nested handlers; Unknown. 209; NAD; Must friend declaration names be; accessible?; Clang 3.2. 210; TC1; What is the type matched by an exception handler?; Unknown. 211; NAD; Constructors should not be allowed to return normally after an exception; Yes. 212; CD4; Implicit instantiation is not described clearly enough; Unknown. 213; TC1; Lookup in dependent base classes; Yes. 214; CD1; Partial ordering of function templates is underspecified; Yes. 215; CD1; Template parameters are not allowed in nested-name-specifiers; Clang 2.9. 216; CD1; Linkage of nameless class-scope enumeration types; No. 217; TC1; Default arguments for non-template member functions of class templates; Yes. 218; CD1; Specification of Koenig lookup; Yes. 219; NAD; Cannot defend against destructors that throw exceptions; N/A. 220; CD1; All deallocation functions should be required not to throw; N/A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:13579,depend,dependent,13579,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"d resolution order (mro), including for classes and thus; also for meta-classes.; In Python2, it was possible to resolve any mro conflicts automatically, but; meta-classes in Python3, although syntactically richer, have functionally; become far more limited.; In particular, the mro is checked in the builtin class builder, instead of; in the meta-class of the meta-class (which in Python3 is the builtin ``type``; rather than the meta-class itself as in Python2, another limitation, and; which actually checks the mro a second time for no reason).; The upshot is that a helper is required (``cppyy.multi``) to resolve the mro; to support Python3.; The helper is written to also work in Python2.; Example:. .. code-block:: python. >>> class PyConcrete(cppyy.multi(cppyy.gbl.Abstract1, cppyy.gbl.Abstract2)):; ... def abstract_method1(self):; ... return ""first message""; ... def abstract_method2(self):; ... return ""second message""; ...; >>> pc = PyConcrete(); >>> cppyy.gbl.call_abstract_method1(pc); first message; >>> cppyy.gbl/call_abstract_method2(pc); second message; >>>. Contrary to multiple inheritance in Python, in C++ there are no two separate; instances representing the base classes.; Thus, a single ``__init__`` call needs to construct and initialize all bases,; rather than calling ``__init__`` on each base independently.; To support this syntax, the arguments to each base class should be grouped; together in a tuple.; If there are no arguments, provide an empty tuple (or omit them altogether,; if these arguments apply to the right-most base(s)). .. _sec-methods-label:. `Methods`; ---------. C++ methods are represented as Python ones: these are first-class objects and; can be bound to an instance.; If a method is virtual in C++, the proper concrete method is called, whether; or not the concrete class is bound.; Similarly, if all classes are bound, the normal Python rules apply:. .. code-block:: python. >>> c.abstract_method(); called Concrete::abstract_method; >>> c.concr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst:6490,message,message,6490,bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,1,['message'],['message']
Integrability,"d sloc>> <invalid sloc>; `-CXXRecordDecl 0x6c7e30 <line:2:7, col:13> col:13 class MyClass definition; |-DefinitionData pass_in_registers standard_layout trivially_copyable trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-CXXRecordDecl 0x6c7f48 <col:7, col:13> col:13 implicit class MyClass; |-FieldDecl 0x6c7ff0 <line:3:9, col:13> col:13 m1 'int'; `-FieldDecl 0x6c8058 <line:4:9, col:13> col:13 m2 'int'. We can spare the call for ``ImportDefinition`` if we set up the importer to do a ""normal"" (not minimal) import. .. code-block:: cpp. ASTImporter Importer( .... /*MinimalImport=*/false);. With **normal import**, all dependent declarations are imported normally.; However, with minimal import, the dependent Decls are imported without definition, and we have to import their definition for each if we later need that. Putting this all together here is how the source of the tool looks like:. .. code-block:: cpp. #include ""clang/AST/ASTImporter.h""; #include ""clang/ASTMatchers/ASTMatchFinder.h""; #include ""clang/ASTMatchers/ASTMatchers.h""; #include ""clang/Tooling/Tooling.h"". using namespace clang;; using namespace tooling;; using namespace ast_matchers;. template <typename Node, typename Matcher>; Node *getFirstDecl(Matcher M, const std::unique_ptr<ASTUnit> &Unit) {; auto MB = M.bind(""bindStr""); // Bind the to-be-matched node to a string key.; auto MatchRes = match(MB, Unit->getASTContext());; // We should have at least one match.; assert(MatchRes.size() >= 1);; // Get the first matched and bound node.; Node *Result =; const_cast<Node *>(MatchRes[0].template getNodeAs<Node>(""bindStr""));; assert(Result);; return Re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:8554,depend,dependent,8554,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,1,['depend'],['dependent']
Integrability,"d the actual length of the buffer. Section; `Maintaining correctness of bounds annotations`_ provides more details about; this programming model. .. code-block:: c. int g;. void foo(int *__counted_by(count) p, size_t count) {; count++; // may violate the invariant of __counted_by; count--; // may violate the invariant of __counted_by if count was 0.; count = g; // may violate the invariant of __counted_by; // depending on the value of `g`.; }. The requirement to annotate all pointers with explicit bounds information could; present a significant adoption burden. To tackle this issue, the model; incorporates the concept of a ""wide pointer"" (a.k.a. fat pointer) – a larger; pointer that carries bounds information alongside the pointer value. Utilizing; wide pointers can potentially reduce the adoption burden, as it contains bounds; information internally and eliminates the need for explicit bounds annotations.; However, wide pointers differ from standard C pointers in their data layout,; which may result in incompatibilities with the application binary interface; (ABI). Breaking the ABI complicates interoperability with external code that has; not adopted the same programming model. ``-fbounds-safety`` harmonizes the wide pointer and the bounds annotation; approaches to reduce the adoption burden while maintaining the ABI. In this; model, local variables of pointer type are implicitly treated as wide pointers,; allowing them to carry bounds information without requiring explicit bounds; annotations. Please note that this approach doesn't apply to function parameters; which are considered ABI-visible. As local variables are typically hidden from; the ABI, this approach has a marginal impact on it. In addition,; ``-fbounds-safety`` employs compile-time restrictions to prevent implicit wide; pointers from silently breaking the ABI (see `ABI implications of default bounds; annotations`_). Pointers associated with any other variables, including function; parameters, are treat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:5617,interface,interface,5617,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['interface'],['interface']
Integrability,"d the same as ``m``.; - ``r``: A 32 or 64-bit integer register.; - ``b``: A 32 or 64-bit integer register, excluding ``R0`` (that is:; ``R1-R31``).; - ``f``: A 32 or 64-bit float register (``F0-F31``),; - ``v``: For ``4 x f32`` or ``4 x f64`` types, a 128-bit altivec vector; register (``V0-V31``). - ``y``: Condition register (``CR0-CR7``).; - ``wc``: An individual CR bit in a CR register.; - ``wa``, ``wd``, ``wf``: Any 128-bit VSX vector register, from the full VSX; register set (overlapping both the floating-point and vector register files).; - ``ws``: A 32 or 64-bit floating-point register, from the full VSX register; set. RISC-V:. - ``A``: An address operand (using a general-purpose register, without an; offset).; - ``I``: A 12-bit signed integer immediate operand.; - ``J``: A zero integer immediate operand.; - ``K``: A 5-bit unsigned integer immediate operand.; - ``f``: A 32- or 64-bit floating-point register (requires F or D extension).; - ``r``: A 32- or 64-bit general-purpose register (depending on the platform; ``XLEN``).; - ``vr``: A vector register. (requires V extension).; - ``vm``: A vector register for masking operand. (requires V extension). Sparc:. - ``I``: An immediate 13-bit signed integer.; - ``r``: A 32-bit integer register.; - ``f``: Any floating-point register on SparcV8, or a floating-point; register in the ""low"" half of the registers on SparcV9.; - ``e``: Any floating-point register. (Same as ``f`` on SparcV8.). SystemZ:. - ``I``: An immediate unsigned 8-bit integer.; - ``J``: An immediate unsigned 12-bit integer.; - ``K``: An immediate signed 16-bit integer.; - ``L``: An immediate signed 20-bit integer.; - ``M``: An immediate integer 0x7fffffff.; - ``Q``: A memory address operand with a base address and a 12-bit immediate; unsigned displacement.; - ``R``: A memory address operand with a base address, a 12-bit immediate; unsigned displacement, and an index register.; - ``S``: A memory address operand with a base address and a 20-bit immediate;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:230959,depend,depending,230959,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depending']
Integrability,"d to be performed to produce; intermediate or final outputs (in some cases, like ``-fsyntax-only``,; there is no ""real"" final output). Phases are well known compilation; steps, such as ""preprocess"", ""compile"", ""assemble"", ""link"", etc. #. **Bind: Tool & Filename Selection**. This stage (in conjunction with the Translate stage) turns the tree; of Actions into a list of actual subprocess to run. Conceptually, the; driver performs a top down matching to assign Action(s) to Tools. The; ToolChain is responsible for selecting the tool to perform a; particular action; once selected the driver interacts with the tool; to see if it can match additional actions (for example, by having an; integrated preprocessor). Once Tools have been selected for all actions, the driver determines; how the tools should be connected (for example, using an inprocess; module, pipes, temporary files, or user provided filenames). If an; output file is required, the driver also computes the appropriate; file name (the suffix and file location depend on the input types and; options such as ``-save-temps``). The driver interacts with a ToolChain to perform the Tool bindings.; Each ToolChain contains information about all the tools needed for; compilation for a particular architecture, platform, and operating; system. A single driver invocation may query multiple ToolChains; during one compilation in order to interact with tools for separate; architectures. The results of this stage are not computed directly, but the driver; can print the results via the ``-ccc-print-bindings`` option. For; example:. .. code-block:: console. $ clang -ccc-print-bindings -arch i386 -arch ppc t0.c; # ""i386-apple-darwin9"" - ""clang"", inputs: [""t0.c""], output: ""/tmp/cc-Sn4RKF.s""; # ""i386-apple-darwin9"" - ""darwin::Assemble"", inputs: [""/tmp/cc-Sn4RKF.s""], output: ""/tmp/cc-gvSnbS.o""; # ""i386-apple-darwin9"" - ""darwin::Link"", inputs: [""/tmp/cc-gvSnbS.o""], output: ""/tmp/cc-jgHQxi.out""; # ""ppc-apple-darwin9"" - ""gcc::Compile"", input",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:9276,depend,depend,9276,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['depend'],['depend']
Integrability,"d to detect the standard ""``#ifndef XX`` / ``#define XX``""; idiom that people typically use to prevent multiple inclusion of headers. If a; buffer uses this idiom and is subsequently ``#include``'d, the preprocessor can; simply check to see whether the guarding condition is defined or not. If so,; the preprocessor can completely ignore the include of the header. .. _Parser:. The Parser Library; ==================. This library contains a recursive-descent parser that polls tokens from the; preprocessor and notifies a client of the parsing progress. Historically, the parser used to talk to an abstract ``Action`` interface that; had virtual methods for parse events, for example ``ActOnBinOp()``. When Clang; grew C++ support, the parser stopped supporting general ``Action`` clients --; it now always talks to the :ref:`Sema library <Sema>`. However, the Parser; still accesses AST objects only through opaque types like ``ExprResult`` and; ``StmtResult``. Only :ref:`Sema <Sema>` looks at the AST node contents of these; wrappers. .. _AST:. The AST Library; ===============. .. _ASTPhilosophy:. Design philosophy; -----------------. Immutability; ^^^^^^^^^^^^. Clang AST nodes (types, declarations, statements, expressions, and so on) are; generally designed to be immutable once created. This provides a number of key; benefits:. * Canonicalization of the ""meaning"" of nodes is possible as soon as the nodes; are created, and is not invalidated by later addition of more information.; For example, we :ref:`canonicalize types <CanonicalType>`, and use a; canonicalized representation of expressions when determining whether two; function template declarations involving dependent expressions declare the; same entity.; * AST nodes can be reused when they have the same meaning. For example, we; reuse ``Type`` nodes when representing the same type (but maintain separate; ``TypeLoc``\s for each instance where a type is written), and we reuse; non-dependent ``Stmt`` and ``Expr`` nodes across",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:57438,wrap,wrappers,57438,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['wrap'],['wrappers']
Integrability,"d to ensure the above points are met and to reduce clutter. ### Your Commit Message. The commit summary (i.e. the first line of the commit message) should be preceded by the a tag indicating the scope of; ROOT that is affected by your commit, in square brackets. Most tags are self-describing (e.g., `[tree]` indicates a; change to TTree, `[RF]` indicates a change to RooFit). If you are unsure about which scope tags to use, we are happy to; point you in the right direction! See also the [commit log](https://github.com/root-project/root/commits/master/) for; examples. The summary itself should not exceed 50 characters (excluding the scope tag), be meaningful (i.e., it; describes the change) and should be written in the; [present imperative mood](https://git.kernel.org/pub/scm/git/git.git/tree/Documentation/SubmittingPatches?id=HEAD#n239); (e.g. `Add this awesome feature` instead of `Adds this awesome feature` or `Added this awesome feature`). The commit message that follow the summary can be used to provide more context to the change.; It should describe the **why**, rather than the **what** and **how** (we can gather this from the commit summary and the; change diff, respectively).; The commit message should be wrapped at 72 characters. > [!TIP]; > We provide a commit message template to help with following the above guidelines. It can be found in the root of this; > repository as [`.git-commit-template`](https://github.com/root-project/root/blob/master/.git-commit-template),; > and can be set to automatically be used for every commit with the following command:; > ```sh; > $ git config commit.template .git-commit-template; > ```. ## Your Pull Request. > [!NOTE]; > For the mechanics on how to create pull requests, please visit; > [this page](https://root.cern/for_developers/creating_pr). The title of your PR follows the same principle as the commit summary. If your PR only involves one commit, you can; reuse this summary. For non-functional changes (e.g. to the docume",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md:3205,message,message,3205,CONTRIBUTING.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md,1,['message'],['message']
Integrability,"d unbinned datasets; (representation as a RooDataSet with weights). The setWeightVar() method has been deprecated as it is very difficult to support on-the-fly redefinition; of the event weight variable in the new data store scheme. To declare a data set weighed,; use the WeightVar() modifier of the constructor instead,e.g.:. RooDataSet wdata(""wdata"",""wdata"",RooArgSet(x,y,wgt),WeightVar(wgt)) ;. The RooHist class that represents data as a histogram in a RooPlot has been modified; so that it can show approximate Poisson errors for non-integer data. These approximate; errors are calculated from interpolation of the error bars of the nearest integers. NB: A weighted dataset; plotted with RooAbsData::plotOn() will be default show sum-of-weights-squared errors. Only; when Poisson error are forced through a DataError(RooAbsData::Poisson) argument these; approximate Poisson error bars are shown. Miscellaneous improvements other. The RooFit messagee service class RooMsgService has been augmented with a stack that; can store its configurate state information. A call to saveState() will save the; present configuration, which can be restored through a subsequent call to restoreState().; In addition to the method RooAbsArg::printCompactTree() which is mostly intende for; debugging, a new method RooAbsArg::printComponentTree() has been added that prints; the tree structure of a pdf in a more user-friendly content oriented way. The printing ; of the leaf nodes (the variables) is omitted in this method to keep the output compact. RooStats. This release contains significant bug fixes and it is strongly; recommended to update to this version if using older ones. . Major Changes in LimitCalculator and HypoTestCalculator classes: usage of ModelConfig class. The RooStats calculator interfaces have been changed to use the ModelConfig class.; All the setter methods with the parameter lists, pdf instances and name have been removed from the interfaces.; The SetWorkspace(RooWorkspace & ) ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:10688,message,messagee,10688,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,1,['message'],['messagee']
Integrability,"d will be removed. Please remove them from the rootcling invocations.; * rootcling legacy cint flags `+P`, `+V` and `+STUB` have no effect and will be; removed. Please remove them from the rootcling invocations.; * genreflex flag `--deep` has no effect and will be removed. Please remove it; from the genreflex invocation.; * rootcling warns if it sees and unrecognized flag (usually coming from the; CXXFLAGS of the build system). Please remove them from the invocation because; the warning will become a hard error in the next releases.; * The empty headers `Gtypes.h` and `Htypes.h` are deprecated. Please include; `Rtypes.h`; * TInterpreter::EnableAutoLoading currently does nothing and is deprecated. ### Deprecated packages. ### Removed packages. ## Core Libraries. * Speed-up startup, in particular in case of no or poor network accesibility, by avoiding; a network access that was used as input to generate a globally unique ID for the current; process.; * This network access is replaced by a passive scan of the network interface. This; reduces somewhat the uniqueness of the unique ID as the IP address is no longer; guaranteed by the DNS server to be unique. Note that this was already the case when; the network access (used to look up the hostname and its IP address) failed. ## I/O Libraries. * TFile: A new bit `TFile::kReproducible` was introduced. It can be enabled by; specifying the `""reproducible""` url option when creating the file:; ~~~ {.cpp}; TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; ~~~; Unlike regular `TFile`s, the content of such file has reproducible binary; content when writing exactly same data. This achieved by writing pre-defined; values for creation and modification date of TKey/TDirectory objects and null; value for TUUID objects inside TFile. As drawback, TRef objects stored in such; file cannot be read correctly.; * Significantly improved the scaling of hadd tear-down/cleanup-phase in the presence; of large number histogr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md:2978,interface,interface,2978,README/ReleaseNotes/v620/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md,1,['interface'],['interface']
Integrability,"d*.; ==================================== ====================================================. *Type* may be specified using message *name* or message *id*. *Op* may be specified using operation *name* or operation *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ============================== ============ ==========; MSG_INTERRUPT 1 \- \- \-; MSG_GS 2 GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_GS_DONE 3 GS_OP_NOP 0 \-; \ GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_SYSMSG 15 SYSMSG_OP_ECC_ERR_INTERRUPT 1 \-; \ SYSMSG_OP_REG_RD 2 \-; \ SYSMSG_OP_HOST_TRAP_ACK 3 \-; \ SYSMSG_OP_TTRACE_PC 4 \-; ====================== ========== ============================== ============ ==========. *Sendmsg* arguments are validated depending on how *type* value is specified:. * If message *type* is specified by name, arguments values must satisfy limitations detailed in the table above.; * If message *type* is specified as a number, each argument must not exceed the corresponding value range (see the first table). Examples:. .. parsed-literal::. // numeric message code; msg = 0x10; s_sendmsg 0x12; s_sendmsg msg + 2. // sendmsg with strict arguments validation; s_sendmsg sendmsg(MSG_INTERRUPT); s_sendmsg sendmsg(MSG_GS, GS_OP_EMIT); s_sendmsg sendmsg(MSG_GS, 2); s_sendmsg sendmsg(MSG_GS_DONE, GS_OP_EMIT_CUT, 1); s_sendmsg sendmsg(MSG_SYSMSG, SYSMSG_OP_TTRACE_PC). // sendmsg with validation of value range only; msg = 2; op = 3; stream = 1; s_sendmsg sendmsg(msg, op, stream); s_sendmsg sendmsg(2, GS_OP_CUT); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_msg.rst:2559,depend,depending,2559,interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx7_msg.rst,4,"['depend', 'message']","['depending', 'message']"
Integrability,"d-jam; as well as an additional inner loop unrolling. If no follow-up; attribute specified for a generated loop, it is added automatically. Loop Distribution; -----------------. The LoopDistribution pass tries to separate vectorizable parts of a loop; from the non-vectorizable part (which otherwise would make the entire; loop non-vectorizable). Conceptually, it transforms a loop such as. .. code-block:: c. for (int i = 1; i < n; i+=1) { // original loop; A[i] = i;; B[i] = 2 + B[i];; C[i] = 3 + C[i - 1];; }. into the following code:. .. code-block:: c. if (rtc) {; for (int i = 1; i < n; i+=1) // coincident loop; A[i] = i;; for (int i = 1; i < n; i+=1) // coincident loop; B[i] = 2 + B[i];; for (int i = 1; i < n; i+=1) // sequential loop; C[i] = 3 + C[i - 1];; } else {; for (int i = 1; i < n; i+=1) { // fallback loop; A[i] = i;; B[i] = 2 + B[i];; C[i] = 3 + C[i - 1];; }; }. where ``rtc`` is a generated runtime check. ``llvm.loop.distribute.followup_coincident`` sets the loop attributes of; all loops without loop-carried dependencies (i.e. vectorizable loops).; There might be more than one such loops. If not defined, the loops will; inherit the original loop's attributes. ``llvm.loop.distribute.followup_sequential`` sets the loop attributes of the; loop with potentially unsafe dependencies. There should be at most one; such loop. If not defined, the loop will inherit the original loop's; attributes. ``llvm.loop.distribute.followup_fallback`` defines the loop attributes; for the fallback loop, which is a copy of the original loop for when; loop versioning is required. If undefined, the fallback loop inherits; all attributes from the original loop. Attributes defined in ``llvm.loop.distribute.followup_all`` are added to; all of the aforementioned output loops. It is recommended to add ``llvm.loop.disable_nonforced`` to; ``llvm.loop.distribute.followup_fallback``. This avoids that the; fallback version (which is likely never executed) is further optimized; which would incr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:11758,depend,dependencies,11758,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['depend'],['dependencies']
Integrability,"d-just-interpreting-cpp/>`_; - *Vassil Vassilev* 2021 The LLVM Project Blog; - This blog page discusses how Cling enables template Instantiation on demand, language interoperability on demand, interpreter/compiler as a service, plugins extension.; * - `TinySpec-Cling <https://github.com/nwoeanhinnogaehr/tinyspec-cling>`_; - Noah Weninger 2020; - A tiny C++ live-coded overlap-add (re)synthesizer for Linux, which uses Cling to add REPL-like functionality for C++ code.; * - `Interactive C++ for Data Science <https://blog.llvm.org/posts/2020-12-21-interactive-cpp-for-data-science/>`_; - *Vassil Vassilev,* *David Lange,* *Simeon Ehrig,* *Sylvain Corlay* 2020 The LLVM Project Blog; - Cling enables eval-style programming for Data Science applications. Examples of ROOT and Xeus-Cling for data science are shown.; * - `Interactive C++ with Cling <https://blog.llvm.org/posts/2020-11-30-interactive-cpp-with-cling/>`_; - *Vassil Vassilev* 2020 The LLVM Project Blog; - This blog page briefly discusses the concept of interactive C++ by presenting Cling’s main features, such as wrapper functions, entity redefinition, error recovery. ; * - `Using the Cling C++ Interpreter on the Bela Platform <https://gist.github.com/jarmitage/6e411ae8746c04d6ecbee1cbc1ebdcd4>`_; - Jack Armitage 2019; - Cling has been installed on a BeagleBoard to bring live coding to the Bela interactive audio platform.; * - `Implementation of GlobalModuleIndex in ROOT and Cling <https://indico.cern.ch/event/840376/contributions/3525646/attachments/1895398/3127159/GSoC_Presentation__GMI.pdf>`_; - *Arpitha Raghunandan* 2012 Google Summer of Code GSoC; - GlobalModuleIndex can be used for improving ROOT’s and Cling’s performance ; * - `Example project using cling as library <https://github.com/root-project/cling/tree/master/tools/demo>`_; - *Axel Naumann* 2016 GitHub; - This video showcases how to use Cling as a library, and shows how to set up a simple CMake configuration that uses Cling.; * - `Cling C++ interpreter t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst:3732,wrap,wrapper,3732,interpreter/cling/docs/chapters/references.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst,1,['wrap'],['wrapper']
Integrability,"d.; Painting it produced a dot with the X11 backend.; * New class `TRatioPlot` implemented by Paul Gessinger <hello@paulgessinger.com>.; Class for displaying ratios, differences and fit residuals. `TRatioPlot` has two constructors, one which accepts two histograms, and is responsible; for setting up the calculation of ratios and differences. This calculation is in part; delegated to `TEfficiency`. A single option can be given as a parameter, that is; used to determine which procedure is chosen. The remaining option string is then; passed through to the calculation, if applicable. Several examples illustrate how to use this class. See:; `$ROOTSYS/tutorials/hist/ratioplot?.C`. * New option ""I"" allowing to draw TGraph with invisible axis (used by `TRatioPlot`);. ## New histogram drawing options. ### COL2; COL2 is a new rendering technique providing potential performance improvements; compared to the standard COL option. The performance comparison of the COL2 to; the COL option depends on the histogram and the size of the rendering region in; the current pad. In general, a small (approx. less than 100 bins per axis),; sparsely populated TH2 will render faster with the COL option. However, for larger histograms (approx. more than 100 bins per axis) that are; not sparse, the COL2 option will provide up to 20 times performance improvements.; For example, a 1000x1000 bin TH2 that is not sparse will render an order of; magnitude faster with the COL2 option. The COL2 option will also scale its performance based on the size of the pixmap; the histogram image is being rendered into. It also is much better optimized for; sessions where the user is forwarding X11 windows through an `ssh` connection. For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; and COLZ options. There is one major difference and that concerns the treatment of; bins with zero content. The COL2 and COLZ2 options color these bins the color of zero. This has been implemented by Je",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:21973,depend,depends,21973,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['depend'],['depends']
Integrability,"d.f (zero value, not-a-number, normalization zero etc..); and show the observable values at which this error occurred. At most N detailed messages per p.d.f component; are shown where N is the integral value of the 'code' argument. . [#0] WARNING:Minization -- RooFitGlue: Minimized function has error status.; Returning maximum FCN so far (-1e+30) to force MIGRAD to back out of this region. Error log follows; Parameter values: m=-7.397; RooGaussian::gx[ x=x mean=m sigma=sx ]; getLogVal() top-level p.d.f evaluates to zero or negative number @ x=x=9.09989, mean=m=-7.39713, sigma=sx=0.1; getLogVal() top-level p.d.f evaluates to zero or negative number @ x=x=6.04652, mean=m=-7.39713, sigma=sx=0.1; getLogVal() top-level p.d.f evaluates to zero or negative number @ x=x=2.48563, mean=m=-7.39713, sigma=sx=0.1. The new-style error logging is active whenever MINUIT is operating on such a p.d.f. The default value for N is 3.; Outside the MINUIT context the evaluation error each evualuation error will generate a separate message through; RooMsgService; Other new features. The RooAddPdf constructor has been augmented with an additional boolean argument that allows to; interpret the supplied fraction parameters as recursive fractions rather than plain fractions.; If activated, an example RooAddPdf with three input p.d.f. A,B,C and two fractions fA and fB will; result in the expression; fA*A + (1-fA)(fB*B + 1-fB*C) rather than fA*A + fB*B + (1-fA-fB)*C. Recursive fraction have the advantage that all fraction can be defined to be in the range [0-1]; without resulting in configuration where the sum of all fractions exceeds 1.; The low-level object printing interface printToStream() has been deprecated in favor of a new; printStream() method which allows much greater control over the information printed. ; The printing of almost all RooFit objects has been reworked to present a more uniform look and feel.; The standard one-line result of the high-level Print() method without option now",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:17562,message,message,17562,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['message'],['message']
Integrability,"d:; frame setup and destruction may take several instructions, require a; disproportionate amount of debugging information in the output binary to; describe, and should be stepped over by debuggers anyway. Variable locations in Instruction Selection and MIR; ---------------------------------------------------. Instruction selection creates a MIR function from an IR function, and just as; it transforms ``intermediate`` instructions into machine instructions, so must; ``intermediate`` variable locations become machine variable locations.; Within IR, variable locations are always identified by a Value, but in MIR; there can be different types of variable locations. In addition, some IR; locations become unavailable, for example if the operation of multiple IR; instructions are combined into one machine instruction (such as; multiply-and-accumulate) then intermediate Values are lost. To track variable; locations through instruction selection, they are first separated into; locations that do not depend on code generation (constants, stack locations,; allocated virtual registers) and those that do. For those that do, debug; metadata is attached to SDNodes in SelectionDAGs. After instruction selection; has occurred and a MIR function is created, if the SDNode associated with debug; metadata is allocated a virtual register, that virtual register is used as the; variable location. If the SDNode is folded into a machine instruction or; otherwise transformed into a non-register, the variable location becomes; unavailable. Locations that are unavailable are treated as if they have been optimized out:; in IR the location would be assigned ``undef`` by a debug intrinsic, and in MIR; the equivalent location is used. After MIR locations are assigned to each variable, machine pseudo-instructions; corresponding to each ``llvm.dbg.value`` intrinsic are inserted. There are two; forms of this type of instruction. The first form, ``DBG_VALUE``, appears thus:. .. code-block:: text. DBG_VAL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:26286,depend,depend,26286,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['depend'],['depend']
Integrability,"d; rewrite the example at the beginning of `Concrete Bases and Deeper; Hierarchies`_ as:. .. code-block:: c++. enum ShapeKind {; SK_Square,; + SK_SpecialSquare,; + SK_OtherSpecialSquare,; + SK_LastSquare,; SK_Circle; }; ...; // Square::classof(); - static bool classof(const Shape *S) {; - return S->getKind() == SK_Square;; - }; + static bool classof(const Shape *S) {; + return S->getKind() >= SK_Square &&; + S->getKind() <= SK_LastSquare;; + }. Then, adding new subclasses is easy:. .. code-block:: c++. enum ShapeKind {; SK_Square,; SK_SpecialSquare,; SK_OtherSpecialSquare,; + SK_SomewhatSpecialSquare,; SK_LastSquare,; SK_Circle; }. Notice that ``Square::classof`` does not need to be changed. .. _classof-contract:. The Contract of ``classof``; ---------------------------. To be more precise, let ``classof`` be inside a class ``C``. Then the; contract for ``classof`` is ""return ``true`` if the dynamic type of the; argument is-a ``C``"". As long as your implementation fulfills this; contract, you can tweak and optimize it as much as you want. For example, LLVM-style RTTI can work fine in the presence of; multiple-inheritance by defining an appropriate ``classof``.; An example of this in practice is; `Decl <https://clang.llvm.org/doxygen/classclang_1_1Decl.html>`_ vs.; `DeclContext <https://clang.llvm.org/doxygen/classclang_1_1DeclContext.html>`_; inside Clang.; The ``Decl`` hierarchy is done very similarly to the example setup; demonstrated in this tutorial.; The key part is how to then incorporate ``DeclContext``: all that is needed; is in ``bool DeclContext::classof(const Decl *)``, which asks the question; ""Given a ``Decl``, how can I determine if it is-a ``DeclContext``?"".; It answers this with a simple switch over the set of ``Decl`` ""kinds"", and; returning true for ones that are known to be ``DeclContext``'s. .. TODO::. Touch on some of the more advanced features, like ``isa_impl`` and; ``simplify_type``. However, those two need reference documentation in; the form",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst:10986,contract,contract,10986,interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,1,['contract'],['contract']
Integrability,"d_subdirectory(cmake/modules). if(CLANG_STAGE); message(STATUS ""Setting current clang stage to: ${CLANG_STAGE}""); endif(). if (CLANG_ENABLE_BOOTSTRAP); include(ExternalProject). add_custom_target(clang-bootstrap-deps DEPENDS clang). if(NOT CLANG_STAGE); set(CLANG_STAGE stage1); endif(). string(REGEX MATCH ""stage([0-9]*)"" MATCHED_STAGE ""${CLANG_STAGE}""); if(MATCHED_STAGE); if(NOT LLVM_BUILD_INSTRUMENTED); math(EXPR STAGE_NUM ""${CMAKE_MATCH_1} + 1""); set(NEXT_CLANG_STAGE stage${STAGE_NUM}); else(); set(NEXT_CLANG_STAGE stage${CMAKE_MATCH_1}); endif(); else(); set(NEXT_CLANG_STAGE bootstrap); endif(). if(BOOTSTRAP_LLVM_BUILD_INSTRUMENTED); set(NEXT_CLANG_STAGE ${NEXT_CLANG_STAGE}-instrumented); endif(); message(STATUS ""Setting next clang stage to: ${NEXT_CLANG_STAGE}""). set(STAMP_DIR ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-stamps/); set(BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-bins/). if(BOOTSTRAP_LLVM_ENABLE_LLD); # adding lld to clang-bootstrap-deps without having it enabled in; # LLVM_ENABLE_PROJECTS just generates a cryptic error message.; if (NOT ""lld"" IN_LIST LLVM_ENABLE_PROJECTS); message(FATAL_ERROR ""LLD is enabled in the bootstrap build, but lld is not in LLVM_ENABLE_PROJECTS""); endif(); add_dependencies(clang-bootstrap-deps lld); endif(). if (WIN32); # Build llvm-rc and llvm-mt which are needed by the Windows build.; add_dependencies(clang-bootstrap-deps llvm-rc); if(LLVM_ENABLE_LIBXML2); add_dependencies(clang-bootstrap-deps llvm-mt); endif(); endif(). # If the next stage is LTO we need to depend on LTO and possibly lld or LLVMgold; if(BOOTSTRAP_LLVM_ENABLE_LTO OR LLVM_ENABLE_LTO AND NOT LLVM_BUILD_INSTRUMENTED); if(APPLE); add_dependencies(clang-bootstrap-deps LTO); # on Darwin we need to set DARWIN_LTO_LIBRARY so that -flto will work; # using the just-built compiler, and we need to override DYLD_LIBRARY_PATH; # so that the host object file tools will use the just-built libLTO.; # However if System Integrity Protection is enabled th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:20999,message,message,20999,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['message'],['message']
Integrability,"d`` or ``__bridge_transfer`` cast purely to convince; ARC to emit an unbalanced retain or release, respectively, is poor form. .. _arc.objects.restrictions:. Restrictions; ------------. .. _arc.objects.restrictions.conversion:. Conversion of retainable object pointers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In general, a program which attempts to implicitly or explicitly convert a; value of retainable object pointer type to any non-retainable type, or; vice-versa, is ill-formed. For example, an Objective-C object pointer shall; not be converted to ``void*``. As an exception, cast to ``intptr_t`` is; allowed because such casts are not transferring ownership. The :ref:`bridged; casts <arc.objects.operands.casts>` may be used to perform these conversions; where necessary. .. admonition:: Rationale. We cannot ensure the correct management of the lifetime of objects if they; may be freely passed around as unmanaged types. The bridged casts are; provided so that the programmer may explicitly describe whether the cast; transfers control into or out of ARC. However, the following exceptions apply. .. _arc.objects.restrictions.conversion.with.known.semantics:. Conversion to retainable object pointer type of expressions with known semantics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. :when-revised:`[beginning Apple 4.0, LLVM 3.1]`; :revision:`These exceptions have been greatly expanded; they previously applied; only to a much-reduced subset which is difficult to categorize but which; included null pointers, message sends (under the given rules), and the various; global constants.`. An unbridged conversion to a retainable object pointer type from a type other; than a retainable object pointer type is ill-formed, as discussed above, unless; the operand of the cast has a syntactic form which is known retained, known; unretained, or known retain-agnostic. An expression is :arc-term:`known retain-agnostic` if it is:. * an Objective-C string",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:25055,bridg,bridged,25055,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['bridg'],['bridged']
Integrability,"dded:; ; TMinuitMinimizer: implementation of the ROOT::Math::Minimizer interface with TMinuit. This class is used for example by the new Fitter class.; TLinearMinimizer: implementation of the ROOT::Math::Minimizer interface with the TLinearFitter.; ; In addition, the method TLinearFitter::SetBasisFunction(TObjArray * f) has been added to set directly the linear terms of the fit function. Minuit2. Various fixes have been applied to different problems discovered mainly by a test program from Alfio Lazzaro. In detail:; . Fix a bug in MnMinos which was setting wrong initial values when the parameters were limited.; This was resulting in a much larger number of function calls used inside MnMinos. ; Improve MnHesse by returning in the final state the improved gradient step values used in HessianGradientCalculator. With this change same results are obtained from using Hesse in Minuit2 or TMinuit. In addition, the interface of MnHesse (MnHesse::operator() ) has been improved to use it from the FunctionMinimum object (similar to MnMinos) in order to be called after the minimization (Migrad). The API with a MnUserParameterState should not be used after minimization, because in that case the latest state information resulting from the minimum (gradient values and step sizes) is lost. Add support in MnMigrad and MnMinimize for user provided analytical gradient of the FCN function. One needs to pass an instance of a function implementing the ROOT::Minuit2::FcnGradientBase interface. Use now std::string for storing parameter names. This removes the un-necessary limitation on the length of parameter name (10 characters) existing before. The method Name() of MinuitParameter (and of MnUserParameterState and MnUserParameters) still returns a const char * (for backward compatibility). A new method, GetName() has been added to return a std::string. The Minuit2Minimizer class has been improved by having an option to always run Hesse if it was not done before during the minimization. Meth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:13316,interface,interface,13316,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['interface'],['interface']
Integrability,"ddition to running them. Clang frontend; --------------. The Clang frontend (``clang -cc1``) is used to compile C family languages. The; command-line interface of the frontend is considered to be an implementation; detail, intentionally has no external documentation, and is subject to change; without notice. Language frontends for other languages; --------------------------------------. Clang can be provided with inputs written in non-C-family languages. In such; cases, an external tool will be used to compile the input. The; currently-supported languages are:. * Ada (``-x ada``, ``.ad[bs]``); * Fortran (``-x f95``, ``.f``, ``.f9[05]``, ``.for``, ``.fpp``, case-insensitive); * Java (``-x java``). In each case, GCC will be invoked to compile the input. Assembler; ---------. Clang can either use LLVM's integrated assembler or an external system-specific; tool (for instance, the GNU Assembler on GNU OSes) to produce machine code from; assembly.; By default, Clang uses LLVM's integrated assembler on all targets where it is; supported. If you wish to use the system assembler instead, use the; ``-fno-integrated-as`` option. Linker; ------. Clang can be configured to use one of several different linkers:. * GNU ld; * GNU gold; * LLVM's `lld <https://lld.llvm.org>`_; * MSVC's link.exe. Link-time optimization is natively supported by lld, and supported via; a `linker plugin <https://llvm.org/docs/GoldPlugin.html>`_ when using gold. The default linker varies between targets, and can be overridden via the; ``-fuse-ld=<linker name>`` flag. Runtime libraries; =================. A number of different runtime libraries are required to provide different; layers of support for C family programs. Clang will implicitly link an; appropriate implementation of each runtime library, selected based on; target defaults or explicitly selected by the ``--rtlib=`` and ``--stdlib=``; flags. The set of implicitly-linked libraries depend on the language mode. As a; consequence, you should use ``cl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:4119,integrat,integrated,4119,interpreter/llvm-project/clang/docs/Toolchain.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst,1,['integrat'],['integrated']
Integrability,"de does not cover; their setup. The RMS preconfigured for the Virtual Analysis Facility is; [HTCondor](http://research.cs.wisc.edu/htcondor/), which we recommend primarily; because it has dynamic addition of workers built in. Configuration steps for all nodes; ---------------------------------. ### Setup CernVM-FS. [CernVM-FS](http://cernvm.cern.ch/portal/filesystem) should be installed; on all machines as the preferred method for software distribution. > Configuration instructions for the latest CernVM-FS can be found; > [here](http://cernvm.cern.ch/portal/filesystem/techinformation). A brief step-by-step procedure to install CernVM-FS is hereby described. - Download and install the latest stable version from; [here](http://cernvm.cern.ch/portal/filesystem): pick one which is; appropriate to your operating system. You need the `cvmfs` package,; you *don't* need the `cvmfs-devel` or `cvmfs-server` ones. - As root user, run:. # cvmfs_config setup. - Start the `autofs` service: how to to this depends on your operating; system. On Ubuntu using Upstart:. # restart autofs. On RHEL-based or older Ubuntus:. # service autofs restart. - Prepare a `/etc/cvmfs/default.local` file (create it if it does not; exists) with the following configuration bits:. ``` {.bash}; CVMFS_HTTP_PROXY=http://your-proxy-server.domain.ch:3128,DIRECT; CVMFS_REPOSITORIES=your-experiment.cern.ch,sft.cern.ch; CVMFS_QUOTA_LIMIT=50000; ```. You need to properly specify your closest HTTP caching proxy:; separate many of them via commas. The last fallback value, `DIRECT`,; tells cvmfs to connect directly without using any proxy at all. Among the list of repositories (comma-separated), always specify; `sft.cern.ch` and the one containing the software to your experiment; (e.g., `cms.cern.ch`). The quota limit is, in Megabytes, the amount of local disk space to; use as cache. - Check the configuration and repositories with:. # cvmfs_config chksetup; OK; # cvmfs_config probe; Probing /cvmfs/cms.cern.ch... OK;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md:2513,depend,depends,2513,proof/doc/confman/ConfigProofPoD.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md,1,['depend'],['depends']
Integrability,"de effects as well as its memory footprint, and to make; it ready for RooFit's faster batch evaluations.; Derived classes that directly access protected members might need to be updated. This holds especially for direct accesses to `_curWeight`,; `_curWeightErrLo`, etc, which have been removed. (It doesn't make sense to write to these members from const functions when the same information; can be retrieved using an index access operator of an array.) All similar accesses in derived classes should be replaced by the getters `get_curWeight()`; or better `get_wgt(i)`, which were also supported in ROOT \<v6.24. More details on what happened:. - Reduced side effects. This code produces undefined behaviour because the side effect of `get(i)`, i.e., loading the new weight into `_curWeight`; is not guaranteed to happen before `weight()` is called:; ```; processEvent(dataHist.get(i), dataHist.weight()); // Dangerous! Order of evaluation is not guaranteed.; ```; With the modernised interface, one would use:; ```; processEvent(dataHist.get(i), dataHist.weight(i));; ```; To modernise old code, one should replace patterns like `h.get(i); h.func()` by `h.func(i);`. One may `#define R__SUGGEST_NEW_INTERFACE` to switch on; deprecation warnings for the functions in question.; Similarly, the bin content can now be set using an index, making prior loading of a certain coordinate unnecessary:; ```; for (int i=0 ; i<hist->numEntries() ; i++) {; - hist->get(i) ;; - hist->set(hist->weight() / sum);; + hist->set(i, hist->weight(i) / sum, 0.);; }; ```; - More const correctness. `calcTreeIndex()` doesn't rely on side effects, any more. Instead of overwriting the internal; coordinates with new values:; ```; // In a RooDataHist subclass:; _vars = externalCoordinates;; auto index = calcTreeIndex();. // Or from the outside:; auto index = dataHist.getIndex(externalCoordinates); // Side effect: Active bin is now `index`.; ```; coordinates are now passed into calcTreeIndex without side effects:; ```",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:21685,interface,interface,21685,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['interface'],['interface']
Integrability,"de which does treat them as a bit mask to use the new query; methods on the Attribute class. ``AttributeList``; =================. The ``AttributeList`` stores a collection of Attribute objects for each kind of; object that may have an attribute associated with it: the function as a whole,; the return type, or the function's parameters. A function's attributes are at; index ``AttributeList::FunctionIndex``; the return type's attributes are at; index ``AttributeList::ReturnIndex``; and the function's parameters' attributes; are at indices 1, ..., n (where 'n' is the number of parameters). Most methods; on the ``AttributeList`` class take an index parameter. An ``AttributeList`` is also a uniqued and immutable object. You create an; ``AttributeList`` through the ``AttributeList::get`` methods. You can add and; remove attributes, which result in the creation of a new ``AttributeList``. An ``AttributeList`` object is designed to be passed around by value. Note: It is advised that you do *not* use the ``AttributeList`` ""introspection""; methods (e.g. ``Raw``, ``getRawPointer``, etc.). These methods break; encapsulation, and may be removed in a future release. ``AttrBuilder``; ===============. Lastly, we have a ""builder"" class to help create the ``AttributeList`` object; without having to create several different intermediate uniqued; ``AttributeList`` objects. The ``AttrBuilder`` class allows you to add and; remove attributes at will. The attributes won't be uniqued until you call the; appropriate ``AttributeList::get`` method. An ``AttrBuilder`` object is *not* designed to be passed around by value. It; should be passed by reference. Note: It is advised that you do *not* use the ``AttrBuilder::addRawValue()``; method or the ``AttrBuilder(uint64_t Val)`` constructor. These are for; backwards compatibility and may be removed in a future release. And that's basically it! A lot of functionality is hidden behind these classes,; but the interfaces are pretty straight forward. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUseAttributes.rst:3497,interface,interfaces,3497,interpreter/llvm-project/llvm/docs/HowToUseAttributes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUseAttributes.rst,1,['interface'],['interfaces']
Integrability,"de-block:: c++. int foo(int x) {; // %0 and %1 both refer to x; // %l2 refers to err; asm goto(""# %0 %1 %l2"" : ""+r""(x) : : : err);; return x;; err:; return -1;; }. This was changed to match GCC in clang-13; for better portability, symbolic; references can be used instead of numeric references. .. code-block:: c++. int foo(int x) {; asm goto(""# %[x] %l[err]"" : [x]""+r""(x) : : : err);; return x;; err:; return -1;; }. Objective-C Features; ====================. Related result types; --------------------. According to Cocoa conventions, Objective-C methods with certain names; (""``init``"", ""``alloc``"", etc.) always return objects that are an instance of; the receiving class's type. Such methods are said to have a ""related result; type"", meaning that a message send to one of these methods will have the same; static type as an instance of the receiver class. For example, given the; following classes:. .. code-block:: objc. @interface NSObject; + (id)alloc;; - (id)init;; @end. @interface NSArray : NSObject; @end. and this common initialization pattern. .. code-block:: objc. NSArray *array = [[NSArray alloc] init];. the type of the expression ``[NSArray alloc]`` is ``NSArray*`` because; ``alloc`` implicitly has a related result type. Similarly, the type of the; expression ``[[NSArray alloc] init]`` is ``NSArray*``, since ``init`` has a; related result type and its receiver is known to have the type ``NSArray *``.; If neither ``alloc`` nor ``init`` had a related result type, the expressions; would have had type ``id``, as declared in the method signature. A method with a related result type can be declared by using the type; ``instancetype`` as its result type. ``instancetype`` is a contextual keyword; that is only permitted in the result type of an Objective-C method, e.g. .. code-block:: objc. @interface A; + (instancetype)constructAnA;; @end. The related result type can also be inferred for some methods. To determine; whether a method has an inferred related result type, the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:68618,interface,interface,68618,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['interface'],['interface']
Integrability,"de-block:: llvm. void @llvm.eh.sjlj.callsite(i32 %call_site_num). For SJLJ based exception handling, the ``llvm.eh.sjlj.callsite`` intrinsic; identifies the callsite value associated with the following ``invoke``; instruction. This is used to ensure that landing pad entries in the LSDA are; generated in matching order. Asm Table Formats; =================. There are two tables that are used by the exception handling runtime to; determine which actions should be taken when an exception is thrown. Exception Handling Frame; ------------------------. An exception handling frame ``eh_frame`` is very similar to the unwind frame; used by DWARF debug info. The frame contains all the information necessary to; tear down the current frame and restore the state of the prior frame. There is; an exception handling frame for each function in a compile unit, plus a common; exception handling frame that defines information common to all functions in the; unit. The format of this call frame information (CFI) is often platform-dependent,; however. ARM, for example, defines their own format. Apple has their own compact; unwind info format. On Windows, another format is used for all architectures; since 32-bit x86. LLVM will emit whatever information is required by the; target. Exception Tables; ----------------. An exception table contains information about what actions to take when an; exception is thrown in a particular part of a function's code. This is typically; referred to as the language-specific data area (LSDA). The format of the LSDA; table is specific to the personality function, but the majority of personalities; out there use a variation of the tables consumed by ``__gxx_personality_v0``.; There is one exception table per function, except leaf functions and functions; that have calls only to non-throwing functions. They do not need an exception; table. .. _wineh:. Exception Handling using the Windows Runtime; =================================================. Background on ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:19053,depend,dependent,19053,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['depend'],['dependent']
Integrability,"decl)) *Y)();; macroQualifiedType(); matches the type of the typedef declaration of X but not Y. Matcher<Type>memberPointerTypeMatcher<MemberPointerType>...; Matches member pointer types.; Given; struct A { int i; }; A::* ptr = A::i;; memberPointerType(); matches ""A::* ptr"". Matcher<Type>objcObjectPointerTypeMatcher<ObjCObjectPointerType>...; Matches an Objective-C object pointer type, which is different from; a pointer type, despite being syntactically similar. Given; int *a;. @interface Foo; @end; Foo *f;; pointerType(); matches ""Foo *f"", but does not match ""int *a"". Matcher<Type>parenTypeMatcher<ParenType>...; Matches ParenType nodes. Given; int (*ptr_to_array)[4];; int *array_of_ptrs[4];. varDecl(hasType(pointsTo(parenType()))) matches ptr_to_array but not; array_of_ptrs. Matcher<Type>pointerTypeMatcher<PointerType>...; Matches pointer types, but does not match Objective-C object pointer; types. Given; int *a;; int &b = *a;; int c = 5;. @interface Foo; @end; Foo *f;; pointerType(); matches ""int *a"", but does not match ""Foo *f"". Matcher<Type>rValueReferenceTypeMatcher<RValueReferenceType>...; Matches rvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. rValueReferenceType() matches the types of c and f. e is not; matched as it is deduced to int& by reference collapsing rules. Matcher<Type>recordTypeMatcher<RecordType>...; Matches record types (e.g. structs, classes). Given; class C {};; struct S {};. C c;; S s;. recordType() matches the type of the variable declarations of both c; and s. Matcher<Type>referenceTypeMatcher<ReferenceType>...; Matches both lvalue and rvalue reference types. Given; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. referenceType() matches the types of b, c, d, e, and f. Matcher<Type>substTemplateTypeParmTypeMatcher<SubstTemplateTypeParmType>...; Matches types that represent the result of substituting a type for a; template ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:50508,interface,interface,50508,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['interface'],['interface']
Integrability,"declaration is not a single token,; e.g. for destructors. You could use NamedDecl::getNameAsString for those cases.; Note that this method is much slower and should be used sparringly, e.g. only when generating reports; but not during analysis.; Is -analyzer-checker=core included in all test RUN: lines? It was never supported; to run the analyzer with the core checks disabled. It might cause unexpected behavior and; crashes. You should do all your testing with the core checks enabled. Patterns that you should most likely avoid even if they're not technically wrong:. BugReporterVisitor should most likely not match the AST of the current program point; to decide when to emit a note. It is much easier to determine that by observing changes in; the program state.; In State->getSVal(Region), if Region is not known to be a TypedValueRegion; and the optional type argument is not specified, the checker may accidentally try to dereference a; void pointer.; Checker logic should not depend on whether a certain value is a Loc or NonLoc.; It should be immediately obvious whether the SVal is a Loc or a; NonLoc depending on the AST that is being checked. Checking whether a value; is Loc or Unknown/Undefined or whether the value is; NonLoc or Unknown/Undefined is totally fine.; New symbols should not be constructed in the checker via direct calls to SymbolManager,; unless they are of SymbolMetadata class tagged by the checker,; or they represent newly created values such as the return value in evalCall.; For modeling arithmetic/bitwise/comparison operations, SValBuilder should be used.; Custom ProgramPointTags should not be created within the checker. There is usually; no good reason for a checker to chain multiple nodes together, because checkers aren't worklists. Checkers are encouraged to actively participate in the analysis by sharing; their knowledge about the program state with the rest of the analyzer,; but they should not be disrupting the analysis unnecessarily:. If a chec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:26474,depend,depend,26474,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['depend'],['depend']
Integrability,"declaration then first we import everything which is needed to; call the constructor of that declaration node. Everything which can be set; later is set after the node is created. For example, in case of a; ``FunctionDecl`` we first import the declaration context in which the function; is declared, then we create the ``FunctionDecl`` and only then we import the; body of the function. This means there are implicit dependencies between AST; nodes. These dependencies determine the order in which we visit nodes in the; ""from"" context. As with the regular graph traversal algorithms like DFS, we; keep track which nodes we have already visited in; ``ASTImporter::ImportedDecls``. Whenever we create a node then we immediately; add that to the ``ImportedDecls``. We must not start the import of any other; declarations before we keep track of the newly created one. This is essential,; otherwise, we would not be able to handle circular dependencies. To enforce; this, we wrap all constructor calls of all AST nodes in; ``GetImportedOrCreateDecl()``. This wrapper ensures that all newly created; declarations are immediately marked as imported; also, if a declaration is; already marked as imported then we just return its counterpart in the ""to""; context. Consequently, calling a declaration's ``::Create()`` function directly; would lead to errors, please don't do that!. Even with the use of ``GetImportedOrCreateDecl()`` there is still a; probability of having an infinite import recursion if things are imported from; each other in wrong way. Imagine that during the import of ``A``, the import of; ``B`` is requested before we could create the node for ``A`` (the constructor; needs a reference to ``B``). And the same could be true for the import of ``B``; (``A`` is requested to be imported before we could create the node for ``B``).; In case of the :ref:`templated-described swing <templated>` we take; extra attention to break the cyclical dependency: we import and set the; described temp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:99003,wrap,wrap,99003,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['wrap'],['wrap']
Integrability,"declaration to the existing redeclaration chain (if; there is structural equivalency). We do not import, however, the whole; redeclaration chain as we do in case of functions. Up till now, we haven't; found any essential property of forward declarations which is similar to the; case of the virtual flag in a member function prototype. In the future, this; may change, though. Traversal during the Import; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. The node specific import mechanisms are implemented in; ``ASTNodeImporter::VisitNode()`` functions, e.g. ``VisitFunctionDecl()``.; When we import a declaration then first we import everything which is needed to; call the constructor of that declaration node. Everything which can be set; later is set after the node is created. For example, in case of a; ``FunctionDecl`` we first import the declaration context in which the function; is declared, then we create the ``FunctionDecl`` and only then we import the; body of the function. This means there are implicit dependencies between AST; nodes. These dependencies determine the order in which we visit nodes in the; ""from"" context. As with the regular graph traversal algorithms like DFS, we; keep track which nodes we have already visited in; ``ASTImporter::ImportedDecls``. Whenever we create a node then we immediately; add that to the ``ImportedDecls``. We must not start the import of any other; declarations before we keep track of the newly created one. This is essential,; otherwise, we would not be able to handle circular dependencies. To enforce; this, we wrap all constructor calls of all AST nodes in; ``GetImportedOrCreateDecl()``. This wrapper ensures that all newly created; declarations are immediately marked as imported; also, if a declaration is; already marked as imported then we just return its counterpart in the ""to""; context. Consequently, calling a declaration's ``::Create()`` function directly; would lead to errors, please don't do that!. Even with the use of ``GetImportedOrCreateDe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:98448,depend,dependencies,98448,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['dependencies']
Integrability,declarator declarations; Unknown. 1244; C++11; Equivalence of alias templates and class templates; Unknown. 1245; C++11; Matching declarations involving decltype; Unknown. 1246; C++11; Non-deduced non-final parameter packs; Unknown. 1247; CD4; Restriction on alias name appearing in type-id; Unknown. 1248; open; Updating Annex C to C99; Not resolved. 1249; CD6; Cv-qualification of nested lambda capture; Unknown. 1250; CD3; Cv-qualification of incomplete virtual function return types; Clang 3.9. 1251; CD3; C compatibility: casting to unqualified void*; Unknown. 1252; CD6; Overloading member function templates based on dependent return type; Unknown. 1253; open; Generic non-template members; Not resolved. 1254; NAD; odr-use vs template arguments and constexpr functions; Unknown. 1255; drafting; Definition problems with constexpr functions; Not resolved. 1256; open; Unevaluated operands are not necessarily constant expressions; Not resolved. 1257; open; Instantiation via non-dependent references in uninstantiated templates; Not resolved. 1258; CD5; “Instantiation context” differs from dependent lookup rules; Unknown. 1259; NAD; Deleting a POD via a pointer to base; Unknown. 1260; CD3; Incorrect use of term “overloaded” in description of odr-use; Unknown. 1261; CD3; Explicit handling of cv-qualification with non-class prvalues; Unknown. 1262; CD3; Default template arguments and deduction failure; Unknown. 1263; NAD; Mismatch between rvalue reference binding and overload resolution; Unknown. 1264; CD3; Use of this in constexpr constructor; Unknown. 1265; CD3; Mixed use of the auto specifier; Clang 5. 1266; open; user-defined-integer-literal overflow; Not resolved. 1267; CD3; Rvalue reference types in exception-specifications; Unknown. 1268; CD3; reinterpret_cast of an xvalue operand; Unknown. 1269; CD3; dynamic_cast of an xvalue operand; Unknown. 1270; CD3; Brace elision in array temporary initialization; Unknown. 1271; CD5; Imprecise wording regarding dependent types; Un,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:83850,depend,dependent,83850,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"def A B;; class C : public B {}; // derived from a typedef of X. In the following example, Bar matches isDerivedFrom(hasName(""X"")):; class Foo;; typedef Foo X;; class Bar : public Foo {}; // derived from a type that X is a typedef of. Matcher<ObjCInterfaceDecl>isSameOrDerivedFromMatcher<NamedDecl> Base; Similar to isDerivedFrom(), but also matches classes that directly; match Base. Matcher<ObjCMessageExpr>calleeMatcher<Decl> InnerMatcher; Matches 1) if the call expression's callee's declaration matches the; given matcher; or 2) if the Obj-C message expression's callee's method; declaration matches the given matcher. Example matches y.x() (matcher = callExpr(callee(; cxxMethodDecl(hasName(""x""))))); class Y { public: void x(); };; void z() { Y y; y.x(); }. Example 2. Matches [I foo] with; objcMessageExpr(callee(objcMethodDecl(hasName(""foo"")))). @interface I: NSObject; +(void)foo;; @end; ...; [I foo]. Matcher<ObjCMessageExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<ObjCMessageExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<ObjCMessageExpr>hasReceiverMatcher<Expr> InnerMatcher; Matches if the Objective-C message is sent to an instance,; and the inner matcher matches on that instance. For example the method call in; NSString *x = @""hello"";; [x containsString:@""h""];; is matched by; objcMessageExpr(hasReceiver(declRefExpr(to(varDec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:220799,message,message-send,220799,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['message'],['message-send']
Integrability,"def with; another matched register. The ``GIReplaceReg`` builtin can do just that. .. code-block:: text. def Foo : GICombineRule<; (defs root:$dst),; (match (G_FNEG $tmp, $src), (G_FNEG $dst, $tmp)),; (apply (GIReplaceReg $dst, $src))>;. This also works if the replacement register is a temporary register from the; ``apply`` pattern. .. code-block:: text. def ReplaceTemp : GICombineRule<; (defs root:$a),; (match (G_BUILD_VECTOR $tmp, $x, $y),; (G_UNMERGE_VALUES $a, $b, $tmp)),; (apply (G_UNMERGE_VALUES $a, i32:$new, $y),; (GIReplaceReg $b, $new))>. Common Pattern #2: Erasing a Def-less Root; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If we simply want to erase a def-less match root, we can use the; ``GIEraseRoot`` builtin. .. code-block:: text. def Foo : GICombineRule<; (defs root:$mi),; (match (G_STORE $a, $b):$mi),; (apply (GIEraseRoot))>;. Common Pattern #3: Emitting a Constant Value; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. When an immediate operand appears in an 'apply' pattern, the behavior; depends on whether it's typed or not. * If the immediate is typed, ``MachineIRBuilder::buildConstant`` is used; to create a ``G_CONSTANT``. A ``G_BUILD_VECTOR`` will be used for vectors.; * If the immediate is untyped, a simple immediate is added; (``MachineInstrBuilder::addImm``). There is of course a special case for ``G_CONSTANT``. Immediates for; ``G_CONSTANT`` must always be typed, and a CImm is added; (``MachineInstrBuilder::addCImm``). .. code-block:: text; :caption: Constant Emission Examples:. // Example output:; // %0 = G_CONSTANT i32 0; // %dst = COPY %0; def Foo : GICombineRule<; (defs root:$dst),; (match (G_FOO $dst, $src)),; (apply (COPY $dst, (i32 0)))>;. // Example output:; // %dst = COPY 0; // Note that this would be ill-formed because COPY; // expects a register operand!; def Bar : GICombineRule<; (defs root:$dst),; (match (G_FOO $dst, $src)),; (apply (COPY $dst, (i32 0)))>;. // Example output:; // %dst = G_CONSTANT i32 0; def Bux : GICombineRule<; (d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst:9396,depend,depends,9396,interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/MIRPatterns.rst,1,['depend'],['depends']
Integrability,"default arguments to use with 'lit', and an option for the user; # to override.; set(LIT_ARGS_DEFAULT ""-sv""); if (MSVC OR XCODE); set(LIT_ARGS_DEFAULT ""${LIT_ARGS_DEFAULT} --no-progress-bar""); endif(); set(LLVM_LIT_ARGS ""${LIT_ARGS_DEFAULT}"" CACHE STRING ""Default options for lit""). get_errc_messages(LLVM_LIT_ERRC_MESSAGES). # On Win32 hosts, provide an option to specify the path to the GnuWin32 tools.; if( WIN32 AND NOT CYGWIN ); set(LLVM_LIT_TOOLS_DIR """" CACHE PATH ""Path to GnuWin32 tools""); endif(); else(); set(LLVM_INCLUDE_TESTS OFF); endif(). umbrella_lit_testsuite_begin(check-all); endif() # LLVM_INCLUDE_TESTS; endif() # standalone. # Make sure that our source directory is on the current cmake module path so that; # we can include cmake files from this directory.; list(INSERT CMAKE_MODULE_PATH 0; ""${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules""; ""${LLVM_COMMON_CMAKE_UTILS}/Modules""; ). # This allows disabling clang's XML dependency even if LLVM finds libxml2.; # By default, clang depends on libxml2 if LLVM does.; option(CLANG_ENABLE_LIBXML2 ""Whether libclang may depend on libxml2""; ${LLVM_ENABLE_LIBXML2}). if(CLANG_ENABLE_LIBXML2); # Don't look for libxml if we're using MSan, since uninstrumented third party; # code may call MSan interceptors like strlen, leading to false positives.; if(NOT LLVM_USE_SANITIZER MATCHES ""Memory.*""); set (LIBXML2_FOUND 0); find_package(LibXml2 2.5.3 QUIET); if (LIBXML2_FOUND); set(CLANG_HAVE_LIBXML 1); endif(); endif(); endif(). include(CheckIncludeFile); check_include_file(sys/resource.h CLANG_HAVE_RLIMITS). # This check requires _GNU_SOURCE on linux; check_include_file(dlfcn.h CLANG_HAVE_DLFCN_H); if( CLANG_HAVE_DLFCN_H ); include(CheckLibraryExists); include(CheckSymbolExists); check_library_exists(dl dlopen """" HAVE_LIBDL); if( HAVE_LIBDL ); list(APPEND CMAKE_REQUIRED_LIBRARIES dl); endif(); list(APPEND CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE); check_symbol_exists(dladdr dlfcn.h CLANG_HAVE_DLADDR); list(REMOVE_ITEM CMAKE_REQUIRED_DE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:5322,depend,depends,5322,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['depend'],['depends']
Integrability,"del.; string FilterClass;. // List of fields/attributes that should be same for all the instructions in; // a row of the relation table. Think of this as a set of properties shared; // by all the instructions related by this relationship.; list<string> RowFields = [];. // List of fields/attributes that are same for all the instructions; // in a column of the relation table.; list<string> ColFields = [];. // Values for the fields/attributes listed in 'ColFields' corresponding to; // the key instruction. This is the instruction that will be transformed; // using this relation model.; list<string> KeyCol = [];. // List of values for the fields/attributes listed in 'ColFields', one for; // each column in the relation table. These are the instructions a key; // instruction will be transformed into.; list<list<string> > ValueCols = [];; }. Sample Example; --------------. Let's say that we want to have a function; ``int getPredOpcode(uint16_t Opcode, enum PredSense inPredSense)`` which; takes a non-predicated instruction and returns its predicated true or false form; depending on some input flag, ``inPredSense``. The first step in the process is; to define a relationship model that relates predicated instructions to their; non-predicated form by assigning appropriate values to the ``InstrMapping``; fields. For this relationship, non-predicated instructions are treated as key; instruction since they are the one used to query the interface function. .. code-block:: text. def getPredOpcode : InstrMapping {; // Choose a FilterClass that is used as a base class for all the; // instructions modeling this relationship. This is done to reduce the; // search space only to these set of instructions.; let FilterClass = ""PredRel"";. // Instructions with same values for all the fields in RowFields form a; // row in the resulting relation table.; // For example, if we want to relate 'ADD' (non-predicated) with 'Add_pt'; // (predicated true) and 'Add_pf' (predicated false), then all 3; //",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUseInstrMappings.rst:2712,depend,depending,2712,interpreter/llvm-project/llvm/docs/HowToUseInstrMappings.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUseInstrMappings.rst,1,['depend'],['depending']
Integrability,"dencies(CLING ${CLING_LIBRARIES}). set(CLING_INCLUDE_DIRS ${CMAKE_SOURCE_DIR}/interpreter/cling/include CACHE STRING """"). #---These are the libraries that we link ROOT with CLING---------------------------; if (builtin_llvm); add_dependencies(CLING intrinsics_gen); endif(); if (builtin_clang); add_dependencies(CLING clang-headers clang-resource-headers); # Windows (and some other LLVM setups) do not have that target available.; if (TARGET clang-cmake-exports); add_dependencies(CLING clang-cmake-exports); endif(); endif(); else(); set(Cling_DIR ${LLVM_BINARY_DIR}/lib/cmake/cling/); find_package(Cling REQUIRED CONFIG PATHS ${Cling_DIR} ""${Cling_DIR}/lib/cmake/cling"" ""${Cling_DIR}/cmake"" NO_DEFAULT_PATH); find_package(Clang REQUIRED CONFIG PATHS ${Cling_DIR} ""${Cling_DIR}/lib/cmake/clang"" ""${Cling_DIR}/cmake"" NO_DEFAULT_PATH). # We need to consider not just the direct link dependencies, but also the; # transitive link dependencies. Do this by starting with the set of direct; # dependencies, then the dependencies of those dependencies, and so on.; set(new_libs ""clingMetaProcessor""); set(link_libs ${new_libs}); while(NOT ""${new_libs}"" STREQUAL """"); foreach(lib ${new_libs}); if(TARGET ${lib}); get_target_property(lib_type ${lib} TYPE); if(""${lib_type}"" STREQUAL ""STATIC_LIBRARY""); list(APPEND static_libs ${lib}); else(); list(APPEND other_libs ${lib}); endif(); get_target_property(transitive_libs ${lib} INTERFACE_LINK_LIBRARIES); if (NOT transitive_libs); continue(); endif(); foreach(transitive_lib ${transitive_libs}); list(FIND link_libs ${transitive_lib} idx); #if(TARGET ${transitive_lib} AND idx EQUAL -1); if(idx EQUAL -1); list(APPEND newer_libs ${transitive_lib}); list(APPEND link_libs ${transitive_lib}); endif(); endforeach(transitive_lib); endif(); endforeach(lib); set(new_libs ${newer_libs}); set(newer_libs """"); endwhile(); set(CLING_DEPEND_LIBS ${link_libs} CACHE STRING """"); endif(builtin_cling). #---Avoid to dependencies to system (e.g. atomic) libraries without ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:23251,depend,dependencies,23251,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,3,['depend'],['dependencies']
Integrability,"dencies(TMVA VDT); endif(). if(tmva-cpu); target_include_directories(TMVA PRIVATE ${TBB_INCLUDE_DIRS}); target_link_libraries(TMVA PRIVATE ${TBB_LIBRARIES}); set_target_properties(TMVA PROPERTIES COMPILE_FLAGS ""${TBB_CXXFLAGS}""). if(BLAS_FOUND); target_link_libraries(TMVA PRIVATE ${BLAS_LINKER_FLAGS} ${BLAS_LIBRARIES}); elseif(GSL_FOUND); target_compile_definitions(TMVA PRIVATE -DDNN_USE_CBLAS); target_include_directories(TMVA SYSTEM PRIVATE ${GSL_INCLUDE_DIR}); target_link_libraries(TMVA PRIVATE ${GSL_CBLAS_LIBRARY}); if(builtin_gsl); add_dependencies(TMVA GSL); endif(); else(); message(FATAL_ERROR ""tmva-cpu enabled but neither BLAS nor GSL BLAS were found""); endif(); endif(). if(tmva-gpu); target_sources(TMVA PRIVATE; src/DNN/Architectures/Cuda.cu; src/DNN/Architectures/Cuda/CudaBuffers.cxx; src/DNN/Architectures/Cuda/CudaMatrix.cu; src/DNN/Architectures/Cuda/CudaTensor.cu ); target_link_libraries(TMVA PRIVATE CUDA::cuda_driver CUDA::cublas); if(tmva-cudnn); message(STATUS ""Using Cuda+cuDNN for TMVA Deep Learning on GPU""); target_sources(TMVA PRIVATE; src/DNN/Architectures/Cudnn/TensorDataLoader.cxx; src/DNN/Architectures/Cudnn.cu); target_link_libraries(TMVA PRIVATE ROOT::cuDNN); else(); message(STATUS ""cuDNN not found or disabled - use only Cuda+Cublas for TMVA Deep Learning on GPU""); endif(); endif(tmva-gpu). if(dataframe); ROOT_STANDARD_LIBRARY_PACKAGE(TMVAUtils; NO_INSTALL_HEADERS; HEADERS; TMVA/RTensorUtils.hxx; TMVA/RStandardScaler.hxx; TMVA/RReader.hxx; TMVA/RInferenceUtils.hxx; TMVA/RBDT.hxx; TMVA/RSofieReader.hxx; TMVA/RBatchGenerator.hxx; TMVA/RBatchLoader.hxx; TMVA/RChunkLoader.hxx. SOURCES. src/RBDT.cxx. DEPENDENCIES; TMVA ROOTDataFrame ROOTVecOps; ${TMVA_EXTRA_DEPENDENCIES}. LINKDEF LinkDefUtils.h; DICTIONARY_OPTIONS; -writeEmptyRootPCM. ${EXTRA_DICT_OPTS}; ); endif(). ROOT_ADD_TEST_SUBDIRECTORY(test); ROOT_ADD_TEST_SUBDIRECTORY(test/crossvalidation); ROOT_ADD_TEST_SUBDIRECTORY(test/DNN); ROOT_ADD_TEST_SUBDIRECTORY(test/Method); ROOT_ADD_TEST_SUBDIRE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/CMakeLists.txt:10524,message,message,10524,tmva/tmva/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/CMakeLists.txt,1,['message'],['message']
Integrability,"dent even if it is; neither type- nor value-dependent. In the following example, the expression sizeof(sizeof(T() + T())); is instantiation-dependent (since it involves a template parameter T),; but is neither type- nor value-dependent, since the type of the inner; sizeof is known (std::size_t) and therefore the size of the outer; sizeof is known.; template<typename T>; void f(T x, T y) { sizeof(sizeof(T() + T()); }; expr(isInstantiationDependent()) matches sizeof(sizeof(T() + T()). Matcher<Expr>isTypeDependent; Matches expressions that are type-dependent because the template type; is not yet instantiated. For example, the expressions ""x"" and ""x + y"" are type-dependent in; the following code, but ""y"" is not type-dependent:; template<typename T>; void add(T x, int y) {; x + y;; }; expr(isTypeDependent()) matches x + y. Matcher<Expr>isValueDependent; Matches expression that are value-dependent because they contain a; non-type template parameter. For example, the array bound of ""Chars"" in the following example is; value-dependent.; template<int Size> int f() { return Size; }; expr(isValueDependent()) matches return Size. Matcher<Expr>nullPointerConstant; Matches expressions that resolve to a null pointer constant, such as; GNU's __null, C++11's nullptr, or C's NULL macro. Given:; void *v1 = NULL;; void *v2 = nullptr;; void *v3 = __null; // GNU extension; char *cp = (char *)0;; int *ip = 0;; int i = 0;; expr(nullPointerConstant()); matches the initializer for v1, v2, v3, cp, and ip. Does not match the; initializer for i. Matcher<FieldDecl>hasBitWidthunsigned Width; Matches non-static data members that are bit-fields of the specified; bit width. Given; class C {; int a : 2;; int b : 4;; int c : 2;; };; fieldDecl(hasBitWidth(2)); matches 'int a;' and 'int c;' but not 'int b;'. Matcher<FieldDecl>isBitField; Matches non-static data members that are bit-fields. Given; class C {; int a : 2;; int b;; };; fieldDecl(isBitField()); matches 'int a;' but not 'int b;'. Matcher<Float",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:87162,depend,dependent,87162,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['depend'],['dependent']
Integrability,"dent members are not resolved and so can; not be matched to particular named declarations. This matcher allows to match on the known name of members. Given; template <typename T>; struct S {; void mem();; };; template <typename T>; void x() {; S<T> s;; s.mem();; }; cxxDependentScopeMemberExpr(hasMemberName(""mem"")) matches `s.mem()`. Matcher<CXXDependentScopeMemberExpr>isArrow; Matches member expressions that are called with '->' as opposed; to '.'. Member calls on the implicit this pointer match as called with '->'. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; template <class T> void f() { this->f<T>(); f<T>(); }; int a;; static int b;; };; template <class T>; class Z {; void x() { this->m; }; };; memberExpr(isArrow()); matches this->x, x, y.x, a, this->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, f<T>. Matcher<CXXDependentScopeMemberExpr>memberHasSameNameAsBoundNodestd::string BindingID; Matches template-dependent, but known, member names against an already-bound; node. In template declarations, dependent members are not resolved and so can; not be matched to particular named declarations. This matcher allows to match on the name of already-bound VarDecl, FieldDecl; and CXXMethodDecl nodes. Given; template <typename T>; struct S {; void mem();; };; template <typename T>; void x() {; S<T> s;; s.mem();; }; The matcher; @code; cxxDependentScopeMemberExpr(; hasObjectExpression(declRefExpr(hasType(templateSpecializationType(; hasDeclaration(classTemplateDecl(has(cxxRecordDecl(has(; cxxMethodDecl(hasName(""mem"")).bind(""templMem""); ))))); )))),; memberHasSameNameAsBoundNode(""templMem""); ); @endcode; first matches and binds the @c mem member of the @c S template, then; compares its name to the usage in @c s.mem() in the @c x function template. Matcher<CXXFoldExpr>hasOperatorNamestd::string Name; Matches the operator Name of operator expressions and fold expressions; (binary o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:65710,depend,dependent,65710,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['depend'],['dependent']
Integrability,"dent server threads. Fortunately, ``LLVMContext``; exists to enable just this kind of scenario!. Conceptually, ``LLVMContext`` provides isolation. Every LLVM entity; (``Module``\ s, ``Value``\ s, ``Type``\ s, ``Constant``\ s, etc.) in LLVM's; in-memory IR belongs to an ``LLVMContext``. Entities in different contexts; *cannot* interact with each other: ``Module``\ s in different contexts cannot be; linked together, ``Function``\ s cannot be added to ``Module``\ s in different; contexts, etc. What this means is that is safe to compile on multiple; threads simultaneously, as long as no two threads operate on entities within the; same context. In practice, very few places in the API require the explicit specification of a; ``LLVMContext``, other than the ``Type`` creation/lookup APIs. Because every; ``Type`` carries a reference to its owning context, most other entities can; determine what context they belong to by looking at their own ``Type``. If you; are adding new entities to LLVM IR, please try to maintain this interface; design. .. _jitthreading:. Threads and the JIT; -------------------. LLVM's ""eager"" JIT compiler is safe to use in threaded programs. Multiple; threads can call ``ExecutionEngine::getPointerToFunction()`` or; ``ExecutionEngine::runFunction()`` concurrently, and multiple threads can run; code output by the JIT concurrently. The user must still ensure that only one; thread accesses IR in a given ``LLVMContext`` while another thread might be; modifying it. One way to do that is to always hold the JIT lock while accessing; IR outside the JIT (the JIT *modifies* the IR by adding ``CallbackVH``\ s).; Another way is to only call ``getPointerToFunction()`` from the; ``LLVMContext``'s thread. When the JIT is configured to compile lazily (using; ``ExecutionEngine::DisableLazyCompilation(false)``), there is currently a `race; condition <https://bugs.llvm.org/show_bug.cgi?id=5184>`_ in updating call sites; after a function is lazily-jitted. It's still possible",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:124029,interface,interface,124029,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['interface'],['interface']
Integrability,"dependent names; Yes. 198; CD1; Definition of ""use"" in local and nested classes; Yes. 199; CD1; Order of destruction of temporaries; Unknown. 200; dup; Partial ordering and explicit arguments; Duplicate of 214. 201; CD1; Order of destruction of temporaries in initializers; Unknown. 202; TC1; Use of overloaded function name; Clang 3.1. 203; NAD; Type of address-of-member expression; Unknown. 204; CD1; Exported class templates; No. 205; drafting; Templates and static data members; Not resolved. 206; TC1; Semantic constraints on non-dependent names; Yes. 207; CD1; using-declarations and protected access; Yes. 208; CD1; Rethrowing exceptions in nested handlers; Unknown. 209; NAD; Must friend declaration names be; accessible?; Clang 3.2. 210; TC1; What is the type matched by an exception handler?; Unknown. 211; NAD; Constructors should not be allowed to return normally after an exception; Yes. 212; CD4; Implicit instantiation is not described clearly enough; Unknown. 213; TC1; Lookup in dependent base classes; Yes. 214; CD1; Partial ordering of function templates is underspecified; Yes. 215; CD1; Template parameters are not allowed in nested-name-specifiers; Clang 2.9. 216; CD1; Linkage of nameless class-scope enumeration types; No. 217; TC1; Default arguments for non-template member functions of class templates; Yes. 218; CD1; Specification of Koenig lookup; Yes. 219; NAD; Cannot defend against destructors that throw exceptions; N/A. 220; CD1; All deallocation functions should be required not to throw; N/A. 221; CD1; Must compound assignment operators be member functions?; Clang 3.6. 222; CD1; Sequence points and lvalue-returning operators; Duplicate of 637. 223; CD3; The meaning of deprecation; N/A. 224; CD1; Definition of dependent names; Clang 16. 225; NAD; Koenig lookup and fundamental types; Yes. 226; CD1; Default template arguments for function templates; No. 227; TC1; How many scopes in an if statement?; Yes. 228; CD1; Use of template keyword with non-member templ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:14040,depend,dependent,14040,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,depends tutorial-io-importCode); set(fit-fit1-depends tutorial-hist-fillrandom); set(fit-myfit-depends tutorial-fit-fitslicesy); set(foam-foam_demopers-depends tutorial-foam-foam_demo); set(tree-staff-depends tutorial-tree-cernbuild); set(tree-cernstaff-depends tutorial-tree-cernbuild); set(hist-hbars-depends tutorial-tree-cernbuild); set(benchmarks-depends tutorial-hsimple; tutorial-fit-fit1; tutorial-fit-myfit; tutorial-hist-h1ReadAndDraw; tutorial-hist-FirstContour; tutorial-geom-na49view; tutorial-tree-ntuple1; tutorial-tree-spider; tutorial-io-hadd; tutorial-io-loopdir; tutorial-io-copyFiles); set(geom-na49view-depends tutorial-geom-geometry); set(multicore-mt102_readNtuplesFillHistosAndFit-depends tutorial-multicore-mt101_fillNtuples); set(multicore-mp102_readNtuplesFillHistosAndFit-depends tutorial-multicore-mp101_fillNtuples); set(multicore-mp105_processEntryList-depends tutorial-multicore-mp104_processH1). #--many histfactory and roostats tutorials depending on having creating the file first with histfactory and example_combined_GaussExample_model.root; foreach(tname histfactory-hf001_example; roostats-ModelInspector; roostats-OneSidedFrequentistUpperLimitWithBands; roostats-OneSidedFrequentistUpperLimitWithBands; roostats-StandardBayesianMCMCDemo; roostats-StandardBayesianNumericalDemo; roostats-StandardFeldmanCousinsDemo; roostats-StandardFrequentistDiscovery; roostats-StandardHistFactoryPlotsWithCategories; roostats-StandardHypoTestDemo; roostats-StandardHypoTestInvDemo; roostats-StandardProfileInspectorDemo; roostats-StandardProfileLikelihoodDemo; roostats-StandardTestStatDistributionDemo; roostats-TwoSidedFrequentistUpperLimitWithBands); set(${tname}-depends tutorial-roostats-CreateExampleFile); set(${tname}-py-depends tutorial-roostats-CreateExampleFile); endforeach(). #--dependency for TMVA tutorials; set (tmva-TMVAClassificationApplication-depends tutorial-tmva-TMVAClassification); set (tmva-TMVAClassificationCategory-depends tutorial-tmva-TMVAClassi,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:18255,depend,depending,18255,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['depend'],['depending']
Integrability,"der.cxx; src/DNN/Architectures/Cpu.cxx; src/DNN/Architectures/Cpu/CpuBuffer.cxx; src/DNN/Architectures/Cpu/CpuMatrix.cxx; ${TMVA_EXTRA_SOURCES}; DEPENDENCIES; TreePlayer; Tree; Hist; Matrix; Minuit; MLP; MathCore; Core; RIO; XMLIO; ${TMVA_EXTRA_DEPENDENCIES}; DICTIONARY_OPTIONS; -writeEmptyRootPCM; INSTALL_OPTIONS; ${installoptions}; ${EXTRA_DICT_OPTS}; ). if(MSVC); target_compile_definitions(TMVA PRIVATE _USE_MATH_DEFINES); endif(). if(vdt OR builtin_vdt); target_link_libraries(TMVA PRIVATE VDT::VDT); endif(); if(builtin_vdt); add_dependencies(TMVA VDT); endif(). if(tmva-cpu); target_include_directories(TMVA PRIVATE ${TBB_INCLUDE_DIRS}); target_link_libraries(TMVA PRIVATE ${TBB_LIBRARIES}); set_target_properties(TMVA PROPERTIES COMPILE_FLAGS ""${TBB_CXXFLAGS}""). if(BLAS_FOUND); target_link_libraries(TMVA PRIVATE ${BLAS_LINKER_FLAGS} ${BLAS_LIBRARIES}); elseif(GSL_FOUND); target_compile_definitions(TMVA PRIVATE -DDNN_USE_CBLAS); target_include_directories(TMVA SYSTEM PRIVATE ${GSL_INCLUDE_DIR}); target_link_libraries(TMVA PRIVATE ${GSL_CBLAS_LIBRARY}); if(builtin_gsl); add_dependencies(TMVA GSL); endif(); else(); message(FATAL_ERROR ""tmva-cpu enabled but neither BLAS nor GSL BLAS were found""); endif(); endif(). if(tmva-gpu); target_sources(TMVA PRIVATE; src/DNN/Architectures/Cuda.cu; src/DNN/Architectures/Cuda/CudaBuffers.cxx; src/DNN/Architectures/Cuda/CudaMatrix.cu; src/DNN/Architectures/Cuda/CudaTensor.cu ); target_link_libraries(TMVA PRIVATE CUDA::cuda_driver CUDA::cublas); if(tmva-cudnn); message(STATUS ""Using Cuda+cuDNN for TMVA Deep Learning on GPU""); target_sources(TMVA PRIVATE; src/DNN/Architectures/Cudnn/TensorDataLoader.cxx; src/DNN/Architectures/Cudnn.cu); target_link_libraries(TMVA PRIVATE ROOT::cuDNN); else(); message(STATUS ""cuDNN not found or disabled - use only Cuda+Cublas for TMVA Deep Learning on GPU""); endif(); endif(tmva-gpu). if(dataframe); ROOT_STANDARD_LIBRARY_PACKAGE(TMVAUtils; NO_INSTALL_HEADERS; HEADERS; TMVA/RTensorUtils.hxx; TMVA/RStandard",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/CMakeLists.txt:10136,message,message,10136,tmva/tmva/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/CMakeLists.txt,1,['message'],['message']
Integrability,"der; copyright law: that is to say, a work containing the Library or a; portion of it, either verbatim or with modifications and/or translated; straightforwardly into another language. (Hereinafter, translation is; included without limitation in the term ""modification"".). ""Source code"" for a work means the preferred form of the work for; making modifications to it. For a library, complete source code means; all the source code for all modules it contains, plus any associated; interface definition files, plus the scripts used to control compilation; and installation of the library. Activities other than copying, distribution and modification are not; covered by this License; they are outside its scope. The act of; running a program using the Library is not restricted, and output from; such a program is covered only if its contents constitute a work based; on the Library (independent of the use of the Library in a tool for; writing it). Whether that is true depends on what the Library does; and what the program that uses the Library does. 1. You may copy and distribute verbatim copies of the Library's; complete source code as you receive it, in any medium, provided that; you conspicuously and appropriately publish on each copy an; appropriate copyright notice and disclaimer of warranty; keep intact; all the notices that refer to this License and to the absence of any; warranty; and distribute a copy of this License along with the; Library. You may charge a fee for the physical act of transferring a copy,; and you may at your option offer warranty protection in exchange for a; fee. 2. You may modify your copy or copies of the Library or any portion; of it, thus forming a work based on the Library, and copy and; distribute such modifications or work under the terms of Section 1; above, provided that you also meet all of these conditions:. a) The modified work must itself be a software library. b) You must cause the files modified to carry prominent notices; stating that",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/LICENSE.TXT:9999,depend,depends,9999,interpreter/cling/LICENSE.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/LICENSE.TXT,1,['depend'],['depends']
Integrability,"der; copyright law: that is to say, a work containing the Library or a; portion of it, either verbatim or with modifications and/or translated; straightforwardly into another language. (Hereinafter, translation is; included without limitation in the term ""modification"".). ""Source code"" for a work means the preferred form of the work for; making modifications to it. For a library, complete source code means; all the source code for all modules it contains, plus any associated; interface definition files, plus the scripts used to control compilation; and installation of the library. Activities other than copying, distribution and modification are not; covered by this License; they are outside its scope. The act of; running a program using the Library is not restricted, and output from; such a program is covered only if its contents constitute a work based; on the Library (independent of the use of the Library in a tool for; writing it). Whether that is true depends on what the Library does; and what the program that uses the Library does.; ; 1. You may copy and distribute verbatim copies of the Library's; complete source code as you receive it, in any medium, provided that; you conspicuously and appropriately publish on each copy an; appropriate copyright notice and disclaimer of warranty; keep intact; all the notices that refer to this License and to the absence of any; warranty; and distribute a copy of this License along with the; Library. You may charge a fee for the physical act of transferring a copy,; and you may at your option offer warranty protection in exchange for a; fee.; ; 2. You may modify your copy or copies of the Library or any portion; of it, thus forming a work based on the Library, and copy and; distribute such modifications or work under the terms of Section 1; above, provided that you also meet all of these conditions:. a) The modified work must itself be a software library. b) You must cause the files modified to carry prominent notices; stati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt:7720,depend,depends,7720,LGPL2_1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt,1,['depend'],['depends']
Integrability,"dering>`). Note that program order does not introduce *happens-before* edges; between a thread and signals executing inside that thread. Every (defined) read operation (load instructions, memcpy, atomic; loads/read-modify-writes, etc.) R reads a series of bytes written by; (defined) write operations (store instructions, atomic; stores/read-modify-writes, memcpy, etc.). For the purposes of this; section, initialized globals are considered to have a write of the; initializer which is atomic and happens before any other read or write; of the memory in question. For each byte of a read R, R\ :sub:`byte`; may see any write to the same byte, except:. - If write\ :sub:`1` happens before write\ :sub:`2`, and; write\ :sub:`2` happens before R\ :sub:`byte`, then; R\ :sub:`byte` does not see write\ :sub:`1`.; - If R\ :sub:`byte` happens before write\ :sub:`3`, then; R\ :sub:`byte` does not see write\ :sub:`3`. Given that definition, R\ :sub:`byte` is defined as follows:. - If R is volatile, the result is target-dependent. (Volatile is; supposed to give guarantees which can support ``sig_atomic_t`` in; C/C++, and may be used for accesses to addresses that do not behave; like normal memory. It does not generally provide cross-thread; synchronization.); - Otherwise, if there is no write to the same byte that happens before; R\ :sub:`byte`, R\ :sub:`byte` returns ``undef`` for that byte.; - Otherwise, if R\ :sub:`byte` may see exactly one write,; R\ :sub:`byte` returns the value written by that write.; - Otherwise, if R is atomic, and all the writes R\ :sub:`byte` may; see are atomic, it chooses one of the values written. See the :ref:`Atomic; Memory Ordering Constraints <ordering>` section for additional; constraints on how the choice is made.; - Otherwise R\ :sub:`byte` returns ``undef``. R returns the value composed of the series of bytes it read. This; implies that some bytes within the value may be ``undef`` **without**; the entire value being ``undef``. Note that this only d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:150589,depend,dependent,150589,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependent']
Integrability,"ders that were (transitively) included when building the AST file. The bulk of the source manager block is dedicated to information about the; various files, buffers, and macro instantiations into which a source location; can refer. Each of these is referenced by a numeric ""file ID"", which is a; unique number (allocated starting at 1) stored in the source location. Clang; serializes the information for each kind of file ID, along with an index that; maps file IDs to the position within the AST file where the information about; that file ID is stored. The data associated with a file ID is loaded only when; required by the front end, e.g., to emit a diagnostic that includes a macro; instantiation history inside the header itself. The source manager block also contains information about all of the headers; that were included when building the AST file. This includes information about; the controlling macro for the header (e.g., when the preprocessor identified; that the contents of the header dependent on a macro like; ``LLVM_CLANG_SOURCEMANAGER_H``). .. _pchinternals-preprocessor:. Preprocessor Block; ^^^^^^^^^^^^^^^^^^. The preprocessor block contains the serialized representation of the; preprocessor. Specifically, it contains all of the macros that have been; defined by the end of the header used to build the AST file, along with the; token sequences that comprise each macro. The macro definitions are only read; from the AST file when the name of the macro first occurs in the program. This; lazy loading of macro definitions is triggered by lookups into the; :ref:`identifier table <pchinternals-ident-table>`. .. _pchinternals-types:. Types Block; ^^^^^^^^^^^. The types block contains the serialized representation of all of the types; referenced in the translation unit. Each Clang type node (``PointerType``,; ``FunctionProtoType``, etc.) has a corresponding record type in the AST file.; When types are deserialized from the AST file, the data within the record is; used",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:11126,depend,dependent,11126,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['depend'],['dependent']
Integrability,"design between the LTO optimizer and the linker. Design Philosophy; =================. The LLVM Link Time Optimizer provides complete transparency, while doing; intermodular optimization, in the compiler tool chain. Its main goal is to let; the developer take advantage of intermodular optimizations without making any; significant changes to the developer's makefiles or build system. This is; achieved through tight integration with the linker. In this model, the linker; treats LLVM bitcode files like native object files and allows mixing and; matching among them. The linker uses `libLTO`_, a shared object, to handle LLVM; bitcode files. This tight integration between the linker and LLVM optimizer; helps to do optimizations that are not possible in other models. The linker; input allows the optimizer to avoid relying on conservative escape analysis. .. _libLTO-example:. Example of link time optimization; ---------------------------------. The following example illustrates the advantages of LTO's integrated approach; and clean interface. This example requires a system linker which supports LTO; through the interface described in this document. Here, clang transparently; invokes system linker. * Input source file ``a.c`` is compiled into LLVM bitcode form.; * Input source file ``main.c`` is compiled into native object code. .. code-block:: c++. --- a.h ---; extern int foo1(void);; extern void foo2(void);; extern void foo4(void);. --- a.c ---; #include ""a.h"". static signed int i = 0;. void foo2(void) {; i = -1;; }. static int foo3() {; foo4();; return 10;; }. int foo1(void) {; int data = 0;. if (i < 0); data = foo3();. data = data + 42;; return data;; }. --- main.c ---; #include <stdio.h>; #include ""a.h"". void foo4(void) {; printf(""Hi\n"");; }. int main() {; return foo1();; }. To compile, run:. .. code-block:: console. % clang -flto -c a.c -o a.o # <-- a.o is LLVM bitcode file; % clang -c main.c -o main.o # <-- main.o is native object file; % clang -flto a.o main.o -o mai",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst:1467,integrat,integrated,1467,interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst,2,"['integrat', 'interface']","['integrated', 'interface']"
Integrability,"determined by calculating a central interval that capture N% of the; variations for each value of x, where N% is controlled by Z (i.e. Z=1; gives N=68%). The number of sampling curves is chosen to be such that; at least 100 curves are expected to be outside the N% interval. Intervals from; the sampling method can be asymmetric, and may perform better in the; presence of strong correlations, but may take (much) longer to; calculate. The sampling method also assumes that the uncertainty on the; parameters can modeled by a multi-variate Gaussian distribution. A complete example is provided in a new tutorial macro rf610_visualerror.C,; the output of which is shown below. It is also possible to visualize partial errors (from a subset of the parameters),; as shown above. Binned dataset generation. A new method RooAbsPdf::generateBinned() has been implemented; that samples binned datasets (RooDataHist) from any; p.d.f. RooDataHist* data = pdf.generateBinned(x,10000) ;. This binned generation interface samples the p.d.f. at each bin; center and applies a Poisson fluctuation to each sampled value.; The binning of the returned RooDataHist is controlled by the default; binning associated with the observables generated. To set the number; of bins in x to 200, do e.g. x.setBins(200) prior to the call; to generateBinned(). The binned dataset generation method does not (yet) support the concept of; prototype datasets. New minimizer interface to Minuit2, GSLMinimizer etc... A new minimizer interface, RooMinimizer has been added (contribution; from Alfio Lazarro). The new minimizer is similar in functionality to; the existing class RooMinuit, but supports the new ROOT abstract; minimizer interface and supports multiple minimizer packages and algorithms; through that interface. The present interface of RooMinimizer is identical to that of RooMinuit; with two extensions. The setMinimizer(const char*) method allows to choose between ""minuit"" and ""minuit2""); as implementation for migrad",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:2602,interface,interface,2602,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['interface'],['interface']
Integrability,"developers who don't build our project from source. Those; modules are the fundamental pieces needed to build LLVM-based projects with; CMake. We also rely on modules as a way of organizing the build system's; functionality for maintainability and re-use within LLVM projects. Argument Handling; -----------------. When defining a CMake command handling arguments is very useful. The examples; in this section will all use the CMake ``function`` block, but this all applies; to the ``macro`` block as well. CMake commands can have named arguments that are required at every call site. In; addition, all commands will implicitly accept a variable number of extra; arguments (In C parlance, all commands are varargs functions). When a command is; invoked with extra arguments (beyond the named ones) CMake will store the full; list of arguments (both named and unnamed) in a list named ``ARGV``, and the; sublist of unnamed arguments in ``ARGN``. Below is a trivial example of; providing a wrapper function for CMake's built in function ``add_dependencies``. .. code-block:: cmake. function(add_deps target); add_dependencies(${target} ${ARGN}); endfunction(). This example defines a new macro named ``add_deps`` which takes a required first; argument, and just calls another function passing through the first argument and; all trailing arguments. CMake provides a module ``CMakeParseArguments`` which provides an implementation; of advanced argument parsing. We use this all over LLVM, and it is recommended; for any function that has complex argument-based behaviors or optional; arguments. CMake's official documentation for the module is in the; ``cmake-modules`` manpage, and is also available at the; `cmake-modules online documentation; <https://cmake.org/cmake/help/v3.4/module/CMakeParseArguments.html>`_. .. note::; As of CMake 3.5 the cmake_parse_arguments command has become a native command; and the CMakeParseArguments module is empty and only left around for; compatibility. Functions V",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:10945,wrap,wrapper,10945,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['wrap'],['wrapper']
Integrability,"diagnostic using the ``<<`` operator in the same way; that highlighted source ranges and arguments are passed to the diagnostic.; Fix-it hints can be created with one of three constructors:. * ``FixItHint::CreateInsertion(Loc, Code)``. Specifies that the given ``Code`` (a string) should be inserted before the; source location ``Loc``. * ``FixItHint::CreateRemoval(Range)``. Specifies that the code in the given source ``Range`` should be removed. * ``FixItHint::CreateReplacement(Range, Code)``. Specifies that the code in the given source ``Range`` should be removed,; and replaced with the given ``Code`` string. .. _DiagnosticConsumer:. The ``DiagnosticConsumer`` Interface; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Once code generates a diagnostic with all of the arguments and the rest of the; relevant information, Clang needs to know what to do with it. As previously; mentioned, the diagnostic machinery goes through some filtering to map a; severity onto a diagnostic level, then (assuming the diagnostic is not mapped; to ""``Ignore``"") it invokes an object that implements the ``DiagnosticConsumer``; interface with the information. It is possible to implement this interface in many different ways. For; example, the normal Clang ``DiagnosticConsumer`` (named; ``TextDiagnosticPrinter``) turns the arguments into strings (according to the; various formatting rules), prints out the file/line/column information and the; string, then prints out the line of code, the source ranges, and the caret.; However, this behavior isn't required. Another implementation of the ``DiagnosticConsumer`` interface is the; ``TextDiagnosticBuffer`` class, which is used when Clang is in ``-verify``; mode. Instead of formatting and printing out the diagnostics, this; implementation just captures and remembers the diagnostics as they fly by.; Then ``-verify`` compares the list of produced diagnostics to the list of; expected ones. If they disagree, it prints out its own output. Full; documentation for t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:21262,interface,interface,21262,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['interface'],['interface']
Integrability,"dicates the stack; alignment along 4-byte units. (Special cases: if size is zero, then the ABI; size is used; if alignment is zero, then the ABI alignment is used.). .. code-block:: text. def CC_Sparc32 : CallingConv<[; // All arguments get passed in integer registers if there is space.; CCIfType<[i32, f32, f64], CCAssignToReg<[I0, I1, I2, I3, I4, I5]>>,; CCAssignToStack<4, 4>; ]>;. ``CCDelegateTo`` is another commonly used interface, which tries to find a; specified sub-calling convention, and, if a match is found, it is invoked. In; the following example (in ``X86CallingConv.td``), the definition of; ``RetCC_X86_32_C`` ends with ``CCDelegateTo``. After the current value is; assigned to the register ``ST0`` or ``ST1``, the ``RetCC_X86Common`` is; invoked. .. code-block:: text. def RetCC_X86_32_C : CallingConv<[; CCIfType<[f32], CCAssignToReg<[ST0, ST1]>>,; CCIfType<[f64], CCAssignToReg<[ST0, ST1]>>,; CCDelegateTo<RetCC_X86Common>; ]>;. ``CCIfCC`` is an interface that attempts to match the given name to the current; calling convention. If the name identifies the current calling convention,; then a specified action is invoked. In the following example (in; ``X86CallingConv.td``), if the ``Fast`` calling convention is in use, then; ``RetCC_X86_32_Fast`` is invoked. If the ``SSECall`` calling convention is in; use, then ``RetCC_X86_32_SSE`` is invoked. .. code-block:: text. def RetCC_X86_32 : CallingConv<[; CCIfCC<""CallingConv::Fast"", CCDelegateTo<RetCC_X86_32_Fast>>,; CCIfCC<""CallingConv::X86_SSECall"", CCDelegateTo<RetCC_X86_32_SSE>>,; CCDelegateTo<RetCC_X86_32_C>; ]>;. ``CCAssignToRegAndStack`` is the same as ``CCAssignToReg``, but also allocates; a stack slot, when some register is used. Basically, it works like:; ``CCIf<CCAssignToReg<regList>, CCAssignToStack<size, align>>``. .. code-block:: text. class CCAssignToRegAndStack<list<Register> regList, int size, int align>; : CCAssignToReg<regList> {; int Size = size;; int Align = align;; }. Other calling convention int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:64640,interface,interface,64640,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['interface'],['interface']
Integrability,"different master; and/or session  and displays human readable information about; the starting time of the session being browsed.; A set of scripts for quick interaction with a dataset; manager via PROOF are available under $ROOTSYS/etc/proof/utils/pq2 .; The scripts are prefixed; pq2 (proof; quick query - or; proof-dq2); and allow to {browse, register, remove, verify} datasets on a given; PROOF master. See $ROOTSYS/etc/proof/utils/pq2/README for more; information. Improvements. Enable by default schema evolution in TMessage; can be; disabled setting 'Proof.SchemaEvolution:; 0' .; Extend the functionality of the dataset API to obtaine; information on per-server base; add also two new methods:. TProof::SetDataSetTreeName(<dataset>,<treename>):; set/change the default tree name in the TFileCollection;; TProof::ExistsDataSet(<dataset>):; check; by-name the availability of a given dataset;. In ProofBench, . Load the macro before executing it. This allows to; circumvent a problem recently fixed giving less dependency on the; server version.; In make_dset.C, simplification of the body and of the; signature, eliminating one redundant argument. In TProofOutputFile, improve flexibility in defining the; URL for the local files server. The ""LOCALDATASERVER"" env is tested,; which can defined with placeholders via the xpd.putenv directive in the; xrootd/xproofd config files.; Improving parsing of lines with memory info.; This solves occasional crashes while generating the memory; plots.; In TProofMgr::GetSessionLogs:. add the possibility to postpone the retrieval of the; logs files when the TProofLog object is created. This improved; functionality is exploited in the log window.; add decoding of the session starting time and full; information about the master URL. Enable new xrootd configuration options, including the; possibility to set the compiler and linker; Cleanup of the TProofMgr functions DetachSession and; ShutdownSession, and better handling of the internal list registra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:5547,depend,dependency,5547,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['depend'],['dependency']
Integrability,"ding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants of the following instructions have been; removed:. * ``and``; * ``or``; * ``lshr``; * ``ashr``; * ``zext``; * ``sext``; * ``fptrunc``; * ``fpext``; * ``fptoui``; * ``fptosi``; * ``uitofp``; * ``sitofp``. * Added `llvm.exp10` intrinsic. * Added a ``code_model`` attribute for the `global variable <LangRef.html#global-variables>`_. Changes to LLVM infrastructure; ------------------------------. * Minimum Clang version to build LLVM in C++20 configuration has been updated to clang-17.0.6. Changes to building LLVM; ------------------------. Changes to TableGen; -------------------. * Added constructs for debugging TableGen files:. * `dump` keyword to dump messages to standard error, see; https://github.com/llvm/llvm-project/pull/68793.; * `!repr` bang operator to inspect the content of values, see; https://github.com/llvm/llvm-project/pull/68716. Changes to Interprocedural Optimizations; ----------------------------------------. Changes to the AArch64 Backend; ------------------------------. * Added support for Cortex-A520, Cortex-A720 and Cortex-X4 CPUs. * Neoverse-N2 was incorrectly marked as an Armv8.5a core. This has been; changed to an Armv9.0a core. However, crypto options are not enabled; by default for Armv9 cores, so `-mcpu=neoverse-n2+crypto` is now required; to enable crypto for this core. As far as the compiler is concerned,; Armv9.0a has the same features enabled as Armv8.5a, with the exception; of crypto. * Assembler/disassembler support has been added for 2023 architecture; extensions. * Support has been added for Stack Clash Protection. During function frame; creation and dynamic stack allocations, the compiler will issue memory; a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:2659,message,messages,2659,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['message'],['messages']
Integrability,"ding location; descriptions that describe when bytes are in registers, are implicit, or a; composite of these, the ``DW_OP_LLVM_offset``, ``DW_OP_LLVM_offset_uconst``, and; ``DW_OP_LLVM_bit_offset`` offset operations are added. The offset operations can operate on location storage of any size. For example,; implicit location storage could be any number of bits in size. It is simpler to; define offsets that exceed the size of the location storage as being an; evaluation error, than having to force an implementation to support potentially; infinite precision offsets to allow it to correctly track a series of positive; and negative offsets that may transiently overflow or underflow, but end up in; range. This is simple for the arithmetic operations as they are defined in terms; of two's complement arithmetic on a base type of a fixed size. Therefore, the; offset operation define that integer overflow is ill-formed. This is in contrast; to the ``DW_OP_plus``, ``DW_OP_plus_uconst``, and ``DW_OP_minus`` arithmetic; operations which define that it causes wrap-around. Having the offset operations allows ``DW_OP_push_object_address`` to push a; location description that may be in a register, or be an implicit value. The; DWARF expression of ``DW_TAG_ptr_to_member_type`` can use the offset operations; without regard to what kind of location description was pushed. Since; :ref:`amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack` has; generalized location storage to be bit indexable, ``DW_OP_LLVM_bit_offset``; generalizes DWARF to work with bit fields. This is generally not possible in; DWARF Version 5. The ``DW_OP_*piece`` operations only allow literal indices. A way to use a; computed offset of an arbitrary location description (such as a vector register); is required. The offset operations provide this ability since they can be used; to compute a location description on the stack. It could be possible to define ``DW_OP_plus``, ``DW_OP_plus_uconst``, and; ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:12251,wrap,wrap-around,12251,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['wrap'],['wrap-around']
Integrability,"dingStandards>`. To enforce this language version, we check the most; popular host toolchains for specific minimum versions in our build systems:. * Clang 5.0; * Apple Clang 10.0; * GCC 7.4; * Visual Studio 2019 16.7. Anything older than these toolchains *may* work, but will require forcing the; build system with a special option and is not really a supported host platform.; Also note that older versions of these compilers have often crashed or; miscompiled LLVM. For less widely used host toolchains such as ICC or xlC, be aware that a very; recent version may be required to support all of the C++ features used in LLVM. We track certain versions of software that are *known* to fail when used as; part of the host toolchain. These even include linkers at times. **GNU ld 2.16.X**. Some 2.16.X versions of the ld linker will produce very long; warning messages complaining that some ""``.gnu.linkonce.t.*``"" symbol was; defined in a discarded section. You can safely ignore these messages as they are; erroneous and the linkage is correct. These messages disappear using ld 2.17. **GNU binutils 2.17**: Binutils 2.17 contains `a bug; <http://sourceware.org/bugzilla/show_bug.cgi?id=3111>`__ which causes huge link; times (minutes instead of seconds) when building LLVM. We recommend upgrading; to a newer version (2.17.50.0.4 or later). **GNU Binutils 2.19.1 Gold**: This version of Gold contained `a bug; <http://sourceware.org/bugzilla/show_bug.cgi?id=9836>`__ which causes; intermittent failures when building LLVM with position independent code. The; symptom is an error about cyclic dependencies. We recommend upgrading to a; newer version of Gold. Getting a Modern Host C++ Toolchain; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This section mostly applies to Linux and older BSDs. On macOS, you should; have a sufficiently modern Xcode, or you will likely need to upgrade until you; do. Windows does not have a ""system compiler"", so you must install either Visual; Studio 2019 (or later), or a r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:14177,message,messages,14177,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['message'],['messages']
Integrability,"direction crosses the surface. ``` {.cpp}; Double_t *TGeoManager::FindNormal(Bool_t forward=kTRUE);; ```. The method above computes the normal to the next crossed surface in; forward or backward direction (i.e. the current one), assuming the state; corresponding to a current arbitrary point is initialized. An example of; usage of normal computation is ray tracing. The two most important features of the geometrical modeller concerning; tracking are scalability and performance as function of the total number; of physical nodes. The first refers to the possibility to make use of; the available memory resources and at the same time be able to resolve; any geometrical query, while the second defines the capability of the; modeller to respond quickly even for huge geometries. These parameters; can become critical when simulating big experiments like those at LHC. ### Creating and Visualizing Tracks. In case the modeller is interfaced with a tracking engine, one might; consider quite useful being able to store and visualize at least a part; of the tracks in the context of the geometry. The base class; **`TVirtualGeoTrack`** provides this functionality. It currently has one; implementation inside the drawing package (**`TGeoTrack`** class). A; track can be defined like:. ``` {.cpp}; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; ```. Where: `id` is user-defined id of the track, `pdg` - `pdg` code,; `parent` - a pointer to parent track, `particle` - a pointer to an; arbitrary particle object (may be a **`TParticle`**). A track has a list of daughters that have to be filled using the; following method:. ``` {.cpp}; TVirtualGeoTrack *TVirtualGeoTrack::AddDaughter(Int_t id,Int_t pdg,; TObject *particle=0);; ```. The method above is pure virtual and have to create a track daughter; object. Tracks are fully customizable objects when inheriting from; **`TVirtualGeoTrack`** class. We will describe the structure and; functionality provided by ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:124300,interface,interfaced,124300,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interfaced']
Integrability,"directory contains a set of examples that represent all areas; of the framework. When a new release is cut, the examples in this; directory are compiled and run to test the new release's backward; compatibility. We see these source files:. +-------------------+--------------------------------------------------------+; | `Makefile` | Makefile to build all test programs. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test program that creates and saves some |; | | histograms |; +-------------------+--------------------------------------------------------+; | `MainEvent.cxx` | Simple test program that creates a ROOT Tree object |; | | and fills it with some simple structures but also with |; | | complete histograms. This program uses the files |; | | `Event.cxx`, `EventCint.cxx` and `Event.h`. An example |; | | of a procedure to link this program is in |; | | `bind_Event`. Note that the `Makefile` invokes the |; | | `rootcling` utility to generate the Cling interface |; | | `EventCint.cxx` |; +-------------------+--------------------------------------------------------+; | `Event.cxx` | Implementation for classes Event and Track |; +-------------------+--------------------------------------------------------+; | `minexam.cxx` | Simple test program for data fitting |; +-------------------+--------------------------------------------------------+; | `tcollex.cxx` | Example usage of the ROOT collection classes |; +-------------------+--------------------------------------------------------+; | `tcollbm.cxx` | Benchmarks of ROOT collection classes |; +-------------------+--------------------------------------------------------+; | ctorture.cxx | Test program for the class **`TComplex`** |; +-------------------+--------------------------------------------------------+; | `tstring.cxx` | Example usage of the ROOT string class |; +-------------------+--------------------------------------------------------+; | `vmatr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:2540,interface,interface,2540,documentation/users-guide/TutorialsandTests.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md,1,['interface'],['interface']
Integrability,"displayed lines to 100; instead of 10. Improve diagnostic in case of worker death: clients will; now; receive a message containing the low level reason for the failure and a; hint for getting more informationIn; TProofOutputFile, support the ""<user>"" and ""<group>""; placeholders in the output file name to automatically re-direct the; output to an area specific to the logged user.; Addition of a new class TProofProgressStatus, which is used to keep; the query progress stauts in all the TProofPlayer objects and in the; TPacketizerAdaptive. It is also send in kPROOF_GETPACKET and; kPROOF_STOPPROCESS messages. ; The class TPacketizerProgressive is removed. . Fixes. Enable; the max number of sessions ('mxsess' parameter in the xpd.schedparam; directive); users are just refused to start a session if this limit is; reached.Make sure to collect consistently input messages when running in asynchronous modeFix; a few problems with TProof::SendFile (used by UploadPackage, Load); appearing when a rapid sequence of these commands was submitted Invalidate the TProofMgr when the physical connection is; closed; avoids; crashing when trying to get the logs after a failure. ; Fix a memory leak in log retrieval (the TProofLog object; was never; deleted); Add protections for the cases the manager cannot be; initialized; Fix a race condition possibly affecting the handling of; workers death; Avoid duplicating worker logs in the master log file; unless; when explicitly needed by the request (Exec(...), Print(...)) or when; an error occuredFix; problem with the determination and transmission of the name of the; object to be processed. The problem appeared when processing files; containing >1 trees in changing order.Fix problem with TProof::Load loading the macro to one worker only per machineFix wrong return code preventing the correct propagation of the full ClearPackage to workersFix a problem causing the whole query to stop even in the case a worker was terminated gently with SIGTERM.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html:6137,message,messages,6137,proof/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html,1,['message'],['messages']
Integrability,"dist, ""method=dgt"");; // sample N times (generate N random numbers); for (int i = 0; i < N; ++i); int k = unr.SampleDiscr();; ```. - For empirical distribution via the class **`TUnuranEmpDist`**. In; this case one can generate random numbers from a set of un-bin or; bin data. In the first case the parent distribution is estimated by; UNU.RAN using a gaussian kernel smoothing algorithm. The; **`TUnuranEmpDist`** distribution class can be created from a vector; of data or from **`TH1`** (using the bins or from its buffer for; un-binned data). ``` {.cpp}; // Create distribution from a set of data; // vdata is an std::vector containing the data; TUnuranEmpDist dist(vdata.begin(),vdata.end());; unr.Init(dist);; // sample N times (generate N random numbers); for (int i = 0; i<N; ++i); double x = unr.Sample();; ```. - For some predefined distributions, like `Poisson` and `Binomial`,; one can use directly a function in the **`TUnuran`** class. This is; more convenient in passing distribution parameters than using; directly the string interface. ``` {.cpp}; TUnuran unr;; // Initialize unuran to generate normal random numbers from the; // Poisson distribution with parameter mu; unr.InitPoisson(mu);; ...; // Sample distributions N times (generate N random numbers); for (int i = 0; i<N; ++i); int k = unr.SampleDiscr();; ```. Functionality is also provided via the C++ classes for using a different; random number generator by passing a TRandom pointer when constructing; the **`TUnuran`** class (by default the ROOT ***`gRandom`*** is passed; to UNURAN). ### Performances of Random Numbers. Here are the CPU times obtained using the four random classes on an; `lxplus` machine with an Intel 64 bit architecture and compiled using gcc; 3.4:. +--------------------+---------------+----------------+----------------+----------------+; | | **`TRandom`** | **`TRandom1`** | **`TRandom2`** | **`TRandom3`** |; | | (ns/call) | (ns/call) | (ns/call) | (ns/call) |; +--------------------+------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:22047,interface,interface,22047,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interface']
Integrability,"distributed under the terms of Sections; 1 and 2 above on a medium customarily used for software interchange; or,. b) Accompany it with a written offer, valid for at least three; years, to give any third party, for a charge no more than your; cost of physically performing source distribution, a complete; machine-readable copy of the corresponding source code, to be; distributed under the terms of Sections 1 and 2 above on a medium; customarily used for software interchange; or,. c) Accompany it with the information you received as to the offer; to distribute corresponding source code. (This alternative is; allowed only for noncommercial distribution and only if you; received the program in object code or executable form with such; an offer, in accord with Subsection b above.). The source code for a work means the preferred form of the work for; making modifications to it. For an executable work, complete source; code means all the source code for all modules it contains, plus any; associated interface definition files, plus the scripts used to; control compilation and installation of the executable. However, as a; special exception, the source code distributed need not include; anything that is normally distributed (in either source or binary; form) with the major components (compiler, kernel, and so on) of the; operating system on which the executable runs, unless that component; itself accompanies the executable. If distribution of executable or object code is made by offering; access to copy from a designated place, then offering equivalent; access to copy the source code from the same place counts as; distribution of the source code, even though third parties are not; compelled to copy the source along with the object code. 4. You may not copy, modify, sublicense, or distribute the Program; except as expressly provided under this License. Any attempt; otherwise to copy, modify, sublicense or distribute the Program is; void, and will automatically terminate your ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt:8183,interface,interface,8183,misc/rootql/LICENSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt,2,['interface'],['interface']
Integrability,"ditional initial adjustment. .. code-block:: c++. enum RelocationType {; reloc_pcrel_word = 0, // add reloc value after adjusting for the PC loc; reloc_picrel_word = 1, // add reloc value after adjusting for the PIC base; reloc_absolute_word = 2, // absolute relocation; no additional adjustment; reloc_absolute_dword = 3 // absolute relocation; no additional adjustment; };. Target JIT Info; ---------------. ``XXXJITInfo.cpp`` implements the JIT interfaces for target-specific; code-generation activities, such as emitting machine code and stubs. At; minimum, a target-specific version of ``XXXJITInfo`` implements the following:. * ``getLazyResolverFunction`` --- Initializes the JIT, gives the target a; function that is used for compilation. * ``emitFunctionStub`` --- Returns a native function with a specified address; for a callback function. * ``relocate`` --- Changes the addresses of referenced globals, based on; relocation types. * Callback function that are wrappers to a function stub that is used when the; real target is not initially known. ``getLazyResolverFunction`` is generally trivial to implement. It makes the; incoming parameter as the global ``JITCompilerFunction`` and returns the; callback function that will be used a function wrapper. For the Alpha target; (in ``AlphaJITInfo.cpp``), the ``getLazyResolverFunction`` implementation is; simply:. .. code-block:: c++. TargetJITInfo::LazyResolverFn AlphaJITInfo::getLazyResolverFunction(; JITCompilerFn F) {; JITCompilerFunction = F;; return AlphaCompilationCallback;; }. For the X86 target, the ``getLazyResolverFunction`` implementation is a little; more complicated, because it returns a different callback function for; processors with SSE instructions and XMM registers. The callback function initially saves and later restores the callee register; values, incoming arguments, and frame and return address. The callback; function needs low-level access to the registers or stack, so it is typically; implemented with a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:82630,wrap,wrappers,82630,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['wrap'],['wrappers']
Integrability,"dled by llvm-config are valid.; if(NOT DEFINED LLVM_DYLIB_COMPONENTS); set(LLVM_DYLIB_COMPONENTS ""all"" CACHE STRING; ""Semicolon-separated list of components to include in libLLVM, or \""all\"".""); endif(). if(MSVC); option(LLVM_BUILD_LLVM_C_DYLIB ""Build LLVM-C.dll (Windows only)"" ON); # Set this variable to OFF here so it can't be set with a command-line; # argument.; set (LLVM_LINK_LLVM_DYLIB OFF); if (BUILD_SHARED_LIBS); message(FATAL_ERROR ""BUILD_SHARED_LIBS options is not supported on Windows.""); endif(); else(); option(LLVM_LINK_LLVM_DYLIB ""Link tools against the libllvm dynamic library"" OFF); option(LLVM_BUILD_LLVM_C_DYLIB ""Build libllvm-c re-export library (Darwin only)"" OFF); set(LLVM_BUILD_LLVM_DYLIB_default OFF); if(LLVM_LINK_LLVM_DYLIB OR LLVM_BUILD_LLVM_C_DYLIB); set(LLVM_BUILD_LLVM_DYLIB_default ON); endif(); option(LLVM_BUILD_LLVM_DYLIB ""Build libllvm dynamic library"" ${LLVM_BUILD_LLVM_DYLIB_default}); endif(). if (LLVM_LINK_LLVM_DYLIB AND BUILD_SHARED_LIBS); message(FATAL_ERROR ""Cannot enable BUILD_SHARED_LIBS with LLVM_LINK_LLVM_DYLIB. We recommend disabling BUILD_SHARED_LIBS.""); endif(). option(LLVM_OPTIMIZED_TABLEGEN ""Force TableGen to be built with optimization"" OFF); if(CMAKE_CROSSCOMPILING OR (LLVM_OPTIMIZED_TABLEGEN AND (LLVM_ENABLE_ASSERTIONS OR CMAKE_CONFIGURATION_TYPES))); set(LLVM_USE_HOST_TOOLS ON); endif(). option(LLVM_OMIT_DAGISEL_COMMENTS ""Do not add comments to DAG ISel"" ON); if (CMAKE_BUILD_TYPE AND uppercase_CMAKE_BUILD_TYPE MATCHES ""^(RELWITHDEBINFO|DEBUG)$""); set(LLVM_OMIT_DAGISEL_COMMENTS OFF); endif(). if (MSVC_IDE); option(LLVM_ADD_NATIVE_VISUALIZERS_TO_SOLUTION ""Configure project to use Visual Studio native visualizers"" TRUE); endif(). if(NOT LLVM_INDIVIDUAL_TEST_COVERAGE); if(LLVM_BUILD_INSTRUMENTED OR LLVM_BUILD_INSTRUMENTED_COVERAGE OR LLVM_ENABLE_IR_PGO); if(NOT LLVM_PROFILE_MERGE_POOL_SIZE); # A pool size of 1-2 is probably sufficient on an SSD. 3-4 should be fine; # for spinning disks. Anything higher may only help on slower",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:34362,message,message,34362,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"do not want to; simply wrap each operating system call. It would be preferable to wrap several; operating system calls that are always used in conjunction with one another by; LLVM. For example, consider what is needed to execute a program, wait for it to; complete, and return its result code. On Unix, this involves the following; operating system calls: ``getenv``, ``fork``, ``execve``, and ``wait``. The; correct thing for ``lib/Support`` to provide is a function, say; ``ExecuteProgramAndWait``, that implements the functionality completely. what; we don't want is wrappers for the operating system calls involved. There must **not** be a one-to-one relationship between operating system; calls and the Support library's interface. Any such interface function will be; suspicious. No Unused Functionality; -----------------------. There must be no functionality specified in the interface of ``lib/Support``; that isn't actually used by LLVM. We're not writing a general purpose operating; system wrapper here, just enough to satisfy LLVM's needs. And, LLVM doesn't; need much. This design goal aims to keep the ``lib/Support`` interface small and; understandable which should foster its actual use and adoption. No Duplicate Implementations; ----------------------------. The implementation of a function for a given platform must be written exactly; once. This implies that it must be possible to apply a function's; implementation to multiple operating systems if those operating systems can; share the same implementation. This rule applies to the set of operating; systems supported for a given class of operating system (e.g. Unix, Win32). No Virtual Methods; ------------------. The Support Library interfaces can be called quite frequently by LLVM. In order; to make those calls as efficient as possible, we discourage the use of virtual; methods. There is no need to use inheritance for implementation differences, it; just adds complexity. The ``#include`` mechanism works just fine. N",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:5086,wrap,wrapper,5086,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['wrap'],['wrapper']
Integrability,"do this by attaching a; ``DynamicLibrarySearchGenerator`` instance using the; ``DynamicLibrarySearchGenerator::GetForCurrentProcess`` method. .. code-block:: c++. static Expected<std::unique_ptr<KaleidoscopeJIT>> Create() {; auto JTMB = JITTargetMachineBuilder::detectHost();. if (!JTMB); return JTMB.takeError();. auto DL = JTMB->getDefaultDataLayoutForTarget();; if (!DL); return DL.takeError();. return std::make_unique<KaleidoscopeJIT>(std::move(*JTMB), std::move(*DL));; }. const DataLayout &getDataLayout() const { return DL; }. LLVMContext &getContext() { return *Ctx.getContext(); }. Next we have a named constructor, ``Create``, which will build a KaleidoscopeJIT; instance that is configured to generate code for our host process. It does this; by first generating a JITTargetMachineBuilder instance using that classes'; detectHost method and then using that instance to generate a datalayout for; the target process. Each of these operations can fail, so each returns its; result wrapped in an Expected value [3]_ that we must check for error before; continuing. If both operations succeed we can unwrap their results (using the; dereference operator) and pass them into KaleidoscopeJIT's constructor on the; last line of the function. Following the named constructor we have the ``getDataLayout()`` and; ``getContext()`` methods. These are used to make data structures created and; managed by the JIT (especially the LLVMContext) available to the REPL code that; will build our IR modules. .. code-block:: c++. void addModule(std::unique_ptr<Module> M) {; cantFail(CompileLayer.add(ES.getMainJITDylib(),; ThreadSafeModule(std::move(M), Ctx)));; }. Expected<ExecutorSymbolDef> lookup(StringRef Name) {; return ES.lookup({&ES.getMainJITDylib()}, Mangle(Name.str()));; }. Now we come to the first of our JIT API methods: addModule. This method is; responsible for adding IR to the JIT and making it available for execution. In; this initial implementation of our JIT we will make our modules",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:9453,wrap,wrapped,9453,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['wrap'],['wrapped']
Integrability,"dress of the shadow call stack to be; aligned to its size. .. _`avoids this`: https://android.googlesource.com/platform/bionic/+/808d176e7e0dd727c7f929622ec017f6e065c582/libc/arch-arm64/bionic/setjmp.S#49. The architecture's call and return instructions (``bl`` and ``ret``) operate on; a register rather than the stack, which means that leaf functions are generally; protected from return address overwrites even without ShadowCallStack. Usage; =====. To enable ShadowCallStack, just pass the ``-fsanitize=shadow-call-stack`` flag; to both compile and link command lines. On aarch64, you also need to pass; ``-ffixed-x18`` unless your target already reserves ``x18``. On RISC-V, ``x3``; (``gp``) is always reserved. It is, however, important to disable GP relaxation; in the linker. This can be done with the ``--no-relax-gp`` flag in GNU ld. Low-level API; -------------. ``__has_feature(shadow_call_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some cases one may need to execute different code depending on whether; ShadowCallStack is enabled. The macro ``__has_feature(shadow_call_stack)`` can; be used for this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(shadow_call_stack); // code that builds only under ShadowCallStack; # endif; #endif. ``__attribute__((no_sanitize(""shadow-call-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""shadow-call-stack"")))`` on a function; declaration to specify that the shadow call stack instrumentation should not be; applied to that function, even if enabled globally. Example; =======. The following example code:. .. code-block:: c++. int foo() {; return bar() + 1;; }. Generates the following aarch64 assembly when compiled with ``-O2``:. .. code-block:: none. stp x29, x30, [sp, #-16]!; mov x29, sp; bl bar; add w0, w0, #1; ldp x29, x30, [sp], #16; ret. Adding ``-fsanitize=shadow-call-stack`` would output the following assembly:. .. code-block:: none. str x30, [x18]",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:8777,depend,depending,8777,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst,1,['depend'],['depending']
Integrability,"ds <threads.h>; N/A. 415; C11; Missing divide by zero entry in Annex J; Yes. 416; C11; tss_t destruction unspecified; N/A. 417; C11; Annex J not updated with necessary aligned_alloc entries; Yes. 418; NAD; Possible defect report: fmod(0.,NaN) and fmod(NaN,infinity); N/A. 419; C11; Generic Functions; Yes. 420; NAD; Sytax error in specification of for-statement; Yes. 421; NAD; Initialization of atomic_flag; N/A. 422; NAD; Initialization of atomic types; N/A. 423; C11; Defect Report relative to n1570: underspecification for qualified rvalues. Partial; Clang properly handles dropping qualifiers from cast operations, but; does not yet handle dropping qualifiers from the function return type.; . 424; Dup; Underspecification of tss_t; Duplicate of 416. 425; NAD; No specification for the access to variables with temporary lifetime; Yes. 426; C11; G.5.1: -yv and -x/v are ambiguous; N/A. 427; NAD; Function Parameter and Return Value Assignments; Unknown. 428; C11; Runtime-constraint issue with sprintf family of routines in Annex K; N/A. 429; C11; Should gets_s discard next input line when (s == NULL) ?; N/A. 430; C11; getenv_s, maxsize should be allowed to be zero; N/A. 431; C11; atomic_compare_exchange: What does it mean to say two structs compare equal?; Unknown. 432; C11; Possible defect report: Is 0.0 required to be a representable value?; Yes. 433; C11; Issue with constraints for wide character function arguments involving RSIZE_MAX; N/A. 434; C11; Possible defect report: Missing constraint w.r.t. Atomic; Yes. 435; NAD; Possible defect report: Missing constraint w.r.t. Imaginary; Yes. 436; C11; Request for interpretation of C11 6.8.5#6; Yes. 437; C11; clock overflow problems; N/A. 438; C11; ungetc / ungetwc and file position after discarding push back problems; N/A. 439; C11; Issues with the definition of ""full expression""; Unknown. 440; NAD; Floating-point issues in C11 from PDTS 18661-1 UK review, Issue 1; Unknown. 441; C11; Floating-point issues in C11 from PDTS 18661",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:22964,rout,routines,22964,interpreter/llvm-project/clang/www/c_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html,1,['rout'],['routines']
Integrability,"ds or by; adopting protocols. Moreover, because the method names are selected by; the type of the subscript, an object can be subscripted using both array; and dictionary styles. Array-Style Subscripting; ^^^^^^^^^^^^^^^^^^^^^^^^. When the subscript operand has an integral type, the expression is; rewritten to use one of two different selectors, depending on whether; the element is being read or written. When an expression reads an; element using an integral index, as in the following example:. .. code-block:: objc. NSUInteger idx = ...;; id value = object[idx];. it is translated into a call to ``objectAtIndexedSubscript:``. .. code-block:: objc. id value = [object objectAtIndexedSubscript:idx];. When an expression writes an element using an integral index:. .. code-block:: objc. object[idx] = newValue;. it is translated to a call to ``setObject:atIndexedSubscript:``. .. code-block:: objc. [object setObject:newValue atIndexedSubscript:idx];. These message sends are then type-checked and performed just like; explicit message sends. The method used for objectAtIndexedSubscript:; must be declared with an argument of integral type and a return value of; some Objective-C object pointer type. The method used for; setObject:atIndexedSubscript: must be declared with its first argument; having some Objective-C pointer type and its second argument having; integral type. The meaning of indexes is left up to the declaring class. The compiler; will coerce the index to the appropriate argument type of the method it; uses for type-checking. For an instance of ``NSArray``, reading an; element using an index outside the range ``[0, array.count)`` will raise; an exception. For an instance of ``NSMutableArray``, assigning to an; element using an index within this range will replace that element, but; assigning to an element using an index outside this range will raise an; exception; no syntax is provided for inserting, appending, or removing; elements for mutable arrays. A class need n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:13001,message,message,13001,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,2,['message'],['message']
Integrability,"ds the precedence for each binary operator that is; /// defined.; static std::map<char, int> BinopPrecedence;. /// GetTokPrecedence - Get the precedence of the pending binary operator token.; static int GetTokPrecedence() {; if (!isascii(CurTok)); return -1;. // Make sure it's a declared binop.; int TokPrec = BinopPrecedence[CurTok];; if (TokPrec <= 0) return -1;; return TokPrec;; }. int main() {; // Install standard binary operators.; // 1 is lowest precedence.; BinopPrecedence['<'] = 10;; BinopPrecedence['+'] = 20;; BinopPrecedence['-'] = 20;; BinopPrecedence['*'] = 40; // highest.; ...; }. For the basic form of Kaleidoscope, we will only support 4 binary; operators (this can obviously be extended by you, our brave and intrepid; reader). The ``GetTokPrecedence`` function returns the precedence for; the current token, or -1 if the token is not a binary operator. Having a; map makes it easy to add new operators and makes it clear that the; algorithm doesn't depend on the specific operators involved, but it; would be easy enough to eliminate the map and do the comparisons in the; ``GetTokPrecedence`` function. (Or just use a fixed-size array). With the helper above defined, we can now start parsing binary; expressions. The basic idea of operator precedence parsing is to break; down an expression with potentially ambiguous binary operators into; pieces. Consider, for example, the expression ""a+b+(c+d)\*e\*f+g"".; Operator precedence parsing considers this as a stream of primary; expressions separated by binary operators. As such, it will first parse; the leading primary expression ""a"", then it will see the pairs [+, b]; [+, (c+d)] [\*, e] [\*, f] and [+, g]. Note that because parentheses are; primary expressions, the binary expression parser doesn't need to worry; about nested subexpressions like (c+d) at all. To start, an expression is a primary expression potentially followed by; a sequence of [binop,primaryexpr] pairs:. .. code-block:: c++. /// expression; /// ::= pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:13781,depend,depend,13781,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['depend'],['depend']
Integrability,"dule linkage; Not resolved. 2589; review; Context of access checks during constraint satisfaction checking; Not resolved. 2590; C++23; Underlying type should determine size and alignment requirements of an enum; Unknown. 2591; DR; Implicit change of active union member for anonymous union in union; Unknown. 2592; open; Missing definition for placement allocation/deallocation function; Not resolved. 2593; review; Insufficient base class restriction for pointer-to-member expression; Not resolved. 2594; CD6; Disallowing a global function template main; Unknown. 2595; DR; ""More constrained"" for eligible special member functions; Unknown. 2596; drafting; Instantiation of constrained non-template friends; Not resolved. 2597; CD6; Replaceable allocation and deallocation functions in the global module; Unknown. 2598; C++23; Unions should not require a non-static data member of literal type; Clang 18. 2599; C++23; What does initializing a parameter include?; Unknown. 2600; DR; Type dependency of placeholder types; Unknown. 2601; C++23; Tracking of created and destroyed subobjects; Unknown. 2602; C++23; consteval defaulted functions; Unknown. 2603; C++23; Holistic functional equivalence for function templates; Unknown. 2604; C++23; Attributes for an explicit specialization; Unknown. 2605; C++23; Implicit-lifetime aggregates; Unknown. 2606; CD6; static_cast from ""pointer to void"" does not handle similar types; Unknown. 2607; drafting; Visibility of enumerator names; Not resolved. 2608; CD6; Omitting an empty template argument list; Unknown. 2609; open; Padding in class types; Not resolved. 2610; C++23; Indirect private base classes in aggregates; Unknown. 2611; C++23; Missing parentheses in expansion of fold-expression could cause syntactic reinterpretation; Unknown. 2612; C++23; Incorrect comment in example; Unknown. 2613; C++23; Incomplete definition of resumer; Unknown. 2614; C++23; Unspecified results for class member access; Unknown. 2615; C++23; Missing __has_cpp_attribut",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:179153,depend,dependency,179153,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependency']
Integrability,"dural protection](#interprocedural-checking).; * When hardening the address of a load, it uses a *destructive* or; *non-reversible* modification of the address to prevent an attacker from; reversing the check using attacker-controlled inputs.; * It does not completely block speculative execution, and merely prevents; *mis*-speculated paths from leaking secrets from memory (and stalls; speculation until this can be determined).; * It is completely general and makes no fundamental assumptions about the; underlying architecture other than the ability to do branchless conditional; data updates and a lack of value prediction.; * It does not require programmers to identify all possible secret data using; static source code annotations or code vulnerable to a variant #1 style; attack. Limitations of this approach:; * It requires re-compiling source code to insert hardening instruction; sequences. Only software compiled in this mode is protected.; * The performance is heavily dependent on a particular architecture's; implementation strategy. We outline a potential x86 implementation below and; characterize its performance.; * It does not defend against secret data already loaded from memory and; residing in registers or leaked through other side-channels in; non-speculative execution. Code dealing with this, e.g cryptographic; routines, already uses constant-time algorithms and code to prevent; side-channels. Such code should also scrub registers of secret data following; [these; guidelines](https://github.com/HACS-workshop/spectre-mitigations/blob/master/crypto_guidelines.md).; * To achieve reasonable performance, many loads may not be checked, such as; those with compile-time fixed addresses. This primarily consists of accesses; at compile-time constant offsets of global and local variables. Code which; needs this protection and intentionally stores secret data must ensure the; memory regions used for secret data are necessarily dynamic mappings or heap; allocations. This ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:6560,depend,dependent,6560,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['depend'],['dependent']
Integrability,"e 'std' namespace; use '::data' to reference this declaration; int data;; ^; ```. - Line editing at the ROOT interactive prompt has been improved. This version introduces useful shortcuts for common actions, e.g. Xterm-like fast movement between words using Ctrl+Left and Ctrl+Right, Ctrl+Del to delete the word under the cursor, or clearing the screen using Ctrl+L. Most users coming from a GUI will find these shortcuts convenient.; A list of the available key bindings is printed by; ```; root [] .help edit; ```. ## I/O Libraries. ### Faster reading from EOS. A new cross-protocol redirection has been added to allow files on EOS mounts to be opened; by `TFile::Open` via XRootD protocol rather than via FUSE when that is possible. The; redirection uses the `eos.url.xroot` extended file attribute that is present on files in EOS.; The attribute can be viewed with `getfattr -n eos.url.xroot [file]` on the command line.; When the URL passed into `TFile::Open` is a for a file on an EOS mount, the extended; attribute is used to attempt the redirection to XRootD protocol. If the redirection fails,; the file is opened using the plain file path as before. This feature is controlled by the; pre-existing configuration option `TFile.CrossProtocolRedirects` and is enabled by default.; It can be disabled by setting `TFile.CrossProtocolRedirects` to `0` in `rootrc`. ## TTree Libraries. ## RNTuple; ROOT's experimental successor of TTree has seen many updates during the last few months. Specifically, v6.28 includes the following changes:. - Complete support for big-endian architectures (PR [#10402](https://github.com/root-project/root/pull/10402)). - Support for `std::pair<T1, T2>` and `std::tuple<Ts...>` fields. - Support for C array fields whose type is of the form `T[N]`. Note that only single-dimension arrays are currently supported. - Improvements to the ROOT file embedding (PR [#10558](https://github.com/root-project/root/pull/10558)). In particular, a `RNTupleReader` or `RDataFram",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:8177,protocol,protocol,8177,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['protocol'],['protocol']
Integrability,"e (1);. * ``bool IndentBraces`` Indent the wrapped braces themselves. * ``bool SplitEmptyFunction`` If ``false``, empty function body can be put on a single line.; This option is used only if the opening brace of the function has; already been wrapped, i.e. the ``AfterFunction`` brace wrapping mode is; set, and the function could/should not be put on a single line (as per; ``AllowShortFunctionsOnASingleLine`` and constructor formatting; options). .. code-block:: c++. false: true:; int f() vs. int f(); {} {; }. * ``bool SplitEmptyRecord`` If ``false``, empty record (e.g. class, struct or union) body; can be put on a single line. This option is used only if the opening; brace of the record has already been wrapped, i.e. the ``AfterClass``; (for classes) brace wrapping mode is set. .. code-block:: c++. false: true:; class Foo vs. class Foo; {} {; }. * ``bool SplitEmptyNamespace`` If ``false``, empty namespace body can be put on a single line.; This option is used only if the opening brace of the namespace has; already been wrapped, i.e. the ``AfterNamespace`` brace wrapping mode is; set. .. code-block:: c++. false: true:; namespace Foo vs. namespace Foo; {} {; }. .. _BracedInitializerIndentWidth:. **BracedInitializerIndentWidth** (``Unsigned``) :versionbadge:`clang-format 17` :ref:`¶ <BracedInitializerIndentWidth>`; The number of columns to use to indent the contents of braced init lists.; If unset, ``ContinuationIndentWidth`` is used. .. code-block:: c++. AlignAfterOpenBracket: AlwaysBreak; BracedInitializerIndentWidth: 2. void f() {; SomeClass c{; ""foo"",; ""bar"",; ""baz"",; };; auto s = SomeStruct{; .foo = ""foo"",; .bar = ""bar"",; .baz = ""baz"",; };; SomeArrayT a[3] = {; {; foo,; bar,; },; {; foo,; bar,; },; SomeArrayT{},; };; }. .. _BreakAdjacentStringLiterals:. **BreakAdjacentStringLiterals** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <BreakAdjacentStringLiterals>`; Break between adjacent string literals. .. code-block:: c++. true:; return ""Code""; ""\0\52\26\55",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:42652,wrap,wrapped,42652,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrapped']
Integrability,"e (register); break;; case X86II::MRMSrcMem: // for instructions that use the Mod/RM byte; ... // to specify a source (memory); break;; case X86II::MRM0r: case X86II::MRM1r: // for instructions that operate on; case X86II::MRM2r: case X86II::MRM3r: // a REGISTER r/m operand and; case X86II::MRM4r: case X86II::MRM5r: // use the Mod/RM byte and a field; case X86II::MRM6r: case X86II::MRM7r: // to hold extended opcode data; ...; break;; case X86II::MRM0m: case X86II::MRM1m: // for instructions that operate on; case X86II::MRM2m: case X86II::MRM3m: // a MEMORY r/m operand and; case X86II::MRM4m: case X86II::MRM5m: // use the Mod/RM byte and a field; case X86II::MRM6m: case X86II::MRM7m: // to hold extended opcode data; ...; break;; case X86II::MRMInitReg: // for instructions whose source and; ... // destination are the same register; break;; }. The implementations of these case statements often first emit the opcode and; then get the operand(s). Then depending upon the operand, helper methods may; be called to process the operand(s). For example, in ``X86CodeEmitter.cpp``,; for the ``X86II::AddRegFrm`` case, the first data emitted (by ``emitByte``) is; the opcode added to the register operand. Then an object representing the; machine operand, ``MO1``, is extracted. The helper methods such as; ``isImmediate``, ``isGlobalAddress``, ``isExternalSymbol``,; ``isConstantPoolIndex``, and ``isJumpTableIndex`` determine the operand type.; (``X86CodeEmitter.cpp`` also has private methods such as ``emitConstant``,; ``emitGlobalAddress``, ``emitExternalSymbolAddress``, ``emitConstPoolAddress``,; and ``emitJumpTableAddress`` that emit the data into the output stream.). .. code-block:: c++. case X86II::AddRegFrm:; MCE.emitByte(BaseOpcode + getX86RegNum(MI.getOperand(CurOp++).getReg()));. if (CurOp != NumOps) {; const MachineOperand &MO1 = MI.getOperand(CurOp++);; unsigned Size = X86InstrInfo::sizeOfImm(Desc);; if (MO1.isImmediate()); emitConstant(MO1.getImm(), Size);; else {; unsigne",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:79249,depend,depending,79249,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['depend'],['depending']
Integrability,"e *G* was used we; also have alias to *F*. 4. Set *F* linkage to private. Make it strong :-). No global aliases, replaceDirectCallers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; If global aliases are not supported. We call ``replaceDirectCallers``. Just; go through all calls of *G* and replace it with calls of *F*. If you look into; the method you will see that it scans all uses of *G* too, and if use is callee; (if user is call instruction and *G* is used as what to be called), we replace; it with use of *F*. If “F” could not be overridden, fix it!; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". We call ``writeThunkOrAlias(Function *F, Function *G)``. Here we try to replace; *G* with alias to *F* first. The next conditions are essential:. * target should support global aliases,; * the address itself of *G* should be not significant, not named and not; referenced anywhere,; * function should come with external, local or weak linkage. Otherwise we write thunk: some wrapper that has *G's* interface and calls *F*,; so *G* could be replaced with this wrapper. *writeAlias*. As follows from *llvm* reference:. “Aliases act as *second name* for the aliasee value”. So we just want to create; a second name for *F* and use it instead of *G*:. 1. create global alias itself (*GA*),. 2. adjust alignment of *F* so it must be maximum of current and *G's* alignment;. 3. replace uses of *G*:. 3.1. first mark all callers of *G* as to-be-analyzed-again, using; ``removeUsers`` method (see chapter above),. 3.2. call ``G->replaceAllUsesWith(GA)``. 4. Get rid of *G*. *writeThunk*. As it written in method comments:. “Replace G with a simple tail call to bitcast(F). Also replace direct uses of G; with bitcast(F). Deletes G.”. In general it does the same as usual when we want to replace callee, except the; first point:. 1. We generate tail call wrapper around *F*, but with interface that allows use; it instead of *G*. 2. “As-usual”: ``removeUsers`` and ``replaceAllUsesWith`` then. 3. Get rid of *G*. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:31180,wrap,wrapper,31180,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,"e = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other sui",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10632,interface,interface,10632,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,2,"['interface', 'protocol']","['interface', 'protocol']"
Integrability,"e BrentRootFinder class is used by TF1::GetX . ; A similar class, BrentMinimizer1D, provides the possibility to find the minimum of one-dimensional functions using the Brent algorithm. This class is used by TF1::GetMinimum or TF1::GetMaximum; Use ROOT convention for all enumeration names defining the type of numerical algorithms (start with k, like kADAPTIVE for the integration type). This affects both MathCore and MathMore.; . In addition we use now the ROOT convention for all enumeration names defining the type of numerical algorithms. The names start with k, like kADAPTIVE for the integration type. This change affects both MathCore and MathMore and it breaks backward compatibility. MathCore Function interfaces; Mathcore provides as well interfaces for the evaluation of mathematical and parametric functions to be used in the numerical methods. This release contains the following changes:. The ROOT::Math::IParamFunction, ROOT::Math::IParamMultiFunction interfaces (used mainly for fitting) require now a pointer to the parameters (type const double *), when evaluating the function. The derived classes must implement now the const; method DoEvalPar (and not DoEval as before). In addition the method; operator()(const double * x, const double * p) is now const. This change makes the caching of parameter not hidden and the interface is now; thread-safe. ; A similar change in the ROOT::Math::IParamGradFunction, ROOT::Math::IParamMultiGradFunction interfaces, where the parameter values are now required for calculating the partial derivatives with respect to the parameters.; This changes the signature of the pure abstract method, DoParameterDerivative(const double *x, const double * p, , which takes also a pointer (type const double *) to the parameters.; In addition, these classes do not inherit anymore from the function gradient interface (ROOT::Math::IGradFunction and ROOT::Math::IMultiGradFunction). They define only the parameter gradient which is needed for fitting and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:8976,interface,interfaces,8976,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['interface'],['interfaces']
Integrability,"e C++20 standard these constructs are; well-defined, so activating pedantic mode in C++20 has no effect.). **Examples**. .. code-block:: cpp. static_assert(sizeof(int) == 4, ""assuming 32-bit int""). void basic_examples(int a, int b) {; if (b < 0) {; b = a << b; // warn: right operand is negative in left shift; } else if (b >= 32) {; b = a >> b; // warn: right shift overflows the capacity of 'int'; }; }. int pedantic_examples(int a, int b) {; if (a < 0) {; return a >> b; // warn: left operand is negative in right shift; }; a = 1000u << 31; // OK, overflow of unsigned value is well-defined, a == 0; if (b > 10) {; a = b << 31; // this is undefined before C++20, but the checker doesn't; // warn because it doesn't know the exact value of b; }; return 1000 << 31; // warn: this overflows the capacity of 'int'; }. **Solution**. Ensure the shift operands are in proper range before shifting. .. _core-CallAndMessage:. core.CallAndMessage (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C message expressions (e.g., uninitialized arguments, null function pointers). .. literalinclude:: checkers/callandmessage_example.c; :language: objc. .. _core-DivideZero:. core.DivideZero (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for division by zero. .. literalinclude:: checkers/dividezero_example.c; :language: c. .. _core-NonNullParamChecker:. core.NonNullParamChecker (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for null pointers passed as arguments to a function whose arguments are references or marked with the 'nonnull' attribute. .. code-block:: cpp. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. .. _core-NullDereference:. core.NullDereference (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for dereferences of null pointers. This checker specifically does; not report null pointer dereferences for x86 and x86-64 targets when the; address space is 256",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:2860,message,message,2860,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['message'],['message']
Integrability,"e CACHE unless the; FORCE option is specified. In addition to directory-based scope, CMake functions also have their own scope.; This means variables set inside functions do not bleed into the parent scope.; This is not true of macros, and it is for this reason LLVM prefers functions; over macros whenever reasonable. .. note::; Unlike C-based languages, CMake's loop and control flow blocks do not have; their own scopes. Control Flow; ============. CMake features the same basic control flow constructs you would expect in any; scripting language, but there are a few quirks because, as with everything in; CMake, control flow constructs are commands. If, ElseIf, Else; ----------------. .. note::; For the full documentation on the CMake if command go; `here <https://cmake.org/cmake/help/v3.4/command/if.html>`_. That resource is; far more complete. In general CMake if blocks work the way you'd expect:. .. code-block:: cmake. if(<condition>); message(""do stuff""); elseif(<condition>); message(""do other stuff""); else(); message(""do other other stuff""); endif(). The single most important thing to know about CMake's if blocks coming from a C; background is that they do not have their own scope. Variables set inside; conditional blocks persist after the ``endif()``. Loops; -----. The most common form of the CMake ``foreach`` block is:. .. code-block:: cmake. foreach(var ...); message(""do stuff""); endforeach(). The variable argument portion of the ``foreach`` block can contain dereferenced; lists, values to iterate, or a mix of both:. .. code-block:: cmake. foreach(var foo bar baz); message(${var}); endforeach(); # prints:; # foo; # bar; # baz. set(my_list 1 2 3); foreach(var ${my_list}); message(${var}); endforeach(); # prints:; # 1; # 2; # 3. foreach(var ${my_list} out_of_bounds); message(${var}); endforeach(); # prints:; # 1; # 2; # 3; # out_of_bounds. There is also a more modern CMake foreach syntax. The code below is equivalent; to the code above:. .. code-block:: cmake. fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:7871,message,message,7871,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,3,['message'],['message']
Integrability,"e Foo : NSObject; + (void) releaseArg:(CFDateRef) CF_CONSUMED x;; @end. void test_method() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; [Foo releaseArg:date]; // No leak!; }. Attribute 'ns_consumes_self'; (Clang-specific); The 'ns_consumes_self' attribute can be placed only on an Objective-C method; declaration. It indicates that the receiver of the message is; ""consumed"" (a single reference count decremented) after the message; is sent. This matches the semantics of all ""init"" methods.; One use of this attribute is declare your own init-like methods that do not; follow the standard Cocoa naming conventions.; Example. #ifndef __has_feature; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMES_SELF; #if __has_feature((attribute_ns_consumes_self)); #define NS_CONSUMES_SELF __attribute__((ns_consumes_self)); #else; #define NS_CONSUMES_SELF; #endif; #endif. @interface MyClass : NSObject; - initWith:(MyClass *)x;; - nonstandardInitWith:(MyClass *)x NS_CONSUMES_SELF NS_RETURNS_RETAINED;; @end. In this example, -nonstandardInitWith: has the same ownership; semantics as the init method -initWith:. The static analyzer will; observe that the method consumes the receiver, and then returns an object with; a +1 retain count.; The Foundation framework defines a macro NS_REPLACES_RECEIVER; which is functionally equivalent to the combination of NS_CONSUMES_SELF; and NS_RETURNS_RETAINED shown above.; Libkern Memory Management Annotations; Libkern; requires developers to inherit all heap allocated objects from OSObject; and to perform manual reference counting.; The reference counting model is very similar to MRR (manual retain-release) mode in; Objective-C; or to CoreFoundation reference counting.; Freshly-allocated objects start with a reference count of 1,; and calls to retain increment it,; while calls to release decrement it.; The object is deallocated whenever its reference count reaches zero.; Manually increment",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:13107,interface,interface,13107,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['interface'],['interface']
Integrability,"e Optimizer provides complete transparency, while doing; intermodular optimization, in the compiler tool chain. Its main goal is to let; the developer take advantage of intermodular optimizations without making any; significant changes to the developer's makefiles or build system. This is; achieved through tight integration with the linker. In this model, the linker; treats LLVM bitcode files like native object files and allows mixing and; matching among them. The linker uses `libLTO`_, a shared object, to handle LLVM; bitcode files. This tight integration between the linker and LLVM optimizer; helps to do optimizations that are not possible in other models. The linker; input allows the optimizer to avoid relying on conservative escape analysis. .. _libLTO-example:. Example of link time optimization; ---------------------------------. The following example illustrates the advantages of LTO's integrated approach; and clean interface. This example requires a system linker which supports LTO; through the interface described in this document. Here, clang transparently; invokes system linker. * Input source file ``a.c`` is compiled into LLVM bitcode form.; * Input source file ``main.c`` is compiled into native object code. .. code-block:: c++. --- a.h ---; extern int foo1(void);; extern void foo2(void);; extern void foo4(void);. --- a.c ---; #include ""a.h"". static signed int i = 0;. void foo2(void) {; i = -1;; }. static int foo3() {; foo4();; return 10;; }. int foo1(void) {; int data = 0;. if (i < 0); data = foo3();. data = data + 42;; return data;; }. --- main.c ---; #include <stdio.h>; #include ""a.h"". void foo4(void) {; printf(""Hi\n"");; }. int main() {; return foo1();; }. To compile, run:. .. code-block:: console. % clang -flto -c a.c -o a.o # <-- a.o is LLVM bitcode file; % clang -c main.c -o main.o # <-- main.o is native object file; % clang -flto a.o main.o -o main # <-- standard link command with -flto. * In this example, the linker recognizes that ``foo2()`` is an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst:1579,interface,interface,1579,interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LinkTimeOptimization.rst,1,['interface'],['interface']
Integrability,"e `StreamerInfo` list; to decode an object into the current version. The `StreamerInfo` is made; up of **`TStreamerElements`** . Each describes one persistent data; member of the class. By default, all data members of a class are; persistent. To exclude a data member (i.e. make it not persistent), add; a ""`!`"" after the comment marks. For example the pointer \*`fPainter` of; a **`TH1`** is not persistent:. ``` {.cpp}; TVirtualHistPainter* fPainter //!pointer to histogram painter; ```. ### The TStreamerElement Class. A **`TStreamerElement`** describes a data member of a simple type,; object, array, pointer, or container. The offset in the; **`TStreamerElement`** is the starting address of the data for that data; member. ``` {.cpp}; BASE TNamed offset= 0 type=67 The basis for a named object; BASE TAttLine offset= 28 type= 0 Line attributes; ```. In this example, the **`TNamed`** data starts at byte 0, and; **`TAttLine`** starts at byte 28. The offset is machine and compiler; dependent and is computed when the `StreamerInfo` is analyzed. The types; are defined in the file `TStreamerInfo.h` and listed here:. ``` {.cpp}; enum EReadWrite {; kBase=0, kChar=1,kShort=2,kInt=3,kLong=4,; kFloat=5, kCounter=6,kCharStar=7, kDouble=8,kUChar=11,; kUShort=12, kUInt=13,kULong=14,kBits=15,kOffsetL=20,; kOffsetP=40, kObject=61,kAny=62,kObjectp=63,kObjectP=64,; kTString=65, kTObject=66,kTNamed=67,kSkip=100,kSkipL=120,; kSkipP=140, kConv=200, kConvL=220,kConvP=240,kStreamer=500,; kStreamLoop=501, kMissing=99999; };; ```. The method `TClass::GetStreamerInfo` analyzes the `StreamerInfo` the; same way it would be analyzed by referring to the class. While analyzing; the `StreamerInfo`, it computes the offsets. The type field is the type; of the **`TStreamerElement`**. It is specific to the `StreamerInfo`; definition. ### Example: TH1 StreamerInfo. In the `StreamerInfo` of the **`TH1`** class we see the four base; classes: **`TNamed`**, **`TAttLine`**, **`TAttFill`**,; `and `**`TAttMarker`**.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:71431,depend,dependent,71431,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['depend'],['dependent']
Integrability,"e `root slits.C` in the shell. This will start root and make it; read the ""macro"" `slits.C`, i.e. all the lines in the file will be; executed one after the other. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/slits.C; ```; [f21]: figures/TF1_DoubleSlit.png ""f21""; <a name=""f21""></a>. ![Output of slits.C with parameters 0.2 and 2.\label{f21}][f21]. The example first asks for user input, namely the ratio of slit width; over slit distance, and the number of slits. After entering this; information, you should see the graphical output as is shown in Figure [2.1](#f21). This is a more complicated example than the ones we have seen before, so; spend some time analysing it carefully, you should have understood it; before continuing. Let us go through it in detail:. Lines *7-18* define the necessary functions in `C++` code, split into; three separate functions, as suggested by the problem considered. The; full interference pattern is given by the product of a function; depending on the ratio of the width and distance of the slits, and a; second one depending on the number of slits. More important for us here; is the definition of the interface of these functions to make them; usable for the ROOT class `TF1`: the first argument is the pointer to; *x*, the second one points to the array of parameters. The main program starts at line 21 with the definition of a function; `slits()` of type `void`. After asking for user input, a ROOT function; is defined using the C-type function given in the beginning. We can now; use all methods of the `TF1` class to control the behaviour of our; function -- nice, isn't it ?. If you like, you can easily extend the example to also plot the; interference pattern of a single slit, using function `double single`,; or of a grid with narrow slits, function `double nslit0`, in `TF1`; instances. Here, we used a macro, some sort of lightweight program, that the; interpreter distributed with ROOT, Cling, is able to execute. This is a; rather extraordi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:6385,depend,depending,6385,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,2,['depend'],['depending']
Integrability,"e a description :ref:`here<amdgpu_synid_sc0>`. sc1; ~~~. See a description :ref:`here<amdgpu_synid_sc1>`. nt; ~~. See a description :ref:`here<amdgpu_synid_nt>`. MIMG Modifiers; --------------. .. _amdgpu_synid_dmask:. dmask; ~~~~~. Specifies which channels (image components) are used by the operation.; By default, no channels are used. =============== ====================================================================; Syntax Description; =============== ====================================================================; dmask:{0..15} Specifies image channels as a positive; :ref:`integer number <amdgpu_synid_integer_number>`; or an :ref:`absolute expression<amdgpu_synid_absolute_expression>`. Each bit corresponds to one of 4 image components (RGBA). If the specified bit value is 0, the image component is not used,; while value 1 means that the component is used.; =============== ====================================================================. This modifier has some limitations depending on the instruction kind:. =================================================== ========================; Instruction Kind Valid dmask Values; =================================================== ========================; 32-bit atomic *cmpswap* 0x3; 32-bit atomic instructions except for *cmpswap* 0x1; 64-bit atomic *cmpswap* 0xF; 64-bit atomic instructions except for *cmpswap* 0x3; *gather4* 0x1, 0x2, 0x4, 0x8; GFX11+ *msaa_load* 0x1, 0x2, 0x4, 0x8; Other instructions any value; =================================================== ========================. Examples:. .. parsed-literal::. dmask:0xf; dmask:0b1111; dmask:x|y|z. .. _amdgpu_synid_unorm:. unorm; ~~~~~. Specifies whether the address is normalized or not (the address is normalized by default). ======================== ========================================; Syntax Description; ======================== ========================================; unorm Force the address to be not normalized.; ======================== ====",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst:11471,depend,depending,11471,interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,1,['depend'],['depending']
Integrability,"e algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:56576,integrat,integration,56576,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,2,['integrat'],['integration']
Integrability,"e builtin function `textureSample`. Texture sampling; requires screen-space derivatives of the coordinates to determine the level of; detail (mipmap level) of the sample. They are commonly approximated by taking; the difference between neighboring pixels, which are computed by different; threads in the same group:. .. code-block:: c++. void example_shader() {; ...; color = textureSample(texture, coordinates);; if (condition) {; use(color);; }; ...; }. From a purely single-threaded perspective, sinking the `textureSample` into; the if-statement appears legal. However, if the condition is false for some; neighboring pixels, then their corresponding threads will not execute together; in the group, making it impossible to take the difference of coordinates as an; approximation of the screen-space derivative. In practice, the outcome will be; an undefined value. That is, the `textureSample` operation fits our definition of a convergent; operation:. 1. It communicates with a set of threads that implicitly depends on control; flow.; 2. Correctness depends on this set of threads. The compiler frontend can emit IR that expresses the convergence constraints as; follows:. .. code-block:: llvm. define void @example_shader() convergent {; %entry = call token @llvm.experimental.convergence.entry(); ...; %color = call T @textureSample(U %texture, V %coordinates) [ ""convergencectrl""(token %entry) ]; br i1 %condition, label %then, label %end. then:; call void @use(T %color); br label %end. end:; ret void; }. The :ref:`llvm.experimental.convergence.entry <llvm.experimental.convergence.entry>`; intrinsic is itself ``convergent``, and we expect it to communicate at least; among all threads of the same ""quad"" -- a group of 2x2 pixels that are; evaluated together for the purpose of approximating screen-space derivatives.; This fact is not part of the generic LLVM IR semantics; it would have to be; defined somewhere else, for example as part of target-specific ABI definitions; and/or in r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:4797,depend,depends,4797,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['depend'],['depends']
Integrability,"e client:. ```{.cpp}. // get connection id for the first connection in the list. if (win->NumConnections() > 0) {; unsigned connid = win->GetConnectionId();; std::string msg = ""Hello, world"";; win->Send(msg, connid);; }. ```. ## Display window. To display window in the browser, one should call `win->Show()` method.; This will starts new window (or new tab) in the default browser and show content of HTML page,; configured for the window. As argument of `Show()` method one can specify browser kind like; ""chromium"" or ""firefox"" or just full path to the program which should be invoked.; With the method `win->GetUrl()` one obtains URL string, which can be typed in the browser address string directly. Same window can be displayed several times in different browsers or different browser tabs - one only; must allow appropriate number of connections calling `win->SetConnLimit(3)`. For the local displays **Chromium Embeded Framework (CEF)** is used. It provides functionality; of Chrome web browser in ROOT application without need to create and start real http server.; If CEF was configured correctly, it is enough to call `win->Show(""cef"")` to display window in CEF. ## Client code. There is no limitations which framework should be used on the client side.; The minimal HTML/JavaScript code, which establish connection with the server, looks like:. ``` {.html}; <!DOCTYPE HTML>; <html>; <head>; <meta charset=""utf-8"">; <title>RWebWindow Example</title>; </head>; <body>; <div id=""main""></div>; <script type=""module"">; import { connectWebWindow } from './jsrootsys/modules/webwindow.mjs';; connectWebWindow({; receiver: {; onWebsocketOpened(handle) {; console.log('Connected');; handle.send('Init msg from client');; },; onWebsocketMsg(handle, msg) {; console.log('Get message ' + msg);; document.getElementById('main').innerHTML = msg;; },; onWebsocketClosed(handle) {; // when connection closed, close panel as well; if (window) window.close();; }; }; });; </script>; </body>; </html>. ```; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md:3233,message,message,3233,documentation/users-guide/WebDisplay.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md,1,['message'],['message']
Integrability,"e code necessary to register it with the offloading; runtime. Usage; =====. This tool can be used with the following options. Any arguments not intended; only for the linker wrapper will be forwarded to the wrapped linker job. .. code-block:: console. USAGE: clang-linker-wrapper [options] -- <options to passed to the linker>. OPTIONS:; --bitcode-library=<kind>-<triple>-<arch>=<path>; Extra bitcode library to link; --cuda-path=<dir> Set the system CUDA path; --device-debug Use debugging; --device-linker=<value> or <triple>=<value>; Arguments to pass to the device linker invocation; --dry-run Print program arguments without running; --embed-bitcode Embed linked bitcode in the module; --help-hidden Display all available options; --help Display available options (--help-hidden for more); --host-triple=<triple> Triple to use for the host compilation; --linker-path=<path> The linker executable to invoke; -L <dir> Add <dir> to the library search path; -l <libname> Search for library <libname>; --opt-level=<O0, O1, O2, or O3>; Optimization level for LTO; -o <path> Path to file to write output; --pass-remarks-analysis=<value>; Pass remarks for LTO; --pass-remarks-missed=<value>; Pass remarks for LTO; --pass-remarks=<value> Pass remarks for LTO; --print-wrapped-module Print the wrapped module's IR for testing; --ptxas-arg=<value> Argument to pass to the 'ptxas' invocation; --save-temps Save intermediate results; --sysroot<value> Set the system root; --verbose Verbose output from tools; --v Display the version number and exit; -- The separator for the wrapped linker arguments. Example; =======. This tool links object files with offloading images embedded within it using the; ``-fembed-offload-object`` flag in Clang. Given an input file containing the; magic section we can pass it to this tool to extract the data contained at that; section and run a device linking job on it. .. code-block:: console. clang-linker-wrapper --host-triple=x86_64 --linker-path=/usr/bin/ld -- <Args>; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst:2588,wrap,wrapper,2588,interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangLinkerWrapper.rst,1,['wrap'],['wrapper']
Integrability,"e constructors:. * ``FixItHint::CreateInsertion(Loc, Code)``. Specifies that the given ``Code`` (a string) should be inserted before the; source location ``Loc``. * ``FixItHint::CreateRemoval(Range)``. Specifies that the code in the given source ``Range`` should be removed. * ``FixItHint::CreateReplacement(Range, Code)``. Specifies that the code in the given source ``Range`` should be removed,; and replaced with the given ``Code`` string. .. _DiagnosticConsumer:. The ``DiagnosticConsumer`` Interface; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Once code generates a diagnostic with all of the arguments and the rest of the; relevant information, Clang needs to know what to do with it. As previously; mentioned, the diagnostic machinery goes through some filtering to map a; severity onto a diagnostic level, then (assuming the diagnostic is not mapped; to ""``Ignore``"") it invokes an object that implements the ``DiagnosticConsumer``; interface with the information. It is possible to implement this interface in many different ways. For; example, the normal Clang ``DiagnosticConsumer`` (named; ``TextDiagnosticPrinter``) turns the arguments into strings (according to the; various formatting rules), prints out the file/line/column information and the; string, then prints out the line of code, the source ranges, and the caret.; However, this behavior isn't required. Another implementation of the ``DiagnosticConsumer`` interface is the; ``TextDiagnosticBuffer`` class, which is used when Clang is in ``-verify``; mode. Instead of formatting and printing out the diagnostics, this; implementation just captures and remembers the diagnostics as they fly by.; Then ``-verify`` compares the list of produced diagnostics to the list of; expected ones. If they disagree, it prints out its own output. Full; documentation for the ``-verify`` mode can be found at; :ref:`verifying-diagnostics`. There are many other possible implementations of this interface, and this is; why we prefer diagnostics to p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:21327,interface,interface,21327,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['interface'],['interface']
Integrability,"e current ``#include`` stack that was; active when the location was processed. For example, if the location; corresponds to a token, it should contain the set of ``#include``\ s active; when the token was lexed. This allows us to print the ``#include`` stack; for a diagnostic.; #. ``SourceLocation`` must be able to describe macro expansions, capturing both; the ultimate instantiation point and the source of the original character; data. In practice, the ``SourceLocation`` works together with the ``SourceManager``; class to encode two pieces of information about a location: its spelling; location and its expansion location. For most tokens, these will be the; same. However, for a macro expansion (or tokens that came from a ``_Pragma``; directive) these will describe the location of the characters corresponding to; the token and the location where the token was used (i.e., the macro; expansion point or the location of the ``_Pragma`` itself). The Clang front-end inherently depends on the location of a token being tracked; correctly. If it is ever incorrect, the front-end may get confused and die.; The reason for this is that the notion of the ""spelling"" of a ``Token`` in; Clang depends on being able to find the original input characters for the; token. This concept maps directly to the ""spelling location"" for the token. ``SourceRange`` and ``CharSourceRange``; ---------------------------------------. .. mostly taken from https://discourse.llvm.org/t/code-ranges-of-tokens-ast-elements/16893/2. Clang represents most source ranges by [first, last], where ""first"" and ""last""; each point to the beginning of their respective tokens. For example consider; the ``SourceRange`` of the following statement:. .. code-block:: text. x = foo + bar;; ^first ^last. To map from this representation to a character-based representation, the ""last""; location needs to be adjusted to point to (or past) the end of that token with; either ``Lexer::MeasureTokenLength()`` or ``Lexer::getLocForEndO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:24744,depend,depends,24744,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['depends']
Integrability,"e default since v6.20 (Unix) and v6.22 (OSX). ## Design Goals. * Coherence with standard C++ -- C++ Modules TS is advancing and will be; likely part the upcoming C++20 standard;; * Performance -- provide performance that is competitive to ROOT with PCH and; advance further the implementation of the C++ Modules in clang to optimize; memory footprint and execution time;; * Incremental adoption -- provide third-party code with an incremental; migration process for their codebases. ## Motivation. An implementation of the modules concepts exists in the LLVM frontend Clang used; as a library by ROOT [[2]]. Clang supports the Modules TS and hosts modules ; research and development work. The implementation encourages incremental, ; bottom-up [[3]] adoption of the modules feature. Modules in Clang are designed; to work for C, C++, ObjectiveC, ObjectiveC++ and Swift. Users can enable the; modules feature without modifications in header files. The LLVM compiler allows; users to specify module interfaces in dedicated file, called *module maps files*.; A module map file expresses the mapping between a module file and a collection; of header files. If the compiler finds such file in the include paths it; automatically generates, imports and uses module files. The module map files can; be mounted using the compiler's virtual file system overlay mechanism to; non-writable production library installations. In practice, a non-invasive *modularization* can be done easily by introducing; a module map file. ```cpp; // A.h ; int pow2(int x) {; return x * x;; }; ```; ```cpp; // B.cpp; #include ""A.h"" // clang rewires this to import A.; int main() {; return pow2(42);; }; ```. ```cpp; // A.h module interface, aka module map file; module A {; header ""A.h""; export * // clang exports the contents of A.h as part of module A.; }; ```. A.h defines *pow2*, the module map file instructs clang to create *A.pcm* and; import it in B.cpp. In a number of cases the module map files can be automatically ge",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:2628,interface,interfaces,2628,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['interface'],['interfaces']
Integrability,"e enables the ``Expand`` conversion technique for; non-v9 SPARC implementations. .. code-block:: c++. setOperationAction(ISD::CTPOP, MVT::i32, Expand);; ...; if (TM.getSubtarget<SparcSubtarget>().isV9()); setOperationAction(ISD::CTPOP, MVT::i32, Legal);. Calling Conventions; -------------------. To support target-specific calling conventions, ``XXXGenCallingConv.td`` uses; interfaces (such as ``CCIfType`` and ``CCAssignToReg``) that are defined in; ``lib/Target/TargetCallingConv.td``. TableGen can take the target descriptor; file ``XXXGenCallingConv.td`` and generate the header file; ``XXXGenCallingConv.inc``, which is typically included in; ``XXXISelLowering.cpp``. You can use the interfaces in; ``TargetCallingConv.td`` to specify:. * The order of parameter allocation. * Where parameters and return values are placed (that is, on the stack or in; registers). * Which registers may be used. * Whether the caller or callee unwinds the stack. The following example demonstrates the use of the ``CCIfType`` and; ``CCAssignToReg`` interfaces. If the ``CCIfType`` predicate is true (that is,; if the current argument is of type ``f32`` or ``f64``), then the action is; performed. In this case, the ``CCAssignToReg`` action assigns the argument; value to the first available register: either ``R0`` or ``R1``. .. code-block:: text. CCIfType<[f32,f64], CCAssignToReg<[R0, R1]>>. ``SparcCallingConv.td`` contains definitions for a target-specific return-value; calling convention (``RetCC_Sparc32``) and a basic 32-bit C calling convention; (``CC_Sparc32``). The definition of ``RetCC_Sparc32`` (shown below) indicates; which registers are used for specified scalar return types. A single-precision; float is returned to register ``F0``, and a double-precision float goes to; register ``D0``. A 32-bit integer is returned in register ``I0`` or ``I1``. .. code-block:: text. def RetCC_Sparc32 : CallingConv<[; CCIfType<[i32], CCAssignToReg<[I0, I1]>>,; CCIfType<[f32], CCAssignToReg<[F0]>>,; CCIfTy",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:62385,interface,interfaces,62385,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['interface'],['interfaces']
Integrability,"e end-point URL for local; files; Improve realtime notification during 'verify'. TProofDraw. Fix a problem with the axis ranges of the underlying; histogram in PolyMarker3D; Allow to use the default pad instead of forcing; creation of one pad per object; Add wrapper to handle the feedback default canvas. TEventIter. Fix a problem with changing the tree cache size: the; size was reset to the default value after the first file. TDataSetManagerFile. Solve a consistency problem in checking URLs for; duplication when adding them to the relevant TFileInfo; During dataset validation, do not fail on duplications; but notify and add them to the bad file list. TPacketizerAdaptive, TPacketizer. Improve data node / worker matching by always using the; host FQDN. TPacketizerUnit, TEventIter. Make sure that the entry; number passed to TSelector::Process is unique and in increasing order; for non-data driven processing (packetizer TPacketizerUnit). This; allows to give a meaning to this variable, for example to related it to; one dimension of an integration. Fixes in PROOF-Lite:. Make sure that with envs settings via TProof::AddEnvVar; are effective; this enables, for example, the automatic valgrind setup; introduced in 5.24/00 or the experiment specific settings via the; script defined by the env PROOF_INIT; Fix a problem with TProof::Load so that now it can be; also be used for PROOF-Lite. TProofPlayerRemote. In SendSelector, add misisng; option kCpBin when sending the selector source; the binary files were;  never retrieved, even if present and valid. TProofPlayerSlave. In; Process, fix a problem with cache directory locking while building; the selector;  the net effect was that each worker process was; re-buidling its own selector binary. . TProofServ; Fix; the order in which the log file is sent in asynchronous processing; the; wrong order was screwing up an immediate synchronous query submission; after an asynchronous run; this case occured, for example, in; 'stressProof' . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html:9094,integrat,integration,9094,proof/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html,1,['integrat'],['integration']
Integrability,"e environment variables.""); endif(); # RULE_LAUNCH_COMPILE should work with Ninja but currently has issues; # with cmd.exe and some MSVC tools other than cl.exe; set(CMAKE_C_COMPILER_LAUNCHER ${CCACHE_PROGRAM}); set(CMAKE_CXX_COMPILER_LAUNCHER ${CCACHE_PROGRAM}); endif(); else(); message(FATAL_ERROR ""Unable to find the program ccache. Set LLVM_CCACHE_BUILD to OFF""); endif(); endif(). set(LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS """" CACHE STRING; ""Optional arguments for the native tool used in CMake --build invocations for external projects.""); mark_as_advanced(LLVM_EXTERNAL_PROJECT_BUILD_TOOL_ARGS). option(LLVM_DEPENDENCY_DEBUGGING ""Dependency debugging mode to verify correctly expressed library dependencies (Darwin only)"" OFF). # Some features of the LLVM build may be disallowed when dependency debugging is; # enabled. In particular you cannot use ccache because we want to force compile; # operations to always happen.; if(LLVM_DEPENDENCY_DEBUGGING); if(NOT CMAKE_HOST_APPLE); message(FATAL_ERROR ""Dependency debugging is only currently supported on Darwin hosts.""); endif(); if(LLVM_CCACHE_BUILD); message(FATAL_ERROR ""Cannot enable dependency debugging while using ccache.""); endif(); endif(). option(LLVM_ENABLE_DAGISEL_COV ""Debug: Prints tablegen patterns that were used for selecting"" OFF); option(LLVM_ENABLE_GISEL_COV ""Enable collection of GlobalISel rule coverage"" OFF); if(LLVM_ENABLE_GISEL_COV); set(LLVM_GISEL_COV_PREFIX ""${CMAKE_BINARY_DIR}/gisel-coverage-"" CACHE STRING ""Provide a filename prefix to collect the GlobalISel rule coverage""); endif(). # Add path for custom modules; list(INSERT CMAKE_MODULE_PATH 0; ""${CMAKE_CURRENT_SOURCE_DIR}/cmake""; ""${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules""; ""${LLVM_COMMON_CMAKE_UTILS}/Modules""; ). # Generate a CompilationDatabase (compile_commands.json file) for our build,; # for use by clang_complete, YouCompleteMe, etc.; set(CMAKE_EXPORT_COMPILE_COMMANDS 1). option(LLVM_INSTALL_BINUTILS_SYMLINKS; ""Install symlinks from the binutils t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:12446,message,message,12446,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"e environment. # Example usage:; # cmake -G Ninja -DLLVM_CREATE_XCODE_TOOLCHAIN=On; # -DCMAKE_INSTALL_PREFIX=$PWD/install; # ninja install-xcode-toolchain; # export EXTERNAL_TOOLCHAINS_DIR=$PWD/install/Toolchains; # export TOOLCHAINS=org.llvm.3.8.0svn. # `xcrun -find clang` should return the installed clang, and `clang --version`; # should show 3.8.0svn. if(NOT APPLE); return(); endif(). option(LLVM_CREATE_XCODE_TOOLCHAIN ""Create a target to install LLVM into an Xcode toolchain"" Off). if(NOT LLVM_CREATE_XCODE_TOOLCHAIN); return(); endif(). # XCODE_VERSION is set by CMake when using the Xcode generator, otherwise we need; # to detect it manually here.; if(NOT XCODE_VERSION); execute_process(; COMMAND xcodebuild -version; OUTPUT_VARIABLE xcodebuild_version; OUTPUT_STRIP_TRAILING_WHITESPACE; ERROR_FILE /dev/null; ); string(REGEX MATCH ""Xcode ([0-9][0-9]?([.][0-9])+)"" version_match ${xcodebuild_version}); if(version_match); message(STATUS ""Identified Xcode Version: ${CMAKE_MATCH_1}""); set(XCODE_VERSION ${CMAKE_MATCH_1}); else(); # If detecting Xcode version failed, set a crazy high version so we default; # to the newest.; set(XCODE_VERSION 99); message(WARNING ""Failed to detect the version of an installed copy of Xcode, falling back to highest supported version. Set XCODE_VERSION to override.""); endif(); endif(). # Xcode 8 requires CompatibilityVersion 2; set(COMPAT_VERSION 2); if(XCODE_VERSION VERSION_LESS 8.0.0); # Xcode 7.3 (the first version supporting external toolchains) requires; # CompatibilityVersion 1; set(COMPAT_VERSION 1); endif(). execute_process(; COMMAND xcrun -find otool; OUTPUT_VARIABLE clang_path; OUTPUT_STRIP_TRAILING_WHITESPACE; ERROR_FILE /dev/null; ); string(REGEX MATCH ""(.*/Toolchains)/.*"" toolchains_match ${clang_path}); if(NOT toolchains_match); message(FATAL_ERROR ""Could not identify toolchain dir""); endif(); set(toolchains_dir ${CMAKE_MATCH_1}). set(LLVMToolchainDir ""${CMAKE_INSTALL_PREFIX}/Toolchains/LLVM${PACKAGE_VERSION}.xctoolchain/""). add",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt:2210,message,message,2210,interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/xcode-toolchain/CMakeLists.txt,1,['message'],['message']
Integrability,"e following rule: the property; should be set with the setter, not though a direct assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions; (ObjC); Check for direct assignments to instance variables in the methods annotated; with objc_no_direct_instance_variable_assignment. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. alpha.osx.cocoa.InstanceVariableInvalidation; (ObjC); Check that the invalidatable instance variables are invalidated in the methods; annotated with objc_instance_variable_invalidator. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. alpha.osx.cocoa.MissingInvalidationMethod; (ObjC); Check that the invalidation methods are present in classes that contain; invalidatable instance variables. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. alpha.osx.cocoa.localizability.PluralMisuseChecker; (ObjC); Warns against using one vs. many plural pattern in code; when generating ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:8149,protocol,protocol,8149,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['protocol'],['protocol']
Integrability,"e following to your `.vimrc`:. .. code-block:: vim. if has('python'); map <C-K> :pyf <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; elseif has('python3'); map <C-K> :py3f <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; endif. The first line enables :program:`clang-format` for NORMAL and VISUAL mode, the; second line adds support for INSERT mode. Change ""C-K"" to another binding if; you need :program:`clang-format` on a different key (C-K stands for Ctrl+k). With this integration you can press the bound key and clang-format will; format the current line in NORMAL and INSERT mode or the selected region in; VISUAL mode. The line or region is extended to the next bigger syntactic; entity. It operates on the current, potentially unsaved buffer and does not create; or save any files. To revert a formatting, just undo. An alternative option is to format changes when saving a file and thus to; have a zero-effort integration into the coding workflow. To do this, add this to; your `.vimrc`:. .. code-block:: vim. function! Formatonsave(); let l:formatdiff = 1; pyf <path-to-this-file>/clang-format.py; endfunction; autocmd BufWritePre *.h,*.cc,*.cpp call Formatonsave(). Emacs Integration; =================. Similar to the integration for :program:`vim`, there is an integration for; :program:`emacs`. It can be found at `clang/tools/clang-format/clang-format.el`; and used by adding this to your `.emacs`:. .. code-block:: common-lisp. (load ""<path-to-clang>/tools/clang-format/clang-format.el""); (global-set-key [C-M-tab] 'clang-format-region). This binds the function `clang-format-region` to C-M-tab, which then formats the; current line or selected region. BBEdit Integration; ==================. :program:`clang-format` cannot be used as a text filter with BBEdit, but works; well via a script. The AppleScript to do this integration can be found at; `clang/tools/clang-format/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:7704,integrat,integration,7704,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['integrat'],['integration']
Integrability,"e functionally related controls. ![](pictures/02000207.jpg). It is a composite frame with a border and a title. The title explains; the purpose of the group and should be a noun or noun phrase. Here is an; example taken from `guitest.C`:. ``` {.cpp}; groupFrame = new TGGroupFrame(tf,""Options"",kVerticalFrame);; groupFrame->SetTitlePos(TGGroupFrame::kLeft);; ```. The second line sets the title position on the left. You can change it; to be centered or right aligned if you use **`TGGroupFrame::kCenter`** or; `TGGroupFrame::kRight` as a parameter. ![](pictures/02000208.jpg). Be conservative in the use of borders because of the potential for; clutter. Do not place them around single entry fields, single combo; boxes, list boxes and groups of command buttons. The design of these; widgets provides them with a border. The picture above provides kind of; borders to avoid. ## Layout Management. The layout process is an integral part of any GUI. When you create a; simple message window, laying out its few buttons and text widgets is; quite simple. However, this process becomes increasingly difficult if; you have to implement large GUI's with many widgets that should behave; properly when the GUI is resized or uses a different font type or size.; Layout management is the process of determining the size and position of; every widget in a container. A layout manager is an object that performs layout management for the; widgets within a container. You already know that when adding a; component (child widget) to a container (parent widget) you can provide; alignment hints (or rely on the default ones). These hints are used by; the layout manager to correctly position the widgets in the container.; The **`TGLayoutManager`** is an abstract class providing the basic; layout functionality. ![The layout classes hierarchy](pictures/02000209.jpg). The base ""container"" class is **`TGCmpositeFrame`**. You can easily; change the layout manager using the; `SetLayoutManager(TGLayoutManager *l)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:33681,message,message,33681,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['message'],['message']
Integrability,"e global module fragments; of different module units, it is not free for clang to deal with the duplicated; declarations. In other word, for a translation unit, it will compile slower if the; translation unit itself and its importing module units contains a lot duplicated; declarations. For example,. .. code-block:: c++. // M-partA.cppm; module;; #include ""big.header.h""; export module M:partA;; ... // M-partB.cppm; module;; #include ""big.header.h""; export module M:partB;; ... // other partitions; ... // M-partZ.cppm; module;; #include ""big.header.h""; export module M:partZ;; ... // M.cppm; export module M;; export import :partA;; export import :partB;; ...; export import :partZ;. // use.cpp; import M;; ... // use declarations from module M. When ``big.header.h`` is big enough and there are a lot of partitions,; the compilation of ``use.cpp`` may be slower than; the following style significantly:. .. code-block:: c++. module;; #include ""big.header.h""; export module m:big.header.wrapper;; export ... // export the needed declarations. // M-partA.cppm; export module M:partA;; import :big.header.wrapper;; ... // M-partB.cppm; export module M:partB;; import :big.header.wrapper;; ... // other partitions; ... // M-partZ.cppm; export module M:partZ;; import :big.header.wrapper;; ... // M.cppm; export module M;; export import :partA;; export import :partB;; ...; export import :partZ;. // use.cpp; import M;; ... // use declarations from module M. The key part of the tip is to reduce the duplications from the text includes. Known Problems; --------------. The following describes issues in the current implementation of modules.; Please see https://github.com/llvm/llvm-project/labels/clang%3Amodules for more issues; or file a new issue if you don't find an existing one.; If you're going to create a new issue for standard C++ modules,; please start the title with ``[C++20] [Modules]`` (or ``[C++23] [Modules]``, etc); and add the label ``clang:modules`` (if you have permissions for ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:20563,wrap,wrapper,20563,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['wrap'],['wrapper']
Integrability,"e has now automatically the sum of the weight squared stored inside, without the need to call anymore; `TH1::Sumw2()`. As a consequences an histogram filled with weights will always draw the errors by default. If one desire to continue having the histogram drawn; without the errors, one should use the `hist` option: `h.Draw(""hist"")`.; If, for memory reason, one does not want to remove the internal array storing the bin errors (the bin sum of weight square), one can use the function `TH1::Sumw2(false)`. - The copy constructor is not anymore public for TH1. Before (in 5.34) this code was allowed by the compiler, although giving undefined behavior: now not anymore:. ``` {.cpp}; TH1D h1;; TH1 h2(h1);; ```; Now this code is not allowed anymore. It will give a compilation error.; The copy constructor of the derived classes (`TH1D` in this example) should instead be used.; This applies also for `TH2` and `TH3`.; In case you want to copy histograms using the TH1 interface, you can use either `TObject::Clone`, which uses the I/O system and can be unconvenient in some cases (e.g. in a multi-threaded; environment) or `TH1::Copy` which is public since some of the latest 5.34 revisions together with `TClass::New` as following:. ``` {.cpp}; TH1 * h2 = (TH1*) h1->IsA()->New();; h1->Copy(*h2);; ```; Note that `TH1::Copy` does not copy the attached list of functions, while `TH1::Clone()` does a deep copy also of the contained functions. - Add new method `TH1::GetNCells` to retrieve the total number of bins of an histogram including underflow and overflows. This is the product of all the bins in each dimension. - The methods `GetCellContent`, `GetCellError` and `SetCellContent` and `SetCellError` have been deprecated. Get/SetBinContent and Get/SetBinError should be instead used and they have exactly the; same functionality. - The following code should produce a plot. It did not. ``` {.cpp}; TH1F* h=new TH1F(""hist"", ""histogram"", 10, 0, 3);; h->FillRandom(""gaus"");; h->Draw(""same"");; ```",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md:8978,interface,interface,8978,hist/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md,1,['interface'],['interface']
Integrability,"e header file; for that function is not exposed. As with functions, this prevents inadvertent; use of data that might not exist on all platforms. Minimize Soft Errors; --------------------. Operating system interfaces will generally provide error results for every; little thing that could go wrong. In almost all cases, you can divide these; error results into two groups: normal/good/soft and abnormal/bad/hard. That is,; some of the errors are simply information like ""file not found"", ""insufficient; privileges"", etc. while other errors are much harder like ""out of space"", ""bad; disk sector"", or ""system call interrupted"". We'll call the first group ""*soft*""; errors and the second group ""*hard*"" errors. ``lib/Support`` must always attempt to minimize soft errors. This is a design; requirement because the minimization of soft errors can affect the granularity; and the nature of the interface. In general, if you find that you're wanting to; throw soft errors, you must review the granularity of the interface because it; is likely you're trying to implement something that is too low level. The rule; of thumb is to provide interface functions that **can't** fail, except when; faced with hard errors. For a trivial example, suppose we wanted to add an ""``OpenFileForWriting``""; function. For many operating systems, if the file doesn't exist, attempting to; open the file will produce an error. However, ``lib/Support`` should not simply; throw that error if it occurs because its a soft error. The problem is that the; interface function, ``OpenFileForWriting`` is too low level. It should be; ``OpenOrCreateFileForWriting``. In the case of the soft ""doesn't exist"" error,; this function would just create it and then open it for writing. This design principle needs to be maintained in ``lib/Support`` because it; avoids the propagation of soft error handling throughout the rest of LLVM.; Hard errors will generally just cause a termination for an LLVM tool so don't; be bashful about th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:8071,interface,interface,8071,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interface']
Integrability,"e it into a (hopefully) more optimized but semantically; equivalent form. In the original tutorial series the FunctionPassManager was; created outside the KaleidoscopeJIT and modules were optimized before being; added to it. In this Chapter we will make optimization a phase of our JIT; instead. For now this will provide us a motivation to learn more about ORC; layers, but in the long term making optimization part of our JIT will yield an; important benefit: When we begin lazily compiling code (i.e. deferring; compilation of each function until the first time it's run) having; optimization managed by our JIT will allow us to optimize lazily too, rather; than having to do all our optimization up-front. To add optimization support to our JIT we will take the KaleidoscopeJIT from; Chapter 1 and compose an ORC *IRTransformLayer* on top. We will look at how the; IRTransformLayer works in more detail below, but the interface is simple: the; constructor for this layer takes a reference to the execution session and the; layer below (as all layers do) plus an *IR optimization function* that it will; apply to each Module that is added via addModule:. .. code-block:: c++. class KaleidoscopeJIT {; private:; ExecutionSession ES;; RTDyldObjectLinkingLayer ObjectLayer;; IRCompileLayer CompileLayer;; IRTransformLayer TransformLayer;. DataLayout DL;; MangleAndInterner Mangle;; ThreadSafeContext Ctx;. public:. KaleidoscopeJIT(JITTargetMachineBuilder JTMB, DataLayout DL); : ObjectLayer(ES,; []() { return std::make_unique<SectionMemoryManager>(); }),; CompileLayer(ES, ObjectLayer, ConcurrentIRCompiler(std::move(JTMB))),; TransformLayer(ES, CompileLayer, optimizeModule),; DL(std::move(DL)), Mangle(ES, this->DL),; Ctx(std::make_unique<LLVMContext>()) {; ES.getMainJITDylib().addGenerator(; cantFail(DynamicLibrarySearchGenerator::GetForCurrentProcess(DL.getGlobalPrefix())));; }. Our extended KaleidoscopeJIT class starts out the same as it did in Chapter 1,; but after the CompileLayer we int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:2692,interface,interface,2692,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['interface'],['interface']
Integrability,"e library. Functions for filling the new ROOT::Fit::BinData classes with all the histogram and graph types have been added in the histogram library (libHist) and graph library:; ; ROOT::Fit::FillData( BinData & , const TH1 *, TF1 * ) for histograms (in libHist); ROOT::Fit::FillData( BinData & , const TGraph2D *, TF1 * ) for 2D graphs (in libHist); ROOT::Fit::FillData( BinData & , const TGraph *, TF1 * ) for all 1D graphs (in libGraf); ROOT::Fit::FillData( BinData & , const TMultiGraph *, TF1 * ) for multi-graphs (in libGraf); . MathCore Numerical Algorithms. Classes implementing numerical methods which can be used by all the other ROOT library have been added in MathCore. These originate mainly from methods present previously in the implementation of the TF1 class. Now they can be used also outside this class. In addition, in order to have a common entry point, interfaces classes for these numerical algorithms have been; included.; These interfaces are as well implemented by classes using the GSL library and located in the MathMore library. The library can be loaded automatically using the ROOT plug-in manager.; In detail, the new classes containing implementations present previously in TF1 are:. ; GaussIntegrator and GaussLegendreIntegrator for numerical integration of one-dimensional functions. The first class uses Gaussian 8 and 16 point quadrature approximation, it provides the translation of the CERNLIB algorithm; DGAUSS by Sigfried Kolbig, and it is used by the TF1::Integral method. The second one uses the Gauss Legendre quadrature formula. It is used by the TF1::IntegralFast method.; These classes implement both the same virtual interface as the adaptive integration methods provided by the MathMore library. They can all be created and used easily via the common class ROOT::Math::IntegratorOneDim providing the interfaces for numerical integration.; New template methods have been also included in the common Integration class in order to be able to integrate aut",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:6379,interface,interfaces,6379,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['interface'],['interfaces']
Integrability,"e looks like this:. .. code-block:: c++. enum DebugLev {; nodebuginfo, quick, detailed; };. // Enable Debug Options to be specified on the command line; cl::opt<DebugLev> DebugLevel(""debug_level"", cl::desc(""Set the debugging level:""),; cl::values(; clEnumValN(nodebuginfo, ""none"", ""disable debug information""),; clEnumVal(quick, ""enable quick debug information""),; clEnumVal(detailed, ""enable detailed debug information"")));. This definition defines an enumerated command line variable of type ""``enum; DebugLev``"", which works exactly the same way as before. The difference here is; just the interface exposed to the user of your program and the help output by; the ""``-help``"" option:. ::. USAGE: compiler [options] <input file>. OPTIONS:; Choose optimization level:; -g - No optimizations, enable debugging; -O1 - Enable trivial optimizations; -O2 - Enable default optimizations; -O3 - Enable expensive optimizations; -debug_level - Set the debugging level:; =none - disable debug information; =quick - enable quick debug information; =detailed - enable detailed debug information; -f - Enable binary output on terminals; -help - display available options (-help-hidden for more); -o <filename> - Specify output filename; -quiet - Don't print informational messages. Again, the only structural difference between the debug level declaration and; the optimization level declaration is that the debug level declaration includes; an option name (``""debug_level""``), which automatically changes how the library; processes the argument. The CommandLine library supports both forms so that you; can choose the form most appropriate for your application. .. _lists:. Parsing a list of options; -------------------------. Now that we have the standard run-of-the-mill argument types out of the way,; lets get a little wild and crazy. Lets say that we want our optimizer to accept; a **list** of optimizations to perform, allowing duplicates. For example, we; might want to run: ""``compiler -dce -instsimpl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:18664,message,messages,18664,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['message'],['messages']
Integrability,"e max number; of running; queries is determined dynamically.; Add support for repeat functionality in the xrd.worker; directive. To avoid repeating the same line N times; one can just add; 'repeat=N'; in the line; for; example;            ;     xpd.worker worker; proofwrks:2093 repeat=4; will define 4 workers on port 2093 of machine 'proofwrks'.; Add support for port specification via the directive; 'xpd.port'; Enable variable; substitution in 'xpd.' directives using the standard; Scalla mechanism described in; http://xrootd.slac.stanford.edu/doc/dev/Syntax_config.htm .; Build also a binary named 'xproofd' which runs; a xrootd; daemon with only the XrdProofdProtocol (i.e. no data serving).; This simplifies setups when data serving is not needed and also allows; to better disantagle problems related to one specific protocol. The new; binary accepts the same arguments as 'xrootd' and parses the same; directives form the same configuration file, with the exception of; 'xpd.protocol xproofd libXrdProofd.so' which should now be dropped. AN; alternative port can be specified via the new 'xpd.port' directive (see; above).; Add support for 'MasterOnly' mode in starting a PROOF; session. This avoids starting the workers when one wants just to browse; the datasets or retrieve results. To start a session in 'MasterOnly'; mode enter ""masteronly""; as second argument to TProof::Open, e.g.;  ;          root[]; TProof *p = TProof::Open(""<masterurl>"", ""masteronly""); Add full support for placeholders; <uid>,; <gid>, <group> and <homedir>; for the directives specified via 'xpd.putenv'; Add the configuration directive 'proofservparents' to; allow specifying a different list of parent names for the 'proofserv'; tasks. This is needed to avoid untimely killing of 'proofserv'; instances in test setups when multiple instances of the daemons are; running on the same machines under different names.; Add the possibility to switch to asynchronous mode while; running synchronously. A new button ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:1871,protocol,protocol,1871,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['protocol'],['protocol']
Integrability,"e metadata node shall consist of a single positive float type number; representing the maximum relative error, for example:. .. code-block:: llvm. !0 = !{ float 2.5 } ; maximum acceptable inaccuracy is 2.5 ULPs. .. _range-metadata:. '``range``' Metadata; ^^^^^^^^^^^^^^^^^^^^. ``range`` metadata may be attached only to ``load``, ``call`` and ``invoke`` of; integer or vector of integer types. It expresses the possible ranges the loaded; value or the value returned by the called function at this call site is in. If; the loaded or returned value is not in the specified range, a poison value is; returned instead. The ranges are represented with a flattened list of integers.; The loaded value or the value returned is known to be in the union of the ranges; defined by each consecutive pair. Each pair has the following properties:. - The type must match the scalar type of the instruction.; - The pair ``a,b`` represents the range ``[a,b)``.; - Both ``a`` and ``b`` are constants.; - The range is allowed to wrap.; - The range should not represent the full or empty set. That is,; ``a!=b``. In addition, the pairs must be in signed order of the lower bound and; they must be non-contiguous. For vector-typed instructions, the range is applied element-wise. Examples:. .. code-block:: llvm. %a = load i8, ptr %x, align 1, !range !0 ; Can only be 0 or 1; %b = load i8, ptr %y, align 1, !range !1 ; Can only be 255 (-1), 0 or 1; %c = call i8 @foo(), !range !2 ; Can only be 0, 1, 3, 4 or 5; %d = invoke i8 @bar() to label %cont; unwind label %lpad, !range !3 ; Can only be -2, -1, 3, 4 or 5; %e = load <2 x i8>, ptr %x, !range 0 ; Can only be <0 or 1, 0 or 1>; ...; !0 = !{ i8 0, i8 2 }; !1 = !{ i8 255, i8 2 }; !2 = !{ i8 0, i8 2, i8 3, i8 6 }; !3 = !{ i8 -2, i8 0, i8 3, i8 6 }. '``absolute_symbol``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``absolute_symbol`` metadata may be attached to a global variable; declaration. It marks the declaration as a reference to an absolute symbol,; which cause",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:285513,wrap,wrap,285513,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['wrap'],['wrap']
Integrability,"e method `TCanvas::cd()` with the pad number, as was done in; the example above:. ``` {.cpp}; root[] MyC->cd(3); ```. Pads are numbered from left to right and from top to bottom. Each new; pad created by `TCanvas::Divide()` has a name, which is the name of; the canvas followed by \_1, \_2, etc. To apply the method `cd()` to; the third pad, you would write:. ``` {.cpp}; root[] MyC_3->cd(); ```. - Third pad will be selected since you called `TPad::cd()` for the; object `MyC_3`. ROOT will find the pad that was named` MyC_3 `when; you typed it on the command line (see ROOT/Cling Extensions to; C++). ### Saving the Canvas. ![The SaveAs... dialog](pictures/0300002B.png). Using the File menu / Save cascade menu users can save the canvas as; one of the files from the list. Please note that saving the canvas; this way will overwrite the file with the same name without a warning. All supported file types can be saved via File menu / SaveAs... This; dialog gives a choice to show or suppress the confirmation message for; overwriting an existing file. If the Overwrite check box is not selected, a message dialog appears; asking the user to overwrite the file (Yes/No). The user choice is; saved for the next time the Save As... dialog shows up. ### Printing the Canvas. The Print command in the canvas File menu pops-up a print dialog where; the user can specify a preferred print command and the printer name. ![](pictures/0300002D.png). Both print parameters can be set via the new Print.Command and; Print.Printer rootrc resources as follows:. ```; # Printer settings.; WinNT.*.Print.Command: AcroRd32.exe; Unix.*.Print.Command: xprint -P%p %f; Print.Printer: 32-rb205-hp; Print.Directory: .; ```. If the `%p` and `%f` are specified as a part of the print command,; they will be replaced by the specified printer name and the file name.; All other parameters will be kept as they are written. A print button; is available in the canvas toolbar (activated via View menu/Toolbar). ## The ROOT Co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:24308,message,message,24308,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['message'],['message']
Integrability,"e most; popular host toolchains for specific minimum versions in our build systems:. * Clang 5.0; * Apple Clang 10.0; * GCC 7.4; * Visual Studio 2019 16.7. Anything older than these toolchains *may* work, but will require forcing the; build system with a special option and is not really a supported host platform.; Also note that older versions of these compilers have often crashed or; miscompiled LLVM. For less widely used host toolchains such as ICC or xlC, be aware that a very; recent version may be required to support all of the C++ features used in LLVM. We track certain versions of software that are *known* to fail when used as; part of the host toolchain. These even include linkers at times. **GNU ld 2.16.X**. Some 2.16.X versions of the ld linker will produce very long; warning messages complaining that some ""``.gnu.linkonce.t.*``"" symbol was; defined in a discarded section. You can safely ignore these messages as they are; erroneous and the linkage is correct. These messages disappear using ld 2.17. **GNU binutils 2.17**: Binutils 2.17 contains `a bug; <http://sourceware.org/bugzilla/show_bug.cgi?id=3111>`__ which causes huge link; times (minutes instead of seconds) when building LLVM. We recommend upgrading; to a newer version (2.17.50.0.4 or later). **GNU Binutils 2.19.1 Gold**: This version of Gold contained `a bug; <http://sourceware.org/bugzilla/show_bug.cgi?id=9836>`__ which causes; intermittent failures when building LLVM with position independent code. The; symptom is an error about cyclic dependencies. We recommend upgrading to a; newer version of Gold. Getting a Modern Host C++ Toolchain; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This section mostly applies to Linux and older BSDs. On macOS, you should; have a sufficiently modern Xcode, or you will likely need to upgrade until you; do. Windows does not have a ""system compiler"", so you must install either Visual; Studio 2019 (or later), or a recent version of mingw64. FreeBSD 10.0 and newer; have a modern",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:14243,message,messages,14243,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['message'],['messages']
Integrability,"e not everything; can be added in-line and this function helps split the code into multiple; lines. ### Step 3. analyticalIntegral() Use Case. > Besides the `evaluate()` function, this tutorial illustrates how the; `analyticalIntegral()` can be updated. This highly dependent on the class that; is being transformed for AD support, but will be necessary in those specific; instances. Let's consider a fictional class RooFoo, that performs some arbitrary; mathematical operations called 'Foo' (as seen in doFoo() function below). > Note that doFoo is a simplified example, in many cases the mathematical; operations are not limited to a single function, so they need to be spotted; within the `evaluate()` function. ``` {.cpp}; class RooFoo : public RooAbsReal {; int a;; int b;; int doFoo() { return a* b + a + b; }; int integralFoo() { return /* whatever */;}; public:; // Other functions...; double evaluate() override {; // Do some bookkeeping; return doFoo();; };; double analyticalIntegral(Int_t code, const char* rangeName) override {; // Select the right paths for integration using codes or whatever.; return integralFoo();; }; };; ```. \note All RooFit classes are deriving from the RooAbsReal object, but; its details are not relevant to the current example. Note how the `evaluate()` function overrides the `RooAbsReal` for the RooFoo; class. Similarly, the `analyticalIntegral()` function has also been overridden; from the `RooAbsReal` class. The `evaluate()` function includes some bookkeeping steps (commented out in; above example) that are not relevant to AD. The important part is that it; calls a specific function (doFoo() in this example), and returns the results. Similarly, the `analyticalIntegral()` function calls a specific function (; `integralFoo()` in this example), and returns the results. It may also include; some code that may need to be looked at, but for simplicity, its contents are; commented out in this example. #### Adding Code Generation Support to RooFoo cl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:19676,integrat,integration,19676,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['integrat'],['integration']
Integrability,"e numbered sequentially starting from 0. From the example output above, we know the following:. * Instruction [1,0] was dispatched at cycle 1.; * Instruction [1,0] started executing at cycle 2.; * Instruction [1,0] reached the write back stage at cycle 4.; * Instruction [1,0] was retired at cycle 10. Instruction [1,0] (i.e., vmulps from iteration #1) does not have to wait in the; scheduler's queue for the operands to become available. By the time vmulps is; dispatched, operands are already available, and pipeline JFPU1 is ready to; serve another instruction. So the instruction can be immediately issued on the; JFPU1 pipeline. That is demonstrated by the fact that the instruction only; spent 1cy in the scheduler's queue. There is a gap of 5 cycles between the write-back stage and the retire event.; That is because instructions must retire in program order, so [1,0] has to wait; for [0,2] to be retired first (i.e., it has to wait until cycle 10). In the example, all instructions are in a RAW (Read After Write) dependency; chain. Register %xmm2 written by vmulps is immediately used by the first; vhaddps, and register %xmm3 written by the first vhaddps is used by the second; vhaddps. Long data dependencies negatively impact the ILP (Instruction Level; Parallelism). In the dot-product example, there are anti-dependencies introduced by; instructions from different iterations. However, those dependencies can be; removed at register renaming stage (at the cost of allocating register aliases,; and therefore consuming physical registers). Table *Average Wait times* helps diagnose performance issues that are caused by; the presence of long latency instructions and potentially long data dependencies; which may limit the ILP. Last row, ``<total>``, shows a global average over all; instructions measured. Note that :program:`llvm-mca`, by default, assumes at; least 1cy between the dispatch event and the issue event. When the performance is limited by data dependencies and/or long ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:24909,depend,dependency,24909,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['dependency']
Integrability,"e out of your application into the; library. This is just one example of how using flags can alter the default; behaviour of the library, on a per-option basis. By adding one of the; declarations above, the ``-help`` option synopsis is now extended to:. ::. USAGE: compiler [options] <input file>. OPTIONS:; -h - Alias for -help; -help - display available options (-help-hidden for more); -o <filename> - Specify output filename. ... indicating that an input filename is expected. Boolean Arguments; -----------------. In addition to input and output filenames, we would like the compiler example to; support three boolean flags: ""``-f``"" to force writing binary output to a; terminal, ""``--quiet``"" to enable quiet mode, and ""``-q``"" for backwards; compatibility with some of our users. We can support these by declaring options; of boolean type like this:. .. code-block:: c++. cl::opt<bool> Force (""f"", cl::desc(""Enable binary output on terminals""));; cl::opt<bool> Quiet (""quiet"", cl::desc(""Don't print informational messages""));; cl::opt<bool> Quiet2(""q"", cl::desc(""Don't print informational messages""), cl::Hidden);. This does what you would expect: it declares three boolean variables; (""``Force``"", ""``Quiet``"", and ""``Quiet2``"") to recognize these options. Note; that the ""``-q``"" option is specified with the ""`cl::Hidden`_"" flag. This; modifier prevents it from being shown by the standard ""``-help``"" output (note; that it is still shown in the ""``-help-hidden``"" output). The CommandLine library uses a `different parser`_ for different data types.; For example, in the string case, the argument passed to the option is copied; literally into the content of the string variable... we obviously cannot do that; in the boolean case, however, so we must use a smarter parser. In the case of; the boolean parser, it allows no options (in which case it assigns the value of; true to the variable), or it allows the values ""``true``"" or ""``false``"" to be; specified, allowing any of the followi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:9330,message,messages,9330,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,2,['message'],['messages']
Integrability,"e path is relative to a changing working directory. These environment variables are handy when you need to request the statistics; report without changing your build scripts or alter the existing set of compiler; options. Note that ``-fproc-stat-report`` take precedence over ``CC_PRINT_PROC_STAT``; and ``CC_PRINT_PROC_STAT_FILE``. .. code-block:: console. $ export CC_PRINT_PROC_STAT=1; $ export CC_PRINT_PROC_STAT_FILE=~/project-build-proc-stat.csv; $ make. Other Options; -------------; Clang options that don't fit neatly into other categories. .. option:: -fgnuc-version=. This flag controls the value of ``__GNUC__`` and related macros. This flag; does not enable or disable any GCC extensions implemented in Clang. Setting; the version to zero causes Clang to leave ``__GNUC__`` and other; GNU-namespaced macros, such as ``__GXX_WEAK__``, undefined. .. option:: -MV. When emitting a dependency file, use formatting conventions appropriate; for NMake or Jom. Ignored unless another option causes Clang to emit a; dependency file. When Clang emits a dependency file (e.g., you supplied the -M option); most filenames can be written to the file without any special formatting.; Different Make tools will treat different sets of characters as ""special""; and use different conventions for telling the Make tool that the character; is actually part of the filename. Normally Clang uses backslash to ""escape""; a special character, which is the convention used by GNU Make. The -MV; option tells Clang to put double-quotes around the entire filename, which; is the convention used by NMake and Jom. .. option:: -femit-dwarf-unwind=<value>. When to emit DWARF unwind (EH frame) info. This is a Mach-O-specific option. Valid values are:. * ``no-compact-unwind`` - Only emit DWARF unwind when compact unwind encodings; aren't available. This is the default for arm64.; * ``always`` - Always emit DWARF unwind regardless.; * ``default`` - Use the platform-specific default (``always`` for all; non-arm64-p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:29250,depend,dependency,29250,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['depend'],['dependency']
Integrability,"e resides in. .. code-block:: c++. someMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; });. someMethod(someOtherMethod(; [](SomeReallyLongLambdaSignatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **Macro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:83880,protocol,protocol-buffers,83880,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['protocol'],['protocol-buffers']
Integrability,"e run using ``check-fuzzer`` target from the build directory; which was configured with ``-DCOMPILER_RT_INCLUDE_TESTS=ON`` flag. .. code-block:: console. ninja check-fuzzer. FAQ; =========================. Q. Why doesn't libFuzzer use any of the LLVM support?; -----------------------------------------------------. There are two reasons. First, we want this library to be used outside of the LLVM without users having to; build the rest of LLVM. This may sound unconvincing for many LLVM folks,; but in practice the need for building the whole LLVM frightens many potential; users -- and we want more users to use this code. Second, there is a subtle technical reason not to rely on the rest of LLVM, or; any other large body of code (maybe not even STL). When coverage instrumentation; is enabled, it will also instrument the LLVM support code which will blow up the; coverage set of the process (since the fuzzer is in-process). In other words, by; using more external dependencies we will slow down the fuzzer while the main; reason for it to exist is extreme speed. Q. Does libFuzzer Support Windows?; ------------------------------------------------------------------------------------. Yes, libFuzzer now supports Windows. Initial support was added in r341082.; Any build of Clang 9 supports it. You can download a build of Clang for Windows; that has libFuzzer from; `LLVM Snapshot Builds <https://llvm.org/builds/>`_. Using libFuzzer on Windows without ASAN is unsupported. Building fuzzers with the; ``/MD`` (dynamic runtime library) compile option is unsupported. Support for these; may be added in the future. Linking fuzzers with the ``/INCREMENTAL`` link option; (or the ``/DEBUG`` option which implies it) is also unsupported. Send any questions or comments to the mailing list: libfuzzer(#)googlegroups.com. Q. When libFuzzer is not a good solution for a problem?; ---------------------------------------------------------. * If the test inputs are validated by the target library and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:28403,depend,dependencies,28403,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['depend'],['dependencies']
Integrability,"e same on-disk representation as a user-defined class. ## Limits. This section summarizes key design limits of RNTuple data sets.; The limits refer to a single RNTuple and do not consider combinations/joins such as ""friends"" and ""chains"". | Limit | Value | Reason / Comment |; |------------------------------------------------|------------------------------|--------------------------------------------------------|; | Maximum volume | 10 PB (theoretically more) | Assuming 10k cluster groups of 10k clusters of 100MB |; | Maximum number of elements, entries | 2^63 | Using default (Split)Index64, otherwise 2^32 |; | Maximum cluster & entry size | 8TB (depends on pagination) | Assuming limit of 4B pages of 4kB each |; | Maximum page size | 2B elements, 256MB - 24GB | #elements * element size |; | Maximum element size | 8kB | 16bit for number of bits per element |; | Maximum number of column types | 64k | 16bit for column type |; | Maximum envelope size | 2^48B (~280TB) | Envelope header encoding |; | Maximum frame size | 2^62B, 4B items (list frame) | Frame preamble encoding |; | Maximum field / type version | 4B | Field meta-data encoding |; | Maximum number of fields, columns | 4B (foreseen: <10M) | 32bit column / field IDs, list frame limit |; | Maximum number of cluster groups | 4B (foreseen: <10k) | List frame limits |; | Maximum number of clusters per group | 4B (foreseen: <10k) | List frame limits, cluster group summary encoding |; | Maximum number of pages per cluster per column | 4B | List frame limits |; | Maximum number of entries per cluster | 2^56 | Cluster summary encoding |; | Maximum string length (meta-data) | 4GB | String encoding |; | Maximum RBlob size | 128 PiB | 1GiB / 8B * 1GiB (with maxKeySize=1GiB, offsetSize=8B) |. ## Glossary. ### Anchor. The anchor is a data block that represents the entry point to an RNTuple.; The anchor is specific to the RNTuple container in which the RNTuple data are embedded (e.g., a ROOT file or an object store).; The ancho",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:48825,depend,depends,48825,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['depend'],['depends']
Integrability,"e second property, let us look at f2 as an example. In the interleaved layout,; there are two entries for f2: B::f2 and D::f2. The distance between &B::f2; and its address point D::offset-to-top (the entry immediately after &B::rtti) is 5 entry-length, so is the distance between &D::f2 and C::offset-to-top (the entry immediately after &D::rtti). Forward-Edge CFI for Indirect Function Calls; ============================================. Under forward-edge CFI for indirect function calls, each unique function; type has its own bit vector, and at each call site we need to check that the; function pointer is a member of the function type's bit vector. This scheme; works in a similar way to forward-edge CFI for virtual calls, the distinction; being that we need to build bit vectors of function entry points rather than; of virtual tables. Unlike when re-arranging global variables, we cannot re-arrange functions; in a particular order and base our calculations on the layout of the; functions' entry points, as we have no idea how large a particular function; will end up being (the function sizes could even depend on how we arrange; the functions). Instead, we build a jump table, which is a block of code; consisting of one branch instruction for each of the functions in the bit; set that branches to the target function, and redirect any taken function; addresses to the corresponding jump table entry. In this way, the distance; between function entry points is predictable and controllable. In the object; file's symbol table, the symbols for the target functions also refer to the; jump table entries, so that addresses taken outside the module will pass; any verification done inside the module. In more concrete terms, suppose we have three functions ``f``, ``g``,; ``h`` which are all of the same type, and a function foo that returns their; addresses:. .. code-block:: none. f:; mov 0, %eax; ret. g:; mov 1, %eax; ret. h:; mov 2, %eax; ret. foo:; mov f, %eax; mov g, %edx; mov h, %e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:16949,depend,depend,16949,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['depend'],['depend']
Integrability,"e semantic handling of the attribute. Parsing of the attribute is determined by the various syntactic forms attributes; can take, such as GNU, C++11, and Microsoft style attributes, as well as other; information provided by the table definition of the attribute. Ultimately, the; parsed representation of an attribute object is a ``ParsedAttr`` object.; These parsed attributes chain together as a list of parsed attributes attached; to a declarator or declaration specifier. The parsing of attributes is handled; automatically by Clang, except for attributes spelled as so-called “custom”; keywords. When implementing a custom keyword attribute, the parsing of the; keyword and creation of the ``ParsedAttr`` object must be done manually. Eventually, ``Sema::ProcessDeclAttributeList()`` is called with a ``Decl`` and; a ``ParsedAttr``, at which point the parsed attribute can be transformed; into a semantic attribute. The process by which a parsed attribute is converted; into a semantic attribute depends on the attribute definition and semantic; requirements of the attribute. The end result, however, is that the semantic; attribute object is attached to the ``Decl`` object, and can be obtained by a; call to ``Decl::getAttr<T>()``. Similarly, for statement attributes,; ``Sema::ProcessStmtAttributes()`` is called with a ``Stmt`` a list of; ``ParsedAttr`` objects to be converted into a semantic attribute. The structure of the semantic attribute is also governed by the attribute; definition given in Attr.td. This definition is used to automatically generate; functionality used for the implementation of the attribute, such as a class; derived from ``clang::Attr``, information for the parser to use, automated; semantic checking for some attributes, etc. ``include/clang/Basic/Attr.td``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; The first step to adding a new attribute to Clang is to add its definition to; `include/clang/Basic/Attr.td; <https://github.com/llvm/llvm-project/blob/main/clang/inclu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:126613,depend,depends,126613,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['depends']
Integrability,"e show how to extend; it with control flow operations ('if' statement and a 'for' loop). This; gives us a chance to talk about SSA construction and control; flow.; - `Chapter #6: Extending the Language: User-defined Operators; <LangImpl06.html>`_ - This chapter extends the language to let; users define arbitrary unary and binary operators - with assignable; precedence! This allows us to build a significant piece of the; ""language"" as library routines.; - `Chapter #7: Extending the Language: Mutable Variables; <LangImpl07.html>`_ - This chapter talks about adding user-defined local; variables along with an assignment operator. This shows how easy it is; to construct SSA form in LLVM: LLVM does *not* require your front-end; to construct SSA form in order to use it!; - `Chapter #8: Compiling to Object Files <LangImpl08.html>`_ - This; chapter explains how to take LLVM IR and compile it down to object; files, like a static compiler does.; - `Chapter #9: Debug Information <LangImpl09.html>`_ - A real language; needs to support debuggers, so we; add debug information that allows setting breakpoints in Kaleidoscope; functions, print out argument variables, and call functions!; - `Chapter #10: Conclusion and other tidbits <LangImpl10.html>`_ - This; chapter wraps up the series by discussing ways to extend the language; and includes pointers to info on ""special topics"" like adding garbage; collection support, exceptions, debugging, support for ""spaghetti; stacks"", etc. By the end of the tutorial, we'll have written a bit less than 1000 lines; of (non-comment, non-blank) lines of code. With this small amount of; code, we'll have built up a nice little compiler for a non-trivial; language including a hand-written lexer, parser, AST, as well as code; generation support - both static and JIT! The breadth of this is a great; testament to the strengths of LLVM and shows why it is such a popular; target for language designers and others who need high performance code; generation.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst:3980,wrap,wraps,3980,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,1,['wrap'],['wraps']
Integrability,"e source uses an `RClusterPool` to asynchronously read-ahead data.; When a page of a certain cluster is required, the cluster pool reads pages of _active_ columns.; For instance, if only certain fields are used (e.g., through an imposed model), only the pages of columns connected to those fields are read.; Columns can be dynamically added (e.g. during event iteration, a new field view is created in a reader).; The cluster pool reads ahead a limited number of clusters given by the _cluster bunch size_ option (default = 1).; The read-ahead uses vector reads.; For the file backend, it additionally coalesces close read requests and uses uring reads when available. The page source can be restricted to a certain entry range.; This allows for optimizing the page lists that are being read.; Additionally, it allows for optimizing the cluster pool to not read-ahead beyond the limits. #### Late model extension; Reading an RNTuple with an extended model is transparent -- i.e., no additional interface calls are required.; Internally, columns that were created as part of late model extension will have synthesized zero-initialized column ranges for the clusters that were already written before the model was extended.; In addition, pages made up of 0x00 bytes are synthesized for deferred columns in the clusters that were already (partially) filled before the model was extended. Storage Backends; ----------------. Support for storage backends is implemented through derived classes of `RPageSink` and `RPageSource`.; The `RPage{Sink,Source}File` class provides a storage backend for RNTuple data in ROOT files, local or remote.; The `RPage{Sink,Source}Daos` class provides a storage backend for RNTuple data in the DAOS object store. Every new storage backend needs to define; 1) The RNTuple embedding: how are RNTuple data blobs stored, e.g. in keys of ROOT files, or in objects of object stores; 2) The RNTuple anchor: the initial link to the location of the header and footer (cf. format spe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:23049,interface,interface,23049,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['interface'],['interface']
Integrability,"e systems, the math function ``sqrt`` is specified; as setting ``errno`` to ``EDOM`` when the input is negative. On these; systems, the compiler cannot normally optimize a call to ``sqrt`` to use; inline code (e.g. the x86 ``sqrtsd`` instruction) without additional; checking to ensure that ``errno`` is set appropriately.; ``-fno-math-errno`` permits these transformations. On some targets, math library functions never set ``errno``, and so; ``-fno-math-errno`` is the default. This includes most BSD-derived; systems, including Darwin. .. option:: -f[no-]trapping-math. Control floating point exception behavior. ``-fno-trapping-math`` allows optimizations that assume that floating point operations cannot generate traps such as divide-by-zero, overflow and underflow. - The option ``-ftrapping-math`` behaves identically to ``-ffp-exception-behavior=strict``.; - The option ``-fno-trapping-math`` behaves identically to ``-ffp-exception-behavior=ignore``. This is the default. .. option:: -ffp-contract=<value>. Specify when the compiler is permitted to form fused floating-point; operations, such as fused multiply-add (FMA). Fused operations are; permitted to produce more precise results than performing the same; operations separately. The C standard permits intermediate floating-point results within an; expression to be computed with more precision than their type would; normally allow. This permits operation fusing, and Clang takes advantage; of this by default. This behavior can be controlled with the ``FP_CONTRACT``; and ``clang fp contract`` pragmas. Please refer to the pragma documentation; for a description of how the pragmas interact with this option. Valid values are:. * ``fast`` (fuse across statements disregarding pragmas, default for CUDA); * ``on`` (fuse in the same statement unless dictated by pragmas, default for languages other than CUDA/HIP); * ``off`` (never fuse); * ``fast-honor-pragmas`` (fuse across statements unless dictated by pragmas, default for HIP). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:56711,contract,contract,56711,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['contract'],['contract']
Integrability,"e task of analyzing the computations and assigning each to the correct piece of hardware, taking into consideration the performance boost or penalty that may arise with every method of computing. #### Multithread computations; The CPU instance of the computing library can furthermore execute multithread computations. This also applies for computations handled by the CPU in the `""cuda""` mode. To use them, one needs to set the desired number of parallel tasks before calling `fitTo()` as shown below:; ``` {.cpp}; ROOT::EnableImplicitMT(nThreads);; RooMyPDF.fitTo(data, BatchMode(""cuda"")); // can also use ""cuda""; ```. ### User-made PDFs; The easiest and most efficient way of accelerating your PDFs is to request their addition to the official RooFit by submitting a ticket [here](https://github.com/root-project/root/issues/new). The ROOT team will gladly assist you and take care of the details. While your code is integrated, you are able to significantly improve the speed of fitting (but not take full advantage of the RooBatchCompute library), at least by using the batch evaluation feature.; To make use of it, one should override `RooAbsReal::computeBatch()`; ``` {.cpp}; void RooMyPDF::computeBatch(RooBatchCompute::RooBatchComputeInterface*, double* output, size_t nEvents, RooBatchCompute::DataMap& dataMap) const; ```; This method must be implemented so that it fills the `output` array with the **normalized** probabilities computed for `nEvents` events, the data of which can be retrieved from `dataMap`. `dataMap` is a simple `std::map<RooRealVar*, std::span<const double>>`. Note that it is not necessary to evaluate any of the objects that the PDF relies to, because they have already been evaluated by the RooFitDriver, so that their updated results are always present in `dataMap`. The `RooBatchCompute::RooBatchComputeInterface` pointer should be ignored. ``` {.cpp}; void RooMyPDF::computeBatch(RooBatchCompute::RooBatchComputeInterface*, double* output, size_t nEvents, RooBa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/batchcompute.md:3858,integrat,integrated,3858,roofit/doc/developers/batchcompute.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/batchcompute.md,1,['integrat'],['integrated']
Integrability,"e that creates releases and buildbots (CMake, scripts).; * `Phabricator <https://github.com/llvm/phabricator>`_ and; `buildbot <https://github.com/llvm/llvm-zorg>`_ infrastructure.; * The `test-suite <https://github.com/llvm/llvm-test-suite>`_. Requirements; ------------. Code in this tier must:; * Keep official buildbots green, with warnings on breakages being emailed to; all affected developers. Those must be fixed as soon as possible or patches; must be reverted, as per review policy.; * Bit-rot of a component in the core tier will result in that component being; downgraded to the peripheral tier or being removed. Sub-communities can; avoid this by fixing all raised issues in a timely manner. Peripheral Tier; ===============. The peripheral tier encompass the parts of LLVM that cater to a specific; sub-community and which don't usually affect the core components directly. This includes experimental back-ends, disabled-by-default options and; alternative paths (work-in-progress replacements) in the same repository, as; well as separate efforts to integrate LLVM development with local practices. It is the responsibility of each sub-community to care about their own parts; and the intersection of that with the core tier and other peripheral parts. There are three main groups of code that fit in this category:; * Code that is making its way into LLVM, via the `experimental <https://llvm.org/docs/DeveloperPolicy.html#introducing-new-components-into-llvm>`_; roadmap or similar efforts.; * Code that is making its way out of LLVM, via deprecation, replacement or; bit-rot, and will be removed if the sub-community that cares about it; cannot maintain it.; * Code that isn't meant to be in LLVM core and can coexist with the code in; the core tier (and others in the peripheral tier) long term, without causing; breakages or disturbances. What is covered; ---------------. The peripheral tier is composed of:; * Experimental targets and options that haven't been enable by default",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:3496,integrat,integrate,3496,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['integrat'],['integrate']
Integrability,"e that:. * The .cpp file be compiled. The required compilation steps are; platform-dependent.; * The bindings are not packaged for distribution. Typically, users expect; to have a pip-compatible package.; * The binding are in the 'cppyy.gbl' namespace. This is an inconvenience at; best for users who might expect C++ code from KF5::Config to appear in; Python via ""import KF5.Config"".; * The bindings are loaded lazily, which limits the discoverability of the; content of the bindings.; * ``cppyy`` supports customization of the bindings via 'Pythonization' but; there is no automated way to load them. These issues are addressed by the CMake support. This is a blend of Python; packaging and CMake where CMake provides:. * Platform-independent scripting of the creation of a Python 'wheel' package; for the bindings.; * An facility for CMake-based projects to automate the entire bindings; generation process, including basic automated tests. .. note::. The JIT needs to resolve linker symbols in order to call them through; generated wrappers.; Thus, any classes, functions, and data that will be used in Python need; to be exported.; This is the default behavior on Mac and Linux, but not on Windows.; On that platform, use ``__declspec(dllexport)`` to explicitly export the; classes and function you expect to call.; CMake has simple `support for exporting all`_ C++ symbols. Python packaging; ----------------. Modern Python packaging usage is based on the 'wheel'. This is places the onus; on the creation of binary artifacts in the package on the distributor. In this; case, this includes the platform-dependent steps necessary to compile the .cpp; file. The generated package also takes advantage of the __init__.py load-time; mechanism to enhance the bindings:. * The bindings are rehosted in a ""native"" namespace so that C++ code from; KF5::Config appears in Python via ""import KF5.Config"".; * (TBD) Load Pythonizations. Both of these need/can use the output of the; :ref:`cppyy-generator <",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst:1276,wrap,wrappers,1276,bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,1,['wrap'],['wrappers']
Integrability,"e the ``#include <iostream>`` to ``import <iostream>;`` automatically. Relationships between Clang modules; -----------------------------------. Header units have pretty similar semantics with Clang modules.; The semantics of both of them are like headers. In fact, we could even ""mimic"" the sytle of header units by Clang modules:. .. code-block:: c++. module ""iostream"" {; export *; header ""/path/to/libstdcxx/iostream""; }. .. code-block:: console. $ clang++ -std=c++20 -fimplicit-modules -fmodule-map-file=.modulemap main.cpp. It would be simpler if we are using libcxx:. .. code-block:: console. $ clang++ -std=c++20 main.cpp -fimplicit-modules -fimplicit-module-maps. Since there is already one; `module map <https://github.com/llvm/llvm-project/blob/main/libcxx/include/module.modulemap.in>`_; in the source of libcxx. Then immediately leads to the question: why don't we implement header units through Clang header modules?. The main reason for this is that Clang modules have more semantics like hierarchy or; wrapping multiple headers together as a big module.; However, these things are not part of Standard C++ Header units,; and we want to avoid the impression that these additional semantics get interpreted as Standard C++ behavior. Another reason is that there are proposals to introduce module mappers to the C++ standard; (for example, https://wg21.link/p1184r2).; If we decide to reuse Clang's modulemap, we may get in trouble once we need to introduce another module mapper. So the final answer for why we don't reuse the interface of Clang modules for header units is that; there are some differences between header units and Clang modules and that ignoring those; differences now would likely become a problem in the future. Discover Dependencies; =====================. Prior to modules, all the translation units can be compiled parallelly.; But it is not true for the module units. The presence of module units requires; us to compile the translation units in a (topological) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:31865,wrap,wrapping,31865,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['wrap'],['wrapping']
Integrability,"e the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a pointer to; **`TObject`**. We have to cast it to a **`TH1`** pointer, and now we; have a histogram. At the end of the loop, the message is deleted, and; another one is created at the beginning. ``` {.cpp}; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; ```. ## Closing the Connection. Once we are done sending objects, we close the connection by closing the; sockets at both ends. ``` {.cpp}; Socket->Close();; ```. This diagram summarizes the steps we just covered:. ![Server - Client setting-up and closing the connection](pictures/080001FF.png). ## A Server with Multiple Sockets. Chances are that your server has to be able to receive data from; multiple clients. The class we need for this is **`TMonitor`**. It lets; you add sockets and the `TMonitor::Select` method returns the socket; with data waiting. Sockets can be added, removed, or enabled and; disabled. Here is an example of a server that has a **`TMonitor`** to; manage multiple sockets:. ``` {.cpp}; {; TServerSocket *ss = new TServerSocket (9090, kTRUE);. // Accept a connection and return a full-duplex communication socket.; TSocket *s0 = ss->Accept();; TSocket *s1 = ss->Accept();. // tell the clients to start; s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:2457,message,message,2457,documentation/users-guide/Networking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md,5,['message'],['message']
Integrability,"e the default policy is sufficient in most cases, it may break down when; ``T`` does not provide a default constructor. Also, in the case of many; instances of ``ilist``\ s, the memory overhead of the associated sentinels is; wasted. To alleviate the situation with numerous and voluminous; ``T``-sentinels, sometimes a trick is employed, leading to *ghostly sentinels*. Ghostly sentinels are obtained by specially-crafted ``ilist_traits<T>`` which; superpose the sentinel with the ``ilist`` instance in memory. Pointer; arithmetic is used to obtain the sentinel, which is relative to the ``ilist``'s; ``this`` pointer. The ``ilist`` is augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. .. _dss_other:. Other Sequential Container options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Other STL containers are available, such as ``std::string``. There are also various STL adapter classes such as ``std::queue``,; ``std::priority_queue``, ``std::stack``, etc. These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:70708,adapter,adapter,70708,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['adapter'],['adapter']
Integrability,"e type system in all sorts of interesting ways. Simple; arrays are very easy and are quite useful for many different; applications. Adding them is mostly an exercise in learning how the; LLVM `getelementptr <../../LangRef.html#getelementptr-instruction>`_ instruction; works: it is so nifty/unconventional, it `has its own; FAQ <../../GetElementPtr.html>`_!; - **standard runtime** - Our current language allows the user to access; arbitrary external functions, and we use it for things like ""printd""; and ""putchard"". As you extend the language to add higher-level; constructs, often these constructs make the most sense if they are; lowered to calls into a language-supplied runtime. For example, if; you add hash tables to the language, it would probably make sense to; add the routines to a runtime, instead of inlining them all the way.; - **memory management** - Currently we can only access the stack in; Kaleidoscope. It would also be useful to be able to allocate heap; memory, either with calls to the standard libc malloc/free interface; or with a garbage collector. If you would like to use garbage; collection, note that LLVM fully supports `Accurate Garbage; Collection <../../GarbageCollection.html>`_ including algorithms that; move objects and need to scan/update the stack.; - **exception handling support** - LLVM supports generation of `zero; cost exceptions <../../ExceptionHandling.html>`_ which interoperate with; code compiled in other languages. You could also generate code by; implicitly making every function return an error value and checking; it. You could also make explicit use of setjmp/longjmp. There are; many different ways to go here.; - **object orientation, generics, database access, complex numbers,; geometric programming, ...** - Really, there is no end of crazy; features that you can add to the language.; - **unusual domains** - We've been talking about applying LLVM to a; domain that many people are interested in: building a compiler for a; specific la",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:3410,interface,interface,3410,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['interface'],['interface']
Integrability,"e updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible in global; metadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_accesses``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.parallel_accesses`` metadata refers to one or more; access group metadata nodes (see ``llvm.access.group``). It denotes that; no loop-carried memory dependence exist between it and other instructions; in the loop with this metadata. Let ``m1`` and ``m2`` be two instructions that both have the; ``llvm.access.group`` metadata to the access group ``g1``, respectively; ``g2`` (which might be identical). If a loop contains both access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ``m2`` carried by; this loop. Instructions that belong to multiple access groups are; considered having this property if at least one of the access groups; matches the ``llvm.loop.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loops that were originally parallel to be considered; sequential (if optimization passes that are unaware of the parallel semantics; insert new memory instructions into the loop",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:311996,depend,dependency,311996,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependency']
Integrability,"e vector architectures.; option(LLVM_ENABLE_STRICT_FIXED_SIZE_VECTORS; ""Enable assertions that type is not scalable in implicit conversion from TypeSize to uint64_t and calls to getNumElements"" OFF). set(LLVM_ABI_BREAKING_CHECKS ""WITH_ASSERTS"" CACHE STRING; ""Enable abi-breaking checks. Can be WITH_ASSERTS, FORCE_ON or FORCE_OFF.""). option(LLVM_FORCE_USE_OLD_TOOLCHAIN; ""Set to ON to force using an old, unsupported host toolchain."" OFF). set(LLVM_LOCAL_RPATH """" CACHE FILEPATH; ""If set, an absolute path added as rpath on binaries that do not already contain an executable-relative rpath.""). option(LLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN; ""Set to ON to only warn when using a toolchain which is about to be deprecated, instead of emitting an error."" OFF). option(LLVM_USE_INTEL_JITEVENTS; ""Use Intel JIT API to inform Intel(R) VTune(TM) Amplifier XE 2011 about JIT code""; OFF). if( LLVM_USE_INTEL_JITEVENTS ); # Verify we are on a supported platform; if( NOT CMAKE_SYSTEM_NAME MATCHES ""Windows"" AND NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR; ""Intel JIT API support is available on Linux and Windows only.""); endif(); endif( LLVM_USE_INTEL_JITEVENTS ). option(LLVM_USE_OPROFILE; ""Use opagent JIT interface to inform OProfile about JIT code"" OFF). option(LLVM_EXTERNALIZE_DEBUGINFO; ""Generate dSYM files and strip executables and libraries (Darwin Only)"" OFF). option(LLVM_EXPERIMENTAL_DEBUGINFO_ITERATORS; ""Add extra Booleans to ilist_iterators to communicate facts for debug-info"" OFF). set(LLVM_CODESIGNING_IDENTITY """" CACHE STRING; ""Sign executables and dylibs with the given identity or skip if empty (Darwin Only)""). # If enabled, verify we are on a platform that supports oprofile.; if( LLVM_USE_OPROFILE ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""OProfile support is available on Linux only.""); endif( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); endif( LLVM_USE_OPROFILE ). option(LLVM_USE_PERF; ""Use perf JIT interface to inform perf about JIT code"" O",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:27024,message,message,27024,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"e""; Size of the dynamically allocated LDS memory is passed in the kernarg. ""hidden_private_base""; The high 32 bits of the flat addressing private aperture base.; Only used by GFX8 to allow conversion between private segment; and flat addresses. See :ref:`amdgpu-amdhsa-kernel-prolog-flat-scratch`. ""hidden_shared_base""; The high 32 bits of the flat addressing shared aperture base.; Only used by GFX8 to allow conversion between shared segment; and flat addresses. See :ref:`amdgpu-amdhsa-kernel-prolog-flat-scratch`. ""hidden_queue_ptr""; A global memory address space pointer to the ROCm runtime; ``struct amd_queue_t`` structure for the HSA queue of the; associated dispatch AQL packet. It is only required for pre-GFX9; devices for the trap handler ABI (see :ref:`amdgpu-amdhsa-trap-handler-abi`). ====================== ============== ========= ================================. .. Kernel Dispatch; ~~~~~~~~~~~~~~~. The HSA architected queuing language (AQL) defines a user space memory interface; that can be used to control the dispatch of kernels, in an agent independent; way. An agent can have zero or more AQL queues created for it using an HSA; compatible runtime (see :ref:`amdgpu-os`), in which AQL packets (all of which; are 64 bytes) can be placed. See the *HSA Platform System Architecture; Specification* [HSA]_ for the AQL queue mechanics and packet layouts. The packet processor of a kernel agent is responsible for detecting and; dispatching HSA kernels from the AQL queues associated with it. For AMD GPUs the; packet processor is implemented by the hardware command processor (CP),; asynchronous dispatch controller (ADC) and shader processor input controller; (SPI). An HSA compatible runtime can be used to allocate an AQL queue object. It uses; the kernel mode driver to initialize and register the AQL queue with CP. To dispatch a kernel the following actions are performed. This can occur in the; CPU host program, or from an HSA kernel executing on a GPU. 1. A pointer to an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:148924,interface,interface,148924,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['interface'],['interface']
Integrability,"e, control flow constructs are commands. If, ElseIf, Else; ----------------. .. note::; For the full documentation on the CMake if command go; `here <https://cmake.org/cmake/help/v3.4/command/if.html>`_. That resource is; far more complete. In general CMake if blocks work the way you'd expect:. .. code-block:: cmake. if(<condition>); message(""do stuff""); elseif(<condition>); message(""do other stuff""); else(); message(""do other other stuff""); endif(). The single most important thing to know about CMake's if blocks coming from a C; background is that they do not have their own scope. Variables set inside; conditional blocks persist after the ``endif()``. Loops; -----. The most common form of the CMake ``foreach`` block is:. .. code-block:: cmake. foreach(var ...); message(""do stuff""); endforeach(). The variable argument portion of the ``foreach`` block can contain dereferenced; lists, values to iterate, or a mix of both:. .. code-block:: cmake. foreach(var foo bar baz); message(${var}); endforeach(); # prints:; # foo; # bar; # baz. set(my_list 1 2 3); foreach(var ${my_list}); message(${var}); endforeach(); # prints:; # 1; # 2; # 3. foreach(var ${my_list} out_of_bounds); message(${var}); endforeach(); # prints:; # 1; # 2; # 3; # out_of_bounds. There is also a more modern CMake foreach syntax. The code below is equivalent; to the code above:. .. code-block:: cmake. foreach(var IN ITEMS foo bar baz); message(${var}); endforeach(); # prints:; # foo; # bar; # baz. set(my_list 1 2 3); foreach(var IN LISTS my_list); message(${var}); endforeach(); # prints:; # 1; # 2; # 3. foreach(var IN LISTS my_list ITEMS out_of_bounds); message(${var}); endforeach(); # prints:; # 1; # 2; # 3; # out_of_bounds. Similar to the conditional statements, these generally behave how you would; expect, and they do not have their own scope. CMake also supports ``while`` loops, although they are not widely used in LLVM. Modules, Functions and Macros; =============================. Modules; -------. Mod",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:8518,message,message,8518,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['message'],['message']
Integrability,"e-C; class. Each of these updates is captured in an ""update record"" that is; stored in the chained precompiled header file and will be loaded along with; the original entity. .. _pchinternals-modules:. Modules; -------. Modules generalize the chained precompiled header model yet further, from a; linear chain of precompiled headers to an arbitrary directed acyclic graph; (DAG) of AST files. All of the same techniques used to make chained; precompiled headers work --- ID number, name lookup, update records --- are; shared with modules. However, the DAG nature of modules introduce a number of; additional complications to the model:. Numbering of IDs; The simple, linear numbering scheme used in chained precompiled headers falls; apart with the module DAG, because different modules may end up with; different numbering schemes for entities they imported from common shared; modules. To account for this, each module file provides information about; which modules it depends on and which ID numbers it assigned to the entities; in those modules, as well as which ID numbers it took for its own new; entities. The AST reader then maps these ""local"" ID numbers into a ""global""; ID number space for the current translation unit, providing a 1-1 mapping; between entities (in whatever AST file they inhabit) and global ID numbers.; If that translation unit is then serialized into an AST file, this mapping; will be stored for use when the AST file is imported. Declaration merging; It is possible for a given entity (from the language's perspective) to be; declared multiple times in different places. For example, two different; headers can have the declaration of ``printf`` or could forward-declare; ``struct stat``. If each of those headers is included in a module, and some; third party imports both of those modules, there is a potentially serious; problem: name lookup for ``printf`` or ``struct stat`` will find both; declarations, but the AST nodes are unrelated. This would result in a; co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:27866,depend,depends,27866,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['depend'],['depends']
Integrability,"e. `RDataFrame(nentries)`, by removing usage of `Range` operation to define the per-task entry range. - Explicitly error out when trying to process a TTree with a TTreeIndex in distributed mode. The feature is currently not supported. - JITting the RDataFrame computation graph now only happens once per worker process, not once per task. This greatly reduces memory usage and runtime overhead at of each task. ## TTree Libraries. ## RNTuple; ROOT's experimental successor of TTree has seen a large number of updates during the last few months. Specifically, v6.30 includes the following changes:. - Support for custom ROOT I/O rules that target transient members of a user-defined class (see PR [#11944](https://github.com/root-project/root/pull/11944)). If a rule only targets transient members and it was working in TTree, it should work unmodified in RNTuple. - Improved support for user-defined classes that behave as a collection. Specifically, RNTuple now relies on the iterator interface defined in `TVirtualCollectionProxy` (see PR [#12380](https://github.com/root-project/root/pull/12380) for details).; Note that associative collections are not yet supported. - Support for new field types: `std::bitset<N>`, `std::unique_ptr<T>`, `std::set<T>`, `Double32_t`, scoped and unscoped enums with dictionary. - Full support for late model extension, which allows the RNTuple model to be extended after a `RNTupleWriter` has been created from the initial model (see PR [#12376](https://github.com/root-project/root/pull/12376)).; New top-level fields can be created at any time during the writing process.; On read-back, zero-initialized values are read for entries before the field was first seen.; The example below illustrates the use of this feature.; ```; auto model = RNTupleModel::Create();; auto fieldPt = model->MakeField<float>(""pt"", 42.0);; auto ntuple = RNTupleWriter::Recreate(std::move(model), ""myNTuple"", ""out.ntuple"");; ntuple->Fill();. auto modelUpdater = ntuple->CreateModelUpdat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:6585,interface,interface,6585,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['interface'],['interface']
Integrability,"e:. #. If you require interprocedural analysis, it should be a ``Pass``.; #. If you are a function-local analysis, subclass ``FunctionPass``.; #. If you don't need to look at the program at all, subclass ``ImmutablePass``. In addition to the pass that you subclass, you should also inherit from the; ``AliasAnalysis`` interface, of course, and use the ``RegisterAnalysisGroup``; template to register as an implementation of ``AliasAnalysis``. Required initialization calls; -----------------------------. Your subclass of ``AliasAnalysis`` is required to invoke two methods on the; ``AliasAnalysis`` base class: ``getAnalysisUsage`` and; ``InitializeAliasAnalysis``. In particular, your implementation of; ``getAnalysisUsage`` should explicitly call into the; ``AliasAnalysis::getAnalysisUsage`` method in addition to doing any declaring; any pass dependencies your pass has. Thus you should have something like this:. .. code-block:: c++. void getAnalysisUsage(AnalysisUsage &AU) const {; AliasAnalysis::getAnalysisUsage(AU);; // declare your dependencies here.; }. Additionally, your must invoke the ``InitializeAliasAnalysis`` method from your; analysis run method (``run`` for a ``Pass``, ``runOnFunction`` for a; ``FunctionPass``, or ``InitializePass`` for an ``ImmutablePass``). For example; (as part of a ``Pass``):. .. code-block:: c++. bool run(Module &M) {; InitializeAliasAnalysis(this);; // Perform analysis here...; return false;; }. Required methods to override; ----------------------------. You must override the ``getAdjustedAnalysisPointer`` method on all subclasses; of ``AliasAnalysis``. An example implementation of this method would look like:. .. code-block:: c++. void *getAdjustedAnalysisPointer(const void* ID) override {; if (ID == &AliasAnalysis::ID); return (AliasAnalysis*)this;; return this;; }. Interfaces which may be specified; ---------------------------------. All of the `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__ virtual methods",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:11260,depend,dependencies,11260,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['depend'],['dependencies']
Integrability,"e:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arcanist and forget to add the; ``Differential Revision`` line to your commit message then it is recommended; that you close the review manually. In the web UI, under ""Leap Into Action"" put; the git revision number in the Comment, set the Action to ""Close Revision"" and; click Submit. Note the review must have been Accepted first. Committing someone's change from Phabricator; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. On a clean Git repository on an up to date ``main`` branch run the; following (where ``<Revision>`` is the Phabricator review number):. ::. arc patch D<Revision>. This will create a new branch called ``arcpatch-D<Revision>`` based on the; current ``main`` and will create a commit corresponding to ``D<Revision>`` with a; commit message derived from information in the Phabricator review. Check you are happy with the commit message and amend it if necessary.; For example, ensure the 'Author' property of the commit is set to the original author.; You can use a command to correct the author property if it is incorrect:. :",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:14699,message,message,14699,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['message'],['message']
Integrability,e; Unknown. 1159; C++11; Class and enumeration definitions in template aliases; Unknown. 1160; C++11; Definitions of template members and the current instantiation; Unknown. 1161; C++11; Dependent nested-name-specifier in a pointer-to-member declarator; Unknown. 1162; NAD; Dependent elaborated-type-specifiers in non-deduced contexts; Unknown. 1163; NAD; extern template prevents inlining functions not marked inline; Unknown. 1164; C++11; Partial ordering of f(T&) and f(T&&); Unknown. 1165; C++11; Exceptions when destroying array elements; Unknown. 1166; C++11; exception-declarations that do not declare objects; Unknown. 1167; C++11; function-try-blocks for destructors; Unknown. 1168; C++11; Additional reasons to call std::terminate; Unknown. 1169; C++11; Missing feature macro for strict pointer safety; Unknown. 1170; C++11; Access checking during template argument deduction; Unknown. 1171; C++11; Partial stack unwinding with noexcept violation; Unknown. 1172; drafting; “instantiation-dependent” constructs; Not resolved. 1173; C++11; Unclear specification of effects of signal handling; Unknown. 1174; C++11; When is a pure virtual function “used?”; Unknown. 1175; C++11; Disambiguating user-defined literals; Unknown. 1176; C++11; Definition of release sequence; Unknown. 1177; C++11; Intra-thread dependency-ordered-before; Unknown. 1178; C++11; Deduction failure matching placement new; Unknown. 1179; NAD; Cv-qualification of non-type template parameters; Unknown. 1180; C++11; Over-aligned class types; Unknown. 1181; C++11; What is a “built-in type?”; Unknown. 1182; C++11; Incorrect description of pack expansion syntax; Unknown. 1183; C++11; Expansion of parameter packs in declarators; Unknown. 1184; C++11; Argument conversions to nondeduced parameter types; Unknown. 1185; C++11; Misleading description of language linkage and member function types; Unknown. 1186; C++11; Non-dependent constexpr violations in function templates; Unknown. 1187; C++11; Problems in initializat,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:78008,depend,dependent,78008,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"e; about the first one. Also, while the architecture interface question is important for; Java-type VMs, the design constraints are very different. 2. Design issues to consider (an initial list that we should continue; to modify). Note that I'm not trying to suggest actual solutions here,; but just various directions we can pursue:. a. A single-assignment VM, which we've both already been thinking about. b. A strongly-typed VM. One question is do we need the types to be; explicitly declared or should they be inferred by the dynamic compiler?. c. How do we get more high-level information into the VM while keeping; to a low-level VM design?. o Explicit array references as operands? An alternative is; to have just an array type, and let the index computations be; separate 3-operand instructions. o Explicit instructions to handle aliasing, e.g.s:; -- an instruction to say ""I speculate that these two values are not; aliased, but check at runtime"", like speculative execution in; EPIC?; -- or an instruction to check whether two values are aliased and; execute different code depending on the answer, somewhat like; predicated code in EPIC. o (This one is a difficult but powerful idea.); A ""thread-id"" field on every instruction that allows the static; compiler to generate a set of parallel threads, and then have; the runtime compiler and hardware do what they please with it.; This has very powerful uses, but thread-id on every instruction; is expensive in terms of instruction size and code size.; We would need to compactly encode it somehow. Also, this will require some reading on at least two other; projects:; -- Multiscalar architecture from Wisconsin; -- Simultaneous multithreading architecture from Washington. o Or forget all this and stick to a traditional instruction set?. BTW, on an unrelated note, after the meeting yesterday, I did remember; that you had suggested doing instruction scheduling on SSA form instead; of a dependence DAG earlier in the semester. When we ta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeas.txt:1887,depend,depending,1887,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeas.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeas.txt,1,['depend'],['depending']
Integrability,"e; calling function or; * the autorelease pool is restored to a previous state. .. admonition:: Rationale. Rationale: not all memory and resources are managed with reference counts; it; is common for objects to manage private resources in their own, private way.; Typically these resources are completely encapsulated within the object, but; some classes offer their users direct access for efficiency. If ARC is not; aware of methods that return such ""interior"" pointers, its optimizations can; cause the owning object to be reclaimed too soon. This attribute informs ARC; that it must tread lightly. The extension rules are somewhat intentionally vague. The autorelease pool; limit is there to permit a simple implementation to simply retain and; autorelease the receiver. The other limit permits some amount of; optimization. The phrase ""derived from"" is intended to encompass the results; both of pointer transformations, such as casts and arithmetic, and of loading; from such derived pointers; furthermore, it applies whether or not such; derivations are applied directly in the calling code or by other utility code; (for example, the C library routine ``strchr``). However, the implementation; never need account for uses after a return from the code which calls the; method returning an interior pointer. As an exception, no extension is required if the receiver is loaded directly; from a ``__strong`` object with :ref:`precise lifetime semantics; <arc.optimization.precise>`. .. admonition:: Rationale. Implicit autoreleases carry the risk of significantly inflating memory use,; so it's important to provide users a way of avoiding these autoreleases.; Tying this to precise lifetime semantics is ideal, as for local variables; this requires a very explicit annotation, which allows ARC to trust the user; with good cheer. .. _arc.misc.c-retainable:. C retainable pointer types; --------------------------. A type is a :arc-term:`C retainable pointer type` if it is a pointer to; (possibl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:101212,rout,routine,101212,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['rout'],['routine']
Integrability,"e; directly using ``git push``, per the section in the :ref:`getting started; guide <commit_from_git>`. Note that if you commit the change without using Arcanist and forget to add the; ``Differential Revision`` line to your commit message then it is recommended; that you close the review manually. In the web UI, under ""Leap Into Action"" put; the git revision number in the Comment, set the Action to ""Close Revision"" and; click Submit. Note the review must have been Accepted first. Committing someone's change from Phabricator; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. On a clean Git repository on an up to date ``main`` branch run the; following (where ``<Revision>`` is the Phabricator review number):. ::. arc patch D<Revision>. This will create a new branch called ``arcpatch-D<Revision>`` based on the; current ``main`` and will create a commit corresponding to ``D<Revision>`` with a; commit message derived from information in the Phabricator review. Check you are happy with the commit message and amend it if necessary.; For example, ensure the 'Author' property of the commit is set to the original author.; You can use a command to correct the author property if it is incorrect:. ::. git commit --amend --author=""John Doe <jdoe@llvm.org>"". Then, make sure the commit is up-to-date, and commit it. This can be done by running; the following:. ::. git pull --rebase https://github.com/llvm/llvm-project.git main; git show # Ensure the patch looks correct.; ninja check-$whatever # Rerun the appropriate tests if needed.; git push https://github.com/llvm/llvm-project.git HEAD:main. Abandoning a change; -------------------. If you decide you should not commit the patch, you should explicitly abandon; the review so that reviewers don't think it is still open. In the web UI,; scroll to the bottom of the page where normally you would enter an overall; comment. In the drop-down Action list, which defaults to ""Comment,"" you should; select ""Abandon Revision"" and then enter a comment",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:15470,message,message,15470,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['message'],['message']
Integrability,"e; individuals and organizations will contribute back their work if they do not; want to have to maintain a fork forever (which is time consuming and expensive; when merges are involved). Further, nobody makes money on compilers these days,; but many people need them to get bigger goals accomplished: it makes sense for; everyone to work together.; For more information about the LLVM/clang license, please see the LLVM License; Description for more information. Internal Design and Implementation. A real-world, production quality compiler. Clang is designed and built by experienced compiler developers who are; increasingly frustrated with the problems that existing open source; compilers have. Clang is carefully and thoughtfully designed and; built to provide the foundation of a whole new generation of; C/C++/Objective C development tools, and we intend for it to be; production quality.; Being a production quality compiler means many things: it means being high; performance, being solid and (relatively) bug free, and it means eventually; being used and depended on by a broad range of people. While we are still in; the early development stages, we strongly believe that this will become a; reality. A simple and hackable code base. Our goal is to make it possible for anyone with a basic understanding; of compilers and working knowledge of the C/C++/ObjC languages to understand and; extend the clang source base. A large part of this falls out of our decision to; make the AST mirror the languages as closely as possible: you have your friendly; if statement, for statement, parenthesis expression, structs, unions, etc, all; represented in a simple and explicit way.; In addition to a simple design, we work to make the source base approachable; by commenting it well, including citations of the language standards where; appropriate, and designing the code for simplicity. Beyond that, clang offers; a set of AST dumpers, printers, and visualizers that make it easy to put code in; a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:11788,depend,depended,11788,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['depend'],['depended']
Integrability,"e; results during tracking. *A)* If a positioned volume contains points that are not also contained; by its mother, we will call the corresponding region as an ""extrusion"".; When navigating from outside to inside (trying to enter such a node); these regions are invisible since the current track has not yet reached; its mother. This is not the case when going the other way since the; track has first to exit the extruding node before checking the mother.; In other words, an extrusion behavior is dependent on the track; parameters, which is a highly undesirable effect. *B)* We will call ""overlaps"" only the regions in space contained by; more than one node inside the same container. The owner of such regions; cannot be determined based on hierarchical considerations; therefore; they will be considered as belonging to the node from which the current; track is coming from. When coming from their container, the ownership is totally; unpredictable. Again, the ownership of overlapping regions highly; depends on the current track parameters. We must say that even the overlaps of type *A)* and *B)* are allowed in case; the corresponding nodes are created using; TGeoVolume::AddNodeOverlap() method. Navigation is performed in such; cases by giving priority to the non-overlapping nodes. The modeller has; to perform an additional search through the overlapping candidates.; These are detected automatically during the geometry closing procedure; in order to optimize the algorithm, but we will stress that extensive; usage of this feature leads to a drastic deterioration of performance.; In the following we will focus on the non-declared overlaps of type *A)*; and *B)* since this is the main source of errors during tracking. These; are generally non-intended overlaps due to coding mistakes or bad; geometry design. The checking package is loaded together with the; painter classes and contains an automated overlap checker. \image html geometry008.png ""Overlap checking"". This can be activ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:91915,depend,depends,91915,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['depend'],['depends']
Integrability,"e; reverted. This is necessary when the change blocks other developers from making; progress. The developer is welcome to re-commit the change after the problem has; been fixed. .. _commit messages:. Commit messages; ---------------. Although we don't enforce the format of commit messages, we prefer that; you follow these guidelines to help review, search in logs, email formatting; and so on. These guidelines are very similar to rules used by other open source; projects. Most importantly, the contents of the message should be carefully written to; convey the rationale of the change (without delving too much in detail). It; also should avoid being vague or overly specific. For example, ""bits were not; set right"" will leave the reviewer wondering about which bits, and why they; weren't right, while ""Correctly set overflow bits in TargetInfo"" conveys almost; all there is to the change. Below are some guidelines about the format of the message itself:. * Separate the commit message into title and body separated by a blank line. * If you're not the original author, ensure the 'Author' property of the commit is; set to the original author and the 'Committer' property is set to yourself.; You can use a command similar to; ``git commit --amend --author=""John Doe <jdoe@llvm.org>""`` to correct the; author property if it is incorrect. See `Attribution of Changes`_ for more; information including the method we used for attribution before the project; migrated to git. In the rare situation where there are multiple authors, please use the `git; tag 'Co-authored-by:' to list the additional authors; <https://github.blog/2018-01-29-commit-together-with-co-authors/>`_. * The title should be concise. Because all commits are emailed to the list with; the first line as the subject, long titles are frowned upon. Short titles; also look better in `git log`. * When the changes are restricted to a specific part of the code (e.g. a; back-end or optimization pass), it is customary to add a tag",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:15593,message,message,15593,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['message'],['message']
Integrability,"eDeclMatcher<NamespaceDecl>...; Matches a declaration of a namespace. Given; namespace {}; namespace test {}; namespaceDecl(); matches ""namespace {}"" and ""namespace test {}"". Matcher<Decl>nonTypeTemplateParmDeclMatcher<NonTypeTemplateParmDecl>...; Matches non-type template parameter declarations. Given; template <typename T, int N> struct C {};; nonTypeTemplateParmDecl(); matches 'N', but not 'T'. Matcher<Decl>objcCategoryDeclMatcher<ObjCCategoryDecl>...; Matches Objective-C category declarations. Example matches Foo (Additions); @interface Foo (Additions); @end. Matcher<Decl>objcCategoryImplDeclMatcher<ObjCCategoryImplDecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matches Objective-C instance variable declarations. Example matches _enabled; @implementation Foo {; BOOL _enabled;; }; @end. Matcher<Decl>objcMethodDeclMatcher<ObjCMethodDecl>...; Matches Objective-C method declarations. Example matches both declaration and definition of -[Foo method]; @interface Foo; - (void)method;; @end. @implementation Foo; - (void)method {}; @end. Matcher<Decl>objcPropertyDeclMatcher<ObjCPropertyDecl>...; Matches Objective-C property declarations. Example matches enabled; @interface Foo; @property BOOL enabled;; @end. Matcher<Decl>objcProtocolDeclMatcher<ObjCProtocolDecl>...; Matches Objective-C protocol declarations. Example matches FooDelegate; @protocol FooDelegate; @end. Matcher<Decl>parmVarDeclMatcher<ParmVarDecl>...; Matches parameter variable declarations. Given; void f(int x);; parmVarDecl(); matches int x. Matcher<Decl>recordDeclMatcher<Re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:15555,interface,interface,15555,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['interface'],['interface']
Integrability,"eGenBackendSkeleton.cpp``. Printing Error Messages; =======================. TableGen records are often derived from multiple classes and also often; defined through a sequence of multiclasses. Because of this, it can be; difficult for backends to report clear error messages with accurate source; file locations. To make error reporting easier, five error reporting; functions are provided, each with four overloads. * ``PrintWarning`` prints a message tagged as a warning. * ``PrintError`` prints a message tagged as an error. * ``PrintFatalError`` prints a message tagged as an error and then terminates. * ``PrintNote`` prints a note. It is often used after one of the previous; functions to provide more information. * ``PrintFatalNote`` prints a note and then terminates. Each of these five functions is overloaded four times. * ``PrintError(const Twine &Msg)``:; Prints the message with no source file location. * ``PrintError(ArrayRef<SMLoc> ErrorLoc, const Twine &Msg)``:; Prints the message followed by the specified source line,; along with a pointer to the item in error. The array of; source file locations is typically taken from a ``Record`` instance. * ``PrintError(const Record *Rec, const Twine &Msg)``:; Prints the message followed by the source line associated with the; specified record (see `Record`_). * ``PrintError(const RecordVal *RecVal, const Twine &Msg)``:; Prints the message followed by the source line associated with the; specified record field (see `RecordVal`_). Using these functions, the goal is to produce the most specific error report; possible. Debugging Tools; ===============. TableGen provides some tools to aid in debugging backends. The ``PrintRecords`` Backend; ----------------------------. The TableGen command option ``--print-records`` invokes a simple backend; that prints all the classes and records defined in the source files. This is; the default backend option. The format of the output is guaranteed to be; constant over time, so that the outp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:24476,message,message,24476,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,1,['message'],['message']
Integrability,"e_t`` as part of the API, because it wasn't there when the header was parsed. The fix for this problem is either to pull the copied declarations into a common header that gets included everywhere ``size_t`` is part of the API, or to eliminate the ``#ifndef`` and redefine the ``size_t`` type. The latter works for C++ headers and C11, but will cause an error for non-modules C90/C99, where redefinition of ``typedefs`` is not permitted. **Conflicting definitions**; Different system headers may provide conflicting definitions for various macros, functions, or types. These conflicting definitions don't tend to cause problems in a pre-modules world unless someone happens to include both headers in one translation unit. Since the fix is often simply ""don't do that"", such problems persist. Modules requires that the conflicting definitions be eliminated or that they be placed in separate modules (the former is generally the better answer). **Missing includes**; Headers are often missing ``#include`` directives for headers that they actually depend on. As with the problem of conflicting definitions, this only affects unlucky users who don't happen to include headers in the right order. With modules, the headers of a particular module will be parsed in isolation, so the module may fail to build if there are missing includes. **Headers that vend multiple APIs at different times**; Some systems have headers that contain a number of different kinds of API definitions, only some of which are made available with a given include. For example, the header may vend ``size_t`` only when the macro ``__need_size_t`` is defined before that header is included, and also vend ``wchar_t`` only when the macro ``__need_wchar_t`` is defined. Such headers are often included many times in a single translation unit, and will have no include guards. There is no sane way to map this header to a submodule. One can either eliminate the header (e.g., by splitting it into separate headers, one per actual A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:54693,depend,depend,54693,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['depend'],['depend']
Integrability,"eader should have header guards and include all other headers it needs. There are rare cases where a file designed to be included is not; self-contained. These are typically intended to be included at unusual; locations, such as the middle of another file. They might not use header; guards, and might not include their prerequisites. Name such files with the; .inc extension. Use sparingly, and prefer self-contained headers when possible. In general, a header should be implemented by one or more ``.cpp`` files. Each; of these ``.cpp`` files should include the header that defines their interface; first. This ensures that all of the dependences of the header have been; properly added to the header itself, and are not implicit. System headers; should be included after user headers for a translation unit. Library Layering; ^^^^^^^^^^^^^^^^. A directory of header files (for example ``include/llvm/Foo``) defines a; library (``Foo``). One library (both; its headers and implementation) should only use things from the libraries; listed in its dependencies. Some of this constraint can be enforced by classic Unix linkers (Mac & Windows; linkers, as well as lld, do not enforce this constraint). A Unix linker; searches left to right through the libraries specified on its command line and; never revisits a library. In this way, no circular dependencies between; libraries can exist. This doesn't fully enforce all inter-library dependencies, and importantly; doesn't enforce header file circular dependencies created by inline functions.; A good way to answer the ""is this layered correctly"" would be to consider; whether a Unix linker would succeed at linking the program if all inline; functions were defined out-of-line. (& for all valid orderings of dependencies; - since linking resolution is linear, it's possible that some implicit; dependencies can sneak through: A depends on B and C, so valid orderings are; ""C B A"" or ""B C A"", in both cases the explicit dependencies come before thei",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:30674,depend,dependencies,30674,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['depend'],['dependencies']
Integrability,"eaders; ------------. For AMDGPU the following values apply for each of the unit headers described in; DWARF Version 5 sections 7.5.1.1, 7.5.1.2, and 7.5.1.3:. ``address_size`` (ubyte); Matches the address size for the ``Global`` address space defined in; :ref:`amdgpu-dwarf-address-space-identifier`. .. _amdgpu-code-conventions:. Code Conventions; ================. This section provides code conventions used for each supported target triple OS; (see :ref:`amdgpu-target-triples`). AMDHSA; ------. This section provides code conventions used when the target triple OS is; ``amdhsa`` (see :ref:`amdgpu-target-triples`). .. _amdgpu-amdhsa-code-object-metadata:. Code Object Metadata; ~~~~~~~~~~~~~~~~~~~~. The code object metadata specifies extensible metadata associated with the code; objects executed on HSA [HSA]_ compatible runtimes (see :ref:`amdgpu-os`). The; encoding and semantics of this metadata depends on the code object version; see; :ref:`amdgpu-amdhsa-code-object-metadata-v2`,; :ref:`amdgpu-amdhsa-code-object-metadata-v3`,; :ref:`amdgpu-amdhsa-code-object-metadata-v4` and; :ref:`amdgpu-amdhsa-code-object-metadata-v5`. Code object metadata is specified in a note record (see; :ref:`amdgpu-note-records`) and is required when the target triple OS is; ``amdhsa`` (see :ref:`amdgpu-target-triples`). It must contain the minimum; information necessary to support the HSA compatible runtime kernel queries. For; example, the segment sizes needed in a dispatch packet. In addition, a; high-level language runtime may require other information to be included. For; example, the AMD OpenCL runtime records kernel argument information. .. _amdgpu-amdhsa-code-object-metadata-v2:. Code Object V2 Metadata; +++++++++++++++++++++++. .. warning::; Code object V2 generation is no longer supported by this version of LLVM. Code object V2 metadata is specified by the ``NT_AMD_HSA_METADATA`` note record; (see :ref:`amdgpu-note-records-v2`). The metadata is specified as a YAML formatted string ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:117363,depend,depends,117363,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['depend'],['depends']
Integrability,"eady available,; something that reassoc doesn't think about yet. //===---------------------------------------------------------------------===//. These two functions should generate the same code on big-endian systems:. int g(int *j,int *l) { return memcmp(j,l,4); }; int h(int *j, int *l) { return *j - *l; }. this could be done in SelectionDAGISel.cpp, along with other special cases,; for 1,2,4,8 bytes. //===---------------------------------------------------------------------===//. It would be nice to revert this patch:; http://lists.llvm.org/pipermail/llvm-commits/Week-of-Mon-20060213/031986.html. And teach the dag combiner enough to simplify the code expanded before ; legalize. It seems plausible that this knowledge would let it simplify other; stuff too. //===---------------------------------------------------------------------===//. For vector types, DataLayout.cpp::getTypeInfo() returns alignment that is equal; to the type size. It works but can be overly conservative as the alignment of; specific vector types are target dependent. //===---------------------------------------------------------------------===//. We should produce an unaligned load from code like this:. v4sf example(float *P) {; return (v4sf){P[0], P[1], P[2], P[3] };; }. //===---------------------------------------------------------------------===//. Add support for conditional increments, and other related patterns. Instead; of:. 	movl 136(%esp), %eax; 	cmpl $0, %eax; 	je LBB16_2	#cond_next; LBB16_1:	#cond_true; 	incl _foo; LBB16_2:	#cond_next. emit:; 	movl	_foo, %eax; 	cmpl	$1, %edi; 	sbbl	$-1, %eax; 	movl	%eax, _foo. //===---------------------------------------------------------------------===//. Combine: a = sin(x), b = cos(x) into a,b = sincos(x). Expand these to calls of sin/cos and stores:; double sincos(double x, double *sin, double *cos);; float sincosf(float x, float *sin, float *cos);; long double sincosl(long double x, long double *sin, long double *cos);. Doing so could allow SROA o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:3863,depend,dependent,3863,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['depend'],['dependent']
Integrability,"eaken its invariants, e.g. arg count may be; wrong. This would introduce a huge burden on consumers of the AST to handle such; ""impossible"" cases. So when we're representing (rather than correcting) errors,; we use a distinct recovery node type with extremely weak invariants instead. ``RecoveryExpr`` is the only recovery node so far. In practice, broken decls; need more detailed semantics preserved (the current ``Invalid`` flag works; fairly well), and completely broken statements with interesting internal; structure are rare (so dropping the statements is OK). Types and dependence; ^^^^^^^^^^^^^^^^^^^^. ``RecoveryExpr`` is an ``Expr``, so it must have a type. In many cases the true; type can't really be known until the code is corrected (e.g. a call to a; function that doesn't exist). And it means that we can't properly perform type; checks on some containing constructs, such as ``return 42 + unknownFunction()``. To model this, we generalize the concept of dependence from C++ templates to; mean dependence on a template parameter or how an error is repaired. The; ``RecoveryExpr`` ``unknownFunction()`` has the totally unknown type; ``DependentTy``, and this suppresses type-based analysis in the same way it; would inside a template. In cases where we are confident about the concrete type (e.g. the return type; for a broken non-overloaded function call), the ``RecoveryExpr`` will have this; type. This allows more code to be typechecked, and produces a better AST and; more diagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:88064,depend,dependence,88064,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['depend'],['dependence']
Integrability,"eate miscompiles if mixing of constrained and normal; operations is done. The correct way to mix constrained and less constrained; operations is to use the rounding mode and exception handling metadata to; mark constrained intrinsics as having LLVM's default behavior. Each of these intrinsics corresponds to a normal floating-point operation. The; data arguments and the return value are the same as the corresponding FP; operation. The rounding mode argument is a metadata string specifying what; assumptions, if any, the optimizer can make when transforming constant; values. Some constrained FP intrinsics omit this argument. If required; by the intrinsic, this argument must be one of the following strings:. ::. ""round.dynamic""; ""round.tonearest""; ""round.downward""; ""round.upward""; ""round.towardzero""; ""round.tonearestaway"". If this argument is ""round.dynamic"" optimization passes must assume that the; rounding mode is unknown and may change at runtime. No transformations that; depend on rounding mode may be performed in this case. The other possible values for the rounding mode argument correspond to the; similarly named IEEE rounding modes. If the argument is any of these values; optimization passes may perform transformations as long as they are consistent; with the specified rounding mode. For example, 'x-0'->'x' is not a valid transformation if the rounding mode is; ""round.downward"" or ""round.dynamic"" because if the value of 'x' is +0 then; 'x-0' should evaluate to '-0' when rounding downward. However, this; transformation is legal for all other rounding modes. For values other than ""round.dynamic"" optimization passes may assume that the; actual runtime rounding mode (as defined in a target-specific manner) matches; the specified rounding mode, but this is not guaranteed. Using a specific; non-dynamic rounding mode which does not match the actual rounding mode at; runtime results in undefined behavior. The exception behavior argument is a metadata string describing th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:868835,depend,depend,868835,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depend']
Integrability,"ebuggingSampler Simply returns a uniform distribution; between 0,1. �Useful for debugging. NeymanConstruction and FeldmanCousins; A flexible framework for the Neyman Construction was added in this; release. The NeymanConstruction is a concrete implementation of the; IntervalCalculator interface, but it needs several; additional components�to be specified before use. The design; factorizes the choice of the parameter points to be tested,�the choice of; the test statistic, and the generation of sampling distribution into; separate parts (described above). �Finally, the NeymanConstruction class; is simply in charge of using these parts (strategies) and constructing; the confidence belt and confidence intervals. �The ConfidenceBelt class; is still under development, but the current version works fine for; producing ConfidenceIntervals. �We are also working to make this class; work with parallelization approaches, which is not yet complete.; The FeldmanCousins class is a separate concrete implementation of the; IntervalCalculator interface. �It uses the NeymanConstruction internally,; and�enforces�specific choices of the test statistic and ordering; principle to realize the Unified intervals described by Feldman and; Cousins in their paper�Phys.Rev.D57:3873-3889,1998. In an extension to the technique discussed in Feldman and Cousins paper,; the FeldmanCousins class also performs a ""profile construction"" if their are nuisance parameters.; In this case, the parameters of interest are scanned in a regular grid. For each point in the grid; the calculator finds the best fit value of the nuisance parameters (given the data). The construction; is then only performed in this subspace of the parameters. As a result, the number of points in the; construction only scales in the number of parameters of interest, not in the number of nuisance parameters. Markov Chain Monte Carlo Interval; A flexible framework for Markov Chain Monte Carlo was added in this; release. The MCMCCalculator",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:28621,interface,interface,28621,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['interface'],['interface']
Integrability,"ecause; the feature they test was broken and has been fixed). **FAIL**. The test failed. **UNRESOLVED**. The test result could not be determined. For example, this occurs when the test; could not be run, the test itself is invalid, or the test was interrupted. **UNSUPPORTED**. The test is not supported in this environment. This is used by test formats; which can report unsupported tests. **TIMEOUT**. The test was run, but it timed out before it was able to complete. This is; considered a failure. Depending on the test format tests may produce additional information about; their status (generally only for failures). See the :ref:`output-options`; section for more information. .. _lit-infrastructure:. LIT INFRASTRUCTURE; ------------------. This section describes the :program:`lit` testing architecture for users interested in; creating a new :program:`lit` testing implementation, or extending an existing one. :program:`lit` proper is primarily an infrastructure for discovering and running; arbitrary tests, and to expose a single convenient interface to these; tests. :program:`lit` itself doesn't know how to run tests, rather this logic is; defined by *test suites*. TEST SUITES; ~~~~~~~~~~~. As described in :ref:`test-discovery`, tests are always located inside a *test; suite*. Test suites serve to define the format of the tests they contain, the; logic for finding those tests, and any additional information to run the tests. :program:`lit` identifies test suites as directories containing ``lit.cfg`` or; ``lit.site.cfg`` files (see also :option:`--config-prefix`). Test suites are; initially discovered by recursively searching up the directory hierarchy for; all the input files passed on the command line. You can use; :option:`--show-suites` to display the discovered test suites at startup. Once a test suite is discovered, its config file is loaded. Config files; themselves are Python modules which will be executed. When the config file is; executed, two important globa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:14018,interface,interface,14018,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['interface'],['interface']
Integrability,"ecessary; to support the somewhat common pattern in C of intentionally storing to an; invalid pointer to crash the program. In the future, it might make sense to; allow frontends to control this behavior. IR-level volatile loads and stores cannot safely be optimized into llvm.memcpy; or llvm.memmove intrinsics even when those intrinsics are flagged volatile.; Likewise, the backend should never split or merge target-legal volatile; load/store instructions. Similarly, IR-level volatile loads and stores cannot; change from integer to floating-point or vice versa. .. admonition:: Rationale. Platforms may rely on volatile loads and stores of natively supported; data width to be executed as single instruction. For example, in C; this holds for an l-value of volatile primitive type with native; hardware support, but not necessarily for aggregate types. The; frontend upholds these expectations, which are intentionally; unspecified in the IR. The rules above ensure that IR transformations; do not violate the frontend's contract with the language. .. _memmodel:. Memory Model for Concurrent Operations; --------------------------------------. The LLVM IR does not define any way to start parallel threads of; execution or to register signal handlers. Nonetheless, there are; platform-specific ways to create them, and we define LLVM IR's behavior; in their presence. This model is inspired by the C++ memory model. For a more informal introduction to this model, see the :doc:`Atomics`. We define a *happens-before* partial order as the least partial order; that. - Is a superset of single-thread program order, and; - When ``a`` *synchronizes-with* ``b``, includes an edge from ``a`` to; ``b``. *Synchronizes-with* pairs are introduced by platform-specific; techniques, like pthread locks, thread creation, thread joining,; etc., and by atomic instructions. (See also :ref:`Atomic Memory Ordering; Constraints <ordering>`). Note that program order does not introduce *happens-before* edges; be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:148679,contract,contract,148679,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['contract'],['contract']
Integrability,ecialization on member function types; Clang 3.2. 548; dup; qualified-ids in declarations; Duplicate of 482. 549; drafting; Non-deducible parameters in partial specializations; Not resolved. 550; dup; Pointer to array of unknown bound in parameter declarations; Unknown. 551; CD1; When is inline permitted in an explicit instantiation?; Yes (C++11 onwards). 552; NAD; Use of typename in the type in a non-type parameter-declaration; Yes. 553; NAD; Problems with friend allocation and deallocation functions; Unknown. 554; CD6; Definition of “declarative region” and “scope”; N/A. 555; CD5; Pseudo-destructor name lookup; Unknown. 556; CD2; Conflicting requirements for acceptable aliasing; N/A. 557; CD1; Does argument-dependent lookup cause template instantiation?; Clang 3.1. 558; CD1; Excluded characters in universal character names; Clang 2.9. 559; CD1; Editing error in issue 382 resolution; Yes. 560; NAD; Use of the typename keyword in return types; Unknown. 561; CD2; Internal linkage functions in dependent name lookup; Yes. 562; CD6; qualified-ids in non-expression contexts; N/A. 563; CD6; Linkage specification for objects; Unknown. 564; CD2; Agreement of language linkage or linkage-specifications?; Yes. 565; CD3; Conflict rules for using-declarations naming function templates; Yes. 566; NAD; Conversion of negative floating point values to integer type; Yes. 567; NAD; Can size_t and ptrdiff_t be larger than long?; N/A. 568; CD1; Definition of POD is too strict; Clang 3.0 (C++11 onwards). 569; CD2; Spurious semicolons at namespace scope should be allowed; Yes (C++11 onwards). 570; CD2; Are references subject to the ODR?; Duplicate of 633. 571; CD2; References declared const; Unknown. 572; C++11; Standard conversions for non-built-in types; Yes. 573; C++11; Conversions between function pointers and void*; No. 574; NAD; Definition of “copy assignment operator”; Clang 3.0. 575; C++11; Criteria for deduction failure; Yes. 576; CD2; Typedefs in function definitions; Clang 3.5.,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:38480,depend,dependent,38480,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"ecise lifetime semantics and, at some point after ``T`` but; before the next store to ``S``, the computation history features a; load from ``S`` and in some way depends on the value loaded, or. * ``X`` is a value described as being released at the end of the; current full-expression and, at some point after ``T`` but before; the end of the full-expression, the computation history depends; on that value. .. admonition:: Rationale. The intent of the second rule is to say that objects held in normal; ``__strong`` local variables may be released as soon as the value in; the variable is no longer being used: either the variable stops; being used completely or a new value is stored in the variable. The intent of the third rule is to say that return values may be; released after they've been used. A computation history depends on a pointer value ``P`` if it:. * performs a pointer comparison with ``P``,; * loads from ``P``,; * stores to ``P``,; * depends on a pointer value ``Q`` derived via pointer arithmetic; from ``P`` (including an instance-variable or field access), or; * depends on a pointer value ``Q`` loaded from ``P``. Dependency applies only to values derived directly or indirectly from; a particular expression result and does not occur merely because a; separate pointer value dynamically aliases ``P``. Furthermore, this; dependency is not carried by values that are stored to objects. .. admonition:: Rationale. The restrictions on dependency are intended to make this analysis; feasible by an optimizer with only incomplete information about a; program. Essentially, dependence is carried to ""obvious"" uses of a; pointer. Merely passing a pointer argument to a function does not; itself cause dependence, but since generally the optimizer will not; be able to prove that the function doesn't depend on that parameter,; it will be forced to conservatively assume it does. Dependency propagates to values loaded from a pointer because those; values might be invalidated by deal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:79961,depend,depends,79961,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['depend'],['depends']
Integrability,"ecl>...; Matches Objective-C category definitions. Example matches Foo (Additions); @implementation Foo (Additions); @end. Matcher<Decl>objcImplementationDeclMatcher<ObjCImplementationDecl>...; Matches Objective-C implementation declarations. Example matches Foo; @implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matches Objective-C instance variable declarations. Example matches _enabled; @implementation Foo {; BOOL _enabled;; }; @end. Matcher<Decl>objcMethodDeclMatcher<ObjCMethodDecl>...; Matches Objective-C method declarations. Example matches both declaration and definition of -[Foo method]; @interface Foo; - (void)method;; @end. @implementation Foo; - (void)method {}; @end. Matcher<Decl>objcPropertyDeclMatcher<ObjCPropertyDecl>...; Matches Objective-C property declarations. Example matches enabled; @interface Foo; @property BOOL enabled;; @end. Matcher<Decl>objcProtocolDeclMatcher<ObjCProtocolDecl>...; Matches Objective-C protocol declarations. Example matches FooDelegate; @protocol FooDelegate; @end. Matcher<Decl>parmVarDeclMatcher<ParmVarDecl>...; Matches parameter variable declarations. Given; void f(int x);; parmVarDecl(); matches int x. Matcher<Decl>recordDeclMatcher<RecordDecl>...; Matches class, struct, and union declarations. Example matches X, Z, U, and S; class X;; template<class T> class Z {};; struct S {};; union U {};. Matcher<Decl>staticAssertDeclMatcher<StaticAssertDecl>...; Matches a C++ static_assert declaration. Example:; staticAssertDecl(); matches; static_assert(sizeof(S) == sizeof(int)); in; struct S {; int x;; };; static_assert(sizeof(S) == sizeof(int));. Matcher<Decl>tagDeclMatcher<TagDecl>...; Matches tag declarations. Example matches X, Z, U, S, E; class X;; template<class T> class Z {};; struct S {};; union U {};; enum E {; A, B, C; };. Matcher<Decl>templateTempla",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:16174,interface,interface,16174,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['interface'],['interface']
Integrability,"eclarative regions, and translation units; N/A. 2166; drafting; Unclear meaning of “undefined constexpr function”; Not resolved. 2167; CD4; Non-member references with lifetimes within the current evaluation; Unknown. 2168; open; Narrowing conversions and +/- infinity; Not resolved. 2169; open; Narrowing conversions and overload resolution; Not resolved. 2170; CD5; Unclear definition of odr-use for arrays; Clang 9. 2171; CD4; Triviality of copy constructor with less-qualified parameter; Clang 15. 2172; drafting; Multiple exceptions with one exception object; Not resolved. 2173; open; Partial specialization with non-deduced contexts; Not resolved. 2174; C++17; Unclear rules for friend definitions in templates; Unknown. 2175; CD4; Ambiguity with attribute in conversion operator declaration; Unknown. 2176; CD4; Destroying the returned object when a destructor throws; Unknown. 2177; CD5; Placement operator delete and parameter copies; Unknown. 2178; NAD; Substitution of dependent template arguments in default template arguments; Unknown. 2179; drafting; Required diagnostic for partial specialization after first use; Not resolved. 2180; CD4; Virtual bases in destructors and defaulted assignment operators; Yes. 2181; drafting; Normative requirements in an informative Annex; Not resolved. 2182; drafting; Pointer arithmetic in array-like containers; Not resolved. 2183; NAD; Problems in description of potential exceptions; Unknown. 2184; CD4; Missing C compatibility entry for decrement of bool; Unknown. 2185; CD6; Cv-qualified numeric types; Unknown. 2186; drafting; Unclear point that “preceding initialization” must precede; Not resolved. 2187; drafting; Protected members and access via qualified-id; Not resolved. 2188; open; empty-declaration grammar ambiguity; Not resolved. 2189; open; Surrogate call template; Not resolved. 2190; open; Insufficient specification of __has_include; Not resolved. 2191; C++17; Incorrect result for noexcept(typeid(v)); Unknown. 2192; open; Const",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:148418,depend,dependent,148418,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"ect `a` of type **`TArrow`**. When; you want to draw the line, you do:. ``` {.cpp}; l.Draw();; ```. `Draw()` from **`TLine`** is called. If you do:. ``` {.cpp}; a.Draw();; ```. `Draw()` from **`TArrow`** is called and the arrow `a` is drawn. ### Data Encapsulation. We have seen previously the keyword ""`public`"". This keyword means; that every name declared public is seen by the outside world. This is; opposed to ""`private`"" that means only the class where the name was; declared private could see this name. For example, suppose we declare; in **`TArrow`** the variable `ArrowHeadSize` private. ``` {.cpp}; private:; int ArrowHeadSize;; ```. Then, only the methods (i.e. member functions) of **`TArrow`** will be; able to access this variable. Nobody else will see it. Even the; classes that we could derive from **`TArrow`** will not see it. On the; other hand, if we declare the method `Draw()` as public, everybody will; be able to see it and use it. You see that the character public or; private does not depend of the type of argument. It can be a data; member, a member function, or even a class. For example, in the case; of **`TArrow`**, the base class **`TLine`** is declared as public:. ``` {.cpp}; class TArrow : public TLine { ...; ```. This means that all methods of **`TArrow`** will be able to access all; methods of **`TLine`**, but this will be also true for anybody in the; outside world. Of course, this is true if **`TLine`** accepts the; outside world to see its methods/data members. If something is; declared private in **`TLine`**, nobody will see it, not even; **`TArrow`** members, even if **`TLine`** is declared as a public; base class. What if **`TLine`** is declared ""`private`"" instead of ""`public`"" ?; Well, it will behave as any other name declared private in; **`TArrow`**: only the data members and methods of **`TArrow`** will; be able to access **`TLine`**, its methods and data members, nobody; else. This may seem a little bit confusing and readers should re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:4631,depend,depend,4631,documentation/users-guide/ALittleC++.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md,1,['depend'],['depend']
Integrability,"ect with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can break the library API or cause compilation failures; in the library header itself. For an extreme example,; ``#define std ""The C++ Standard""`` and then include a standard; library header: the result is a horrific cascade of failures in the; C++ Standard Library's implementation. More subtle real-world; problems occur when the headers for two different libraries interact; due to macro collisions, and users are forced to reorder; ``#include`` directives or introduce ``#undef`` directives to break; the (unintended) dependency. * **Conventional workarounds**: C programmers have; adopted a number of conventions to work around the fragility of the; C preprocessor model. Include guards, for example, are required for; the vast majority of headers to ensure that multiple inclusion; doesn't break the compile. Macro names are written with; ``LONG_PREFIXED_UPPERCASE_IDENTIFIERS`` to avoid collisions, and some; library/framework developers even use ``__underscored`` names; in headers to avoid collisions with ""normal"" names that (by; convention) shouldn't even be macros. These conventions are a; barrier to entry for developers coming from non-C languages, are; boilerplate for more experienced developers, and make our headers; far uglier than they should be. * **Tool confusion**: In a C-based language, it is hard to build tools; that work well with software libraries, because the boundaries of; t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:2518,depend,dependency,2518,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['depend'],['dependency']
Integrability,"ect, use:. ``` {.cpp}; TClass::GetClass(classname)->SetCanSplit(true);; ```. ### I/O Schema Checksum. The algorithm used to calculate a single number giving an indication on whether; the schema layout has changed (i.e. if two StreamerInfo are equivalent) have; been update to. - Use the normalized name for the types (i.e. two different spelling of the same; name will lead to the same checksum); - Take into account the base classes' checksum in the derived class checksum;; this is necessary to properly support base classes during memberwise streaming. The algorithm that checks whether two StreamerInfo are equal even-though their; checksum is different has been significantly enhanced in particular to also; check the base classes. ### TFileMerger. - Added possibility to merge only a list of objects/folders from the; input files, specified by name, \; or to skip them from merging. This is fully integrated with the new; PartialMerge(flags) schema. \; Usage: \; The names of the objects to be merged or skipped have to be; specified using the interface:. ``` {.cpp}; TFileMerger::AddObjectNames(const char *names); ```. This method can be called several times to add object names. Several; names can be added with one call separated by single blancs (no; blanc at the end). Directory names are accepted, applying the; merging selection to all content. Two new options are being; supported for partial merging:. ``` {.cpp}; TFileMerger::PartialMerge(flags | kOnlyListed); ```. This will merge only the objects in the files having the names in; the specified list. If a folder is specified, it whole content will; be merged. ``` {.cpp}; TFileMerger::PartialMerge(flags | kSkipListed); ```. This will skip merging for the specified objects. If a folder is; specified, its whole content will be skipped. Important note:; The kOnlyListed and kSkipListed flags have to be bitwise OR-ed; on top of the merging defaults: kAll | kIncremental (as in the example $ROOTSYS/tutorials/io/mergeSelective.C). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v600/index.md:1621,interface,interface,1621,io/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v600/index.md,1,['interface'],['interface']
Integrability,"ected to be substantially more expensive even than using; `%rsp` and potentially `lfence` within the function entry block. ##### Define a new ABI and/or calling convention. We could define a new ABI and/or calling convention to explicitly pass the; predicate state in and out of functions. This may be interesting if none of the; alternatives have adequate performance, but it makes deployment and adoption; dramatically more complex, and potentially infeasible. ## High-Level Alternative Mitigation Strategies. There are completely different alternative approaches to mitigating variant 1; attacks. [Most](https://lwn.net/Articles/743265/); [discussion](https://lwn.net/Articles/744287/) so far focuses on mitigating; specific known attackable components in the Linux kernel (or other kernels) by; manually rewriting the code to contain an instruction sequence that is not; vulnerable. For x86 systems this is done by either injecting an `lfence`; instruction along the code path which would leak data if executed speculatively; or by rewriting memory accesses to have branch-less masking to a known safe; region. On Intel systems, `lfence` [will prevent the speculative load of secret; data](https://newsroom.intel.com/wp-content/uploads/sites/11/2018/01/Intel-Analysis-of-Speculative-Execution-Side-Channels.pdf).; On AMD systems `lfence` is currently a no-op, but can be made; dispatch-serializing by setting an MSR, and thus preclude misspeculation of the; code path ([mitigation G-2 +; V1-1](https://developer.amd.com/wp-content/resources/Managing-Speculation-on-AMD-Processors.pdf)). However, this relies on finding and enumerating all possible points in code; which could be attacked to leak information. While in some cases static; analysis is effective at doing this at scale, in many cases it still relies on; human judgement to evaluate whether code might be vulnerable. Especially for; software systems which receive less detailed scrutiny but remain sensitive to; these attacks, this se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:43888,inject,injecting,43888,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['inject'],['injecting']
Integrability,"ection(SR.getStart(), SR.getEnd());; }. return Error::success();; }. * Record call sites for later mutation -- A post-allocation pass can record; the call sites of all calls to a particular function, allowing those call; sites to be updated later at runtime (e.g. for instrumentation, or to; enable the function to be lazily compiled but still called directly after; compilation). .. code-block:: c++. StringRef FunctionName = ""foo"";; std::vector<ExecutorAddr> CallSitesForFunction;. auto RecordCallSites =; [&](LinkGraph &G) -> Error {; for (auto *B : G.blocks()); for (auto &E : B.edges()); if (E.getKind() == CallEdgeKind &&; E.getTarget().hasName() &&; E.getTraget().getName() == FunctionName); CallSitesForFunction.push_back(B.getFixupAddress(E));; return Error::success();; };. Memory Management with JITLinkMemoryManager; -------------------------------------------. JIT linking requires allocation of two kinds of memory: working memory in the; JIT process and target memory in the execution process (these processes and; memory allocations may be one and the same, depending on how the user wants; to build their JIT). It also requires that these allocations conform to the; requested code model in the target process (e.g. MachO/x86-64's Small code; model requires that all code and data for a simulated dylib is allocated within; 4Gb). Finally, it is natural to make the memory manager responsible for; transferring memory to the target address space and applying memory protections,; since the memory manager must know how to communicate with the executor, and; since sharing and protection assignment can often be efficiently managed (in; the common case of running across processes on the same machine for security); via the host operating system's virtual memory management APIs. To satisfy these requirements ``JITLinkMemoryManager`` adopts the following; design: The memory manager itself has just two virtual methods for asynchronous; operations (each with convenience overloads for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:25829,depend,depending,25829,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['depend'],['depending']
Integrability,"ective-C generics. .. code-block:: objc. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. .. _osx-cocoa-RetainCount:. osx.cocoa.RetainCount (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaks and improper reference count management. .. code-block:: objc. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. .. _osx-cocoa-RunLoopAutoreleaseLeak:. osx.cocoa.RunLoopAutoreleaseLeak; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaked memory in autorelease pools that will never be drained. .. _osx-cocoa-SelfInit:. osx.cocoa.SelfInit (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""; Check that 'self' is properly initialized inside an initializer method. .. code-block:: objc. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. .. _osx-cocoa-SuperDealloc:. osx.cocoa.SuperDealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about improper use of '[super dealloc]' in Objective-C. .. code-block:: objc. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. .. _osx-cocoa-UnusedIvars:. osx.cocoa.UnusedIvars (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about private ivars that are never used. .. code-block:: objc. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. .. _osx-cocoa-VariadicMetho",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:40618,interface,interface,40618,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['interface'],['interface']
Integrability,"ectly the pdf and parameter; objects in the constructors. ; Setter methods using pdf instances and parameter lists are maintained in the derived classes, like the ProfileLikelihoodCalculator or the HybridCalculator, but those passing a string for the name of the pdf have been removed. ; All the calculator classes do not keep anymore a pointer to the workspace, but they contain pointers to the pdf, the data and the parameters required to run the calculator. These pointers are managed outside by the users or by the RooWorkspace. They can be passed either directly to the classes, for example via the constructor, or by using the ModelConfig class. The ModelConfig class acts as an interface to the Workspace in order to load and store all the; needed information. . ProfileLikelihoodCalculator, LikelihoodInterval. The Minos algorithm of Minuit is used now to find the limit of the likelihood intervals instead of searching directly the roots of the RooProfileLL class. Minos is used via the ROOT::Math::Minimizer interface. By default TMinuit is used, one can also use Minuit2 by doing ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"").; The LikelihoodInterval class now provides now two new methods, FindLimits which finds both the upper and lower interval bounds, and GetContourPoints to find the 2D contour points defining the likelihood interval. GetContourPoints is now used by the LikelihoodIntervalPlot class to draw the 2D contour.; ; New tutorials have been added: rs501_ProfileLikelihoodCalculator_limit.C and rs502_ProfileLikelihoodCalculator_significance.C for getting the interval limits and significance using the ProfileLikelihoodCalculator. The tutorials can be run on a set of Poisson data or Gaussian over flat with model considering optionally the nuisance parameters. The data can be generated with the rs500 tutorials. HybridCalculator. In the constructor the signature passing a name and a title string has been removed, for being consistent with all the other ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:12977,interface,interface,12977,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,1,['interface'],['interface']
Integrability,"ects) can be; deallocated by calling the ``JITLinkMemoryManager::dealloc`` method. This method; takes a vector of ``FinalizedAlloc`` objects, since it is common to deallocate; multiple objects at the same time and this allows us to batch these requests for; transmission to the executing process. JITLink provides a simple in-process implementation of this interface:; ``InProcessMemoryManager``. It allocates pages once and re-uses them as both; working and target memory. ORC provides a cross-process-capable ``MapperJITLinkMemoryManager`` that can use; shared memory or ORC-RPC-based communication to transfer content to the executing; process. JITLinkMemoryManager and Security; ---------------------------------. JITLink's ability to link JIT'd code for a separate executor process can be; used to improve the security of a JIT system: The executor process can be; sandboxed, run within a VM, or even run on a fully separate machine. JITLink's memory manager interface is flexible enough to allow for a range of; trade-offs between performance and security. For example, on a system where code; pages must be signed (preventing code from being updated), the memory manager; can deallocate working memory pages after linking to free memory in the process; running JITLink. Alternatively, on a system that allows RWX pages, the memory; manager may use the same pages for both working and target memory by marking; them as RWX, allowing code to be modified in place without further overhead.; Finally, if RWX pages are not permitted but dual-virtual-mappings of; physical memory pages are, then the memory manager can dual map physical pages; as RW- in the JITLink process and R-X in the executor process, allowing; modification from the JITLink process but not from the executor (at the cost of; extra administrative overhead for the dual mapping). Error Handling; --------------. JITLink makes extensive use of the ``llvm::Error`` type (see the error handling; section of :doc:`ProgrammersManual`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:30978,interface,interface,30978,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['interface'],['interface']
Integrability,"ects](pictures/020001EE.jpg). The second use case applies when starting to edit an existing geometry.; Supposing the geometry was loaded into memory, besides the first method; that still applies one can also edit drawn geometry objects. For this,; the menu entry View/Editor of the canvas containing for instance a drawn; volume must be activated. For starting the volume editor one can click; on a volume. The GUI of the **`TGeoManager`** class can be started by; clicking on the top-right `40x40` pixels corner of the pad with a drawn; geometry. This is the main entry point for editing the geometry or creating new; objects. Once the interface is created (using one of the methods; described above), several categories can be accessed via a shutter GUI; widget:. - *General.* This allows changing the name/title of the geometry,; setting the top volume, closing the geometry and saving the geometry; in a file. The file name is formed by `geometry_name.C` or `.root`; depending if the geometry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of properties related to tracking); - *Matrices.* Allows creation of translations, rotations or combined; transformations. Existing matrices can also be browser/edited. ### Editing Existing Objects. For editing an existing object from one of the categories described; above, the interface imposes first a selection",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:168048,depend,depending,168048,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['depend'],['depending']
Integrability,"ecute converged dynamic instances of the operation. By; definition, this changes the set of threads that participate in the; communication of the convergent operation, which will typically change its; result. There are a number of exceptions, though most of them require additional; knowledge. For example, hoisting and sinking across *uniform* conditional branches -- i.e.,; conditional branches where within every possible relevant set of threads, all; threads will always take the same direction -- is generally allowed. See the end; of the :ref:`example of reductions inside control flow; <convergence_example_reductions>` for a brief discussion. Some convergent operations can be hoisted but not sunk, or vice versa. A simple; example is the ``subgroupShuffle(data, id)`` operation. It returns the ``data``; operand of the thread identified by ``id``, where thread IDs are fixed and; assigned to each thread at launch. The result is undefined (or perhaps there is; UB, depending on the language and environment) if thread ``id`` is not in the; communicating set of threads. So hoisting is allowed in the following; pseudo-code example:. .. code-block:: llvm. define void @example(...) convergent {; %entry = call token @llvm.experimental.convergence.entry(); %data = ...; %id = ...; if (condition) {; %shuffled = call i32 @subgroupShuffle(i32 %data, i32 %id) [ ""convergencectrl""(token %entry) ]; ...; } else {; %shuffled = call i32 @subgroupShuffle(i32 %data, i32 %id) [ ""convergencectrl""(token %entry) ]; ...; }; }. After hoisting the calls to ``@subgroupShuffle``, the communicating set of; threads is the union of the two sets of threads in the original program, so; ``%id`` can only go ""out of range"" after hoisting if it did so in the original; program. However, speculative execution of ``@subgroupShuffle`` in the following program; may be forbidden:. .. code-block:: llvm. define void @example(...) convergent {; %entry = call token @llvm.experimental.convergence.entry(); %data = ...; %i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:56301,depend,depending,56301,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['depend'],['depending']
Integrability,"ecution; of threads. Informational note: Threads that execute converged dynamic instances do not; necessarily do so at the same time. Other Interactions; ==================. A function can be both ``convergent`` and; ``speculatable``, indicating that the function does not have undefined; behavior and has no effects besides calculating its result, but is still; affected by the set of threads executing this function. This typically; prevents speculation of calls to the function unless the constraint imposed; by ``convergent`` is further relaxed by some other means. Controlled Maximal Convergence; ==============================. The :ref:`converged-with relation <convergence-definition>` over dynamic; instances of each controlled convergent operation is completely defined by the; semantics of convergence tokens. But the implementation-defined convergence at a; call to :ref:`llvm.experimental.convergence.anchor; <llvm.experimental.convergence.anchor>` also depends on the cycle hierarchy; chosen if it occurs inside an irreducible cycle. When the token defined by a convergent operation ``D`` is used at another; convergent operation ``U``, the implementation must ensure that the threads that; converge at ``U`` are all the threads that reached ``U`` after converging at; ``D``. On most implementations, it is reasonable to assume that only these; threads are converged at every node they reach on any path from ``D`` to ``U``.; In other words, the converged-with relation at ``D`` produces groups of threads; that can converge only within each group, while inside the convergence region of; ``D``. All this affects the :ref:`maximal converged-with relation; <convergence-maximal>` over dynamic instances and in turn the :ref:`m-converged; property <uniformity-analysis>` of static instances in the convergence region of; ``D``. .. _controlled_maximal_converged_with:. **Controlled Maximal converged-with Relation**. 1. Dynamic instances of a *convergent operation* are related in the cont",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:35545,depend,depends,35545,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['depend'],['depends']
Integrability,ed by a non-member using-declaration?; Unknown. 1904; NAD; Default template arguments for members of class templates; Unknown. 1905; NAD; Dependent types and injected-class-names; Unknown. 1906; NAD; Name lookup in member friend declaration; Unknown. 1907; CD6; using-declarations and default arguments; Unknown. 1908; CD6; Dual destructor lookup and template-ids; Unknown. 1909; CD4; Member class template with the same name as the class; Clang 3.7. 1910; CD5; “Shall” requirement applied to runtime behavior; Unknown. 1911; CD4; constexpr constructor with non-literal base class; Unknown. 1912; CD5; exception-specification of defaulted function; Unknown. 1913; CD5; decltype((x)) in lambda-expressions; Unknown. 1914; extension; Duplicate standard attributes; Extension. 1915; open; Potentially-invoked destructors in non-throwing constructors; Not resolved. 1916; CD4; “Same cv-unqualified type”; Unknown. 1917; NAD; decltype-qualified enumeration names; Unknown. 1918; open; friend templates with dependent scopes; Not resolved. 1919; open; Overload resolution for ! with explicit conversion operator; Not resolved. 1920; CD4; Qualification mismatch in pseudo-destructor-name; Unknown. 1921; NAD; constexpr constructors and point of initialization of const variables; Unknown. 1922; CD4; Injected class template names and default arguments; Unknown. 1923; NAD; Lvalues of type void; Unknown. 1924; review; Definition of “literal” and kinds of literals; Not resolved. 1925; CD4; Bit-field prvalues; Unknown. 1926; CD4; Potential results of subscript operator; Unknown. 1927; dup; Lifetime of temporaries in init-captures; Unknown. 1928; NAD; Triviality of deleted special member functions; Unknown. 1929; CD4; template keyword following namespace nested-name-specifier; Unknown. 1930; CD4; init-declarator-list vs member-declarator-list; Unknown. 1931; CD5; Default-constructible and copy-assignable closure types; Unknown. 1932; CD4; Bit-field results of conditional operators; Unknown. 1933; NA,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:130243,depend,dependent,130243,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"ed in; ``test/Bitcode/compatibility.ll``. * The current LLVM version supports loading any bitcode since version 3.0. * After each X.Y release, ``compatibility.ll`` must be copied to; ``compatibility-X.Y.ll``. The corresponding bitcode file should be assembled; using the X.Y build and committed as ``compatibility-X.Y.ll.bc``. * Newer releases can ignore features from older releases, but they cannot; miscompile them. For example, if nsw is ever replaced with something else,; dropping it would be a valid way to upgrade the IR. * Debug metadata is special in that it is currently dropped during upgrades. * Non-debug metadata is defined to be safe to drop, so a valid way to upgrade; it is to drop it. That is not very user friendly and a bit more effort is; expected, but no promises are made. C API Changes; -------------. * Stability Guarantees: The C API is, in general, a ""best effort"" for stability.; This means that we make every attempt to keep the C API stable, but that; stability will be limited by the abstractness of the interface and the; stability of the C++ API that it wraps. In practice, this means that things; like ""create debug info"" or ""create this type of instruction"" are likely to be; less stable than ""take this IR file and JIT it for my current machine"". * Release stability: We won't break the C API on the release branch with patches; that go on that branch, with the exception that we will fix an unintentional; C API break that will keep the release consistent with both the previous and; next release. * Testing: Patches to the C API are expected to come with tests just like any; other patch. * Including new things into the API: If an LLVM subcomponent has a C API already; included, then expanding that C API is acceptable. Adding C API for; subcomponents that don't currently have one needs to be discussed on the; `LLVM Discourse forums`_ for design and maintainability feedback prior to implementation. * Documentation: Any changes to the C API are required to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:32788,interface,interface,32788,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,2,"['interface', 'wrap']","['interface', 'wraps']"
Integrability,"ed into ``__weak`` locations; if garbage collection is enabled. Within a Block literal expression within a method definition; references to instance variables are also imported into the lexical; scope of the compound statement. These variables are implicitly; qualified as references from self, and so self is imported as a const; copy. The net effect is that instance variables can be mutated. The :block-term:`Block_copy` operator retains all objects held in; variables of automatic storage referenced within the Block expression; (or form strong references if running under garbage collection).; Object variables of ``__block`` storage type are assumed to hold; normal pointers with no provision for retain and release messages. Foundation defines (and supplies) ``-copy`` and ``-release`` methods for; Blocks. In the Objective-C and Objective-C++ languages, we allow the; ``__weak`` specifier for ``__block`` variables of object type. If; garbage collection is not enabled, this qualifier causes these; variables to be kept without retain messages being sent. This; knowingly leads to dangling pointers if the Block (or a copy) outlives; the lifetime of this object. In garbage collected environments, the ``__weak`` variable is set to; nil when the object it references is collected, as long as the; ``__block`` variable resides in the heap (either by default or via; ``Block_copy()``). The initial Apple implementation does in fact; start ``__block`` variables on the stack and migrate them to the heap; only as a result of a ``Block_copy()`` operation. It is a runtime error to attempt to assign a reference to a; stack-based Block into any storage marked ``__weak``, including; ``__weak`` ``__block`` variables. C++ Extensions; ==============. Block literal expressions within functions are extended to allow const; use of C++ objects, pointers, or references held in automatic storage. As usual, within the block, references to captured variables become; const-qualified, as if they were refe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:10301,message,messages,10301,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['message'],['messages']
Integrability,"ed into the; list the object pointer is wrapped in a **`TObjLink`** object that; contains, besides the object pointer also a previous and next pointer. Objects are typically added using:. - `Add()`. - `AddFirst(), AddLast()`. - `AddBefore(), AddAfter()`. **Main features of`TList`**: very low cost of adding/removing elements; anywhere in the list. **Overhead per element**: 1 `TObjLink`, i.e. two 4 (or 8) byte pointers; + pointer to `vtable` = 12 (or 24) bytes. Next figure shows the internal data structure of a **`TList`**. ![The internal data structure of a TList](pictures/020001A6.jpg). ### Iterating Over a TList. There are four ways to iterate over a **`TList`**:. - Using the `ForEach` script:. ``` {.cpp}; GetListOfPrimitives()->ForEach(TObject,Draw)();; ```. - Using the **`TList`** iterator **`TListIter`** (via the wrapper; class **`TIter`**):. ``` {.cpp}; TIter next(GetListOfTracks());; while ((TTrack *obj = (TTrack *)next())); obj->Draw();; ```. - Using the **`TObjLink`** list entries (that wrap the; **`TObject`**\*):. ``` {.cpp}; TObjLink *lnk = GetListOfPrimitives()->FirstLink();; while (lnk) {; lnk->GetObject()->Draw();; lnk = lnk->Next();; }; ```. - Using the **`TList`**'s `After()` and `Before()` member functions:. ``` {.cpp}; TFree *idcur = this;; while (idcur) {; ...; idcur = (TFree*)GetListOfFree()->After(idcur);; }; ```. Method 1 uses internally method 2. Method 2 works for all collection classes. **`TIter`** overloads; `operator()`. Methods 3 and 4 are specific for **`TList`**. Methods 2, 3 and 4 can also easily iterate backwards using either a; backward **`TIter`** (using argument `kIterBackward`) or by using; `LastLink()` and `lnk>Prev`() or by using the `Before()` method. ## The TObjArray Collection. A **`TObjArray`** is a collection which supports traditional array; semantics via the overloading of `operator[]`. Objects can be directly; accessed via an index. The array expands automatically when objects are; added. At creation time one specifies the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:14041,wrap,wrap,14041,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['wrap'],['wrap']
Integrability,"ed or centered text was not correctly positioned when rotated. TASImage. The text size adjustment applied TASImage::DrawText; was not valid (scale factor of 1.044). The text size was wrong and the; following macro produced a wrong title when ran in batch:; ; {; TCanvas *canvas = new TCanvas(""c5"",""c5"",900,900);; TH1F *histo = new TH1F(""Histo"",""123456x_{i}abcdefy^{2}"",100,0,20);; canvas->Print(""drawing.gif"");; }; ; Suppress annoying messages like:; ; root : looking for image ""filename"" in path [/home/username/icons]; ; printed by libAfterImage when using TImage::Open(""filename""); In TImageDump the hollow filled areas were not correct:; ; they used the line attributes,; a line was drawn around the polygons filled with patterns. This fixes the problem mentionned here:; https://savannah.cern.ch/bugs/index.php?59263; as well as the test #22 in stressGraphics (no need to change; the reference file). Interface to graphviz. Thanks to three new classes (TGraphStruct, TGraphNode and; TGraphEdge) ROOT provides; an interface to the graphs visualization package graphviz. Graph; visualization is a way of representing structural information as diagrams of; abstract graphs and networks. Example:. The previous image is produced by the following ROOT macro:; ; // Draw a simple graph structure.; // The graph layout is made using graphviz. This macro creates some; // nodes and edges and change a few graphical attributes on some of them.; // Author: Olivier Couet; {; TGraphStruct *gs = new TGraphStruct();. // create some nodes and put them in the graph in one go ...; TGraphNode *n0 = gs->AddNode(""n0"",""Node 0"");; TGraphNode *n1 = gs->AddNode(""n1"",""First node"");; TGraphNode *n2 = gs->AddNode(""n2"",""Second node"");; TGraphNode *n3 = gs->AddNode(""n3"",""Third node"");; TGraphNode *n4 = gs->AddNode(""n4"",""Fourth node"");; TGraphNode *n5 = gs->AddNode(""n5"",""5th node"");; TGraphNode *n6 = gs->AddNode(""n6"",""Node number six"");; TGraphNode *n7 = gs->AddNode(""n7"",""Node 7"");; TGraphNode *n8 = gs->AddNode(""n8",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html:1543,interface,interface,1543,graf2d/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html,1,['interface'],['interface']
Integrability,"ed size array. For example:. #pragma read sourceClass = ""ACache"" targetClass = ""ACache"" version = ""[8]"" \; source = ""Int_t *fArray; Int_t fN;"" \; target = ""fArray"" \; code = ""{ fArray = new Char_t[onfile.fN]; Char_t* gtc=fArray; Int_t* gti=onfile.fArray; \; for(Int_t i=0; i<onfile.fN; i++) *(gtc+i) = *(gti+i)+10; }""; #pragma read sourceClass = ""ACache"" targetClass = ""ACache"" version = ""[8]"" \; source = ""float fValues[3]"" \; target = ""fValues"" \; code = ""{ for(Int_t i=0; i<3; i++) fValues[i] = 1+onfile.fValues[i]; }"". Allow the seamless schema evolution from map<a,b> to vector<pair<a,b> >.; Avoid dropping information when reading a long written on a 64 bits platforms; and being read into a long long on a 32 bits platform (previously the higher; bits were lost due to passing through a 32 bits temporary long).; Migrate the functionality of TStreamerInfo::TagFile to a new interface TBuffer::TagStreamerInfo; so that TMessage can customize the behavior. TMessage now relies on this new interface; instead of TBuffer::IncrementLevel.; New option to hadd, -O requesting the (re)optimization of the basket size (by avoid the fast merge technique). The equivalent in TFileMerger is to call; merger->SetFastMethod(kFALSE); To make sure that the class emulation layer of ROOT does not double delete an object,; tell the StreamerElement representing one of the pointers pointing to the object; to never delete the object. For example:. TClass::AddRule(""HepMC::GenVertex m_event attributes=NotOwner"");. The handling of memory by the collection proxy has been improved in the case of a; collection of pointers which can now become owner of its content. The default, for backward compatibility reasons and to avoid double delete (at the expense; of memory leaks), the container of pointers are still not owning their content; unless they are a free standing container (i.e. itself not contained in another; object).; To make a container of pointers become owner of its content do something like:. TClass",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html:10831,interface,interface,10831,io/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html,1,['interface'],['interface']
Integrability,"ed to be atomic in the sense that if you use; unordered loads and unordered stores, a load cannot see a value which was; never stored. A normal load or store instruction is usually sufficient, but; note that an unordered load or store cannot be split into multiple; instructions (or an instruction which does multiple memory operations, like; ``LDRD`` on ARM without LPAE, or not naturally-aligned ``LDRD`` on LPAE ARM). Monotonic; ---------. Monotonic is the weakest level of atomicity that can be used in synchronization; primitives, although it does not provide any general synchronization. It; essentially guarantees that if you take all the operations affecting a specific; address, a consistent ordering exists. Relevant standard; This corresponds to the C++/C ``memory_order_relaxed``; see those; standards for the exact definition. Notes for frontends; If you are writing a frontend which uses this directly, use with caution. The; guarantees in terms of synchronization are very weak, so make sure these are; only used in a pattern which you know is correct. Generally, these would; either be used for atomic operations which do not protect other memory (like; an atomic counter), or along with a ``fence``. Notes for optimizers; In terms of the optimizer, this can be treated as a read+write on the relevant; memory location (and alias analysis will take advantage of that). In addition,; it is legal to reorder non-atomic and Unordered loads around Monotonic; loads. CSE/DSE and a few other optimizations are allowed, but Monotonic; operations are unlikely to be used in ways which would make those; optimizations useful. Notes for code generation; Code generation is essentially the same as that for unordered for loads and; stores. No fences are required. ``cmpxchg`` and ``atomicrmw`` are required; to appear as a single operation. Acquire; -------. Acquire provides a barrier of the sort necessary to acquire a lock to access; other memory with normal loads and stores. Relevant standar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:10569,synchroniz,synchronization,10569,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['synchroniz'],['synchronization']
Integrability,"ed to know this convention, since we are given the name of the ivar; directly. Also, it is common practice in ObjC to have different property declarations in; the @interface and @implementation - e.g. to provide a read-only property in; the interface, and a read-write interface in the implementation. In that case,; the compiler should emit whichever property declaration will be in force in the; current translation unit. Developers can decorate a property with attributes which are encoded using; ``DW_AT_APPLE_property_attribute``. .. code-block:: objc. @property (readonly, nonatomic) int pr;. .. code-block:: none. TAG_APPLE_property [8]; AT_name( ""pr"" ); AT_type ( {0x00000147} (int) ); AT_APPLE_property_attribute (DW_APPLE_PROPERTY_readonly, DW_APPLE_PROPERTY_nonatomic). The setter and getter method names are attached to the property using; ``DW_AT_APPLE_property_setter`` and ``DW_AT_APPLE_property_getter`` attributes. .. code-block:: objc. @interface I1; @property (setter=myOwnP3Setter:) int p3;; -(void)myOwnP3Setter:(int)a;; @end. @implementation I1; @synthesize p3;; -(void)myOwnP3Setter:(int)a{ }; @end. The DWARF for this would be:. .. code-block:: none. 0x000003bd: TAG_structure_type [7] *; AT_APPLE_runtime_class( 0x10 ); AT_name( ""I1"" ); AT_decl_file( ""Objc_Property.m"" ); AT_decl_line( 3 ). 0x000003cd TAG_APPLE_property; AT_name ( ""p3"" ); AT_APPLE_property_setter ( ""myOwnP3Setter:"" ); AT_type( {0x00000147} ( int ) ). 0x000003f3: TAG_member [8]; AT_name( ""_p3"" ); AT_type ( {0x00000147} ( int ) ); AT_APPLE_property ( {0x000003cd} ); AT_artificial ( 0x1 ). New DWARF Tags; ^^^^^^^^^^^^^^. +-----------------------+--------+; | TAG | Value |; +=======================+========+; | DW_TAG_APPLE_property | 0x4200 |; +-----------------------+--------+. New DWARF Attributes; ^^^^^^^^^^^^^^^^^^^^. +--------------------------------+--------+-----------+; | Attribute | Value | Classes |; +================================+========+===========+; | DW_AT_APPLE_property | 0x3fed ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:53477,interface,interface,53477,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['interface'],['interface']
Integrability,"ed to the canvas. To open the editor in a separate frame one; should provide a non-empty string as option to the `Edit()` method. \image html geometry018.png ""The geometry manager editor"". \anchor GP08b; ### The Geometry Manager Editor. \image html geometry019.png ""Accessing/creating different categories of editable objects"" width=600px. The second use case applies when starting to edit an existing geometry.; Supposing the geometry was loaded into memory, besides the first method; that still applies one can also edit drawn geometry objects. For this,; the menu entry View/Editor of the canvas containing for instance a drawn; volume must be activated. For starting the volume editor one can click; on a volume. The GUI of the TGeoManager class can be started by; clicking on the top-right `40x40` pixels corner of the pad with a drawn; geometry. This is the main entry point for editing the geometry or creating new; objects. Once the interface is created (using one of the methods; described above), several categories can be accessed via a shutter GUI; widget:. - *General.* This allows changing the name/title of the geometry,; setting the top volume, closing the geometry and saving the geometry; in a file. The file name is formed by `geometry_name.C` or `.root`; depending if the geometry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of proper",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:127921,interface,interface,127921,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['interface'],['interface']
Integrability,"ed whenever the option is; invoked, passing in the option itself, the option name, the string to parse, and; a reference to a return value. If the string to parse is not well-formed, the; parser should output an error message and return true. Otherwise it should; return false and set '``Val``' to the parsed value. In our example, we; implement ``parse`` as:. .. code-block:: c++. bool FileSizeParser::parse(cl::Option &O, StringRef ArgName,; const std::string &Arg, unsigned &Val) {; const char *ArgStart = Arg.c_str();; char *End;. // Parse integer part, leaving 'End' pointing to the first non-integer char; Val = (unsigned)strtol(ArgStart, &End, 0);. while (1) {; switch (*End++) {; case 0: return false; // No error; case 'i': // Ignore the 'i' in KiB if people use that; case 'b': case 'B': // Ignore B suffix; break;. case 'g': case 'G': Val *= 1024*1024*1024; break;; case 'm': case 'M': Val *= 1024*1024; break;; case 'k': case 'K': Val *= 1024; break;. default:; // Print an error message if unrecognized character!; return O.error(""'"" + Arg + ""' value invalid for file size argument!"");; }; }; }. This function implements a very simple parser for the kinds of strings we are; interested in. Although it has some holes (it allows ""``123KKK``"" for example),; it is good enough for this example. Note that we use the option itself to print; out the error message (the ``error`` method always returns true) in order to get; a nice error message (shown below). Now that we have our parser class, we can; use it like this:. .. code-block:: c++. static cl::opt<unsigned, false, FileSizeParser>; MFS(""max-file-size"", cl::desc(""Maximum file size to accept""),; cl::value_desc(""size""));. Which adds this to the output of our program:. ::. OPTIONS:; -help - display available options (-help-hidden for more); ...; -max-file-size=<size> - Maximum file size to accept. And we can test that our parse works correctly now (the test program just prints; out the max-file-size argument value):. ::. $ ./tes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:65060,message,message,65060,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['message'],['message']
Integrability,"ed within a declaration context; (either for iteration or for name lookup). ``ExternalSemaSource``; This abstract interface is associated with the ``Sema`` class, and is used; whenever semantic analysis needs to read information from the :ref:`global; method pool <pchinternals-method-pool>`. .. _pchinternals-chained:. Chained precompiled headers; ---------------------------. Chained precompiled headers were initially intended to improve the performance; of IDE-centric operations such as syntax highlighting and code completion while; a particular source file is being edited by the user. To minimize the amount; of reparsing required after a change to the file, a form of precompiled header; --- called a precompiled *preamble* --- is automatically generated by parsing; all of the headers in the source file, up to and including the last; ``#include``. When only the source file changes (and none of the headers it; depends on), reparsing of that source file can use the precompiled preamble and; start parsing after the ``#include``\ s, so parsing time is proportional to the; size of the source file (rather than all of its includes). However, the; compilation of that translation unit may already use a precompiled header: in; this case, Clang will create the precompiled preamble as a chained precompiled; header that refers to the original precompiled header. This drastically; reduces the time needed to serialize the precompiled preamble for use in; reparsing. Chained precompiled headers get their name because each precompiled header can; depend on one other precompiled header, forming a chain of dependencies. A; translation unit will then include the precompiled header that starts the chain; (i.e., nothing depends on it). This linearity of dependencies is important for; the semantic model of chained precompiled headers, because the most-recent; precompiled header can provide information that overrides the information; provided by the precompiled headers it depends on, just li",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:24125,depend,depends,24125,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['depend'],['depends']
Integrability,"ed, execute:; ; $ analyze-build --ctu. For CTU analysis an additional (external definition) collection-phase is required. ; For debugging purposes, it is possible to separately execute the collection ; and the analysis phase. By doing this, the intermediate files used for ; the analysis are kept on the disk in `./ctu-dir`.; ; # Collect and store the data required by the CTU analysis; $ analyze-build --ctu-collect-only; ; # Analyze using the previously collected data; $ analyze-build --ctu-analyze-only. Use `--help` to get more information about the commands. Limitations; -----------. Generally speaking, the `intercept-build` and `analyze-build` tools together; does the same job as `scan-build` does. So, you can expect the same output; from this line as simple `scan-build` would do:. $ intercept-build <your build command> && analyze-build. The major difference is how and when the analyzer is run. The `scan-build`; tool has three distinct model to run the analyzer:. 1. Use compiler wrappers to make actions.; The compiler wrappers does run the real compiler and the analyzer.; This is the default behaviour, can be enforced with `--override-compiler`; flag. 2. Use special library to intercept compiler calls during the build process.; The analyzer run against each modules after the build finished.; Use `--intercept-first` flag to get this model. 3. Use compiler wrappers to intercept compiler calls during the build process.; The analyzer run against each modules after the build finished.; Use `--intercept-first` and `--override-compiler` flags together to get; this model. The 1. and 3. are using compiler wrappers, which works only if the build; process respects the `CC` and `CXX` environment variables. (Some build; process can override these variable as command line parameter only. This case; you need to pass the compiler wrappers manually. eg.: `intercept-build; --override-compiler make CC=intercept-cc CXX=intercept-c++ all` where the; original build command would have bee",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/README.md:2303,wrap,wrappers,2303,interpreter/llvm-project/clang/tools/scan-build-py/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/README.md,1,['wrap'],['wrappers']
Integrability,ed. 1677; C++17; Constant initialization via aggregate initialization; Unknown. 1678; NAD; Naming the type of an array of runtime bound; Unknown. 1679; NAD; Range-based for and array of runtime bound; Unknown. 1680; drafting; Including <initializer_list> for range-based for; Not resolved. 1681; C++14; init-captures and nested lambdas; Unknown. 1682; open; Overly-restrictive rules on function templates as allocation functions; Not resolved. 1683; CD4; Incorrect example after constexpr changes; Unknown. 1684; C++14; Static constexpr member functions for non-literal classes; Clang 3.6. 1685; NAD; Value category of noexcept expression; Unknown. 1686; CD4; Which variables are “explicitly declared const?”; Unknown. 1687; C++14; Conversions of operands of built-in operators; Clang 7. 1688; NAD; Volatile constexpr variables; Unknown. 1689; C++14; Syntactic nonterminal for operand of alignas; Unknown. 1690; C++14; Associated namespace for local type; Clang 9. 1691; C++14; Argument-dependent lookup and opaque enumerations; Clang 9. 1692; C++14; Associated namespaces of doubly-nested classes; Clang 9. 1693; C++14; Superfluous semicolons in class definitions; Unknown. 1694; CD4; Restriction on reference to temporary as a constant expression; Unknown. 1695; NAD; Lifetime extension via init-capture; Unknown. 1696; CD4; Temporary lifetime and non-static data member initializers; Clang 7. 1697; CD4; Lifetime extension and copy elision; Unknown. 1698; DR; Files ending in \; Unknown. 1699; open; Does befriending a class befriend its friends?; Not resolved. 1700; NAD; Does the special rvalue-reference deduction apply to alias templates?; Unknown. 1701; drafting; Array vs sequence in object representation; Not resolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703; NAD; Language linkage of names of functions with internal linkage; Unknown. 1704; CD5; Type checking in explicit instantiation of variable templates; Unknown. 1705; CD4; Unclear specifica,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:114417,depend,dependent,114417,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"edEvent(Int_t,Int_t,Int_t,TObject*)"",; ""MyClass"", this, ""HandleMyCanvas(Int_t,Int_t,Int_t,TObject*)"");; ```. ![](pictures/03000221.png). To embed a canvas derived from a **`TCanvas`** do the following:. ``` {.cpp}; TRootEmbeddedCanvas *embed = new TRootEmbeddedCanvas(0, p, w, h);; // note name must be 0, not null string """"; Int_t wid = embed->GetCanvasWindowId();; TCanvas *myc = new TCanvas(""myname"",10,10,wid);; embed->AdoptCanvas(myc);; // the TCanvas is adopted by the embedded canvas and will be; // destroyed by it; ```. ## The ROOT Graphics Editor (GED). Everything drawn in a ROOT canvas is an object. There are classes for; all objects, and they fall into hierarchies. In addition, the ROOT has; fully cross-platform GUI classes and provides all standard components; for an application environment with common ‘look and feel'. The; object-oriented, event-driven programming model supports the modern; signals/slots communication mechanism. It handles user interface actions; and allows total independence of interacting objects and classes. This; mechanism uses the ROOT dictionary information and the Cling the C++; Interpreter to connect signals to slots methods. Therefore, all necessary elements for an object-oriented editor design; are in place. The editor complexity can be reduced by splitting it into; discrete units of so-called *`object`* *`editors`*. Any object editor; provides an object specific GUI. The main purpose of the ROOT graphics; editor is the organization of the object editors' appearance and the; task sequence between them. ### Object Editors. Every object editor follows a simple naming convention: to have as a; name the object class name concatenated with ‘*`Editor`*' (e.g. for; **`TGraph`** objects the object editor is **`TGraphEditor`**). Thanks to; the signals/slots communication mechanism and to the method; `DistancetoPrimitive()` that computes a ‘‘distance'' to an object from; the mouse position, it was possible to implement a signal method of the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:101566,interface,interface,101566,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['interface'],['interface']
Integrability,"ediated by the free and reallocation. As an exception to this is with the :ref:`noalias <noalias>` keyword;; the ""irrelevant"" dependencies are ignored. The ``MayAlias`` response is used whenever the two pointers might refer to the; same object. The ``PartialAlias`` response is used when the two memory objects are known to; be overlapping in some way, regardless whether they start at the same address; or not. The ``MustAlias`` response may only be returned if the two memory objects are; guaranteed to always start at exactly the same location. A ``MustAlias``; response does not imply that the pointers compare equal. The ``getModRefInfo`` methods; -----------------------------. The ``getModRefInfo`` methods return information about whether the execution of; an instruction can read or modify a memory location. Mod/Ref information is; always conservative: if an instruction **might** read or write a location,; ``ModRef`` is returned. The ``AliasAnalysis`` class also provides a ``getModRefInfo`` method for testing; dependencies between function calls. This method takes two call sites (``CS1``; & ``CS2``), returns ``NoModRef`` if neither call writes to memory read or; written by the other, ``Ref`` if ``CS1`` reads memory written by ``CS2``,; ``Mod`` if ``CS1`` writes to memory read or written by ``CS2``, or ``ModRef`` if; ``CS1`` might read or write memory written to by ``CS2``. Note that this; relation is not commutative. Other useful ``AliasAnalysis`` methods; --------------------------------------. Several other tidbits of information are often collected by various alias; analysis implementations and can be put to good use by various clients. The ``getModRefInfoMask`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``getModRefInfoMask`` method returns a bound on Mod/Ref information for; the supplied pointer, based on knowledge about whether the pointer points to; globally-constant memory (for which it returns ``NoModRef``) or; locally-invariant memory (for which it returns ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:6349,depend,dependencies,6349,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['depend'],['dependencies']
Integrability,"eds to be able to search; # for python modules.; find_package(Python3 ${LLVM_MINIMUM_PYTHON_VERSION} REQUIRED; COMPONENTS Interpreter). # All options referred to from HandleLLVMOptions have to be specified; # BEFORE this include, otherwise options will not be correctly set on; # first cmake run; include(config-ix). # By default, we target the host, but this can be overridden at CMake; # invocation time. Except on 64-bit AIX, where the system toolchain; # expect 32-bit objects by default.; if(""${LLVM_HOST_TRIPLE}"" MATCHES ""^powerpc64-ibm-aix""); string(REGEX REPLACE ""^powerpc64"" ""powerpc"" LLVM_DEFAULT_TARGET_TRIPLE_DEFAULT ""${LLVM_HOST_TRIPLE}""); else(); # Only set default triple when native target is enabled.; if (LLVM_NATIVE_TARGET); set(LLVM_DEFAULT_TARGET_TRIPLE_DEFAULT ""${LLVM_HOST_TRIPLE}""); endif(); endif(). set(LLVM_DEFAULT_TARGET_TRIPLE ""${LLVM_DEFAULT_TARGET_TRIPLE_DEFAULT}"" CACHE STRING; ""Default target for which LLVM will generate code."" ); message(STATUS ""LLVM default target triple: ${LLVM_DEFAULT_TARGET_TRIPLE}""). set(LLVM_TARGET_TRIPLE ""${LLVM_DEFAULT_TARGET_TRIPLE}""). if(WIN32 OR CYGWIN); if(BUILD_SHARED_LIBS OR LLVM_BUILD_LLVM_DYLIB); set(LLVM_ENABLE_PLUGINS_default ON); else(); set(LLVM_ENABLE_PLUGINS_default OFF); endif(); else(); set(LLVM_ENABLE_PLUGINS_default ${LLVM_ENABLE_PIC}); endif(); option(LLVM_ENABLE_PLUGINS ""Enable plugin support"" ${LLVM_ENABLE_PLUGINS_default}). set(LLVM_ENABLE_NEW_PASS_MANAGER TRUE CACHE BOOL; ""Enable the new pass manager by default.""); if(NOT LLVM_ENABLE_NEW_PASS_MANAGER); message(FATAL_ERROR ""Enabling the legacy pass manager on the cmake level is""; "" no longer supported.""); endif(). include(HandleLLVMOptions). ######. # Configure all of the various header file fragments LLVM uses which depend on; # configuration variables.; set(LLVM_ENUM_TARGETS """"); set(LLVM_ENUM_ASM_PRINTERS """"); set(LLVM_ENUM_ASM_PARSERS """"); set(LLVM_ENUM_DISASSEMBLERS """"); set(LLVM_ENUM_TARGETMCAS """"); set(LLVM_ENUM_EXEGESIS """"); foreach(t ${LLVM_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:38568,message,message,38568,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"eds to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used whenever the program source refers to an identifier that has not yet; been seen. In this case, the AST reader searches for this identifier within; its :ref:`identifier table <pchinternals-ident-table>` to load any top-level; declarations or macros associated with that identifier. ``ExternalASTSource``; This abstract interface is associated with the ``ASTContext`` class, and is; used whenever the abstract syntax tree nodes need to loaded from the AST; file. It provides the ability to de-serialize declarations and types; identified by their numeric values, read the bodies of functions when; required, and read the declarations stored within a declaration context; (either for iteration or for name lookup). ``ExternalSemaSource``; This abstract interface is associated with the ``Sema`` class, and is used; whenever semantic analysis needs to read information from the :ref:`global; method pool <pchinternals-method-pool>`. .. _pchinternals-chained:. Chained precompiled headers; ---------------------------. Chained precompiled headers were initially intended to improve the performance; of IDE-centric operations such as syntax highlighting and code completion while; a particular source file is being edited by the user. To minimize the amount; of reparsing required after a change to the file, a form of precompiled header; --- called a precompiled *preamble* --- is automatically generated by parsing; all of the headers in the source file, up to and including the last; ``#include``. When only the source file changes (and none of the headers it; depends on), reparsing of that source file can use the precompiled preamble and; start parsing after the ``#include``\ s, so parsing time is proportional to the; size of the source file (rather than all of its includes). However, the; compilation of that transla",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:23317,interface,interface,23317,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['interface'],['interface']
Integrability,"eds_implicit; | | `-CXXRecordDecl 0xe91270 <col:7, col:14> col:14 implicit struct X; | `-ClassTemplateSpecialization 0xe91340 'X'; `-ClassTemplateSpecializationDecl 0xe91340 <line:6:7, line:7:30> col:14 struct X definition; |-DefinitionData pass_in_registers aggregate standard_layout trivially_copyable pod trivial literal; | |-DefaultConstructor exists trivial needs_implicit; | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveConstructor exists simple trivial needs_implicit; | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param; | |-MoveAssignment exists simple trivial needs_implicit; | `-Destructor simple irrelevant trivial needs_implicit; |-TemplateArgument type 'int'; |-CXXRecordDecl 0xe91558 <col:7, col:14> col:14 implicit struct X; `-FieldDecl 0xe91600 <col:23, col:27> col:27 i 'int'. Error propagation; """""""""""""""""""""""""""""""""". If there is a dependent node we have to import before we could import a given node then the import error associated to the dependency propagates to the dependant node.; Let's modify the previous example and import a ``FieldDecl`` instead of the ``ClassTemplateSpecializationDecl``. .. code-block:: cpp. auto Matcher = fieldDecl(hasName(""i2""));; auto *From = getFirstDecl<FieldDecl>(Matcher, FromUnit);. In this case we can see that an error is associated (``getImportDeclErrorIfAny``) to the specialization also, not just to the field:. .. code-block:: cpp. llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // check that the ClassTemplateSpecializationDecl is also marked as; // erroneous.; auto *FromSpec = getFirstDecl<ClassTemplateSpecializationDecl>(; classTemplateSpecializationDecl(hasName(""X"")), FromUnit);; assert(Importer.getImportDeclErrorIfAny(FromSpec));; // Btw, the error is also set for the FieldDecl.; assert(Importer.getImportDeclErrorIfAny(From));; re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:15276,depend,dependent,15276,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,3,['depend'],"['dependant', 'dependency', 'dependent']"
Integrability,"eed these bitcasts.; * The ``CodeGenFunction`` class has a number of helper functions to make; certain operations easy, such as generating code to produce an lvalue or; an rvalue, or to initialize a memory location with a given value. Prefer; to use these functions rather than directly writing loads and stores,; because these functions take care of some of the tricky details for you; (e.g., for exceptions).; * If your expression requires some special behavior in the event of an; exception, look at the ``push*Cleanup`` functions in ``CodeGenFunction``; to introduce a cleanup. You shouldn't have to deal with; exception-handling directly.; * Testing is extremely important in IR generation. Use ``clang -cc1; -emit-llvm`` and `FileCheck; <https://llvm.org/docs/CommandGuide/FileCheck.html>`_ to verify that you're; generating the right IR. #. Teach template instantiation how to cope with your AST node, which requires; some fairly simple code:. * Make sure that your expression's constructor properly computes the flags; for type dependence (i.e., the type your expression produces can change; from one instantiation to the next), value dependence (i.e., the constant; value your expression produces can change from one instantiation to the; next), instantiation dependence (i.e., a template parameter occurs; anywhere in your expression), and whether your expression contains a; parameter pack (for variadic templates). Often, computing these flags; just means combining the results from the various types and; subexpressions.; * Add ``TransformXXX`` and ``RebuildXXX`` functions to the ``TreeTransform``; class template in ``Sema``. ``TransformXXX`` should (recursively); transform all of the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your express",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:152507,depend,dependence,152507,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['dependence']
Integrability,"een-space derivatives of the coordinates to determine the level of; detail (mipmap level) of the sample. They are commonly approximated by taking; the difference between neighboring pixels, which are computed by different; threads in the same group:. .. code-block:: c++. void example_shader() {; ...; color = textureSample(texture, coordinates);; if (condition) {; use(color);; }; ...; }. From a purely single-threaded perspective, sinking the `textureSample` into; the if-statement appears legal. However, if the condition is false for some; neighboring pixels, then their corresponding threads will not execute together; in the group, making it impossible to take the difference of coordinates as an; approximation of the screen-space derivative. In practice, the outcome will be; an undefined value. That is, the `textureSample` operation fits our definition of a convergent; operation:. 1. It communicates with a set of threads that implicitly depends on control; flow.; 2. Correctness depends on this set of threads. The compiler frontend can emit IR that expresses the convergence constraints as; follows:. .. code-block:: llvm. define void @example_shader() convergent {; %entry = call token @llvm.experimental.convergence.entry(); ...; %color = call T @textureSample(U %texture, V %coordinates) [ ""convergencectrl""(token %entry) ]; br i1 %condition, label %then, label %end. then:; call void @use(T %color); br label %end. end:; ret void; }. The :ref:`llvm.experimental.convergence.entry <llvm.experimental.convergence.entry>`; intrinsic is itself ``convergent``, and we expect it to communicate at least; among all threads of the same ""quad"" -- a group of 2x2 pixels that are; evaluated together for the purpose of approximating screen-space derivatives.; This fact is not part of the generic LLVM IR semantics; it would have to be; defined somewhere else, for example as part of target-specific ABI definitions; and/or in reference to some relevant API specs. Since the ``@textureSample`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:4839,depend,depends,4839,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['depend'],['depends']
Integrability,"efining very small bits of functionality; only. The other difference between CMake functions and macros is how arguments are; passed. Arguments to macros are not set as variables, instead dereferences to; the parameters are resolved across the macro before executing it. This can; result in some unexpected behavior if using unreferenced variables. For example:. .. code-block:: cmake. macro(print_list my_list); foreach(var IN LISTS my_list); message(""${var}""); endforeach(); endmacro(). set(my_list a b c d); set(my_list_of_numbers 1 2 3 4); print_list(my_list_of_numbers); # prints:; # a; # b; # c; # d. Generally speaking this issue is uncommon because it requires using; non-dereferenced variables with names that overlap in the parent scope, but it; is important to be aware of because it can lead to subtle bugs. LLVM Project Wrappers; =====================. LLVM projects provide lots of wrappers around critical CMake built-in commands.; We use these wrappers to provide consistent behaviors across LLVM components; and to reduce code duplication. We generally (but not always) follow the convention that commands prefaced with; ``llvm_`` are intended to be used only as building blocks for other commands.; Wrapper commands that are intended for direct use are generally named following; with the project in the middle of the command name (i.e. ``add_llvm_executable``; is the wrapper for ``add_executable``). The LLVM ``add_*`` wrapper functions are; all defined in ``AddLLVM.cmake`` which is installed as part of the LLVM; distribution. It can be included and used by any LLVM sub-project that requires; LLVM. .. note::. Not all LLVM projects require LLVM for all use cases. For example compiler-rt; can be built without LLVM, and the compiler-rt sanitizer libraries are used; with GCC. Useful Built-in Commands; ========================. CMake has a bunch of useful built-in commands. This document isn't going to; go into details about them because The CMake project has excellent; docum",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:13225,wrap,wrappers,13225,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['wrap'],['wrappers']
Integrability,"efinitions(-DCLANG_REPOSITORY_STRING=""${CLANG_REPOSITORY_STRING}""); endif(). set(CLANG_VENDOR_UTI ""org.llvm.clang"" CACHE STRING; ""Vendor-specific uti.""). set(CLANG_PYTHON_BINDINGS_VERSIONS """" CACHE STRING; ""Python versions to install libclang python bindings for""). set(CLANG_LINK_CLANG_DYLIB ${LLVM_LINK_LLVM_DYLIB} CACHE BOOL; ""Link tools against libclang-cpp.so""). if (NOT LLVM_LINK_LLVM_DYLIB AND CLANG_LINK_CLANG_DYLIB); message(FATAL_ERROR ""Cannot set CLANG_LINK_CLANG_DYLIB=ON when ""; ""LLVM_LINK_LLVM_DYLIB=OFF""); endif(). # The libdir suffix must exactly match whatever LLVM's configuration used.; set(CLANG_LIBDIR_SUFFIX ""${LLVM_LIBDIR_SUFFIX}""). set(CLANG_TOOLS_INSTALL_DIR ""${CMAKE_INSTALL_BINDIR}"" CACHE PATH; ""Path for binary subdirectory (defaults to '${CMAKE_INSTALL_BINDIR}')""); mark_as_advanced(CLANG_TOOLS_INSTALL_DIR). set(CLANG_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}); set(CLANG_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}). if( CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR AND NOT MSVC_IDE ); message(FATAL_ERROR ""In-source builds are not allowed. ""; ""Please create a directory and run cmake ""; ""from there, passing the path to this source directory as the last argument. ""; ""This process created the file `CMakeCache.txt' and the directory ""; ""`CMakeFiles'. Please delete them.""); endif(). # If CLANG_VERSION_* is specified, use it, if not use LLVM_VERSION_*.; if(NOT DEFINED CLANG_VERSION_MAJOR); set(CLANG_VERSION_MAJOR ${LLVM_VERSION_MAJOR}); endif(); if(NOT DEFINED CLANG_VERSION_MINOR); set(CLANG_VERSION_MINOR ${LLVM_VERSION_MINOR}); endif(); if(NOT DEFINED CLANG_VERSION_PATCHLEVEL); set(CLANG_VERSION_PATCHLEVEL ${LLVM_VERSION_PATCH}); endif(); if(NOT DEFINED CLANG_VERSION_SUFFIX); set(CLANG_VERSION_SUFFIX ${LLVM_VERSION_SUFFIX}); endif(); set(CLANG_VERSION ""${CLANG_VERSION_MAJOR}.${CLANG_VERSION_MINOR}.${CLANG_VERSION_PATCHLEVEL}${CLANG_VERSION_SUFFIX}""); message(STATUS ""Clang version: ${CLANG_VERSION}""). # Configure the Version.inc file.; configure_file(; ${CMAKE_CURRE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:11064,message,message,11064,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['message'],['message']
Integrability,"efore setting the various objects.; . General Improvements. ModelConfig is now used extensively by the calculator tools. It encapsulates the configuration of a model to define a particular hypothesis.; ProfileLikelihood::GetInterval now returns LikleihoodInterval in the interface to avoid unnecessary casting; FeldmanCousins::GetInterval now returns PointSetInterval in the interface to avoid unnecessary casting. Profile Likelihood . When running ProfileLikelihoodCalculator::GetHypoTest; the user does not need anymore to clone the null parameter set. It; is done now inside the calculator; LikelihoodInterval::LowerLimit (and UpperLimit); returns now a boolean flag with the status of the limit search.; In case of a failure in finding the upper/lower limit a value of; zero is returned instead of the min/max of the variable range; LikelihoodIntervalPlot fix drawing of horizontal green; line when limits are outside the variable range . HybridCalculator. New re-written class based on the TestStatSampler and; TestStatistic interfaces. The new class is designed to provide; consistent use of a ModelConfig, specifying the Pdf and Prior. ; The old class remains, but with a new name: HybridCalculatorOriginal. ; The tutorial rs201b_hybridcalculator shows the usage of; the new class.; Note that the new class can be constructed only from a; ModelConfig; One can specify a TestStatSampler in the constructor (which implies a choice of a TestStatistic, or by default the tool will use the ToyMCSampler and the RatioOfProfiledLikelihoods; The interface of the new HybridCalculator class is now more uniform with the other calculator tools, which is different from the original; HybridCalculator's interface. Users wishing to run their old macro are advised to use ModelConfig, but if that is too time consuming one can just change the; name of the class from HybridCalculator to; HybridCalculatorOriginal; Note also that with the new class no HybridResult is; returned but directly the base class Hy",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html:4543,interface,interfaces,4543,roofit/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html,1,['interface'],['interfaces']
Integrability,"eful LLVM APIs; ==============================. Here we highlight some LLVM APIs that are generally useful and good to know; about when writing transformations. .. _isa:. The ``isa<>``, ``cast<>`` and ``dyn_cast<>`` templates; ------------------------------------------------------. The LLVM source-base makes extensive use of a custom form of RTTI. These; templates have many similarities to the C++ ``dynamic_cast<>`` operator, but; they don't have some drawbacks (primarily stemming from the fact that; ``dynamic_cast<>`` only works on classes that have a v-table). Because they are; used so often, you must know what they do and how they work. All of these; templates are defined in the ``llvm/Support/Casting.h`` (`doxygen; <https://llvm.org/doxygen/Casting_8h_source.html>`__) file (note that you very; rarely have to include this file directly). ``isa<>``:; The ``isa<>`` operator works exactly like the Java ""``instanceof``"" operator.; It returns true or false depending on whether a reference or pointer points to; an instance of the specified class. This can be very useful for constraint; checking of various sorts (example below). ``cast<>``:; The ``cast<>`` operator is a ""checked cast"" operation. It converts a pointer; or reference from a base class to a derived class, causing an assertion; failure if it is not really an instance of the right type. This should be; used in cases where you have some information that makes you believe that; something is of the right type. An example of the ``isa<>`` and ``cast<>``; template is:. .. code-block:: c++. static bool isLoopInvariant(const Value *V, const Loop *L) {; if (isa<Constant>(V) || isa<Argument>(V) || isa<GlobalValue>(V)); return true;. // Otherwise, it must be an instruction...; return !L->contains(cast<Instruction>(V)->getParent());; }. Note that you should **not** use an ``isa<>`` test followed by a ``cast<>``,; for that use the ``dyn_cast<>`` operator. ``dyn_cast<>``:; The ``dyn_cast<>`` operator is a ""checking cast"" o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:4353,depend,depending,4353,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['depend'],['depending']
Integrability,"egisters, instrument comments can; be used to specify these values. InstrumentManager's main function is `getSchedClassID()` which has access; to the MCInst and all of the instruments that are active for that MCInst.; This function can use the instruments to override the schedule class of; the MCInst. On RISCV, instrument comments containing LMUL information are used; by `getSchedClassID()` to map a vector instruction and the active; LMUL to the scheduling class of the pseudo-instruction that describes; that base instruction and the active LMUL. Custom Views; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; :program:`llvm-mca` comes with several Views such as the Timeline View and; Summary View. These Views are generic and can work with most (if not all); targets. If you wish to add a new View to :program:`llvm-mca` and it does not; require any backend functionality that is not already exposed through MC layer; classes (MCSubtargetInfo, MCInstrInfo, etc.), please add it to the; `/tools/llvm-mca/View/` directory. However, if your new View is target specific; AND requires unexposed backend symbols or functionality, you can define it in; the `/lib/Target/<TargetName>/MCA/` directory. To enable this target specific View, you will have to use this target's; CustomBehaviour class to override the `CustomBehaviour::getViews()` methods.; There are 3 variations of these methods based on where you want your View to; appear in the output: `getStartViews()`, `getPostInstrInfoViews()`, and; `getEndViews()`. These methods returns a vector of Views so you will want to; return a vector containing all of the target specific Views for the target in; question. Because these target specific (and backend dependent) Views require the; `CustomBehaviour::getViews()` variants, these Views will not be enabled if; the `-disable-cb` flag is used. Enabling these custom Views does not affect the non-custom (generic) Views.; Continue to use the usual command line arguments to enable / disable those; Views.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:47854,depend,dependent,47854,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['dependent']
Integrability,"egratorMultiDim::kMISER` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kPLAIN` | `ROOT::Math:::GSLMCIntegrator` |. The control parameters for the integration algorithms can be specified using the; `ROOT::Math::IntegratorMultiDimOptions` class. Static methods are provided to change the default values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Deriv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61366,integrat,integration,61366,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integration']
Integrability,"eights, basic blocks post-dominated by a cold; function call are also considered to be cold; and, thus, given low; weight. .. _attr_convergent:. ``convergent``; This attribute indicates that this function is convergent.; When it appears on a call/invoke, the convergent attribute; indicates that we should treat the call as though we’re calling a; convergent function. This is particularly useful on indirect; calls; without this we may treat such calls as though the target; is non-convergent. See :doc:`ConvergentOperations` for further details. It is an error to call :ref:`llvm.experimental.convergence.entry; <llvm.experimental.convergence.entry>` from a function that; does not have this attribute.; ``disable_sanitizer_instrumentation``; When instrumenting code with sanitizers, it can be important to skip certain; functions to ensure no instrumentation is applied to them. This attribute is not always similar to absent ``sanitize_<name>``; attributes: depending on the specific sanitizer, code can be inserted into; functions regardless of the ``sanitize_<name>`` attribute to prevent false; positive reports. ``disable_sanitizer_instrumentation`` disables all kinds of instrumentation,; taking precedence over the ``sanitize_<name>`` attributes and other compiler; flags.; ``""dontcall-error""``; This attribute denotes that an error diagnostic should be emitted when a; call of a function with this attribute is not eliminated via optimization.; Front ends can provide optional ``srcloc`` metadata nodes on call sites of; such callees to attach information about where in the source language such a; call came from. A string value can be provided as a note.; ``""dontcall-warn""``; This attribute denotes that a warning diagnostic should be emitted when a; call of a function with this attribute is not eliminated via optimization.; Front ends can provide optional ``srcloc`` metadata nodes on call sites of; such callees to attach information about where in the source language such a; call ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:81669,depend,depending,81669,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depending']
Integrability,"eir respective types for a CallExpr or; CXXConstructExpr. It is very similar to forEachArgumentWithParam but; it works on calls through function pointers as well. The difference is, that function pointers do not provide access to a; ParmVarDecl, but only the QualType for each argument. Given; void f(int i);; int y;; f(y);; void (*f_ptr)(int) = f;; f_ptr(y);; callExpr(; forEachArgumentWithParamType(; declRefExpr(to(varDecl(hasName(""y"")))),; qualType(isInteger()).bind(""type); )); matches f(y) and f_ptr(y); with declRefExpr(...); matching int y; and qualType(...); matching int. Matcher<CXXConstructExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<CXXConstructExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<CXXConstructExpr>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:148623,interface,interface,148623,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['interface'],['interface']
Integrability,"el.; $ clang++ -std=c++20 -O3 Use.cpp -fprebuilt-module-path=.; # Inconsistent debugging level.; $ clang++ -std=c++20 -g Use.cpp -fprebuilt-module-path=. Although the two examples have inconsistent optimization and debugging level, both of them are accepted. Note that **currently** the compiler doesn't consider inconsistent macro definition a problem. For example:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; # Inconsistent optimization level.; $ clang++ -std=c++20 -O3 -DNDEBUG Use.cpp -fprebuilt-module-path=. Currently Clang would accept the above example. But it may produce surprising results if the; debugging code depends on consistent use of ``NDEBUG`` also in other translation units. Definitions consistency; ^^^^^^^^^^^^^^^^^^^^^^^. The C++ language defines that same declarations in different translation units should have; the same definition, as known as ODR (One Definition Rule). Prior to modules, the translation; units don't dependent on each other and the compiler itself can't perform a strong; ODR violation check. With the introduction of modules, now the compiler have; the chance to perform ODR violations with language semantics across translation units. However, in the practice, we found the existing ODR checking mechanism is not stable; enough. Many people suffers from the false positive ODR violation diagnostics, AKA,; the compiler are complaining two identical declarations have different definitions; incorrectly. Also the true positive ODR violations are rarely reported.; Also we learned that MSVC don't perform ODR check for declarations in the global module; fragment. So in order to get better user experience, save the time checking ODR and keep consistent; behavior with MSVC, we disabled the ODR check for the declarations in the global module; fragment by default. Users who want more strict check can still use the; ``-Xclang -fno-skip-odr-check-in-gmf`` flag to get the ODR check enabled. It is also; encouraged to repor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:17176,depend,dependent,17176,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['depend'],['dependent']
Integrability,"el; <https://discord.com/channels/636084430946959380/976196303681896538>`__.; * :ref:`IRC`. Doing this can help:; * overcome potential anxiety to call in for a first time,; * people who prefer to first exchange a few messages through text chat; before dialing in, and; * remind the wider community that office hours do exist.; * If you decide to no longer host office hours, please do remove your entry; from the list above. .. _IRC:. IRC; ---. Users and developers of the LLVM project (including subprojects such as Clang); can be found in #llvm on `irc.oftc.net <irc://irc.oftc.net/llvm>`_. The channel; is actively moderated. The #llvm-build channel has a bot for; `LLVM buildbot <http://lab.llvm.org/buildbot/#/console>`_ status changes. The; bot will post a message with a link to a build bot and a blamelist when a build; goes from passing to failing and again (without the blamelist) when the build; goes from failing back to passing. It is a good channel for actively monitoring; build statuses, but it is a noisy channel due to the automated messages. The; channel is not actively moderated. In addition to the traditional IRC there is a; `Discord <https://discord.com/channels/636084430946959380/636725486533345280>`_; chat server available. To sign up, please use this; `invitation link <https://discord.com/invite/xS7Z362>`_. .. _meetups-social-events:. Meetups and social events; -------------------------. .. toctree::; :hidden:. MeetupGuidelines. Besides developer `meetings and conferences <https://llvm.org/devmtg/>`_,; there are several user groups called; `LLVM Socials <https://www.meetup.com/pro/llvm/>`_. We greatly encourage you to; join one in your city. Or start a new one if there is none:. :doc:`MeetupGuidelines`. .. _community-proposals:. Community wide proposals; ------------------------. Proposals for massive changes in how the community behaves and how the work flow; can be better. .. toctree::; :hidden:. Proposals/GitHubMove; BugpointRedesign; Proposals/TestSuite;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst:17471,message,messages,17471,interpreter/llvm-project/llvm/docs/GettingInvolved.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingInvolved.rst,1,['message'],['messages']
Integrability,"elaboratedType() matches the type of the variable declarations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Matches injected class name types. Example matches S s, but not S<T> s.; (matcher = parmVarDecl(hasType(injectedClassNameType()))); template <typename T> struct S {; void f(S s);; void g(S<T> s);; };. Matcher<Type>lValueReferenceTypeMatcher<LValueReferenceType>...; Matches lvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. lValueReferenceType() matches the types of b, d, and e. e is; matched since the type is deduced as int& by reference collapsing rules. Matcher<Type>macroQualifiedTypeMatcher<MacroQualifiedType>...; Matches qualified types when the qualifier is applied via a macro. Given; #define CDECL __attribute__((cdecl)); typedef void (CDECL *X)();; typedef void (__attribute__((cdecl)) *Y)();; macroQualifiedType(); matches the type of the typedef declaration of X but not Y. Matcher<Type>memberPointerTypeMatcher<MemberPointerType>...; Matches member pointer types.; Given; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:48729,inject,injectedClassNameTypeMatcher,48729,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['inject'],['injectedClassNameTypeMatcher']
Integrability,"eleases.; Tying this to precise lifetime semantics is ideal, as for local variables; this requires a very explicit annotation, which allows ARC to trust the user; with good cheer. .. _arc.misc.c-retainable:. C retainable pointer types; --------------------------. A type is a :arc-term:`C retainable pointer type` if it is a pointer to; (possibly qualified) ``void`` or a pointer to a (possibly qualifier) ``struct``; or ``class`` type. .. admonition:: Rationale. ARC does not manage pointers of CoreFoundation type (or any of the related; families of retainable C pointers which interoperate with Objective-C for; retain/release operation). In fact, ARC does not even know how to; distinguish these types from arbitrary C pointer types. The intent of this; concept is to filter out some obviously non-object types while leaving a hook; for later tightening if a means of exhaustively marking CF types is made; available. .. _arc.misc.c-retainable.audit:. Auditing of C retainable pointer interfaces; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. :when-revised:`[beginning Apple 4.0, LLVM 3.1]`. A C function may be marked with the ``cf_audited_transfer`` attribute to; express that, except as otherwise marked with attributes, it obeys the; parameter (consuming vs. non-consuming) and return (retained vs. non-retained); conventions for a C function of its name, namely:. * A parameter of C retainable pointer type is assumed to not be consumed; unless it is marked with the ``cf_consumed`` attribute, and; * A result of C retainable pointer type is assumed to not be returned retained; unless the function is either marked ``cf_returns_retained`` or it follows; the create/copy naming convention and is not marked; ``cf_returns_not_retained``. A function obeys the :arc-term:`create/copy` naming convention if its name; contains as a substring:. * either ""Create"" or ""Copy"" not followed by a lowercase letter, or; * either ""create"" or ""copy"" not followed by a lowercase letter and; not preceded by a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:102704,interface,interfaces,102704,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['interface'],['interfaces']
Integrability,"else; #define CF_RETURNS_NOT_RETAINED; #endif; #endif. Attribute 'ns_consumed'; (Clang-specific); The 'ns_consumed' attribute can be placed on a specific parameter in either; the declaration of a function or an Objective-C method. It indicates to the; static analyzer that a release message is implicitly sent to the; parameter upon completion of the call to the given function or method. The; Foundation framework defines a macro NS_RELEASES_ARGUMENT that; is functionally equivalent to the NS_CONSUMED macro shown below.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMED; #if __has_feature(attribute_ns_consumed); #define NS_CONSUMED __attribute__((ns_consumed)); #else; #define NS_CONSUMED; #endif; #endif. void consume_ns(id NS_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_ns(x); // No leak!; }. @interface Foo : NSObject; + (void) releaseArg:(id) NS_CONSUMED x;; + (void) releaseSecondArg:(id)x second:(id) NS_CONSUMED y;; @end. void test_method() {; id x = [[NSObject alloc] init];; [Foo releaseArg:x]; // No leak!; }. void test_method2() {; id a = [[NSObject alloc] init];; id b = [[NSObject alloc] init];; [Foo releaseSecondArg:a second:b]; // 'a' is leaked, but 'b' is released.; }. Attribute 'cf_consumed'; (Clang-specific); The 'cf_consumed' attribute is practically identical to ns_consumed. The attribute can be placed on a; specific parameter in either the declaration of a function or an Objective-C; method. It indicates to the static analyzer that the object reference is; implicitly passed to a call to CFRelease upon completion of the call; to the given function or method. The CoreFoundation framework defines a macro; CF_RELEASES_ARGUMENT that is functionally equivalent to the; CF_CONSUMED macro shown below.; Operationally this attribute is nearly identical to 'ns_consumed'.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:10571,interface,interface,10571,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['interface'],['interface']
Integrability,"ely; in the sandbox, as 'mymacro.C'; so they should be included directly by; 'mymacro.C', e.g. '#include ""thisheader.h""' .; Import the dataset stager daemon 'afdsmgrd' into ROOT; this is used; to manage data staging based on the dataset information (see; http://code.google.com/p/afdsmgrd/ for more info). The daemon is; located under $ROOTSYS/proof/afdsmgrd .; New PROOF bench suite, a framework to run CPU and IO benchmarks with; default selectors/data or with user-provided ones. The code is located; under proof/proofbench.; Add the possibility to access the files on the workers via the same; port used by PROOF. This is useful for cases when it is not possible to; start a file server daemon on a different port (because, for eample, of; a firewall or just inconvenience) and workers do not share a file; system. Internally this works by forking a 'rootd' after identifying a; file request and trasferring the connection to it. The client side is a; TNetFile and it is triggered by the protocol ""rootd://"" (the just; implemented etc/plugins/TFile/P120_TNetFile.C includes this; protocol).; Add support for log file truncation. Truncation is disabled by; default. Enabling is controlled by the rootrc variable.           ; ProofServ.LogFileMaxSize  ; {<bytes>|<kilobytes>K|<megabytes>M|<gigabytes>G}.  indicating the max number of bytes. The number can be followed by; a {K,M,G} to indicate KBytes, MBytes or GBytes, respectively.; Add new derivation of TList (TProofOutputList) to be used on the; PROOF client to filter out PROOF internal objects when displaying or; printing the list. By default objects was names start with 'PROOF_' are; not shown. The presence of a non empty missing file list is; notified.; In the PROOF monitoring to: send additional information about memory; usage during the query, the name and size (# of files) of the dataset; processed (if any); add possibility to send the information to multiple; monitoring collectors.; Add support for block activation/deactivatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html:1533,protocol,protocol,1533,proof/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html,1,['protocol'],['protocol']
Integrability,"em is to check for target-specific output, for example sizes; of structures, paths and architecture names, for example:. * Tests containing Windows paths will fail on Linux and vice-versa.; * Tests that check for ``x86_64`` somewhere in the text will fail anywhere else.; * Tests where the debug information calculates the size of types and structures. Also, if the test rely on any behaviour that is coded in any back-end, it must; go in its own directory. So, for instance, code generator tests for ARM go; into ``test/CodeGen/ARM`` and so on. Those directories contain a special; ``lit`` configuration file that ensure all tests in that directory will; only run if a specific back-end is compiled and available. For instance, on ``test/CodeGen/ARM``, the ``lit.local.cfg`` is:. .. code-block:: python. config.suffixes = ['.ll', '.c', '.cpp', '.test']; if not 'ARM' in config.root.targets:; config.unsupported = True. Other platform-specific tests are those that depend on a specific feature; of a specific sub-architecture, for example only to Intel chips that support ``AVX2``. For instance, ``test/CodeGen/X86/psubus.ll`` tests three sub-architecture; variants:. .. code-block:: llvm. ; RUN: llc -mcpu=core2 < %s | FileCheck %s -check-prefix=SSE2; ; RUN: llc -mcpu=corei7-avx < %s | FileCheck %s -check-prefix=AVX1; ; RUN: llc -mcpu=core-avx2 < %s | FileCheck %s -check-prefix=AVX2. And the checks are different:. .. code-block:: llvm. ; SSE2: @test1; ; SSE2: psubusw LCPI0_0(%rip), %xmm0; ; AVX1: @test1; ; AVX1: vpsubusw LCPI0_0(%rip), %xmm0, %xmm0; ; AVX2: @test1; ; AVX2: vpsubusw LCPI0_0(%rip), %xmm0, %xmm0. So, if you're testing for a behaviour that you know is platform-specific or; depends on special features of sub-architectures, you must add the specific; triple, test with the specific FileCheck and put it into the specific; directory that will filter out all other architectures. Constraining test execution; ---------------------------. Some tests can be run only in specific con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:18557,depend,depend,18557,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['depend'],['depend']
Integrability,ember function; No. 1891; CD4; Move constructor/assignment for closure class; Clang 4. 1892; CD4; Use of auto in function type; Unknown. 1893; CD5; Function-style cast with braced-init-lists and empty pack expansions; Unknown. 1894; CD6; typedef-names and using-declarations; Clang 3.8. 1895; CD4; Deleted conversions in conditional operator operands; Unknown. 1896; CD6; Repeated alias templates; Unknown. 1897; review; ODR vs alternative tokens; Not resolved. 1898; CD6; Use of “equivalent” in overload resolution; Unknown. 1899; CD4; Value-dependent constant expressions; Unknown. 1900; CD6; Do friend declarations count as “previous declarations”?; Unknown. 1901; drafting; punctuator referenced but not defined; Not resolved. 1902; CD4; What makes a conversion “otherwise ill-formed”?; Clang 3.7. 1903; CD4; What declarations are introduced by a non-member using-declaration?; Unknown. 1904; NAD; Default template arguments for members of class templates; Unknown. 1905; NAD; Dependent types and injected-class-names; Unknown. 1906; NAD; Name lookup in member friend declaration; Unknown. 1907; CD6; using-declarations and default arguments; Unknown. 1908; CD6; Dual destructor lookup and template-ids; Unknown. 1909; CD4; Member class template with the same name as the class; Clang 3.7. 1910; CD5; “Shall” requirement applied to runtime behavior; Unknown. 1911; CD4; constexpr constructor with non-literal base class; Unknown. 1912; CD5; exception-specification of defaulted function; Unknown. 1913; CD5; decltype((x)) in lambda-expressions; Unknown. 1914; extension; Duplicate standard attributes; Extension. 1915; open; Potentially-invoked destructors in non-throwing constructors; Not resolved. 1916; CD4; “Same cv-unqualified type”; Unknown. 1917; NAD; decltype-qualified enumeration names; Unknown. 1918; open; friend templates with dependent scopes; Not resolved. 1919; open; Overload resolution for ! with explicit conversion operator; Not resolved. 1920; CD4; Qualification mismatch in,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:129399,inject,injected-class-names,129399,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['inject'],['injected-class-names']
Integrability,"ementing methods follow the signature of the static type.; It is undefined behavior if ARC is exposed to an invalid pointer. For ARC's purposes, a valid object is one with ""well-behaved"" retaining; operations. Specifically, the object must be laid out such that the; Objective-C message send machinery can successfully send it the following; messages:. * ``retain``, taking no arguments and returning a pointer to the object.; * ``release``, taking no arguments and returning ``void``.; * ``autorelease``, taking no arguments and returning a pointer to the object. The behavior of these methods is constrained in the following ways. The term; :arc-term:`high-level semantics` is an intentionally vague term; the intent is; that programmers must implement these methods in a way such that the compiler,; modifying code in ways it deems safe according to these constraints, will not; violate their requirements. For example, if the user puts logging statements; in ``retain``, they should not be surprised if those statements are executed; more or less often depending on optimization settings. These constraints are; not exhaustive of the optimization opportunities: values held in local; variables are subject to additional restrictions, described later in this; document. It is undefined behavior if a computation history featuring a send of; ``retain`` followed by a send of ``release`` to the same object, with no; intervening ``release`` on that object, is not equivalent under the high-level; semantics to a computation history in which these sends are removed. Note that; this implies that these methods may not raise exceptions. It is undefined behavior if a computation history features any use whatsoever; of an object following the completion of a send of ``release`` that is not; preceded by a send of ``retain`` to the same object. The behavior of ``autorelease`` must be equivalent to sending ``release`` when; one of the autorelease pools currently in scope is popped. It may not throw a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:13875,depend,depending,13875,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['depend'],['depending']
Integrability,"ements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no matching function for call to 'f'; f<A>(a);; ^~~~; t.cc:1:24: note: candidate template ignored: substitution failure [with T = A]: no type named 'type' in 'A'; template<class T> void f(T::type) { }; ^ ~~~~. While each of these details is minor, we feel that they all add up to provide; a much more polished experience. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:11125,depend,dependent,11125,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['depend'],['dependent']
Integrability,"emplate constructors of the Rotation classes, taking as input any other type; of rotation are missing. Therefore code like the following one will now work in CINT (or Python):. ROOT::Math::Rotation3D r;; ROOT::Math::EulerAngles eulerRot(r);. A possible solution is to use the operator=:. ROOT::Math::EulerAngles eulerRot; eulerRot = r;. In addition the setter methods for the 2D,3D and 4D vector classes have been extended following a suggestion by G. Raven. Functions like SetX instead of returning a void return now a reference to the vector class itself (*this).; Detailed description of the current GenVector release can be found at this location. SMatrix; Fix a bug discovered by Harals Soleng in the addition of two matrix expressions. Remove also some compilation warning found on Windows when compiling matrices instantiated using float types.; Detailed description of the current SMatrix release can be found at this location. Minuit; Two new classes have been added:; ; TMinuitMinimizer: implementation of the ROOT::Math::Minimizer interface with TMinuit. This class is used for example by the new Fitter class.; TLinearMinimizer: implementation of the ROOT::Math::Minimizer interface with the TLinearFitter.; ; In addition, the method TLinearFitter::SetBasisFunction(TObjArray * f) has been added to set directly the linear terms of the fit function. Minuit2. Various fixes have been applied to different problems discovered mainly by a test program from Alfio Lazzaro. In detail:; . Fix a bug in MnMinos which was setting wrong initial values when the parameters were limited.; This was resulting in a much larger number of function calls used inside MnMinos. ; Improve MnHesse by returning in the final state the improved gradient step values used in HessianGradientCalculator. With this change same results are obtained from using Hesse in Minuit2 or TMinuit. In addition, the interface of MnHesse (MnHesse::operator() ) has been improved to use it from the FunctionMinimum object (simi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:12467,interface,interface,12467,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['interface'],['interface']
Integrability,emplates; Unknown. 1245; C++11; Matching declarations involving decltype; Unknown. 1246; C++11; Non-deduced non-final parameter packs; Unknown. 1247; CD4; Restriction on alias name appearing in type-id; Unknown. 1248; open; Updating Annex C to C99; Not resolved. 1249; CD6; Cv-qualification of nested lambda capture; Unknown. 1250; CD3; Cv-qualification of incomplete virtual function return types; Clang 3.9. 1251; CD3; C compatibility: casting to unqualified void*; Unknown. 1252; CD6; Overloading member function templates based on dependent return type; Unknown. 1253; open; Generic non-template members; Not resolved. 1254; NAD; odr-use vs template arguments and constexpr functions; Unknown. 1255; drafting; Definition problems with constexpr functions; Not resolved. 1256; open; Unevaluated operands are not necessarily constant expressions; Not resolved. 1257; open; Instantiation via non-dependent references in uninstantiated templates; Not resolved. 1258; CD5; “Instantiation context” differs from dependent lookup rules; Unknown. 1259; NAD; Deleting a POD via a pointer to base; Unknown. 1260; CD3; Incorrect use of term “overloaded” in description of odr-use; Unknown. 1261; CD3; Explicit handling of cv-qualification with non-class prvalues; Unknown. 1262; CD3; Default template arguments and deduction failure; Unknown. 1263; NAD; Mismatch between rvalue reference binding and overload resolution; Unknown. 1264; CD3; Use of this in constexpr constructor; Unknown. 1265; CD3; Mixed use of the auto specifier; Clang 5. 1266; open; user-defined-integer-literal overflow; Not resolved. 1267; CD3; Rvalue reference types in exception-specifications; Unknown. 1268; CD3; reinterpret_cast of an xvalue operand; Unknown. 1269; CD3; dynamic_cast of an xvalue operand; Unknown. 1270; CD3; Brace elision in array temporary initialization; Unknown. 1271; CD5; Imprecise wording regarding dependent types; Unknown. 1272; NAD; Implicit definition of static data member of const literal type; Unknown,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:83962,depend,dependent,83962,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"en capability must not be held on entry, and will be held on exit; (exclusively for ``ACQUIRE``, shared for ``ACQUIRE_SHARED``). ``RELEASE``, ``RELEASE_SHARED``, and ``RELEASE_GENERIC`` declare that the; function releases the given capability. The capability must be held on entry; (exclusively for ``RELEASE``, shared for ``RELEASE_SHARED``, exclusively or; shared for ``RELEASE_GENERIC``), and will no longer be held on exit. .. code-block:: c++. Mutex mu;; MyClass myObject GUARDED_BY(mu);. void lockAndInit() ACQUIRE(mu) {; mu.Lock();; myObject.init();; }. void cleanupAndUnlock() RELEASE(mu) {; myObject.cleanup();; } // Warning! Need to unlock mu. void test() {; lockAndInit();; myObject.doSomething();; cleanupAndUnlock();; myObject.doSomething(); // Warning, mu is not locked.; }. If no argument is passed to ``ACQUIRE`` or ``RELEASE``, then the argument is; assumed to be ``this``, and the analysis will not check the body of the; function. This pattern is intended for use by classes which hide locking; details behind an abstract interface. For example:. .. code-block:: c++. template <class T>; class CAPABILITY(""mutex"") Container {; private:; Mutex mu;; T* data;. public:; // Hide mu from public interface.; void Lock() ACQUIRE() { mu.Lock(); }; void Unlock() RELEASE() { mu.Unlock(); }. T& getElem(int i) { return data[i]; }; };. void test() {; Container<int> c;; c.Lock();; int i = c.getElem(0);; c.Unlock();; }. EXCLUDES(...); -------------. *Previously*: ``LOCKS_EXCLUDED``. ``EXCLUDES`` is an attribute on functions or methods, which declares that; the caller must *not* hold the given capabilities. This annotation is; used to prevent deadlock. Many mutex implementations are not re-entrant, so; deadlock can occur if the function acquires the mutex a second time. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void clear() EXCLUDES(mu) {; mu.Lock();; a = 0;; mu.Unlock();; }. void reset() {; mu.Lock();; clear(); // Warning! Caller cannot hold 'mu'.; mu.Unlock();; }. Unl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:9690,interface,interface,9690,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['interface'],['interface']
Integrability,"en individual instructions. Each node in such a graph; represents a single instruction and is referred to as an ""atomic"" node.; It is also possible to combine some atomic nodes that have a simple; def-use dependency between them into larger nodes that contain multiple-; instructions. As described in [1]_ the DDG uses graph abstraction to group nodes; that are part of a strongly connected component of the graph; into special nodes called pi-blocks. pi-blocks represent cycles of data; dependency that prevent reordering transformations. Since any strongly; connected component of the graph is a maximal subgraph of all the nodes; that form a cycle, pi-blocks are at most one level deep. In other words,; no pi-blocks are nested inside another pi-block, resulting in a; hierarchical representation that is at most one level deep. For example, consider the following:. .. code-block:: c++. for (int i = 1; i < n; i++) {; b[i] = c[i] + b[i-1];; }. This code contains a statement that has a loop carried dependence on; itself creating a cycle in the DDG. The figure below illustrates; how the cycle of dependency is carried through multiple def-use relations; and a memory access dependency. .. image:: cycle.png. The DDG corresponding to this example would have a pi-block that contains; all the nodes participating in the cycle, as shown below:. .. image:: cycle_pi.png. Program Dependence Graph; ========================. The Program Dependence Graph (or PDG) has a similar structure as the; DDG, but it is capable of representing both data dependencies and; control-flow dependencies between program elements such as; instructions, groups of instructions, basic blocks or groups of; basic blocks. High-Level Design; =================. The DDG and the PDG are both directed graphs and they extend the; ``DirectedGraph`` class. Each implementation extends its corresponding; node and edge types resulting in the inheritance relationship depicted; in the UML diagram below:. .. image:: uml_nodes_and_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:1709,depend,dependence,1709,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,1,['depend'],['dependence']
Integrability,"en on the [demo page](https://root.cern/js/latest/httpserver.C/). One could also specify similar URL parameters to configure the displayed items and drawing options. It is also possible to display one single item from the THttpServer server like:. <https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz>. ## Data monitoring with JSROOT. ### Monitoring with http server. The best possibility to organize the monitoring of data from a running application; is to use THttpServer. In such case the client can always access the latest; changes and request only the items currently displayed in the browser.; To enable monitoring, one should activate the appropriate checkbox or; provide __monitoring__ parameter in the URL string like:. <https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000>. The parameter value is the update interval in milliseconds. ### JSON file-based monitoring. Solid file-based monitoring (without integration of THttpServer into application) can be; implemented in JSON format. There is the [TBufferJSON](https://root.cern/doc/master/classTBufferJSON.html) class,; which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to; create JSON files for selected objects and write such files in a directory,; which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser. There is a demonstration page showing such functionality: <https://root.cern/js/latest/demo/update_draw.htm>.; This demo page reads in cycle 20 json files and displays them. If one has a web server which already provides such JSON file, one could specify the URL to this file like:. <https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz>. Here the same problem with [Cross-Origin Request](https://developer.mozilla.org/en/http_access_control) can appear. If the web server configuration cannot be chan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:31076,integrat,integration,31076,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['integrat'],['integration']
Integrability,"en sent the; ``autorelease`` message. Always returns ``value``. .. _arc.runtime.objc_autoreleasePoolPop:. ``void objc_autoreleasePoolPop(void *pool);``; ---------------------------------------------. *Precondition:* ``pool`` is the result of a previous call to; :ref:`objc_autoreleasePoolPush <arc.runtime.objc_autoreleasePoolPush>` on the; current thread, where neither ``pool`` nor any enclosing pool have previously; been popped. Releases all the objects added to the given autorelease pool and any; autorelease pools it encloses, then sets the current autorelease pool to the; pool directly enclosing ``pool``. .. _arc.runtime.objc_autoreleasePoolPush:. ``void *objc_autoreleasePoolPush(void);``; -----------------------------------------. Creates a new autorelease pool that is enclosed by the current pool, makes that; the current pool, and returns an opaque ""handle"" to it. .. admonition:: Rationale. While the interface is described as an explicit hierarchy of pools, the rules; allow the implementation to just keep a stack of objects, using the stack; depth as the opaque pool handle. .. _arc.runtime.objc_autoreleaseReturnValue:. ``id objc_autoreleaseReturnValue(id value);``; ---------------------------------------------. *Precondition:* ``value`` is null or a pointer to a valid object. If ``value`` is null, this call has no effect. Otherwise, it makes a best; effort to hand off ownership of a retain count on the object to a call to; :ref:`objc_retainAutoreleasedReturnValue; <arc.runtime.objc_retainAutoreleasedReturnValue>` (or; :ref:`objc_unsafeClaimAutoreleasedReturnValue; <arc.runtime.objc_unsafeClaimAutoreleasedReturnValue>`) for the same object in; an enclosing call frame. If this is not possible, the object is autoreleased as; above. Always returns ``value``. .. _arc.runtime.objc_copyWeak:. ``void objc_copyWeak(id *dest, id *src);``; ------------------------------------------. *Precondition:* ``src`` is a valid pointer which either contains a null pointer; or has been",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:108176,interface,interface,108176,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['interface'],['interface']
Integrability,"en/Save, File Properties, Font Selection,; Color Selection, About. - The widgets are shown in frames:. - frame, composite frame, main frame, transient frame, group frame. - Arranged by layout managers:. - horizontal layout, vertical layout, row layout, list layout, tile; layout, matrix layout. Using a combination of layout hints:. - left, right, center x, center y, top, bottom, expand x, expand y,; fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. - in response to actions widgets send messages and emit signals. - associated frames process these messages or the slot methods; connected to the signals are executed. ## TVirtualX. The GUI classes interface to the platform dependent low level graphics; system via the semi-abstract graphics base class **`TVirtualX`**.; Currently concrete implementations exist for X11 and Win32 (MacOS X is; fully supported via Apple's X11 implementation). Thanks to this single; graphics interface, porting the ROOT GUI to a new platform requires only; the implementation of **`TVirtualX`**. ![](pictures/02000201.jpg). ## A Simple Example. We will start with a simple example that builds a small application; containing a canvas and two buttons: Draw and Exit. Its functionality; will be very simple: every time you click on Draw button, the graphics; of the function `sin(x)/x` will be drawn in randomly chosen interval in; the canvas window, if you click on Exit - you close the application.; This example shows the basic concepts for almost any GUI-application in; ROOT and it is important to understand how it is constructed. The; example program is written as a named script. See ""Cling the C++; Interpreter"". Remember that the named script can be executed via. ``` {.cpp}; root[] .x example.C; ```. only if the filename (without extension) and the function entry point; are both the same. ![](pictures/02000202.jpg). We need to say a few words about the parent-children relationship; between the widgets before going",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:2565,interface,interface,2565,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['interface'],['interface']
Integrability,"en1:; ...; %cond2 = ...; br label %mid. mid:; %flag = phi i1 [ true, %entry ], [ %cond2, %then1 ]; br i1 %flag, label %then2, label %end. then2:; ...; call void @subgroupControlBarrier() [ ""convergencectrl""(token %entry) ]; ...; br label %end. end:; }. If S is the set of threads that the entry intrinsic communicated with, then; the ``@subgroupControlBarrier`` call communicates with the subset of S that; actually reaches the call site. This set of threads doesn't change after; jump-threading, so the answer to the question posed above remains the same. .. _opportunistic_convergence:. Opportunistic convergent operations; -----------------------------------. Some programs have local regions of code that contain a sequence of convergent; operations where the code does not care about the exact set of threads with; which it is executed, but only that the set of threads is the same for all the; operations within the sequence. (If a subset of the convergent operations in the; sequence have additional, non-uniform control dependencies, then this is not; possible. However, the code may still require that the sets of threads are; logically consistent with the conditions of those control dependencies.) In this; case, :ref:`llvm.experimental.convergence.anchor; <llvm.experimental.convergence.anchor>` can be used to express the desired; semantics. The following example function could be part of a hypothetical ""append buffer""; implementation, where threads conditionally write fixed-sized records; contiguously into a global buffer. The function ``@reserveSpaceInBuffer``; returns the index into the buffer at which the calling thread should store its; data. This could be achieved by using a simple atomic operation in every thread to; bump an allocation counter. However, the following implementation can be more performant on some hardware,; because it uses only a single atomic operation for an entire group of threads.; To do this, it first determines the total size of the group, which ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:11772,depend,dependencies,11772,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['depend'],['dependencies']
Integrability,"ence>`_ are constrained by strict; rules: for example, the Left and Right operands of an `add; instruction <../../LangRef.html#add-instruction>`_ must have the same type, and the; result type of the add must match the operand types. Because all values; in Kaleidoscope are doubles, this makes for very simple code for add,; sub and mul. On the other hand, LLVM specifies that the `fcmp; instruction <../../LangRef.html#fcmp-instruction>`_ always returns an 'i1' value (a; one bit integer). The problem with this is that Kaleidoscope wants the; value to be a 0.0 or 1.0 value. In order to get these semantics, we; combine the fcmp instruction with a `uitofp; instruction <../../LangRef.html#uitofp-to-instruction>`_. This instruction converts its; input integer into a floating point value by treating the input as an; unsigned value. In contrast, if we used the `sitofp; instruction <../../LangRef.html#sitofp-to-instruction>`_, the Kaleidoscope '<' operator; would return 0.0 and -1.0, depending on the input value. .. code-block:: c++. Value *CallExprAST::codegen() {; // Look up the name in the global module table.; Function *CalleeF = TheModule->getFunction(Callee);; if (!CalleeF); return LogErrorV(""Unknown function referenced"");. // If argument mismatch error.; if (CalleeF->arg_size() != Args.size()); return LogErrorV(""Incorrect # arguments passed"");. std::vector<Value *> ArgsV;; for (unsigned i = 0, e = Args.size(); i != e; ++i) {; ArgsV.push_back(Args[i]->codegen());; if (!ArgsV.back()); return nullptr;; }. return Builder->CreateCall(CalleeF, ArgsV, ""calltmp"");; }. Code generation for function calls is quite straightforward with LLVM. The code; above initially does a function name lookup in the LLVM Module's symbol table.; Recall that the LLVM Module is the container that holds the functions we are; JIT'ing. By giving each function the same name as what the user specifies, we; can use the LLVM symbol table to resolve function names for us. Once we have the function to call, w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:8948,depend,depending,8948,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['depend'],['depending']
Integrability,"encies-output-file=/tmp/inconsistencies.html. This will group the instructions into clusters with the same performance; characteristics. The clusters will be written out to `/tmp/clusters.csv` in the; following format:. .. code-block:: none. cluster_id,opcode_name,config,sched_class; ...; 2,ADD32ri8_DB,,WriteALU,1.00; 2,ADD32ri_DB,,WriteALU,1.01; 2,ADD32rr,,WriteALU,1.01; 2,ADD32rr_DB,,WriteALU,1.00; 2,ADD32rr_REV,,WriteALU,1.00; 2,ADD64i32,,WriteALU,1.01; 2,ADD64ri32,,WriteALU,1.01; 2,MOVSX64rr32,,BSWAP32r_BSWAP64r_MOVSX64rr32,1.00; 2,VPADDQYrr,,VPADDBYrr_VPADDDYrr_VPADDQYrr_VPADDWYrr_VPSUBBYrr_VPSUBDYrr_VPSUBQYrr_VPSUBWYrr,1.02; 2,VPSUBQYrr,,VPADDBYrr_VPADDDYrr_VPADDQYrr_VPADDWYrr_VPSUBBYrr_VPSUBDYrr_VPSUBQYrr_VPSUBWYrr,1.01; 2,ADD64ri8,,WriteALU,1.00; 2,SETBr,,WriteSETCC,1.01; ... :program:`llvm-exegesis` will also analyze the clusters to point out; inconsistencies in the scheduling information. The output is an html file. For; example, `/tmp/inconsistencies.html` will contain messages like the following :. .. image:: llvm-exegesis-analysis.png; :align: center. Note that the scheduling class names will be resolved only when; :program:`llvm-exegesis` is compiled in debug mode, else only the class id will; be shown. This does not invalidate any of the analysis results though. OPTIONS; -------. .. option:: --help. Print a summary of command line options. .. option:: --opcode-index=<LLVM opcode index>. Specify the opcode to measure, by index. Specifying `-1` will result; in measuring every existing opcode. See example 1 for details.; Either `opcode-index`, `opcode-name` or `snippets-file` must be set. .. option:: --opcode-name=<opcode name 1>,<opcode name 2>,... Specify the opcode to measure, by name. Several opcodes can be specified as; a comma-separated list. See example 1 for details.; Either `opcode-index`, `opcode-name` or `snippets-file` must be set. .. option:: --snippets-file=<filename>. Specify the custom code snippet to measure. See example 2 for details.; E",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:8864,message,messages,8864,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,1,['message'],['messages']
Integrability,"ency is carried through multiple def-use relations; and a memory access dependency. .. image:: cycle.png. The DDG corresponding to this example would have a pi-block that contains; all the nodes participating in the cycle, as shown below:. .. image:: cycle_pi.png. Program Dependence Graph; ========================. The Program Dependence Graph (or PDG) has a similar structure as the; DDG, but it is capable of representing both data dependencies and; control-flow dependencies between program elements such as; instructions, groups of instructions, basic blocks or groups of; basic blocks. High-Level Design; =================. The DDG and the PDG are both directed graphs and they extend the; ``DirectedGraph`` class. Each implementation extends its corresponding; node and edge types resulting in the inheritance relationship depicted; in the UML diagram below:. .. image:: uml_nodes_and_edges.png. Graph Construction; ------------------. The graph build algorithm considers dependencies between elements of; a given set of instructions or basic blocks. Any dependencies coming; into or going out of instructions that do not belong to that range; are ignored. The steps in the build algorithm for the DDG are very; similar to the steps in the build algorithm for the PDG. As such,; one of the design goals is to reuse the build algorithm code to; allow creation of both DDG and PDG representations while allowing; the two implementations to define their own distinct and independent; node and edge types. This is achieved by using the well-known builder; design pattern to isolate the construction of the dependence graph; from its concrete representation. The following UML diagram depicts the overall structure of the design; pattern as it applies to the dependence graph implementation. .. image:: uml_builder_pattern.png. Notice that the common code for building the two types of graphs are; provided in the ``DependenceGraphBuilder`` class, while the ``DDGBuilder``; and ``PDGBuilder`` contr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:2793,depend,dependencies,2793,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,1,['depend'],['dependencies']
Integrability,"end instead of one-by-one to; exploit, for example, the better performance of TH1::Merge on the full; list of histos.; Add possibility to compress the messages; this is; controlled by ProofServ.CompressMessage; <compression_level>; The default is still 'no compression' but this will allow to study the; impact of compression. Add sort of 'progress' counter for merging is now shown; on the client:;  ;     root [n] p->Process(...);       ... ;       Mst-0: merging output objects ... / (4; workers still sending). This asserts socket activity and fixes the timeout; problems during long merging phases reported in a few cases.; In TFileMerger, create directly the output file at the; final destination do not make a local copy in the temp directory first; (if needed, one can always set the temporary destination to temp; followed by a TFile::Cp to the final destination); this allows to avoid; reported problems with small temp partitions (see Forum).; In XrdProofConn, enable cycling through the; authentication protocol presented by the server. This only holds for; the choice of the protocol, because the server currently supports only; one full handshake.; In test/stressProof.cxx, avoid interferences between the; settings used for the PROOF tutorial and possible local settings; (daemon, dataset manager).; Add possibility to control the automatic re-loading of; the <proof.conf> file via the keyword; 'reload:1'/'reload:0'; in the xpd.resource directive.; Move the validation of <proof.conf> at the; moment of use; this allows to specify a file path and to dynamically; create/modify/destroy the file; used by PoD.; Improve displaying speed of large log files. Fixes. Fix two severe; bugs in the way TTreeCache; was used in PROOF: one bug was de facto disactivating the cache; the; other was causing a std::bad_alloc exception to be thrown on workers; when opening a remote file after a local one.    ; Fix several problems in TChain::Draw including. drawing into an existing histogram, i.e.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:7985,protocol,protocol,7985,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['protocol'],['protocol']
Integrability,"end is built as a component of the LLVM toolkit that can be used; with the LLVM backend or independently of it. In this spirit, the API has been; carefully designed as the following components:; ; libsupport - Basic support library, reused from LLVM. libsystem - System abstraction library, reused from LLVM.; ; libbasic - Diagnostics, SourceLocations, SourceBuffer abstraction,; file system caching for input source files. This depends on; libsupport and libsystem. libast - Provides classes to represent the C AST, the C type system,; builtin functions, and various helpers for analyzing and; manipulating the AST (visitors, pretty printers, etc). This; library depends on libbasic. liblex - C/C++/ObjC lexing and preprocessing, identifier hash table,; pragma handling, tokens, and macros. This depends on libbasic. libparse - C (for now) parsing and local semantic analysis. This library; invokes coarse-grained 'Actions' provided by the client to do; stuff (e.g. libsema builds ASTs). This depends on liblex. libsema - Provides a set of parser actions to build a standardized AST; for programs. AST's are 'streamed' out a top-level declaration; at a time, allowing clients to use decl-at-a-time processing,; build up entire translation units, or even build 'whole; program' ASTs depending on how they use the APIs. This depends; on libast and libparse. librewrite - Fast, scalable rewriting of source code. This operates on; the raw syntactic text of source code, allowing a client; to insert and delete text in very large source files using; the same source location information embedded in ASTs. This; is intended to be a low-level API that is useful for; higher-level clients and libraries such as code refactoring. libanalysis - Source-level dataflow analysis useful for performing analyses; such as computing live variables. It also includes a; path-sensitive ""graph-reachability"" engine for writing; analyses that reason about different possible paths of; execution through source code. Thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt:1863,depend,depends,1863,interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,1,['depend'],['depends']
Integrability,"end of #endif directive. #pragma clang diagnostic push; #pragma clang diagnostic ignored ""-Wextra-tokens"". #if foo; #endif foo // no warning. #pragma clang diagnostic pop. The push and pop pragmas will save and restore the full diagnostic state; of the compiler, regardless of how it was set. That means that it is; possible to use push and pop around GCC compatible diagnostics and Clang; will push and pop them appropriately, while GCC will ignore the pushes; and pops as unknown pragmas. It should be noted that while Clang; supports the GCC pragma, Clang and GCC do not support the exact same set; of warnings, so even when using GCC compatible #pragmas there is no; guarantee that they will have identical behaviour on both compilers. In addition to controlling warnings and errors generated by the compiler, it is; possible to generate custom warning and error messages through the following; pragmas:. .. code-block:: c. // The following will produce warning messages; #pragma message ""some diagnostic message""; #pragma GCC warning ""TODO: replace deprecated feature"". // The following will produce an error message; #pragma GCC error ""Not supported"". These pragmas operate similarly to the ``#warning`` and ``#error`` preprocessor; directives, except that they may also be embedded into preprocessor macros via; the C99 ``_Pragma`` operator, for example:. .. code-block:: c. #define STR(X) #X; #define DEFER(M,...) M(__VA_ARGS__); #define CUSTOM_ERROR(X) _Pragma(STR(GCC error(X "" at line "" DEFER(STR,__LINE__)))). CUSTOM_ERROR(""Feature not available"");. Controlling Diagnostics in System Headers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Warnings are suppressed when they occur in system headers. By default,; an included file is treated as a system header if it is found in an; include path specified by ``-isystem``, but this can be overridden in; several ways. The ``system_header`` pragma can be used to mark the current file as; being a system header. No warnings will be produced from ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:40742,message,messages,40742,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,3,['message'],"['message', 'messages']"
Integrability,"end that requires an intermediate (Python; interpreter dependent) layer, and a backend (see; :ref:`Package Structure <package-structure>`).; Because of this layering and because it leverages several existing packages; through reuse, the relevant codes are contained across a number of; repositories. * Frontend, cppyy: https://github.com/wlav/cppyy; * CPython (v2/v3) intermediate: https://github.com/wlav/CPyCppyy; * PyPy intermediate (module _cppyy): https://foss.heptapod.net/pypy; * Backend, cppyy: https://github.com/wlav/cppyy-backend. The backend repo contains both the cppyy-cling (under ""cling"") and; cppyy-backend (under ""clingwrapper"") packages. .. _building_from_source:. Building from source; --------------------. Except for cppyy-cling, the structure in the repositories follows a normal; PyPA package and they are thus ready to build with `setuptools`_: simply; clone the package and either run ``python setup.py``, or use ``pip``. It is highly recommended to follow the dependency chain when manually; upgrading packages individually (i.e. ``cppyy-cling``, ``cppyy-backend``,; ``CPyCppyy`` if on CPython, and then finally ``cppyy``), because upstream; packages expose headers that are used by the ones downstream.; Of course, if only building for a patch/point release, there is no need to; re-install the full chain (or follow the order).; Always run the local updates from the package directories (i.e. where the; ``setup.py`` file is located), as some tools rely on the package structure. The ``STDCXX`` envar can be used to control the C++ standard version; use; ``MAKE`` to change the ``make`` command; and ``MAKE_NPROCS`` to control the; maximum number of parallel jobs.; Compilation of the backend, which contains a customized version of; Clang/LLVM, can take a long time, so by default the setup script will use all; cores (x2 if hyperthreading is enabled). On MS Windows, some temporary path names may be too long, causing the build to; fail.; To resolve this issue, point th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst:1065,depend,dependency,1065,bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,1,['depend'],['dependency']
Integrability,"ension; `_quantile` calculate the inverse of the cumulative distribution; function (lower tail integral of the probability density function),; while those with the *`quantile_c`* extension calculate the inverse of; the complement of the cumulative distribution (upper tail integral). All; the inverse distributions are in the MathMore library and are defined in; the header file `Math/ProbFuncInv.h`. The following picture illustrates the available statistical functions; (PDF, CDF and quantiles) in the case of the normal distribution. ![PDF, CDF and quantiles in the case of the normal distribution](pictures/03000128.png). ## Numerical Algorithms. ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:. * Evaluation of function derivatives.; * Evaluation of integrals.; * Finding the roots of a function; * Finding the minimum/maximum of a function. In order to use these algorithm the user needs to provide a function.; ROOT provides a common way of specifying them via some interfaces. ## ROOT::Math Function interfaces. To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function.; In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ![ROOT::Math Function interface structure](pictures/function-hierarchy.png). ### One-dimensional Function Interfaces. These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions.; For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. * `ROOT::Math::IBaseFunctionOneDim`: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing; `double operator() (const double",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:34718,interface,interfaces,34718,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interfaces']
Integrability,"ent *elem,; Double_t weight);; void TGeoMixture::DefineElement(Int_t iel, Int_t z, Int_t natoms);; ```. or:. ``` {.cpp}; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight); ```. - `iel:` index of the element` [0,nel-1]`; - `a` and `z:` the atomic mass and charge; - `weight:` proportion by mass of the elements; - `natoms`: number of atoms of the element in the molecule making the; mixture. The radiation length is automatically computed when all elements are; defined. Since tracking MC provide several other ways to create; materials/mixtures, the materials classes are likely to evolve as the; interfaces to these engines are being developed. Generally in the; process of tracking material properties are not enough and more specific; media properties have to be defined. These highly depend on the MC; performing tracking and sometimes allow the definition of different; media properties (e.g. energy or range cuts) for the same material. ### Radionuclides. A new class **`TGeoElementRN`** was introduced in this version to; provide support for radioactive nuclides and their decays. A database of; 3162 radionuclides can be loaded on demand via the table of elements; (**`TGeoElementTable`** class). One can make then materials/mixtures; based on these radionuclides and use them in a geometry. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; ```. One can make materials or mixtures from radionuclides:. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:17322,depend,depend,17322,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['depend'],['depend']
Integrability,"ent to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. osx.cocoa.ObjCGenerics; (ObjC); Check for type errors when using Objective-C generics. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. osx.cocoa.RetainCount; (ObjC); Check for leaks and violations of the Cocoa Memory Management rules. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. osx.cocoa.SelfInit; (ObjC); Check that self is properly initialized inside an initializer; method. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. osx.cocoa.SuperDealloc; (ObjC); Warn about improper use of '[super dealloc]' in Objective-C. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. osx.cocoa.UnusedIvars; (ObjC); Warn about private ivars that are never used. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. osx.cocoa.VariadicMethodTypes; (ObjC); Check for passing non-Objective-C types to variadic collection initialization; methods that expect only Objective-C types. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. osx.coreFoundation.CFError; (C); Check usage of CFErrorRef* parameters. void test(CFErrorRef *error) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:18836,interface,interface,18836,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['interface'],['interface']
Integrability,"ent(projName ${entry} NAME); if(""${projName}"" MATCHES ""compiler-rt""); set(${path} ${entry} PARENT_SCOPE); return(); endif(); endforeach(); endfunction(). include(LLVMExternalProjectUtils). if(NOT LLVM_BUILD_RUNTIMES); set(EXTRA_ARGS EXCLUDE_FROM_ALL); endif(). function(check_apple_target triple builtin_or_runtime); set(error ""\; compiler-rt for Darwin builds for all platforms and architectures using a \; single configuration. Specify only a single darwin triple (e.g. x86_64-apple-darwin) \; in your targets list (and not a triple for a specific platform such as macos). \; You can use variables such as COMPILER_RT_ENABLE_IOS and DARWIN_ios_ARCHS to \; control the specific platforms and architectures to build.""). set(seen_property ${builtin_or_runtime}_darwin_triple_seen); string(REPLACE ""-"" "";"" triple_components ${triple}); foreach(component ${triple_components}); string(TOLOWER ""${component}"" component_lower); if(component_lower MATCHES ""^darwin""); get_property(darwin_triple_seen GLOBAL PROPERTY ${seen_property}); if(darwin_triple_seen); message(FATAL_ERROR ""${error}""); endif(); set_property(GLOBAL PROPERTY ${seen_property} YES); if(NOT RUNTIMES_BUILD_ALLOW_DARWIN); message(FATAL_ERROR ""\; ${error} Set RUNTIMES_BUILD_ALLOW_DARWIN to allow a single darwin triple.""); endif(); elseif(component_lower MATCHES ""^ios|^macos|^tvos|^watchos""); message(FATAL_ERROR ""${error}""); endif(); endforeach(); endfunction(). macro(set_enable_per_target_runtime_dir); # May have been set by llvm/CMakeLists.txt.; if (NOT DEFINED LLVM_ENABLE_PER_TARGET_RUNTIME_DIR); # AIX should fold 32-bit & 64-bit arch libraries into a single archive.; if (LLVM_TARGET_TRIPLE MATCHES ""aix""); set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR OFF); else(); set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR ON); endif(); endif(); endmacro(). function(builtin_default_target compiler_rt_path); cmake_parse_arguments(ARG """" """" ""DEPENDS"" ${ARGN}). set_enable_per_target_runtime_dir(). llvm_ExternalProject_Add(builtins; ${compiler_rt_path}",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt:1986,message,message,1986,interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,2,['message'],['message']
Integrability,"ent.com/root-project/root/master/README/CREDITS); file shipped with every binary and source distribution.; The copyright transfer helps us with effectively defending the project in case of litigation. ## Your Commit. Each commit is a self-contained, _atomic_ change. This means that:; 1. **Each commit should be able to successfully build ROOT.**; Doing so makes traveling through the git history, for example during a `git bisect` much easier.; Ideally, the commit also should not depend on other commits to _run_ ROOT.; 2. **Each commit does not contain more than one independent change.**; This allows us to revert changes when needed, without affecting anything else. > [!TIP]; > During a code review, it may be useful to make smaller commits to track intermediate changes, and rebase after the PR; > is approved to ensure the above points are met and to reduce clutter. ### Your Commit Message. The commit summary (i.e. the first line of the commit message) should be preceded by the a tag indicating the scope of; ROOT that is affected by your commit, in square brackets. Most tags are self-describing (e.g., `[tree]` indicates a; change to TTree, `[RF]` indicates a change to RooFit). If you are unsure about which scope tags to use, we are happy to; point you in the right direction! See also the [commit log](https://github.com/root-project/root/commits/master/) for; examples. The summary itself should not exceed 50 characters (excluding the scope tag), be meaningful (i.e., it; describes the change) and should be written in the; [present imperative mood](https://git.kernel.org/pub/scm/git/git.git/tree/Documentation/SubmittingPatches?id=HEAD#n239); (e.g. `Add this awesome feature` instead of `Adds this awesome feature` or `Added this awesome feature`). The commit message that follow the summary can be used to provide more context to the change.; It should describe the **why**, rather than the **what** and **how** (we can gather this from the commit summary and the; change diff, re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md:2379,message,message,2379,CONTRIBUTING.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md,1,['message'],['message']
Integrability,"entation of the ``DiagnosticConsumer`` interface is the; ``TextDiagnosticBuffer`` class, which is used when Clang is in ``-verify``; mode. Instead of formatting and printing out the diagnostics, this; implementation just captures and remembers the diagnostics as they fly by.; Then ``-verify`` compares the list of produced diagnostics to the list of; expected ones. If they disagree, it prints out its own output. Full; documentation for the ``-verify`` mode can be found at; :ref:`verifying-diagnostics`. There are many other possible implementations of this interface, and this is; why we prefer diagnostics to pass down rich structured information in; arguments. For example, an HTML output might want declaration names be; linkified to where they come from in the source. Another example is that a GUI; might let you click on typedefs to expand them. This application would want to; pass significantly more information about types through to the GUI than a; simple flat string. The interface allows this to happen. .. _internals-diag-translation:. Adding Translations to Clang; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Not possible yet! Diagnostic strings should be written in UTF-8, the client can; translate to the relevant code page if needed. Each translation completely; replaces the format string for the diagnostic. .. _SourceLocation:; .. _SourceManager:. The ``SourceLocation`` and ``SourceManager`` classes; ----------------------------------------------------. Strangely enough, the ``SourceLocation`` class represents a location within the; source code of the program. Important design points include:. #. ``sizeof(SourceLocation)`` must be extremely small, as these are embedded; into many AST nodes and are passed around often. Currently it is 32 bits.; #. ``SourceLocation`` must be a simple value object that can be efficiently; copied.; #. We should be able to represent a source location for any byte of any input; file. This includes in the middle of tokens, in whitespace, in trigraphs,;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:22699,interface,interface,22699,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['interface'],['interface']
Integrability,"entity matrix.; The columns of $V$ represent the; eigenvectors in the sense that $A.V = V.D$. If $A$ is not; symmetric, the eigenvalue matrix $D$ is block; diagonal with the real eigenvalues in 1-by-1 blocks and any complex; eigenvalues, `a+i*b`, in 2-by-2 blocks, `[a,b;-b,a]`. That is, if the; complex eigenvalues look like:. $$; \left(\begin{array}{cccccc}; u+iv & . & . & . & . & . \\; . & u-iv & . & . & . & . \\; . & . & a+ib & . & . & . \\; . & . & . & a-ib & . & . \\; . & . & . & . & x & . \\; . & . & . & . & . & y; \end{array}\right); $$; then $D$ looks like:; $$; \left(\begin{array}{cccccc}; u & v & . & . & . & . \\; -v & u & . & . & . & . \\; . & . & a & b & . & . \\; . & . & . & -b & a & . \\; . & . & . & . & x & . \\; . & . & . & . & . & y; \end{array}\right); $$. This keeps $V$ a real matrix in both symmetric; and non-symmetric cases, and $A.V = V.D$. The matrix $V$ may be badly conditioned,; or even singular, so the validity of the equation $A = V.D.V^{-1}$ depends upon the; condition number of $V$. Next table shows the; methods of the classes **`TMatrixDEigen`** and **`TMatrixDSymEigen`** to; obtain the eigenvalues and eigenvectors. Obviously,; **`MatrixDSymEigen`** constructors can only be called with; **`TMatrixDSym`**:. +------------------------------+-----------+------------------------------------+; | Format | Output | Description |; +------------------------------+-----------+------------------------------------+; | `eig.GetEigenVectors` `()` | `TMatrixD | eigenvectors for both |; | | ` | `TMatrixDEigen` and |; | | | `TMatrixDSymEigen` |; +------------------------------+-----------+------------------------------------+; | `eig.GetEigenValues` `()` | `TVectorD | eigenvalues vector for |; | | ` | `TMatrixDSymEigen` |; +------------------------------+-----------+------------------------------------+; | `eig.GetEigenValues()` | `TMatrixD | eigenvalues matrix for |; | | ` | `TMatrixDEigen` |; +------------------------------+-----------+-----------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:47636,depend,depends,47636,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['depend'],['depends']
Integrability,"ents in some predefined configurations; might be embedded directly into the binary file name:. .. code-block:: shell. % bin/llvm-opt-fuzzer--x86_64-instcombine <corpus-dir>. llvm-mc-assemble-fuzzer; -----------------------. A |generic fuzzer| that fuzzes the MC layer's assemblers by treating inputs as; target specific assembly. Note that this fuzzer has an unusual command line interface which is not fully; compatible with all of libFuzzer's features. Fuzzer arguments must be passed; after ``--fuzzer-args``, and any ``llc`` flags must use two dashes. For; example, to fuzz the AArch64 assembler you might use the following command:. .. code-block:: console. llvm-mc-fuzzer --triple=aarch64-linux-gnu --fuzzer-args -max_len=4. This scheme will likely change in the future. llvm-mc-disassemble-fuzzer; --------------------------. A |generic fuzzer| that fuzzes the MC layer's disassemblers by treating inputs; as assembled binary data. Note that this fuzzer has an unusual command line interface which is not fully; compatible with all of libFuzzer's features. See the notes above about; ``llvm-mc-assemble-fuzzer`` for details. .. |generic fuzzer| replace:: :ref:`generic fuzzer <fuzzing-llvm-generic>`; .. |protobuf fuzzer|; replace:: :ref:`libprotobuf-mutator based fuzzer <fuzzing-llvm-protobuf>`; .. |LLVM IR fuzzer|; replace:: :ref:`structured LLVM IR fuzzer <fuzzing-llvm-ir>`. lldb-target-fuzzer; ---------------------. A |generic fuzzer| that interprets inputs as object files and uses them to; create a target in lldb. Mutators and Input Generators; =============================. The inputs for a fuzz target are generated via random mutations of a; :ref:`corpus <libfuzzer-corpus>`. There are a few options for the kinds of; mutations that a fuzzer in LLVM might want. .. _fuzzing-llvm-generic:. Generic Random Fuzzing; ----------------------. The most basic form of input mutation is to use the built in mutators of; LibFuzzer. These simply treat the input corpus as a bag of bits and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst:4931,interface,interface,4931,interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,1,['interface'],['interface']
Integrability,eordering declarations in class scope; Unknown. 1876; NAD; Preventing explicit specialization; Unknown. 1877; CD4; Return type deduction from return with no operand; Unknown. 1878; CD4; operator auto template; Clang 18. 1879; NAD; Inadequate definition of alignment requirement; Unknown. 1880; CD4; When are parameter objects destroyed?; Unknown. 1881; CD4; Standard-layout classes and unnamed bit-fields; Clang 7. 1882; CD4; Reserved names without library use; Unknown. 1883; drafting; Protected access to constructors in mem-initializers; Not resolved. 1884; CD6; Unclear requirements for same-named external-linkage entities; Unknown. 1885; CD4; Return value of a function is underspecified; Unknown. 1886; CD4; Language linkage for main(); Unknown. 1887; CD4; Problems with :: as nested-name-specifier; Unknown. 1888; CD4; Implicitly-declared default constructors and explicit; Unknown. 1889; drafting; Unclear effect of #pragma on conformance; Not resolved. 1890; drafting; Member type depending on definition of member function; No. 1891; CD4; Move constructor/assignment for closure class; Clang 4. 1892; CD4; Use of auto in function type; Unknown. 1893; CD5; Function-style cast with braced-init-lists and empty pack expansions; Unknown. 1894; CD6; typedef-names and using-declarations; Clang 3.8. 1895; CD4; Deleted conversions in conditional operator operands; Unknown. 1896; CD6; Repeated alias templates; Unknown. 1897; review; ODR vs alternative tokens; Not resolved. 1898; CD6; Use of “equivalent” in overload resolution; Unknown. 1899; CD4; Value-dependent constant expressions; Unknown. 1900; CD6; Do friend declarations count as “previous declarations”?; Unknown. 1901; drafting; punctuator referenced but not defined; Not resolved. 1902; CD4; What makes a conversion “otherwise ill-formed”?; Clang 3.7. 1903; CD4; What declarations are introduced by a non-member using-declaration?; Unknown. 1904; NAD; Default template arguments for members of class templates; Unknown. 1905; NAD; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:128370,depend,depending,128370,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['depending']
Integrability,"ependencies with pyproject.toml; * Simplified flow of pointer types for callbacks and cross-derivation; * Pointer-comparing objects performs auto-cast as needed; * Add main dimension for ptr-ptr to builtin returns; * Transparant handling of ptr-ptr to instance returns; * Stricter handling of bool type in overload with int types; * Fix uint64_t template instantiation regression; * Do not filter out enum data for ``__dir__``; * Fix lookup of interpreter-only explicit instantiations; * Fix inconsistent naming of std types with char_traits; * Further hiding of upstream code/dependencies; * Extended documentation. 2020-07-12: 1.8.0; -----------------. * Support mixing of Python and C++ types in global operators; * Capture Cling error messages from cppdef and include in the Python exception; * Add a cppexec method to evalutate statements in Cling's global scope; * Support initialization of ``std::array<>`` from sequences; * Support C++17 style initialization of common STL containers; * Allow base classes with no virtual destructor (with warning); * Support const by-value returns in Python-side method overrides; * Support for cross-language multiple inheritance of C++ bases; * Allow for pass-by-value of ``std::unique_ptr`` through move; * Reduced dependencies on upstream code; * Put remaining upstream code in CppyyLegacy namespace. 2020-06-06: 1.7.1; -----------------. * Expose protected members in Python derived classes; * Support for deep Python-side derived hierarchies; * Do not generate a copy ctor in the Python derived class if private; * include, c_include, and cppdef now raise exceptions on error; * Allow mixing of keywords and default values; * Fix by-ptr return of objects in Python derived classes; * Fix for passing numpy boolean array through ``bool*``; * Fix assignment to ``const char*`` data members; * Support ``__restrict`` and ``__restrict__`` in interfaces; * Allow passing sequence of strings through ``const char*[]`` argument. 2020-04-27: 1.7.0; -----------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:11887,message,messages,11887,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,2,"['depend', 'message']","['dependencies', 'messages']"
Integrability,"equentially lines up classes, whereas; multiple (virtual) inheritance usually requires thunks.; Thus, when calling base class methods on a derived instance, the latter; requires offset calculations that depend on that instance, whereas the former; has fixed offsets fully determined by the class definitions themselves.; By labeling classes appropriately, single inheritance classes (by far the; most common case) do not incur the overhead in PyPy's JIT-ed traces that is; otherwise unavoidable for multiple virtual inheritance.; As another example, consider that the C++ standard does not allow modifying; a ``std::vector`` while looping over it, whereas Python has no such; restriction, complicating loops.; Thus, cppyy has specialized ``std::vector`` iteration for both PyPy and; CPython, easily outperforming looping over an equivalent numpy array. In CPython, the performance of `non-overloaded` function calls depends; greatly on the Python interpreter's internal specializations; and Python3; has many specializations specific to basic extension modules (C function; pointer calls), gaining a performance boost of more than 30% over Python2.; Only since Python3.8 is there also better support for closure objects (vector; calls) as cppyy uses, to short-cut through the interpreter's own overhead. As a practical consideration, whether a binder performs well on code that you; care about, depends `entirely` on whether it has the relevant specializations; for your most performance-sensitive use cases.; The only way to know for sure is to write a test application and measure, but; a binder that provides more specializations, or makes it easy to add your; own, is more likely to deliver. `Manual v.s. automatic`; -----------------------. Python is, today, one of the most popular programming languages and has a; rich and mature eco-system around it.; But when the project that became cppyy started in the field of High Energy; Physics (HEP), Python usage was non-existent there.; As a Python",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:3737,depend,depends,3737,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['depend'],['depends']
Integrability,"equires using the subprocess execution; mode.; * `LLVM-EXEGESIS-MEM-MAP <value name> <address>` - This annotation allows for; mapping previously defined memory definitions into the execution context of a; process. The value name refers to a previously defined memory definition and; the address is a decimal number that specifies the address the memory; definition should start at. Note that a single memory definition can be; mapped multiple times. Using this annotation requires the subprocess; execution mode.; * `LLVM-EXEGESIS-SNIPPET-ADDRESS <address>` - This annotation allows for; setting the address where the beginning of the snippet to be executed will; be mapped in at. The address is given in hexadecimal. Note that the snippet; also includes setup code, so the instruction exactly at the specified; address will not be the first instruction in the snippet. Using this; annotation requires the subprocess execution mode. This is useful in; cases where the memory accessed by the snippet depends on the location; of the snippet, like RIP-relative addressing. EXAMPLE 1: benchmarking instructions; ------------------------------------. Assume you have an X86-64 machine. To measure the latency of a single; instruction, run:. .. code-block:: bash. $ llvm-exegesis --mode=latency --opcode-name=ADD64rr. Measuring the uop decomposition or inverse throughput of an instruction works similarly:. .. code-block:: bash. $ llvm-exegesis --mode=uops --opcode-name=ADD64rr; $ llvm-exegesis --mode=inverse_throughput --opcode-name=ADD64rr. The output is a YAML document (the default is to write to stdout, but you can; redirect the output to a file using `--benchmarks-file`):. .. code-block:: none. ---; key:; opcode_name: ADD64rr; mode: latency; config: ''; cpu_name: haswell; llvm_triple: x86_64-unknown-linux-gnu; num_repetitions: 10000; measurements:; - { key: latency, value: 1.0058, debug_string: '' }; error: ''; info: 'explicit self cycles, selecting one aliasing configuration.; Snippet:; AD",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:4644,depend,depends,4644,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,1,['depend'],['depends']
Integrability,"er 3 is corrupt. Size is 10 when it should be 20. This is a bad message, since it does not provide useful information and uses the; wrong style:. .. code-block:: none. error: file.o: Corrupt section header. As with other coding standards, individual projects, such as the Clang Static; Analyzer, may have preexisting styles that do not conform to this. If a; different formatting scheme is used consistently throughout the project, use; that style instead. Otherwise, this standard applies to all LLVM tools,; including clang, clang-tidy, and so on. If the tool or project does not have existing functions to emit warnings or; errors, use the error and warning handlers provided in ``Support/WithColor.h``; to ensure they are printed in the appropriate style, rather than printing to; stderr directly. When using ``report_fatal_error``, follow the same standards for the message as; regular error messages. Assertion messages and ``llvm_unreachable`` calls do not; necessarily need to follow these same styles as they are automatically; formatted, and thus these guidelines may not be suitable. ``#include`` Style; ^^^^^^^^^^^^^^^^^^. Immediately after the `header file comment`_ (and include guards if working on a; header file), the `minimal list of #includes`_ required by the file should be; listed. We prefer these ``#include``\s to be listed in this order:. .. _Main Module Header:; .. _Local/Private Headers:. #. Main Module Header; #. Local/Private Headers; #. LLVM project/subproject headers (``clang/...``, ``lldb/...``, ``llvm/...``, etc); #. System ``#include``\s. and each category should be sorted lexicographically by the full path. The `Main Module Header`_ file applies to ``.cpp`` files which implement an; interface defined by a ``.h`` file. This ``#include`` should always be included; **first** regardless of where it lives on the file system. By including a; header file first in the ``.cpp`` files that implement the interfaces, we ensure; that the header does not have any hid",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:15543,message,messages,15543,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['message'],['messages']
Integrability,"er ``D0``. A 32-bit integer is returned in register ``I0`` or ``I1``. .. code-block:: text. def RetCC_Sparc32 : CallingConv<[; CCIfType<[i32], CCAssignToReg<[I0, I1]>>,; CCIfType<[f32], CCAssignToReg<[F0]>>,; CCIfType<[f64], CCAssignToReg<[D0]>>; ]>;. The definition of ``CC_Sparc32`` in ``SparcCallingConv.td`` introduces; ``CCAssignToStack``, which assigns the value to a stack slot with the specified; size and alignment. In the example below, the first parameter, 4, indicates; the size of the slot, and the second parameter, also 4, indicates the stack; alignment along 4-byte units. (Special cases: if size is zero, then the ABI; size is used; if alignment is zero, then the ABI alignment is used.). .. code-block:: text. def CC_Sparc32 : CallingConv<[; // All arguments get passed in integer registers if there is space.; CCIfType<[i32, f32, f64], CCAssignToReg<[I0, I1, I2, I3, I4, I5]>>,; CCAssignToStack<4, 4>; ]>;. ``CCDelegateTo`` is another commonly used interface, which tries to find a; specified sub-calling convention, and, if a match is found, it is invoked. In; the following example (in ``X86CallingConv.td``), the definition of; ``RetCC_X86_32_C`` ends with ``CCDelegateTo``. After the current value is; assigned to the register ``ST0`` or ``ST1``, the ``RetCC_X86Common`` is; invoked. .. code-block:: text. def RetCC_X86_32_C : CallingConv<[; CCIfType<[f32], CCAssignToReg<[ST0, ST1]>>,; CCIfType<[f64], CCAssignToReg<[ST0, ST1]>>,; CCDelegateTo<RetCC_X86Common>; ]>;. ``CCIfCC`` is an interface that attempts to match the given name to the current; calling convention. If the name identifies the current calling convention,; then a specified action is invoked. In the following example (in; ``X86CallingConv.td``), if the ``Fast`` calling convention is in use, then; ``RetCC_X86_32_Fast`` is invoked. If the ``SSECall`` calling convention is in; use, then ``RetCC_X86_32_SSE`` is invoked. .. code-block:: text. def RetCC_X86_32 : CallingConv<[; CCIfCC<""CallingConv::Fast"", CCDel",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:64100,interface,interface,64100,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['interface'],['interface']
Integrability,"er arithmetic or array access, as; these operations would immediately cause the pointer to exceed its bounds.; Consequently, this prompts programmers to provide sufficient bounds information; to pointers. In the following example, the pointer on parameter p is; single-by-default, and is employed for array access. As a result, the compiler; generates an error suggesting to add ``__counted_by`` to the pointer. .. code-block:: c. void fill_array_with_indices(int *p, unsigned count) {; for (unsigned i = 0; i < count; ++i) {; p[i] = i; // error; }; }. External bounds annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. ""External"" bounds annotations provide a way to express a relationship between a; pointer variable and another variable (or expression) containing the bounds; information of the pointer. In the following example, ``__counted_by(count)``; annotation expresses the bounds of parameter p using another parameter count.; This model works naturally with many C interfaces and structs because the bounds; of a pointer is often available adjacent to the pointer itself, e.g., at another; parameter of the same function prototype, or at another field of the same struct; declaration. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, size_t count) {; // off-by-one error; for (size_t i = 0; i <= count; ++i); p[i] = i;; }. External bounds annotations include ``__counted_by``, ``__sized_by``, and; ``__ended_by``. These annotations do not change the pointer representation,; meaning they do not have ABI implications. * ``__counted_by(N)`` : The pointer points to memory that contains ``N``; elements of pointee type. ``N`` is an expression of integer type which can be; a simple reference to declaration, a constant including calls to constant; functions, or an arithmetic expression that does not have side effect. The; ``__counted_by`` annotation cannot apply to pointers to incomplete types or; types without size such as ``void *``. Instead, ``__sized_by`` can be use",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:9343,interface,interfaces,9343,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['interface'],['interfaces']
Integrability,"er contents. Many improvements in text and axis rendering for orthographic; view markup. In TGLSceneBase add data-member Bool_t; fSelectable allowing one to preventing any of its elements to be; selected. Useful when given scene is used as background to help guid; the eye. Eve. Added support for internal window management. Windows can be; arranged in horizontal/vertical stacks, tabs and main windows.; The containers and individaul windows can be moved to arbitrary; window-slot. See classes TEveWindow and TEveWindowManager. See tutorial tutorials/eve/test_windows.C. TEveQuadSet -- Add flag 'Bool_t fAntiFlick'. If on (now the; default) it causes each quad to be also rendered as a pixel, thus; preventing it from disappearing when zoomed away. This is needed for visualization of small quads, e.g. silicon; detectors digits. TEveCalo classes -- Add support for automatic rebinning; of 3D views (only supported for 2D views before). In 2D mode support; automatic determination of the cell color based on the most energetic; contribution from available calo slices. Add support for enumerative registration of calorimeter towers. Before; one had to provide THStack as input. See TEveCaloDataVec; class. TEveTrackList -- Generalized API for finding of momentum; limits. TEveTrackPropagator now supports propagation of charged; particles in arbitrary / external magnetic field. Propagation can be; done with the helix-stepper or with the Runge-Kutta method. New abstract interface to magnetic field TEveMagField to get; field vector at given position. Implement two interfaces:; TEveMagFieldConst for constant magnetic field and; TEveMagFieldDuo (two constant magnetic fields, chosen by; cylindrical radius). See examples in tutorials/eve/track.C. TEvePointSetArray -- Added underflow and overflow bins. Many improvements in text and axis rendering for axes in; non-linear projections and for the dedicated lego view. New tutorial tutorials/eve/lineset_test.py showing how; tu run Eve from python. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v522/index.html:1873,interface,interface,1873,graf3d/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v522/index.html,2,['interface'],"['interface', 'interfaces']"
Integrability,"er files should be self-contained (compile on their own) and end in ``.h``.; Non-header files that are meant for inclusion should end in ``.inc`` and be; used sparingly. All header files should be self-contained. Users and refactoring tools should; not have to adhere to special conditions to include the header. Specifically, a; header should have header guards and include all other headers it needs. There are rare cases where a file designed to be included is not; self-contained. These are typically intended to be included at unusual; locations, such as the middle of another file. They might not use header; guards, and might not include their prerequisites. Name such files with the; .inc extension. Use sparingly, and prefer self-contained headers when possible. In general, a header should be implemented by one or more ``.cpp`` files. Each; of these ``.cpp`` files should include the header that defines their interface; first. This ensures that all of the dependences of the header have been; properly added to the header itself, and are not implicit. System headers; should be included after user headers for a translation unit. Library Layering; ^^^^^^^^^^^^^^^^. A directory of header files (for example ``include/llvm/Foo``) defines a; library (``Foo``). One library (both; its headers and implementation) should only use things from the libraries; listed in its dependencies. Some of this constraint can be enforced by classic Unix linkers (Mac & Windows; linkers, as well as lld, do not enforce this constraint). A Unix linker; searches left to right through the libraries specified on its command line and; never revisits a library. In this way, no circular dependencies between; libraries can exist. This doesn't fully enforce all inter-library dependencies, and importantly; doesn't enforce header file circular dependencies created by inline functions.; A good way to answer the ""is this layered correctly"" would be to consider; whether a Unix linker would succeed at linking the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:30263,depend,dependences,30263,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['depend'],['dependences']
Integrability,"er function; ROOT::Math::Functor1D f3(&myf1,&MyFunction1D::Eval);. cout << f1(2) << endl;; cout << f2(2) << endl;; cout << f3(2) << endl;. return 0;; }; ```. #### Wrapping One Dimensional Gradient Functions. The `ROOT::Math::GradFunctor1D` class is used to wrap one-dimensional gradient functions. It can be constructed in three different ways:; * Any object implementing both `double operator()( double)` for the function evaluation and `double Derivative(double)` for the function derivative.; * Any object implementing any member function like `Foo::XXX(double )` for the function evaluation and any other member function like `Foo::YYY(double )` for the derivative.; * Any two function objects implementing `double operator()( double )` . One object provides the function evaluation, the other the derivative. One or both function object can be a free C function of; type `double ()(double )`. #### Wrapping Multi-dimensional Functions. The class `ROOT::Math::Functor` is used to wrap in a very simple and convenient way multi-dimensional function objects. It can wrap all the following types:; * Any C++ callable object implementing `double operator()( const double * )`.; * A free C function of type `double ()(const double * )`.; * A member function with the correct signature like `Foo::Eval(const double * )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. The function dimension is required when constructing the functor. Example of using `Functor`:; ```{.cpp}; #include ""Math/Functor.h"". class MyFunction {. public:; double operator()(const double *x) const {; return x[0]+x[1];; }. double Eval(const double * x) const { return x[0]+x[1]; }; };. double freeFunction(const double * x ); {; return x[0]+x[1];; }. int main(); {; // test directly calling the function object; MyFunction myf;. // test from a free function pointer; ROOT::Math::Functor f1(&freeFunction,2);. // test from function object; ROOT::Math::Functor f2(myf,2);. // test fro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:44858,wrap,wrap,44858,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['wrap'],['wrap']
Integrability,"er matcher matches on that instance. For example the method call in; NSString *x = @""hello"";; [x containsString:@""h""];; is matched by; objcMessageExpr(hasReceiver(declRefExpr(to(varDecl(hasName(""x"")))))). Matcher<ObjCMessageExpr>hasReceiverTypeMatcher<QualType> InnerMatcher; Matches on the receiver of an ObjectiveC Message expression. Example; matcher = objCMessageExpr(hasReceiverType(asString(""UIWebView *"")));; matches the [webView ...] message invocation.; NSString *webViewJavaScript = ...; UIWebView *webView = ...; [webView stringByEvaluatingJavaScriptFromString:webViewJavascript];. Matcher<ObjCMethodDecl>hasAnyParameterMatcher<ParmVarDecl> InnerMatcher; Matches any parameter of a function or an ObjC method declaration or a; block. Does not match the 'this' parameter of a method. Given; class X { void f(int x, int y, int z) {} };; cxxMethodDecl(hasAnyParameter(hasName(""y""))); matches f(int x, int y, int z) {}; with hasAnyParameter(...); matching int y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasAnyParameter(hasName(""y""))); matches the declaration of method f with hasParameter; matching y. For blocks, given; b = ^(int y) { printf(""%d"", y) };. the matcher blockDecl(hasAnyParameter(hasName(""y""))); matches the declaration of the block b with hasParameter; matching y. Matcher<ObjCMethodDecl>hasParameterunsigned N, Matcher<ParmVarDecl> InnerMatcher; Matches the n'th parameter of a function or an ObjC method; declaration or a block. Given; class X { void f(int x) {} };; cxxMethodDecl(hasParameter(0, hasType(varDecl()))); matches f(int x) {}; with hasParameter(...); matching int x. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasParameter(0, hasName(""y""))); matches the declaration of method f with hasParameter; matching y. Matcher<ObjCPropertyDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:222544,interface,interface,222544,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['interface'],['interface']
Integrability,"er of formal arguments. A method may be an instance method, in which case; it can be invoked on objects of the class, or a class method, in which case it; can be invoked on objects of the metaclass. A method may be invoked by; providing an object (called the :arc-term:`receiver`) and a list of formal; arguments interspersed with the selector, like so:. .. code-block:: objc. [receiver foo: fooArg bar: barArg baz: bazArg]. This looks in the dynamic class of the receiver for a method with this name,; then in that class's superclass, etc., until it finds something it can execute.; The receiver ""expression"" may also be the name of a class, in which case the; actual receiver is the class object for that class, or (within method; definitions) it may be ``super``, in which case the lookup algorithm starts; with the static superclass instead of the dynamic class. The actual methods; dynamically found in a class are not those declared in the ``@interface``, but; those defined in a separate ``@implementation`` declaration; however, when; compiling a call, typechecking is done based on the methods declared in the; ``@interface``. Method declarations may also be grouped into :arc-term:`protocols`, which are not; inherently associated with any class, but which classes may claim to follow.; Object pointer types may be qualified with additional protocols that the object; is known to support. :arc-term:`Class extensions` are collections of ivars and methods, designed to; allow a class's ``@interface`` to be split across multiple files; however,; there is still a primary implementation file which must see the; ``@interface``\ s of all class extensions. :arc-term:`Categories` allow; methods (but not ivars) to be declared *post hoc* on an arbitrary class; the; methods in the category's ``@implementation`` will be dynamically added to that; class's method tables which the category is loaded at runtime, replacing those; methods in case of a collision. In the standard environment, objects ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:5578,interface,interface,5578,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['interface'],['interface']
Integrability,"er options that were used to; compile the ROOT executable. You do not have to write a Makefile; remembering the correct compiler options, and you do not have to exit; ROOT. ### Usage. Before you can compile your interpreted script you need to add include; statements for the classes used in the script. Once you did that, you; can build and load a shared library containing your script. To load it; use the command `.L` and append the file name with a `+`. ``` {.cpp}; root[] .L MyScript.C+; ```. The + option generates the shared library and names it by taking; the name of the file ""filename"" but replacing the dot before the; extension by an underscore and by adding the shared library extension; for the current platform. For example on most platforms, `hsimple.cxx`; will generate `hsimple_cxx.so`. The + command rebuild the library only if the script or any of the; files it includes are newer than the library. When checking the; timestamp, ACLiC generates a dependency file which name is the same as; the library name, just replacing the 'so' extension by the extension; 'd'. For example on most platforms, `hsimple.cxx` will generate; `hsimple_cxx.d`. To ensure that the shared library is rebuilt you can use the ++; syntax:. ``` {.cpp}; root[] .L MyScript.C++; ```. To build, load, and execute the function with the same name as the; file you can use the `.x` command. This is the same as executing a; named script; you can also provide parameters. The only; difference is you need to append a + or a ++. ``` {.cpp}; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; ```. You can select whether the script in compiled with debug symbol or; with optimization by appending the letter 'g' or 'O' after the '+' or; '++'. Without the specification, the script is compiled with the same; level of debugging symbol and optimization as the currently running; ROOT executable. For example:. ``` {.cpp}; root[] .L MyScript.C++g; ```. will compile `MyScript.C` with debug sym",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:14218,depend,dependency,14218,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['depend'],['dependency']
Integrability,"er or generated by TableGen. Associated with that name; is a list of *fields* with values and an optional list of *parent classes*; (sometimes called base or super classes). The fields are the primary data that; backends will process. Note that TableGen assigns no meanings to fields; the; meanings are entirely up to the backends and the programs that incorporate; the output of those backends. .. note::. The term ""parent class"" can refer to a class that is a parent of another; class, and also to a class from which a concrete record inherits. This; nonstandard use of the term arises because TableGen treats classes and; concrete records similarly. A backend processes some subset of the concrete records built by the; TableGen parser and emits the output files. These files are usually C++; ``.inc`` files that are included by the programs that require the data in; those records. However, a backend can produce any type of output files. For; example, it could produce a data file containing messages tagged with; identifiers and substitution parameters. In a complex use case such as the; LLVM code generator, there can be many concrete records and some of them can; have an unexpectedly large number of fields, resulting in large output files. In order to reduce the complexity of TableGen files, classes are used to; abstract out groups of record fields. For example, a few classes may; abstract the concept of a machine register file, while other classes may; abstract the instruction formats, and still others may abstract the; individual instructions. TableGen allows an arbitrary hierarchy of classes,; so that the abstract classes for two concepts can share a third superclass that; abstracts common ""sub-concepts"" from the two original concepts. In order to make classes more useful, a concrete record (or another class); can request a class as a parent class and pass *template arguments* to it.; These template arguments can be used in the fields of the parent class to; initialize the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:3560,message,messages,3560,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['message'],['messages']
Integrability,"er outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). NCycles No 3000 − Number of training cycles. HiddenLayers No N,N-1 − Specification of hidden layer architecture. Configuration options for MVA method :. Configuration options reference for MVA method: KNN. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). nkNN No 20 − Number of k-nearest neighbors. BalanceDepth No 6 − Binary tree balance depth. ScaleFrac No 0.8 − Fraction of events used to compute variable width. SigmaFact No 1 − Scale factor for sigma in Gaussian kernel. Kernel No Gaus − Use polynomial (=Poln) or Gaussian (=Gaus) kernel. Trim No False − Use equal number of signal and background events. UseKernel No False − Use polynomial kernel weight. UseWeight No True − Use weight to count kNN events. UseLDA No False − Use local linear discriminant - experimental feature. Configuration options for MVA method :. Configuration options reference for MVA method: BDT. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLev",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:10129,message,message,10129,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['message'],['message']
Integrability,"er than ``long double``. .. option:: -f[no-]protect-parens. This option pertains to floating-point types, complex types with; floating-point components, and vectors of these types. Some arithmetic; expression transformations that are mathematically correct and permissible; according to the C and C++ language standards may be incorrect when dealing; with floating-point types, such as reassociation and distribution. Further,; the optimizer may ignore parentheses when computing arithmetic expressions; in circumstances where the parenthesized and unparenthesized expression; express the same mathematical value. For example (a+b)+c is the same; mathematical value as a+(b+c), but the optimizer is free to evaluate the; additions in any order regardless of the parentheses. When enabled, this; option forces the optimizer to honor the order of operations with respect; to parentheses in all circumstances.; Defaults to ``-fno-protect-parens``. Note that floating-point contraction (option `-ffp-contract=`) is disabled; when `-fprotect-parens` is enabled. Also note that in safe floating-point; modes, such as `-ffp-model=precise` or `-ffp-model=strict`, this option; has no effect because the optimizer is prohibited from making unsafe; transformations. .. option:: -fexcess-precision:. The C and C++ standards allow floating-point expressions to be computed as if; intermediate results had more precision (and/or a wider range) than the type; of the expression strictly allows. This is called excess precision; arithmetic.; Excess precision arithmetic can improve the accuracy of results (although not; always), and it can make computation significantly faster if the target lacks; direct hardware support for arithmetic in a particular type. However, it can; also undermine strict floating-point reproducibility. Under the standards, assignments and explicit casts force the operand to be; converted to its formal type, discarding any excess precision. Because data; can only flow between stateme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:65966,contract,contraction,65966,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,2,['contract'],"['contract', 'contraction']"
Integrability,"er the network. If the request is accepted, it; returns a full-duplex socket. Once the connection is accepted, we can; communicate to the client that we are ready to go by sending the string; ""go"", and we can close the server socket. ``` {.cpp}; { // server; TServerSocket *ss = new TServerSocket(9090,kTRUE);; TSocket *socket = ss->Accept();; socket->Send(""go"");; ss->Close();; }; ```. *On the clientside*, we create a socket and ask the socket to receive; input. ``` {.cpp}; { // client; TSocket *socket = new TSocket(""localhost"",9090);; Char str[32];; socket->Recv(str,32);; }; ```. ## Sending Objects over the Network. We have just established a connection and you just saw how to send and; receive a string with the example ""go"". Now let's send a histogram. *To send an object (in our case on the client side*) it has to derive; from **`TObject`** class because it uses the `Streamers` to fill a; buffer that is then sent over the connection. On the receiving side, the; `Streamers` are used to read the object from the message sent via the; socket. For network communication, we have a specialized **`TBuffer`**,; a descendant of **`TBuffer`** called **`TMessage`**. In the following; example, we create a **`TMessage`** with the intention to store an; object, hence the constant `kMESS_OBJECT` in the constructor. We create; and fill the histogram and write it into the message. Then we call; **`TSocket`**`::Send` to send the message with the histogram. ``` {.cpp}; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; ```. On the receiving end (in our case the server side), we write a while; loop to wait and receive a message with a histogram. Once we have a; message, we call `TMessage::ReadObject`, which returns a po",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md:1254,message,message,1254,documentation/users-guide/Networking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Networking.md,1,['message'],['message']
Integrability,"er(nullptr /*Dump to stdout.*/,; this->ASTDumpFilter);; if (this->ASTPrint.operator _Bool()); return clang::CreateASTPrinter(&llvm::outs(), this->ASTDumpFilter);; return new clang::ASTConsumer();; }. Using Ninja Build System; =======================================. Optionally you can use the `Ninja`_ build system instead of make. It is; aimed at making your builds faster. Currently this step will require; building Ninja from sources. To take advantage of using Clang Tools along with Ninja build you need; at least CMake 2.8.9. Clone the Ninja git repository and build Ninja from sources:. .. code-block:: console. $ git clone git://github.com/martine/ninja.git; $ cd ninja/; $ ./bootstrap.py. This will result in a single binary ``ninja`` in the current directory.; It doesn't require installation and can just be copied to any location; inside ``$PATH``, say ``/usr/local/bin/``:. .. code-block:: console. $ sudo cp ninja /usr/local/bin/; $ sudo chmod a+rx /usr/local/bin/ninja. After doing all of this, you'll need to generate Ninja build files for; LLVM with CMake. You need to make a build directory and run CMake from; it:. .. code-block:: console. $ mkdir your/build/directory; $ cd your/build/directory; $ cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. If you want to use clang instead of GCC, you can add; ``-DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables in an interactive manner. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using Ninja:. .. code-block:: console. $ ninja check-all. Other target names can be used in the same way as with make. .. _Ninja: https://ninja-build.org/; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:8950,interface,interface,8950,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,1,['interface'],['interface']
Integrability,er-rt/lib/scudo/standalone/report.cpp; compiler-rt/lib/scudo/standalone/report.h; compiler-rt/lib/scudo/standalone/secondary.h; compiler-rt/lib/scudo/standalone/size_class_map.h; compiler-rt/lib/scudo/standalone/stack_depot.h; compiler-rt/lib/scudo/standalone/stats.h; compiler-rt/lib/scudo/standalone/string_utils.cpp; compiler-rt/lib/scudo/standalone/string_utils.h; compiler-rt/lib/scudo/standalone/trusty.cpp; compiler-rt/lib/scudo/standalone/trusty.h; compiler-rt/lib/scudo/standalone/tsd.h; compiler-rt/lib/scudo/standalone/tsd_exclusive.h; compiler-rt/lib/scudo/standalone/tsd_shared.h; compiler-rt/lib/scudo/standalone/vector.h; compiler-rt/lib/scudo/standalone/wrappers_c.cpp; compiler-rt/lib/scudo/standalone/wrappers_c.h; compiler-rt/lib/scudo/standalone/wrappers_c_bionic.cpp; compiler-rt/lib/scudo/standalone/wrappers_c_checks.h; compiler-rt/lib/scudo/standalone/benchmarks/malloc_benchmark.cpp; compiler-rt/lib/scudo/standalone/fuzz/get_error_info_fuzzer.cpp; compiler-rt/lib/scudo/standalone/include/scudo/interface.h; compiler-rt/lib/scudo/standalone/tests/atomic_test.cpp; compiler-rt/lib/scudo/standalone/tests/bytemap_test.cpp; compiler-rt/lib/scudo/standalone/tests/checksum_test.cpp; compiler-rt/lib/scudo/standalone/tests/chunk_test.cpp; compiler-rt/lib/scudo/standalone/tests/combined_test.cpp; compiler-rt/lib/scudo/standalone/tests/common_test.cpp; compiler-rt/lib/scudo/standalone/tests/flags_test.cpp; compiler-rt/lib/scudo/standalone/tests/list_test.cpp; compiler-rt/lib/scudo/standalone/tests/map_test.cpp; compiler-rt/lib/scudo/standalone/tests/memtag_test.cpp; compiler-rt/lib/scudo/standalone/tests/mutex_test.cpp; compiler-rt/lib/scudo/standalone/tests/primary_test.cpp; compiler-rt/lib/scudo/standalone/tests/quarantine_test.cpp; compiler-rt/lib/scudo/standalone/tests/release_test.cpp; compiler-rt/lib/scudo/standalone/tests/report_test.cpp; compiler-rt/lib/scudo/standalone/tests/scudo_unit_test.h; compiler-rt/lib/scudo/standalone/tests/scudo_unit_test_main.cpp; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:102294,interface,interface,102294,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['interface'],['interface']
Integrability,"er.Parse(“./example_model.onnx”);; model.Generate();; model.OutputGenerated(“./example_output.hxx”);; ```; And an C++ header file will be generated. In addition also a text file, `example_output.dat` will be also generated. This file will contain the model weight values that will be used to initialize the model.; A full example for parsing an ONNX input file is given by the tutorial [`TMVA_SOFIE_ONNX.C`](https://root.cern/doc/master/TMVA__SOFIE__ONNX_8C.html). To use the generated inference code, you need to create a `Session` class and call the function `Session::inder(float *)`:. ```; #include ""example_output.hxx""; float input[INPUT_SIZE] = {.....}; // input data; TMVA_SOFIE_example_model::Session s(""example_output.dat"");; std::vector<float> out = s.infer(input);; ```. For using the ONNX parser you need to build ROOT with the configure option `tmva-sofie=ON`, which will be enabled when a Google Protocol Buffer library (`protobuf`, see https://developers.google.com/protocol-buffers) is found in your system. If you don't have `protobuf` and you don't want to install you can still use SOFIE, although with some more limited operator support parsing directly Keras `.h5` input files or PyTorch `.pt` files.; In tis case you can convert directly the model to a `RModel` representation which can be used as above to generate the header and the weight file. For parsing a Keras input file you need to do:; ```; SOFIE::RModel model = SOFIE::PyKeras::Parse(""KerasModel.h5"");; ```; See the tutorial [`TMVA_SOFIE_Keras.C`](https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html).; For parsing a PyTorch input file :; ```; SOFIE::RModel model = SOFIE::PyTorch::Parse(""PyTorchModel.pt"",inputShapes);; ```; where `inputShapes` is a `std::vector<std::vector<size_t>>` defining the inputs shape tensors. This information is required by PyTorch since it is not stored in the model.; A full example for parsing a PyTorch file is in the [`TMVA_SOFIE_PyTorch.C`](https://root.cern/doc/master/TMVA__SO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:34178,protocol,protocol-buffers,34178,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['protocol'],['protocol-buffers']
Integrability,"er/group__vecops.html#ga59cc6e477803f2bfd7dae29e56048cc1), [Product](https://root.cern/doc/master/group__vecops.html#ga25e4c2cf5c82fe56dd6bbc86b2386b69) and Enumerate; - the [Take](https://root.cern/doc/master/group__vecops.html#gac719439afb1ec9d32a28acdc7aee5948) helper function now allows passing a default value that will be used to fill the output array in case it's longer than the input. ## RooFit Libraries. ### Consistent definition of the default minimizer type for all of RooFit/RooStats. In previous releases, the default minimizer type that RooFit used was hardcoded to be the original `Minuit`, while RooStats used the default minimizer specified by `ROOT::Math::MinimizerOptions::DefaultMinimizerType()`. Now it is possible to centrally define the global minimizer for all RooFit libraries via `ROOT::Math::MinimizerOptions::SetDefaultMinimizer()`, or alternatively in the `.rootrc` file by adding for example `Root.Fitter: Minuit2` to select Minuit2. ### Code modernization by using `std::string` in RooFit interfaces. The following lesser-used RooFit functions now return a `std::string` instead of a `const char*`, potentially requiring the update of your code:. - [std::string RooCmdConfig::missingArgs() const](https://root.cern/doc/v628/classRooCmdConfig.html#aec50335293c45a507d347c604bf9651f); ### Uniquely identifying RooArgSet and RooDataSet objects. Before v6.28, it was ensured that no `RooArgSet` and `RooDataSet` objects on the heap were located at an address that had already been used for an instance of the same class before.; With v6.28, this is not guaranteed anymore.; Hence, if your code uses pointer comparisons to uniquely identify RooArgSet or RooDataSet instances, please consider using the new `RooArgSet::uniqueId()` or `RooAbsData::uniqueId()`. ### Introducing binned likelihood fit optimization in HistFactory. In a binned likelihood fit, it is possible to skip the PDF normalization when; the unnormalized binned PDF can be interpreted directly in terms o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:19319,interface,interfaces,19319,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['interface'],['interfaces']
Integrability,"er2) {; if (condition) {; // ... lots of code ...; leak(*pointer1);; } else {; // ... more code ...; leak(*pointer2);; }; }; ```. This would get transformed into something resembling the following:; ```; uintptr_t all_ones_mask = std::numerical_limits<uintptr_t>::max();; uintptr_t all_zeros_mask = 0;; void leak(int data);; void example(int* pointer1, int* pointer2) {; uintptr_t predicate_state = all_ones_mask;; if (condition) {; // Assuming ?: is implemented using branchless logic...; predicate_state = !condition ? all_zeros_mask : predicate_state;; // ... lots of code ...; //; // Harden the pointer so it can't be loaded; pointer1 &= predicate_state;; leak(*pointer1);; } else {; predicate_state = condition ? all_zeros_mask : predicate_state;; // ... more code ...; //; // Alternative: Harden the loaded value; int value2 = *pointer2 & predicate_state;; leak(value2);; }; }; ```. The result should be that if the `if (condition) {` branch is mis-predicted,; there is a *data* dependency on the condition used to zero out any pointers; prior to loading through them or to zero out all of the loaded bits. Even; though this code pattern may still execute speculatively, *invalid* speculative; executions are prevented from leaking secret data from memory (but note that; this data might still be loaded in safe ways, and some regions of memory are; required to not hold secrets, see below for detailed limitations). This; approach only requires the underlying hardware have a way to implement a; branchless and unpredicted conditional update of a register's value. All modern; architectures have support for this, and in fact such support is necessary to; correctly implement constant time cryptographic primitives. Crucial properties of this approach:; * It is not preventing any particular side-channel from working. This is; important as there are an unknown number of potential side channels and we; expect to continue discovering more. Instead, it prevents the observation of; secret data",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:4342,depend,dependency,4342,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['depend'],['dependency']
Integrability,"er; ------------------. Changes can be reviewed by anyone in the LLVM community who has commit; access.For larger and more complicated changes, it's important that the; reviewer has experience with the area of LLVM and knows the design goals; well. The author of a change will often assign a specific reviewer (git; blame and git log can be useful to find one). As our change is fairly simple, we'll add the cfe-commits mailing list; as a subscriber; anyone who works on clang can likely pick up the; review. (For changes outside clang, llvm-commits is the usual list. See; `http://lists.llvm.org/ <http://lists.llvm.org/mailman/listinfo>`__ for; all the \*-commits mailing lists). Uploading a change for review; -----------------------------. LLVM code reviews happen through pull-request on GitHub, see; :ref:`GitHub <github-reviews>` documentation for how to open; a pull-request on GitHub. Review process; --------------. When you open a pull-request, some automation will add a comment and; notify different member of the projects depending on the component you; changed.; Within a few days, someone should start the review. They may add; themselves as a reviewer, or simply start leaving comments. You'll get; another email any time the review is updated. The details are in the; `https://llvm.org/docs/CodeReview/ <https://llvm.org/docs/CodeReview.html>`__. Comments; ~~~~~~~~. The reviewer can leave comments on the change, and you can reply. Some; comments are attached to specific lines, and appear interleaved with the; code. You can either reply to these, or address them and mark them as; ""done"". Note that in-line replies are **not** sent straight away! They; become ""draft"" comments and you must click ""Submit"" at the bottom of the; page. Updating your change; ~~~~~~~~~~~~~~~~~~~~. If you make changes in response to a reviewer's comments, simply update; your branch with more commits and push to your fork. It may be a good; idea to answer the comments from the reviewer explicitly. A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:9961,depend,depending,9961,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['depend'],['depending']
Integrability,"erExpr(); matches this->x, x, y.x, a, this->b. Matcher<Stmt>nullStmtMatcher<NullStmt>...; Matches null statements. foo();;; nullStmt(); matches the second ';'. Matcher<Stmt>objcCatchStmtMatcher<ObjCAtCatchStmt>...; Matches Objective-C @catch statements. Example matches @catch; @try {}; @catch (...) {}. Matcher<Stmt>objcFinallyStmtMatcher<ObjCAtFinallyStmt>...; Matches Objective-C @finally statements. Example matches @finally; @try {}; @finally {}. Matcher<Stmt>objcIvarRefExprMatcher<ObjCIvarRefExpr>...; Matches a reference to an ObjCIvar. Example: matches ""a"" in ""init"" method:; @implementation A {; NSString *a;; }; - (void) init {; a = @""hello"";; }. Matcher<Stmt>objcMessageExprMatcher<ObjCMessageExpr>...; Matches ObjectiveC Message invocation expressions. The innermost message send invokes the ""alloc"" class method on the; NSString class, while the outermost message send invokes the; ""initWithString"" instance method on the object returned from; NSString's ""alloc"". This matcher should match both message sends.; [[NSString alloc] initWithString:@""Hello""]. Matcher<Stmt>objcStringLiteralMatcher<ObjCStringLiteral>...; Matches ObjectiveC String literal expressions. Example matches @""abcd""; NSString *s = @""abcd"";. Matcher<Stmt>objcThrowStmtMatcher<ObjCAtThrowStmt>...; Matches Objective-C statements. Example matches @throw obj;. Matcher<Stmt>objcTryStmtMatcher<ObjCAtTryStmt>...; Matches Objective-C @try statements. Example matches @try; @try {}; @catch (...) {}. Matcher<Stmt>ompExecutableDirectiveMatcher<OMPExecutableDirective>...; Matches any ``#pragma omp`` executable directive. Given. #pragma omp parallel; #pragma omp parallel default(none); #pragma omp taskyield. ``ompExecutableDirective()`` matches ``omp parallel``,; ``omp parallel default(none)`` and ``omp taskyield``. Matcher<Stmt>opaqueValueExprMatcher<OpaqueValueExpr>...; Matches opaque value expressions. They are used as helpers; to reference another expressions and can be met; in BinaryConditionalOperators, for ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:38687,message,message,38687,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['message'],['message']
Integrability,"erSetting` class.; This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter. ``` {.cpp}; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; ```. Note that a `ROOT::Fit::ParameterSettings` objects exists for each fit parameter and it created by the `ROOT::Fit::FitConfig` class, after the model function has been set in the Fitter.; Only when the function is set, the number of parameter is known and; automatically the `FitConfig` creates the corresponding `ParameterSetting` objects. When fitting, different minimizer can be used. The can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT.; Each different minimizer (e.g. *Minuit, Minuit2, Fumili,* etc.) consists of a different implementation of the `ROOT::Math::Minimizer` interface.; Within the same minimizer, thus within the same class implementing the `Minimizer` interface, different algorithms can exist.; For example in the case of Minuit, we have *Migrad, Simplex* or *Minimize*. The minimizer and its corresponding algorithm, when available,; can be set by using the function `FitConfig::SetMinimizer(""minimizerName"")` or by using directly the `ROOT:Math::MinimizerOptions` class. If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the; static function `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName"")`. ### Minimizer Libraries and Algorithms. The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following one.; Some minimizers (e.g. *Minuit*) contain several algorithms that the user can; choose. Others are based on a single algorithm (e.g. *Fumili*). - **`Minuit`** (library *libMinuit*). Old version of Minuit, based on the `TMinuit` class. The list",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:40104,interface,interface,40104,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['interface'],['interface']
Integrability,"er_number>`.; ======================================================== ====================================================================. Note: *N* and *K* must satisfy the following conditions:. * *N* must be properly aligned based on the sequence size.; * *N* <= *K*.; * 0 <= *N* < *SMAX*\ , where *SMAX* is the number of available *scalar* registers.; * 0 <= *K* < *SMAX*\ , where *SMAX* is the number of available *scalar* registers.; * *K-N+1* must be in the range from 1 to 12 or equal to 16 or 32. Examples:. .. parsed-literal::. s0; s[0]; s[0:1]; s[1:1]; s[0:3]; s[2*2]; s[1-1:2-1]; [s4]; [s4,s5,s6,s7]. Examples of *scalar* registers with an invalid alignment:. .. parsed-literal::. s[1:2]; s[2:5]. .. _amdgpu_synid_trap:. trap; ----. A set of trap handler registers:. * :ref:`ttmp<amdgpu_synid_ttmp>`; * :ref:`tba<amdgpu_synid_tba>`; * :ref:`tma<amdgpu_synid_tma>`. .. _amdgpu_synid_ttmp:. ttmp; ----. Trap handler temporary scalar registers, 32-bits wide.; The number of available *ttmp* registers depends on the GPU:. ======= ===========================; GPU Number of *ttmp* registers; ======= ===========================; GFX7 12; GFX8 12; GFX9 16; GFX10+ 16; ======= ===========================. A sequence of *ttmp* registers may be used to operate with more than 32 bits of data.; Assembler currently supports tuples with 1 to 12 and 16 *ttmp* registers. Pairs of *ttmp* registers must be even-aligned (first register must be even).; Sequences of 4 and more *ttmp* registers must be quad-aligned. ============================================================= ====================================================================; Syntax Description; ============================================================= ====================================================================; **ttmp**\ <N> A single 32-bit *ttmp* register. *N* must be a decimal; :ref:`integer number<amdgpu_synid_integer_number>`.; **ttmp[**\ <N>\ **]** A single 32-bit *ttmp* register. *N* may be specified a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst:9570,depend,depends,9570,interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,1,['depend'],['depends']
Integrability,"erance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61921,integrat,integration,61921,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,2,['integrat'],['integration']
Integrability,"ere are some examples:. .. code-block:: c++. class VehicleMaker {; ...; Factory<Tire> F; // Avoid: a non-descriptive abbreviation.; Factory<Tire> Factory; // Better: more descriptive.; Factory<Tire> TireFactory; // Even better: if VehicleMaker has more than one; // kind of factories.; };. Vehicle makeVehicle(VehicleType Type) {; VehicleMaker M; // Might be OK if scope is small.; Tire Tmp1 = M.makeTire(); // Avoid: 'Tmp1' provides no information.; Light Headlight = M.makeLight(""head""); // Good: descriptive.; ...; }. Assert Liberally; ^^^^^^^^^^^^^^^^. Use the ""``assert``"" macro to its fullest. Check all of your preconditions and; assumptions, you never know when a bug (not necessarily even yours) might be; caught early by an assertion, which reduces debugging time dramatically. The; ""``<cassert>``"" header file is probably already included by the header files you; are using, so it doesn't cost anything to use it. To further assist with debugging, make sure to put some kind of error message in; the assertion statement, which is printed if the assertion is tripped. This; helps the poor debugger make sense of why an assertion is being made and; enforced, and hopefully what to do about it. Here is one complete example:. .. code-block:: c++. inline Value *getOperand(unsigned I) {; assert(I < Operands.size() && ""getOperand() out of range!"");; return Operands[I];; }. Here are more examples:. .. code-block:: c++. assert(Ty->isPointerType() && ""Can't allocate a non-pointer type!"");. assert((Opcode == Shl || Opcode == Shr) && ""ShiftInst Opcode invalid!"");. assert(idx < getNumSuccessors() && ""Successor # out of range!"");. assert(V1.getType() == V2.getType() && ""Constant types must be identical!"");. assert(isa<PHINode>(Succ->front()) && ""Only works on PHId BBs!"");. You get the idea. In the past, asserts were used to indicate a piece of code that should not be; reached. These were typically of the form:. .. code-block:: c++. assert(0 && ""Invalid radix for integer literal"");. This h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:45414,message,message,45414,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['message'],['message']
Integrability,"ere no basket is stored with the TTree object.; Fix the axis used for an histogram created by TTree::Draw for a branch of TString or std::string objects.; MakeProxy now correctly support branches that created with a leaflist with more than one leaf; (usually used for C-struct).; TTree::CloneTree and TChain::Merge in fast mode now can recover from some mismatch errors between; the input and output TTrees by falling back to using the 'slow' mode. In particular this allow; a 'fast cloning' to handle files that requires schema evolution (albeit it is of course much slower).; Make sure that the TTreeCache is not attempting to cache (wrongly) the content of branches that are in an auxiliary files.; Make sure that FillBuffer does it work when the learning phase is over even if the entry number is 'low' for the 'current' file of a chain.; If TTree::SetEventList is called, TTree::GetEntryList no longer relinquish ownership of the automatically created TEntryList; Add the ability to see the TTree UserInfo list from the TBrowser; Fix the case of reading a TTree containing an 'old' class layout that contained a std::vector that is no longer part of the current class layout; Implement direct interfaces from TTree to the result of TSelector::Draw; TTree:GetVal(int) and TTree::GetVar(int); In TTree::ReadFile add the possibility to read multiple input files and add support for large/wide Trees definition.; Added support for ""5-D"" plotting.; Added support for std::bitset; Reduce the memory used by the mechanism keeping track of the entry of variables sizes within a basket (fEntryOffset).; The memory used now automatically decrease if the number of entries in the basket is less than 1/4 oflength of fEntryOffset.; Also the default length fEntryOffset can be set via TTree::SetDefaultEntryOffsetLen which can be optionially applied to the; existing branches. Parallel Coordinates. Fix a memory leak. The TParallelCoord destructor was not called; when the canvas used to draw it was closed. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v524/index.html:1390,interface,interfaces,1390,tree/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v524/index.html,1,['interface'],['interfaces']
Integrability,"erences within the stack frame must be identified so that the collector may; traverse and perhaps update them. * Write barriers when storing object references to the heap. These are commonly; used to optimize incremental scans in generational collectors. * Emission of read barriers when loading object references. These are useful; for interoperating with concurrent collectors. There are additional areas that LLVM does not directly address:. * Registration of global roots with the runtime. * Registration of stack map entries with the runtime. * The functions used by the program to allocate memory, trigger a collection,; etc. * Computation or compilation of type maps, or registration of them with the; runtime. These are used to crawl the heap for object references. In general, LLVM's support for GC does not include features which can be; adequately addressed with other features of the IR and does not specify a; particular binary interface. On the plus side, this means that you should be; able to integrate LLVM with an existing runtime. On the other hand, it can; have the effect of leaving a lot of work for the developer of a novel; language. We try to mitigate this by providing built in collector strategy; descriptions that can work with many common collector designs and easy; extension points. If you don't already have a specific binary interface; you need to support, we recommend trying to use one of these built in collector; strategies. .. _gc_intrinsics:. LLVM IR Features; ================. This section describes the garbage collection facilities provided by the; :doc:`LLVM intermediate representation <LangRef>`. The exact behavior of these; IR features is specified by the selected :ref:`GC strategy description; <plugin>`. Specifying GC code generation: ``gc ""...""``; -------------------------------------------. .. code-block:: text. define <returntype> @name(...) gc ""name"" { ... }. The ``gc`` function attribute is used to specify the desired GC strategy to the; co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:7703,integrat,integrate,7703,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['integrat'],['integrate']
Integrability,"erent information, making it difficult to; write proper -verify directives. In C, the argument can be typed as 'int' or as '_Bool'. Example usage::. clang_analyzer_eval(x); // expected-warning{{UNKNOWN}}; if (!x) return;; clang_analyzer_eval(x); // expected-warning{{TRUE}}. - ``void clang_analyzer_checkInlined(bool);``. If a call occurs within an inlined function, prints TRUE or FALSE according to; the value of its argument. If a call occurs outside an inlined function,; nothing is printed. The intended use of this checker is to assert that a function is inlined at; least once (by passing 'true' and expecting a warning), or to assert that a; function is never inlined (by passing 'false' and expecting no warning). The; argument is technically unnecessary but is intended to clarify intent. You might wonder why we can't print TRUE if a function is ever inlined and; FALSE if it is not. The problem is that any inlined function could conceivably; also be analyzed as a top-level function (in which case both TRUE and FALSE; would be printed), depending on the value of the -analyzer-inlining option. In C, the argument can be typed as 'int' or as '_Bool'. Example usage::. int inlined() {; clang_analyzer_checkInlined(true); // expected-warning{{TRUE}}; return 42;; }. void topLevel() {; clang_analyzer_checkInlined(false); // no-warning (not inlined); int value = inlined();; // This assertion will not be valid if the previous call was not inlined.; clang_analyzer_eval(value == 42); // expected-warning{{TRUE}}; }. - ``void clang_analyzer_warnIfReached();``. Generate a warning if this line of code gets reached by the analyzer. Example usage::. if (true) {; clang_analyzer_warnIfReached(); // expected-warning{{REACHABLE}}; }; else {; clang_analyzer_warnIfReached(); // no-warning; }. - ``void clang_analyzer_numTimesReached();``. Same as above, but include the number of times this call expression; gets reached by the analyzer during the current analysis. Example usage::. for (int x = 0",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:4416,depend,depending,4416,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,1,['depend'],['depending']
Integrability,"erface to land your change.; If you have created multiple commits to address feedback at this point you need; to consolidate those commits into one commit. There are two different ways to; do this:. `Interactive rebase <https://git-scm.com/docs/git-rebase#_interactive_mode>`_; with fixup's. This is the recommended method since you can control the final; commit message and inspect that the final commit looks as you expect. When; your local state is correct, remember to force-push to your branch and press; the merge button afterwards. Use the button `Squash and merge` in GitHub's web interface, if you do this; remember to review the commit message when prompted. Afterwards you can select the option `Delete branch` to delete the branch; from your fork. You can also merge via the CLI by switching to your branch locally and run:. ::. gh pr merge --squash --delete-branch. If you observe an error message from the above informing you that your pull; request is not mergeable, then that is likely because upstream has been; modified since your pull request was authored in a way that now results in a; merge conflict. You must first resolve this merge conflict in order to merge; your pull request. In order to do that:. ::. git fetch upstream; git rebase upstream/main. Then fix the source files causing merge conflicts and make sure to rebuild and; retest the result. Then:. ::. git add <files with resolved merge conflicts>; git rebase --continue. Finally, you'll need to force push to your branch one more time before you can; merge:. ::. git push -f; gh pr merge --squash --delete-branch. This force push may ask if you intend to push hundreds, or potentially; thousands of patches (depending on how long it's been since your pull request; was initially authored vs. when you intended to merge it). Since you're pushing; to a branch in your fork, this is ok and expected. Github's UI for the pull; request will understand that you're rebasing just your patches, and display; this result cor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:5759,message,message,5759,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['message'],['message']
Integrability,"erface. Implementing a loop pass is usually straightforward.; ``LoopPass``\ es may override three virtual methods to do their work. All; these methods should return ``true`` if they modified the program, or ``false``; if they didn't. A ``LoopPass`` subclass which is intended to run as part of the main loop pass; pipeline needs to preserve all of the same *function* analyses that the other; loop passes in its pipeline require. To make that easier,; a ``getLoopAnalysisUsage`` function is provided by ``LoopUtils.h``. It can be; called within the subclass's ``getAnalysisUsage`` override to get consistent; and correct behavior. Analogously, ``INITIALIZE_PASS_DEPENDENCY(LoopPass)``; will initialize this set of function analyses. The ``doInitialization(Loop *, LPPassManager &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(Loop *, LPPassManager &LPM);. The ``doInitialization`` method is designed to do simple initialization type of; stuff that does not depend on the functions being processed. The; ``doInitialization`` method call is not scheduled to overlap with any other; pass executions (thus it should be very fast). ``LPPassManager`` interface; should be used to access ``Function`` or ``Module`` level analysis information. .. _writing-an-llvm-pass-runOnLoop:. The ``runOnLoop`` method; ^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnLoop(Loop *, LPPassManager &LPM) = 0;. The ``runOnLoop`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a ``true`` value; should be returned if the function is modified. ``LPPassManager`` interface; should be used to update loop nest. The ``doFinalization()`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization();. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnLoop; <writ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:21609,depend,depend,21609,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['depend'],['depend']
Integrability,"erface.h; Header file defining functions in the namespace ROOT::Fit providing functions required for fitting the data objects of the histogram package. These functions are used for example from other libraries like the FitPanel or the TTreePlayer for performing the fits.; . ROOT::Fit::FitObject: function for fitting the various data objects. The user must pass in addition to a pointer to the fit object, the fit options (via the FOption class and not a string), the minimizer options and the fit data range.; ; ROOT::Fit::FillData: function for filling the fit data from the histogram data objects. Used for fitting an histogram using the ROOT::Fit::Fitter class.; ; ROOT::Fit::UnBinFit:: function for fitting an unbinned data sets, for example obtained from TTree data.; . TBackCompFitter; New class providing a backward compatible implementation of the; TVirtualFitter using the new fitting class. It is wrapping the functionality of the ROOT::Math::Fitter and it; can be used to retrieve the fit information (result and; configuration) via the; TVirtualFitter API from FitConfig and FitResult. A static instance of this class; is created after calling the histograms and graph Fit methods in order to retrieve the full fit information after having fit. This instace will be deleted only when the next fit is executed.; This gives full backward compatibility functionality in fitting.; This class in addition to the TVirtualFitter provides the following functionality:; ; access direct to references to ROOT::Fit::FitResult and ROOT::FitConfig objects via the member functions TBackCompFitter::GetFitResult() and TBackCompFitter::GetFitConfig(); Possibility to set the fit the fit function directly as a function pointer to a muldi-dimensional function interface instead of using the TMinuit FCN style API.; New methods for making in a easy way contour , with TBackCompFitter::Contour, and scan plots of the objective function, with TBackCompFitter::Scan. Both Scan and Contour takes as input a T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:1336,wrap,wrapping,1336,hist/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html,1,['wrap'],['wrapping']
Integrability,"erformance throughput. Important performance indicators are; **IPC**, **uOps Per Cycle**, and **Block RThroughput** (Block Reciprocal; Throughput). Field *DispatchWidth* is the maximum number of micro opcodes that are dispatched; to the out-of-order backend every simulated cycle. For processors with an; in-order backend, *DispatchWidth* is the maximum number of micro opcodes issued; to the backend every simulated cycle. IPC is computed dividing the total number of simulated instructions by the total; number of cycles. Field *Block RThroughput* is the reciprocal of the block throughput. Block; throughput is a theoretical quantity computed as the maximum number of blocks; (i.e. iterations) that can be executed per simulated clock cycle in the absence; of loop carried dependencies. Block throughput is superiorly limited by the; dispatch rate, and the availability of hardware resources. In the absence of loop-carried data dependencies, the observed IPC tends to a; theoretical maximum which can be computed by dividing the number of instructions; of a single iteration by the `Block RThroughput`. Field 'uOps Per Cycle' is computed dividing the total number of simulated micro; opcodes by the total number of cycles. A delta between Dispatch Width and this; field is an indicator of a performance issue. In the absence of loop-carried; data dependencies, the observed 'uOps Per Cycle' should tend to a theoretical; maximum throughput which can be computed by dividing the number of uOps of a; single iteration by the `Block RThroughput`. Field *uOps Per Cycle* is bounded from above by the dispatch width. That is; because the dispatch width limits the maximum size of a dispatch group. Both IPC; and 'uOps Per Cycle' are limited by the amount of hardware parallelism. The; availability of hardware resources affects the resource pressure distribution,; and it limits the number of instructions that can be executed in parallel every; cycle. A delta between Dispatch Width and the theoretica",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:16685,depend,dependencies,16685,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['dependencies']
Integrability,"ergeInfo*);. it will be used by a TFileMerger (and thus by PROOF) to merge one or more; other objects into the current object. Merge should; return a negative value if the merging failed. If this method does not exist, the TFileMerger will use; a method with the name and signature:. Long64_t Merge(TCollection *input);. TClass now provides a quick access to these merging; function via TClass::GetMerge. The wrapper function; is automatically created by rootcint and can be installed; via TClass::SetMerge. The wrapper function should have; the signature/type ROOT::MergeFunc_t:. Long64_t (*)(void *thisobj, TCollection *input, TFileMergeInfo*);. We added the new Merge function to TTree and THStack.; We also added the new Merge function to TQCommand as the; existing TQCommand::Merge does not have the right; semantic (in part because TQCommand is a collection). In TFileMerger, we added a PrintLevel to allow hadd to request; more output than regular TFileMerger. We removed all hard dependencies of TFileMerger on TH1 and TTree.; (Soft dependencies still exist to be able to disable the; merging of TTrees and to be able to disable the AutoAdd; behavior of TH1). The object TFileMergeInfo can be used inside the Merge; function to pass information between runs of the Merge; (see below). In particular it contains:. TDirectory *fOutputDirectory; // Target directory where the merged object will be written.; Bool_t fIsFirst; // True if this is the first call to Merge for this series of object.; TString fOptions; // Additional text based option being passed down to customize the merge.; TObject *fUserData; // Place holder to pass extra information. This object will be deleted at the end of each series of objects. The default in TFileMerger is to call Merge for every object; in the series (i.e the collection has exactly one element) in; order to save memory (by not having all the object in memory; at the same time). However for histograms, the default is to first load all the; objects a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v530/index.html:3734,depend,dependencies,3734,io/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v530/index.html,1,['depend'],['dependencies']
Integrability,"erializable C++ types with associated names, similar to branches in a TTree.; The data model can contain (nested) collections, e.g., a type can be `std::vector<std::vector<float>>`. Each serializable type is represented by a **field**, concretely by a templated version of RField,; e.g. `RField<double>`. A field can generate or adopt an associated **value**, which represents a memory location; storing a value of the given C++ type. These distinguished memory locations are the destinations and sources for the; deserialization and serialization. The (de-)serialization is a mapping from the C++ type to the more simple **column** type system. A column contains; an arbitrary number of fixed-sized elements of a well-defined set of types: integers and floats of different; bit sizes. A C++ type may be mapped to multiple columns. For instance, an `std::vector<float>` maps to two columns,; an offset column indicating the size of the vector per entry, and a payload column with the float data. Columns are partitioned into **pages** (roughly: TTree baskets) of a few kB -- a few tens of kB each.; The **physical layer** (only) needs to provide the means to store and retrieve pages. The physical layer is; decoupled from the high-level C++ logic. The physical layer implements an abstract page storage interface,; so that dedicated implementations for key-value stores and other storage systems are conceivable.; At this point, the only provided backend stores the pages in ROOT files. RNTuples are further grouped into **clusters**, which are, like TTree clusters, self-contained blocks of; consecutive entries. Clusters provide a unit of writing and will provide the means for parallel writing of data; in a future version of RNTuple. Related classes; ---------------. \defgroup ROOT7 ROOT7 classes; \brief Interfaces and classes designed for future ROOT version 7 (experimental!). \defgroup NTuple NTuple-related classes; \brief tuple classes designed for future ROOT version 7 (experimental!); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md:2937,interface,interface,2937,tree/ntuple/v7/doc/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/README.md,1,['interface'],['interface']
Integrability,"erializing an; Objective-C method declaration (or other Objective-C construct) that refers to; the selector. AST Reader Integration Points; -----------------------------. The ""lazy"" deserialization behavior of AST files requires their integration; into several completely different submodules of Clang. For example, lazily; deserializing the declarations during name lookup requires that the name-lookup; routines be able to query the AST file to find entities stored there. For each Clang data structure that requires direct interaction with the AST; reader logic, there is an abstract class that provides the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and; is used whenever the :ref:`source manager <pchinternals-sourcemgr>` needs to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used whenever the program source refers to an identifier that has not yet; been seen. In this case, the AST reader searches for this identifier within; its :ref:`identifier table <pchinternals-ident-table>` to load any top-level; declarations or macros associated with that identifier. ``ExternalASTSource``; This abstract interface is associated with the ``ASTContext`` class, and is; used whenever the abstract syntax tree nodes need to loaded from the AST; file. It provides the ability to de-serialize declarations and types; identified by their numeric values, read the bodies of functions when; required, and read the declarations stored within a declaration context; (either for iteration or for name lookup). ``ExternalSemaSource``; This abstract interface is a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:22253,interface,interface,22253,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['interface'],['interface']
Integrability,"erials made of single elements can be defined by their atomic mass; (`A`), charge (`Z`) and density (`rho`). One can also create a material; by specifying the element that it is made of. Optionally the radiation; and absorption lengths can be also provided; otherwise they can be; computed on-demand [`G3`]. The class representing them is; TGeoMaterial:. ~~~{.cpp}; TGeoMaterial(const char *name,Double_t a,Double_t z,; Double_t density, Double_t radlen=0,Double_t intlen=0);; TGeoMaterial(const char *name, TGeoElement *elem,; Double_t density);; TGeoMaterial(const char* name, Double_t a, Double_t z,; Double_t rho,; TGeoMaterial::EGeoMaterialState state,; Double_t temperature = STP_temperature,; Double_t pressure = STP_pressure); ~~~. Any material or derived class is automatically indexed after creation.; The assigned index is corresponding to the last entry in the list of; materials owned by TGeoManager class. This can be changed using; the `TGeoMaterial::SetIndex()` method, however it is not; recommended while using the geometry package interfaced with a transport; MC. Radiation and absorption lengths can be set using:. ~~~{.cpp}; TGeoMaterial::SetRadLen(Double_t radlen, Double_t intlen);; ~~~. - `radlen:` radiation length. If `radlen<=0` the value is computed; using GSMATE algorithm in GEANT3; - `intlen:` absorption length. Material state, temperature and pressure can be changed via setters.; Another material property is transparency. It can be defined and used; while viewing the geometry with OpenGL. ~~~{.cpp}; void SetTransparency (Char_t transparency = 0); ~~~. - `transparency:` between 0 (opaque default) to 100 (fully; transparent). One can attach to a material a user-defined object storing Cerenkov; properties. Another hook for material shading properties is currently; not in use. Mixtures are materials made of several elements. They are; represented by the class TGeoMixture, deriving from; TGeoMaterial and defined by their number of components and the; density:. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md:2587,interface,interfaced,2587,geom/geom/doc/materials.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md,1,['interface'],['interfaced']
Integrability,"eric Options:. --help - Display available options (--help-hidden for more); --help-list - Display list of available options (--help-list-hidden for more); --version - Display the version of this program. clang-offload-bundler options:. --### - Print any external commands that are to be executed instead of actually executing them - for testing purposes.; --allow-missing-bundles - Create empty files if bundles are missing when unbundling.; --bundle-align=<uint> - Alignment of bundle for binary files; --check-input-archive - Check if input heterogeneous archive is valid in terms of TargetID rules.; --inputs=<string> - [<input file>,...]; --list - List bundle IDs in the bundled file.; --outputs=<string> - [<output file>,...]; --targets=<string> - [<offload kind>-<target triple>,...]; --type=<string> - Type of the files to be bundled/unbundled.; Current supported types are:; i - cpp-output; ii - c++-cpp-output; cui - cuda/hip-output; d - dependency; ll - llvm; bc - llvm-bc; s - assembler; o - object; a - archive of bundled files; gch - precompiled-header; ast - clang AST file; --unbundle - Unbundle bundled file into several output files. Usage; =====. This tool can be used as follows for bundling:. ::. clang-offload-bundler -targets=triple1,triple2 -type=ii -inputs=a.triple1.ii,a.triple2.ii -outputs=a.ii. or, it can be used as follows for unbundling:. ::. clang-offload-bundler -targets=triple1,triple2 -type=ii -outputs=a.triple1.ii,a.triple2.ii -inputs=a.ii -unbundle. Supported File Formats; ======================. Multiple text and binary file formats are supported for bundling/unbundling. See; :ref:`supported-file-formats-table` for a list of currently supported input; formats. Use the ``File Type`` column to determine the value to pass to the; ``--type`` option based on the type of input files while bundling/unbundling. .. table:: Supported File Formats; :name: supported-file-formats-table. +--------------------------+----------------+-------------+; | File Format | Fi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:2718,depend,dependency,2718,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,1,['depend'],['dependency']
Integrability,"erical integration.; New template methods have been also included in the common Integration class in order to be able to integrate automatically any C++ callable object. ROOT::Math::RichardsonDerivator implementing numerical derivation using the Richardson's extrapolation formula (use 2 derivative estimates to compute a third, more accurate estimation). This is used by the TD1::Derivative method. ; BrentRootFinder for finding the root of one-dimensional function using the Brent algorithm. The class inherits from a virtual interface, which is also implemented by the MathMore root finder methods. The user can instantiate, via the common ROOT::Math::RootFinder class, all the various root finder algorithms. The BrentRootFinder class is used by TF1::GetX . ; A similar class, BrentMinimizer1D, provides the possibility to find the minimum of one-dimensional functions using the Brent algorithm. This class is used by TF1::GetMinimum or TF1::GetMaximum; Use ROOT convention for all enumeration names defining the type of numerical algorithms (start with k, like kADAPTIVE for the integration type). This affects both MathCore and MathMore.; . In addition we use now the ROOT convention for all enumeration names defining the type of numerical algorithms. The names start with k, like kADAPTIVE for the integration type. This change affects both MathCore and MathMore and it breaks backward compatibility. MathCore Function interfaces; Mathcore provides as well interfaces for the evaluation of mathematical and parametric functions to be used in the numerical methods. This release contains the following changes:. The ROOT::Math::IParamFunction, ROOT::Math::IParamMultiFunction interfaces (used mainly for fitting) require now a pointer to the parameters (type const double *), when evaluating the function. The derived classes must implement now the const; method DoEvalPar (and not DoEval as before). In addition the method; operator()(const double * x, const double * p) is now const. This cha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:8377,integrat,integration,8377,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['integrat'],['integration']
Integrability,"eritance tree.; #. The argument to ``classof`` should be a ``const Base *``, where ``Base``; is some ancestor in the inheritance hierarchy. The argument should; *never* be a derived class or the class itself: the template machinery; for ``isa<>`` already handles this case and optimizes it.; #. For each class in the hierarchy that has no children, implement a; ``classof`` that checks only against its ``Kind``.; #. For each class in the hierarchy that has children, implement a; ``classof`` that checks a range of the first child's ``Kind`` and the; last child's ``Kind``. RTTI for Open Class Hierarchies; ===============================. Sometimes it is not possible to know all types in a hierarchy ahead of time.; For example, in the shapes hierarchy described above the authors may have; wanted their code to work for user defined shapes too. To support use cases; that require open hierarchies LLVM provides the ``RTTIRoot`` and; ``RTTIExtends`` utilities. The ``RTTIRoot`` class describes an interface for performing RTTI checks. The; ``RTTIExtends`` class template provides an implementation of this interface; for classes derived from ``RTTIRoot``. ``RTTIExtends`` uses the ""`Curiously; Recurring Template Idiom`_"", taking the class being defined as its first; template argument and the parent class as the second argument. Any class that; uses ``RTTIExtends`` must define a ``static char ID`` member, the address of; which will be used to identify the type. This open-hierarchy RTTI support should only be used if your use case requires; it. Otherwise the standard LLVM RTTI system should be preferred. .. _`Curiously Recurring Template Idiom`:; https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern. E.g. .. code-block:: c++. class Shape : public RTTIExtends<Shape, RTTIRoot> {; public:; static char ID;; virtual double computeArea() = 0;; };. class Square : public RTTIExtends<Square, Shape> {; double SideLength;; public:; static char ID;. Square(double S) : SideLength(S) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst:13265,interface,interface,13265,interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,1,['interface'],['interface']
Integrability,"erminator instruction that has no; successors. Arguments:; """""""""""""""""""". The '``resume``' instruction requires one argument, which must have the; same type as the result of any '``landingpad``' instruction in the same; function. Semantics:; """""""""""""""""""". The '``resume``' instruction resumes propagation of an existing; (in-flight) exception whose unwinding was interrupted with a; :ref:`landingpad <i_landingpad>` instruction. Example:; """""""""""""""". .. code-block:: llvm. resume { ptr, i32 } %exn. .. _i_catchswitch:. '``catchswitch``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind to caller; <resultval> = catchswitch within <parent> [ label <handler1>, label <handler2>, ... ] unwind label <default>. Overview:; """""""""""""""""". The '``catchswitch``' instruction is used by `LLVM's exception handling system; <ExceptionHandling.html#overview>`_ to describe the set of possible catch handlers; that may be executed by the :ref:`EH personality routine <personalityfn>`. Arguments:; """""""""""""""""""". The ``parent`` argument is the token of the funclet that contains the; ``catchswitch`` instruction. If the ``catchswitch`` is not inside a funclet,; this operand may be the token ``none``. The ``default`` argument is the label of another basic block beginning with; either a ``cleanuppad`` or ``catchswitch`` instruction. This unwind destination; must be a legal target with respect to the ``parent`` links, as described in; the `exception handling documentation\ <ExceptionHandling.html#wineh-constraints>`_. The ``handlers`` are a nonempty list of successor blocks that each begin with a; :ref:`catchpad <i_catchpad>` instruction. Semantics:; """""""""""""""""""". Executing this instruction transfers control to one of the successors in; ``handlers``, if appropriate, or continues to unwind via the unwind label if; present. The ``catchswitch`` is both a terminator and a ""pad"" instruction, meaning that; it must ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:370904,rout,routine,370904,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['rout'],['routine']
Integrability,"ern.ch/js/dev/?json=demo/canvas_tf1.json; 15. Introduce JSROOT.FFormat function to convert numeric values into string according; format like 6.4g or 5.7e. Used for statistic display. ## Changes in 3.5; 1. Fix error in vertical text alignment; 2. Many improvements in TPaletteAxis drawing - draw label, avoid too large ticks.; 3. Fix error with col drawing - bin with maximum value got wrong color; 4. Test for existing jquery.js, jquery-ui.js and d3.js libraries, reuse when provided; 5. Fix several I/O problems; now one could read files, produced in Geant4; 6. Implement 'e2' drawing option for TH1 class,; use by default 'e' option when TH1 has non-empty fSumw2; 7. Reuse statistic from histogram itself, when no axis selection done; 8. Support log/lin z scale for color drawing; 9. Implement interactive z-scale selection on TPaletteAxis; 10. Allow to redraw item with other draw options (before one should clear drawings); 11. Several improvements in THttpServer user interface - repair hierarchy reload,; hide unsupported context menu entries, status line update. ## Changes in 3.4; 1. Support usage of minimized versions of .js and .css files.; Minimized scripts used by default on web servers.; 2. Implement JSROOT.extend instead of jQuery.extend, reduce; usage of jquery.js in core JSROOT classes; 3. Implement main graphics without jquery at all,; such mode used in `nobrowser` mode.; 4. Provide optional latex drawing with MathJax SVG.; TMathText always drawn with MathJax,; other classes require `mathjax` option in URL; 5. Improve drawing of different text classes, correctly handle; their alignment and scaling, special handling for IE; 6. Fix error with time axes - time offset was not correctly interpreted. ## Changes in 3.3; 1. Use d3.time.scale for display of time scales; 2. Within JSRootCore.js script URL one could specify JSROOT; functionality to be loaded: '2d', '3d', 'io', 'load', 'onload'.; Old method with JSROOT.AssertPrerequisites will also work.; 3. With THttpServer JS",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:66170,interface,interface,66170,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['interface'],['interface']
Integrability,"err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file; ```. ## The Minimization packages. As explained before various minimization packages can be used when fitting in ROOT.; We have seen before how to configure the `Fitter` class to use different minimization packages; and different minimization options.; When using the `Fit` method the minimization package (and its options) can be selected using the; static methods of the `ROOT::Math::MinimizerOptions` class.; For example to select `Minuit2` instead of `Minuit` for fitting an histogram do:. ``` {.cpp}; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; // fit the histogram histo with the gaussian pre-defined function; histo->Fit(""gaus"");; ```. In the following we will give some brief description of the minimization packages.; The packages all implement the `ROOT::Math::Minimizer` interface which can be use for; finding the minimum of a multi-dimensional function.; The interface is documented in the Mathematical Library Chapter. In addition packages like Minuit or Minuit2 provide their own interfaces. ## MINUIT (Old TMInuit Version). This package was originally written in FORTRAN by Fred James and part; of `PACKLIB` (patch D506). It has been converted to a C++ class by; René Brun. The current implementation in C++ is a straightforward; conversion of the original FORTRAN version. The main changes are:. - The variables in the various `Minuit` labeled common blocks have; been changed to the **`TMinuit`** class data members. - The internal arrays with a maximum dimension depending on the; maximum number of parameters are now data members' arrays with a; dynamic dimension such that one can fit very large problems by; simply initializing the **`TMinuit`** constructor with the maximum; number of parameters. - The include file `Minuit.h` has been commented as much as possible; using ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:52731,interface,interface,52731,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['interface'],['interface']
Integrability,"error logging facility for problems. This allows much more detailed and accurate warning messages; during the minimization phase. The level of verbosity of this new error facility can be controlled with; a new . PrintEvalErrors(Int_t code). argument to fitTo(). . With code of -1, no errors are printed at all.; With a; code of zero, one line is printed for each p.d.f component with problems summarizing the number of times; problems occurred during the likelihood evaluation. . [#0] WARNING:Minization -- RooFitGlue: Minimized function has error status. ; Returning maximum FCN so far (-1e+30) to force MIGRAD to back out of this region. Error log follows; Parameter values: m=-7.397; RooGaussian::gx[ x=x mean=m sigma=sx ] has 3 errors. A code greater than zero will generate even more detail and; print the details of each evaluation error as provided by the p.d.f (zero value, not-a-number, normalization zero etc..); and show the observable values at which this error occurred. At most N detailed messages per p.d.f component; are shown where N is the integral value of the 'code' argument. . [#0] WARNING:Minization -- RooFitGlue: Minimized function has error status.; Returning maximum FCN so far (-1e+30) to force MIGRAD to back out of this region. Error log follows; Parameter values: m=-7.397; RooGaussian::gx[ x=x mean=m sigma=sx ]; getLogVal() top-level p.d.f evaluates to zero or negative number @ x=x=9.09989, mean=m=-7.39713, sigma=sx=0.1; getLogVal() top-level p.d.f evaluates to zero or negative number @ x=x=6.04652, mean=m=-7.39713, sigma=sx=0.1; getLogVal() top-level p.d.f evaluates to zero or negative number @ x=x=2.48563, mean=m=-7.39713, sigma=sx=0.1. The new-style error logging is active whenever MINUIT is operating on such a p.d.f. The default value for N is 3.; Outside the MINUIT context the evaluation error each evualuation error will generate a separate message through; RooMsgService; Other new features. The RooAddPdf constructor has been augmented with an additio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:16676,message,messages,16676,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['message'],['messages']
Integrability,"ers and exporters. `RooFitHS3` allows to different types of importers and exporters:; *Native* implementations, and *proxy-based* ones. If for a certain; class several implementations are provided, the native; implementation(s) take precedence. ### Writing your own importers and exporters: Proxy-based. Proxy-based implementations can be added very easily and without; actually writing any `C++` code -- you only need to add a short item; to a list in a `JSON` file, namely the; [export keys](https://github.com/root-project/root/blob/master/etc/RooFitHS3_wsexportkeys.json); for an exporter, or the; [factory expressions](https://github.com/root-project/root/blob/master/etc/RooFitHS3_wsfactoryexpressions.json); for an importer. This works in the following way: Every `RooFit` class performs; dependency tracking via proxies, which have names. This can be; exploited to perform the mapping of proxy names to `json` keys upon; export. In the other direction, the `RooWorkspace` has a factory; interface that allows to call any constructor via a string; interface. Hence:; - If a `RooFit` class has no other members aside from proxies, it can; be exported using a set of `export keys`.; - If all relevant members to a `RooFit` class are passed as; constructor arguments, it can be imported using a `factory; expression`. For the importer, an entry in the; [factory expressions](https://github.com/root-project/root/blob/master/etc/RooFitHS3_wsfactoryexpressions.json); needs to be added as follows:. ``` {.json}; ""<json-key>"": {; ""class"": ""<C++ class name>"",; ""arguments"": [; ""<json-key of constructor argument #1>"",; ""<json-key of constructor argument #2>"",; ...; ]; }; ```. Similarly, for the exporter, an entry in the; [export keys](https://github.com/root-project/root/blob/master/etc/RooFitHS3_wsexportkeys.json); needs to be added as follows:. ``` {.json}; ""<C++ class name>"": {; ""type"": ""<json-key>"",; ""proxies"": {; ""<name of proxy>"": ""<json-key of this element>"",; ""<name of proxy>"": ""<json-k",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_hs3.md:3180,interface,interface,3180,roofit/doc/developers/roofit_hs3.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_hs3.md,2,['interface'],['interface']
Integrability,"ers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is little growth of the global; state, the state is contained within each object, rather than; scattered through the program in the form of global variables. - Objects may come and go, but the basic structure of the program; remains relatively static, increases opportunity for reuse of; design. ## Installing ROOT; \index{install ROOT}. To install ROOT you have the choice to; download the binaries or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the source.; The GNU g++ compiler on most UNIX platforms can compile ROOT. Before downloading a binary version make sure your machine contains the; right run-time environment. In most cases it is not possible to run a; version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is; installed. In such cases you'll have to install ROOT from source. ROOT is currently running on the following platforms: supported; platforms. - `GNU/Linux x86-32 (IA32) and x86-64 (AMD64)(GCC,Intel/icc,; Portland/PGCC,KAI/KCC)`. - `Intel Itanium (IA64) GNU/Linux (GCC, Intel/ecc, SGI/CC) `. - `FreeBSD and OpenBSD (GCC)`. - `GNU/Hurd (GCC)`. - `HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC)`. - `IBM AIX 4.1 (xlC compiler, GCC)`. - `Sun Solaris for SPARC (SUN C++ compiler, GCC) `. - `Sun Solaris for x86 (SUN C++ comp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:9054,depend,depending,9054,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['depend'],['depending']
Integrability,"ers giving them; a name and starting values. More information can be found in; [api:parameters]. ### MnUserCovariance ###. The user can (optionally) provide a covariance matrix as input using the; class MnUserCovariance. More information can be found in; [api:covariance]. ### MnUserParameterState ###. The MnUserParameterState contains the parameters (MnUserParameters) and; covariance (MnUserCovariance). The MnUserParameterState has to main; purposes:. - It can be used as input to minimization. - The result of the minimization is transformed into the user; representable format by M . For more explanations see [api:state]. ## Input to M ##. The following input combinations to M are possible:. - $\mbox{FCN}$ + parameters + uncertainties. - $\mbox{FCN}$ with gradient + parameters + uncertainties. - $\mbox{FCN}$ + parameters + covariance. - $\mbox{FCN}$ with gradient + parameters + covariance. For each of these combinations the user can chose between a minimal; required interface (using std::vector containers) for the parameters and; uncertainties or a more functional one provided by M . If the user wants; to interact with the parameters before minimization (fixing,; adding/removing limits), the minimal required interface cannot be used. ### What the user must supply ###. The user must supply to M. - a valid implementation of the FCNBase base class. - parameters with their starting values. - expected uncertainties on the parameters. The input parameters can be simply defined via an; std::vector$<$double$>$, which means that all parameters are variables.; If the user wants fix a parameter or put limits on it before; minimization, they have to instantiate a MnUserParameters object and then; add parameters one by one, giving them a name, value, uncertainty. Once; all parameters are added to MnUserParameters, they can fix a parameter or; put limits on another one before handing them over to Minuit for; minimization. ### What the user can supply ###. Optionally the user can s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:32060,interface,interface,32060,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interface']
Integrability,"ersion`` (ubyte). A version number (see Section 7.24 Call Frame Information). This number is; specific to the call frame information and is independent of the DWARF; version number. The value of the CIE version number is 4. .. note::. Would this be increased to 5 to reflect the changes in these extensions?. 4. ``augmentation`` (sequence of UTF-8 characters). A null-terminated UTF-8 string that identifies the augmentation to this CIE; or to the FDEs that use it. If a reader encounters an augmentation string; that is unexpected, then only the following fields can be read:. * CIE: length, CIE_id, version, augmentation; * FDE: length, CIE_pointer, initial_location, address_range. If there is no augmentation, this value is a zero byte. *The augmentation string allows users to indicate that there is additional; vendor and target architecture specific information in the CIE or FDE which; is needed to virtually unwind a stack frame. For example, this might be; information about dynamically allocated data which needs to be freed on exit; from the routine.*. *Because the* ``.debug_frame`` *section is useful independently of any*; ``.debug_info`` *section, the augmentation string always uses UTF-8; encoding.*. The recommended format for the augmentation string is:. | ``[``\ *vendor*\ ``:v``\ *X*\ ``.``\ *Y*\ [\ ``:``\ *options*\ ]\ ``]``\ *. Where *vendor* is the producer, ``vX.Y`` specifies the major X and minor Y; version number of the extensions used, and *options* is an optional string; providing additional information about the extensions. The version number; must conform to semantic versioning [:ref:`SEMVER <amdgpu-dwarf-SEMVER>`].; The *options* string must not contain the ""\ ``]``\ "" character. For example:. ::. [abc:v0.0][def:v1.2:feature-a=on,feature-b=3]. 5. ``address_size`` (ubyte). The size of a target address in this CIE and any FDEs that use it, in bytes.; If a compilation unit exists for this frame, its address size must match the; address size here. 6. ``segme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:198634,rout,routine,198634,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['rout'],['routine']
Integrability,"erver = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); ```. Be aware, that with *lighttpd* one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: `http://lighttpd_host_name/root.app/`. Example of authorization configuration for FastCGI connection:. auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ). ## Integration with existing applications. In many practical cases no change of existing code is required. Opened files (and all objects inside), existing canvas and histograms are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a [THttpServer::Register()](https://root.cern/doc/master/classTHttpServer.html#a73658daf379e87a4832fe9dc5c1483ed) call. Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the `gSystem->ProcessEvents()` call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session. If an application runs in compiled code and does not contain `gSystem->ProcessEvents()` calls, two method are available. ### Asynchronous timer. The first method is to configure an asynchronous timer for the server, like for example:. ```cpp; serv->SetTimer(100, kFALSE);; ```. Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of **`TH1::Fill()`** calls and an histogram object may be incomplete. Therefore such method is not recommended. ### Regular calls of THttpServer::ProcessR",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:13033,integrat,integration,13033,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['integrat'],['integration']
Integrability,"es 5 0; Symbols 0 0; Types 2 2; Lines 0 0; -----------------------------; Total 7 2. From the values printed under the **Found** column, we can see that no; **Types** were found in the DWARF debug information generated by Clang. TEST CASE 5 - INCORRECT LEXICAL SCOPE FOR VARIABLE; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The below example is used to show different output generated by; :program:`llvm-debuginfo-analyzer`. We compiled the example for an X86; Codeview and ELF targets with recent versions of Clang, GCC and MSVC; (-O0 -g). .. code-block:: c++. // definitions.h; #ifdef _MSC_VER; #define forceinline __forceinline; #elif defined(__clang__); #if __has_attribute(__always_inline__); #define forceinline inline __attribute__((__always_inline__)); #else; #define forceinline inline; #endif; #elif defined(__GNUC__); #define forceinline inline __attribute__((__always_inline__)); #else; #define forceinline inline; #error; #endif. As the test is dependent on inline compiler options, the above header; file defines *forceinline*. .. code-block:: c++. #include ""definitions.h"". .. code-block:: c++. 1 #include ""definitions.h""; 2 forceinline int InlineFunction(int Param) {; 3 int Var_1 = Param;; 4 {; 5 int Var_2 = Param + Var_1;; 6 Var_1 = Var_2;; 7 }; 8 return Var_1;; 9 }; 10; 11 int test(int Param_1, int Param_2) {; 12 int A = Param_1;; 13 A += InlineFunction(Param_2);; 14 return A;; 15 }. The above test is used to illustrate a variable issue found in the Clang; compiler:; `PR43860 (Bugs LLVM) <https://bugs.llvm.org/show_bug.cgi?id=43860>`_ /; `PR43205 (GitHub) <https://github.com/llvm/llvm-project/issues/43205>`_. These are the logical views that :program:`llvm-debuginfo-analyzer`; generates for 3 different compilers (MSVC, Clang and GCC), emitting; different debug information formats (CodeView, DWARF) on different; platforms. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level,format,producer; --output-sort=name; --print=symbols; pr-43860-codeview-cl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:49101,depend,dependent,49101,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['depend'],['dependent']
Integrability,"es are as well implemented by classes using the GSL library and located in the MathMore library. The library can be loaded automatically using the ROOT plug-in manager.; In detail, the new classes containing implementations present previously in TF1 are:. ; GaussIntegrator and GaussLegendreIntegrator for numerical integration of one-dimensional functions. The first class uses Gaussian 8 and 16 point quadrature approximation, it provides the translation of the CERNLIB algorithm; DGAUSS by Sigfried Kolbig, and it is used by the TF1::Integral method. The second one uses the Gauss Legendre quadrature formula. It is used by the TF1::IntegralFast method.; These classes implement both the same virtual interface as the adaptive integration methods provided by the MathMore library. They can all be created and used easily via the common class ROOT::Math::IntegratorOneDim providing the interfaces for numerical integration.; New template methods have been also included in the common Integration class in order to be able to integrate automatically any C++ callable object. ROOT::Math::RichardsonDerivator implementing numerical derivation using the Richardson's extrapolation formula (use 2 derivative estimates to compute a third, more accurate estimation). This is used by the TD1::Derivative method. ; BrentRootFinder for finding the root of one-dimensional function using the Brent algorithm. The class inherits from a virtual interface, which is also implemented by the MathMore root finder methods. The user can instantiate, via the common ROOT::Math::RootFinder class, all the various root finder algorithms. The BrentRootFinder class is used by TF1::GetX . ; A similar class, BrentMinimizer1D, provides the possibility to find the minimum of one-dimensional functions using the Brent algorithm. This class is used by TF1::GetMinimum or TF1::GetMaximum; Use ROOT convention for all enumeration names defining the type of numerical algorithms (start with k, like kADAPTIVE for the integratio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:7414,integrat,integrate,7414,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['integrat'],['integrate']
Integrability,"es for Linux. N: Louis Gerbarg; E: lgg@apple.com; D: Portions of the PowerPC backend. N: Saem Ghani; E: saemghani@gmail.com; D: Callgraph class cleanups. N: Mikhail Glushenkov; E: foldr@codedgers.com; D: Author of llvmc2. N: Dan Gohman; E: llvm@sunfishcode.online; D: Miscellaneous bug fixes; D: WebAssembly Backend. N: Renato Golin; E: rengolin@systemcall.eu; E: rengolin@gmail.com; D: ARM/AArch64 back-end improvements; D: Loop Vectorizer improvements; D: Regression and Test Suite improvements; D: Linux compatibility (GNU, musl, etc); D: Initial Linux kernel / Android support effort; I: rengolin. N: David Goodwin; E: david@goodwinz.net; D: Thumb-2 code generator. N: David Greene; E: greened@obbligato.org; D: Miscellaneous bug fixes; D: Register allocation refactoring. N: Gabor Greif; E: ggreif@gmail.com; D: Improvements for space efficiency. N: James Grosbach; E: grosbach@apple.com; I: grosbach; D: SjLj exception handling support; D: General fixes and improvements for the ARM back-end; D: MCJIT; D: ARM integrated assembler and assembly parser; D: Led effort for the backend formerly known as ARM64. N: Lang Hames; E: lhames@gmail.com; D: PBQP-based register allocator. N: Gordon Henriksen; E: gordonhenriksen@mac.com; D: Pluggable GC support; D: C interface; D: Ocaml bindings. N: Raul Fernandes Herbster; E: raul@dsc.ufcg.edu.br; D: JIT support for ARM. N: Paolo Invernizzi; E: arathorn@fastwebnet.it; D: Visual C++ compatibility fixes. N: Patrick Jenkins; E: patjenk@wam.umd.edu; D: Nightly Tester. N: Tony(Yanjun) Jiang; E: jtony@ca.ibm.com; D: PowerPC Backend Developer; D: Improvements to the PPC backend and miscellaneous bug fixes. N: Dale Johannesen; E: dalej@apple.com; D: ARM constant islands improvements; D: Tail merging improvements; D: Rewrite X87 back end; D: Use APFloat for floating point constants widely throughout compiler; D: Implement X87 long double. N: Brad Jones; E: kungfoomaster@nondot.org; D: Support for packed types. N: Rod Kay; E: rkay@auroraux.org; D: Aut",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT:5076,integrat,integrated,5076,interpreter/llvm-project/llvm/CREDITS.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT,1,['integrat'],['integrated']
Integrability,"es of top-level functions. .. code-block:: c++. class A {; int f() { return 0; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_AllDefinitions`` (in configuration: ``AllDefinitions``); Always break after the return type of function definitions. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int f();; int; f() {; return 1;; }. * ``RTBS_TopLevelDefinitions`` (in configuration: ``TopLevelDefinitions``); Always break after the return type of top-level definitions. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int; f() {; return 1;; }. .. _AlwaysBreakBeforeMultilineStrings:. **AlwaysBreakBeforeMultilineStrings** (``Boolean``) :versionbadge:`clang-format 3.4` :ref:`¶ <AlwaysBreakBeforeMultilineStrings>`; If ``true``, always break before multiline string literals. This flag is mean to make cases where there are multiple multiline strings; in a file look more consistent. Thus, it will only take effect if wrapping; the string at that point leads to it being indented; ``ContinuationIndentWidth`` spaces from the start of the line. .. code-block:: c++. true: false:; aaaa = vs. aaaa = ""bbbb""; ""bbbb"" ""cccc"";; ""cccc"";. .. _AlwaysBreakTemplateDeclarations:. **AlwaysBreakTemplateDeclarations** (``BreakTemplateDeclarationsStyle``) :versionbadge:`clang-format 3.4` :ref:`¶ <AlwaysBreakTemplateDeclarations>`; The template declaration breaking style to use. Possible values:. * ``BTDS_No`` (in configuration: ``No``); Do not force break before declaration.; ``PenaltyBreakTemplateDeclaration`` is taken into account. .. code-block:: c++. template <typename T> T foo() {; }; template <typename T> T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. * ``BTDS_MultiLine`` (in configuration: ``MultiLine``); Force break after template declaration only when the following; declaration spans multiple lines. .. code-block:: c++. template <typename T> T foo() {; }; template <typename T>; T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbb",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:34568,wrap,wrapping,34568,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrapping']
Integrability,"es that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behavior is; controlled by the ``-fdelayed-template-parsing`` flag. While Clang delays; parsing of method bodies, it still parses the bodies *before* template argument; substitution, which is not what MSVC does. The following compatibility tweaks; are necessary to parse the template in those cases. MSVC allows some name lookup into dependent base classes. Even on other; platforms, this has been a `frequently asked question`_ for Clang users. A; dependent base class is a base class that depends on the value of a template; parameter. Clang cannot see any of the names inside dependent bases while it; is parsing your template, so the user is sometimes required to use the; ``typename`` keyword to assist the parser. On Windows, Clang attempts to; follow the normal lookup rules, but if lookup fails, it will assume that the; user intended to find the name in a dependent base. While parsing the; following program, Clang will recover as if the user had written the; commented-out code:. .. _frequently asked question:; https://clang.llvm.org/compatibility.html#dep_lookup. .. code-block:: c++. template <typename T>; struct Foo : T {; void f() {; /*typename*/ T::UnknownType x = /*this->*/unknownMember;; }; };. After recovery, Clang warns the user that this code is non-standard and issues; a hint suggesting how to fix the problem. As of this writing, Clang is able to compile a simple ATL hello world; application. There are still issues parsing WRL headers for modern Windows 8; apps, but they should be addressed soon.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:6023,depend,dependent,6023,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,2,['depend'],['dependent']
Integrability,"es to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlined (for example, when compiling without optimization), then; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:987,depend,dependent,987,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['depend'],['dependent']
Integrability,"es(CGAM);; PB.registerFunctionAnalyses(FAM);; PB.registerLoopAnalyses(LAM);; PB.crossRegisterProxies(LAM, FAM, CGAM, MAM);. // Create the pass manager.; // This one corresponds to a typical -O2 optimization pipeline.; ModulePassManager MPM = PB.buildPerModuleDefaultPipeline(OptimizationLevel::O2);. // Optimize the IR!; MPM.run(MyModule, MAM);. The C API also supports most of this, see ``llvm-c/Transforms/PassBuilder.h``. Adding Passes to a Pass Manager; ===============================. For how to write a new PM pass, see :doc:`this page <WritingAnLLVMNewPMPass>`. To add a pass to a new PM pass manager, the important thing is to match the; pass type and the pass manager type. For example, a ``FunctionPassManager``; can only contain function passes:. .. code-block:: c++. FunctionPassManager FPM;; // InstSimplifyPass is a function pass; FPM.addPass(InstSimplifyPass());. If you want to add a loop pass that runs on all loops in a function to a; ``FunctionPassManager``, the loop pass must be wrapped in a function pass; adaptor that goes through all the loops in the function and runs the loop; pass on each one. .. code-block:: c++. FunctionPassManager FPM;; // LoopRotatePass is a loop pass; FPM.addPass(createFunctionToLoopPassAdaptor(LoopRotatePass()));. The IR hierarchy in terms of the new PM is Module -> (CGSCC ->) Function ->; Loop, where going through a CGSCC is optional. .. code-block:: c++. FunctionPassManager FPM;; // loop -> function; FPM.addPass(createFunctionToLoopPassAdaptor(LoopFooPass()));. CGSCCPassManager CGPM;; // loop -> function -> cgscc; CGPM.addPass(createCGSCCToFunctionPassAdaptor(createFunctionToLoopPassAdaptor(LoopFooPass())));; // function -> cgscc; CGPM.addPass(createCGSCCToFunctionPassAdaptor(FunctionFooPass()));. ModulePassManager MPM;; // loop -> function -> module; MPM.addPass(createModuleToFunctionPassAdaptor(createFunctionToLoopPassAdaptor(LoopFooPass())));; // function -> module; MPM.addPass(createModuleToFunctionPassAdaptor(FunctionFooPass(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:2048,wrap,wrapped,2048,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['wrap'],['wrapped']
Integrability,"es, etc.) R reads a series of bytes written by; (defined) write operations (store instructions, atomic; stores/read-modify-writes, memcpy, etc.). For the purposes of this; section, initialized globals are considered to have a write of the; initializer which is atomic and happens before any other read or write; of the memory in question. For each byte of a read R, R\ :sub:`byte`; may see any write to the same byte, except:. - If write\ :sub:`1` happens before write\ :sub:`2`, and; write\ :sub:`2` happens before R\ :sub:`byte`, then; R\ :sub:`byte` does not see write\ :sub:`1`.; - If R\ :sub:`byte` happens before write\ :sub:`3`, then; R\ :sub:`byte` does not see write\ :sub:`3`. Given that definition, R\ :sub:`byte` is defined as follows:. - If R is volatile, the result is target-dependent. (Volatile is; supposed to give guarantees which can support ``sig_atomic_t`` in; C/C++, and may be used for accesses to addresses that do not behave; like normal memory. It does not generally provide cross-thread; synchronization.); - Otherwise, if there is no write to the same byte that happens before; R\ :sub:`byte`, R\ :sub:`byte` returns ``undef`` for that byte.; - Otherwise, if R\ :sub:`byte` may see exactly one write,; R\ :sub:`byte` returns the value written by that write.; - Otherwise, if R is atomic, and all the writes R\ :sub:`byte` may; see are atomic, it chooses one of the values written. See the :ref:`Atomic; Memory Ordering Constraints <ordering>` section for additional; constraints on how the choice is made.; - Otherwise R\ :sub:`byte` returns ``undef``. R returns the value composed of the series of bytes it read. This; implies that some bytes within the value may be ``undef`` **without**; the entire value being ``undef``. Note that this only defines the; semantics of the operation; it doesn't mean that targets will emit more; than one instruction to read the series of bytes. Note that in cases where none of the atomic intrinsics are used, this; model places only one",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:150814,synchroniz,synchronization,150814,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['synchroniz'],['synchronization']
Integrability,"es. For example, when fitting a `k`-dimensional histogram,; the independent variables **`X`** are the bin center coordinates and `Y` is the bin weight. The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe; the observed data. We can use the ROOT **`TF1`** class, the parametric function class, to describe the model function. However the `ROOT::Fit::Fitter` class, to be independent of the ROOT *`Hist`* library,; takes as input a more general parametric function object, the interface (abstract) class `ROOT::Math::IParametricFunctionMultiDim`, which describe a generic one or multi-dimensional function; with parameters. This interface extends the abstract class `ROOT::Math::IBaseFunctionMultiDim`, with methods to set/retrieve parameter values and to evaluate the function given the; independent vector of values **`X`** and vector of parameters `P`.; More information about the different `ROOT::Math` function interfaces is available in the Mathematical Library chapter. An end-user can convert a **`TF1`** object in a `ROOT::Math::IParametricFunctionMultiDim`, using the wrapper class `ROOT::Math::WrapperMultiTF1`:. ``` {.cpp}; TF1 * f1 = new TF1(""f1"",""gaus"");; ROOT::Math::WrappedMultiTF1 fitFunction(f1, f1->GetNdim() );; ROOT::Fit::Fitter fitter;; fitter.SetFunction( fitFunction, false);; ```. When creating the wrapper, the parameter values stored in **`TF1`** will be copied in the `ROOT::Math::WrappedMultiTF1` object.; The function object representing the model function is given to the `ROOT::Fitter` class using the `Fitter::SetFunction` method. The user has also the possibility to provide a function object, which implements the derivatives of the function with respect; to the parameters.; This information might be useful for some types of fits. In this case he needs to provide the function object as a class deriving from the; `ROOT::Math::IParametricGradFunctionMultiDim` interface.; Note th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:36552,interface,interfaces,36552,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['interface'],['interfaces']
Integrability,"es. The descriptor classes contain a copy of the meta-data; they are not linked to an open page source.; A descriptor can be used after its originating page source has been deleted. ### RField<T>; The RField<T> classes are central in RNTuple:; they link the in-memory representation of data types to their on-disk representation.; All field classes inherit from `RFieldBase`. Every type with RNTuple I/O supported has a corresponding RField<T> template specialization.; Complex types are composed of fields and sub fields.; E.g., a `struct` is represented by a parent field for the `struct` itself and a subfield for every member of the `struct`.; Fields of complex types have type-erased versions in addition to the templated ones (e.g., `RVectorField`, `RClassField`).; In this way, fields can be constructed even if the type information is only available at runtime.; To this end, `RFieldBase::Create()` creates an `RField` object from a type string. On the ""in-memory"" side, fields can construct and destroy objects of their wrapped type; (cf. `CreateValue()`, `CreateObject()`, `GetDeleter()` methods).; Existing objects in memory can be bound to fields (cf. `BindValue()` method). On the ""on-disk"" side, fields know about the possible column representations of their wrapped type.; Upon connecting a field to a page source or page sink,; fields create `RColumn` objects and register them with the page source/sink.; When reading and writing data, the field maps the in-memory information of an object to read/write calls on its columns.; For instance, when writing a `std::vector<float>`,; the field writes to an index column (storing information about the size of the vector).; Its subfield writes the actual values to a float column. During its lifetime, a field undergoes the following possible state transitions:; ```; [*] --> Unconnected --> ConnectedToSink ----; | | |; | --> ConnectedToSource ---> [*]; | |; -------------------------------; ```. The RField class hierarchy is fixed and n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:8524,wrap,wrapped,8524,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['wrap'],['wrapped']
Integrability,"es: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: false; SplitEmptyFunction: false. Nested configuration flags:. Precise control over the wrapping of braces. .. code-block:: c++. # Should be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true:; switch (foo) { vs. switch (foo) {; case 1: { case 1:; bar(); {; break; bar();; } break;; default: { }; plop(); default:; } {; } plop();; }; }. * ``bool AfterClass`` Wrap class definitions. .. code-block:: c++. true:; class foo; {};. false:; class foo {};. * ``BraceWrappingAfterControlStatementStyle AfterControlStatement``; Wrap control statements (``if``/``for``/``while``/``switch``/..). Possible values:. * ``BWACS_Never`` (in configuration: ``Never``); Never wrap braces after a control statement. .. code-block:: c++. if (foo()) {; } else {; }; for (int i = 0; i < 10; ++i) {; }. * ``BWACS_MultiLine`` (in configuration: ``MultiLine``); Only wrap braces after a multi-line control statement. .. code-block:: c++. if (foo && bar &&; baz); {; quux();; }; while (foo || bar) {; }. * ``BWACS_Always`` (in configuration: ``Always``); Always wrap braces after a control statement. .. code-block:: c++. if (foo()); {; } else; {}; for (int i = 0; i < 10; ++i); {}. * ``bool AfterEnum`` Wrap enum definitions. .. code-block:: c++. true:; enum X : int; {; B; };. false:; enum X : int { B };. * ``bool AfterFunction`` Wrap function definitions. .. code-block:: c++. true:; void foo(); {; bar();; bar2();; }. false:; void foo() {; bar();; bar2();; }. * ``bool AfterNamespace`` Wrap namespace definitions. .. code-block:: c++. true:; namespace; {; int foo();; int bar();; }. false:; namespace {; int foo();; int bar();; }. * ``bool AfterObjCDeclaration`` Wrap ObjC definitions (interfaces, implementations...). .. note::. @autoreleasepool and @synchronized blocks are wrapped; according to ``AfterControlStatement`` flag. * ``bool AfterStruct`` Wra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:39665,wrap,wrap,39665,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrap']
Integrability,es; Unknown. 2060; NAD; Deduced return type for explicit specialization; Unknown. 2061; CD4; Inline namespace after simplifications; Yes. 2062; CD6; Class template redeclaration requirements; Unknown. 2063; CD4; Type/nontype hiding in class scope; Unknown. 2064; CD4; Conflicting specifications for dependent decltype-specifiers; Unknown. 2065; CD6; Current instantiation of a partial specialization; Unknown. 2066; CD4; Does type-dependent imply value-dependent?; Unknown. 2067; open; Generated variadic templates requiring empty pack; Not resolved. 2068; CD4; When can/must a defaulted virtual destructor be defined?; Unknown. 2069; CD4; Do destructors have names?; Unknown. 2070; CD6; using-declaration with dependent nested-name-specifier; Unknown. 2071; CD4; typedef with no declarator; Unknown. 2072; C++23; Default argument instantiation for member functions of templates; Unknown. 2073; drafting; Allocating memory for exception objects; Not resolved. 2074; drafting; Type-dependence of local class of function template; Not resolved. 2075; CD4; Passing short initializer lists to array reference parameters; Unknown. 2076; CD4; List-initialization of arguments for constructor parameters; Clang 13. 2077; drafting; Overload resolution and invalid rvalue-reference initialization; Not resolved. 2078; NAD; Name lookup of mem-initilizer-id; Unknown. 2079; CD4; [[ appearing in a balanced-token-seq; Unknown. 2080; CD5; Example with empty anonymous union member; Unknown. 2081; CD5; Deduced return type in redeclaration or specialization of function template; Unknown. 2082; CD4; Referring to parameters in unevaluated operands of default arguments; Clang 11. 2083; CD5; Incorrect cases of odr-use; Partial. 2084; CD4; NSDMIs and deleted union default constructors; Unknown. 2085; CD4; Invalid example of adding special member function via default argument; Unknown. 2086; drafting; Reference odr-use vs implicit capture; Not resolved. 2087; NAD; Left shift of negative value by zero bits; Unkno,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:140966,depend,dependence,140966,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependence']
Integrability,"ese classes are still available in this release, but will be removed in the next one. Please migrate to STL container classes, such as `std::unordered_map`, `std::set`, and `std::vector`.; - The `RooFit::FitOptions(const char*)` command to steer [RooAbsPdf::fitTo()](https://root.cern.ch/doc/v628/classRooAbsPdf.html) with an option string in now deprecated and will be removed in ROOT v6.28. Please migrate to the RooCmdArg-based fit configuration. The former character flags map to RooFit command arguments as follows:; - `'h'` : RooFit::Hesse(); - `'m'` : RooFit::Minos(); - `'o'` : RooFit::Optimize(1); - `'r'` : RooFit::Save(); - `'t'` : RooFit::Timer(); - `'v'` : RooFit::Verbose(); - `'0'` : RooFit::Strategy(0); Subsequently, the `RooMinimizer::fit(const char*)` function and the [RooMCStudy](https://root.cern.ch/doc/v626/classRooMCStudy.html) constructor that takes an option string is deprecated as well. ## Core Libraries. ### Interpreter. - As of v6.26, cling diagnostic messages can be redirected to the ROOT error handler. Users may enable/disable this via `TCling::ReportDiagnosticsToErrorHandler()`, e.g.; ```cpp; root [1] gInterpreter->ReportDiagnosticsToErrorHandler();; root [2] int f() { return; }; Error in <cling>: ROOT_prompt_2:1:11: non-void function 'f' should return a value [-Wreturn-type]; int f() { return; }; ^; ```; More details at [PR #8737](https://github.com/root-project/root/pull/8737).; - Continuation of input lines using backslash `\` is supported in ROOT's prompt, e.g.; ```cpp; root [0] std::cout \; root (cont'ed, cancel with .@) [1]<< ""ROOT\n"";; ```. ## I/O Libraries. - `TDirectory::WriteObject` now always saves the object's title to the file if it is derived from `TObject` (PR [#8394](https://github.com/root-project/root/pull/8934)). ### Command line utilities. - `rootls` now follows the same logic of `TFile::ls()` to print the key cycle number and its tag when listing contents of a file with the `-l` option (PR [#7878](https://github.com/root-pro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:3601,message,messages,3601,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['message'],['messages']
Integrability,"essage(STATUS ""Building Cling as part of LLVM""); set(BACKEND_PACKAGE_STRING ""${PACKAGE_STRING}""); # Try finding the LLVMConfig.cmake if we build against prebuilt LLVM; set(LLVM_CMAKE_PATH ""${LLVM_BINARY_DIR}/lib${LLVM_LIBDIR_SUFFIX}/cmake/llvm""); set(LLVMCONFIG_FILE ""${LLVM_CMAKE_PATH}/LLVMConfig.cmake""); if(EXISTS ${LLVMCONFIG_FILE}); list(APPEND CMAKE_MODULE_PATH ""${LLVM_CMAKE_PATH}""); include(${LLVMCONFIG_FILE}); endif(); if (NOT CLANG_INCLUDE_DIRS); set (CLANG_INCLUDE_DIRS ""${LLVM_MAIN_SRC_DIR}/tools/clang/include""); if (NOT EXISTS ${CLANG_INCLUDE_DIRS}); # Otherwise assume the monorepo layout.; set (CLANG_INCLUDE_DIRS ${LLVM_MAIN_SRC_DIR}/../clang/include ); endif(); set (CLANG_INCLUDE_DIRS ""${CLANG_INCLUDE_DIRS}""; ""${LLVM_BINARY_DIR}/tools/clang/include""); endif(); if (NOT LLVM_INCLUDE_DIRS); set (LLVM_INCLUDE_DIRS ""${LLVM_MAIN_SRC_DIR}/include"" ""${LLVM_BINARY_DIR}/include""); endif(); endif(). if( NOT ""NVPTX"" IN_LIST LLVM_TARGETS_TO_BUILD); message(FATAL_ERROR ""NVPTX backend is not activated\n""; ""Please enable it via -DLLVM_TARGETS_TO_BUILD=\""host;NVPTX\""""); endif(). set(CLING_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}); set(CLING_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}); set(LLVM_TOOLS_BINARY_DIR ""${LLVM_BINARY_DIR}/bin""); if(DEFINED CLING_ROOT_BUILD); set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ""${LLVM_TOOLS_BINARY_DIR}""); endif(). if( CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR AND NOT MSVC_IDE ); message(FATAL_ERROR ""In-source builds are not allowed. CMake would overwrite ""; ""the makefiles distributed with LLVM. Please create a directory and run cmake ""; ""from there, passing the path to this source directory as the last argument. ""; ""This process created the file `CMakeCache.txt' and the directory ""; ""`CMakeFiles'. Please delete them.""); endif(). # From ROOT:; function(cling_add_cxx_flag var flag); string(REGEX REPLACE ""[-.+/:= ]"" ""_"" flag_esc ""${flag}""); CHECK_CXX_COMPILER_FLAG(""${flag}"" CXX_HAS${flag_esc}); if(CXX_HAS${flag_esc}); set(${var} ""${${var}} ${flag}"" PARENT_S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/CMakeLists.txt:4702,message,message,4702,interpreter/cling/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/CMakeLists.txt,1,['message'],['message']
Integrability,"essing. ### Implicit Multi-Threading; When `ROOT::EnableImplicitMT()` is used, RNTuple uses ROOT's task arena to compress and decompress pages.; That requires writes to be buffered and reads uses the cluster pool resp.; The RNTuple data source for RDataFrame lets RDataFrame full control of the thread pool.; That means that RDataFrame uses a separate data source for every thread, each of the data sources runs in sequential mode. ### Concurrent Readers; Multiple readers can read the same RNTuple concurrently as long as access to every individual reader is sequential. ### Parallel REntry Preparation; Multiple `REntry` object can be concurrently prepared by multiple threads.; I.e., construction and binding of the objects can happen in parallel.; The actual reading and writing of entries (`RNTupleReader::LoadEntry()`, `RNTupleWriter::Fill()`) needs to be protected by a mutex.; This is considered ""mild scalability parallelization"" in RNTuple. ### RNTupleParallelWriter; The parallel writer offers the most scalable parallel writing interface.; Multiple _fill contexts_ can concurrently serialize and compress data.; Every fill context prepares a set of entire clusters in the final on-disk layout.; When a fill context flushes data,; a brief serialization point handles the RNTuple meta-data updates and the reservation of disk space to write into. Low precision float types; --------------------------; RNTuple supports encoding floating point types with a lower precision when writing them to disk. This encoding is specified by the; user per field and it is independent on the in-memory type used for that field (meaning both a `RField<double>` or `RField<float>` can; be mapped to e.g. a low-precision 16 bit float). RNTuple supports the following encodings (all mutually exclusive):. - **Real16**/**SplitReal16**: IEEE-754 half precision float. Set by calling `RField::SetHalfPrecision()`;; - **Real32Trunc**: floating point with less than 32 bits of precision (truncated mantissa).; Set",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:25510,interface,interface,25510,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['interface'],['interface']
Integrability,"essions; Yes. 95; NAD; Elaborated type specifiers referencing names declared in friend decls; Clang 3.3. 96; C++11; Syntactic disambiguation using the template keyword; No. 97; NAD; Use of bool constants in integral constant expressions; Yes. 98; TC1; Branching into try block; Yes. 99; NAD; Partial ordering, references and cv-qualifiers; Superseded by 214. 100; TC1; Clarify why string literals are not allowed as template arguments; Yes. 101; TC1; Redeclaration of extern ""C"" names via using-declarations; Clang 3.5. 102; NAD; Operator lookup rules do not work well with parts of the library; Yes. 103; TC1; Is it extended-namespace-definition or extension-namespace-definition ?; N/A. 104; NAD; Destroying the exception temp when no handler is found; N/A (Library DR). 105; TC1; Meaning of ""template function""; N/A. 106; CD1; Creating references to references during template deduction/instantiation; Superseded by 540. 107; NAD; Linkage of operator functions; Yes. 108; TC1; Are classes nested in templates dependent?; Clang 2.9. 109; NAD; Allowing ::template in using-declarations; Yes. 110; CD6; Can template functions and classes be declared in the same scope?; Unknown. 111; NAD; Copy constructors and cv-qualifiers; Duplicate of 535. 112; CD1; Array types and cv-qualifiers; Yes. 113; CD1; Visibility of called function; Yes. 114; NAD; Virtual overriding by template member function specializations; Yes. 115; CD1; Address of template-id; Clang 3.0. 116; TC1; Equivalent and functionally-equivalent function templates; Yes. 117; NAD; Timing of destruction of temporaries; N/A. 118; CD1; Calls via pointers to virtual member functions; Yes. 119; CD1; Object lifetime and aggregate initialization; N/A. 120; TC1; Nonexistent non-terminal qualified-name; N/A. 121; TC1; Dependent type names with non-dependent nested-name-specifiers; Yes. 122; CD1; template-ids as unqualified-ids; Yes. 123; TC1; Bad cross-reference; N/A. 124; CD1; Lifetime of temporaries in default initialization of class ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:7960,depend,dependent,7960,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"est(id x) {; return;; [x retain]; // warn; }. alpha.fuchsia; ^^^^^^^^^^^^^. .. _alpha-fuchsia-lock:. alpha.fuchsia.Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of fuchsia mutexes. .. code-block:: cpp. spin_lock_t mtx1;. void bad1(void); {; spin_lock(&mtx1);; spin_lock(&mtx1);	// warn: This lock has already been acquired; }. alpha.llvm; ^^^^^^^^^^. .. _alpha-llvm-Conventions:. alpha.llvm.Conventions; """""""""""""""""""""""""""""""""""""""""""". Check code for LLVM codebase conventions:. * A StringRef should not be bound to a temporary std::string whose lifetime is shorter than the StringRef's.; * Clang AST nodes should not have fields that can allocate memory. alpha.osx; ^^^^^^^^^. .. _alpha-osx-cocoa-DirectIvarAssignment:. alpha.osx.cocoa.DirectIvarAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. .. _alpha-osx-cocoa-DirectIvarAssignmentForAnnotatedFunctions:. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables in; the methods annotated with ``objc_no_direct_instance_variable_assignment``. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. .. _alpha-osx-cocoa-InstanceVariableInvalidation:. alpha.osx.cocoa.InstanceVariableInvalidation (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidatable instance variables are; invalidated in the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:57269,interface,interface,57269,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['interface'],['interface']
Integrability,"et address is passed in X15.; ""``cc <n>``"" - Numbered convention; Any calling convention may be specified by number, allowing; target-specific calling conventions to be used. Target specific; calling conventions start at 64. More calling conventions can be added/defined on an as-needed basis, to; support Pascal conventions or any other well-known target-independent; convention. .. _visibilitystyles:. Visibility Styles; -----------------. All Global Variables and Functions have one of the following visibility; styles:. ""``default``"" - Default style; On targets that use the ELF object file format, default visibility; means that the declaration is visible to other modules and, in; shared libraries, means that the declared entity may be overridden.; On Darwin, default visibility means that the declaration is visible; to other modules. On XCOFF, default visibility means no explicit; visibility bit will be set and whether the symbol is visible; (i.e ""exported"") to other modules depends primarily on export lists; provided to the linker. Default visibility corresponds to ""external; linkage"" in the language.; ""``hidden``"" - Hidden style; Two declarations of an object with hidden visibility refer to the; same object if they are in the same shared object. Usually, hidden; visibility indicates that the symbol will not be placed into the; dynamic symbol table, so no other module (executable or shared; library) can reference it directly.; ""``protected``"" - Protected style; On ELF, protected visibility indicates that the symbol will be; placed in the dynamic symbol table, but that references within the; defining module will bind to the local symbol. That is, the symbol; cannot be overridden by another module. A symbol with ``internal`` or ``private`` linkage must have ``default``; visibility. .. _dllstorageclass:. DLL Storage Classes; -------------------. All Global Variables, Functions and Aliases can have one of the following; DLL storage class:. ``dllimport``; ""``dllimport``"" ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:23543,depend,depends,23543,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depends']
Integrability,"et(CONFIG_COMMAND ${LLVM_CONFIG}; ""--assertion-mode""; ""--bindir""; ""--libdir""; ""--includedir""; ""--prefix""; ""--cmakedir""; ""--build-mode""; ""--version""); execute_process(; COMMAND ${CONFIG_COMMAND}; RESULT_VARIABLE HAD_ERROR; OUTPUT_VARIABLE CONFIG_OUTPUT; ); if(NOT HAD_ERROR); string(REGEX REPLACE; ""[ \t]*[\r\n]+[ \t]*"" "";""; CONFIG_OUTPUT ${CONFIG_OUTPUT}); else(); string(REPLACE "";"" "" "" CONFIG_COMMAND_STR ""${CONFIG_COMMAND}""); message(STATUS ""${CONFIG_COMMAND_STR}""); message(FATAL_ERROR ""llvm-config failed with status ${HAD_ERROR}""); endif(); else(); message(FATAL_ERROR ""llvm-config not found -- ${LLVM_CONFIG}""); endif(). list(GET CONFIG_OUTPUT 0 ENABLE_ASSERTIONS); list(GET CONFIG_OUTPUT 1 TOOLS_BINARY_DIR); list(GET CONFIG_OUTPUT 2 LIBRARY_DIR); list(GET CONFIG_OUTPUT 3 INCLUDE_DIR); list(GET CONFIG_OUTPUT 4 LLVM_OBJ_ROOT); list(GET CONFIG_OUTPUT 5 LLVM_CONFIG_CMAKE_PATH); list(GET CONFIG_OUTPUT 6 LLVM_BUILD_MODE); list(GET CONFIG_OUTPUT 7 LLVM_VERSION). message(STATUS ""External llvm built in ${LLVM_BUILD_MODE} mode.""). if(NOT MSVC_IDE); set(LLVM_ENABLE_ASSERTIONS ${ENABLE_ASSERTIONS}; CACHE BOOL ""Enable assertions""); # Assertions should follow llvm-config's.; mark_as_advanced(LLVM_ENABLE_ASSERTIONS); endif(). set(LLVM_TOOLS_BINARY_DIR ${TOOLS_BINARY_DIR} CACHE PATH ""Path to llvm/bin""); set(LLVM_LIBRARY_DIR ${LIBRARY_DIR} CACHE PATH ""Path to llvm/lib""); set(LLVM_MAIN_INCLUDE_DIR ${INCLUDE_DIR} CACHE PATH ""Path to llvm/include""); set(LLVM_BINARY_DIR ${LLVM_OBJ_ROOT} CACHE PATH ""Path to LLVM build tree""). set(LLVM_DIR ""${LLVM_BINARY_DIR}""). # Normalize LLVM_CMAKE_PATH. --cmakedir might contain backslashes.; # CMake assumes slashes as PATH.; file(TO_CMAKE_PATH ${LLVM_CONFIG_CMAKE_PATH} LLVM_CMAKE_PATH). find_program(LLVM_TABLEGEN_EXE ""llvm-tblgen"" ${LLVM_TOOLS_BINARY_DIR}; NO_DEFAULT_PATH). set(LLVMCONFIG_FILE ""${LLVM_CMAKE_PATH}/LLVMConfig.cmake""); if(EXISTS ${LLVMCONFIG_FILE}); list(APPEND CMAKE_MODULE_PATH ""${LLVM_CMAKE_PATH}""); include(${LLVMCONFIG_FILE}); else(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:13679,message,message,13679,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['message'],['message']
Integrability,"et(stldicts; vector; list; forward_list; deque; map map2 unordered_map; multimap multimap2 unordered_multimap; set unordered_set; multiset unordered_multiset; complex); if(NOT WIN32); list(APPEND stldicts valarray); endif(); foreach(dict ${stldicts}); string(REPLACE ""2"" """" header ${dict}); string(REPLACE ""complex"" ""root_std_complex.h"" header ${header}); string(REPLACE ""multi"" """" header ${header}); ROOT_STANDARD_LIBRARY_PACKAGE(${dict}Dict; NO_SOURCES NO_INSTALL_HEADERS NO_CXXMODULE; STAGE1; NODEPHEADERS ${header}; LINKDEF src/${dict}Linkdef.h; DICTIONARY_OPTIONS --noIncludePaths; DEPENDENCIES Core); target_include_directories(${dict}Dict PRIVATE ${CMAKE_SOURCE_DIR}/interpreter/cling/include/cling/cint); endforeach(). set(CLANG_RESOURCE_DIR_STEM); if (builtin_clang); set(CLANG_RESOURCE_DIR_STEM ${CMAKE_BINARY_DIR}/interpreter/llvm-project/llvm/${CMAKE_CFG_INTDIR}/lib/clang); set(CLANG_RESOURCE_DIR_VERSION ${LLVM_VERSION_MAJOR}); else (); set(CLANG_RESOURCE_DIR_STEM ${LLVM_LIBRARY_DIR}/clang); # A user can define a clang version to use, otherwise find it (but will error if more than one version is present); if (NOT DEFINED CLANG_RESOURCE_DIR_VERSION); if (NOT EXISTS ${CLANG_RESOURCE_DIR_STEM}); message(FATAL_ERROR ""${CLANG_RESOURCE_DIR_STEM} does not exist. Please install clang.""); endif(); # There is no reasonable way to get the version of clang under which is its resource directory.; # For example, lib/clang/5.0.0/include. Deduce it.; file(GLOB CHILDREN RELATIVE ${CLANG_RESOURCE_DIR_STEM} ${CLANG_RESOURCE_DIR_STEM}/*); list(LENGTH CHILDREN CHILDREN_LENGTH); if (${CHILDREN_LENGTH} GREATER 1); message(FATAL_ERROR ""Found more than one version of clang. CLANG_RESOURCE_DIR_VERSION contains: '${CHILDREN}'."" ); endif(). list(GET CHILDREN 0 CLANG_RESOURCE_DIR_VERSION); endif(); endif(). set(CLANG_RESOURCE_DIR ${CLANG_RESOURCE_DIR_STEM}/${CLANG_RESOURCE_DIR_VERSION}/include). #---Deal with clang resource here----------------------------------------------; install(DIRECTORY ${",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/CMakeLists.txt:2957,message,message,2957,core/clingutils/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/CMakeLists.txt,1,['message'],['message']
Integrability,"et, Extend)>;; }. defm : ro_signed_pats<""B"", Rm, Base, Offset, Extend,; !foreach(decls.pattern, address,; !subst(SHIFT, imm_eq0, decls.pattern)),; i8>;. See the :doc:`TableGen Programmer's Reference <./ProgRef>` for an in-depth; description of TableGen. .. _backend:; .. _backends:. TableGen backends; =================. TableGen files have no real meaning without a backend. The default operation; when running ``*-tblgen`` is to print the information in a textual format, but; that's only useful for debugging the TableGen files themselves. The power; in TableGen is, however, to interpret the source files into an internal; representation that can be generated into anything you want. Current usage of TableGen is to create huge include files with tables that you; can either include directly (if the output is in the language you're coding),; or be used in pre-processing via macros surrounding the include of the file. Direct output can be used if the backend already prints a table in C format; or if the output is just a list of strings (for error and warning messages).; Pre-processed output should be used if the same information needs to be used; in different contexts (like Instruction names), so your backend should print; a meta-information list that can be shaped into different compile-time formats. See :doc:`TableGen BackEnds <./BackEnds>` for a list of available; backends, and see the :doc:`TableGen Backend Developer's Guide <./BackGuide>`; for information on how to write and debug a new backend. Tools and Resources; ===================. In addition to this documentation, a list of tools and resources for TableGen; can be found in TableGen's; `README <https://github.com/llvm/llvm-project/blob/main/llvm/utils/TableGen/README.md>`_. TableGen Deficiencies; =====================. Despite being very generic, TableGen has some deficiencies that have been; pointed out numerous times. The common theme is that, while TableGen allows; you to build domain specific languages, the f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/index.rst:11281,message,messages,11281,interpreter/llvm-project/llvm/docs/TableGen/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/index.rst,1,['message'],['messages']
Integrability,"et`** are specified by; `SetFlags(Int_t flags)` and `ClearFlags(Int_t flags)` methods. The; status flags are: `kWidgetWantFocus`, `kWidgetHasFocus`, and; `kWidgetIsEnabled`. The method `Associate(const TGWindow* w)` - sets the; window which handles the widget events.; `SetCommand(const char* command)` - sets the command to be executed. The; command string can be gathering via `GetCommand()` method. For example,; the third parameter in **`TGTextButton`** constructor can be omitted and; set later in your program, i.e. instead of:. ``` {.cpp}; TGTextButton *exit = new TGTextButton(hframe,""&Exit"",; ""gApplication->Terminate()"");; ```. You will have the following the two lines:. ``` {.cpp}; TGTextButton *exit = new TGTextButton(hframe,""&Exit"");; exit->SetCommand(""gApplication->Terminate()"");; ```. The method `IsEnabled()` - returns `kTRUE` if the widget has flag; `kWidgetIsEnabled` and it accepts user events. This method is very; important for creating a good user interface because it allows you to; disable or enable a widget depending on the situation of your; application. As a standard all disabled widgets are displayed ""grayed; out"". `HasFocus()` - returns `kTRUE` if the widget has the input focus; (i.e. flag `kWidgetHasFocus` is set). Remember that only one item in a; complex widget as a dialog can have the value of `HasFocus()` sets as; true. `WantFocus()` - returns `kTRUE` if the flag `kWidgetWantFocus` is; set. ### TGWindow. **`TGWindow`** is a ROOT GUI window base class. It inherits from; **`TGObject`** and **`TGFrame`** derives from it. The application does; not use it directly. It creates and registers a new window within the; system. This window has common characteristics: existing parent,; location, size in height and width (it has a default minimum size 1, 1; under which it cannot shrink), border with particular view, state,; specific attributes. If there are no specified arguments their values; will be taken from the parent. It receives events from the windo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:23126,interface,interface,23126,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,2,"['depend', 'interface']","['depending', 'interface']"
Integrability,"eter of a function or an ObjC method declaration or a; block. Does not match the 'this' parameter of a method. Given; class X { void f(int x, int y, int z) {} };; cxxMethodDecl(hasAnyParameter(hasName(""y""))); matches f(int x, int y, int z) {}; with hasAnyParameter(...); matching int y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasAnyParameter(hasName(""y""))); matches the declaration of method f with hasParameter; matching y. For blocks, given; b = ^(int y) { printf(""%d"", y) };. the matcher blockDecl(hasAnyParameter(hasName(""y""))); matches the declaration of the block b with hasParameter; matching y. Matcher<ObjCMethodDecl>hasParameterunsigned N, Matcher<ParmVarDecl> InnerMatcher; Matches the n'th parameter of a function or an ObjC method; declaration or a block. Given; class X { void f(int x) {} };; cxxMethodDecl(hasParameter(0, hasType(varDecl()))); matches f(int x) {}; with hasParameter(...); matching int x. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasParameter(0, hasName(""y""))); matches the declaration of method f with hasParameter; matching y. Matcher<ObjCPropertyDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:223227,interface,interface,223227,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['interface'],['interface']
Integrability,eter pack end?; Not resolved. 2106; CD4; Unclear restrictions on use of function-type template arguments; Unknown. 2107; CD4; Lifetime of temporaries for default arguments in array copying; Unknown. 2108; drafting; Conversions to non-class prvalues in reference initialization; Not resolved. 2109; CD4; Value dependence underspecified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown. 2115; drafting; Order of implicit destruction vs release of automatic storage; Not resolved. 2116; C++17; Direct or copy initialization for omitted aggregate initializers; Unknown. 2117; drafting; Explicit specializations and constexpr function templates; Not resolved. 2118; open; Stateful metaprogramming via friend injection; Not resolved. 2119; NAD; Disambiguation of multi-level covariant return type; Unknown. 2120; CD4; Array as first non-static data member in standard-layout class; Clang 7. 2121; CD6; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant initialization of local static variables; Not resolved. 2124; CD4; Signature of constructor template; Unknown. 2125; NAD; Copy elision and comma operator; Unknown. 2126; C++20; Lifetime-extended temporaries in constant expressions; Clang 12. 2127; drafting; Partial specialization and nullptr; Not resolved. 2128; drafting; Imprecise rule for reference member initializer; Not resolved. 2129; CD4; Non-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:144268,inject,injection,144268,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['inject'],['injection']
Integrability,"eterSettings` to define the properties of the fit parameters (initial; 	values, bounds, etc..), `ROOT::Fit::FitResult` for storing the result of the fit.; * Data classes containing the data sets used in the fitting. These classes are the`ROOT::Fit::BinData`for describing bin data sets,; 	 thus data points containing both coordinates and a corresponding value/weight; 	 with optionally an error on the value or the coordinate and the `ROOT::Fit::UnBinData` for un-binned data sets,; 	 which consists only of a vector of coordinate values. The coordinate values can be; 	 one-dimensional (i.e. one entry per event) or multi-dimensional (N entries per event).; * Function classes defining the type of fit (the objective function used for fitting):; 	- `ROOT::Fit::Chi2FCN` for chi2 (least-square fits),; 	- `ROOT::Fit::PoissonLikelihoodFCN` for binned likelihood fits of histograms,; 	- `ROOT::Fit::LogLikelihoodFCN` for generic un-binned likelihood fits.; 	These classes are templated on the type of function interface they implement (see later). User convenient typedefs are also provided.; 	They derive from the common generic interface multi-dimensional for function evaluation, `ROOT::Math::IBaseFunctionMultiDim`. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, `ROOT::Math::IParametricFunctionMultiDim`; to define the fit model function and use the `ROOT::Math::Minimizer` interface to perform the minimization of the objective function.; More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter. Here we present a detailed description of the `ROOT::Fit` classes and how to use them.; Using these classes instead of the interface provided directly in the ROOT data objects, like `TH1::Fit` allow are more fine control; to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed. To understand",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:27695,interface,interface,27695,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['interface'],['interface']
Integrability,"eterized ranges but are not involved in the; parameterization of others (e.g. x and y in the example above). Running integrals and Cumulative distribution functions. It is now possible to create running integrals from any RooAbsReal function and; to create cumulative distribution functions from any RooAbsPdf using the following; methods:. // Create int[xlo,x] f(x') dx' from f(x); RooAbsReal* runInt = func.createRunningIntegral(x) ;. // Create int[xlo,x] f(x') dx' from p.d.f f(x) normalized over x; RooAbsReal* cdf = pdf.createCdf(x) ;. // Create int[xlo,x] f(x',y) dx' from p.d.f f(x,y) normalized over (x,y); RooAbsReal* cdf = pdf.createCdf(x,y) ;. ; As with the similarly styled function createIntegral running integrals and c.d.f. can be created; over any number of observables, e.g createCdf(RooArgSet(x,y,z)) will create a three-dimensional; cumulative distribution function. C.d.f and running integrals that are calculated from p.d.fs that have; support for analytical integration are constructed from an appropriately reconnected RooRealIntegral.; If numeric integration is required, the c.d.f or running integral is calculated by a dedicated class; RooRunningIntegral that precalculates results for all observable values, which is more efficient; in most use cases. Cumulative distributions functions that are calculated numerically are handled slightly differently; that standard running integrals: their values is constructed to converge to exactly zero at the lower bound; and exactly 1 at the upper bound so that algorithms that make use of that property of c.d.f can do so reliably. Constraints management. New tools have been added to simplify studies with fits involving (external) constraints on parameters.; The general philosophy is that constraints on parameters can be represented as probability density functions; and can thus be modeled by RooAbsPdf classes (e.g. a RooGaussian for a simple Gaussian constraint on a parameter).; There are two modes of operation: you can add",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:5958,integrat,integration,5958,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['integrat'],['integration']
Integrability,"ethod 2. Another method allows to create the evolution of a given radioactive; material/mixture at a given moment in time:. ~~~{.cpp}; TGeoMaterial::DecayMaterial(Double_t time, Double_t precision=0.001); ~~~. The method will create the mixture that result from the decay of a; initial material/mixture at time, while all resulting elements having a; fractional weight less than precision are excluded. A demo macro for radioactive material features is; `$ROOTSYS/tutorials/geom/RadioNuclides.C` It demonstrates also the decay; of a mixture made of radionuclides. \image html geometry004.png width=600px. \anchor GM00c; ### Tracking Media. The class TGeoMedium describes tracking media properties. This has; a pointer to a material and the additional data members representing the; properties related to tracking. ~~~{.cpp}; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);; ~~~. - `name:` name assigned to the medium; - `mat:` pointer to a material; - `params:` array of additional parameters. Another constructor allows effectively defining tracking parameters in; GEANT3 style:. ~~~{.cpp}; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; ~~~. This constructor is reserved for creating tracking media from the VMC; interface [...]:. - `numed:` user-defined medium index; - `imat:` unique ID of the material; - `others:` see G3 documentation. Looking at our simple world example, one can see that for creating; volumes one needs to create tracking media before. The way to proceed; for those not interested in performing tracking with external MC's is to; define and use only one `dummy tracking medium` as in the example (or a; `NULL` pointer). \anchor GM00d; ### User Interface for Handling Materials and Media. The TGeoManager class contains the API for accessing and handling; defined materials:. ~~~{.cpp}; TGeoManager::GetMaterial(name);; ~~~. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md:9897,interface,interface,9897,geom/geom/doc/materials.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md,1,['interface'],['interface']
Integrability,"ethods follow such a convention very reliably, at least for; system libraries on macOS, and functions always pass objects at +0. The; C-based APIs for Core Foundation objects, on the other hand, have much more; varied transfer semantics. The use of ``__attribute__((NSObject))`` typedefs is not recommended. If it's; absolutely necessary to use this attribute, be very explicit about using the; typedef, and do not assume that it will be preserved by language features like; ``__typeof`` and C++ template argument substitution. .. admonition:: Rationale. Any compiler operation which incidentally strips type ""sugar"" from a type; will yield a type without the attribute, which may result in unexpected; behavior. .. _arc.objects.retains:. Retain count semantics; ----------------------. A retainable object pointer is either a :arc-term:`null pointer` or a pointer; to a valid object. Furthermore, if it has block pointer type and is not; ``null`` then it must actually be a pointer to a block object, and if it has; ``Class`` type (possibly protocol-qualified) then it must actually be a pointer; to a class object. Otherwise ARC does not enforce the Objective-C type system; as long as the implementing methods follow the signature of the static type.; It is undefined behavior if ARC is exposed to an invalid pointer. For ARC's purposes, a valid object is one with ""well-behaved"" retaining; operations. Specifically, the object must be laid out such that the; Objective-C message send machinery can successfully send it the following; messages:. * ``retain``, taking no arguments and returning a pointer to the object.; * ``release``, taking no arguments and returning ``void``.; * ``autorelease``, taking no arguments and returning a pointer to the object. The behavior of these methods is constrained in the following ways. The term; :arc-term:`high-level semantics` is an intentionally vague term; the intent is; that programmers must implement these methods in a way such that the compiler,; m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:12664,protocol,protocol-qualified,12664,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['protocol'],['protocol-qualified']
Integrability,"etry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of properties related to tracking); - *Matrices.* Allows creation of translations, rotations or combined; transformations. Existing matrices can also be browser/edited. \anchor GP08c; ### Editing Existing Objects. For editing an existing object from one of the categories described; above, the interface imposes first a selection among all objects of the; corresponding type stored in the geometry. This can be done by clicking; the button next to the blue label *Select \<object\>*. The dialog; interfaces are generally different for different types of objects. The; volume selection dialog offers the possibility to select either a volume; already connected to the geometry hierarchy or non-connected ones.; Selection for shapes and matrices is split into categories represented; by top-level list tree items for: boxes, tubes, translations, rotations,; etc. \image html geometry020.png ""Selection dialogs for different TGeo objects"". Once a selection is made and the dialog is closed, the selected item; name will appear in the corresponding label and the button Edit will; start the object editor in a transient frame. Closing these transient; frames will not delete, but just hide existing opened editors for later; reuse. Their lifetime is determined by the canvas to which the manager; editor is att",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:129265,interface,interface,129265,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['interface'],['interface']
Integrability,"etting next clang stage to: ${NEXT_CLANG_STAGE}""). set(STAMP_DIR ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-stamps/); set(BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/${NEXT_CLANG_STAGE}-bins/). if(BOOTSTRAP_LLVM_ENABLE_LLD); # adding lld to clang-bootstrap-deps without having it enabled in; # LLVM_ENABLE_PROJECTS just generates a cryptic error message.; if (NOT ""lld"" IN_LIST LLVM_ENABLE_PROJECTS); message(FATAL_ERROR ""LLD is enabled in the bootstrap build, but lld is not in LLVM_ENABLE_PROJECTS""); endif(); add_dependencies(clang-bootstrap-deps lld); endif(). if (WIN32); # Build llvm-rc and llvm-mt which are needed by the Windows build.; add_dependencies(clang-bootstrap-deps llvm-rc); if(LLVM_ENABLE_LIBXML2); add_dependencies(clang-bootstrap-deps llvm-mt); endif(); endif(). # If the next stage is LTO we need to depend on LTO and possibly lld or LLVMgold; if(BOOTSTRAP_LLVM_ENABLE_LTO OR LLVM_ENABLE_LTO AND NOT LLVM_BUILD_INSTRUMENTED); if(APPLE); add_dependencies(clang-bootstrap-deps LTO); # on Darwin we need to set DARWIN_LTO_LIBRARY so that -flto will work; # using the just-built compiler, and we need to override DYLD_LIBRARY_PATH; # so that the host object file tools will use the just-built libLTO.; # However if System Integrity Protection is enabled the DYLD variables; # will be scrubbed from the environment of any base system commands. This; # includes /bin/sh, which ninja uses when executing build commands. To; # work around the envar being filtered away we pass it in as a CMake; # variable, and have LLVM's CMake append the envar to the archiver calls.; set(LTO_LIBRARY -DDARWIN_LTO_LIBRARY=${LLVM_SHLIB_OUTPUT_INTDIR}/libLTO.dylib; -DDYLD_LIBRARY_PATH=${LLVM_LIBRARY_OUTPUT_INTDIR}); elseif(MSVC); add_dependencies(clang-bootstrap-deps llvm-lib); set(${CLANG_STAGE}_AR -DCMAKE_AR=${LLVM_RUNTIME_OUTPUT_INTDIR}/llvm-lib); elseif(NOT WIN32); add_dependencies(clang-bootstrap-deps llvm-ar llvm-ranlib); if(NOT BOOTSTRAP_LLVM_ENABLE_LLD AND LLVM_BINUTILS_INCDIR); add_depend",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:21475,depend,depend,21475,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['depend'],['depend']
Integrability,"eturn error;; }; }; if (FoundDeclsList is empty) {; Import dependent declarations and types of ToDecl;; ToDecl = create a new AST node in ""to"" Ctx;; Mark FromD as imported;; }; return ToDecl;; }. Two AST nodes are *structurally equivalent* if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and their types are structurally equivalent. We could extend the definition of structural equivalency to templates similarly. If A and B are AST nodes and *A depends on B*, then we say that A is a **dependant** of B and B is a **dependency** of A.; The words ""dependant"" and ""dependency"" are nouns in British English.; Unfortunately, in American English, the adjective ""dependent"" is used for both meanings.; In this document, with the ""dependent"" adjective we always address the dependencies, the B node in the example. API; ---. Let's create a tool which uses the ASTImporter class!; First, we build two ASTs from virtual files; the content of the virtual files are synthesized from string literals:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");. The first AST corresponds to the destination (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match ``MyClass`` in the ""from"" context:. .. code-block:: cpp. auto Matcher = cxxRecordDecl(hasName(""MyClass""));; auto *From = getFirstDecl<CXXRecordDecl>(Matcher, FromUnit);. Now we create the Importer and do the import:. .. code-block:: cpp. ASTImporter Importer(ToUnit->getASTCon",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:4454,depend,dependent,4454,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,1,['depend'],['dependent']
Integrability,"eturn types: they always return null. With these basic helper functions, we can implement the first piece of; our grammar: numeric literals. Basic Expression Parsing; ========================. We start with numeric literals, because they are the simplest to; process. For each production in our grammar, we'll define a function; which parses that production. For numeric literals, we have:. .. code-block:: c++. /// numberexpr ::= number; static std::unique_ptr<ExprAST> ParseNumberExpr() {; auto Result = std::make_unique<NumberExprAST>(NumVal);; getNextToken(); // consume the number; return std::move(Result);; }. This routine is very simple: it expects to be called when the current; token is a ``tok_number`` token. It takes the current number value,; creates a ``NumberExprAST`` node, advances the lexer to the next token,; and finally returns. There are some interesting aspects to this. The most important one is; that this routine eats all of the tokens that correspond to the; production and returns the lexer buffer with the next token (which is; not part of the grammar production) ready to go. This is a fairly; standard way to go for recursive descent parsers. For a better example,; the parenthesis operator is defined like this:. .. code-block:: c++. /// parenexpr ::= '(' expression ')'; static std::unique_ptr<ExprAST> ParseParenExpr() {; getNextToken(); // eat (.; auto V = ParseExpression();; if (!V); return nullptr;. if (CurTok != ')'); return LogError(""expected ')'"");; getNextToken(); // eat ).; return V;; }. This function illustrates a number of interesting things about the; parser:. 1) It shows how we use the LogError routines. When called, this function; expects that the current token is a '(' token, but after parsing the; subexpression, it is possible that there is no ')' waiting. For example,; if the user types in ""(4 x"" instead of ""(4)"", the parser should emit an; error. Because errors can occur, the parser needs a way to indicate that; they happened: in our pa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:7857,rout,routine,7857,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['rout'],['routine']
Integrability,"ety`` implicitly adds the redundant bounds; checks that the optimizer can remove:. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, size_t count) {; for (size_t i = 0; i < count; ++i) {; // implicit bounds checks:; // if (p + i < p || p + i + 1 > p + count) trap();; p[i] = i;; }; }. ``ConstraintElimination`` collects the following facts and determines if the; bounds checks can be safely removed:. * Inside the for-loop, ``0 <= i < count``, hence ``1 <= i + 1 <= count``.; * Pointer arithmetic ``p + count`` in the if-condition doesn’t wrap.; * ``-fbounds-safety`` treats pointer arithmetic overflow as deterministically; two’s complement computation, not an undefined behavior. Therefore,; getelementptr does not typically have inbounds keyword. However, the compiler; does emit inbounds for ``p + count`` in this case because; ``__counted_by(count)`` has the invariant that p has at least as many as; elements as count. Using this information, ``ConstraintElimination`` is able; to determine ``p + count`` doesn’t wrap.; * Accordingly, ``p + i`` and ``p + i + 1`` also don’t wrap.; * Therefore, ``p <= p + i`` and ``p + i + 1 <= p + count``.; * The if-condition simplifies to false and becomes dead code that the subsequent; optimization passes can remove. ``OptRemarks`` can be utilized to provide insights into performance tuning. It; has the capability to report on checks that it cannot eliminate, possibly with; reasons, allowing programmers to adjust their code to unlock further; optimizations. Debugging; =========. Internal bounds annotations; ---------------------------. Internal bounds annotations change a pointer into a wide pointer. The debugger; needs to understand that wide pointers are essentially pointers with a struct; layout. To handle this, a wide pointer is described as a record type in the; debug info. The type name has a special name prefix (e.g.,; ``__bounds_safety$bidi_indexable``) which can be recognized by a debug info; consumer to pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:7712,wrap,wrap,7712,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['wrap'],['wrap']
Integrability,"eve the geometry in a ready state, ignoring what the state; variables that can be always re-initialized. When the code is generated; for a given **`TGeoVolume`** in the geometry, just the branch starting; with that volume will be saved in the file. Executing the generated code; will create a geometry that has `MyVolume` as top volume. In this case,; only the materials/media/matrices used effectively in the `MyVolume`; branch are exported to file. Volumes can be made persistent in the same way the full geometry is.; Exporting is straightforward (module1, 2 are pointers to; **`TGeoVolume`** objects):. ``` {.cpp}; module1->Export(""file.root"");; // by default file is overwritten; module2->Export(""file.root"","""",""update"");; // to the same file; ```. Importing will append the volume to the current TGeoManager or will; create one:. ``` {.cpp}; TGeoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; ```. ### GDML. Few lines above word GDML was used. GDML stands for **G**eometry; **D**escription **M**arkup **L**anguage. It is an application-independent; geometry description format based on XML. It is mainly used for geometry; interchange between ROOT and Geant4 framework. More details about this; project can be found http://gdml.web.cern.ch. This feature; (importing/exporting from/to gdml file format) is disabled by default in; ROOT installation. To enable this feature add `--enable-gdml` option to; `./configure` script call. ## Navigation Algorithms. This section will describe the main methods and algorithms used for; implementing the navigation features withi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:153643,depend,depending,153643,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['depend'],['depending']
Integrability,"event error dterr and all its parameters, convoluted with a triple; gaussian resolution model and multiplied with a Gaussian p.d.f. in the; energy substituted mass. (In plain RooFit this would have required at; least 23 lines of code). A series of three new tutorial macros has been added to illustrate the; various features of the object factory. rf511_wsfactory_basic.C - Basic factory concepts; rf512_wsfactory_oper.C - Using operator p.d.f.s in the factory; rf513_wsfactory_tools.C - Advanced example using interfaced high level tools. A formal transaction model is used to commit composite objects into; the workspace. If an error is detected in the expression, no objects; will be committed to the workspace, thus leaving no 'partial builds'. Compact demo of several new major features. The macro below demonstrates in a couple of lines a number of major new features in RooFit 3.00: Use of. workspace factory to quickly create and store (compiled) models; workspace CINT interface to easily access contents in a typesafe way; new adaptive ND numeric integration technique to normalize arbitrary p.d.f. in fast; and reliable way; new adaptive TFoam sampling technique to efficiently generate toy MC data from strongly; peaked datasets; parallel processing in likelihood construction and use of profile likelihood operator; to represent profile likelihoods as regular RooFit functions. void demo(); {; // Construct compiled 2-D model that requires numeric integration for normalization; RooWorkspace w(""w"",1) ;; w.factory(""CEXPR::model('1/((x-a)*(x-a)+0.001)+1/((y-b)*(y-b)+0.001)',x[-1,1],y[-1,1],a[-5,5],b[-5,5])"") ;. // Generate data from model (using TFoam adaptive sampling algorithm); RooDataSet* d = w::model.generate(RooArgSet(w::x,w::y),1000) ;; w::model.fitTo(*d) ;. // Make 2D plot on (x,y); TH2* hh = w::model.createHistogram(""x,y"",40,40) ;; hh->SetLineColor(kBlue) ;. // Make Projection on x (integrate over y); RooPlot* framex = w::x.frame(Title(""Data and p.d.f. projected on X"")) ;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:22011,interface,interface,22011,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,"['integrat', 'interface']","['integration', 'interface']"
Integrability,"ever need to be converted; to a ``std::error_code`` you can use the ``inconvertibleErrorCode()`` function:. .. code-block:: c++. createStringError(inconvertibleErrorCode(), ""Bad executable"");. This should be done only after careful consideration. If any attempt is made to; convert this error to a ``std::error_code`` it will trigger immediate program; termination. Unless you are certain that your errors will not need; interoperability you should look for an existing ``std::error_code`` that you; can convert to, and even (as painful as it is) consider introducing a new one as; a stopgap measure. ``createStringError`` can take ``printf`` style format specifiers to provide a; formatted message:. .. code-block:: c++. createStringError(errc::executable_format_error,; ""Bad executable: %s"", FileName);. Interoperability with std::error_code and ErrorOr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Many existing LLVM APIs use ``std::error_code`` and its partner ``ErrorOr<T>``; (which plays the same role as ``Expected<T>``, but wraps a ``std::error_code``; rather than an ``Error``). The infectious nature of error types means that an; attempt to change one of these functions to return ``Error`` or ``Expected<T>``; instead often results in an avalanche of changes to callers, callers of callers,; and so on. (The first such attempt, returning an ``Error`` from; MachOObjectFile's constructor, was abandoned after the diff reached 3000 lines,; impacted half a dozen libraries, and was still growing). To solve this problem, the ``Error``/``std::error_code`` interoperability requirement was; introduced. Two pairs of functions allow any ``Error`` value to be converted to a; ``std::error_code``, any ``Expected<T>`` to be converted to an ``ErrorOr<T>``, and vice; versa:. .. code-block:: c++. std::error_code errorToErrorCode(Error Err);; Error errorCodeToError(std::error_code EC);. template <typename T> ErrorOr<T> expectedToErrorOr(Expected<T> TOrErr);; template <typename T> Expected<T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:28428,wrap,wraps,28428,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['wrap'],['wraps']
Integrability,"ever, under certain circumstances, ARC is permitted to re-order and; eliminate operations in a manner which may alter the overall; computation history beyond what is permitted by the general ""as if""; rule of C/C++ and the :ref:`restrictions <arc.objects.retains>` on; the implementation of ``retain`` and ``release``. .. admonition:: Rationale. Specifically, ARC is sometimes permitted to optimize ``release``; operations in ways which might cause an object to be deallocated; before it would otherwise be. Without this, it would be almost; impossible to eliminate any ``retain``/``release`` pairs. For; example, consider the following code:. .. code-block:: objc. id x = _ivar;; [x foo];. If we were not permitted in any event to shorten the lifetime of the; object in ``x``, then we would not be able to eliminate this retain; and release unless we could prove that the message send could not; modify ``_ivar`` (or deallocate ``self``). Since message sends are; opaque to the optimizer, this is not possible, and so ARC's hands; would be almost completely tied. ARC makes no guarantees about the execution of a computation history; which contains undefined behavior. In particular, ARC makes no; guarantees in the presence of race conditions. ARC may assume that any retainable object pointers it receives or; generates are instantaneously valid from that point until a point; which, by the concurrency model of the host language, happens-after; the generation of the pointer and happens-before a release of that; object (possibly via an aliasing pointer or indirectly due to; destruction of a different object). .. admonition:: Rationale. There is very little point in trying to guarantee correctness in the; presence of race conditions. ARC does not have a stack-scanning; garbage collector, and guaranteeing the atomicity of every load and; store operation would be prohibitive and preclude a vast amount of; optimization. ARC may assume that non-ARC code engages in sensible balancing; behavior ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:77198,message,message,77198,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"evision"" as a whole used for the; commit message). If you suggest changes in a code review, but don't wish the suggestion to be; interpreted this strongly, please state so explicitly. Aim to Make Efficient Use of Everyone's Time; --------------------------------------------. Aim to limit the number of iterations in the review process. For example, when; suggesting a change, if you want the author to make a similar set of changes at; other places in the code, please explain the requested set of changes so that; the author can make all of the changes at once. If a patch will require; multiple steps prior to approval (e.g., splitting, refactoring, posting data; from specific performance tests), please explain as many of these up front as; possible. This allows the patch author and reviewers to make the most efficient; use of their time. LGTM - How a Patch Is Accepted; ------------------------------. A patch is approved to be committed when a reviewer accepts it, and this is; almost always associated with a message containing the text ""LGTM"" (which; stands for Looks Good To Me). Only approval from a single reviewer is required. When providing an unqualified LGTM (approval to commit), it is the; responsibility of the reviewer to have reviewed all of the discussion and; feedback from all reviewers ensuring that all feedback has been addressed and; that all other reviewers will almost surely be satisfied with the patch being; approved. If unsure, the reviewer should provide a qualified approval, (e.g.,; ""LGTM, but please wait for @someone, @someone_else""). You may also do this if; you are fairly certain that a particular community member will wish to review,; even if that person hasn't done so yet. Note that, if a reviewer has requested a particular community member to review,; and after a week that community member has yet to respond, feel free to ping; the patch (which literally means submitting a comment on the patch with the; word, ""Ping.""), or alternatively, ask the o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:6575,message,message,6575,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,1,['message'],['message']
Integrability,"ework may be compared to living in the; country. In order to have transportation and water, you will have to; build a road and dig a well. To have services like telephone and; electricity you will need to route the wires to your home. In; addition, you cannot build some things yourself. For example, you; cannot build a commercial airport on your patch of land. From a global; perspective, it would make no sense for everyone to build their; own airport. You see you will be very busy building the infrastructure; (or framework) before you can use the phone to communicate with your; collaborators and have a drink of water at the same time. In software; engineering, it is much the same way. In a framework, the basic; utilities and services, such as I/O and graphics, are provided. In; addition, ROOT being a HEP analysis framework, it provides a large; selection of HEP specific utilities such as histograms and fitting.; The drawback of a framework is that you are constrained to it, as you; are constraint to use the routing algorithm provided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a telephone. If you are interested in doing physics, a good HEP framework will save; you much work. Next is a list of the more commonly used components of; ROOT: Command Line Interpreter, Histograms and Fitting, Writing a; Graphical User Interface, 2D Graphics, Input/Output , Collection; Classes, Script Processor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:6436,rout,routing,6436,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['rout'],['routing']
Integrability,"example of classes with template arguments. First, we; define a class similar to the ``FPFormat`` class above. It takes a template; argument and uses it to initialize a field named ``Value``. Then we define; four records that inherit the ``Value`` field with its four different; integer values. .. code-block:: text. class ModRefVal <bits<2> val> {; bits<2> Value = val;; }. def None : ModRefVal<0>;; def Mod : ModRefVal<1>;; def Ref : ModRefVal<2>;; def ModRef : ModRefVal<3>;. This is somewhat contrived, but let's say we would like to examine the two; bits of the ``Value`` field independently. We can define a class that; accepts a ``ModRefVal`` record as a template argument and splits up its; value into two fields, one bit each. Then we can define records that inherit from; ``ModRefBits`` and so acquire two fields from it, one for each bit in the; ``ModRefVal`` record passed as the template argument. .. code-block:: text. class ModRefBits <ModRefVal mrv> {; // Break the value up into its bits, which can provide a nice; // interface to the ModRefVal values.; bit isMod = mrv.Value{0};; bit isRef = mrv.Value{1};; }. // Example uses.; def foo : ModRefBits<Mod>;; def bar : ModRefBits<Ref>;; def snork : ModRefBits<ModRef>;. This illustrates how one class can be defined to reorganize the; fields in another class, thus hiding the internal representation of that; other class. Running ``llvm-tblgen`` on the example prints the following definitions:. .. code-block:: text. def bar { // Value; bit isMod = 0;; bit isRef = 1;; }; def foo { // Value; bit isMod = 1;; bit isRef = 0;; }; def snork { // Value; bit isMod = 1;; bit isRef = 1;; }. ``let`` --- override fields in classes or records; -------------------------------------------------. A ``let`` statement collects a set of field values (sometimes called; *bindings*) and applies them to all the classes and records defined by; statements within the scope of the ``let``. .. productionlist::; Let: ""let"" `LetList` ""in"" ""{"" `Statement`*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:32060,interface,interface,32060,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['interface'],['interface']
Integrability,"exp(-(x^2)-(y^2))"",-3,3,-3,3);; // two contours less than the number of colors in palette; f2->SetContour(colNum-2);; f2->Draw(""cont"");; }; ```. Since ROOT 6.26, you can also define a palette based on an ASCII text; file, using `TColor::CreateColorTableFromFile(""filename.txt"")` or; `gStyle->SetPalette(""filename.txt"")`. The input file contains one color; per line in ""r g b"" float format. This function is useful to profit from; a full set of colour-vision deficiency friendly and perceptually uniform; colour maps that are available to; [download](https://doi.org/10.5281/zenodo.4491293). ## The Graphics Editor. A new graphics editor took place in ROOT v4.0. The editor can be; activated by selecting the Editor menu entry in the canvas View menu or; one of the context menu entries for setting line, fill, marker or text; attributes. The following object editors are available for the current; ROOT version. ### TAxisEditor. ![](pictures/030000D5.png). This user interface gives the possibility for changing the following; axis attributes:. - color of the selected axis, the axis' title and labels;. - the length of thick parameters and the possibility to set them on; both axis sides (if `+-` is selected);. - to set logarithmic or linear scale along the selected axis with a; choice for optimized or more logarithmic labels;. - primary, secondary and tertiary axis divisions can be set via the; three number fields;. - the axis title can be added or edited and the title's color,; position, offset, size and font can be set interactively;. - the color, size, and offset of axis labels can be set similarly. In; addition, there is a check box for no exponent choice, and another; one for setting the same decimal part for all labels. ### TPadEditor. ![](pictures/030000D6.png). - It provides the following user interface:. - Fixed aspect ratio - can be set for pad resizing. - Edit - sets pad or canvas as editable. - Cross-hair - sets a cross hair on the pad. - TickX - set ticks along the X ax",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:84411,interface,interface,84411,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['interface'],['interface']
Integrability,"expect`` intrinsics, i.e., through use of; ``__builtin_expect(...)``, they are trying to communicate how their code is; expected to behave at runtime to the optimizer. These annotations, however, can; be incorrect for a variety of reasons: changes to the code base invalidate them; silently, the developer mis-annotated them (e.g., using ``LIKELY`` instead of; ``UNLIKELY``), or perhaps they assumed something incorrectly when they wrote; the annotation. Regardless of why, it is useful to detect these situations so; that the optimizer can make more useful decisions about the code. MisExpect; diagnostics are intended to help developers identify and address these; situations, by comparing the use of the ``llvm.expect`` intrinsic to the ground; truth provided by a profiling input. The MisExpect checks in the LLVM backend follow a simple procedure: if there is; a mismatch between the branch weights collected during profiling and those; supplied by an ``llvm.expect`` intrinsic, then it will emit a diagnostic; message to the user. The most natural place to perform the verification is just prior to when; branch weights are assigned to the target instruction in the form of; branch weight metadata. There are 3 key places in the LLVM backend where branch weights are; created and assigned based on profiling information or the use of the; ``llvm.expect`` intrinsic, and our implementation focuses on these; places to perform the verification. We calculate the threshold for emitting MisExpect related diagnostics; based on the values the compiler assigns to ``llvm.expect`` intrinsics,; which can be set through the ``-likely-branch-weight`` and; ``-unlikely-branch-weight`` LLVM options. During verification, if the; profile weights mismatch the calculated threshold, then we will emit a; remark or warning detailing a potential performance regression. The; diagnostic also reports the percentage of the time the annotation was; correct during profiling to help developers reason about how to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MisExpect.rst:1139,message,message,1139,interpreter/llvm-project/llvm/docs/MisExpect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MisExpect.rst,1,['message'],['message']
Integrability,explicit specialization; Not resolved. 1994; dup; Confusing wording regarding multiple template<> prefixes; Duplicate of 529. 1995; CD4; exception-specifications and non-type template parameters; Unknown. 1996; drafting; Reference list-initialization ignores conversion functions; Not resolved. 1997; drafting; Placement new and previous initialization; Not resolved. 1998; NAD; Additional sources of xvalue expressions; Unknown. 1999; CD4; Representation of source characters as universal-character-names; Unknown. 2000; CD4; header-name outside #include directive; Unknown. 2001; CD4; non-directive is underspecified; Unknown. 2002; open; White space within preprocessing directives; Not resolved. 2003; drafting; Zero-argument macros incorrectly specified; Not resolved. 2004; CD4; Unions with mutable members in constant expressions; Unknown. 2005; NAD; Incorrect constexpr reference initialization requirements; Unknown. 2006; CD4; Cv-qualified void types; Unknown. 2007; CD6; Argument-dependent lookup for operator=; Clang 3.4. 2008; CD4; Default template-arguments underspecified; Unknown. 2009; CD6; Unclear specification of class scope; N/A. 2010; CD4; exception-specifications and conversion operators; Unknown. 2011; C++17; Unclear effect of reference capture of reference; Unknown. 2012; CD4; Lifetime of references; Unknown. 2013; drafting; Pointer subtraction in large array; Not resolved. 2014; NAD; Unneeded deallocation signatures; Unknown. 2015; CD4; odr-use of deleted virtual functions; Unknown. 2016; CD4; Confusing wording in description of conversion function; Unknown. 2017; CD4; Flowing off end is not equivalent to no-expression return; Unknown. 2018; dup; Qualification conversion vs reference binding; Unknown. 2019; CD4; Member references omitted from description of storage duration; Unknown. 2020; CD5; Inadequate description of odr-use of implicitly-invoked functions; Unknown. 2021; dup; Function template redeclaration via alias template; Unknown. 2022; CD4; Copy eli,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:136448,depend,dependent,136448,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"explicitly written in; code (as opposed to implicitly added by the compiler). Given; struct Foo {; Foo() { }; Foo(int) : foo_(""A"") { }; string foo_;; };; cxxConstructorDecl(hasAnyConstructorInitializer(isWritten())); will match Foo(int), but not Foo(). Matcher<CXXDeductionGuideDecl>isExplicit; Matches constructor, conversion function, and deduction guide declarations; that have an explicit specifier if this explicit specifier is resolved to; true. Given; template<bool b>; struct S {; S(int); // #1; explicit S(double); // #2; operator int(); // #3; explicit operator bool(); // #4; explicit(false) S(bool) // # 7; explicit(true) S(char) // # 8; explicit(b) S(S) // # 9; };; S(int) -> S<true> // #5; explicit S(double) -> S<false> // #6; cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9.; cxxConversionDecl(isExplicit()) will match #4, but not #3.; cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. Matcher<CXXDependentScopeMemberExpr>hasMemberNamestd::string N; Matches template-dependent, but known, member names. In template declarations, dependent members are not resolved and so can; not be matched to particular named declarations. This matcher allows to match on the known name of members. Given; template <typename T>; struct S {; void mem();; };; template <typename T>; void x() {; S<T> s;; s.mem();; }; cxxDependentScopeMemberExpr(hasMemberName(""mem"")) matches `s.mem()`. Matcher<CXXDependentScopeMemberExpr>isArrow; Matches member expressions that are called with '->' as opposed; to '.'. Member calls on the implicit this pointer match as called with '->'. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; template <class T> void f() { this->f<T>(); f<T>(); }; int a;; static int b;; };; template <class T>; class Z {; void x() { this->m; }; };; memberExpr(isArrow()); matches this->x, x, y.x, a, this->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:64623,depend,dependent,64623,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['depend'],['dependent']
Integrability,"expression; <LangRef.html#diexpression>`_. An `llvm.dbg.value` intrinsic describes the *value* of a source variable; directly, not its address. Note that the value operand of this intrinsic may; be indirect (i.e, a pointer to the source variable), provided that interpreting; the complex expression derives the direct value. ``llvm.dbg.assign``; ^^^^^^^^^^^^^^^^^^^; .. toctree::; :hidden:. AssignmentTracking. .. code-block:: llvm. void @llvm.dbg.assign(Value *Value,; DIExpression *ValueExpression,; DILocalVariable *Variable,; DIAssignID *ID,; Value *Address,; DIExpression *AddressExpression). This intrinsic marks the position in IR where a source assignment occurred. It; encodes the value of the variable. It references the store, if any, that; performs the assignment, and the destination address. The first three arguments are the same as for an ``llvm.dbg.value``. The fourth; argument is a ``DIAssignID`` used to reference a store. The fifth is the; destination of the store (wrapped as metadata), and the sixth is a `complex; expression <LangRef.html#diexpression>`_ that modifies it. The formal LLVM-IR signature is:. .. code-block:: llvm. void @llvm.dbg.assign(metadata, metadata, metadata, metadata, metadata, metadata). See :doc:`AssignmentTracking` for more info. Object lifetimes and scoping; ============================. In many languages, the local variables in functions can have their lifetimes or; scopes limited to a subset of a function. In the C family of languages, for; example, variables are only live (readable and writable) within the source; block that they are defined in. In functional languages, values are only; readable after they have been defined. Though this is a very obvious concept,; it is non-trivial to model in LLVM, because it has no notion of scoping in this; sense, and does not want to be tied to a language's scoping rules. In order to handle this, the LLVM debug format uses the metadata attached to; llvm instructions to encode line number and sc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:11551,wrap,wrapped,11551,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['wrap'],['wrapped']
Integrability,"extSize` error: show code and values.; - Very long text string generated a wrong SVG file.; - Fix the option `SAME` works for `TGraph2D`.; - Implement the title for the palette of a `TH3`.; - Fix typo in `TLegend::PaintPrimitives()` and improve the exclusion graphs legend.; - `SetParameters(…)` or `SetParameter(…)` on a TF1 reset the properties of the axis that have been previously defined.; This was due to the `Update()` that was done after the parameters definition.; - Update fonts' documentation (CMS request).; - Delaunay triangles were computed by the package `triangle.c` included in the ROOT code.; This package had several problems:; - It was not maintained anymore.; - Its license was not compatible with LGPL.; It is now replaced by the CDT package which is properly maintained and has a license (MLP) compatible with LGPL. ## 3D Graphics Libraries. ### REve; * Introduce lightweight visualization of instanced shapes on the level of 100.000 instances. This is integrated in digit visualization of the type REveBoxSet. List of typed instances are boxes, hexagons, and cones. The digit sets support different types of transformation: positioning, rotation, and scaling in different combinations. With the digit set a palette GUI interface has also been added to enable setting digits threshold and value to color mapping. <figure>; <img src=""reve-boxset-cones.png"" >; <figcaption>REveBoxSet screenshot with cone shape type. The set is using value to color map with overflow and underflow mark. The single REveBoxet object has a secondary selection enabled, where one can set a custom tooltip on mouse hover of an individual instance.</figcaption>; </figure>. * Update version of RenderCore to fix tone mapping of transparent objects. ## PROOF Libraries. By default, PROOF is not configured and built any more. It will be deprecated in the future given that its functionality is now provided by the superior RDataFrame and its distributed version, [DistRDF](https://root.cern/doc/master/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:18165,integrat,integrated,18165,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['integrat'],['integrated']
Integrability,"extra_sources`` will be; evaluated as empty before add_executable is given its arguments. Lists; -----. In CMake lists are semi-colon delimited strings, and it is strongly advised that; you avoid using semi-colons in lists; it doesn't go smoothly. A few examples of; defining lists:. .. code-block:: cmake. # Creates a list with members a, b, c, and d; set(my_list a b c d); set(my_list ""a;b;c;d""). # Creates a string ""a b c d""; set(my_string ""a b c d""). Lists of Lists; --------------. One of the more complicated patterns in CMake is lists of lists. Because a list; cannot contain an element with a semi-colon to construct a list of lists you; make a list of variable names that refer to other lists. For example:. .. code-block:: cmake. set(list_of_lists a b c); set(a 1 2 3); set(b 4 5 6); set(c 7 8 9). With this layout you can iterate through the list of lists printing each value; with the following code:. .. code-block:: cmake. foreach(list_name IN LISTS list_of_lists); foreach(value IN LISTS ${list_name}); message(${value}); endforeach(); endforeach(). You'll notice that the inner foreach loop's list is doubly dereferenced. This is; because the first dereference turns ``list_name`` into the name of the sub-list; (a, b, or c in the example), then the second dereference is to get the value of; the list. This pattern is used throughout CMake, the most common example is the compiler; flags options, which CMake refers to using the following variable expansions:; CMAKE_${LANGUAGE}_FLAGS and CMAKE_${LANGUAGE}_FLAGS_${CMAKE_BUILD_TYPE}. Other Types; -----------. Variables that are cached or specified on the command line can have types; associated with them. The variable's type is used by CMake's UI tool to display; the right input field. A variable's type generally doesn't impact evaluation,; however CMake does have special handling for some variables such as PATH.; You can read more about the special handling in `CMake's set documentation; <https://cmake.org/cmake/help/v3.5/co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:5153,message,message,5153,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['message'],['message']
Integrability,"eychainAttributeList *attrList = 0;; UInt32 *length = 0;; void *outData = 0;. OSStatus st =; SecKeychainItemCopyAttributesAndData(itemRef, info,; itemClass, &attrList,; length, &outData);. SecKeychainItemFreeContent(attrList, outData);; // warn: deallocator doesn't match the allocator; }. osx.cocoa.AtSync; (ObjC); Check for nil pointers used as mutexes for @synchronized. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var wasn't retained but was released; - (void)dealloc {; [_myproperty release];; [super dealloc];; }; @end. osx.cocoa.IncompatibleMethodTypes; (ObjC); Check for an incompatible type signature when overriding an Objective-C method. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (fl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:15284,interface,interface,15284,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['interface'],['interface']
Integrability,"f ``true``, horizontally align operands of binary and ternary; expressions. Possible values:. * ``OAS_DontAlign`` (in configuration: ``DontAlign``); Do not align operands of binary and ternary expressions.; The wrapped lines are indented ``ContinuationIndentWidth`` spaces from; the start of the line. * ``OAS_Align`` (in configuration: ``Align``); Horizontally align operands of binary and ternary expressions. Specifically, this aligns operands of a single expression that needs; to be split over multiple lines, e.g.:. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb +; ccccccccccccccc;. When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is; aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. * ``OAS_AlignAfterOperator`` (in configuration: ``AlignAfterOperator``); Horizontally align operands of binary and ternary expressions. This is similar to ``AO_Align``, except when; ``BreakBeforeBinaryOperators`` is set, the operator is un-indented so; that the wrapped operand is aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. .. _AlignTrailingComments:. **AlignTrailingComments** (``TrailingCommentsAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlignTrailingComments>`; Control of trailing comments. The alignment stops at closing braces after a line break, and only; followed by other closing braces, a (``do-``) ``while``, a lambda call, or; a semicolon. .. note::. As of clang-format 16 this option is not a bool but can be set; to the options. Conventional bool options still can be parsed as before. .. code-block:: yaml. # Example of usage:; AlignTrailingComments:; Kind: Always; OverEmptyLines: 2. Nested configuration flags:. Alignment options. * ``TrailingCommentsAlignmentKinds Kind``; Specifies the way to align trailing comments. Possible values:. * ``TCAS_Leave`` (in configuration: ``Leave``); Leave trailing comments as they are. .. c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:22463,wrap,wrapped,22463,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrapped']
Integrability,"f all CPUs which are missing atomic; compare-and-swap support are uniprocessor (no SMP). This is almost always the; case. The only common architecture without that property is SPARC -- SPARCV8 SMP; systems were common, yet it doesn't support any sort of compare-and-swap; operation. Some targets (like RISCV) support a ``+forced-atomics`` target feature, which; enables the use of lock-free atomics even if LLVM is not aware of any specific; OS support for them. In this case, the user is responsible for ensuring that; necessary ``__sync_*`` implementations are available. Code using; ``+forced-atomics`` is ABI-incompatible with code not using the feature, if; atomic variables cross the ABI boundary. In either of these cases, the Target in LLVM can claim support for atomics of an; appropriate size, and then implement some subset of the operations via libcalls; to a ``__sync_*`` function. Such functions *must* not use locks in their; implementation, because unlike the ``__atomic_*`` routines used by; AtomicExpandPass, these may be mixed-and-matched with native instructions by the; target lowering. Further, these routines do not need to be shared, as they are stateless. So,; there is no issue with having multiple copies included in one binary. Thus,; typically these routines are implemented by the statically-linked compiler; runtime support library. LLVM will emit a call to an appropriate ``__sync_*`` routine if the target; ISelLowering code has set the corresponding ``ATOMIC_CMPXCHG``, ``ATOMIC_SWAP``,; or ``ATOMIC_LOAD_*`` operation to ""Expand"", and if it has opted-into the; availability of those library functions via a call to ``initSyncLibcalls()``. The full set of functions that may be called by LLVM is (for ``N`` being 1, 2,; 4, 8, or 16)::. iN __sync_val_compare_and_swap_N(iN *ptr, iN expected, iN desired); iN __sync_lock_test_and_set_N(iN *ptr, iN val); iN __sync_fetch_and_add_N(iN *ptr, iN val); iN __sync_fetch_and_sub_N(iN *ptr, iN val); iN __sync_fetch_and_and_N(i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:28457,rout,routines,28457,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['rout'],['routines']
Integrability,"f bytes it read. This; implies that some bytes within the value may be ``undef`` **without**; the entire value being ``undef``. Note that this only defines the; semantics of the operation; it doesn't mean that targets will emit more; than one instruction to read the series of bytes. Note that in cases where none of the atomic intrinsics are used, this; model places only one restriction on IR transformations on top of what; is required for single-threaded execution: introducing a store to a byte; which might not otherwise be stored is not allowed in general.; (Specifically, in the case where another thread might write to and read; from an address, introducing a store can change a load that may see; exactly one write into a load that may see multiple writes.). .. _ordering:. Atomic Memory Ordering Constraints; ----------------------------------. Atomic instructions (:ref:`cmpxchg <i_cmpxchg>`,; :ref:`atomicrmw <i_atomicrmw>`, :ref:`fence <i_fence>`,; :ref:`atomic load <i_load>`, and :ref:`atomic store <i_store>`) take; ordering parameters that determine which other atomic instructions on; the same address they *synchronize with*. These semantics implement; the Java or C++ memory models; if these descriptions aren't precise; enough, check those specs (see spec references in the; :doc:`atomics guide <Atomics>`). :ref:`fence <i_fence>` instructions; treat these orderings somewhat differently since they don't take an; address. See that instruction's documentation for details. For a simpler introduction to the ordering constraints, see the; :doc:`Atomics`. ``unordered``; The set of values that can be read is governed by the happens-before; partial order. A value cannot be read unless some operation wrote; it. This is intended to provide a guarantee strong enough to model; Java's non-volatile shared variables. This ordering cannot be; specified for read-modify-write operations; it is not strong enough; to make them atomic in any interesting way.; ``monotonic``; In addition ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:152551,synchroniz,synchronize,152551,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['synchroniz'],['synchronize']
Integrability,"f bytes needed to hold all bits of the type. For; example, storing an ``i24`` writes at most three bytes. When writing a; value of a type like ``i20`` with a size that is not an integral number; of bytes, it is unspecified what happens to the extra bits that do not; belong to the type, but they will typically be overwritten.; If ``<value>`` is of aggregate type, padding is filled with; :ref:`undef <undefvalues>`.; If ``<pointer>`` is not a well-defined value, the behavior is undefined. Example:; """""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; store i32 3, ptr %ptr ; yields void; %val = load i32, ptr %ptr ; yields i32:val = i32 3. .. _i_fence:. '``fence``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. fence [syncscope(""<target-scope>"")] <ordering> ; yields void. Overview:; """""""""""""""""". The '``fence``' instruction is used to introduce happens-before edges; between operations. Arguments:; """""""""""""""""""". '``fence``' instructions take an :ref:`ordering <ordering>` argument which; defines what *synchronizes-with* edges they add. They can only be given; ``acquire``, ``release``, ``acq_rel``, and ``seq_cst`` orderings. Semantics:; """""""""""""""""""". A fence A which has (at least) ``release`` ordering semantics; *synchronizes with* a fence B with (at least) ``acquire`` ordering; semantics if and only if there exist atomic operations X and Y, both; operating on some atomic object M, such that A is sequenced before X, X; modifies M (either directly or through some side effect of a sequence; headed by X), Y is sequenced before B, and Y observes M. This provides a; *happens-before* dependency between A and B. Rather than an explicit; ``fence``, one (but not both) of the atomic operations X or Y might; provide a ``release`` or ``acquire`` (resp.) ordering constraint and; still *synchronize-with* the explicit ``fence`` and establish the; *happens-before* edge. A ``fence`` which has ``seq_cst`` ordering, in addition to having both; ``acquire`` and ``release`` seman",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:423788,synchroniz,synchronizes-with,423788,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['synchroniz'],['synchronizes-with']
Integrability,"f datasets that; will speedup certain data intensive operations. RooStats; New Tutorials. Several new tutorials were added for RooStats. rs101_limitexample.C Demonstrates use of Frequentist,; Bayesian, and Likelihood intervals for a simple number counting experiment; with uncertainty on signal and background rates.; rs301_splot.C Demonstrates use of RooStats sPlot; implementation; rs401c_FeldmanCousins.C Demonstrates use of; FeldmanCousins interval calculator with a Poisson problem, reproduces; results from table IV and V of the original; paper�Phys.Rev.D57:3873-3889,1998.; rs401d_FeldmanCousins.C Demonstrates use of; FeldmanCousins interval calculator with the neutrino oscillation toy; example described in the original paper�Phys.Rev.D57:3873-3889,1998.; Reproduces figure 12.; rs_bernsteinCorrection.C Demonstrates use of; BernsteinCorrection class, which corrects a nominal PDF with a polynomial; to agree with observed or simulated data. TestStatistic interface and implementations; We added a new interface class called TestStatistic. It defines the; method Evaluate(data, parameterPoint), which returns a double. �This; class can be used in�conjunction�with the ToyMCSampler class to generate; sampling distributions for a user-defined test statistic. �; The following concrete implementations of the TestStatistic interface; are currently available. ProfileLikelihoodTestStatReturns the log of profile; likelihood ratio. �Generally a powerful test statistic. ; NumEventsTestStatReturns the number of events in the; dataset. �Useful for number counting experiments.; DebuggingTestStat Simply returns a uniform random number; between 0,1. �Useful for debugging. SamplingDistribution and the�TestStatSampler interface and; implementations; We introduced a ``result'' or data model class called; SamplingDistribution, which holds the sampling distribution of an; arbitrary real valued test statistic. �The class also can return the; inverse of the cumulative distribution function (with ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:25811,interface,interface,25811,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['interface'],['interface']
Integrability,"f dependencies. A; translation unit will then include the precompiled header that starts the chain; (i.e., nothing depends on it). This linearity of dependencies is important for; the semantic model of chained precompiled headers, because the most-recent; precompiled header can provide information that overrides the information; provided by the precompiled headers it depends on, just like a header file; ``B.h`` that includes another header ``A.h`` can modify the state produced by; parsing ``A.h``, e.g., by ``#undef``'ing a macro defined in ``A.h``. There are several ways in which chained precompiled headers generalize the AST; file model:. Numbering of IDs; Many different kinds of entities --- identifiers, declarations, types, etc.; --- have ID numbers that start at 1 or some other predefined constant and; grow upward. Each precompiled header records the maximum ID number it has; assigned in each category. Then, when a new precompiled header is generated; that depends on (chains to) another precompiled header, it will start; counting at the next available ID number. This way, one can determine, given; an ID number, which AST file actually contains the entity. Name lookup; When writing a chained precompiled header, Clang attempts to write only; information that has changed from the precompiled header on which it is; based. This changes the lookup algorithm for the various tables, such as the; :ref:`identifier table <pchinternals-ident-table>`: the search starts at the; most-recent precompiled header. If no entry is found, lookup then proceeds; to the identifier table in the precompiled header it depends on, and so one.; Once a lookup succeeds, that result is considered definitive, overriding any; results from earlier precompiled headers. Update records; There are various ways in which a later precompiled header can modify the; entities described in an earlier precompiled header. For example, later; precompiled headers can add entries into the various name-lookup table",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:25789,depend,depends,25789,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['depend'],['depends']
Integrability,"f it appeared at the location of the; declaration whose type is being modified. Macros are not available and; nullability must be applied explicitly (even in an ``NS_ASSUME_NONNULL_BEGIN``; section). ::. - Selector: ""subviews""; MethodKind: Instance; ResultType: ""NSArray * _Nonnull"". :SwiftImportAsAccessors:. Used for properties. If true, the property will be exposed in Swift as its; accessor methods, rather than as a computed property using ``var``. ::. - Name: currentContext; PropertyKind: Class; SwiftImportAsAccessors: true. :NSErrorDomain:. Used for ``NSError`` code enums. The value is the name of the associated; domain ``NSString`` constant; an empty string (``""""``) means the enum is a; normal enum rather than an error code. ::. - Name: MKErrorCode; NSErrorDomain: MKErrorDomain. :SwiftWrapper:. Controls ``NS_STRING_ENUM`` and ``NS_EXTENSIBLE_STRING_ENUM``. There are three; options:. - ""struct"" (extensible); - ""enum""; - ""none"". Note that even an ""enum"" wrapper is still presented as a struct in Swift;; it's just a ""more enum-like"" struct. ::. - Name: AVMediaType; SwiftWrapper: none. :EnumKind:. Has the same effect as ``NS_ENUM`` and ``NS_OPTIONS``. There are four options:. - ""NSEnum"" / ""CFEnum""; - ""NSClosedEnum"" / ""CFClosedEnum""; - ""NSOptions"" / ""CFOptions""; - ""none"". ::. - Name: GKPhotoSize; EnumKind: none. :Parameters:. Used for methods and functions. Parameters are identified by a 0-based; 'Position' and support the 'Nullability', 'NoEscape', and 'Type' keys. .. note::. Using 'Parameters' within a parameter entry to describe the parameters of a; block is not implemented. Use 'Type' on the entire parameter instead. ::. - Selector: ""isEqual:""; MethodKind: Instance; Parameters:; - Position: 0; Nullability: O. :NoEscape:. Used only for block parameters. Equivalent to ``NS_NOESCAPE``. ::. - Name: dispatch_sync; Parameters:; - Position: 0; NoEscape: true. :SwiftBridge:. Used for Objective-C class types bridged to Swift value types. An empty; string ("""") means a type ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/APINotes.rst:8202,wrap,wrapper,8202,interpreter/llvm-project/clang/docs/APINotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/APINotes.rst,1,['wrap'],['wrapper']
Integrability,"f it is not 'real'. II. Usage of clang driver:. * Basic Command-Line Options:; - Help: clang --help; - Standard GCC options accepted: -E, -I*, -i*, -pedantic, -std=c90, etc.; - To make diagnostics more gcc-like: -fno-caret-diagnostics -fno-show-column; - Enable metric printing: -stats. * -fsyntax-only is currently the default mode. * -E mode works the same way as GCC. * -Eonly mode does all preprocessing, but does not print the output,; useful for timing the preprocessor.; ; * -fsyntax-only is currently partially implemented, lacking some; semantic analysis (some errors and warnings are not produced). * -parse-noop parses code without building an AST. This is useful; for timing the cost of the parser without including AST building; time.; ; * -parse-ast builds ASTs, but doesn't print them. This is most; useful for timing AST building vs -parse-noop.; ; * -parse-ast-print pretty prints most expression and statements nodes. * -parse-ast-check checks that diagnostic messages that are expected; are reported and that those which are reported are expected. * -dump-cfg builds ASTs and then CFGs. CFGs are then pretty-printed. * -view-cfg builds ASTs and then CFGs. CFGs are then visualized by; invoking Graphviz. For more information on getting Graphviz to work with clang/LLVM,; see: https://llvm.org/docs/ProgrammersManual.html#ViewGraph. III. Current advantages over GCC:. * Column numbers are fully tracked (no 256 col limit, no GCC-style pruning).; * All diagnostics have column numbers, includes 'caret diagnostics', and they; highlight regions of interesting code (e.g. the LHS and RHS of a binop).; * Full diagnostic customization by client (can format diagnostics however they; like, e.g. in an IDE or refactoring tool) through DiagnosticClient interface.; * Built as a framework, can be reused by multiple tools.; * All languages supported linked into same library (no cc1,cc1obj, ...).; * mmap's code in read-only, does not dirty the pages like GCC (mem footprint).; * LLVM Licens",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt:5216,message,messages,5216,interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,1,['message'],['messages']
Integrability,"f modules is transparent, other than the requirement that they; need to be co-located with the compiled dictionary shared library. Optionally, the dictionary generation process also produces a mapping file,; which lists the libraries needed to load C++ classes on request (for details,; see the section on the class loader below). Structurally, you could have a single dictionary for a project as a whole,; but more likely a large project will have a pre-existing functional; decomposition that can be followed, with a dictionary per functional unit. Generation; ^^^^^^^^^^. There are two interfaces onto the same underlying dictionary generator:; ``rootcling`` and ``genreflex``.; The reason for having two is historic and they are not complete duplicates,; so one or the other may suit your preference better.; It is foreseen that both will be replaced once C++ modules become more; mainstream, as that will allow simplification and improved robustness. rootcling; """""""""""""""""". The first interface is called ``rootcling``::. $ rootcling; Usage: rootcling [-v][-v0-4] [-f] [out.cxx] [opts] file1.h[+][-][!] file2.h[+][-][!] ...[Linkdef.h]; For more extensive help type: /usr/local/lib/python2.7/dist-packages/cppyy_backend/bin/rootcling -h. Rather than providing command line options, the main steering of; ``rootcling`` behavior is done through; `#pragmas in a Linkdef.h <https://root.cern.ch/root/html/guides/users-guide/AddingaClass.html#the-linkdef.h-file>`_; file, with most pragmas dedicated to selecting/excluding (parts of) classes; and functions.; Additionally, the Linkdef.h file may contain preprocessor macros. The output consists of a dictionary file (to be compiled into a shared; library), a C++ module, and an optional mapping file, as described above. genreflex; """""""""""""""""". The second interface is called ``genreflex``::. $ genreflex; Generates dictionary sources and related ROOT pcm starting from an header.; Usage: genreflex headerfile.h [opts] [preproc. opts]; ... ``genreflex`` ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:3832,interface,interface,3832,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,1,['interface'],['interface']
Integrability,f non-type typename-specifier; Unknown. 1975; CD4; Permissible declarations for exception-specifications; Unknown. 1976; NAD; Ambiguity of namespace-aliases; Unknown. 1977; drafting; Contradictory results of failed destructor lookup; Not resolved. 1978; CD4; Redundant description of explicit constructor use; Unknown. 1979; drafting; Alias template specialization in template member definition; Not resolved. 1980; drafting; Equivalent but not functionally-equivalent redeclarations; Not resolved. 1981; CD4; Implicit contextual conversions and explicit; Unknown. 1982; NAD; Deduction extending parameter pack; Unknown. 1983; CD5; Inappropriate use of virt-specifier; Unknown. 1984; NAD; Lossless narrowing conversions; Unknown. 1985; NAD; Unknown bound array member with brace-or-equal-initializer; Unknown. 1986; drafting; odr-use and delayed initialization; Not resolved. 1987; NAD; constexpr static data members across translation units; Unknown. 1988; CD4; Ambiguity between dependent and non-dependent bases in implicit member access; Unknown. 1989; drafting; Insufficient restrictions on parameters of postfix operators; Not resolved. 1990; CD4; Ambiguity due to optional decl-specifier-seq; Unknown. 1991; CD4; Inheriting constructors vs default arguments; Clang 3.9. 1992; CD4; new (std::nothrow) int[N] can throw; Unknown. 1993; drafting; Use of template<> defining member of explicit specialization; Not resolved. 1994; dup; Confusing wording regarding multiple template<> prefixes; Duplicate of 529. 1995; CD4; exception-specifications and non-type template parameters; Unknown. 1996; drafting; Reference list-initialization ignores conversion functions; Not resolved. 1997; drafting; Placement new and previous initialization; Not resolved. 1998; NAD; Additional sources of xvalue expressions; Unknown. 1999; CD4; Representation of source characters as universal-character-names; Unknown. 2000; CD4; header-name outside #include directive; Unknown. 2001; CD4; non-directive is underspeci,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:135051,depend,dependent,135051,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['depend'],['dependent']
Integrability,"f revolution about Z axis (inner and outer surfaces). The; class describing hyperboloids is **`TGeoHype`** has 5 input parameters:. ``` {.cpp}; TGeoHype(Double_t rin,Double_t stin,Double_t rout,; Double_t stout,Double_t dz);; ```. ![TGeoHype Class](pictures/080001C1.png). The hyperbolic surface equation is taken in the form:. ``` {.cpp}; r2 - z2tan2() = r2min; ```. - `r,z:` cylindrical coordinates for a point on the surface; - `:` stereo angle between the hyperbola asymptotic lines and Z axis; - `r2min:` minimum distance between hyperbola and Z axis (at `z=0`). The input parameters represent:. - `rin, stin:` minimum radius and tangent of stereo angle for inner; surface; - `rout, stout:` minimum radius and tangent of stereo angle for outer; surface; - `dz:` half length in Z (bounding planes positions at `+/-dz`). The following conditions are mandatory in order to avoid intersections; between the inner and outer hyperbolic surfaces in the range `+/-dz`:. - `rin<rout`; - `rout>0`; - `rin2 + dz2*stin2 > rout2 + dz2*stout2`. Particular cases:. - `rin=0, stin0:` the inner surface is conical; - `stin=0 / stout=0:` cylindrical surface(s). #### Cones - TGeoCone Class. The cones are defined by 5 parameters:. ``` {.cpp}; TGeoCone(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2);; ```. - `rmin1:` internal radius at Z is `-dz`; - `rmax1:` external radius at Z is `-dz`; - `rmin2:` internal radius at Z is `+dz`; - `rmax2:` external radius at Z is `+dz`; - `dz:` half length in Z (a cone ranges from `-dz` to +`dz`). A cone has Z-axis as its symmetry axis. ![TGeoCone Class](pictures/060001C2.png). #### Cone Segments - TGeoConeSeg Class. A cone segment is a cone having a range in `phi.` The cone segment class; derives from **`TGeoCone`**, having two extra parameters: `phi1` and; `phi2`. ``` {.cpp}; TGeoConeSeg(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2,Double_t phi1,Double_t phi2);; ```. Parameters` phi1` and `phi2` have the same",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:34784,rout,rout,34784,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,2,['rout'],['rout']
Integrability,"f simulateneous p.d.f.s; rf16_normandint.C - Normalization, integration and cumulative distribution functions (1d); rf16_normandint2d.C - Normalization, integration and cumulative distribution functions (1d); ; Update of class documentation; ; The documentation in the code itself that is extracted by THtml to construct; the online class documentation has been updated for all classes. Now all classes; have (again) a short class description, as well as a (short) description of each member function; and most data members. An update to the users manual is foreseen shortly after the 5.20; release. RooWorkspace. A new feature has been added that allows to persist source code of RooFit classes that; are not in ROOT distribution inside a RooWorkspace to facilitate sharing; of custom code with others. To import code of custom classes call. RooWorkspace::importClassCode(). after importing the objects themselves into the workspace. For all classes; that are compiled with ACliC RooWorkspace can automatically find the source; code using the ROOT TClass interface. For custom classes that are compiled; externally and loaded into ROOT as shared library it might be necessary to; provide the location of the source files manually using the static RooWorkspace; member functions addClassDeclImportDir() and addClassImplImportDir().; ; When a TFile with a RooWorkspace containing source code is opened in a ROOT; session that does not have the class code already loaded for the classes; contained in the workspace, the code in the workspace is written to file,; compiled and loaded into the ROOT session on the fly. The code repository of RooWorkspace is designed to handle classes that; have either their own implementation and header file, or are part of a group; of classes that share a common header and implementation file. More complicated; structuring of source code into files is not supported. ; ; Also new accessors have been added for discrete-valued functions catfunc(); and stored categor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:2149,interface,interface,2149,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['interface'],['interface']
Integrability,"f the base expression is more; complex, then the cost can rise quickly. I've seen loops where the end; expression was actually something like: ""``SomeMap[X]->end()``"" and map lookups; really aren't cheap. By writing it in the second form consistently, you; eliminate the issue entirely and don't even have to think about it. The second (even bigger) issue is that writing the loop in the first form hints; to the reader that the loop is mutating the container (a fact that a comment; would handily confirm!). If you write the loop in the second form, it is; immediately obvious without even looking at the body of the loop that the; container isn't being modified, which makes it easier to read the code and; understand what it does. While the second form of the loop is a few extra keystrokes, we do strongly; prefer it. ``#include <iostream>`` is Forbidden; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The use of ``#include <iostream>`` in library files is hereby **forbidden**,; because many common implementations transparently inject a `static constructor`_; into every translation unit that includes it. Note that using the other stream headers (``<sstream>`` for example) is not; problematic in this regard --- just ``<iostream>``. However, ``raw_ostream``; provides various APIs that are better performing for almost every use than; ``std::ostream`` style APIs. .. note::. New code should always use `raw_ostream`_ for writing, or the; ``llvm::MemoryBuffer`` API for reading files. .. _raw_ostream:. Use ``raw_ostream``; ^^^^^^^^^^^^^^^^^^^. LLVM includes a lightweight, simple, and efficient stream implementation in; ``llvm/Support/raw_ostream.h``, which provides all of the common features of; ``std::ostream``. All new code should use ``raw_ostream`` instead of; ``ostream``. Unlike ``std::ostream``, ``raw_ostream`` is not a template and can be forward; declared as ``class raw_ostream``. Public headers should generally not include; the ``raw_ostream`` header, but use forward declarations an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:55163,inject,inject,55163,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['inject'],['inject']
Integrability,"f the normal distribution](pictures/03000128.png). ## Numerical Algorithms. ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:. * Evaluation of function derivatives.; * Evaluation of integrals.; * Finding the roots of a function; * Finding the minimum/maximum of a function. In order to use these algorithm the user needs to provide a function.; ROOT provides a common way of specifying them via some interfaces. ## ROOT::Math Function interfaces. To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function.; In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ![ROOT::Math Function interface structure](pictures/function-hierarchy.png). ### One-dimensional Function Interfaces. These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions.; For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. * `ROOT::Math::IBaseFunctionOneDim`: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing; `double operator() (const double )`. The user class defined only needs to reimplement the pure abstract method `double DoEval(double x)`,; that will do the work of evaluating the function at point x. Example on how to create a class that represents a mathematical function. The user only has to override two methods from `IBaseFunctionOneDim`:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionOneDim; {; double DoEval(double x) const; {; return x*x;; }. ROOT::Math::IBaseFunctionOneDim* Clone() const; {; return new MyFunction();; }; };; ```. * `ROOT::Math::IGradien",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:35203,interface,interfaces,35203,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interfaces']
Integrability,"f the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be regularly updated. ## Accessing file system. THttpServer provides partial access to the files from file system.; First of all, JSROOT scripts and files can be accessed via ""jsrootsys/"" path like ""http://localhost:8080/jsrootsys/modules/core.mjs"".; Files from ROOT install directory can be get via ""rootsys/"" path like ""http://localhost:8080/rootsys/icons/about.xpm"".; Also files from current directory where ROOT is running can be accessed via ""currentdir/"" path like ""http://localhost:8080/currentdir/file.txt"". If necessary, one can add custom path as well, using [THttpServer::AddLocation](https://root.cern/doc/master/classTHttpServer.html#a5322c3bbfddb8eb6849297d83ccaf87f) method:. ```cpp; serv->AddLocation(""mydir/"", ""/home/user/specials"");; ```. Then files from that directory could be addressed via URL like ""http://localhost:8080/mydir/myfile.root"". ## Command interface. THttpServer class provide simple interface to invoke command from web browser.; One just register command like:. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"");; ```. Element with name `DoSomething` will appear in the web browser and can be clicked.; It will result in `gROOT->ProcessLineSync(""SomeFunction()"")` call. One could configure argument(s) for the command.; For that one should use `%arg1`, `%arg2` and so on identifiers. Like:. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction(%arg1%,%arg2%)"");; ```. User will be requested to enter arguments values, when command element clicked in the browser.; Example of the command which executes arbitrary string in application via ProcessLine looks like:. ```cpp; serv->RegisterCommand(""/Process"", ""%arg1%"");; ```. When registering command, one could specify icon name which will be displayed with the command. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:4897,interface,interface,4897,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['interface'],['interface']
Integrability,"f they did not. The ``doInitialization(Region *, RGPassManager &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(Region *, RGPassManager &RGM);. The ``doInitialization`` method is designed to do simple initialization type of; stuff that does not depend on the functions being processed. The; ``doInitialization`` method call is not scheduled to overlap with any other; pass executions (thus it should be very fast). ``RPPassManager`` interface; should be used to access ``Function`` or ``Module`` level analysis information. .. _writing-an-llvm-pass-runOnRegion:. The ``runOnRegion`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnRegion(Region *, RGPassManager &RGM) = 0;. The ``runOnRegion`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a true value should be; returned if the region is modified. ``RGPassManager`` interface should be used to; update region tree. The ``doFinalization()`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization();. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnRegion; <writing-an-llvm-pass-runOnRegion>` for every region in the program being; compiled. The ``MachineFunctionPass`` class; ---------------------------------. A ``MachineFunctionPass`` is a part of the LLVM code generator that executes on; the machine-dependent representation of each LLVM function in the program. Code generator passes are registered and initialized specially by; ``TargetMachine::addPassesToEmitFile`` and similar routines, so they cannot; generally be run from the :program:`opt` or :program:`bugpoint` commands. A ``MachineFunctionPass`` is also a ``FunctionPass``, so all the restrictions; that apply to a ``FunctionPass`` also apply to it. ``MachineFunctionPass``\ es; also have addition",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:24266,interface,interface,24266,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['interface'],['interface']
Integrability,"f when to use LibClang:. * Xcode; * Clang Python Bindings. Use LibClang when you...:. * want to interface with clang from other languages than C++; * need a stable interface that takes care to be backwards compatible; * want powerful high-level abstractions, like iterating through an AST with a; cursor, and don't want to learn all the nitty gritty details of Clang's AST. Do not use LibClang when you...:. * want full control over the Clang AST. Clang Plugins; -------------. :doc:`Clang Plugins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactoring tools. Use LibTooling when you...:. * want to run tools over a single file, or a specific subset of files,; independently of the build system; * want full control over the Clang AST; * want to share code with Clang Plugins. Do not use LibTooling when you...:. * want to run as part of the build triggered by dependency changes; * want a stable",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:1647,depend,dependencies,1647,interpreter/llvm-project/clang/docs/Tooling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst,1,['depend'],['dependencies']
Integrability,"f which do not have any Python equivalent; (e.g. ``unsigned short*``).; Furthermore, such codes tend to be ambiguous: the information from header; file is not sufficient to determine the full purpose.; For example, an ``int*`` type may refer to the address of a single ``int``; (an out-parameter, say) or it may refer to an array of ``int``, the ownership; of which is not clear either.; cppyy provides a few low-level helpers and integration with the Python; `ctypes module`_ to cover these cases. Use of these low-level helpers will obviously lead to very ""C-like"" code and; it is recommended to :doc:`pythonize <pythonizations>` the code, perhaps; using the Cling JIT and embedded C++. Note: the low-level module is not loaded by default (since its use is, or; should be, uncommon).; It needs to be imported explicitly:. .. code-block:: python. >>> import cppyy.ll; >>>. `LowLevelView`; --------------. Python has an elaborate array interface (buffer) specification, but no; standard library array type that completely implements it; instead, the; canonical Python array type is the NumPy one.; cppyy introduces the basic ``LowLevelView`` array class to avoid having a; direct dependency on NumPy and to guarantee zero copy.; The ``LowLevelView`` type gives access to array details such as the size,; type, etc. and allows reading/writing of array elements, both for interactive; use and through the buffer interface to allow NumPy to interface with them.; For more complex operations, it's recommended to copy from the; ``LowLevelView`` inta a NumPy array, or to create a NumPy view (see below,; under :ref:`NumPy Casts <npcasts>`). `C/C++ casts`; -------------. C++ instances are auto-casted to the most derived available type, so do not; require explicit casts even when a function returns a pointer to a base; class or interface.; However, when given only a ``void*`` or ``intptr_t`` type on return, a cast; is required to turn it into something usable. * **bind_object**: This is the preferred",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:1102,interface,interface,1102,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['interface'],['interface']
Integrability,"f()"". You can also use the CRTP; base ManglingParser to perform some simple analysis on the mangled; name, or (in LLVM) use the opaque ItaniumPartialDemangler to query the; demangled AST. Why are there multiple copies of the this library in the source tree?; ---------------------------------------------------------------------. The canonical sources are in libcxxabi/src/demangle and some of the; files are copied to llvm/include/llvm/Demangle. The simple reason for; this comes from before the monorepo, and both [sub]projects need to; demangle symbols, but neither can depend on each other. * libcxxabi needs the demangler to implement __cxa_demangle, which is; part of the itanium ABI spec. * LLVM needs a copy for a bunch of places, and cannot rely on the; system's __cxa_demangle because it a) might not be available (i.e.,; on Windows), and b) may not be up-to-date on the latest language; features. The copy of the demangler in LLVM has some extra stuff that aren't; needed in libcxxabi (ie, the MSVC demangler, ItaniumPartialDemangler),; which depend on the shared generic components. Despite these; differences, we want to keep the ""core"" generic demangling library; identical between both copies to simplify development and testing. If you're working on the generic library, then do the work first in; libcxxabi, then run libcxxabi/src/demangle/cp-to-llvm.sh. This; script takes as an optional argument the path to llvm, and copies the; changes you made to libcxxabi over. Note that this script just; blindly overwrites all changes to the generic library in llvm, so be; careful. Because the core demangler needs to work in libcxxabi, everything; needs to be declared in an anonymous namespace (see; DEMANGLE_NAMESPACE_BEGIN), and you can't introduce any code that; depends on the libcxx dylib. FIXME: Now that LLVM is a monorepo, it should be possible to; de-duplicate this code, and have both LLVM and libcxxabi depend on a; shared demangler library. Testing; -------. The tests are spli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt:1314,depend,depend,1314,interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/README.txt,1,['depend'],['depend']
Integrability,"f-enter`. ### Install the experiment's configuration files system-wide. A system administrator might find convenient to install the experiment; environment scripts system-wide. Configuration scripts for LHC experiments are shipped with the VAF; client and can be found in; `/dest/dir/client/config-samples/<experiment_name>`. To make them used; by default by the VAF client, place them in the `/dest/dir/etc`; directory like this:. ``` {.bash}; rsync -a /dest/dir/client/config-samples/<experiment_name>/ /dest/dir/etc/; ```. Remember that the trailing slash in the source directory name has a; meaning in `rsync` and must not be omitted. > Remember that system-wide configuration files will always have; > precedence over user's configuration files, so *don't place there; > files that are supposed to be provided by the user!*. Entering the Virtual Analysis Facility environment; --------------------------------------------------. The Virtual Analysis Facility client is a wrapper around commands sent; to the remote host by means of PROOF on Demand's `pod-remote`. The VAF; client takes care of setting up passwordless SSH from your client node; to the VAF master. ### Getting the credentials. > You can skip this paragraph if the remote server wasn't configured for; > HTTPS+SSH authentication. In our example we will assume that the remote server's name is; `cloud-gw-213.to.infn.it`: substitute it with your remote endpoint. First, check that you have your Grid certificate and private key; installed both in your browser and in the home directory of your; client. Point your browser to `https://cloud-gw-213.to.infn.it/auth/`: you'll; probably be asked for a certificate to choose for authentication. Pick; one and you'll be presented with the following web page:. ![Web authentication with sshcertauth](img/sshcertauth-web.png). The webpage clearly explains you what to do next. ### Customizing user's configuration. Before entering the VAF environment, you should customize the user's; confi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:8250,wrap,wrapper,8250,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['wrap'],['wrapper']
Integrability,"f:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles extremely large sets without loss of efficiency. .. _dss_smallptrset:. llvm/ADT/SmallPtrSet.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :ref:`std::set <dss_set>`, the iterators of ``SmallPtrSet``; are invalidated whenever an insertion occurs. Also, the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSet.h; ^^^^^^^^^^^^^^^^^^^^. ``StringSet`` is a thin wrapper around :ref:`StringMap\<char\> <dss_stringmap>`,; and it allows efficient storage and retrieval of unique strings. Functionally analogous to ``SmallSet<StringRef>``, ``StringSet`` also supports; iteration. (The iterator dereferences to a ``StringMapEntry<char>``, so you; need to call ``i->getKey()`` to access the item of the StringSet.) On the; other hand, ``StringSet`` doesn't support range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^^^^^^^^^^^. DenseSet is a simple quadratically probed hash table. It excels at supporting; small values: it uses a single allocation to hold all of the pairs that are; currently inserted in the set. DenseSet is a great way to unique small values; that are not simple pointers (use :ref:`SmallPtrSet <dss_smallptrset>` for; pointers). Note that DenseSet has the same requirements for the value type that; :ref:`DenseMap <dss_densemap>` has. .. _dss_sparseset:. llvm/ADT/Spa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:79435,wrap,wrapper,79435,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['wrap'],['wrapper']
Integrability,"fButton->SetStyle(""modern"");. TRootBrowser. Use the ProcessedConfigure signal to be notified when an embedded frame change its layout, to properly call Layout() on its parent frame, to automatically display the change (for example, showing the EventStatusBar of a TCanvas embedded in a TBrowser was only appearing after manually resizing the window). TGFileBrowser. Fixed memory leak when browsing TList inside a file: don't read the list content each time one click on the list; A protection for empty directories (e.g. not containing any key) as been added. Solves the bug #94028, TBrowser crash trying to browse sub-root-directories in memory. TGFSComboBox. Fix a problem when the current directory is similar to $ROOTSYS, for example with $ROOTSYS being /home/user/root and $PWD being /home/user/rootdev, only ""dev"" was displayed, stripping off $ROOTSYS; Properly handle backslashes as directory separators on Windows. TGFileDialog. Change the file name only if the selected entry is not a directory (as reported on the forum). TGMsgBox. Implemented ""Enter"" and ""Escape"" key handling in TGMsgBox (used as Ok and Cancel buttons, if they are there). TGTextEntry. Several issues with text selection and combination of cursor position and text alignment in text entries have been solved. TRootCanvas. A check has been added for the case where the canvas is embedded (e.g. in the browser), then the layout of the main frame has to be re-applied when showing/hiding the editor; Stay in the current (working) directory when using ""File -> Save as..."" from a canvas or from a text editor (as the file dialog changes the current directory). TFitParametersDialog. Implemented keyboard navigation (tab and shift+tab) between the different number entry fields of the dialog. TFitEditor. Layout improvements and removed useless text in message box. TTreeViewer. Fixed a problem with array names (e.g. fVertex[]) as reported on the forum). TGWin32. Fixed several resource leaks (including GDI & USER objects). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v534/index.html:2153,message,message,2153,gui/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v534/index.html,1,['message'],['message']
Integrability,"fallback-style FALLBACK_STYLE] [-binary BINARY]. This script reads input from a unified diff and reformats all the changed; lines. This is useful to reformat all the lines touched by a specific patch.; Example usage for git/svn users:. git diff -U0 --no-color --relative HEAD^ | clang-format-diff.py -p1 -i; svn diff --diff-cmd=diff -x-U0 | clang-format-diff.py -i. It should be noted that the filename contained in the diff is used unmodified; to determine the source file to update. Users calling this script directly; should be careful to ensure that the path in the diff is correct relative to the; current working directory. optional arguments:; -h, --help show this help message and exit; -i apply edits to files instead of displaying a diff; -p NUM strip the smallest prefix containing P slashes; -regex PATTERN custom pattern selecting file paths to reformat (case sensitive, overrides -iregex); -iregex PATTERN custom pattern selecting file paths to reformat (case insensitive, overridden by -regex); -sort-includes let clang-format sort include blocks; -v, --verbose be more verbose, ineffective without -i; -style STYLE formatting style to apply (LLVM, GNU, Google, Chromium, Microsoft, Mozilla, WebKit); -fallback-style FALLBACK_STYLE; The name of the predefined style used as a fallback in case clang-format is invoked with-style=file, but can not; find the .clang-formatfile to use.; -binary BINARY location of binary to use for clang-format. To reformat all the lines in the latest Mercurial/:program:`hg` commit, do:. .. code-block:: console. hg diff -U0 --color=never | clang-format-diff.py -i -p1. The option `-U0` will create a diff without context lines (the script would format; those as well). These commands use the file paths shown in the diff output; so they will only work from the root of the repository. Current State of Clang Format for LLVM; ======================================. The following table :doc:`ClangFormattedStatus` shows the current status of clang-formatt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:13116,message,message,13116,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['message'],['message']
Integrability,"fast-math options. The; pragma can take two values: ``on`` and ``off``. .. code-block:: c++. float f(float x, float y); {; // Enable floating point reciprocal approximation; #pragma clang fp reciprocal(on); return x / y;; }. ``#pragma clang fp contract`` specifies whether the compiler should; contract a multiply and an addition (or subtraction) into a fused FMA; operation when supported by the target. The pragma can take three values: ``on``, ``fast`` and ``off``. The ``on``; option is identical to using ``#pragma STDC FP_CONTRACT(ON)`` and it allows; fusion as specified the language standard. The ``fast`` option allows fusion; in cases when the language standard does not make this possible (e.g. across; statements in C). .. code-block:: c++. for(...) {; #pragma clang fp contract(fast); a = b[i] * c[i];; d[i] += a;; }. The pragma can also be used with ``off`` which turns FP contraction off for a; section of the code. This can be useful when fast contraction is otherwise; enabled for the translation unit with the ``-ffp-contract=fast-honor-pragmas`` flag.; Note that ``-ffp-contract=fast`` will override pragmas to fuse multiply and; addition across statements regardless of any controlling pragmas. ``#pragma clang fp exceptions`` specifies floating point exception behavior. It; may take one of the values: ``ignore``, ``maytrap`` or ``strict``. Meaning of; these values is same as for `constrained floating point intrinsics <http://llvm.org/docs/LangRef.html#constrained-floating-point-intrinsics>`_. .. code-block:: c++. {; // Preserve floating point exceptions; #pragma clang fp exceptions(strict); z = x + y;; if (fetestexcept(FE_OVERFLOW)); ...; }. A ``#pragma clang fp`` pragma may contain any number of options:. .. code-block:: c++. void func(float *dest, float a, float b) {; #pragma clang fp exceptions(maytrap) contract(fast) reassociate(on); ...; }. ``#pragma clang fp eval_method`` allows floating-point behavior to be specified; for a section of the source code. This p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:172032,contract,contraction,172032,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,2,['contract'],"['contract', 'contraction']"
Integrability,"fault --gcc-install-dir= or --gcc-triple=. --gcc-toolchain= is discouraged. ""; ""See https://github.com/llvm/llvm-project/pull/77537 for detail.""); endif(). set(ENABLE_LINKER_BUILD_ID OFF CACHE BOOL ""pass --build-id to ld""). set(ENABLE_X86_RELAX_RELOCATIONS ON CACHE BOOL; ""enable x86 relax relocations by default""). set(PPC_LINUX_DEFAULT_IEEELONGDOUBLE OFF CACHE BOOL; ""Enable IEEE binary128 as default long double format on PowerPC Linux.""). set(CLANG_SPAWN_CC1 OFF CACHE BOOL; ""Whether clang should use a new process for the CC1 invocation""). option(CLANG_DEFAULT_PIE_ON_LINUX ""Default to -fPIE and -pie on linux-gnu"" ON). set(CLANG_DEFAULT_LINKER """" CACHE STRING; ""Default linker to use (linker name or absolute path, empty for platform default)""). set(CLANG_DEFAULT_CXX_STDLIB """" CACHE STRING; ""Default C++ stdlib to use (\""libstdc++\"" or \""libc++\"", empty for platform default""); if (NOT(CLANG_DEFAULT_CXX_STDLIB STREQUAL """" OR; CLANG_DEFAULT_CXX_STDLIB STREQUAL ""libstdc++"" OR; CLANG_DEFAULT_CXX_STDLIB STREQUAL ""libc++"")); message(WARNING ""Resetting default C++ stdlib to use platform default""); set(CLANG_DEFAULT_CXX_STDLIB """" CACHE STRING; ""Default C++ stdlib to use (\""libstdc++\"" or \""libc++\"", empty for platform default"" FORCE); endif(). set(CLANG_DEFAULT_RTLIB """" CACHE STRING; ""Default runtime library to use (\""libgcc\"" or \""compiler-rt\"", empty for platform default)""); if (NOT(CLANG_DEFAULT_RTLIB STREQUAL """" OR; CLANG_DEFAULT_RTLIB STREQUAL ""libgcc"" OR; CLANG_DEFAULT_RTLIB STREQUAL ""compiler-rt"")); message(WARNING ""Resetting default rtlib to use platform default""); set(CLANG_DEFAULT_RTLIB """" CACHE STRING; ""Default runtime library to use (\""libgcc\"" or \""compiler-rt\"", empty for platform default)"" FORCE); endif(). set(CLANG_DEFAULT_UNWINDLIB """" CACHE STRING; ""Default unwind library to use (\""none\"" \""libgcc\"" or \""libunwind\"", empty to match runtime library.)""); if (CLANG_DEFAULT_UNWINDLIB STREQUAL """"); if (CLANG_DEFAULT_RTLIB STREQUAL ""libgcc""); set (CLANG_DEFAULT_UNWINDL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:8074,message,message,8074,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['message'],['message']
Integrability,"fault, assumes at; least 1cy between the dispatch event and the issue event. When the performance is limited by data dependencies and/or long latency; instructions, the number of cycles spent while in the *ready* state is expected; to be very small when compared with the total number of cycles spent in the; scheduler's queue. The difference between the two counters is a good indicator; of how large of an impact data dependencies had on the execution of the; instructions. When performance is mostly limited by the lack of hardware; resources, the delta between the two counters is small. However, the number of; cycles spent in the queue tends to be larger (i.e., more than 1-3cy),; especially when compared to other low latency instructions. Bottleneck Analysis; ^^^^^^^^^^^^^^^^^^^; The ``-bottleneck-analysis`` command line option enables the analysis of; performance bottlenecks. This analysis is potentially expensive. It attempts to correlate increases in; backend pressure (caused by pipeline resource pressure and data dependencies) to; dynamic dispatch stalls. Below is an example of ``-bottleneck-analysis`` output generated by; :program:`llvm-mca` for 500 iterations of the dot-product example on btver2. .. code-block:: none. Cycles with backend pressure increase [ 48.07% ]; Throughput Bottlenecks:; Resource Pressure [ 47.77% ]; - JFPA [ 47.77% ]; - JFPU0 [ 47.77% ]; Data Dependencies: [ 0.30% ]; - Register Dependencies [ 0.30% ]; - Memory Dependencies [ 0.00% ]. Critical sequence based on the simulation:. Instruction Dependency Information; +----< 2. vhaddps %xmm3, %xmm3, %xmm4; |; | < loop carried >; |; | 0. vmulps %xmm0, %xmm1, %xmm2; +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 74% ]; +----> 2. vhaddps %xmm3, %xmm3, %xmm4 ## REGISTER dependency: %xmm3; |; | < loop carried >; |; +----> 1. vhaddps %xmm2, %xmm2, %xmm3 ## RESOURCE interference: JFPA [ probability: 74% ]. According to the analysis, throughput is limited by resource ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:26774,depend,dependencies,26774,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['dependencies']
Integrability,"ferent SIMDs. The exception is when in tgsplit execution mode; when the wavefronts may be executed by different SIMDs in different CUs.; * Each CU has a single LDS memory shared by the wavefronts of the work-groups; executing on it. The exception is when in tgsplit execution mode when no LDS; is allocated as wavefronts of the same work-group can be in different CUs.; * All LDS operations of a CU are performed as wavefront wide operations in a; global order and involve no caching. Completion is reported to a wavefront in; execution order.; * The LDS memory has multiple request queues shared by the SIMDs of a; CU. Therefore, the LDS operations performed by different wavefronts of a; work-group can be reordered relative to each other, which can result in; reordering the visibility of vector memory operations with respect to LDS; operations of other wavefronts in the same work-group. A ``s_waitcnt; lgkmcnt(0)`` is required to ensure synchronization between LDS operations and; vector memory operations between wavefronts of a work-group, but not between; operations performed by the same wavefront.; * The vector memory operations are performed as wavefront wide operations and; completion is reported to a wavefront in execution order. The exception is; that ``flat_load/store/atomic`` instructions can report out of vector memory; order if they access LDS memory, and out of LDS operation order if they access; global memory.; * The vector memory operations access a single vector L1 cache shared by all; SIMDs a CU. Therefore:. * No special action is required for coherence between the lanes of a single; wavefront. * No special action is required for coherence between wavefronts in the same; work-group since they execute on the same CU. The exception is when in; tgsplit execution mode as wavefronts of the same work-group can be in; different CUs and so a ``buffer_inv sc0`` is required which will invalidate; the L1 cache. * A ``buffer_inv sc0`` is required to invalidate the L1 cac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:285499,synchroniz,synchronization,285499,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronization']
Integrability,"ferent SIMDs. The exception is when in tgsplit execution mode; when the wavefronts may be executed by different SIMDs in different CUs.; * Each CU has a single LDS memory shared by the wavefronts of the work-groups; executing on it. The exception is when in tgsplit execution mode when no LDS; is allocated as wavefronts of the same work-group can be in different CUs.; * All LDS operations of a CU are performed as wavefront wide operations in a; global order and involve no caching. Completion is reported to a wavefront in; execution order.; * The LDS memory has multiple request queues shared by the SIMDs of a; CU. Therefore, the LDS operations performed by different wavefronts of a; work-group can be reordered relative to each other, which can result in; reordering the visibility of vector memory operations with respect to LDS; operations of other wavefronts in the same work-group. A ``s_waitcnt; lgkmcnt(0)`` is required to ensure synchronization between LDS operations and; vector memory operations between wavefronts of a work-group, but not between; operations performed by the same wavefront.; * The vector memory operations are performed as wavefront wide operations and; completion is reported to a wavefront in execution order. The exception is; that ``flat_load/store/atomic`` instructions can report out of vector memory; order if they access LDS memory, and out of LDS operation order if they access; global memory.; * The vector memory operations access a single vector L1 cache shared by all; SIMDs a CU. Therefore:. * No special action is required for coherence between the lanes of a single; wavefront. * No special action is required for coherence between wavefronts in the same; work-group since they execute on the same CU. The exception is when in; tgsplit execution mode as wavefronts of the same work-group can be in; different CUs and so a ``buffer_wbinvl1_vol`` is required as described in; the following item. * A ``buffer_wbinvl1_vol`` is required for coherence be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:235351,synchroniz,synchronization,235351,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronization']
Integrability,"ferent methods, using in some case the derivatives. #### `ROOT::Math::BrentMinimizer1D`. This class implements the Brent method to minimize one-dimensional function.; An interval containing the function minimum must be provided.; Here is an example where we define the function to minimize as a *lambda* function; (requires C++11). The function to minimize must be given to the class implementing the algorithm as a; `ROOT::Math::IBaseFunctionOneDim` object. ```{.cpp}; ROOT::Math::Functor1D func( [](double x){ return 1 + -4*x + 1*x*x; } );. ROOT::Math::BrentMinimizer1D bm;; bm.SetFunction(func, -10,10);; bm.Minimize(10,0,0);; cout << ""Minimum: f("" << bm.XMinimum() << "") = "" <<bm.FValMinimum() << endl;; ```. Note that when setting the function to minimize, one needs to provide the interval range to find the minimum.; In the `Minimize` call, the maximum number of function calls, the relative and absolute tolerance must be provided. #### `ROOT::Math::GSLMInimizer1D`. This class wraps two different methods from the GSL.; The algorithms which can be chosen at construction time are *GOLDENSECTION*, which is the simplest method; but the slowest and *BRENT* (the default one) which combines the golden section with a parabolic interpolation.; The algorithm can be chosen as a different enumeration in the constructor:; * `ROOT::Math::Minim1D::kBRENT` for the Brent algorithm (default); * `ROOT::Math::Minim1D::kGOLDENSECTION` for the golden section algorithm. ```{.cpp}; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; ```. The interface to set the function and to minimize is the same as in the case of the `BrentMinimizer1D`. #### Using the TF1 class. It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, `TF1` of the *Hist* library.; The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:64978,wrap,wraps,64978,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['wrap'],['wraps']
Integrability,"fers to standard C++ modules; feature if it is not decorated by ``Clang``. Clang Modules; ~~~~~~~~~~~~~. In this document, the term ``Clang Modules``/``Clang modules`` refer to Clang; c++ modules extension. These are also known as ``Clang header modules``,; ``Clang module map modules`` or ``Clang c++ modules``. Module and module unit; ~~~~~~~~~~~~~~~~~~~~~~. A module consists of one or more module units. A module unit is a special; translation unit. Every module unit must have a module declaration. The syntax; of the module declaration is:. .. code-block:: c++. [export] module module_name[:partition_name];. Terms enclosed in ``[]`` are optional. The syntax of ``module_name`` and ``partition_name``; in regex form corresponds to ``[a-zA-Z_][a-zA-Z_0-9\.]*``. In particular, a literal dot ``.``; in the name has no semantic meaning (e.g. implying a hierarchy). In this document, module units are classified into:. * Primary module interface unit. * Module implementation unit. * Module interface partition unit. * Internal module partition unit. A primary module interface unit is a module unit whose module declaration is; ``export module module_name;``. The ``module_name`` here denotes the name of the; module. A module should have one and only one primary module interface unit. A module implementation unit is a module unit whose module declaration is; ``module module_name;``. A module could have multiple module implementation; units with the same declaration. A module interface partition unit is a module unit whose module declaration is; ``export module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. An internal module partition unit is a module unit whose module declaration; is ``module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. In this document, we use the following umbrella terms:. * A ``module interface unit`` refers to either a ``primary module interface unit``; or a ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:2652,interface,interface,2652,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interface']
Integrability,"fferent ways; <DiagnosticConsumer>` depending on how the ``DiagnosticConsumer`` interface is; implemented. A representative example of a diagnostic is:. .. code-block:: text. t.c:38:15: error: invalid operands to binary expression ('int *' and '_Complex float'); P = (P-42) + Gamma*4;; ~~~~~~ ^ ~~~~~~~. In this example, you can see the English translation, the severity (error), you; can see the source location (the caret (""``^``"") and file/line/column info),; the source ranges ""``~~~~``"", arguments to the diagnostic (""``int*``"" and; ""``_Complex float``""). You'll have to believe me that there is a unique ID; backing the diagnostic :). Getting all of this to happen has several steps and involves many moving; pieces, this section describes them and talks about best practices when adding; a new diagnostic. The ``Diagnostic*Kinds.td`` files; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Diagnostics are created by adding an entry to one of the; ``clang/Basic/Diagnostic*Kinds.td`` files, depending on what library will be; using it. From this file, :program:`tblgen` generates the unique ID of the; diagnostic, the severity of the diagnostic and the English translation + format; string. There is little sanity with the naming of the unique ID's right now. Some; start with ``err_``, ``warn_``, ``ext_`` to encode the severity into the name.; Since the enum is referenced in the C++ code that produces the diagnostic, it; is somewhat useful for it to be reasonably short. The severity of the diagnostic comes from the set {``NOTE``, ``REMARK``,; ``WARNING``,; ``EXTENSION``, ``EXTWARN``, ``ERROR``}. The ``ERROR`` severity is used for; diagnostics indicating the program is never acceptable under any circumstances.; When an error is emitted, the AST for the input code may not be fully built.; The ``EXTENSION`` and ``EXTWARN`` severities are used for extensions to the; language that Clang accepts. This means that Clang fully understands and can; represent them in the AST, but we produce diagnostics ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:3499,depend,depending,3499,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['depending']
Integrability,"fffull);; case 4:; return (x << 32) | ((y >> 24) & 0xffffffffull);; default:; return (x << 40) | ((y >> 16) & 0xffffffffffull);; }; }. //===---------------------------------------------------------------------===//. This (and similar related idioms):. unsigned int foo(unsigned char i) {; return i | (i<<8) | (i<<16) | (i<<24);; } . compiles into:. define i32 @foo(i8 zeroext %i) nounwind readnone ssp noredzone {; entry:; %conv = zext i8 %i to i32; %shl = shl i32 %conv, 8; %shl5 = shl i32 %conv, 16; %shl9 = shl i32 %conv, 24; %or = or i32 %shl9, %conv; %or6 = or i32 %or, %shl5; %or10 = or i32 %or6, %shl; ret i32 %or10; }. it would be better as:. unsigned int bar(unsigned char i) {; unsigned int j=i | (i << 8); ; return j | (j<<16);; }. aka:. define i32 @bar(i8 zeroext %i) nounwind readnone ssp noredzone {; entry:; %conv = zext i8 %i to i32; %shl = shl i32 %conv, 8; %or = or i32 %shl, %conv; %shl5 = shl i32 %or, 16; %or6 = or i32 %shl5, %or; ret i32 %or6; }. or even i*0x01010101, depending on the speed of the multiplier. The best way to; handle this is to canonicalize it to a multiply in IR and have codegen handle; lowering multiplies to shifts on cpus where shifts are faster. //===---------------------------------------------------------------------===//. We do a number of simplifications in simplify libcalls to strength reduce; standard library functions, but we don't currently merge them together. For; example, it is useful to merge memcpy(a,b,strlen(b)) -> strcpy. This can only; be done safely if ""b"" isn't modified between the strlen and memcpy of course. //===---------------------------------------------------------------------===//. We compile this program: (from GCC PR11680); http://gcc.gnu.org/bugzilla/attachment.cgi?id=4487. Into code that runs the same speed in fast/slow modes, but both modes run 2x; slower than when compile with GCC (either 4.0 or 4.2):. $ llvm-g++ perf.cpp -O3 -fno-exceptions; $ time ./a.out fast; 1.821u 0.003s 0:01.82 100.0%	0+0k 0+0io 0pf+",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:18161,depend,depending,18161,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['depend'],['depending']
Integrability,"fficient to determine the full purpose.; For example, an ``int*`` type may refer to the address of a single ``int``; (an out-parameter, say) or it may refer to an array of ``int``, the ownership; of which is not clear either.; cppyy provides a few low-level helpers and integration with the Python; `ctypes module`_ to cover these cases. Use of these low-level helpers will obviously lead to very ""C-like"" code and; it is recommended to :doc:`pythonize <pythonizations>` the code, perhaps; using the Cling JIT and embedded C++. Note: the low-level module is not loaded by default (since its use is, or; should be, uncommon).; It needs to be imported explicitly:. .. code-block:: python. >>> import cppyy.ll; >>>. `LowLevelView`; --------------. Python has an elaborate array interface (buffer) specification, but no; standard library array type that completely implements it; instead, the; canonical Python array type is the NumPy one.; cppyy introduces the basic ``LowLevelView`` array class to avoid having a; direct dependency on NumPy and to guarantee zero copy.; The ``LowLevelView`` type gives access to array details such as the size,; type, etc. and allows reading/writing of array elements, both for interactive; use and through the buffer interface to allow NumPy to interface with them.; For more complex operations, it's recommended to copy from the; ``LowLevelView`` inta a NumPy array, or to create a NumPy view (see below,; under :ref:`NumPy Casts <npcasts>`). `C/C++ casts`; -------------. C++ instances are auto-casted to the most derived available type, so do not; require explicit casts even when a function returns a pointer to a base; class or interface.; However, when given only a ``void*`` or ``intptr_t`` type on return, a cast; is required to turn it into something usable. * **bind_object**: This is the preferred method to proxy a C++ address,; and lives in ``cppyy``, not ``cppyy.ll``, as it is not a low-level C++; cast, but a ``cppyy`` API that is also used internally.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst:1346,depend,dependency,1346,bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/lowlevel.rst,1,['depend'],['dependency']
Integrability,"ficate and private key; installed both in your browser and in the home directory of your; client. Point your browser to `https://cloud-gw-213.to.infn.it/auth/`: you'll; probably be asked for a certificate to choose for authentication. Pick; one and you'll be presented with the following web page:. ![Web authentication with sshcertauth](img/sshcertauth-web.png). The webpage clearly explains you what to do next. ### Customizing user's configuration. Before entering the VAF environment, you should customize the user's; configuration. How to do so depends on your experiment, but usually you; should essentially specify the version of the experiment's software you; need. For instance, in the CMS use case, only one file is needed:; `~/.vaf/common.before`, which contains something like:. ``` {.bash}; # Version of CMSSW (as reported by ""scram list""); export VafCmsswVersion='CMSSW_5_3_9_sherpa2beta2'; ```. ### Entering the VAF environment. Open a terminal on your client machine (can be either your local; computer or a remote user interface) and type:. vaf-enter <username>@cloud-gw-213.to.infn.it. You'll substitute `<username>` with the username that either your system; administrator or the web authentication (if you used it) provided you. You'll be presented with a neat shell which looks like the following:. Entering VAF environment: dberzano@cloud-gw-213.to.infn.it; Remember: you are still in a shell on your local computer!; pod://dberzano@cloud-gw-213.to.infn.it [~] >. This shell runs on your local computer and it has the environment; properly set up. PoD and PROOF workflow; ----------------------. > The following operations are valid inside the `vaf-enter` environment. ### Start your PoD server. With PROOF on Demand, each user has the control of its own personal; PROOF cluster. The first thing to do is to start the PoD server and the; PROOF master like this:. vafctl --start. A successful output will be similar to:. ** Starting remote PoD server on dberzano@cloud-gw-213.to.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:9784,interface,interface,9784,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['interface'],['interface']
Integrability,"fication defines; the concept of ``TU-local`` and ``exposure`` in; `basic.link/p14 <https://eel.is/c++draft/basic.link#14>`_,; `basic.link/p15 <https://eel.is/c++draft/basic.link#15>`_,; `basic.link/p16 <https://eel.is/c++draft/basic.link#16>`_,; `basic.link/p17 <https://eel.is/c++draft/basic.link#17>`_ and; `basic.link/p18 <https://eel.is/c++draft/basic.link#18>`_. However, the compiler doesn't support these 2 ideas formally.; This results in unclear and confusing diagnostic messages.; And it is worse that the compiler may import TU-local entities to other units without any; diagnostics. This is tracked in https://github.com/llvm/llvm-project/issues/78173. Header Units; ============. How to build projects using header unit; ---------------------------------------. .. warning::. The user interfaces of header units is highly experimental. There are still; many unanswered question about how tools should interact with header units.; The user interfaces described here may change after we have progress on how; tools should support for header units. Quick Start; ~~~~~~~~~~~. For the following example,. .. code-block:: c++. import <iostream>;; int main() {; std::cout << ""Hello World.\n"";; }. we could compile it as. .. code-block:: console. $ clang++ -std=c++20 -xc++-system-header --precompile iostream -o iostream.pcm; $ clang++ -std=c++20 -fmodule-file=iostream.pcm main.cpp. How to produce BMIs; ~~~~~~~~~~~~~~~~~~~. Similar to named modules, we could use ``--precompile`` to produce the BMI.; But we need to specify that the input file is a header by ``-xc++-system-header`` or ``-xc++-user-header``. Also we could use `-fmodule-header={user,system}` option to produce the BMI for header units; which has suffix like `.h` or `.hh`.; The value of `-fmodule-header` means the user search path or the system search path.; The default value for `-fmodule-header` is `user`.; For example,. .. code-block:: c++. // foo.h; #include <iostream>; void Hello() {; std::cout << ""Hello World.\n"";;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:27305,interface,interfaces,27305,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interfaces']
Integrability,"fication of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of `TGeo` to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with %ROOT. The interface methods related to tracking are incorporated into; TGeoManager class and implemented in the navigator class; TGeoNavigator. In order to be able to start tracking, one has to; define the initial state providing the starting point \f$\vec{r_0}\f$; and direction \f$\vec{n_0}\f$ .; There are several ways of doing that. \anchor GP02a; ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ~~~{.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ~~~. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ~~~{.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ~~~. A navigator ho",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:62540,interface,interface,62540,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['interface'],['interface']
Integrability,"fication-based vs. subset-based, etc. Traditionally,; alias analyses respond to a query with a `Must, May, or No`_ alias response,; indicating that two pointers always point to the same object, might point to the; same object, or are known to never point to the same object. The LLVM `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__ class is the; primary interface used by clients and implementations of alias analyses in the; LLVM system. This class is the common interface between clients of alias; analysis information and the implementations providing it, and is designed to; support a wide range of implementations and clients (but currently all clients; are assumed to be flow-insensitive). In addition to simple alias analysis; information, this class exposes Mod/Ref information from those implementations; which can provide it, allowing for powerful analyses and transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. The; ``AliasAnalysis`` interface also exposes some helper methods which allow you to; get mod/ref information for arbitrary instructions. All ``AliasAnalysis`` interfa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:1568,interface,interface,1568,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['interface'],['interface']
Integrability,"fig/AsmPrinters.def.in; ${LLVM_INCLUDE_DIR}/llvm/Config/AsmPrinters.def; ); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/AsmParsers.def.in; ${LLVM_INCLUDE_DIR}/llvm/Config/AsmParsers.def; ); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/Disassemblers.def.in; ${LLVM_INCLUDE_DIR}/llvm/Config/Disassemblers.def; ); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/Targets.def.in; ${LLVM_INCLUDE_DIR}/llvm/Config/Targets.def; ); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/TargetMCAs.def.in; ${LLVM_INCLUDE_DIR}/llvm/Config/TargetMCAs.def; ); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/TargetExegesis.def.in; ${LLVM_INCLUDE_DIR}/llvm/Config/TargetExegesis.def; ). # They are not referenced. See set_output_directory().; set( CMAKE_RUNTIME_OUTPUT_DIRECTORY ${LLVM_TOOLS_BINARY_DIR} ); set( CMAKE_LIBRARY_OUTPUT_DIRECTORY ${LLVM_LIBRARY_DIR} ); set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${LLVM_LIBRARY_DIR} ). # For up-to-date instructions for installing the TFLite dependency, refer to; # the bot setup script: https://github.com/google/ml-compiler-opt/blob/main/buildbot/buildbot_init.sh; set(LLVM_HAVE_TFLITE """" CACHE BOOL ""Use tflite""); if (LLVM_HAVE_TFLITE); find_package(tensorflow-lite REQUIRED); endif(). # For up-to-date instructions for installing the Tensorflow dependency, refer to; # the bot setup script: https://github.com/google/ml-compiler-opt/blob/main/buildbot/buildbot_init.sh; # Specifically, assuming python3 is installed:; # python3 -m pip install --upgrade pip && python3 -m pip install --user tf_nightly==2.3.0.dev20200528; # Then set TENSORFLOW_AOT_PATH to the package install - usually it's ~/.local/lib/python3.7/site-packages/tensorflow; #; set(TENSORFLOW_AOT_PATH """" CACHE PATH ""Path to TensorFlow pip install dir""). if (NOT TENSORFLOW_AOT_PATH STREQUAL """"); set(LLVM_HAVE_TF_AOT ""ON"" CACHE BOOL ""Tensorflow AOT available""); set(TENSORFLOW_AOT_COMPILER; ""${TENSORFLOW_AOT_PATH}/../../../../bin/saved_model_cli""; CACHE PATH ""Path to the Te",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:42670,depend,dependency,42670,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['depend'],['dependency']
Integrability,"file for the **master** and the **slave**. Since; most of the configuration variables are the same (like the *HTCondor; shared secret*) you can create one, clone it and change only what's; needed to change. Deploy it on the cloud; ----------------------. Provided you have access to a certain cloud API, you'll need to; instantiate a certain number of CernVM batch images with proper; contextualization: one for the master, as many as you want as slaves. CernVM supports contextualization through the ""user data"" field; supported by all cloud infrastructures. Each cloud infrastructure has a different method of setting the ""user; data"". The following description will focus on:. - [OpenNebula](http://opennebula.org/). - OpenStack (such as the [CERN Agile; infrastructure](https://openstack.cern.ch/)). - [Amazon EC2](http://aws.amazon.com/ec2/)-compatible interfaces via; the open [Eucalyptus](http://www.eucalyptus.com/); [Euca2ools](http://www.eucalyptus.com/eucalyptus-cloud/tools): many popular; clouds support such interface and tools. ### Download the CernVM Online contextualizations. Go to the CernVM Online Dashboard page where you have previously; customized the contexts for your master and your slaves. Click on the rightmost button on the line of the desired context and; select **Get rendered context** from the dropdown: save the output to a; text file (such as `my_vaf_context.txt`, the name we will use in the; examples that follow). This file will be subsequently passed as the so; called ""user-data"" file to the cloud API. > Repeat the operation for both the master context and the slave; > context. ### OpenStack API: nova. Example of a CernVM instantiation using `nova`:. ``` {.bash}; nova boot \; --flavor m1.xlarge \; --image cernvm-batch-node-2.6.0-4-1-x86_64 \; --key-name my_default_keyparir \; --user-data my_vaf_context.txt \; Name-Of-My-New-VM; ```. The `--user-data` option requires the context file we've just; downloaded. ### EC2 API: euca-tools. Example of a CernVM ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md:4347,interface,interface,4347,proof/doc/confman/DeployVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md,1,['interface'],['interface']
Integrability,"file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves up the; inheritance tree until it reaches an ancestor without a parent. To; serialize the object data members it calls their `Streamer`. They in; turn move up their own inheritance tree and so forth. The simple data; members are written to the buffer directly. Eventually the buffer; contains all simple data members of all the classes that make up this; particular object. Data members that are references (as; `MyClass &fObj;`) are never saved, it is always the responsibility of; the object's constructor to set them properly. ### Automatically Generated Streamers. A `Streamer `usually calls other `Streamers`: the `Streamer `of its; parents and data members. This architecture depends on all classes; having `Streamers`, because eventually they will be called. To ensure; that a class has a `Streamer`, `rootcling` automatically creates one in; the `ClassDef` macro that is defined in `$ROOTSYS/include/Rtypes.h`.; `ClassDef` defines several methods for any class, and one of them is the; `Streamer`. The automatically generated `Streamer `is complete and can; be used as long as no customization is needed. The `Event` class is defined in `$ROOTSYS/test/Event.h`. Looking at the; class definition, we find that it inherits from **`TObject`**. It is a; simple example of a class with diverse data members. ``` {.cpp}; class Event : public TObject {; private:; TDirectory *fTransient; //! current directory; Float_t fPt; //! transient value; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr; //|| don't split; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvert",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:43674,depend,depends,43674,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['depend'],['depends']
Integrability,"fill, marker or text; attributes. The following object editors are available for the current; ROOT version. ### TAxisEditor. ![](pictures/030000D5.png). This user interface gives the possibility for changing the following; axis attributes:. - color of the selected axis, the axis' title and labels;. - the length of thick parameters and the possibility to set them on; both axis sides (if `+-` is selected);. - to set logarithmic or linear scale along the selected axis with a; choice for optimized or more logarithmic labels;. - primary, secondary and tertiary axis divisions can be set via the; three number fields;. - the axis title can be added or edited and the title's color,; position, offset, size and font can be set interactively;. - the color, size, and offset of axis labels can be set similarly. In; addition, there is a check box for no exponent choice, and another; one for setting the same decimal part for all labels. ### TPadEditor. ![](pictures/030000D6.png). - It provides the following user interface:. - Fixed aspect ratio - can be set for pad resizing. - Edit - sets pad or canvas as editable. - Cross-hair - sets a cross hair on the pad. - TickX - set ticks along the X axis. - TickY - set ticks along the Y axis. - GridX - set a grid along the X axis. - GridY - set a grid along the Y axis. - The pad or canvas border size can be set if a sunken or a raised; border mode is. - selected; no border mode can be set too. ## Copy and Paste. You can make a copy of a canvas using `TCanvas::DrawClonePad`. This; method is unique to **`TCanvas`**. It clones the entire canvas to the; active pad. There is a more general method `TObject::DrawClone`, which; all objects descendent of **`TObject`**, specifically all graphic; objects inherit. Below are two examples, one to show the use of; `DrawClonePad` and the other to show the use of `DrawClone`. ### Using the GUI. In this example we will copy an entire canvas to a new one with; `DrawClonePad`. Run the script `draw2dopt.C`. ``` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:85260,interface,interface,85260,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['interface'],['interface']
Integrability,"final stage, ROOT might be able to integrate the Name.pcm with the; shared library itself.; * Improved correctness in number of cases -- in a few cases ROOT is more; correct. In particular, when resolving global variables and function; declarations which are not part of the ROOT PCH.; * Enhanced symbol resolution mechanisms, bloom filters -- standard ROOT relies; on information in ROOTMAP files to react when the llvm JIT issues an; unresolved symbol callback. C++ Modules-aware ROOT relies on a behavior much; closer to the standard linker behavior. In particular, we start searching on; the LD_LIBRARY_PATH descending to the system libraries. The algorithm is very; efficient because it uses bloom filters[[5]]. This in turn allows ROOT symbol; to be extended to system libraries. ### Module Registration Approaches. The C++ modules system supports /*preloading*/ of all modules at startup time.; The current implementation of loading of C++ modules in clang has an overhead; and is between 40-60 MB depending on the ROOT configuration while there might; be 2x slowdown depending on the workflow. These issues are very likely to be; addressed by the LLVM community in midterm. Preloading of all C++ modules is semantically the closest to C++ behavior.; However, in order to achieve performance ROOT loads them on demand using; a global module index file. It has sufficient information to map a looked up; identifier to the module which contains the corresponding definition. Switching; back to preloading of all C++ modules is done by setting the `ROOT_USE_GMI`; environment variable to false.; ; ### Supported Platforms. We support all platforms with glibc++ versions: 5.2 onward. We support OSX from XCode 10 onward. ## Changes required by the users; * Self-contained header files -- every header file should be able to compile; on its own. For instance, `cat header.h header.h | gcc -fsyntax-only -xc++ -`.; This command concatenates `header.h` twice before compiling it to make sure; it has p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:13918,depend,depending,13918,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,2,['depend'],['depending']
Integrability,"fine A \; int aaaa; \; int b; \; int dddddddddd;. false:. * ``ENAS_Right`` (in configuration: ``Right``); Align escaped newlines in the right-most column. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AlignOperands>`; If ``true``, horizontally align operands of binary and ternary; expressions. Possible values:. * ``OAS_DontAlign`` (in configuration: ``DontAlign``); Do not align operands of binary and ternary expressions.; The wrapped lines are indented ``ContinuationIndentWidth`` spaces from; the start of the line. * ``OAS_Align`` (in configuration: ``Align``); Horizontally align operands of binary and ternary expressions. Specifically, this aligns operands of a single expression that needs; to be split over multiple lines, e.g.:. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb +; ccccccccccccccc;. When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is; aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. * ``OAS_AlignAfterOperator`` (in configuration: ``AlignAfterOperator``); Horizontally align operands of binary and ternary expressions. This is similar to ``AO_Align``, except when; ``BreakBeforeBinaryOperators`` is set, the operator is un-indented so; that the wrapped operand is aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; + ccccccccccccccc;. .. _AlignTrailingComments:. **AlignTrailingComments** (``TrailingCommentsAlignmentStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlignTrailingComments>`; Control of trailing comments. The alignment stops at closing braces after a line break, and only; followed by other closing braces, a (``do-``) ``while``, a lambda call, or; a semicolon. .. note::. As of clang-format 16 this option is not a bool but can be set; to the options. Conventional bool options still can be parsed ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:22068,wrap,wrapped,22068,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrapped']
Integrability,"fio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; classes are available, and which libraries to load for them. When `TSystem::Load(""ALib"")` is called, ROOT uses this information to; determine which libraries `libALib.so` depends on. It will load these; libraries first. Otherwise, loading the requested library could cause; a system (dynamic loader) error due to unresolved symbols. ### \$ROOTSYS/tutorials. tutorials The tutorials directory contains many example example; scripts. They assume some basic knowledge of ROOT, and for the new; user we recommend reading the chapters: ""Histograms"" and; ""Input/Output"" before trying the examples. The more experienced user; can jump to chapter ""The Tutorials and Tests"" to find more explicit; and specific information about how to build and run the examples. The `$ROOTSYS/tutorials/` directory include the following; sub-directories:. `fft`: Fast Fourier Transform with the fftw package `fit`: Several; examples illustrating minimization/fitting `foam`: Random generator in; multidimensional space `geom`: Examples of use of the geometry package; (**`TGeo`** classes) `gl`: Visualisation with OpenGL `graphics`: Basic; graphics `graphs`: Use of **`TGraph`**, **`TGraphErrors`**, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:20343,depend,depends,20343,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['depend'],['depends']
Integrability,"fixes have been applied to different problems discovered mainly by a test program from Alfio Lazzaro. In detail:; . Fix a bug in MnMinos which was setting wrong initial values when the parameters were limited.; This was resulting in a much larger number of function calls used inside MnMinos. ; Improve MnHesse by returning in the final state the improved gradient step values used in HessianGradientCalculator. With this change same results are obtained from using Hesse in Minuit2 or TMinuit. In addition, the interface of MnHesse (MnHesse::operator() ) has been improved to use it from the FunctionMinimum object (similar to MnMinos) in order to be called after the minimization (Migrad). The API with a MnUserParameterState should not be used after minimization, because in that case the latest state information resulting from the minimum (gradient values and step sizes) is lost. Add support in MnMigrad and MnMinimize for user provided analytical gradient of the FCN function. One needs to pass an instance of a function implementing the ROOT::Minuit2::FcnGradientBase interface. Use now std::string for storing parameter names. This removes the un-necessary limitation on the length of parameter name (10 characters) existing before. The method Name() of MinuitParameter (and of MnUserParameterState and MnUserParameters) still returns a const char * (for backward compatibility). A new method, GetName() has been added to return a std::string. The Minuit2Minimizer class has been improved by having an option to always run Hesse if it was not done before during the minimization. Method to retrieve the correlation coefficients have been also added. More detailed description of the current Minuit2 release can be found at this location. Unuran. A new version, 1.2.4, has been added to fix mainly some problems found in gcc 4.3. For the detailed changes of this new UNU.RAN version see the file $ROOTSYS/math/unuran/src/unuran-1.2.4-root/NEWS. Last modified: Tue Jun 24 17:22:42 CEST 2008 . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:13880,interface,interface,13880,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['interface'],['interface']
Integrability,"fly describe the; modern dialect. Objective-C defines a new type kind, collectively called the :arc-term:`object; pointer types`. This kind has two notable builtin members, ``id`` and; ``Class``; ``id`` is the final supertype of all object pointers. The validity; of conversions between object pointer types is not checked at runtime. Users; may define :arc-term:`classes`; each class is a type, and the pointer to that; type is an object pointer type. A class may have a superclass; its pointer; type is a subtype of its superclass's pointer type. A class has a set of; :arc-term:`ivars`, fields which appear on all instances of that class. For; every class *T* there's an associated metaclass; it has no fields, its; superclass is the metaclass of *T*'s superclass, and its metaclass is a global; class. Every class has a global object whose class is the class's metaclass;; metaclasses have no associated type, so pointers to this object have type; ``Class``. A class declaration (``@interface``) declares a set of :arc-term:`methods`. A; method has a return type, a list of argument types, and a :arc-term:`selector`:; a name like ``foo:bar:baz:``, where the number of colons corresponds to the; number of formal arguments. A method may be an instance method, in which case; it can be invoked on objects of the class, or a class method, in which case it; can be invoked on objects of the metaclass. A method may be invoked by; providing an object (called the :arc-term:`receiver`) and a list of formal; arguments interspersed with the selector, like so:. .. code-block:: objc. [receiver foo: fooArg bar: barArg baz: bazArg]. This looks in the dynamic class of the receiver for a method with this name,; then in that class's superclass, etc., until it finds something it can execute.; The receiver ""expression"" may also be the name of a class, in which case the; actual receiver is the class object for that class, or (within method; definitions) it may be ``super``, in which case the lookup algo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:4412,interface,interface,4412,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['interface'],['interface']
Integrability,"folders can be added and removed to/from a folder. ## Why Use Folders?. One reason to use folders is to reduce class dependencies and improve; modularity. Each set of data has a producer class and one or many; consumer classes. When using folders, the producer class places a; pointer to the data into a folder, and the consumer class retrieves a; reference to the folder. The consumer can access the objects in a folder by specifying the path; name of the folder. Here is an example of a folder's path name:. `//root/Event/Hits/TCP`. One does not have to specify the full path name. If the partial path; name is unique, it will find it; otherwise it will return the first; occurrence of the path. The first diagram shows a system without folders. The objects have; pointers to each other to access each other's data. Pointers are an; efficient way to share data between classes. However, a direct pointer; creates a direct coupling between classes. This design can become a very; tangled web of dependencies in a system with a large number of classes. ![](pictures/020000E2.jpg). In the second diagram, a reference to the data is in the folder and the; consumers refer to the folder rather than each other to access the data.; The naming and search service provided by the ROOT folders hierarchy; provides an alternative. It loosely couples the classes and greatly; enhances I/O operations. In this way, folders separate the data from the; algorithms and greatly improve the modularity of an application by; minimizing the class dependencies. ![](pictures/020000E3.jpg). In addition, the folder hierarchy creates a picture of the data; organization. This is useful when discussing data design issues or when; learning the data organization. The example below illustrates this; point. ## How to Use Folders. Using folders means to build a hierarchy of folders, posting the; reference to the data in the folder by the producer, and creating a; reference to the folder by the user. ### Creating a Folder",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:1418,depend,dependencies,1418,documentation/users-guide/FoldersTasks.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md,1,['depend'],['dependencies']
Integrability,"following:. * An :ref:`integer_number<amdgpu_synid_integer_number>` or an :ref:`absolute_expression<amdgpu_synid_absolute_expression>`. The value must be in the range from 0 to 0xFFFF.; * A combination of *instid0*, *instskip*, *instid1* values which are described below. ======================== =========================== ===============; Syntax Description Default Value; ======================== =========================== ===============; instid0(<*ID name*>) A symbolic *ID0* value. instid0(NO_DEP); instskip(<*SKIP name*>) A symbolic *SKIP* value. instskip(SAME); instid1(<*ID name*>) A symbolic *ID1* value. instid1(NO_DEP); ======================== =========================== ===============. These values may be specified in any order.; When more than one value is specified, the values must be separated from each other by a '|'. Valid *ID names* are defined below. =================== ===================================================================; Name Description; =================== ===================================================================; NO_DEP No dependency on any prior instruction. This is the default value.; VALU_DEP_1 Dependency on a previous VALU instruction, 1 opcode back.; VALU_DEP_2 Dependency on a previous VALU instruction, 2 opcodes back.; VALU_DEP_3 Dependency on a previous VALU instruction, 3 opcodes back.; VALU_DEP_4 Dependency on a previous VALU instruction, 4 opcodes back.; TRANS32_DEP_1 Dependency on a previous TRANS32 instruction, 1 opcode back.; TRANS32_DEP_2 Dependency on a previous TRANS32 instruction, 2 opcodes back.; TRANS32_DEP_3 Dependency on a previous TRANS32 instruction, 3 opcodes back.; FMA_ACCUM_CYCLE_1 Single cycle penalty for FMA accumulation.; SALU_CYCLE_1 1 cycle penalty for a prior SALU instruction.; SALU_CYCLE_2 2 cycle penalty for a prior SALU instruction.; SALU_CYCLE_3 3 cycle penalty for a prior SALU instruction.; =================== ===================================================================. Legal ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_delay.rst:2062,depend,dependency,2062,interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_delay.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx11_delay.rst,1,['depend'],['dependency']
Integrability,"for (i = fFirstEntry; i < fLastEntry; i++) {; sprintf(tmp, ""Entry %i"", i+1);; fListBox->AddEntry(tmp, i);; }; fListBox->Resize(150, 80);; parent->AddFrame(fListBox,new TGLayoutHints(kLHintsTop|kLHintsLeft,; 5, 5, 5, 5));; ```. We create the list box widget passing the parent window pointer and; giving an ID number. Next we add entries with specified string and ID to; the list box. Before adding the list box to its parent widget, it should; be resized via `Resize(width, height)` method. The list box width and; height are in pixels. The default entry layout hints are; `kLHintsExpandX | kLHintsTop`. If you want to add entries using; different ones, call the method:. ``` {.cpp}; TGListBox::AddEntry(TGLBEntry *lbe, TGLayoutHints *lhints);; ```. It adds the specified **`TGLBEntry`** and **`TGLayoutHints`** to the; list box. There are several methods providing a flexible entry; manipulation: you can insert, add or remove list box items dynamically.; The list box entry IDs are used in these methods and also in event; processing routines. In our example the integer variables `fFirstEntry`; and `fLastEntry` contain the information about the first and last entry; IDs. You can add or remove a list box entry using them in the following; way:. ``` {.cpp}; // adding an entry; fLastEntry++;; sprintf(tmp, ""Entry %i"", fLastEntry);; fListBox->AddEntry(tmp, fLastEntry);; fListBox->MapSubwindows();; fListBox->Layout();; . . .; // removing an entry; if (fFirstEntry < fLastEntry) {; fListBox->RemoveEntry(fFirstEntry);; fListBox->Layout();; fFirstEntry++;; }; ```. A single-selection list box is used for selecting only one item in a; list. A multiple-selection list box permits selection of more than one item.; The selected choices should be visible - you have several choices to do; this:. - to mark selected choices with a check mark or highlight them. - to provide a summary list box to the right of the list box,; containing the selected choices. - to provide a display-only text control indi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:81304,rout,routines,81304,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['rout'],['routines']
Integrability,"for Computing Limits and Confidence Levels. **`TFeldmanCousins`** class calculates the `CL` upper/lower limit for a; Poisson process using the Feldman-Cousins method (as described in PRD; V57 \#7, p3873-3889). No treatment is provided in this method for the; uncertainties in the signal or the background. **`TRolke`** computes confidence intervals for the rate of a Poisson; process in the presence of background and efficiency, using the profile; likelihood technique for treating the uncertainties in the efficiency; and background estimate. The signal is always assumed to be Poisson;; background may be Poisson, Gaussian, or user-supplied; efficiency may be; Binomial, Gaussian, or user-supplied. See publication at Nucl. Instrum.; Meth. A551:493-503,2005. **`TLimit`** class computes 95% C.L. limits using the Likelihood ratio; semi-Bayesian method ( <CLs> method; see e.g. T. Junk, NIM A434, p.; 435-443, 1999). It takes signal background and data histograms wrapped; in a `TLimitDataSource` as input, and runs a set of Monte Carlo; experiments in order to compute the limits. If needed, inputs are; fluctuated according to systematic. ### Specialized Classes for Fitting. **`TFractionFitter`** fits Monte Carlo (MC) fractions to data histogram; (a la HMCMLL, R. Barlow and C. Beeston, Comp. Phys. Comm. 77 (1993); 219-228). It takes into account both data and Monte Carlo statistical; uncertainties through a likelihood fit using Poisson statistics.; However, the template (MC) predictions are also varied within; statistics, leading to additional contributions to the overall; likelihood. This leads to many more fit parameters (one per bin per; template), but the minimization with respect to these additional; parameters is done analytically rather than introducing them as formal; fit parameters. Some special care needs to be taken in the case of bins; with zero content. **`TMultiDimFit`** implements multi-dimensional function; parametrization for multi-dimensional data by fitting them",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:117797,wrap,wrapped,117797,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['wrap'],['wrapped']
Integrability,"for June 27, 2011. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities; Tutorials - ROOT's Tutorials. Binaries for all supported platforms are available at:. https://root.cern/releases/release-52800/. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Bertrand Bellenot, CERN/SFT,; Dario Berzano, INFN and University of Torino, ALICE, Proof,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU, RooStats,; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Alice,; Wim Lavrijsen, LBNL, PyRoot,; Sergei Linev, GSI,; Lorenzo Moneta, CERN/SFT,; Axel Naumann, CERN/SFT,; Eddy Offermann, Renaissance, ; Bartolomeu Rabacal, CERN/ADL, Math, ; Fons Rademakers, CERN/SFT,; Paul Russo, FNAL, ; Joerg Stelzer, DESY/Atlas, TMVA, ; Alja Tadel, UCSD/CMS, Eve, ; Matevz Tadel, UCSD/CMS, Eve, ; Eckhard von Toerne, University Bonn, ATLAS, TMVA, ; Wouter Verkerke, NIKHEF/Atlas,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v530/index.html:1295,protocol,protocols,1295,doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v530/index.html,3,"['interface', 'protocol']","['interfaces', 'protocols']"
Integrability,"for ``llvm-tblgen`` commands in the output. Instruction Relation Mapping; ----------------------------. This TableGen feature is used to relate instructions with each other. It is; particularly useful when you have multiple instruction formats and need to; switch between them after instruction selection. This entire feature is driven; by relation models which can be defined in ``XXXInstrInfo.td`` files; according to the target-specific instruction set. Relation models are defined; using ``InstrMapping`` class as a base. TableGen parses all the models; and generates instruction relation maps using the specified information.; Relation maps are emitted as tables in the ``XXXGenInstrInfo.inc`` file; along with the functions to query them. For the detailed information on how to; use this feature, please refer to :doc:`HowToUseInstrMappings`. Implement a subclass of ``TargetInstrInfo``; -------------------------------------------. The final step is to hand code portions of ``XXXInstrInfo``, which implements; the interface described in ``TargetInstrInfo.h`` (see :ref:`TargetInstrInfo`).; These functions return ``0`` or a Boolean or they assert, unless overridden.; Here's a list of functions that are overridden for the SPARC implementation in; ``SparcInstrInfo.cpp``:. * ``isLoadFromStackSlot`` --- If the specified machine instruction is a direct; load from a stack slot, return the register number of the destination and the; ``FrameIndex`` of the stack slot. * ``isStoreToStackSlot`` --- If the specified machine instruction is a direct; store to a stack slot, return the register number of the destination and the; ``FrameIndex`` of the stack slot. * ``copyPhysReg`` --- Copy values between a pair of physical registers. * ``storeRegToStackSlot`` --- Store a register value to a stack slot. * ``loadRegFromStackSlot`` --- Load a register value from a stack slot. * ``storeRegToAddr`` --- Store a register value to memory. * ``loadRegFromAddr`` --- Load a register value from memory. * ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:45764,interface,interface,45764,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['interface'],['interface']
Integrability,"for details:. #. `Maintenance of metadata`_. .. _Reporting:. Reporting bugs; ==============. See :doc:`HowToSubmitABug` on further details on how to submit good bug reports. You can apply `labels <https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/managing-labels>`_; to the bug to provide extra information to make the bug easier to discover, such; as a label for the part of the project the bug pertains to. .. _Triaging:. Triaging bugs; =============. Open bugs that have not been marked with the ``confirmed`` label are bugs that; still need to be triaged. When triage is complete, the ``confirmed`` label; should be added along with any other labels that help to classify the report,; unless the issue is being :ref:`closed<Closing>`. The goal of triaging a bug is to make sure a newly reported bug ends up in a; good, actionable state. Try to answer the following questions while triaging:. * Is the reported behavior actually wrong?. * E.g. does a miscompile example depend on undefined behavior?. * Can you reproduce the bug from the details in the report?. * If not, is there a reasonable explanation why it cannot be reproduced?. * Is it related to an already reported bug?. * Are the following fields filled in correctly?. * Title; * Description; * Labels. * When able to do so, please add the appropriate labels to classify the bug,; such as the tool (``clang``, ``clang-format``, ``clang-tidy``, etc) or; component (``backend:<name>``, ``compiler-rt:<name>``, ``clang:<name>``, etc). * If the issue is with a particular revision of the C or C++ standard, please; add the appropriate language standard label (``c++20``, ``c99``, etc). * Please don't use both a general and a specific label. For example, bugs; labeled ``c++17`` shouldn't also have ``c++``, and bugs labeled; ``clang:codegen`` shouldn't also have ``clang``. * Add the ``good first issue`` label if you think this would be a good bug to; be fixed by someone new to LLVM. This label feeds into `the l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugLifeCycle.rst:2049,depend,depend,2049,interpreter/llvm-project/llvm/docs/BugLifeCycle.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugLifeCycle.rst,1,['depend'],['depend']
Integrability,"for the different interpolation types, but there is a simple script to modify it. . results/example_combined_GaussExample_model.root . Near term goals for HistFactory. Utilities for dealing with Monte Carlo statistical uncertainty in the template histograms; Support for N-D histograms; A new style of histogram variations without a constraint term attached (for shapes determined from control samples); XML steering for interpolation types. RooStats; General Improvements. This release brings several speed improvements to the RooStats tools and improved stability and performance with PROOF. This comes mainly through changes to the ToyMCSampler. In addition the HypoTestInverter tool has been rewritten, leading to some changes in the HypoTestResult. Finally, a new hypothesis test new called FrequentistCalculator was written, which plays the same role as the HybridCalculator but eliminates nuisance parameters in a frequentist way. ToyMCSampler. The primary interface for this class is to return a SamplingDistribution of a given TestStatistic.; The ToyMCSampler had a number of internal changes for improved performance with PROOF. These should be transparent. In addition, a new method was added RooAbsData* GenerateToyData(RooArgSet& paramPoint) that gives public access to the generation of toy data with all the same options for the treatment of nuisance parameters, binned or unbinned data, treatment of the global observables, importance sampling, etc. This is new method particularly useful for producing the expected limit bands where one needs to generate background-only pseudo-experiments in the same way that was used for the primary limit calculation. HypoTestResult. In the process of writing the new HypoTestInverter the conventions for p-values, CLb, CLs+b, and CLs were revisited. The situation is complicated by the fact that when performing a hypothesis test for discovery the null is background-only, but when performing an inverted hypothesis test the null is a signal+back",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html:1880,interface,interface,1880,roofit/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html,1,['interface'],['interface']
Integrability,"for weakly-linked C functions, ``+class`` for Objective-C classes,; and ``-respondsToSelector:`` or ``+instancesRespondToSelector:`` for; Objective-C methods. If such a check was missed, the program would compile; fine, run fine on newer systems, but crash on older systems. As of LLVM 5.0, ``-Wunguarded-availability`` uses the `availability attributes; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ together; with the new ``@available()`` keyword to assist with this issue.; When a method that's introduced in the OS newer than the target OS is called, a; -Wunguarded-availability warning is emitted if that call is not guarded:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; // If fancyNewMethod was added in e.g. macOS 10.12, but the code is; // built with -mmacosx-version-min=10.11, then this unconditional call; // will emit a -Wunguarded-availability warning:; [var fancyNewMethod];; }. To fix the warning and to avoid the crash on macOS 10.11, wrap it in; ``if(@available())``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, *)) {; [var fancyNewMethod];; } else {; // Put fallback behavior for old macOS versions (and for non-mac; // platforms) here.; }; }. The ``*`` is required and means that platforms not explicitly listed will take; the true branch, and the compiler will emit ``-Wunguarded-availability``; warnings for unlisted platforms based on those platform's deployment target.; More than one platform can be listed in ``@available()``:. .. code-block:: objc. void my_fun(NSSomeClass* var) {; if (@available(macOS 10.12, iOS 10, *)) {; [var fancyNewMethod];; }; }. If the caller of ``my_fun()`` already checks that ``my_fun()`` is only called; on 10.12, then add an `availability attribute; <https://clang.llvm.org/docs/AttributeReference.html#availability>`_ to it,; which will also suppress the warning and require that calls to my_fun() are; checked:. .. code-block:: objc. API_AVAILABLE(macos(10.12)) void m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:81912,wrap,wrap,81912,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['wrap'],['wrap']
Integrability,"formation, the compiler inserts bounds checks on every; pointer dereference, ensuring that the program does not access memory outside; the specified bounds. The compiler requires programmers to provide enough bounds; information so that the accesses can be checked at either run time or compile; time — and it rejects code if it cannot. The most important contribution of ``-fbounds-safety`` is how it reduces the; programmer's annotation burden by reconciling bounds annotations at ABI; boundaries with the use of implicit wide pointers (a.k.a. ""fat"" pointers) that; carry bounds information on local variables without the need for annotations. We; designed this model so that it preserves ABI compatibility with C while; minimizing adoption effort. The ``-fbounds-safety`` extension has been adopted on millions of lines of; production C code and proven to work in a consumer operating system setting. The; extension was designed to enable incremental adoption — a key requirement in; real-world settings where modifying an entire project and its dependencies all; at once is often not possible. It also addresses multiple of other practical; challenges that have made existing approaches to safer C dialects difficult to; adopt, offering these properties that make it widely adoptable in practice:. * It is designed to preserve the Application Binary Interface (ABI).; * It interoperates well with plain C code.; * It can be adopted partially and incrementally while still providing safety; benefits.; * It is a conforming extension to C.; * Consequently, source code that adopts the extension can continue to be; compiled by toolchains that do not support the extension (CAVEAT: this still; requires inclusion of a header file macro-defining bounds annotations to; empty).; * It has a relatively low adoption cost. This document discusses the key designs of ``-fbounds-safety``. The document is; subject to be actively updated with a more detailed specification. The; implementation plan can be f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:1880,depend,dependencies,1880,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['depend'],['dependencies']
Integrability,"forward. One additional option is ``std::vector<bool>``: we discourage its use for two; reasons 1) the implementation in many common compilers (e.g. commonly; available versions of GCC) is extremely inefficient and 2) the C++ standards; committee is likely to deprecate this container and/or change it significantly; somehow. In any case, please don't use it. .. _dss_bitvector:. BitVector; ^^^^^^^^^. The BitVector container provides a dynamic size set of bits for manipulation.; It supports individual bit setting/testing, as well as set operations. The set; operations take time O(size of bitvector), but operations are performed one word; at a time, instead of one bit at a time. This makes the BitVector very fast for; set operations compared to other containers. Use the BitVector when you expect; the number of set bits to be high (i.e. a dense set). .. _dss_smallbitvector:. SmallBitVector; ^^^^^^^^^^^^^^. The SmallBitVector container provides the same interface as BitVector, but it is; optimized for the case where only a small number of bits, less than 25 or so,; are needed. It also transparently supports larger bit counts, but slightly less; efficiently than a plain BitVector, so SmallBitVector should only be used when; larger counts are rare. At this time, SmallBitVector does not support set operations (and, or, xor), and; its operator[] does not provide an assignable lvalue. .. _dss_sparsebitvector:. SparseBitVector; ^^^^^^^^^^^^^^^. The SparseBitVector container is much like BitVector, with one major difference:; Only the bits that are set, are stored. This makes the SparseBitVector much; more space efficient than BitVector when the set is sparse, as well as making; set operations O(number of set bits) instead of O(size of universe). The; downside to the SparseBitVector is that setting and testing of random bits is; O(N), and on large SparseBitVectors, this can be slower than BitVector. In our; implementation, setting or testing bits in sorted order (either forwards ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:97489,interface,interface,97489,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['interface'],['interface']
Integrability,"four operands of the `X86 addressing mode`_, which are; currently matched with custom C++ code). In addition, we'll extend fragments; so that a fragment can match multiple different patterns. * We don't automatically infer flags like ``isStore``/``isLoad`` yet. * We don't automatically generate the set of supported registers and operations; for the `Legalizer`_ yet. * We don't have a way of tying in custom legalized nodes yet. Despite these limitations, the instruction selector generator is still quite; useful for most of the binary and logical operations in typical instruction; sets. If you run into any problems or can't figure out how to do something,; please let Chris know!. .. _Scheduling and Formation:; .. _SelectionDAG Scheduling and Formation:. SelectionDAG Scheduling and Formation Phase; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The scheduling phase takes the DAG of target instructions from the selection; phase and assigns an order. The scheduler can pick an order depending on; various constraints of the machines (i.e. order for minimal register pressure or; try to cover instruction latencies). Once an order is established, the DAG is; converted to a list of :raw-html:`<tt>` `MachineInstr`_\s :raw-html:`</tt>` and; the SelectionDAG is destroyed. Note that this phase is logically separate from the instruction selection phase,; but is tied to it closely in the code because it operates on SelectionDAGs. Future directions for the SelectionDAG; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. #. Optional function-at-a-time selection. #. Auto-generate entire selector from ``.td`` file. .. _SSA-based Machine Code Optimizations:. SSA-based Machine Code Optimizations; ------------------------------------. To Be Written. Live Intervals; --------------. Live Intervals are the ranges (intervals) where a variable is *live*. They are; used by some `register allocator`_ passes to determine if two or more virtual; registers which require the same physical register are live at the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:53689,depend,depending,53689,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['depend'],['depending']
Integrability,"fp-math. Enable setting the FP exceptions build attribute not to use exceptions. .. option:: --enable-unsafe-fp-math. Enable optimizations that make unsafe assumptions about IEEE math (e.g. that; addition is associative) or may not work for all input ranges. These; optimizations allow the code generator to make use of some instructions which; would otherwise not be usable (such as ``fsin`` on X86). .. option:: --stats. Print statistics recorded by code-generation passes. .. option:: --time-passes. Record the amount of time needed for each pass and print a report to standard; error. .. option:: --load=<dso_path>. Dynamically load ``dso_path`` (a path to a dynamically shared object) that; implements an LLVM target. This will permit the target name to be used with; the :option:`-march` option so that code can be generated for that target. .. option:: -meabi=[default|gnu|4|5]. Specify which EABI version should conform to. Valid EABI versions are *gnu*,; *4* and *5*. Default value (*default*) depends on the triple. .. option:: -stack-size-section. Emit the .stack_sizes section which contains stack size metadata. The section; contains an array of pairs of function symbol values (pointer size) and stack; sizes (unsigned LEB128). The stack size values only include the space allocated; in the function prologue. Functions with dynamic stack allocations are not; included. .. option:: -remarks-section. Emit the __remarks (MachO) section which contains metadata about remark; diagnostics. Tuning/Configuration Options; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. option:: --print-after-isel. Print generated machine code after instruction selection (useful for debugging). .. option:: --regalloc=<allocator>. Specify the register allocator to use.; Valid register allocators are:. *basic*. Basic register allocator. *fast*. Fast register allocator. It is the default for unoptimized code. *greedy*. Greedy register allocator. It is the default for optimized code. *pbqp*. Register allocator based on '",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst:4718,depend,depends,4718,interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llc.rst,1,['depend'],['depends']
Integrability,"frame - after the |; | | arrangement of all frames the available ""free"" height |; | | space is shared between the frames having this hint |; +------------------+---------------------------------------------------------+; | `kLHintsNormal` | = `kLHintsLeft | kLHintsTop` - default hints |; +------------------+---------------------------------------------------------+. Layout policy:. Child frames never modify their container frame. The container frame can; (or cannot) adapt its size in the layout process. It can show all or a; part of its frames. Every **`TGFrame`** object has a default minimum; size (1, 1) assured by **`TGWindow`**. ## Event Processing: Signals and Slots. Event handling covers the interaction between different objects and; between the user and the objects in an application. There are two; general ways for the user to interact with an application: the keyboard; and the mouse. The Graphical User Interface is as a bridge between the; user and the program - it provides methods to detect the user actions; and instruments that do something as a reaction of these actions. The; user communicates with an application through the window system. The; window system reports interaction events to the application. The; application in turn forwards them to the currently active window. The; objects/widgets receive the events and react to them according to the; application functionality. ![](pictures/0200020B.jpg). The signals/slot communication mechanism is an advanced object; communication concept; it largely replaces the concept of callback; functions to handle actions in GUI's. Signals and slots are just like; any object-oriented methods implemented in C++. The objects are the; instances of classes that don't know anything about each other. They; interact and allow method calls of other object's methods. The idea is; simple: any object can send out (emit) a signal in certain situations; saying that something happened. This is all it does to communicate and; it does",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:40191,bridg,bridge,40191,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['bridg'],['bridge']
Integrability,"from `TLine`. The; constructors of lines and arrows always contain the coordinates of the; endpoints. Arrows also foresee parameters to [specify; their](https://root.cern.ch/doc/master/classTArrow.html) shapes. Do not; underestimate the role of lines and arrows in your plots. Since each; plot should contain a message, it is convenient to stress it with; additional graphics primitives. ### Text. Also text plays a fundamental role in making the plots self-explanatory.; A possibility to add text in your plot is provided by the `TLatex`; class. The objects of this class are constructed with the coordinates of; the bottom-left corner of the text and a string which contains the text; itself. The real twist is that ordinary; [Latex mathematical symbols](https://root.cern.ch/doc/master/classTLatex.html#L5); are automatically interpreted, you just need to replace the ""\\"" by a ""\#"". If; [""\\"" is used as control character](https://root.cern.ch/doc/master/classTLatex.html#L14); , then the; [TMathText interface](https://root.cern.ch/doc/master/classTMathText.html); is invoked. It provides the plain TeX syntax and allow to access character's; set like Russian and Japanese. ## Interpretation and Compilation. As you observed, up to now we heavily exploited the capabilities of ROOT; for interpreting our code, more than compiling and then executing. This; is sufficient for a wide range of applications, but you might have; already asked yourself ""how can this code be compiled ?"". There are two; answers. ### Compile a Macro with ACLiC. ACLiC will create for you a compiled dynamic library for your macro,; without any effort from your side, except the insertion of the; appropriate header files in lines *5--11*. In this example, they are; already included. To generate an object library from the macro code, from inside the; interpreter type (please note the ""+""):. ``` {.cpp}; root [1] .L macro1.C+; ```. Once this operation is accomplished, the macro symbols will be available; in memory an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:8783,interface,interface,8783,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['interface'],['interface']
Integrability,"from the function gradient interface (ROOT::Math::IGradFunction and ROOT::Math::IMultiGradFunction). They define only the parameter gradient which is needed for fitting and not the coordinate gradient. A derived class, like ROOT::Math::Polynomial, implementing both functionality (coordinate and parameter gradient) inherits then from both interfaces.; . More detailed description of the current MathCore release can be found at this location. MathMore; This new release contains:. Modify and rename the class ROOT::Math::RootFinder to ROOT::Math::GSLRootFinder to distinguish from the main interface class which has been put in the Mathcore library and it can create the GSLRootFinder using the plug-in manager. Furthermore, the class ROOT::Math::GSLRootFinder is not anymore a template class on the algorithm. They type of root-finder algorithm can now be selected via an enumeration; Fixed a bug in the ROOT::Math::GSLNLSMultiFi class.; Changes also in the class for the new enumeration names (all names start with k, like kADAPTIVE for the integration types).; . More detailed description of the current MathMore release can be found at this location. GenVector; The new physics vector classes have been moved out from the MathCore library in a new library, libGenVector. The library contains as well the CINT dictionary including main instantiations for the template classes. For this release the instantiation of some extra methods, in particular of the class ROOT::Math::TRansform3D have been added in the dictionary library.; Due to a CINT limitation, the dictionary for explicit template constructors of the Rotation classes, taking as input any other type; of rotation are missing. Therefore code like the following one will now work in CINT (or Python):. ROOT::Math::Rotation3D r;; ROOT::Math::EulerAngles eulerRot(r);. A possible solution is to use the operator=:. ROOT::Math::EulerAngles eulerRot; eulerRot = r;. In addition the setter methods for the 2D,3D and 4D vector classes have bee",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:10880,integrat,integration,10880,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['integrat'],['integration']
Integrability,"frounding-math"", ""{dynamic, tonearest, downward, upward, towardzero}""; ""ffp-contract"", ""{on, off, fast, fast-honor-pragmas}""; ""fdenormal-fp-math"", ""{IEEE, PreserveSign, PositiveZero}""; ""fdenormal-fp-math-fp32"", ""{IEEE, PreserveSign, PositiveZero}""; ""fmath-errno"", ""{on, off}""; ""fhonor-nans"", ""{on, off}""; ""fhonor-infinities"", ""{on, off}""; ""fsigned-zeros"", ""{on, off}""; ""freciprocal-math"", ""{on, off}""; ""allow_approximate_fns"", ""{on, off}""; ""fassociative-math"", ""{on, off}"". This table describes the option settings that correspond to the three; floating point semantic models: precise (the default), strict, and fast. .. csv-table:: Floating Point Models; :header: ""Mode"", ""Precise"", ""Strict"", ""Fast""; :widths: 25, 15, 15, 15. ""except_behavior"", ""ignore"", ""strict"", ""ignore""; ""fenv_access"", ""off"", ""on"", ""off""; ""rounding_mode"", ""tonearest"", ""dynamic"", ""tonearest""; ""contract"", ""on"", ""off"", ""fast""; ""denormal_fp_math"", ""IEEE"", ""IEEE"", ""IEEE""; ""denormal_fp32_math"", ""IEEE"",""IEEE"", ""IEEE""; ""support_math_errno"", ""on"", ""on"", ""off""; ""no_honor_nans"", ""off"", ""off"", ""on""; ""no_honor_infinities"", ""off"", ""off"", ""on""; ""no_signed_zeros"", ""off"", ""off"", ""on""; ""allow_reciprocal"", ""off"", ""off"", ""on""; ""allow_approximate_fns"", ""off"", ""off"", ""on""; ""allow_reassociation"", ""off"", ""off"", ""on"". .. option:: -ffast-math. Enable fast-math mode. This option lets the; compiler make aggressive, potentially-lossy assumptions about; floating-point math. These include:. * Floating-point math obeys regular algebraic rules for real numbers (e.g.; ``+`` and ``*`` are associative, ``x/y == x * (1/y)``, and; ``(a + b) * c == a * c + b * c``),; * Operands to floating-point operations are not equal to ``NaN`` and; ``Inf``, and; * ``+0`` and ``-0`` are interchangeable. ``-ffast-math`` also defines the ``__FAST_MATH__`` preprocessor; macro. Some math libraries recognize this macro and change their behavior.; With the exception of ``-ffp-contract=fast``, using any of the options; below to disable any of the individual optimi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:51362,contract,contract,51362,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['contract'],['contract']
Integrability,"full documentation on the CMake if command go; `here <https://cmake.org/cmake/help/v3.4/command/if.html>`_. That resource is; far more complete. In general CMake if blocks work the way you'd expect:. .. code-block:: cmake. if(<condition>); message(""do stuff""); elseif(<condition>); message(""do other stuff""); else(); message(""do other other stuff""); endif(). The single most important thing to know about CMake's if blocks coming from a C; background is that they do not have their own scope. Variables set inside; conditional blocks persist after the ``endif()``. Loops; -----. The most common form of the CMake ``foreach`` block is:. .. code-block:: cmake. foreach(var ...); message(""do stuff""); endforeach(). The variable argument portion of the ``foreach`` block can contain dereferenced; lists, values to iterate, or a mix of both:. .. code-block:: cmake. foreach(var foo bar baz); message(${var}); endforeach(); # prints:; # foo; # bar; # baz. set(my_list 1 2 3); foreach(var ${my_list}); message(${var}); endforeach(); # prints:; # 1; # 2; # 3. foreach(var ${my_list} out_of_bounds); message(${var}); endforeach(); # prints:; # 1; # 2; # 3; # out_of_bounds. There is also a more modern CMake foreach syntax. The code below is equivalent; to the code above:. .. code-block:: cmake. foreach(var IN ITEMS foo bar baz); message(${var}); endforeach(); # prints:; # foo; # bar; # baz. set(my_list 1 2 3); foreach(var IN LISTS my_list); message(${var}); endforeach(); # prints:; # 1; # 2; # 3. foreach(var IN LISTS my_list ITEMS out_of_bounds); message(${var}); endforeach(); # prints:; # 1; # 2; # 3; # out_of_bounds. Similar to the conditional statements, these generally behave how you would; expect, and they do not have their own scope. CMake also supports ``while`` loops, although they are not widely used in LLVM. Modules, Functions and Macros; =============================. Modules; -------. Modules are CMake's vehicle for enabling code reuse. CMake modules are just; CMake script files. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:8626,message,message,8626,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['message'],['message']
Integrability,"function also needs to be added when; `analyticalIntegral()` is found in your class. Depending on the code, you can; call one or more integral functions using the `code` parameter. Our RooFoo; example above only contains one integral function (`integralFoo()`). Similar to `doFoo()`, comment out `integralFoo()' in the original file and; move it to 'MathFuncs.h'. As with `doFoo()`. add the relevant inputs (a,b) as parameters, instead of; just class members. ``` {.cpp}; ///// The MathFuncs.h file; int integralFoo(int a, int b) { return /* whatever */;}; ```. > Directory path: [hist/hist/src/MathFuncs.h](https://github.com/root-project/root/blob/master/hist/hist/src/MathFuncs.h). Next, in the original RooFoo class, update all references to the; `integralFoo()` function with its new fully qualified path (; `EvaluateFunc::integralFoo`) and include the input parameters as well (; `EvaluateFunc::integralFoo(a, b)`). ``` {.cpp}; double analyticalIntegral(Int_t code, const char* rangeName) override {; // Select the right paths for integration using codes or whatever.; return EvaluateFunc::integralFoo(a, b);; }; ```. Next, in the `RooAbsReal::buildCallToAnalyticIntegral()` function, simply; return the output using the `buildCall()` function. ``` {.cpp}; std::string; buildCallToAnalyticIntegral(Int_t code, const char *rangeName, RooFit::Detail::RooFit::Detail::CodeSquashContext &ctx) const override {; return ctx.buildCall(""EvaluateFunc::integralFoo"", a, b);; }; ```. \note The implementation of the `RooAbsReal::buildCallToAnalyticIntegral()`; function is quite similar to the `translate()` function, except that in; `translate()`, you have to add to the result (using `addResult()`), while for; `buildCallToAnalyticIntegral()`, you only have to return the string (using; `buildCall()`). **Consolidated Code changes in RooFoo example**. Final RooFoo code:. ``` {.cpp}; class RooFoo : public RooAbsReal {; int a;; int b;; // int doFoo() { return a* b + a + b; }; // int integralFoo() { retu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:23579,integrat,integration,23579,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['integrat'],['integration']
Integrability,"function with; both ``cf_audited_transfer`` and ``cf_unknown_transfer``. A pragma is provided to facilitate the mass annotation of interfaces:. .. code-block:: objc. #pragma clang arc_cf_code_audited begin; ...; #pragma clang arc_cf_code_audited end. All C functions declared within the extent of this pragma are treated as if; annotated with the ``cf_audited_transfer`` attribute unless they otherwise have; the ``cf_unknown_transfer`` attribute. The pragma is accepted in all language; modes. A program is ill-formed if it attempts to change files, whether by; including a file or ending the current file, within the extent of this pragma. It is possible to test for all the features in this section with; ``__has_feature(arc_cf_code_audited)``. .. admonition:: Rationale. A significant inconvenience in ARC programming is the necessity of; interacting with APIs based around C retainable pointers. These features are; designed to make it relatively easy for API authors to quickly review and; annotate their interfaces, in turn improving the fidelity of tools such as; the static analyzer and ARC. The single-file restriction on the pragma is; designed to eliminate the risk of accidentally annotating some other header's; interfaces. .. _arc.runtime:. Runtime support; ===============. This section describes the interaction between the ARC runtime and the code; generated by the ARC compiler. This is not part of the ARC language; specification; instead, it is effectively a language-specific ABI supplement,; akin to the ""Itanium"" generic ABI for C++. Ownership qualification does not alter the storage requirements for objects,; except that it is undefined behavior if a ``__weak`` object is inadequately; aligned for an object of type ``id``. The other qualifiers may be used on; explicitly under-aligned memory. The runtime tracks ``__weak`` objects which holds non-null values. It is; undefined behavior to direct modify a ``__weak`` object which is being tracked; by the runtime except thr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:104974,interface,interfaces,104974,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['interface'],['interfaces']
Integrability,"functionality has been added inheriting from RooAbsReal.; These are RooAbsCachedReal,RooAbsSelfCachedReal and RooCachedReal. A newly; added class RooHistFunc presents these shapes and is capable of handling negative entries. New PDF error handling structure. New infrastructure has been put into place to propagate and process p.d.f evaluation errors during fitting.; Previously evaluation errors were marked with a zero p.d.f value and propagated as a special condition; in RooAddPdf, RooProdPdf etc to result in a zero top-level p.d.f value that was caught by the RooFit minuit; interface as a special condition. Summary information on the value of the parameters and the observables; was printed for the first 10 occurrences of such conditions. . Now, each p.d.f component that generates an error; in its evaluation logs the error into a separate facility during fitting and the RooFit minuit interface; polls this error logging facility for problems. This allows much more detailed and accurate warning messages; during the minimization phase. The level of verbosity of this new error facility can be controlled with; a new . PrintEvalErrors(Int_t code). argument to fitTo(). . With code of -1, no errors are printed at all.; With a; code of zero, one line is printed for each p.d.f component with problems summarizing the number of times; problems occurred during the likelihood evaluation. . [#0] WARNING:Minization -- RooFitGlue: Minimized function has error status. ; Returning maximum FCN so far (-1e+30) to force MIGRAD to back out of this region. Error log follows; Parameter values: m=-7.397; RooGaussian::gx[ x=x mean=m sigma=sx ] has 3 errors. A code greater than zero will generate even more detail and; print the details of each evaluation error as provided by the p.d.f (zero value, not-a-number, normalization zero etc..); and show the observable values at which this error occurred. At most N detailed messages per p.d.f component; are shown where N is the integral value of the 'co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:15762,message,messages,15762,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['message'],['messages']
Integrability,"fuzzer is good for stressing the surface layers of a; program, and is good at testing things like lexers, parsers, or binary; protocols. Some of the in-tree fuzzers that use this type of mutator are `clang-fuzzer`_,; `clang-format-fuzzer`_, `llvm-as-fuzzer`_, `llvm-dwarfdump-fuzzer`_,; `llvm-mc-assemble-fuzzer`_, and `llvm-mc-disassemble-fuzzer`_. .. _fuzzing-llvm-protobuf:. Structured Fuzzing using ``libprotobuf-mutator``; ------------------------------------------------. We can use libprotobuf-mutator_ in order to perform structured fuzzing and; stress deeper layers of programs. This works by defining a protobuf class that; translates arbitrary data into structurally interesting input. Specifically, we; use this to work with a subset of the C++ language and perform mutations that; produce valid C++ programs in order to exercise parts of clang that are more; interesting than parser error handling. To build this kind of fuzzer you need `protobuf`_ and its dependencies; installed, and you need to specify some extra flags when configuring the build; with :doc:`CMake <CMake>`. For example, `clang-proto-fuzzer`_ can be enabled by; adding ``-DCLANG_ENABLE_PROTO_FUZZER=ON`` to the flags described in; :ref:`building-fuzzers`. The only in-tree fuzzer that uses ``libprotobuf-mutator`` today is; `clang-proto-fuzzer`_. .. _libprotobuf-mutator: https://github.com/google/libprotobuf-mutator; .. _protobuf: https://github.com/google/protobuf. .. _fuzzing-llvm-ir:. Structured Fuzzing of LLVM IR; -----------------------------. We also use a more direct form of structured fuzzing for fuzzers that take; :doc:`LLVM IR <LangRef>` as input. This is achieved through the ``FuzzMutate``; library, which was `discussed at EuroLLVM 2017`_. The ``FuzzMutate`` library is used to structurally fuzz backends in; `llvm-isel-fuzzer`_. .. _discussed at EuroLLVM 2017: https://www.youtube.com/watch?v=UBbQ_s6hNgg. Building and Running; ====================. .. _building-fuzzers:. Configuring LLVM to Build",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst:6950,depend,dependencies,6950,interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,1,['depend'],['dependencies']
Integrability,"g builtin type which represents it. This mapping helps; to import execution results from the interpreter in a compiled program and vice; versa. The ``Value.h`` header file can be included at runtime and this is why it; has a very low token count and was developed with strict constraints in mind. This also enables the user to receive the computed 'type' back in their code; and then transform the type into something else (e.g., re-cast a double into; a float). Normally, the compiler can handle these conversions transparently,; but in interpreter mode, the compiler cannot see all the 'from' and 'to' types,; so it cannot implicitly do the conversions. So this logic enables providing; these conversions on request. On-request conversions can help improve the user experience, by allowing; conversion to a desired 'to' type, when the 'from' type is unknown or unclear. Significance of this Feature; ----------------------------. The 'Value' object enables wrapping a memory region that comes from the; JIT, and bringing it back to the compiled code (and vice versa).; This is a very useful functionality when:. - connecting an interpreter to the compiled code, or; - connecting an interpreter in another language. For example, this feature helps transport values across boundaries. A notable; example is the cppyy project code makes use of this feature to enable running C++; within Python. It enables transporting values/information between C++; and Python. Note: `cppyy <https://github.com/wlav/cppyy/>`_ is an automatic, run-time,; Python-to-C++ bindings generator, for calling C++ from Python and Python from C++.; It uses LLVM along with a C++ interpreter (e.g., Cling) to enable features like; run-time instantiation of C++ templates, cross-inheritance, callbacks,; auto-casting, transparent use of smart pointers, etc. In a nutshell, this feature enables a new way of developing code, paving the; way for language interoperability and easier interactive programming. Implementation Details;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:10376,wrap,wrapping,10376,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['wrap'],['wrapping']
Integrability,"g dictionary in Osx 12.7, Xcode 14.2; * [[#14594](https://github.com/root-project/root/issues/14594)] - Provide `file.root` request in THttpServer; * [[#14593](https://github.com/root-project/root/issues/14593)] - Build fails with CLING_DEBUG=1 set; * [[#14586](https://github.com/root-project/root/issues/14586)] - [ROOT-6317] using namespace statement does not provoke autoload; * [[#14576](https://github.com/root-project/root/issues/14576)] - [ROOT-7155] Angular units used in HTML doc of TGLViewer::SetPerspectiveCamera are wrong; * [[#14575](https://github.com/root-project/root/issues/14575)] - [ROOT-10196] boundary check in TH1::AddBinContent is missing; * [[#14569](https://github.com/root-project/root/issues/14569)] - [ROOT-8348] Segmentation Fault in TMVA::DecisionTreeNode::Print; * [[#14562](https://github.com/root-project/root/issues/14562)] - [ROOT-5009] TClass::SetDeclFile: second parameter wrong type; * [[#14553](https://github.com/root-project/root/issues/14553)] - [ROOT-10909] Add TMVA python dependencies to the requirements.txt; * [[#14547](https://github.com/root-project/root/issues/14547)] - [ROOT-9200] With Cocoa backend sometimes need two ProcessEvents to show Canvas; * [[#14528](https://github.com/root-project/root/issues/14528)] - Bug in TFoam::GetIntNorm; * [[#14510](https://github.com/root-project/root/issues/14510)] - Large computation graphs cause serious memory and runtime overhead; * [[#14509](https://github.com/root-project/root/issues/14509)] - ROOT segfaults on riscv64; * [[#14508](https://github.com/root-project/root/issues/14508)] - Using LZMA compression with RNTupleWriter leads to memory corruption; * [[#14499](https://github.com/root-project/root/issues/14499)] - It is not possible to set the Title of the palette for a 3D axis; * [[#14462](https://github.com/root-project/root/issues/14462)] - Parser for I/O customization rule is too strict.; * [[#14458](https://github.com/root-project/root/issues/14458)] - Crash when doing Weighted Like",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:30986,depend,dependencies,30986,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['depend'],['dependencies']
Integrability,"g info,; after each of these steps. Alternatively, ``-debug-only=isel-dump`` shows only; the DAG dumps, but the results can be filtered by function names using; ``-filter-print-funcs=<function names>``. One great way to visualize what is going on here is to take advantage of a few; LLC command line options. The following options pop up a window displaying the; SelectionDAG at specific times (if you only get errors printed to the console; while using this, you probably `need to configure your; system <ProgrammersManual.html#viewing-graphs-while-debugging-code>`_ to add support for it). * ``-view-dag-combine1-dags`` displays the DAG after being built, before the; first optimization pass. * ``-view-legalize-dags`` displays the DAG before Legalization. * ``-view-dag-combine2-dags`` displays the DAG before the second optimization; pass. * ``-view-isel-dags`` displays the DAG before the Select phase. * ``-view-sched-dags`` displays the DAG before Scheduling. The ``-view-sunit-dags`` displays the Scheduler's dependency graph. This graph; is based on the final SelectionDAG, with nodes that must be scheduled together; bundled into a single scheduling-unit node, and with immediate operands and; other nodes that aren't relevant for scheduling omitted. The option ``-filter-view-dags`` allows to select the name of the basic block; that you are interested to visualize and filters all the previous; ``view-*-dags`` options. .. _Build initial DAG:. Initial SelectionDAG Construction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The initial SelectionDAG is na\ :raw-html:`&iuml;`\ vely peephole expanded from; the LLVM input by the ``SelectionDAGBuilder`` class. The intent of this pass; is to expose as much low-level, target-specific details to the SelectionDAG as; possible. This pass is mostly hard-coded (e.g. an LLVM ``add`` turns into an; ``SDNode add`` while a ``getelementptr`` is expanded into the obvious; arithmetic). This pass requires target-specific hooks to lower calls, returns,; vararg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:39704,depend,dependency,39704,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['depend'],['dependency']
Integrability,"g is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward to having more use-cases and extend our tool in that direction.; Cling has internal commands, which can change its behavior at runtime. Those commands usually start with dot (.):; .I <path> - Adds an include path;; .x <filename> - #include-s the filename; and calls function called filename(); ; .L <libname> - Loads libname or #include-s the libname if libname is file;; .@ - Cancels the multiline input;; .printAST - (DEBUG ONLY) Turns on the printing of the compiler's abstract syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run the function. The semantics of the statements that declare variables is that variables should b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:2913,depend,depend,2913,interpreter/cling/www/old/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html,1,['depend'],['depend']
Integrability,"g of expensive components cached by operator p.d.f.s ; RooMCStudy - Add Silence() argument to constructor to request minimal verbosity during running; RooMinuit - Improve contour() method to return RooPlots rather than drawing TGraphs straight on a canvas; RooWorkspace - Add private expensive object cache to workspace; RooBinningCategory - New real-to-category function that maps values of input RooRealVar to categories with labels that correspond to bins of input RooRealVar. See rf405_realtocatfuncs.C for details . RooStats; This is a new package introduced in this version for statistical tools built on top of RooFit. It is a joint effort between the LHC experiments and the ROOT team (see the RooStats Wiki page).; ; This version contains the interfaces for performing the statistical calculations and dealing with the obtained results and concrete classes implementing the statistical methods.; ; All the classes and functions in RooStats are provided in the namespace RooStats.; ; RooStats interfaces. ConfInterval: interface for describing a confidence interval. ; IntervalCalculator: interface for a statistical tool producing confidence intervals (class ConfInterval).; HypoTestResult: interface for representing results of a hypothesis test; HypoTestCalculator: interface for a statistical tool performing an hypothesis test. ; CombinedCalculator: interface for a statistical tool which can produce both hypothesis test results and confidence intervals. ; RooStats concrete classes. The concrete classes describing statistical tools implementing the above interfaces are:; ; ProfileLikelihoodCalculator: it is an implementation of a CombinedCalculator using the profile likelihood ratio as a test statistics. After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer).; LikelihoodInterval: concrete implementation of a ConfInterval interface. It implements connected N",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:9815,interface,interfaces,9815,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['interface'],['interfaces']
Integrability,"g part; needing manual intervention.; This is broadly true, but realize that that 5% contains the most difficult; cases and is where 20-30% of the effort would have gone in case the bindings; were done fully manually.; It is therefore important to consider what manual tools an automatic binder; offers and to make sure they fit your work style and needs, because you are; going to spend a significant amount of time with them. `LLVM dependency`; -----------------. cppyy depends on `LLVM`_, through Cling.; LLVM is properly internalized, so that it doesn't conflict with other uses;; and in particular it is fine to mix `Numba`_ and cppyy code.; It does mean a download cost of about 20MB for the binary wheel (exact size; differs per platform) on installation, and additional `primarily initial`; memory overheads at run-time.; Whether this is onerous depends strongly not only on the application, but; also on the rest of the software stack. The initial cost of loading cppyy, and thus starting the Cling interpreter,; is about 45MB (platform dependent).; Initial uses of standard (e.g. STL) C++ results in deserialization of the; precompiled header at another eventual total cost of about 25MB (again,; platform dependent).; The actual bindings of course also carry overheads.; As a rule of thumb, you should budget for ~100MB all-in for the overhead; caused by the bindings. Other binders do not have this initial memory overhead, but do of course; occur an overhead per module, class, function, etc.; At scale, however, cppyy has some advantages: all binding is lazy (including; the option of automatic loading), standard classes are never duplicated, and; there is no additional ""per-module"" overhead.; Thus, eventually (depending on the number of classes bound, across how many; modules, what use fraction, etc.), this initial cost is recouped when; compared to other binders.; As a rule of thumb, if about 10% of classes are used, it takes several; hundreds of bound classes before the cppyy-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:8452,depend,dependent,8452,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['depend'],['dependent']
Integrability,"g review).; * You will see a ""Stack"" tab in the ""Revision Contents"" section of the review; in the web interface, showing the parent review.; * Repeat these steps until you've uploaded or updated all the patches in; your series. When you push the patches, please remove the ""Depends on"" lines from the; commit messages, since they add noise and duplicate git's implicit ordering. One frequently used workflow for creating a series of patches using patch summaries; is based on git's rebasing. These steps assume that you have a series of commits that; you have not posted for review, but can be adapted to update existing reviews. * git interactive rebase back to the first commit you want to upload for review::. git rebase -i HEAD~<number of commits you have written>. * Mark all commits for editing by changing ""pick"" to ""edit"" in the instructions; git shows.; * Start the rebase (usually by writing and closing the instructions).; * For the first commit:. - Upload the current commit for a review (with ``arc diff`` or the web; interface). - Continue to the next commit with ``git rebase --continue``. * For the rest:. - Add the ""Depends on..."" line using ``git commit --amend``. - Upload for review. - Continue the rebase. * Once the rebase is complete, you've created your patch series. .. _finding-potential-reviewers:. Finding potential reviewers; ---------------------------. Here are a couple of ways to pick the initial reviewer(s):. * Use ``git blame`` and the commit log to find names of people who have; recently modified the same area of code that you are modifying.; * Look in CODE_OWNERS.TXT to see who might be responsible for that area.; * If you've discussed the change on a dev list, the people who participated; might be appropriate reviewers. Even if you think the code owner is the busiest person in the world, it's still; okay to put them as a reviewer. Being the code owner means they have accepted; responsibility for making sure the review happens. Reviewing code with Phab",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:8268,interface,interface,8268,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['interface'],['interface']
Integrability,"g the user to reuse the; macro for many different data sets. Here is an example of an input file.; The nice graphic result shown is produced by the macro below, which; reads two such input files and uses different options to display the; data points. ```; # Measurement of Friday 26 March; # Experiment 2 Physics Lab. 1 6 5; 2 12 5; 3 14 4.7; 4 20 4.5; 5 22 4.2; 6 24 5.1; 7 35 2.9; 8 45 4.1; 9 44 4.8; 10 53 5.43; ```; \newpage; ![](figures/graph_with_expectation.png). ``` {.cpp}; @ROOT_INCLUDE_FILE macros/macro2.C; ```. In addition to the inspection of the plot, you can check the actual; contents of the graph with the `TGraph::Print()` method at any time,; obtaining a printout of the coordinates of data points on screen. The; macro also shows us how to print a coloured band around a graph instead; of error bars, quite useful for example to represent the errors of a; theoretical prediction. ## Polar Graphs ##. With ROOT you can profit from rather advanced plotting routines, like; the ones implemented in the `TPolarGraph`, a class to draw graphs in; polar coordinates. You can see the example macro in the following and the; resulting Figure is [4.2](#f42):. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro3.C; ```. A new element was added on line 4, the size of the canvas: it is; sometimes optically better to show plots in specific canvas sizes. [f42]: figures/polar_graph.png ""f42""; <a name=""f42""></a>. ![The graph of a fan obtained with ROOT.\label{f42}][f42]. ## 2D Graphs ##. Under specific circumstances, it might be useful to plot some quantities; versus two variables, therefore creating a bi-dimensional graph. Of; course ROOT can help you in this task, with the `TGraph2DErrors` class.; The following macro produces a bi-dimensional graph representing a; hypothetical measurement, fits a bi-dimensional function to it and draws; it together with its x and y projections. Some points of the code will; be explained in detail. This time, the graph is populated with dat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md:1755,rout,routines,1755,documentation/primer/graphs.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md,1,['rout'],['routines']
Integrability,"g() method. The context value is just a void*. All your traits which use the context; and operate on your native data types, need to agree what the context value; actually is. It could be a pointer to an object or struct which your various; traits use to shared context sensitive information. Output; ======. The llvm::yaml::Output class is used to generate a YAML document from your; in-memory data structures, using traits defined on your data types.; To instantiate an Output object you need an llvm::raw_ostream, an optional; context pointer and an optional wrapping column:. .. code-block:: c++. class Output : public IO {; public:; Output(llvm::raw_ostream &, void *context = NULL, int WrapColumn = 70);. Once you have an Output object, you can use the C++ stream operator on it; to write your native data as YAML. One thing to recall is that a YAML file; can contain multiple ""documents"". If the top level data structure you are; streaming as YAML is a mapping, scalar, or sequence, then Output assumes you; are generating one document and wraps the mapping output; with ""``---``"" and trailing ""``...``"". The WrapColumn parameter will cause the flow mappings and sequences to; line-wrap when they go over the supplied column. Pass 0 to completely; suppress the wrapping. .. code-block:: c++. using llvm::yaml::Output;. void dumpMyMapDoc(const MyMapType &info) {; Output yout(llvm::outs());; yout << info;; }. The above could produce output like:. .. code-block:: yaml. ---; name: Tom; hat-size: 7; ... On the other hand, if the top level data structure you are streaming as YAML; has a DocumentListTraits specialization, then Output walks through each element; of your DocumentList and generates a ""---"" before the start of each element; and ends with a ""..."". .. code-block:: c++. using llvm::yaml::Output;. void dumpMyMapDoc(const MyDocListType &docList) {; Output yout(llvm::outs());; yout << docList;; }. The above could produce output like:. .. code-block:: yaml. ---; name: Tom; hat-size",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:29708,wrap,wraps,29708,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['wrap'],['wraps']
Integrability,"g): Determines whether a; reference of type ``T`` bound to an expression of type ``U`` would bind to a; materialized temporary object. If ``T`` is not a reference type the result; is false. Note this trait will also return false when the initialization of; ``T`` from ``U`` is ill-formed.; Deprecated, use ``__reference_constructs_from_temporary``.; * ``__reference_constructs_from_temporary(T, U)`` (C++); Returns true if a reference ``T`` can be constructed from a temporary of type; a non-cv-qualified ``U``.; * ``__underlying_type`` (C++, GNU, Microsoft). In addition, the following expression traits are supported:. * ``__is_lvalue_expr(e)`` (Embarcadero):; Returns true if ``e`` is an lvalue expression.; Deprecated, use ``__is_lvalue_reference(decltype((e)))`` instead.; * ``__is_rvalue_expr(e)`` (Embarcadero):; Returns true if ``e`` is a prvalue expression.; Deprecated, use ``!__is_reference(decltype((e)))`` instead. There are multiple ways to detect support for a type trait ``__X`` in the; compiler, depending on the oldest version of Clang you wish to support. * From Clang 10 onwards, ``__has_builtin(__X)`` can be used.; * From Clang 6 onwards, ``!__is_identifier(__X)`` can be used.; * From Clang 3 onwards, ``__has_feature(X)`` can be used, but only supports; the following traits:. * ``__has_nothrow_assign``; * ``__has_nothrow_copy``; * ``__has_nothrow_constructor``; * ``__has_trivial_assign``; * ``__has_trivial_copy``; * ``__has_trivial_constructor``; * ``__has_trivial_destructor``; * ``__has_virtual_destructor``; * ``__is_abstract``; * ``__is_base_of``; * ``__is_class``; * ``__is_constructible``; * ``__is_convertible_to``; * ``__is_empty``; * ``__is_enum``; * ``__is_final``; * ``__is_literal``; * ``__is_standard_layout``; * ``__is_pod``; * ``__is_polymorphic``; * ``__is_sealed``; * ``__is_trivial``; * ``__is_trivially_assignable``; * ``__is_trivially_constructible``; * ``__is_trivially_copyable``; * ``__is_union``; * ``__underlying_type``. A simplistic usage example ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:65380,depend,depending,65380,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['depend'],['depending']
Integrability,"g. .. _attrgrp:. Attribute Groups; ----------------. Attribute groups are groups of attributes that are referenced by objects within; the IR. They are important for keeping ``.ll`` files readable, because a lot of; functions will use the same set of attributes. In the degenerative case of a; ``.ll`` file that corresponds to a single ``.c`` file, the single attribute; group will capture the important command line flags used to build that file. An attribute group is a module-level object. To use an attribute group, an; object references the attribute group's ID (e.g. ``#37``). An object may refer; to more than one attribute group. In that situation, the attributes from the; different groups are merged. Here is an example of attribute groups for a function that should always be; inlined, has a stack alignment of 4, and which shouldn't use SSE instructions:. .. code-block:: llvm. ; Target-independent attributes:; attributes #0 = { alwaysinline alignstack=4 }. ; Target-dependent attributes:; attributes #1 = { ""no-sse"" }. ; Function @f has attributes: alwaysinline, alignstack=4, and ""no-sse"".; define void @f() #0 #1 { ... }. .. _fnattrs:. Function Attributes; -------------------. Function attributes are set to communicate additional information about; a function. Function attributes are considered to be part of the; function, not of the function type, so functions with different function; attributes can have the same function type. Function attributes are simple keywords that follow the type specified.; If multiple attributes are needed, they are space separated. For; example:. .. code-block:: llvm. define void @f() noinline { ... }; define void @f() alwaysinline { ... }; define void @f() alwaysinline optsize { ... }; define void @f() optsize { ... }. ``alignstack(<n>)``; This attribute indicates that, when emitting the prologue and; epilogue, the backend should forcibly align the stack pointer.; Specify the desired alignment, which must be a power of two, in; parentheses",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:76647,depend,dependent,76647,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependent']
Integrability,"g. ``vectorize(enable)``). If the transformation is; disabled (e.g. ``vectorize(disable)``), that takes precedence over; transformations option pragmas implying that transformation. Vectorization, Interleaving, and Predication; --------------------------------------------. A vectorized loop performs multiple iterations of the original loop; in parallel using vector instructions. The instruction set of the target; processor determines which vector instructions are available and their vector; widths. This restricts the types of loops that can be vectorized. The vectorizer; automatically determines if the loop is safe and profitable to vectorize. A; vector instruction cost model is used to select the vector width. Interleaving multiple loop iterations allows modern processors to further; improve instruction-level parallelism (ILP) using advanced hardware features,; such as multiple execution units and out-of-order execution. The vectorizer uses; a cost model that depends on the register pressure and generated code size to; select the interleaving count. Vectorization is enabled by ``vectorize(enable)`` and interleaving is enabled; by ``interleave(enable)``. This is useful when compiling with ``-Os`` to; manually enable vectorization or interleaving. .. code-block:: c++. #pragma clang loop vectorize(enable); #pragma clang loop interleave(enable); for(...) {; ...; }. The vector width is specified by; ``vectorize_width(_value_[, fixed|scalable])``, where _value_ is a positive; integer and the type of vectorization can be specified with an optional; second parameter. The default for the second parameter is 'fixed' and; refers to fixed width vectorization, whereas 'scalable' indicates the; compiler should use scalable vectors instead. Another use of vectorize_width; is ``vectorize_width(fixed|scalable)`` where the user can hint at the type; of vectorization to use without specifying the exact width. In both variants; of the pragma the vectorizer may decide to fall back on fi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:163967,depend,depends,163967,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['depend'],['depends']
Integrability,"g/Tooling/Transformer/RangeSelector.h>`_. Stencils; ^^^^^^^^. Transformer offers a large and growing collection of combinators for; constructing output. Above, we demonstrated ``cat``, the core function for; constructing stencils. It takes a series of arguments, of three possible kinds:. #. Raw text, to be copied directly to the output.; #. Selector: specified with a ``RangeSelector``, indicates a range of source text; to copy to the output.; #. Builder: an operation that constructs a code snippet from its arguments. For; example, the ``access`` function we saw above. Data of these different types are all represented (generically) by a ``Stencil``.; ``cat`` takes text and ``RangeSelector``\ s directly as arguments, rather than; requiring that they be constructed with a builder; other builders are; constructed explicitly. In general, ``Stencil``\ s produce text from a match result. So, they are not; limited to generating source code, but can also be used to generate diagnostic; messages that reference (named) elements of the matched code, like we saw in the; example of rewriting method calls. Further details of the ``Stencil`` type are documented in the header file; `clang/Tooling/Transformer/Stencil.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/Stencil.h>`_. Edits; ^^^^^. Transformer supports additional forms of edits. First, in a ``changeTo``, we can; specify the particular portion of code to be replaced, using the same; ``RangeSelector`` we saw earlier. For example, we could change the function name; in a function declaration with:. .. code-block:: c++. makeRule(functionDecl(hasName(""bad"")).bind(f),; 	 changeTo(name(f), cat(""good"")),; 	 cat(""bad is now good""));. We also provide simpler editing primitives for insertion and deletion:; ``insertBefore``, ``insertAfter`` and ``remove``. These can all be found in the header; file; `clang/Tooling/Transformer/RewriteRule.h <https://github.com/llvm/llvm-project/blob/main/clang/inc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:12020,message,messages,12020,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['message'],['messages']
Integrability,"g; ``clang++`` simply. The users may want the scanner to get the transitional dependency information for headers.; Otherwise, the users have to scan twice for the project, once for headers and once for modules.; To address the requirement, clang-scan-deps will recognize the specified preprocessor options; in the given command line and generate the corresponding dependency information. For example,. .. code-block:: console. $ clang-scan-deps -format=p1689 -- ../bin/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o -MD -MT impl_part.ddi -MF impl_part.dep; $ cat impl_part.dep. We will get:. .. code-block:: text. impl_part.ddi: \; /usr/include/bits/wchar.h /usr/include/bits/types/wint_t.h \; /usr/include/bits/types/mbstate_t.h \; /usr/include/bits/types/__mbstate_t.h /usr/include/bits/types/__FILE.h \; /usr/include/bits/types/FILE.h /usr/include/bits/types/locale_t.h \; /usr/include/bits/types/__locale_t.h \; ... When clang-scan-deps detects ``-MF`` option, clang-scan-deps will try to write the; dependency information for headers to the file specified by ``-MF``. Possible Issues: Failed to find system headers; ----------------------------------------------. In case the users encounter errors like ``fatal error: 'stddef.h' file not found``,; probably the specified ``<path-to-compiler-executable>/clang++`` refers to a symlink; instead a real binary. There are 4 potential solutions to the problem:. * (1) End users can resolve the issue by pointing the specified compiler executable to; the real binary instead of the symlink.; * (2) End users can invoke ``<path-to-compiler-executable>/clang++ -print-resource-dir``; to get the corresponding resource directory for your compiler and add that directory; to the include search paths manually in the build scripts.; * (3) Build systems that use a compilation database as the input for clang-scan-deps; scanner, the build system can add the flag ``--resource-dir-recipe invoke-compiler`` to; the clang-scan-deps scanner to calculate the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:37946,depend,dependency,37946,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['depend'],['dependency']
Integrability,"gRef, ..., StringRef; Matches when at least one of the supplied string equals to the; Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""methodA:"", ""methodB:""));; matches both of the expressions below:; [myObj methodA:argA];; [myObj methodB:argB];. Matcher<ObjCMessageExpr>hasKeywordSelector; Matches when the selector is a keyword selector. objCMessageExpr(hasKeywordSelector()) matches the generated setFrame; message expression in. UIWebView *webView = ...;; CGRect bodyFrame = webView.frame;; bodyFrame.size.height = self.bodyContentHeight;; webView.frame = bodyFrame;; // ^---- matches here. Matcher<ObjCMessageExpr>hasNullSelector; Matches when the selector is the empty selector. Matches only when the selector of the objCMessageExpr is NULL. This may; represent an error condition in the tree!. Matcher<ObjCMessageExpr>hasSelectorstd::string BaseName; Matches when BaseName == Selector.getAsString(). matcher = objCMessageExpr(hasSelector(""loadHTMLString:baseURL:""));; matches the outer message expr in the code below, but NOT the message; invocation for self.bodyView.; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>hasUnarySelector; Matches when the selector is a Unary Selector. matcher = objCMessageExpr(matchesSelector(hasUnarySelector());; matches self.bodyView in the code below, but NOT the outer message; invocation of ""loadHTMLString:baseURL:"".; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMessageExpr>isClassMessage; Returns true when the Objective-C message is sent to a class. Example; matcher = objcMessageExpr(isClassMessage()); matches; [NSString stringWithFormat:@""format""];; but not; NSString *x = @""hello"";; [x containsString:@""h""];. Matcher<ObjCMessageExpr>isInstanceMessage; Returns true when the Objective-C message is sent to an instance. Example; matcher = objcMessageExpr(isInstanceMessage()); matches; NSString *x = @""hello"";; [x containsString:@""h""];; but not; [NSString stringWithFormat:@""format""];. Matc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:106782,message,message,106782,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['message'],['message']
Integrability,"gSerialization; clangTooling; ). With that done, Ninja will be able to compile our tool. Let's give it; something to compile! Put the following into; ``clang-tools-extra/loop-convert/LoopConvert.cpp``. A detailed explanation of; why the different parts are needed can be found in the `LibTooling; documentation <LibTooling.html>`_. .. code-block:: c++. // Declares clang::SyntaxOnlyAction.; #include ""clang/Frontend/FrontendActions.h""; #include ""clang/Tooling/CommonOptionsParser.h""; #include ""clang/Tooling/Tooling.h""; // Declares llvm::cl::extrahelp.; #include ""llvm/Support/CommandLine.h"". using namespace clang::tooling;; using namespace llvm;. // Apply a custom category to all command-line options so that they are the; // only ones displayed.; static llvm::cl::OptionCategory MyToolCategory(""my-tool options"");. // CommonOptionsParser declares HelpMessage with a description of the common; // command-line options related to the compilation database and input files.; // It's nice to have this help message in all tools.; static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);. // A help message for this specific tool can be added afterwards.; static cl::extrahelp MoreHelp(""\nMore help text...\n"");. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. And that's it! You can compile our new tool by running ninja from the; ``build`` directory. .. code-block:: console. cd ~/clang-llvm/build; ninja. You should now be able to run the syntax checker, which is located in; ``~/clang-llvm/build/bin``, on any source file. Try it!. .. code-block:: console. echo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:4337,message,message,4337,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['message'],['message']
Integrability,"geName, double* clippedValPtr)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#afc2a8818f433a9a4ec0c437cbdad4e8a): `epsRel = 0, epsAbs = 1e-6`; * [RooAbsRealLValue::inRange(std::span<const double> values, std::string const& rangeName, std::vector<bool>& out)](https://root.cern.ch/doc/v626/classRooAbsRealLValue.html#af9217abd0afe34364562ad0c194f5d2c): `epsRel = 0, epsAbs = 1e-6`. With this release, the default absolute and relative epsilon is zero to avoid confusion.; You can change them with `RooNumber::setRangeEpsRel(epsRel)` and `RooNumber::setRangeEpsAbs(epsAbs)`. ## TMVA. ### SOFIE : Code generation for fast inference of Deep Learning models. A large number of new features have been added in the TMVA SOFIE library. The list of all operators supported in the `RModel` class is the one provided below for the ONNX parser. The interface of `RModel::Generate` has been changed to; ```; RModel::Generate(Options options = Options::kDefault, int batchsize = 1)`; ```; where `Options` is a new enumeration having 3 different values:; - `kDefault = 0x0` : default case, a session class is generated and the weights are stored in a separate `.dat` file (in text format).; - `kNoSession = 0x1` : no session class is generated and the internal intermediate tensors are declared in the global namespace `TMVA_SOFIE_$ModelName`.; - `kNoWeightFile = 0x2` the weight values are not written in a separate `.dat` file, but they are included in the generated header file. In addition, the `RModel::Generate` function takes as an additional optional argument the batch size (default is = 1) and the inference code can then be generated for the desired batch size. #### SOFIE ONNX Parser. The ONNX parser supports now several new ONNX operators. The list of the current supported ONNX operator is the following:; - Gemm; - Conv (in 1D,2D and 3D); - RNN, GRU, LSTM; - Relu, Selu, Sigmoid, Softmax, Tanh, LeakyRelu; - BatchNormalization; - MaxPool, AveragePool, GlobalAverage; - ConvTranspose; - Gat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:26508,interface,interface,26508,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['interface'],['interface']
Integrability,"geName: ""sub1_.t0p"", scope: !4, file: !4, type: !5, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !7, retainedNodes: !24, targetFuncName: ""sub1_""). The targetFuncName field is the name of the function that the trampoline; calls. This descriptor results in the following DWARF tag:. .. code-block:: text. DW_TAG_subprogram; ...; DW_AT_linkage_name	(""sub1_.t0p""); DW_AT_name	(""sub1_.t0p""); DW_AT_trampoline	(""sub1_""). Debugging information format; ============================. Debugging Information Extension for Objective C Properties; ----------------------------------------------------------. Introduction; ^^^^^^^^^^^^. Objective C provides a simpler way to declare and define accessor methods using; declared properties. The language provides features to declare a property and; to let compiler synthesize accessor methods. The debugger lets developer inspect Objective C interfaces and their instance; variables and class variables. However, the debugger does not know anything; about the properties defined in Objective C interfaces. The debugger consumes; information generated by compiler in DWARF format. The format does not support; encoding of Objective C properties. This proposal describes DWARF extensions to; encode Objective C properties, which the debugger can use to let developers; inspect Objective C properties. Proposal; ^^^^^^^^. Objective C properties exist separately from class members. A property can be; defined only by ""setter"" and ""getter"" selectors, and be calculated anew on each; access. Or a property can just be a direct access to some declared ivar.; Finally it can have an ivar ""automatically synthesized"" for it by the compiler,; in which case the property can be referred to in user code directly using the; standard C dereference syntax as well as through the property ""dot"" syntax, but; there is no entry in the ``@interface`` declaration corresponding to this ivar. To facilitate debugging, these properties we will add a new DWARF TAG into the; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:49658,interface,interfaces,49658,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['interface'],['interfaces']
Integrability,"ged from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of properties related to tracking); - *Matrices.* Allows creation of translations, rotations or combined; transformations. Existing matrices can also be browser/edited. ### Editing Existing Objects. For editing an existing object from one of the categories described; above, the interface imposes first a selection among all objects of the; corresponding type stored in the geometry. This can be done by clicking; the button next to the blue label *Select \<object\>*. The dialog; interfaces are generally different for different types of objects. The; volume selection dialog offers the possibility to select either a volume; already connected to the geometry hierarchy or non-connected ones.; Selection for shapes and matrices is split into categories represented; by top-level list tree items for: boxes, tubes, translations, rotations,; etc. ![Selection dialogs for different TGeo objects](pictures/030001EF.png). Once a selection is made and the dialog is closed, the selected item; name will appear in the corresponding label and the button Edit will; start the object editor in a transient frame. Closing these transient; frames will not delete, but just hide existing opened editors for later; reuse. Their lifetime is determined by the canvas to which the manager; editor is attached to, since these will be destroyed together. ![Editors for shapes, materials, media, matrices](pictures/020001F0.jpg); ![Editors for shapes, materials, media, matrices](pictures/020001F1.jpg); ![Editors for shapes, m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:169245,interface,interfaces,169245,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interfaces']
Integrability,"ger 4 bytes. - **`UInt_t `**Unsigned integer 4 bytes. - **`Long64_t`** Portable signed long integer 8 bytes. - **`ULong64_t`** Portable unsigned long integer 8 bytes. - **`Float_t`** Float 4 bytes. - **`Double_t`** Float 8 bytes. - **`Double32_t`** Double 8 bytes in memory, written as a Float 4; bytes. - **`Bool_t`** Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use `int` or; `Int_t`, the result will be the same and the interpreter or the; compiler will treat them in exactly the same way. ### TObject. In ROOT, almost all classes inherit from a common base class called; **`TObject`**. This kind of architecture is also used in the Java; language. The **`TObject`** class provides default behavior and; protocol for all objects in the ROOT system. The main advantage of; this approach is that it enforces the common behavior of the derived; classes and consequently it ensures the consistency of the whole; system. See ""The Role of TObject"". **`TObject`** provides protocol, i.e. (abstract) member functions,; for:. - Object I/O (`Read()`, `Write())`. - Error handling (`Warning()`, `Error()`, `SysError()`, `Fatal())`. - Sorting (`IsSortable()`, `Compare()`, `IsEqual()`, `Hash())`. - Inspection (`Dump()`, `Inspect()`). - Printing (`Print())`. - Drawing (`Draw()`, `Paint()`, `ExecuteEvent())`. - Bit handling (`SetBit()`, `TestBit()`). - Memory allocation (operator` new and delete`, `IsOnHeap())`. - Access to meta information (`IsA()`, `InheritsFrom())`. - Object browsing (`Browse()`, `IsFolder())`. ## Global Variables. ROOT has a set of global variables that apply to the session. For; example,; ***`gDirectory`*** always holds the current directory, and; ***`gStyle`*** holds the current style. All global variables begin with ""*g*"" followed by a capital letter. ### gROOT. The single instance of **`TROOT`** is accessible via the global; ***`gROOT`*** and holds information relative to the current session.; By using the ***`gROOT`*** pointer, you g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:31604,protocol,protocol,31604,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['protocol'],['protocol']
Integrability,"gh)``, 201910, 1; ``__has_cpp_attribute(warn_unused_result)``, 201907, 0; ``__has_cpp_attribute(clang::warn_unused_result)``, 201907, 1; ``__has_cpp_attribute(gnu::warn_unused_result)``, 201907, 1; ``__has_c_attribute(warn_unused_result)``, 202003, 0; ``__has_c_attribute(gnu::warn_unused_result)``, 202003, 1. - Fixed a bug in finding matching `operator!=` while adding reversed `operator==` as; outlined in ""The Equality Operator You Are Looking For"" (`P2468 <http://wg21.link/p2468r2>`_).; Fixes (`#68901 <https://github.com/llvm/llvm-project/issues/68901>`_). C++ Specific Potentially Breaking Changes; -----------------------------------------; - The name mangling rules for function templates has been changed to take into; account the possibility that functions could be overloaded on their template; parameter lists or requires-clauses. This causes mangled names to change for; function templates in the following cases:. - When a template parameter in a function template depends on a previous; template parameter, such as ``template<typename T, T V> void f()``.; - When the function has any constraints, whether from constrained template; parameters or requires-clauses.; - When the template parameter list includes a deduced type -- either; ``auto``, ``decltype(auto)``, or a deduced class template specialization; type.; - When a template template parameter is given a template template argument; that has a different template parameter list. This fixes a number of issues where valid programs would be rejected due to; mangling collisions, or would in some cases be silently miscompiled. Clang; will use the old manglings if ``-fclang-abi-compat=17`` or lower is; specified.; (`#48216 <https://github.com/llvm/llvm-project/issues/48216>`_),; (`#49884 <https://github.com/llvm/llvm-project/issues/49884>`_), and; (`#61273 <https://github.com/llvm/llvm-project/issues/61273>`_). - The `ClassScopeFunctionSpecializationDecl` AST node has been removed.; Dependent class scope explicit functi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:4459,depend,depends,4459,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['depend'],['depends']
Integrability,"gisters and register classes info. .. option:: -register-info-debug. Make -gen-register-info dump register information for debugging. .. option:: -gen-searchable-tables. Generate generic searchable tables. See :doc:`TableGen BackEnds <../TableGen/BackEnds>`; for a detailed description. .. option:: -gen-subtarget. Generate subtarget enumerations. .. option:: -gen-x86-EVEX2VEX-tables. Generate X86 EVEX to VEX compress tables. .. option:: -gen-x86-fold-tables. Generate X86 fold tables. .. option:: -long-string-literals. When emitting large string tables, prefer string literals over; comma-separated char literals. This can be a readability and; compile-time performance win, but upsets some compilers. .. option:: -print-enums. Print enumeration values for a class. .. option:: -class=classname. Make -print-enums print the enumeration list for the specified class. .. option:: -print-sets. Print expanded sets for testing DAG exprs. mlir-tblgen Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -gen-avail-interface-decls. Generate availability interface declarations. .. option:: -gen-avail-interface-defs. Generate op interface definitions. .. option:: -gen-dialect-doc. Generate dialect documentation. .. option:: -dialect. The dialect to generate. .. option:: -gen-directive-decl. Generate declarations for directives (OpenMP, etc.). .. option:: -gen-enum-decls. Generate enum utility declarations. .. option:: -gen-enum-defs. Generate enum utility definitions. .. option:: -gen-enum-from-llvmir-conversions. Generate conversions of EnumAttrs from LLVM IR. .. option:: -gen-enum-to-llvmir-conversions. Generate conversions of EnumAttrs to LLVM IR. .. option:: -gen-llvmir-conversions. Generate LLVM IR conversions. .. option:: -gen-llvmir-intrinsics. Generate LLVM IR intrinsics. .. option:: -llvmir-intrinsics-filter. Only keep the intrinsics with the specified substring in their record name. .. option:: -dialect-opclass-base. The base class for the ops in the dialect we are to emit. .. option:: ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst:12897,interface,interface-decls,12897,interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,1,['interface'],['interface-decls']
Integrability,"given in the printout of the errors, then at; least M believes the errors are accurate, although there is always a; small chance that M has been fooled. Some visible signs that M may have; been fooled are:. - Warning messages produced during the minimization or error analysis. - Failure to find new minimum. - Value of $\mbox{EDM}$ too big. For a ""normal"" minimization,; after $\mbox{MIGRAD}$, the value of $\mbox{EDM}$ is usually; more than three orders of magnitude smaller than $\mbox{up}$,; unless a looser tolerance has been specified. - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).\; This indicates both an exceptionally difficult problem, and one; which has been badly parametrized so that individual errors are not; very meaningful because they are so highly correlated. - Parameter at limit. This condition, signalled by a M warning; message, may make both the function minimum and parameter errors; unreliable. See section [answer:right-errors], *Getting the right; parameter errors with limits*. The best way to be absolutely sure of the errors, is to use; ""independent"" calculations and compare them, or compare the calculated; errors with a picture of the function if possible. For example, if there; is only one free parameter, $\mbox{SCAN}$ allows the user to verify; approximately the function curvature. Similarly, if there are only two; free parameters, use $\mbox{CONTOURS}$. To verify a full error; matrix, compare the results of $\mbox{MIGRAD}$ with those; (calculated afterward) by $\mbox{HESSE}$, which uses a different; method. And of course the most reliable and most expensive technique,; which must be used if asymmetric errors are required, is; $\mbox{MINOS}$. ## Convergence in $\mbox{MIGRAD}$, and positive–definiteness ##. $\mbox{MIGRAD}$ uses its current estimate of the covariance matrix; of the function to determine the curre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:70128,message,message,70128,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['message'],['message']
Integrability,"gle; conversion function to an integral or Objective-C pointer type, in which; case that conversion is applied and analysis continues as appropriate.; Otherwise, the expression is ill-formed. An Objective-C object subscript expression is always an l-value. If the; expression appears on the left-hand side of a simple assignment operator; (=), the element is written as described below. If the expression; appears on the left-hand side of a compound assignment operator (e.g.; +=), the program is ill-formed, because the result of reading an element; is always an Objective-C object pointer and no binary operators are; legal on such pointers. If the expression appears in any other position,; the element is read as described below. It is an error to take the; address of a subscript expression, or (in C++) to bind a reference to; it. Programs can use object subscripting with Objective-C object pointers of; type ``id``. Normal dynamic message send rules apply; the compiler must; see *some* declaration of the subscripting methods, and will pick the; declaration seen first. Caveats; =======. Objects created using the literal or boxed expression syntax are not; guaranteed to be uniqued by the runtime, but nor are they guaranteed to; be newly-allocated. As such, the result of performing direct comparisons; against the location of an object literal (using ``==``, ``!=``, ``<``,; ``<=``, ``>``, or ``>=``) is not well-defined. This is usually a simple; mistake in code that intended to call the ``isEqual:`` method (or the; ``compare:`` method). This caveat applies to compile-time string literals as well.; Historically, string literals (using the ``@""...""`` syntax) have been; uniqued across translation units during linking. This is an; implementation detail of the compiler and should not be relied upon. If; you are using such code, please use global string constants instead; (``NSString * const MyConst = @""...""``) or use ``isEqual:``. Grammar Additions; =================. To support th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:16922,message,message,16922,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['message'],['message']
Integrability,"global offset for the Y; dimension is passed in the; kernarg. ""HiddenGlobalOffsetZ""; The OpenCL grid dispatch; global offset for the Z; dimension is passed in the; kernarg. ""HiddenNone""; An argument that is not used; by the kernel. Space needs to; be left for it, but it does; not need to be set up. ""HiddenPrintfBuffer""; A global address space pointer; to the runtime printf buffer; is passed in kernarg. Mutually; exclusive with; ""HiddenHostcallBuffer"". ""HiddenHostcallBuffer""; A global address space pointer; to the runtime hostcall buffer; is passed in kernarg. Mutually; exclusive with; ""HiddenPrintfBuffer"". ""HiddenDefaultQueue""; A global address space pointer; to the OpenCL device enqueue; queue that should be used by; the kernel by default is; passed in the kernarg. ""HiddenCompletionAction""; A global address space pointer; to help link enqueued kernels into; the ancestor tree for determining; when the parent kernel has finished. ""HiddenMultiGridSyncArg""; A global address space pointer for; multi-grid synchronization is; passed in the kernarg. ""ValueType"" string Unused and deprecated. This should no longer; be emitted, but is accepted for compatibility. ""PointeeAlign"" integer Alignment in bytes of pointee; type for pointer type kernel; argument. Must be a power; of 2. Only present if; ""ValueKind"" is; ""DynamicSharedPointer"".; ""AddrSpaceQual"" string Kernel argument address space; qualifier. Only present if; ""ValueKind"" is ""GlobalBuffer"" or; ""DynamicSharedPointer"". Values; are:. - ""Private""; - ""Global""; - ""Constant""; - ""Local""; - ""Generic""; - ""Region"". .. TODO::. Is GlobalBuffer only Global; or Constant? Is; DynamicSharedPointer always; Local? Can HCC allow Generic?; How can Private or Region; ever happen?. ""AccQual"" string Kernel argument access; qualifier. Only present if; ""ValueKind"" is ""Image"" or; ""Pipe"". Values; are:. - ""ReadOnly""; - ""WriteOnly""; - ""ReadWrite"". .. TODO::. Does this apply to; GlobalBuffer?. ""ActualAccQual"" string The actual memory accesses; performe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:125392,synchroniz,synchronization,125392,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronization']
Integrability,"gnatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockBegin>`; A regular expression matching macros that start a block. .. code-block:: c++. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:84075,message,messages,84075,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['message'],['messages']
Integrability,"gner_9j(int ja, int jb, int jc, int jd, int je, int jf, int jg, int jh, int ji);; . New statistical function: non-central chisquare probability; density function; ; double noncentral_chisquared_pdf(double x, double r, double lambda);; ; It is implemented using Bessel functions or hypergeometric function; ; New classes VavilovAccurate and VavilovFast,; derived from the abstract base class Vavilov,; provide pdf, cdf and quantile functions for the Vavilov distribution,; based on the algorithms of CERNLIB (G116 and G115, respectively).; The classes VavilovAccuratePdf,; VavilovAccurateCdf and VavilovAccurateQuantile; implement the IParametricFunctionOneDim interface; for easier use in fit problems. . Unuran. Use new version 1.7.2 ; Add new class TUnuranSampler implementing the; ROOT::Math::DistSampler interface for one dimensional; continuous and discrete distributions and for mult-dimensional ones; . Foam. Add new class TFoamSampler implementing the; ROOT::Math::DistSampler interface for generating random; numbers according to any one or multi-dim distributions using Foam.; ; All the TFoam options can be controlled via the; ROOT::Math::DistSamplerOptions class, which can be passed; as input to the virtual ROOT::Math::DistSampler::Init(..); function.; . GenVector. Add some missing copy constructor and assignment operators to; fix compilation issue observed with LLVM (Clang). Minuit. Fix a bug when using at the same time TMinuit or TFitter with; the new TMinuitMinimizer class. See bug 72909.; . Minuit2. Fix the returned error from the Minimizer class for fixed and; constant parameters. Now is set explicitly to zero.; ; Fix a problem in re-defining fixed parameters as variable; ones. Before it was not possible to release them.; ; Fix a problem in the number of function calls when running MnHesse; after minimizing. Now the number is incremented instead of being; reset.; . Genetic. Add a new Minimizer implementation based on the genetic; algorithm used in TMVA (plugin name """,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html:9260,interface,interface,9260,math/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v528/index.html,1,['interface'],['interface']
Integrability,"gnostic required”; Unknown. 1463; drafting; extern ""C"" alias templates; Not resolved. 1464; CD3; Negative array bound in a new-expression; Unknown. 1465; CD4; noexcept and std::bad_array_new_length; Unknown. 1466; C++14; Visible sequences of side effects are redundant; Unknown. 1467; CD4; List-initialization of aggregate from same-type object; Clang 3.7 (C++11 onwards). 1468; CD5; typeid, overload resolution, and implicit lambda capture; Unknown. 1469; CD5; Omitted bound in array new-expression; Unknown. 1470; NAD; Thread migration; Unknown. 1471; CD3; Nested type of non-dependent base; Unknown. 1472; CD3; odr-use of reference variables; Unknown. 1473; CD3; Syntax of literal-operator-id; Unknown. 1474; NAD; User-defined literals and <inttypes.h> format macros; Unknown. 1475; CD3; Errors in [[carries_dependency]] example; Unknown. 1476; CD3; Definition of user-defined type; Unknown. 1477; CD3; Definition of a friend outside its namespace; Unknown. 1478; CD6; template keyword for dependent template template arguments; Unknown. 1479; CD3; Literal operators and default arguments; Clang 3.1. 1480; CD3; Constant initialization via non-constant temporary; Unknown. 1481; CD3; Increment/decrement operators with reference parameters; Unknown. 1482; CD3; Point of declaration of enumeration; Clang 3.0. 1483; NAD; Non-dependent static_assert-declarations; Unknown. 1484; CD4; Unused local classes of function templates; Unknown. 1485; drafting; Out-of-class definition of member unscoped opaque enumeration; Not resolved. 1486; drafting; Base-derived conversion in member pointer deduction; Not resolved. 1487; CD3; When are inheriting constructors declared?; Unknown. 1488; drafting; abstract-pack-declarators in type-ids; Not resolved. 1489; CD3; Is value-initialization of an array constant initialization?; Unknown. 1490; CD4; List-initialization from a string literal; Clang 3.7 (C++11 onwards). 1491; CD3; Move construction and rvalue reference members; Unknown. 1492; CD4; Exception s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:99270,depend,dependent,99270,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['depend'],['dependent']
Integrability,"go too overboard on this recommendation, however. You; **must** include all of the header files that you are using --- you can include; them either directly or indirectly through another header file. To make sure; that you don't accidentally forget to include a header file in your module; header, make sure to include your module header **first** in the implementation; file (as mentioned above). This way there won't be any hidden dependencies that; you'll find out about later. Keep ""Internal"" Headers Private; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Many modules have a complex implementation that causes them to use more than one; implementation (``.cpp``) file. It is often tempting to put the internal; communication interface (helper classes, extra functions, etc) in the public; module header file. Don't do this!. If you really need to do something like this, put a private header file in the; same directory as the source files, and include it locally. This ensures that; your private interface remains private and undisturbed by outsiders. .. note::. It's okay to put extra implementation methods in a public class itself. Just; make them private (or protected) and all is well. Use Namespace Qualifiers to Implement Previously Declared Functions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When providing an out of line implementation of a function in a source file, do; not open namespace blocks in the source file. Instead, use namespace qualifiers; to help ensure that your definition matches an existing declaration. Do this:. .. code-block:: c++. // Foo.h; namespace llvm {; int foo(const char *s);; }. // Foo.cpp; #include ""Foo.h""; using namespace llvm;; int llvm::foo(const char *s) {; // ...; }. Doing this helps to avoid bugs where the definition does not match the; declaration from the header. For example, the following C++ code defines a new; overload of ``llvm::foo`` instead of providing a definition for the existing; function declared in the header:. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:33554,interface,interface,33554,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['interface'],['interface']
Integrability,"gonal pivoting method decomposes a real symmetric matrix `A`.; - TDecompChol: The Cholesky decomposition class, which decomposes a symmetric, positive definite matrix `A = U^T * U` where `U` is a upper triangular matrix.; - TDecompQRH: QR decomposition class.; - TDecompSVD: Single value decomposition class.; - TDecompSparse: Sparse symmetric decomposition class. ### Matrix Eigen analysis. With the `TMatrixDEigen` and `TMatrixDSymEigen` classes, you can compute eigenvalues and; eigenvectors for general dense and symmetric real matrices. ## Additional Notes. The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in %ROOT, they of course; can be stored in a %ROOT database. ### How to efficiently use this package. #### 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:. ~~~ {.cpp}; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; ~~~. runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. #### 2. Use ""two-address instructions"". ~~~ {.cpp};",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md:14698,integrat,integrated,14698,math/matrix/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md,1,['integrat'],['integrated']
Integrability,"gram to adjust; the scale of the function. In case of extended p.d.f.s, the adjustment is made with the expected; number of events, rather than the observed number of events. Tutorial macro rf602_chi2fit.C has been updated to use this new interface. Chi-squared fits to X-Y datasets now possible; In addition to the ability to perform chi-squared fits to histograms it is now also possible; to perform chi-squared fits to unbinned datasets containing a series of X and Y values; with associated errors on Y and optionally on X. These 'X-Y' chi-squared fits are interfaced through newly added method; RooAbsReal::chi2FitTo(const RooDataSet&,...). By default the event weight is; interpreted as the 'Y' value, but an YVar() argument can designate any other; dataset column as Y value. If X errors are defined, one can choose to integrate the fitted; function over the range of the X errors, rather than taking the central value by adding; an Integrate(true) argument to chi2FitTo(); Two new arguments, StoreError(const RooArgSet&) and StoreAsymError(const RooArgSet&); have been added to the RooDataSet constructor to simplify the process of storing the errors; of X and Y variables along with their values in a dataset. The newly added tutorial macro rf609_xychi2fit.C illustrates the use of all this; new functionality. Uniform interface for creation of (profile likelihoods) and chi-squared from p.d.f.s; It is now recommended to use the method RooAbsPdf::createNLL(RooAbsData&,...) to; create a likelihood from a p.d.f and a dataset rather than constructing a RooNLLVar; object directly. This is because part of the likelihood construction functionality such a using; multiple Range()s, or the inclusion for constraint terms are only available through; createNLL(). To promote the consistency of this interface, a similar method RooAbsReal::createChi2(); has been added to construct chi-squared functions of a dataset and a function or p.d.f. Along the same lines, it is recommended to use RooAbsRe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:8729,integrat,integrate,8729,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['integrat'],['integrate']
Integrability,"grator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; ```. The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:56438,integrat,integration,56438,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integration']
Integrability,"gs: [--target=thumbv7m-none-eabi]. Design principles; =================. Stable interface; ----------------. ``multilib.yaml`` and ``-print-multi-flags-experimental`` are new; interfaces to Clang. In order for them to be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possib",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:10186,interface,interface,10186,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['interface'],['interface']
Integrability,"gumentWithParam(; declRefExpr(to(varDecl(hasName(""y"")))),; parmVarDecl(hasType(isInteger())); )); matches f(y);; with declRefExpr(...); matching int y; and parmVarDecl(...); matching int i. Matcher<CXXConstructExpr>forEachArgumentWithParamTypeMatcher<Expr> ArgMatcher, Matcher<QualType> ParamMatcher; Matches all arguments and their respective types for a CallExpr or; CXXConstructExpr. It is very similar to forEachArgumentWithParam but; it works on calls through function pointers as well. The difference is, that function pointers do not provide access to a; ParmVarDecl, but only the QualType for each argument. Given; void f(int i);; int y;; f(y);; void (*f_ptr)(int) = f;; f_ptr(y);; callExpr(; forEachArgumentWithParamType(; declRefExpr(to(varDecl(hasName(""y"")))),; qualType(isInteger()).bind(""type); )); matches f(y) and f_ptr(y); with declRefExpr(...); matching int y; and qualType(...); matching int. Matcher<CXXConstructExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<CXXConstructExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<CXXConstructExpr>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:148420,message,message-send,148420,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['message'],['message-send']
Integrability,"h 8.5.2 of the book,; *F. James, Statistical Methods in Experimental Physics, 2nd Edition*. ### Fit Statistics. You can change the statistics box to display the fit parameters with the; `TStyle::SetOptFit(mode)` method. This parameter has four digits:; `mode = pcev` (`default = 0111`). - `p` = 1 print probability; - `c` = 1 print Chi-square/number of degrees of freedom; - `e` = 1 print errors (if `e=1`, `v` must be 1); - `v` = 1 print name/values of parameters. For example, to print the fit probability, parameter names/values, and; errors, use:. ``` {.cpp}; gStyle->SetOptFit(1011);; ```. ## The Fit Panel. ![The Fit Panel](pictures/03000061.png). To display the Fit Panel right click on a histogram to pop up the; context menu, and then select the menu entry Fit Panel. The new Fit Panel GUI is available in ROOT v5.14. Its goal is to; replace the old Fit Panel and to provide more user friendly way for; performing, exploring and comparing fits. By design, this user interface is planned to contain two tabs:; ""General"" and ""Minimization"". Currently, the ""General"" tab provides; user interface elements for setting the fit function, fit method and; different fit, draw, print options.; The ""Minimization tab"" provides the option to set the Minimizer to use in the fit and; its specific options. The new fit panel is a modeless dialog, i.e. when opened, it does not; prevent users from interacting with other windows. Its first prototype; is a singleton application. When the Fit Panel is activated, users can; select an object for fitting in the usual way, i.e. by left-mouse; click on it. If the selected object is suitable for fitting, the fit; panel is connected with this object and users can perform fits by; setting different parameters and options. ### Function Choice and Settings. *‘Predefined' combo box* - contains a list of predefined functions in; ROOT. You have a choice of several polynomials, a Gaussian, a Landau,; and an Exponential function. The default one is Gaussian. *‘",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:20341,interface,interface,20341,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['interface'],['interface']
Integrability,"h a DataError(RooAbsData::Poisson) argument these; approximate Poisson error bars are shown. Miscellaneous improvements other. The RooFit messagee service class RooMsgService has been augmented with a stack that; can store its configurate state information. A call to saveState() will save the; present configuration, which can be restored through a subsequent call to restoreState().; In addition to the method RooAbsArg::printCompactTree() which is mostly intende for; debugging, a new method RooAbsArg::printComponentTree() has been added that prints; the tree structure of a pdf in a more user-friendly content oriented way. The printing ; of the leaf nodes (the variables) is omitted in this method to keep the output compact. RooStats. This release contains significant bug fixes and it is strongly; recommended to update to this version if using older ones. . Major Changes in LimitCalculator and HypoTestCalculator classes: usage of ModelConfig class. The RooStats calculator interfaces have been changed to use the ModelConfig class.; All the setter methods with the parameter lists, pdf instances and name have been removed from the interfaces.; The SetWorkspace(RooWorkspace & ) has also been removed, while a SetModel(const ModelConfig &); function is introduced. Users are supposed to pass all the model information using the; ModelConfig class rather than via the; RooWorkspace or specifying directly the pdf and parameter; objects in the constructors. ; Setter methods using pdf instances and parameter lists are maintained in the derived classes, like the ProfileLikelihoodCalculator or the HybridCalculator, but those passing a string for the name of the pdf have been removed. ; All the calculator classes do not keep anymore a pointer to the workspace, but they contain pointers to the pdf, the data and the parameters required to run the calculator. These pointers are managed outside by the users or by the RooWorkspace. They can be passed either directly to the classes, for exam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:11534,interface,interfaces,11534,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,1,['interface'],['interfaces']
Integrability,"h a hash (``#``) is a comment.; * A non-comment line is a single pattern.; * The slash (``/``) is used as the directory separator.; * A pattern is relative to the directory of the ``.clang-format-ignore`` file; (or the root directory if the pattern starts with a slash). Patterns; containing drive names (e.g. ``C:``) are not supported.; * Patterns follow the rules specified in `POSIX 2.13.1, 2.13.2, and Rule 1 of; 2.13.3 <https://pubs.opengroup.org/onlinepubs/9699919799/utilities/; V3_chap02.html#tag_18_13>`_.; * A pattern is negated if it starts with a bang (``!``). To match all files in a directory, use e.g. ``foo/bar/*``. To match all files in; the directory of the ``.clang-format-ignore`` file, use ``*``.; Multiple ``.clang-format-ignore`` files are supported similar to the; ``.clang-format`` files, with a lower directory level file voiding the higher; level ones. Vim Integration; ===============. There is an integration for :program:`vim` which lets you run the; :program:`clang-format` standalone tool on your current buffer, optionally; selecting regions to reformat. The integration has the form of a `python`-file; which can be found under `clang/tools/clang-format/clang-format.py`. This can be integrated by adding the following to your `.vimrc`:. .. code-block:: vim. if has('python'); map <C-K> :pyf <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; elseif has('python3'); map <C-K> :py3f <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; endif. The first line enables :program:`clang-format` for NORMAL and VISUAL mode, the; second line adds support for INSERT mode. Change ""C-K"" to another binding if; you need :program:`clang-format` on a different key (C-K stands for Ctrl+k). With this integration you can press the bound key and clang-format will; format the current line in NORMAL and INSERT mode or the selected region in; VISUAL mode. The line or region is e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:6360,integrat,integration,6360,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['integrat'],['integration']
Integrability,"h allow for representing large collections.; RNTuple can still use 32bit offset columns, e.g.; ```; RNTupleWriteOptions options;; options.SetHasSmallClusters(true);; auto writer = RNTupleWriter::Recreate(std::move(model), ""myNTuple"", ""out.ntuple"");; ```. - Support for projected fields, i.e. exposing other fields' data as a different (compatible) C++ type.; Users should provide a mapping function that maps each projected subfield in the tree to theunderlying real field, e.g.; ```; auto model = RNTupleModel::Create();; auto fvec = model->MakeField<std::vector<float>>(""vec"");. auto aliasVec = RFieldBase::Create(""aliasVec"", ""std::vector<float>"").Unwrap();; model->AddProjectedField(std::move(aliasVec), [](const std::string &fieldName) {; if (fieldName == ""aliasVec"") return ""vec"";; else return ""vec._0"";; });; ```; Projected fields are stored as part of the metadata. - Improvements on the internal `RField` value API. The `RFieldValue` class has been deprecated in favor of `RField::Value` and the related interfaces have changed accordingly (see [#13219](https://github.com/root-project/root/pull/13219) and [#13264](https://github.com/root-project/root/pull/13264)).; If you were not using `RField::(Read|Append)` directly, this change should not impact you. - The new `RNTupleImporter` class provides automatic conversion of TTree to RNTuple.; Note that not all of the C++ types supported in TTree are currently supported in RNTuple. - Many bug fixes and performance improvements. Please, report any issues regarding the abovementioned features should you encounter them.; RNTuple is still experimental and is scheduled to become production grade by end of 2024.; Thus, we appreciate feedback and suggestions for improvement. ## Histogram Libraries. ## Math Libraries. ### Minuit2 is now the default minimizer. Many ROOT-based frameworks and users employ Minuit2 as the minimizer of choice for a long time already.; Therefore, Minuit2 is now the default minimizer used by ROOT.; This affects",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:9244,interface,interfaces,9244,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['interface'],['interfaces']
Integrability,"h as TH1::Fit.; ; The fit data are decoupled from the fitter class and described by the dedicated fit data classes like the ROOT::Fit::BinData for bin data containing coordinate values of any dimensions, bin content values and optionally errors in coordinate and bin content, and ROOT::Fit::UnBinData classes for any dimension un-bin data.; The fitter class, ROOT::Fit::Fitter, provides the functionality for fitting those data with any model function implementing the parametric function interface, ROOT::Math::IParamMultiFunction. Fit methods such as least square, bin and un-bin likelihood are supported. The fit solution is then found by using the ROOT::Math::Minimizer interface class and the results are stored in the ROOT::Fit::FitResult class. Fit parameter can be configured individually using the ROOT::Fit::FitParameterSettings class.; ; Various implementation of the minimizer interface can be used automatically using the ROOT plug-in manager mechanism, including the linear fitter for a fast and direct solution, in case of a linear least square model, or by using Minuit, Minuit2 or GSL minimization methods provided by the MathMore library. Functions for filling the new ROOT::Fit::BinData classes with all the histogram and graph types have been added in the histogram library (libHist) and graph library:; ; ROOT::Fit::FillData( BinData & , const TH1 *, TF1 * ) for histograms (in libHist); ROOT::Fit::FillData( BinData & , const TGraph2D *, TF1 * ) for 2D graphs (in libHist); ROOT::Fit::FillData( BinData & , const TGraph *, TF1 * ) for all 1D graphs (in libGraf); ROOT::Fit::FillData( BinData & , const TMultiGraph *, TF1 * ) for multi-graphs (in libGraf); . MathCore Numerical Algorithms. Classes implementing numerical methods which can be used by all the other ROOT library have been added in MathCore. These originate mainly from methods present previously in the implementation of the TF1 class. Now they can be used also outside this class. In addition, in order to have a c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:5170,interface,interface,5170,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['interface'],['interface']
Integrability,"h integer overflow errors. Signed integer overflow is; undefined in C. With this flag, extra code is generated to detect this and; abort when it happens. .. option:: -fvisibility. This flag sets the default visibility level. .. option:: -fcommon, -fno-common. This flag specifies that variables without initializers get common linkage.; It can be disabled with :option:`-fno-common`. .. option:: -ftls-model=<model>. Set the default thread-local storage (TLS) model to use for thread-local; variables. Valid values are: ""global-dynamic"", ""local-dynamic"",; ""initial-exec"" and ""local-exec"". The default is ""global-dynamic"". The default; model can be overridden with the tls_model attribute. The compiler will try; to choose a more efficient model if possible. .. option:: -flto, -flto=full, -flto=thin, -emit-llvm. Generate output files in LLVM formats, suitable for link time optimization.; When used with :option:`-S` this generates LLVM intermediate language; assembly files, otherwise this generates LLVM bitcode format object files; (which may be passed to the linker depending on the stage selection options). The default for :option:`-flto` is ""full"", in which the; LLVM bitcode is suitable for monolithic Link Time Optimization (LTO), where; the linker merges all such modules into a single combined module for; optimization. With ""thin"", :doc:`ThinLTO <../ThinLTO>`; compilation is invoked instead. .. note::. On Darwin, when using :option:`-flto` along with :option:`-g` and; compiling and linking in separate steps, you also need to pass; ``-Wl,-object_path_lto,<lto-filename>.o`` at the linking step to instruct the; ld64 linker not to delete the temporary object file generated during Link; Time Optimization (this flag is automatically passed to the linker by Clang; if compilation and linking are done in a single step). This allows debugging; the executable as well as generating the ``.dSYM`` bundle using :manpage:`dsymutil(1)`. Driver Options; ~~~~~~~~~~~~~~. .. option:: -###. Print ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:15285,depend,depending,15285,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,1,['depend'],['depending']
Integrability,"h is supported; for compatibility with SP3 assembler:. =============================== =========================================================; Syntax Description; =============================== =========================================================; dim:SQ_RSRC_IMG_1D One-dimensional image.; dim:SQ_RSRC_IMG_2D Two-dimensional image.; dim:SQ_RSRC_IMG_3D Three-dimensional image.; dim:SQ_RSRC_IMG_CUBE Cubemap array.; dim:SQ_RSRC_IMG_1D_ARRAY One-dimensional image array.; dim:SQ_RSRC_IMG_2D_ARRAY Two-dimensional image array.; dim:SQ_RSRC_IMG_2D_MSAA Two-dimensional multi-sample auto-aliasing image.; dim:SQ_RSRC_IMG_2D_MSAA_ARRAY Two-dimensional multi-sample auto-aliasing image array.; =============================== =========================================================. dlc; ~~~. See a description :ref:`here<amdgpu_synid_dlc>`. Miscellaneous Modifiers; -----------------------. .. _amdgpu_synid_dlc:. dlc; ~~~. Controls device level cache policy for memory operations. Used for synchronization.; When specified, forces operation to bypass device level cache, making the operation device; level coherent. By default, instructions use device level cache. ======================================== ================================================; Syntax Description; ======================================== ================================================; dlc Bypass device level cache.; ======================================== ================================================. .. _amdgpu_synid_glc:. glc; ~~~. For atomic opcodes, this modifier indicates that the instruction returns the value from memory; before the operation. For other opcodes, it is used together with :ref:`slc<amdgpu_synid_slc>`; to specify cache policy. The default value is off (0). ======================================== ================================================; Syntax Description; ======================================== ================================================; glc Set glc bit to 1.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst:17102,synchroniz,synchronization,17102,interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,1,['synchroniz'],['synchronization']
Integrability,"h the; .inc extension. Use sparingly, and prefer self-contained headers when possible. In general, a header should be implemented by one or more ``.cpp`` files. Each; of these ``.cpp`` files should include the header that defines their interface; first. This ensures that all of the dependences of the header have been; properly added to the header itself, and are not implicit. System headers; should be included after user headers for a translation unit. Library Layering; ^^^^^^^^^^^^^^^^. A directory of header files (for example ``include/llvm/Foo``) defines a; library (``Foo``). One library (both; its headers and implementation) should only use things from the libraries; listed in its dependencies. Some of this constraint can be enforced by classic Unix linkers (Mac & Windows; linkers, as well as lld, do not enforce this constraint). A Unix linker; searches left to right through the libraries specified on its command line and; never revisits a library. In this way, no circular dependencies between; libraries can exist. This doesn't fully enforce all inter-library dependencies, and importantly; doesn't enforce header file circular dependencies created by inline functions.; A good way to answer the ""is this layered correctly"" would be to consider; whether a Unix linker would succeed at linking the program if all inline; functions were defined out-of-line. (& for all valid orderings of dependencies; - since linking resolution is linear, it's possible that some implicit; dependencies can sneak through: A depends on B and C, so valid orderings are; ""C B A"" or ""B C A"", in both cases the explicit dependencies come before their; use. But in the first case, B could still link successfully if it implicitly; depended on C, or the opposite in the second case). .. _minimal list of #includes:. ``#include`` as Little as Possible; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``#include`` hurts compile time performance. Don't do it unless you have to,; especially in header files. But wait! S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:30972,depend,dependencies,30972,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['depend'],['dependencies']
Integrability,"h) is no longer necessary; when using ExpandCreateFast. New Thread Pool class. A first version of TThreadPool class has been introduced.; This class implements a Thread Pool pattern.; So far it supports only one type of queue - FIFO. Thread library. Reduces risk of internal dead lock by using a private internal lock to protect the internals of TThread, rather than using TThread::Lock. New header TThreadSlots.h to centralize and formalize the use of the TThread local memory slots amongst the ROOT packages. Global Variables. The global values gPad, gVirtualX, gInterpreter, gDirectory and gFile; are now all accessed via a static function of their respective class. The; access is made transparent via a CPP macro.; The access is now also made transparent from the CINT and python prompt.; gPad, gVirtualX and gInterpreter are now accessible even when their value; is zero and they now properly support tab completion.; See the important note in the I/O section on gDirectory and gFile which; are now thread local. Meta. The new interface TDictionary::GetDictionary(const char*) offers a; single entry point to query the type based on its name, conveniently combining; TDataType and TClass queries. It does name normalization (removing std etc). Add the ability to explicitly forbid (or allow) the splitting of a class; (TClass::SetSplit) so that user can inforce the use of a custom streamer in all possible split cases. Resolve several issues with the creation of StreamerInfo for abstract classes. When looking for the value corresponding to an enum type, skip global that are not enums. (This improves the speed of TFile::Open by 60%). TStyle. The Modern style has now a transparent background for the histogram title. Misc. In the root executable, auto-detect command line arguments that are local root files even if their name does not end with "".root"". If home directory is not correctly set in pw file or user is not known, use the HOME shell variable to find the desired home directory. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html:3410,interface,interface,3410,core/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html,1,['interface'],['interface']
Integrability,h/tan.h; libclc/generic/include/clc/math/tanh.h; libclc/generic/include/clc/math/tanpi.h; libclc/generic/include/clc/math/tgamma.h; libclc/generic/include/clc/math/trunc.h; libclc/generic/include/clc/relational/bitselect.h; libclc/generic/include/clc/relational/isfinite.h; libclc/generic/include/clc/relational/isgreater.h; libclc/generic/include/clc/relational/isgreaterequal.h; libclc/generic/include/clc/relational/isless.h; libclc/generic/include/clc/relational/islessequal.h; libclc/generic/include/clc/relational/islessgreater.h; libclc/generic/include/clc/relational/isnormal.h; libclc/generic/include/clc/relational/isnotequal.h; libclc/generic/include/clc/relational/isordered.h; libclc/generic/include/clc/relational/isunordered.h; libclc/generic/include/clc/relational/signbit.h; libclc/generic/include/clc/shared/clamp.h; libclc/generic/include/clc/shared/max.h; libclc/generic/include/clc/shared/min.h; libclc/generic/include/clc/synchronization/barrier.h; libclc/generic/include/clc/synchronization/cl_mem_fence_flags.h; libclc/generic/include/clc/workitem/get_global_id.h; libclc/generic/include/clc/workitem/get_global_offset.h; libclc/generic/include/clc/workitem/get_global_size.h; libclc/generic/include/clc/workitem/get_group_id.h; libclc/generic/include/clc/workitem/get_local_id.h; libclc/generic/include/clc/workitem/get_local_size.h; libclc/generic/include/clc/workitem/get_num_groups.h; libclc/generic/include/clc/workitem/get_work_dim.h; libclc/generic/include/integer/popcount.h; libclc/generic/include/math/clc_exp10.h; libclc/generic/include/math/clc_fma.h; libclc/generic/include/math/clc_fmod.h; libclc/generic/include/math/clc_hypot.h; libclc/generic/include/math/clc_ldexp.h; libclc/generic/include/math/clc_nextafter.h; libclc/generic/include/math/clc_pow.h; libclc/generic/include/math/clc_pown.h; libclc/generic/include/math/clc_powr.h; libclc/generic/include/math/clc_remainder.h; libclc/generic/include/math/clc_remquo.h; libclc/generic/include/math/clc_rootn.h;,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:158264,synchroniz,synchronization,158264,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['synchroniz'],['synchronization']
Integrability,hMulticlass DEPENDS ${PyMVA-Torch-Multiclass-depends}). # Test RModelParser_PyTorch. ROOT_ADD_GTEST(TestRModelParserPyTorch TestRModelParserPyTorch.C; LIBRARIES; ROOTTMVASofie; TMVA; Python3::NumPy; Python3::Python; INCLUDE_DIRS; SYSTEM; ${CMAKE_CURRENT_BINARY_DIR}; ); target_link_libraries(TestRModelParserPyTorch ${BLAS_LINKER_FLAGS} ${BLAS_LIBRARIES}). endif(PY_TORCH_FOUND). if((PY_KERAS_FOUND AND PY_THEANO_FOUND) OR (PY_KERAS_FOUND AND PY_TENSORFLOW_FOUND)); configure_file(generateKerasModels.py generateKerasModels.py COPYONLY); configure_file(scale_by_2_op.hxx scale_by_2_op.hxx COPYONLY). if (PY_TORCH_FOUND); set(PyMVA-Keras-Classification-depends PyMVA-Torch-Classification); set(PyMVA-Keras-Regression-depends PyMVA-Torch-Regression); set(PyMVA-Keras-Multiclass-depends PyMVA-Torch-Multiclass); endif(). # Test PyKeras: Binary classification; ROOT_EXECUTABLE(testPyKerasClassification testPyKerasClassification.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Keras-Classification COMMAND testPyKerasClassification DEPENDS ${PyMVA-Keras-Classification-depends}). # Test PyKeras: Regression; if (NOT ROOT_ARCHITECTURE MATCHES macosx); #veto also keras tutorial on macos due to issue in disabling eager execution on macos; ROOT_EXECUTABLE(testPyKerasRegression testPyKerasRegression.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Keras-Regression COMMAND testPyKerasRegression DEPENDS ${PyMVA-Keras-Regression-depends}); endif(). # Test PyKeras: Multi-class classification; ROOT_EXECUTABLE(testPyKerasMulticlass testPyKerasMulticlass.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-Keras-Multiclass COMMAND testPyKerasMulticlass DEPENDS ${PyMVA-Keras-Multiclass-depends}). ROOT_ADD_GTEST(TestRModelParserKeras TestRModelParserKeras.C; LIBRARIES; ROOTTMVASofie; PyMVA; Python3::NumPy; Python3::Python; INCLUDE_DIRS; SYSTEM; ${CMAKE_CURRENT_BINARY_DIR}; ); target_link_libraries(TestRModelParserKeras ${BLAS_LINKER_FLAGS} ${BLAS_LIBRARIES}). endif((PY_KERAS_FOUND AND PY_THEANO_FOUND) OR (P,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/CMakeLists.txt:4492,depend,depends,4492,tmva/pymva/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/CMakeLists.txt,1,['depend'],['depends']
Integrability,"handling, thread local; variables, and language runtime registration. Supporting these features enables; ORC to execute code generated from source languages which rely on these features; (e.g. C++ requires object format support for static initializers to support; static constructors, eh-frame registration for exceptions, and TLV support for; thread locals; Swift and Objective-C require language runtime registration for; many features). For some object format features support is provided entirely; within JITLink, and for others it is provided in cooperation with the; (prototype) ORC runtime. JITLink aims to support the following features, some of which are still under; development:. 1. Cross-process and cross-architecture linking of single relocatable objects; into a target *executor* process. 2. Support for all object format features. 3. Open linker data structures (``LinkGraph``) and pass system. JITLink and ObjectLinkingLayer; ==============================. ``ObjectLinkingLayer`` is ORCs wrapper for JITLink. It is an ORC layer that; allows objects to be added to a ``JITDylib``, or emitted from some higher level; program representation. When an object is emitted, ``ObjectLinkingLayer`` uses; JITLink to construct a ``LinkGraph`` (see :ref:`constructing_linkgraphs`) and; calls JITLink's ``link`` function to link the graph into the executor process. The ``ObjectLinkingLayer`` class provides a plugin API,; ``ObjectLinkingLayer::Plugin``, which users can subclass in order to inspect and; modify ``LinkGraph`` instances at link time, and react to important JIT events; (such as an object being emitted into target memory). This enables many features; and optimizations that were not possible under MCJIT or RuntimeDyld. ObjectLinkingLayer Plugins; --------------------------. The ``ObjectLinkingLayer::Plugin`` class provides the following methods:. * ``modifyPassConfig`` is called each time a LinkGraph is about to be linked. It; can be overridden to install JITLink *Passes* t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:1894,wrap,wrapper,1894,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['wrap'],['wrapper']
Integrability,"hape; alpha=0.5; RooPlot* frame = x.frame() ;; rlm.plotOn(frame) ;. In short the algorithm works as follows: for both f1(x) and f2(x), the cumulative distribution; functions F1(x) and F2(x) are calculated. One finds takes a value 'y' of both c.d.fs and ; determines the corresponding x values x1,x2 at which F1(x1)=F2(x2)=y. The value of the interpolated ; p.d.f fbar(x) is then calculated as fbar(alpha*x1+(1-alpha)*x2) = f1(x1)*f2(x2) / ( alpha*f2(x2) + ; (1-alpha)*f1(x1) ). Given that it is not easily possible to calculate the value of RooLinearMorph; at a given value of x, the value for all values of x are calculated in one by (through a scan over y); and stored in a cache. NB: The range of the interpolation parameter does not need to be [0,1], it can; be anything. New workspace tool RooSimWSTool. A new tool to clone and customize p.d.f.s into a RooSimultaneous p.d.f has been added. This new; tool succeeds the original RooSimPdfBuilder tool which had a similar functionality but; has a much cleaner interface, partly thanks to its use of the RooWorkspace class for both input; of prototype p.d.fs and output of built p.d.f.s. The simplest use case to to take a workspace p.d.f as prototype and 'split' a parameter of that p.d.f ; into two specialized parameters depending on a category in the dataset. ; For example, given a Gaussian p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'.; Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. . SplitParam(""m"",""c,d"")",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html:11642,interface,interface,11642,roofit/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v520/index.html,1,['interface'],['interface']
Integrability,"hase.; A standalone version of VMC is being developed at [https://github.com/vmc-project/vmc](https://github.com/vmc-project/vmc); to replace the deprecated version in ROOT. ### Removed packages. Support for the following optional components of ROOT has been removed:. * afdsmgrd (Dataset manager for PROOF-based analysis facilities); * bonjour (Avahi/Bonjour/Zeroconf); * castor (CERN Advanced STORage manager); * geocad (OpenCascade); * globus (Globus authentication); * hdfs (Hadoop Distributed File System); * krb5 (Kerberos 5 authentication); * ldap (OpenLDAP authentication); * memstat (legacy memory statistics utility); * qt, qtgsi, qtroot (Qt4-based GUI components); * rfio (Remote File IO for CASTOR); * table (libTable contrib library). In addition, the following deprecated parts of ROOT components have been; removed:. * PROOF's PQ2 module; * `THttpServer::ExecuteHttp()` and `THttpServer::SubmitHttp` from `THttpServer`. ### Other changes. The deprecation of the GraphViz integration has been reverted since the code is; still in use. The ODBC interface, deprecated in ROOT 6.16, is no longer deprecated in ROOT 6.18.; It is the main option to support databases on Windows, so the decision to deprecate; it was reverted. The `xft` option has been merged into `x11` and is no longer used (its value is; now ignored by ROOT). ## Preprocessor deprecation macros; ### Deprecated Classes; * `R__SUGGEST_ALTERNATIVE(""Suggestion text"")` macro allows to suggest alternatives to classes. It must be used after the class definition and before the final semicolon:; ```{.cpp}; class DoNotUseClass {; } R__SUGGEST_ALTERNATIVE(""Use ... instead."");; ```; It is activated by the preprocessor defines `R__SUGGEST_NEW_INTERFACE`. The former is useful when deprecation warnings should be activated/deactivated at global level, for example for an entire project. This could be done by defining `R__SUGGEST_NEW_INTERFACE` in the build system. ; If the warning needs to be confined within single translation ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:2555,integrat,integration,2555,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['integrat'],['integration']
Integrability,"hat accesses private); provided the other operation's sync scope is:. - ``system``, ``agent`` or ``workgroup`` and; executed by a thread in the same work-group.; - ``wavefront`` and executed by a thread in the; same wavefront. ``wavefront`` Synchronizes with, and participates in modification; and seq_cst total orderings with, other operations; (except image operations) for all address spaces; (except private, or generic that accesses private); provided the other operation's sync scope is:. - ``system``, ``agent``, ``workgroup`` or; ``wavefront`` and executed by a thread in the; same wavefront. ``singlethread`` Only synchronizes with and participates in; modification and seq_cst total orderings with,; other operations (except image operations) running; in the same thread for all address spaces (for; example, in signal handlers). ``one-as`` Same as ``system`` but only synchronizes with other; operations within the same address space. ``agent-one-as`` Same as ``agent`` but only synchronizes with other; operations within the same address space. ``workgroup-one-as`` Same as ``workgroup`` but only synchronizes with; other operations within the same address space. ``wavefront-one-as`` Same as ``wavefront`` but only synchronizes with; other operations within the same address space. ``singlethread-one-as`` Same as ``singlethread`` but only synchronizes with; other operations within the same address space.; ======================= ===================================================. LLVM IR Intrinsics; ------------------. The AMDGPU backend implements the following LLVM IR intrinsics. *This section is WIP.*. .. table:: AMDGPU LLVM IR Intrinsics; :name: amdgpu-llvm-ir-intrinsics-table. ============================================== ==========================================================; LLVM Intrinsic Description; ============================================== ==========================================================; llvm.amdgcn.sqrt Provides direct access to v_sqrt_f64, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:34848,synchroniz,synchronizes,34848,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronizes']
Integrability,"hat an operation is not accepted according to a corresponding; specification. ============================== ======= ======= ============= ======= =====; Operator OpenCL AltiVec GCC NEON SVE; ============================== ======= ======= ============= ======= =====; [] yes yes yes yes yes; unary operators +, -- yes yes yes yes yes; ++, -- -- yes yes yes no no; +,--,*,/,% yes yes yes yes yes; bitwise operators &,|,^,~ yes yes yes yes yes; >>,<< yes yes yes yes yes; !, &&, || yes -- yes yes yes; ==, !=, >, <, >=, <= yes yes yes yes yes; = yes yes yes yes yes; ?: [#]_ yes -- yes yes yes; sizeof yes yes yes yes yes [#]_; C-style cast yes yes yes no no; reinterpret_cast yes no yes no no; static_cast yes no yes no no; const_cast no no no no no; address &v[i] no no no [#]_ no no; ============================== ======= ======= ============= ======= =====. See also :ref:`langext-__builtin_shufflevector`, :ref:`langext-__builtin_convertvector`. .. [#] ternary operator(?:) has different behaviors depending on condition; operand's vector type. If the condition is a GNU vector (i.e. __vector_size__),; a NEON vector or an SVE vector, it's only available in C++ and uses normal bool; conversions (that is, != 0).; If it's an extension (OpenCL) vector, it's only available in C and OpenCL C.; And it selects base on signedness of the condition operands (OpenCL v1.1 s6.3.9).; .. [#] sizeof can only be used on vector length specific SVE types.; .. [#] Clang does not allow the address of an element to be taken while GCC; allows this. This is intentional for vectors with a boolean element type and; not implemented otherwise. Vector Builtins; ---------------. **Note: The implementation of vector builtins is work-in-progress and incomplete.**. In addition to the operators mentioned above, Clang provides a set of builtins; to perform additional operations on certain scalar and vector types. Let ``T`` be one of the following types:. * an integer type (as in C23 6.2.5p22), but excluding enumer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:20085,depend,depending,20085,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['depend'],['depending']
Integrability,"hat constant folding in various; ways turns into a tree walk that needs to handle the various cases. However, there are places in both C and C++ that require constants to be; folded. For example, the C standard defines what an ""integer constant; expression"" (i-c-e) is with very precise and specific requirements. The; language then requires i-c-e's in a lot of places (for example, the size of a; bitfield, the value for a case statement, etc). For these, we have to be able; to constant fold the constants, to do semantic checks (e.g., verify bitfield; size is non-negative and that case statements aren't duplicated). We aim for; Clang to be very pedantic about this, diagnosing cases when the code does not; use an i-c-e where one is required, but accepting the code unless running with; ``-pedantic-errors``. Things get a little bit more tricky when it comes to compatibility with; real-world source code. Specifically, GCC has historically accepted a huge; superset of expressions as i-c-e's, and a lot of real world code depends on; this unfortunate accident of history (including, e.g., the glibc system; headers). GCC accepts anything its ""fold"" optimizer is capable of reducing to; an integer constant, which means that the definition of what it accepts changes; as its optimizer does. One example is that GCC accepts things like ""``case; X-X:``"" even when ``X`` is a variable, because it can fold this to 0. Another issue are how constants interact with the extensions we support, such; as ``__builtin_constant_p``, ``__builtin_inf``, ``__extension__`` and many; others. C99 obviously does not specify the semantics of any of these; extensions, and the definition of i-c-e does not include them. However, these; extensions are often used in real code, and we have to have a way to reason; about them. Finally, this is not just a problem for semantic analysis. The code generator; and other clients have to be able to fold constants (e.g., to initialize global; variables) and have to handle",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:119607,depend,depends,119607,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['depends']
Integrability,"hat having a; ptrtoint or inttoptr cast (which is common for such use cases) breaks the; rules used for inferring base pointers for arbitrary references when; lowering out of the abstract model to the explicit physical model. Note; that a frontend which lowers directly to the physical model doesn't have; any problems here. Objects on the Stack; ^^^^^^^^^^^^^^^^^^^^. As noted above, the explicit lowering supports objects allocated on the; stack provided the collector can find a heap map given the stack address. The missing pieces are a) integration with rewriting (RS4GC) from the; abstract machine model and b) support for optionally decomposing on stack; objects so as not to require heap maps for them. The later is required; for ease of integration with some collectors. Lowering Quality and Representation Overhead; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The current statepoint lowering is known to be somewhat poor. In the very; long term, we'd like to integrate statepoints with the register allocator;; in the near term this is unlikely to happen. We've found the quality of; lowering to be relatively unimportant as hot-statepoints are almost always; inliner bugs. Concerns have been raised that the statepoint representation results in a; large amount of IR being produced for some examples and that this; contributes to higher than expected memory usage and compile times. There's; no immediate plans to make changes due to this, but alternate models may be; explored in the future. Relocations Along Exceptional Edges; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Relocations along exceptional paths are currently broken in ToT. In; particular, there is current no way to represent a rethrow on a path which; also has relocations. See `this llvm-dev discussion; <https://groups.google.com/forum/#!topic/llvm-dev/AE417XjgxvI>`_ for more; detail. Bugs and Enhancements; =====================. Currently known bugs and enhancements under consideration can be; tracked by performing a `bu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:35453,integrat,integrate,35453,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['integrat'],['integrate']
Integrability,"hat initializes/serializes the option class (in our case; ``CodeGenOptions``) stored within ``CompilerInvocation``. This can be done; automatically by using the marshalling annotations on the option definition:. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; Group<f_Group>, Flags<[CC1Option]>,; HelpText<""Load pass plugin from a dynamic shared object file."">,; + MarshallingInfoStringVector<CodeGenOpts<""PassPlugins"">>;. Inner workings of the system are introduced in the :ref:`marshalling; infrastructure <OptionMarshalling>` section and the available annotations are; listed :ref:`here <OptionMarshallingAnnotations>`. In case the marshalling infrastructure does not support the desired semantics,; consider simplifying it to fit the existing model. This makes the command line; more uniform and reduces the amount of custom, manually written code. Remember; that the ``-cc1`` command line interface is intended only for Clang developers,; meaning it does not need to mirror the driver interface, maintain backward; compatibility or be compatible with GCC. If the option semantics cannot be encoded via marshalling annotations, you can; resort to parsing/serializing the command line arguments manually:. .. code-block:: diff. // CompilerInvocation.cpp. static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args /*...*/) {; // ... + Opts.PassPlugins = Args.getAllArgValues(OPT_fpass_plugin_EQ);; }. static void GenerateCodeGenArgs(const CodeGenOptions &Opts,; SmallVectorImpl<const char *> &Args,; CompilerInvocation::StringAllocator SA /*...*/) {; // ... + for (const std::string &PassPlugin : Opts.PassPlugins); + GenerateArg(Args, OPT_fpass_plugin_EQ, PassPlugin, SA);; }. Finally, you can specify the argument on the command line:; ``clang -fpass-plugin=a -fpass-plugin=b`` and use the new member variable as; desired. .. code-block:: diff. void EmitAssemblyHelper::EmitAssemblyWithNewPassManager(/*...*/) {; // ...; + for (auto &PluginFN : ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:32748,interface,interface,32748,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['interface'],['interface']
Integrability,"hat it is functional makes it ""too easy"" to generate LLVM IR for it. In; particular, a functional language makes it very easy to build LLVM IR; directly in `SSA; form <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_.; Since LLVM requires that the input code be in SSA form, this is a very; nice property and it is often unclear to newcomers how to generate code; for an imperative language with mutable variables. The short (and happy) summary of this chapter is that there is no need; for your front-end to build SSA form: LLVM provides highly tuned and; well tested support for this, though the way it works is a bit; unexpected for some. Why is this a hard problem?; ===========================. To understand why mutable variables cause complexities in SSA; construction, consider this extremely simple C example:. .. code-block:: c. int G, H;; int test(_Bool Condition) {; int X;; if (Condition); X = G;; else; X = H;; return X;; }. In this case, we have the variable ""X"", whose value depends on the path; executed in the program. Because there are two different possible values; for X before the return instruction, a PHI node is inserted to merge the; two values. The LLVM IR that we want for this example looks like this:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global i32 0 ; type of @H is i32*. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; br label %cond_next. cond_next:; %X.2 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]; ret i32 %X.2; }. In this example, the loads from the G and H global variables are; explicit in the LLVM IR, and they live in the then/else branches of the; if statement (cond\_true/cond\_false). In order to merge the incoming; values, the X.2 phi node in the cond\_next block selects the right value; to use based on where control flow is coming from: if",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:1751,depend,depends,1751,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['depend'],['depends']
Integrability,"hat still applies one can also edit drawn geometry objects. For this,; the menu entry View/Editor of the canvas containing for instance a drawn; volume must be activated. For starting the volume editor one can click; on a volume. The GUI of the **`TGeoManager`** class can be started by; clicking on the top-right `40x40` pixels corner of the pad with a drawn; geometry. This is the main entry point for editing the geometry or creating new; objects. Once the interface is created (using one of the methods; described above), several categories can be accessed via a shutter GUI; widget:. - *General.* This allows changing the name/title of the geometry,; setting the top volume, closing the geometry and saving the geometry; in a file. The file name is formed by `geometry_name.C` or `.root`; depending if the geometry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of properties related to tracking); - *Matrices.* Allows creation of translations, rotations or combined; transformations. Existing matrices can also be browser/edited. ### Editing Existing Objects. For editing an existing object from one of the categories described; above, the interface imposes first a selection among all objects of the; corresponding type stored in the geometry. This can be done by clicking; the button next to the blue label *Select \<object\>*. The dialog; interface",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:168244,interface,interface,168244,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability,"hat you want is to have a native compiler to the; platform itself, but not others. So there's rarely a point in compiling; all back-ends. For that reason, you should also set the; ``TARGETS_TO_BUILD`` to only build the back-end you're targeting to. You must set the ``CMAKE_INSTALL_PREFIX``, otherwise a ``ninja install``; will copy ARM binaries to your root filesystem, which is not what you; want. Hacks; -----. There are some bugs in current LLVM, which require some fiddling before; running CMake:. #. If you're using Clang as the cross-compiler, there is a problem in; the LLVM ARM back-end that is producing absolute relocations on; position-independent code (``R_ARM_THM_MOVW_ABS_NC``), so for now, you; should disable PIC:. .. code-block:: bash. -DLLVM_ENABLE_PIC=False. This is not a problem, since Clang/LLVM libraries are statically; linked anyway, it shouldn't affect much. #. The ARM libraries won't be installed in your system.; But the CMake prepare step, which checks for; dependencies, will check the *host* libraries, not the *target*; ones. Below there's a list of some dependencies, but your project could; have more, or this document could be outdated. You'll see the errors; while linking as an indication of that. Debian based distros have a way to add ``multiarch``, which adds; a new architecture and allows you to install packages for those; systems. See https://wiki.debian.org/Multiarch/HOWTO for more info. But not all distros will have that, and possibly not an easy way to; install them in any anyway, so you'll have to build/download; them separately. A quick way of getting the libraries is to download them from; a distribution repository, like Debian (http://packages.debian.org/jessie/),; and download the missing libraries. Note that the ``libXXX``; will have the shared objects (``.so``) and the ``libXXX-dev`` will; give you the headers and the static (``.a``) library. Just in; case, download both. The ones you need for ARM are: ``libtinfo``, ``zlib1g``,; ``l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst:4773,depend,dependencies,4773,interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,1,['depend'],['dependencies']
Integrability,"hat's been `git add`ed:; git clang-format. To also format everything touched in the most recent commit:; git clang-format HEAD~1. If you're on a branch off main, to format everything touched on your branch:; git clang-format main. If two commits are given (requires --diff), run clang-format on all lines in the; second <commit> that differ from the first <commit>. The following git-config settings set the default of the corresponding option:; clangFormat.binary; clangFormat.commit; clangFormat.extensions; clangFormat.style. positional arguments:; <commit> revision from which to compute the diff; <file>... if specified, only consider differences in these files. optional arguments:; -h, --help show this help message and exit; --binary BINARY path to clang-format; --commit COMMIT default commit to use if none is specified; --diff print a diff instead of applying the changes; --diffstat print a diffstat instead of applying the changes; --extensions EXTENSIONS; comma-separated list of file extensions to format, excluding the period and case-insensitive; -f, --force allow changes to unstaged files; -p, --patch select hunks interactively; -q, --quiet print less information; --staged, --cached format lines in the stage instead of the working dir; --style STYLE passed to clang-format; -v, --verbose print extra information. Script for patch reformatting; =============================. The python script `clang/tools/clang-format/clang-format-diff.py` parses the; output of a unified diff and reformats all contained lines with; :program:`clang-format`. .. code-block:: console. usage: clang-format-diff.py [-h] [-i] [-p NUM] [-regex PATTERN] [-iregex PATTERN] [-sort-includes] [-v] [-style STYLE]; [-fallback-style FALLBACK_STYLE] [-binary BINARY]. This script reads input from a unified diff and reformats all the changed; lines. This is useful to reformat all the lines touched by a specific patch.; Example usage for git/svn users:. git diff -U0 --no-color --relative HEAD^ | clang-form",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:11442,message,message,11442,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['message'],['message']
Integrability,"haviour in wildcard import; * [[#7644](https://github.com/root-project/root/issues/7644)] - Provide in the cmake configuration the C++ standard which was used to compile ROOT; * [[#7627](https://github.com/root-project/root/issues/7627)] - Fix TMVA group links; * [[#7159](https://github.com/root-project/root/issues/7159)] - TNetXNGFile::Open fails with double slash (//) in path; * [[#7128](https://github.com/root-project/root/issues/7128)] - Cannot build ROOT if another ROOT at /usr/local; * [[#6900](https://github.com/root-project/root/issues/6900)] - mathmore: invalid roots for a quartic polynomial; * [[#6811](https://github.com/root-project/root/issues/6811)] - Bug displaying several 3D objects such as TGraph2D on the same canvas ; * [[#6755](https://github.com/root-project/root/issues/6755)] - Greek letter epsilon not rendered correctly using TLatex with OpenGL.CanvasPreferGL option, segmentation fault.; * [[#6753](https://github.com/root-project/root/issues/6753)] - CMake dependency on Python: use targets; * [[#6616](https://github.com/root-project/root/issues/6616)] - hadd writes files with unspecified compression algorithm; * [[#6438](https://github.com/root-project/root/issues/6438)] - hadd --help prints wrong usage info; * [[#6384](https://github.com/root-project/root/issues/6384)] - cxx-standard should not be in CMAKE_CXX_FLAGS; * [[ROOT-3358](https://its.cern.ch/jira/browse/ROOT-3358)] - SetRootSys() improperly sets $ROOTSYS; * [[ROOT-6424](https://its.cern.ch/jira/browse/ROOT-6424)] - Bogus template names suggested by autocompletion; * [[ROOT-6581](https://its.cern.ch/jira/browse/ROOT-6581)] - .x stress.cxx(1) broken; * [[ROOT-6713](https://its.cern.ch/jira/browse/ROOT-6713)] - Root attempts to stream null pointers to abstract classes; * [[ROOT-6867](https://its.cern.ch/jira/browse/ROOT-6867)] - forward declaration 'payload' inadvertently (?) unloaded; * [[ROOT-7280](https://its.cern.ch/jira/browse/ROOT-7280)] - Memory leaks due to erroneous use of Expand",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:49800,depend,dependency,49800,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['depend'],['dependency']
Integrability,"he ""Undo"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. \anchor GP08d; ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection of components before creating the object. \anchor GP08e; ### Editing Volumes. Volumes are hierarchical components in the geometry, therefore their; editor is more complex. It provides the following functionalities:. - *General*. This category allows changing the name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""Position"" allows editing the; positioning matrix of a given node. \image html geometry022.jpg width=600px; \image html geometry023.jpg ""Setting volume properties and modifying volume hierarchy"" width=600px. - *Visualization*. This category allows changing the visibility of the; edited volume or for its daughters, as well as other visualization; settin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:131914,depend,depend,131914,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['depend'],['depend']
Integrability,"he `ClassDef` support, `ClassDefInline(ClassName, Version)` now provides it without the need for a dictionary source: all members injected by this `ClassDef` flavor are generated by the interpreter. ### `TObjString` to `TString`. `TObjString::GetString()` now returns a `const TString&` to the `TString` inside the `TObjString`, instead of copying it.; This is to prevent very common misunderstanding of the interface. In several cases, the misunderstanding of the interface caused invalid memory accesses to the already destructed; temporary `TString` returned by `GetString()`, e.g. `objStr->GetString().Data()`. This will be fixed automatically by the; new return type. In rare cases, the caller expected `GetString()` to return a (non-const) reference to the embedded `TString`, e.g.; `objString->GetString().ReplaceAll(""a"", ""b""); // WRONG!` This will now fail to compile, instead of not doing what the author of the; code expected. Please fix that code by using the `TObjString::String()` interface, which returns a non-const `TString&`:; `objString->String().ReplaceAll(""a"", ""b"");`. In extremely rare cases, this change breaks a valid use where the temporary `TString` was modified and then captured in a new `TString`; object before the destruction of the temporary: `TString str = objStr->GetString().ReplaceAll(""a"", ""b"");`. In these rare cases,; please use the new function `CopyString()` which clearly indicates that it involves a temporary. ## Histogram Libraries. - New class `THnChain` was added to provide a `TChain`-like experience when; working with `THnBase`'ed histograms (currently `THn` and `THnSparse`) from; many files, see [here](https://sft.its.cern.ch/jira/browse/ROOT-4515). This; allows to e.g., interactively adjust axis parameters before performing; projections from high-dimensional histograms,. ```{.cpp}; // Create a chain of histograms called `h`.; THnChain chain(""h"");. // Add files containing histograms `h` to `chain`.; chain->AddFile(""file1.root"");. chain->GetXaxi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:3754,interface,interface,3754,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['interface'],['interface']
Integrability,"he ``@path/to/file.rsp`` syntax. Arguments read from a file must; be one per line and are treated as if they were in the same place as the; original file referencing argument on the command line. A response file can; reference other response files. Users interested in the :program:`lit` architecture or designing a; :program:`lit` testing implementation should see :ref:`lit-infrastructure`. GENERAL OPTIONS; ---------------. .. option:: -h, --help. Show the :program:`lit` help message. .. option:: -j N, --workers=N. Run ``N`` tests in parallel. By default, this is automatically chosen to; match the number of detected available CPUs. .. option:: --config-prefix=NAME. Search for :file:`{NAME}.cfg` and :file:`{NAME}.site.cfg` when searching for; test suites, instead of :file:`lit.cfg` and :file:`lit.site.cfg`. .. option:: -D NAME[=VALUE], --param NAME[=VALUE]. Add a user defined parameter ``NAME`` with the given ``VALUE`` (or the empty; string if not given). The meaning and use of these parameters is test suite; dependent. .. _output-options:. OUTPUT OPTIONS; --------------. .. option:: -q, --quiet. Suppress any output except for test failures. .. option:: -s, --succinct. Show less output, for example don't show information on tests that pass.; Also show a progress bar, unless ``--no-progress-bar`` is specified. .. option:: -v, --verbose. Show more information on test failures, for example the entire test output; instead of just the test result. Each command is printed before it is executed. This can be valuable for; debugging test failures, as the last printed command is the one that failed.; Moreover, :program:`lit` inserts ``'RUN: at line N'`` before each; command pipeline in the output to help you locate the source line of; the failed command. .. option:: -vv, --echo-all-commands. Deprecated alias for -v. .. option:: -a, --show-all. Enable -v, but for all tests not just failed tests. .. option:: --no-progress-bar. Do not use curses based progress bar. .. option:: --s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:2950,depend,dependent,2950,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['depend'],['dependent']
Integrability,"he ``TargetFrameLowering`` class; ---------------------------------. The ``TargetFrameLowering`` class is used to provide information about the stack; frame layout of the target. It holds the direction of stack growth, the known; stack alignment on entry to each function, and the offset to the local area.; The offset to the local area is the offset from the stack pointer on function; entry to the first location where function data (local variables, spill; locations) can be stored. The ``TargetSubtarget`` class; -----------------------------. The ``TargetSubtarget`` class is used to provide information about the specific; chip set being targeted. A sub-target informs code generation of which; instructions are supported, instruction latencies and instruction execution; itinerary; i.e., which processing units are used, in what order, and for how; long. The ``TargetJITInfo`` class; ---------------------------. The ``TargetJITInfo`` class exposes an abstract interface used by the; Just-In-Time code generator to perform target-specific activities, such as; emitting stubs. If a ``TargetMachine`` supports JIT code generation, it should; provide one of these objects through the ``getJITInfo`` method. .. _code being generated:; .. _machine code representation:. Machine code description classes; ================================. At the high-level, LLVM code is translated to a machine specific representation; formed out of :raw-html:`<tt>` `MachineFunction`_ :raw-html:`</tt>`,; :raw-html:`<tt>` `MachineBasicBlock`_ :raw-html:`</tt>`, and :raw-html:`<tt>`; `MachineInstr`_ :raw-html:`</tt>` instances (defined in; ``include/llvm/CodeGen``). This representation is completely target agnostic,; representing instructions in their most abstract form: an opcode and a series of; operands. This representation is designed to support both an SSA representation; for machine code, as well as a register allocated, non-SSA form. .. _MachineInstr:. The ``MachineInstr`` class; --------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:14892,interface,interface,14892,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['interface'],['interface']
Integrability,"he build process needs them.; You may also need to install ``wheel`` first if you have an older version of; ``pip`` and/or do not use virtualenv (which installs wheel by default).; Example::. $ python -m pip install wheel --user; $ PATH=$HOME/.local/bin:$PATH python -m pip install cppyy --user. Wheels on PyPI; --------------. Wheels for the backend (``cppyy-cling``) are available on PyPI for GNU/Linux,; MacOS-X, and MS Windows (both 32b and 64b).; The Linux wheels are built for manylinux2014, but with the dual ABI enabled.; The wheels for MS Windows were build with MSVC Community Edition 2017. There are no wheels for the ``CPyCppyy`` and ``cppyy`` packages, to allow; the C++ standard chosen to match the local compiler. pip with conda; --------------. Although installing ``cppyy`` through `conda-forge`_ is recommended, it is; possible to build/install with ``pip`` under Anaconda/miniconda. Typical Python extensions only expose a C interface for use through the; Python C-API, requiring only calling conventions (and the Python C-API; version, of course) to match to be binary compatible.; Here, cppyy differs because it exposes C++ APIs: it thus requires a C++; run-time that is ABI compatible with the C++ compiler that was used during; build-time. A set of modern compilers is available through conda-forge, but are only; intended for use with ``conda-build``.; In particular, the corresponding run-time is installed (for use through rpath; when building), but not set up.; That is, the conda compilers are added to ``PATH`` but not their libraries; to ``LD_LIBRARY_PATH`` (Mac, Linux; ``PATH`` for both on MS Windows).; Thus, you get the conda compilers and your system libraries mixed in the same; build environment, unless you set ``LD_LIBRARY_PATH`` (``PATH`` on Windows); explicitly, e.g. by adding ``$CONDA_PREFIX/lib``.; Note that the conda documentation recommends against this.; Furthermore, the compilers from conda-forge are not vanilla distributions:; header files have been",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/installation.rst:3295,interface,interface,3295,bindings/pyroot/cppyy/cppyy/doc/source/installation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/installation.rst,1,['interface'],['interface']
Integrability,"he burden to add; things to the LLVM monorepo needs to be very high - code that is added to this; repository is checked out by everyone in the community. As such, we hold; components to a high bar similar to ""official targets"", they:. * Must be generally aligned with the mission of the LLVM project to advance; compilers, languages, tools, runtimes, etc.; * Must conform to all of the policies laid out in this developer policy; document, including license, patent, coding standards, and code of conduct.; * Must have an active community that maintains the code, including established; code owners.; * Should have reasonable documentation about how it works, including a high; quality README file.; * Should have CI to catch breakage within the project itself or due to; underlying LLVM dependencies.; * Should have code free of issues the community finds contentious, or be on a; clear path to resolving them.; * Must be proposed through the LLVM RFC process, and have its addition approved; by the LLVM community - this ultimately mediates the resolution of the; ""should"" concerns above. If you have a project that you think would make sense to add to the LLVM; monorepo, please start an RFC topic on the `LLVM Discourse forums`_ to kick off; the discussion. This process can take some time and iteration - please don’t; be discouraged or intimidated by that!. If you have an earlier stage project that you think is aligned with LLVM, please; see the ""Incubating New Projects"" section. Incubating New Projects; -----------------------. The burden to add a new project to the LLVM monorepo is intentionally very high,; but that can have a chilling effect on new and innovative projects. To help; foster these sorts of projects, LLVM supports an ""incubator"" process that is; much easier to get started with. It provides space for potentially valuable,; new top-level and sub-projects to reach a critical mass before they have enough; code to prove their utility and grow a community. This also allows",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:46596,mediat,mediates,46596,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['mediat'],['mediates']
Integrability,"he case where; the tree is in the top level directory. The file should not contain; sub-directories. Before switching to a new file, the tree header is; written to the current file, then the current file is closed. To process; the multiple files created by `ChangeFile()`, one must use a; **`TChain`**. The new file name has a suffix ""`_N`"" where `N` is equal to; `fFileNumber+1`. By default a Root session starts with `fFileNumber=0`.; One can set `fFileNumber` to a different value via; `TTree::SetFileNumber()`. In case a file named ""`_N`"" already exists,; the function will try a file named ""`__N`"", then ""`___N`"", etc. The; maximum tree size can be set via the static function; `TTree::SetMaxTreeSize()`. The default value of `fgMaxTreeSize` is 100; GB. If the current file contains other objects (like **`TH1`** and; **`TTree`**), these objects are automatically moved to the new file. ### User Info Attached to a TTree Object. The function `TTree::GetUserInfo()` allows adding any object defined by; a user to the tree that is not depending on the entry number. For; example:. ``` {.cpp}; tree->GetUserInfo()->Add(myruninfo);; ```. ### Indexing a Tree. Use `TTree::BuildIndex()`, to build an index table using expressions; depending on the value in the leaves. ``` {.cpp}; tree->BuildIndex(majorname, minorname);; ```. The index is built in the following way:. - a pass on all entries is made like in `TTree::Draw()`; - `var1 = majorname`; - `var2 = minorname`; - `sel = ` $2^{31} \times majorname + minorname$; - for each entry in the tree the sel expression is evaluated and the; results array is sorted into `fIndexValues`. Once the index is computed, using the; `TTree::GetEntryWithIndex(majornumber, minornumber)` one entry can be; retrieved. Example:. ``` {.cpp}; // to create an index using leaves Run and Event; tree.BuildIndex(""Run"",""Event"");; // to read entry corresponding to Run=1234 and Event=56789; tree.GetEntryWithIndex(1234,56789);; ```. Note that `majorname` and `minorname` m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:16252,depend,depending,16252,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['depend'],['depending']
Integrability,"he column limit. A column limit of ``0`` means that there is no column limit. In this case,; clang-format will respect the input's line breaking decisions within; statements unless they contradict other rules. .. _CommentPragmas:. **CommentPragmas** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <CommentPragmas>`; A regular expression that describes comments with special meaning,; which should not be split into lines or otherwise changed. .. code-block:: c++. // CommentPragmas: '^ FOOBAR pragma:'; // Will leave the following line unaffected; #include <vector> // FOOBAR pragma: keep. .. _CompactNamespaces:. **CompactNamespaces** (``Boolean``) :versionbadge:`clang-format 5` :ref:`¶ <CompactNamespaces>`; If ``true``, consecutive namespace declarations will be on the same; line. If ``false``, each namespace is declared on a new line. .. code-block:: c++. true:; namespace Foo { namespace Bar {; }}. false:; namespace Foo {; namespace Bar {; }; }. If it does not fit on a single line, the overflowing namespaces get; wrapped:. .. code-block:: c++. namespace Foo { namespace Bar {; namespace Extra {; }}}. .. _ConstructorInitializerAllOnOneLineOrOnePerLine:. **ConstructorInitializerAllOnOneLineOrOnePerLine** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ConstructorInitializerAllOnOneLineOrOnePerLine>`; This option is **deprecated**. See ``CurrentLine`` of; ``PackConstructorInitializers``. .. _ConstructorInitializerIndentWidth:. **ConstructorInitializerIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ConstructorInitializerIndentWidth>`; The number of characters to use for indentation of constructor; initializer lists as well as inheritance lists. .. _ContinuationIndentWidth:. **ContinuationIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ContinuationIndentWidth>`; Indent width for line continuations. .. code-block:: c++. ContinuationIndentWidth: 2. int i = // VeryVeryVeryVeryVeryLongComment; longFunction( // Again a lon",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:57854,wrap,wrapped,57854,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrapped']
Integrability,"he corresponding function call. Given Mod/Ref information; ``MRI`` for a memory location ``Loc``, ``MRI`` can be refined with a statement; like ``MRI &= AA.getModRefInfoMask(Loc);``. Another useful idiom is; ``isModSet(AA.getModRefInfoMask(Loc))``; this checks to see if the given; location can be modified at all. For convenience, there is also a method; ``pointsToConstantMemory(Loc)``; this is synonymous with; ``isNoModRef(AA.getModRefInfoMask(Loc))``. .. _never access memory or only read memory:. The ``doesNotAccessMemory`` and ``onlyReadsMemory`` methods; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These methods are used to provide very simple mod/ref information for function; calls. The ``doesNotAccessMemory`` method returns true for a function if the; analysis can prove that the function never reads or writes to memory, or if the; function only reads from constant memory. Functions with this property are; side-effect free and only depend on their input arguments, allowing them to be; eliminated if they form common subexpressions or be hoisted out of loops. Many; common functions behave this way (e.g., ``sin`` and ``cos``) but many others do; not (e.g., ``acos``, which modifies the ``errno`` variable). The ``onlyReadsMemory`` method returns true for a function if analysis can prove; that (at most) the function only reads from non-volatile memory. Functions with; this property are side-effect free, only depending on their input arguments and; the state of memory when they are called. This property allows calls to these; functions to be eliminated and moved around, as long as there is no store; instruction that changes the contents of memory. Note that all functions that; satisfy the ``doesNotAccessMemory`` method also satisfy ``onlyReadsMemory``. Writing a new ``AliasAnalysis`` Implementation; ==============================================. Writing a new alias analysis implementation for LLVM is quite straight-forward.; There are already several ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:8661,depend,depend,8661,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['depend'],['depend']
Integrability,"he corresponding; :ref:`llvm.stacksave <int_stacksave>` intrinsic executed. This is; useful for implementing language features like scoped automatic; variable sized arrays in C99. The address space should typically be; the :ref:`alloca address space <alloca_addrspace>`. Semantics:; """""""""""""""""""". See the description for :ref:`llvm.stacksave <int_stacksave>`. .. _int_get_dynamic_area_offset:. '``llvm.get.dynamic.area.offset``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.get.dynamic.area.offset.i32(); declare i64 @llvm.get.dynamic.area.offset.i64(). Overview:; """""""""""""""""". The '``llvm.get.dynamic.area.offset.*``' intrinsic family is used to; get the offset from native stack pointer to the address of the most; recent dynamic alloca on the caller's stack. These intrinsics are; intended for use in combination with; :ref:`llvm.stacksave <int_stacksave>` to get a; pointer to the most recent dynamic alloca. This is useful, for example,; for AddressSanitizer's stack unpoisoning routines. Semantics:; """""""""""""""""""". These intrinsics return a non-negative integer value that can be used to; get the address of the most recent dynamic alloca, allocated by :ref:`alloca <i_alloca>`; on the caller's stack. In particular, for targets where stack grows downwards,; adding this offset to the native stack pointer would get the address of the most; recent dynamic alloca. For targets where stack grows upwards, the situation is a bit more; complicated, because subtracting this value from stack pointer would get the address; one past the end of the most recent dynamic alloca. Although for most targets `llvm.get.dynamic.area.offset <int_get_dynamic_area_offset>`; returns just a zero, for others, such as PowerPC and PowerPC64, it returns a; compile-time-known constant value. The return value type of :ref:`llvm.get.dynamic.area.offset <int_get_dynamic_area_offset>`; must match the target's default address space's (address space 0) pointer type. '``llvm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:521898,rout,routines,521898,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['rout'],['routines']
Integrability,"he currently used compiler runtime library; (""libgcc.a"" or ""libclang_rt.builtins.*.a""). .. option:: -print-prog-name=<name>. Print the full program path of name. .. option:: -print-search-dirs. Print the paths used for finding libraries and programs. .. option:: -save-temps. Save intermediate compilation results. .. option:: -save-stats, -save-stats=cwd, -save-stats=obj. Save internal code generation (LLVM) statistics to a file in the current; directory (:option:`-save-stats`/""-save-stats=cwd"") or the directory; of the output file (""-save-state=obj""). You can also use environment variables to control the statistics reporting.; Setting ``CC_PRINT_INTERNAL_STAT`` to ``1`` enables the feature, the report; goes to stdout in JSON format. Setting ``CC_PRINT_INTERNAL_STAT_FILE`` to a file path makes it report; statistics to the given file in the JSON format. Note that ``-save-stats`` take precedence over ``CC_PRINT_INTERNAL_STAT``; and ``CC_PRINT_INTERNAL_STAT_FILE``. .. option:: -integrated-as, -no-integrated-as. Used to enable and disable, respectively, the use of the integrated; assembler. Whether the integrated assembler is on by default is target; dependent. .. option:: -time. Time individual commands. .. option:: -ftime-report. Print timing summary of each stage of compilation. .. option:: -v. Show commands to run and use verbose output. Diagnostics Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -fshow-column, -fshow-source-location, -fcaret-diagnostics, -fdiagnostics-fixit-info, -fdiagnostics-parseable-fixits, -fdiagnostics-print-source-range-info, -fprint-source-range-info, -fdiagnostics-show-option, -fmessage-length. These options control how Clang prints out information about diagnostics; (errors and warnings). Please see the Clang User's Manual for more information. Preprocessor Options; ~~~~~~~~~~~~~~~~~~~~. .. option:: -D<macroname>=<value>. Adds an implicit #define into the predefines buffer which is read before the; source file is preprocessed. .. option:: -U<mac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:18072,integrat,integrated-as,18072,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,2,['integrat'],['integrated-as']
Integrability,"he custom Streamer,; when storing the object in a TTree and in a collection object, use:. ``` {.cpp}; TClass::GetClass(classname)->SetCanSplit(true);; ```. ### I/O Schema Checksum. The algorithm used to calculate a single number giving an indication on whether; the schema layout has changed (i.e. if two StreamerInfo are equivalent) have; been update to. - Use the normalized name for the types (i.e. two different spelling of the same; name will lead to the same checksum); - Take into account the base classes' checksum in the derived class checksum;; this is necessary to properly support base classes during memberwise streaming. The algorithm that checks whether two StreamerInfo are equal even-though their; checksum is different has been significantly enhanced in particular to also; check the base classes. ### TFileMerger. - Added possibility to merge only a list of objects/folders from the; input files, specified by name, \; or to skip them from merging. This is fully integrated with the new; PartialMerge(flags) schema. \; Usage: \; The names of the objects to be merged or skipped have to be; specified using the interface:. ``` {.cpp}; TFileMerger::AddObjectNames(const char *names); ```. This method can be called several times to add object names. Several; names can be added with one call separated by single blancs (no; blanc at the end). Directory names are accepted, applying the; merging selection to all content. Two new options are being; supported for partial merging:. ``` {.cpp}; TFileMerger::PartialMerge(flags | kOnlyListed); ```. This will merge only the objects in the files having the names in; the specified list. If a folder is specified, it whole content will; be merged. ``` {.cpp}; TFileMerger::PartialMerge(flags | kSkipListed); ```. This will skip merging for the specified objects. If a folder is; specified, its whole content will be skipped. Important note:; The kOnlyListed and kSkipListed flags have to be bitwise OR-ed; on top of the merging defaults: kA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v600/index.md:1474,integrat,integrated,1474,io/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v600/index.md,1,['integrat'],['integrated']
Integrability,"he dtor for the contained object; 3. The contained object itself. Note that it is necessary to maintain #1 & #2 in the exception object itself; because objects without virtual function tables may be thrown (as in this ; example). Assuming this, TryHandler would look something like this:. TryHandler: ; Exception *E = getThreadLocalException();; switch (E->RTTIType) {; case IntRTTIInfo:; ...int Stuff... // The action to perform from the catch block; break;; case DoubleRTTIInfo:; ...double Stuff... // The action to perform from the catch block; goto TryCleanup // This catch block rethrows the exception; break; // Redundant, eliminated by the optimizer; default:; goto TryCleanup // Exception not caught, rethrow; }. // Exception was consumed; if (E->dtor); E->dtor(E->object) // Invoke the dtor on the object if it exists; goto EndTry // Continue mainline code... And that is all there is to it. The throw(E) function would then be implemented like this (which may be ; inlined into the caller through standard optimization):. function throw(Exception *E) {; // Get the start of the stack trace...; %frame %f = call getStackCurrentFrame(). // Get the label information that corresponds to it; label * %L = call getFrameLabel(%f); while (%L == 0 && !isFirstFrame(%f)) {; // Loop until a cleanup handler is found; %f = call getNextFrame(%f); %L = call getFrameLabel(%f); }. if (%L != 0) {; call setThreadLocalException(E) // Allow handlers access to this...; call doNonLocalBranch(%L); }; // No handler found!; call BlowUp() // Ends up calling the terminate() method in use; }. That's a brief rundown of how C++ exception handling could be implemented in; llvm. Java would be very similar, except it only uses destructors to unlock; synchronized blocks, not to destroy data. Also, it uses two stack walks: a; nondestructive walk that builds a stack trace, then a destructive walk that; unwinds the stack as shown here. . It would be trivial to get exception interoperability between C++ and Java. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt:7227,synchroniz,synchronized,7227,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt,2,"['interoperab', 'synchroniz']","['interoperability', 'synchronized']"
Integrability,"he event vector itself (`Event` column) as well as the `float` columns `Event.pt` and `Event.eta`. ### RClusterPool; The RClusterPool is an internal class owned be a page source.; The cluster pool maintains an I/O thread that asynchronously prefetches the next few clusters.; Through `RPageSource::SetEntryRange()`, the cluster pool is instructed to not read beyond the given limit.; This is used in the RNTuple data source when multiple threads work on different clusters of the same file. ### RMiniFile; The RMiniFile is an internal class used to read and write RNTuple data in a ROOT file.; It provides a minimal subset of the `TFile` functionality.; Its purpose is to reduce the coupling between RNTuple and the ROOT I/O library. For writing data, the RMiniFile can either use a proper `TFile` (descendant) or a C file stream (only for new ROOT files with a single RNTuple).; For reading, the `RMiniFile` always uses an `RRawFile`. ### RRawFile; The RRawFile internal abstract class provides an interface to read byte ranges from a file, including vector reads.; Concrete implementations exist for local files, XRootD and HTTP (the latter two through the ROOT plugin mechanism).; The local file implementation on Linux uses uring for vector reads, if available.; `RRawFileTFile` wraps an existing `TFile` and provides access to the full set of implementations, e.g. `TMemFile`. Tooling; -------. ### RNTupleMerger; The `RNTupleMerger` is an internal class and part of the core RNTuple library.; It concatenates RNTuple data from several sources into a combined sink.; It implements ""fast merging"", i.e. copy-based merging that does not decompress and recompress pages.; The RNTupler merger is used by the `TFileMerger` and thus provides RNTuple merge support in `hadd` and `TBufferMerger`. ### RNTupleImporter; The RNTupleImporter creates RNTuple data sets from ROOT trees.; It is part of the `ROOTNTupleUtil` library. ### RNTupleInspector; The RNTupleInspector provides insights of an RNTuple, e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:15977,interface,interface,15977,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['interface'],['interface']
Integrability,"he existing SVN repository that; the sub-projects move synchronously, and a single revision number (or commit; hash) identifies the state of the development across all projects. .. _build_single_project:. Building a single sub-project; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Even though there is a single source tree, you are not required to build; all sub-projects together. It is trivial to configure builds for a single; sub-project. For example::. mkdir build && cd build; # Configure only LLVM (default); cmake path/to/monorepo; # Configure LLVM and lld; cmake path/to/monorepo -DLLVM_ENABLE_PROJECTS=lld; # Configure LLVM and clang; cmake path/to/monorepo -DLLVM_ENABLE_PROJECTS=clang. .. _git-svn-mirror:. Outstanding Questions; ---------------------. Read-only sub-project mirrors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. With the Monorepo, it is undecided whether the existing single-subproject; mirrors (e.g. https://git.llvm.org/git/compiler-rt.git) will continue to; be maintained. Read/write SVN bridge; ^^^^^^^^^^^^^^^^^^^^^. GitHub supports a read/write SVN bridge for its repositories. However,; there have been issues with this bridge working correctly in the past,; so it's not clear if this is something that will be supported going forward. Monorepo Drawbacks; ------------------. * Using the monolithic repository may add overhead for those contributing to a; standalone sub-project, particularly on runtimes like libcxx and compiler-rt; that don't rely on LLVM; currently, a fresh clone of libcxx is only 15MB (vs.; 1GB for the monorepo), and the commit rate of LLVM may cause more frequent; `git push` collisions when upstreaming. Affected contributors may be able to; use the SVN bridge or the single-subproject Git mirrors. However, it's; undecided if these projects will continue to be maintained.; * Using the monolithic repository may add overhead for those *integrating* a; standalone sub-project, even if they aren't contributing to it, due to the; same disk space concern as the point ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:10773,bridg,bridge,10773,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['bridg'],['bridge']
Integrability,"he following code in your command prompt:. $ git clone https://github.com/civetweb/civetweb.git; or simply grab a copy of the source code as a ZIP or TGZ file. Quick start documentation; --------------------------. - [docs/Installing.md](https://github.com/civetweb/civetweb/blob/master/docs/Installing.md) - Install Guide (for end users using pre-built binaries); - [docs/UserManual.md](https://github.com/civetweb/civetweb/blob/master/docs/UserManual.md) - End User Guide; - [docs/Building.md](https://github.com/civetweb/civetweb/blob/master/docs/Building.md) - Building the Server (quick start guide); - [docs/Embedding.md](https://github.com/civetweb/civetweb/blob/master/docs/Embedding.md) - Embedding (how to add HTTP support to an existing application); - [docs/OpenSSL.md](https://github.com/civetweb/civetweb/blob/master/docs/OpenSSL.md) - Adding HTTPS (SSL/TLS) support using OpenSSL.; - [API documentation](https://github.com/civetweb/civetweb/tree/master/docs/api) - Additional documentation on the civetweb application programming interface ([civetweb.h](https://github.com/civetweb/civetweb/blob/master/include/civetweb.h)).; - [RELEASE_NOTES.md](https://github.com/civetweb/civetweb/blob/master/RELEASE_NOTES.md) - Release Notes; - [SECURITY.md](https://github.com/civetweb/civetweb/blob/master/SECURITY.md) - Security Policy; - [LICENSE.md](https://github.com/civetweb/civetweb/blob/master/LICENSE.md) - Copyright License. Overview; --------. CivetWeb keeps the balance between functionality and; simplicity by a carefully selected list of features:. - Liberal, commercial-friendly, permissive,; [MIT license](http://en.wikipedia.org/wiki/MIT_License); - Free from copy-left licenses, like GPL, because you should innovate without; restrictions.; - Forked from [Mongoose](https://code.google.com/p/mongoose/) in 2013, before; it changed the licence from MIT to commercial + GPL. A lot of enhancements; have been added since that time, see; [RELEASE_NOTES.md](https://github.com/civet",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:4753,interface,interface,4753,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['interface'],['interface']
Integrability,"he following where ``EltTy`` is the; element type of ``MTy``, ``col`` is the number of columns, ``row`` is the; number of rows in ``MTy`` and ``inner`` is the number of columns of ``M1``:. .. code-block:: c++. MTy Res;; for (int C = 0; C < col; ++C) {; for (int R = 0; R < row; ++R) {; EltTy Elt = 0;; for (int K = 0; K < inner; ++K) {; Elt += M1[R][K] * M2[K][C];; }; Res[R][C] = Elt;; }. All operations on matrix types match the behavior of the element type with; respect to signed overflows. With respect to floating-point contraction, rounding and environment rules,; operations on matrix types match the behavior of the elementwise operations; in the corresponding expansions provided above. Operations on floating-point matrices have the same rounding and floating-point; environment behavior as ordinary floating-point operations in the expression's; context. For the purposes of floating-point contraction, all calculations done; as part of a matrix operation are considered intermediate operations, and their; results need not be rounded to the format of the element type until the final; result in the containing expression. This is subject to the normal restrictions; on contraction, such as ``#pragma STDC FP_CONTRACT``. For the ``+=``, ``-=`` and ``*=`` operators the semantics match their expanded; variants. Matrix Type Builtin Operations; ------------------------------. Each matrix type supports a collection of builtin expressions that look like; function calls but do not form an overload set. Here they are described as; function declarations with rules for how to construct the argument list types; and return type and the library description elements from; [library.description.structure.specifications]/3 in the C++ standard. Definitions:. * *M*, *M1*, *M2*, *M3* - Matrix types; * *T* - Element type; * *row*, *col* - Row and column arguments respectively. ``M2 __builtin_matrix_transpose(M1 matrix)``. **Remarks**: The return type is a cv-unqualified matrix type that has the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:7767,contract,contraction,7767,interpreter/llvm-project/clang/docs/MatrixTypes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst,1,['contract'],['contraction']
Integrability,"he function ""approxfun"" returns a function performing (linear or constant); //interpolation of the given data.; //For a given set of x values, this function will return the corresponding interpolated values.; r<<""f <- approxfun(x, y)"";. r<<""curve(f(x), 0, 11, col = 'green2')"";; r<<""points(x, y)"";. //using approxfun with const method; r<<""fc <- approxfun(x, y, method = 'const')"";; r<<""curve(fc(x), 0, 10, col = 'darkblue', add = TRUE)"";; // different interpolation on left and right side :; r<<""plot(approxfun(x, y, rule = 2:1), 0, 11,col = 'tomato', add = TRUE, lty = 3, lwd = 2)"";; }; ~~~; The image shows the interpolated function plotted within R:; \image html R_image3.png. ## Integration (Passing vectorized function to R); Numerical integration using R passing the function from ROOT. ~~~{.cxx}; #include<TMath.h>; #include<TRInterface.h>; #include<Math/Integrator.h>; #include<TF1.h>. //To integrate using R the function must be vectorized; //The idea is just to receive a vector like an argument,to evaluate; //every element saving the result in another vector; //and return the resultant vector.; std::vector<Double_t> BreitWignerVectorized(std::vector<Double_t> xx); {; std::vector<Double_t> result(xx.size());; for(Int_t i=0;i<xx.size();i++); {; result[i]=TMath::BreitWigner(xx[i]);; }; return result;; }. double BreitWignerWrap( double x){; return TMath::BreitWigner(x);; }. void Integration(); {. ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();. r[""BreitWigner""]=BreitWignerVectorized;. Double_t value=r.Eval(""integrate(BreitWigner, lower = -2, upper = 2)$value"");. std::cout.precision(18);; std::cout<<""Integral of the BreitWigner Function in the interval [-2, 2] R = ""<<value<<std::endl;. ROOT::Math::WrappedFunction<> wf(BreitWignerWrap);; ROOT::Math::Integrator i(wf);; value=i.Integral(-2,2);; std::cout<<""Integral of the BreitWigner Function in the interval [-2, 2] MathMore = ""<<value<<std::endl;. TF1 f1(""BreitWigner"",""BreitWignerWrap(x)"");; value=f1.Integral(-2,2);;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md:22412,integrat,integrate,22412,bindings/r/doc/users-guide/ROOTR_Users_Guide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md,1,['integrat'],['integrate']
Integrability,"he local parameter variable, transferring; ownership of that copy to the callee is generally better for ARC; optimization, since otherwise there will be releases in the caller; that are much harder to pair with transfers in the callee. Breaking compatibility with existing Objective-C++ structures was; considered an acceptable cost, as most Objective-C++ code does not have; binary-compatibility requirements. Any existing code which cannot accept; this compatibility break, which is necessarily Objective-C++, should; force the use of the standard C++ ABI by declaring an empty (but; non-defaulted) destructor. .. _arc.ownership.inference:. Ownership inference; -------------------. .. _arc.ownership.inference.variables:. Objects; ^^^^^^^. If an object is declared with retainable object owner type, but without an; explicit ownership qualifier, its type is implicitly adjusted to have; ``__strong`` qualification. As a special case, if the object's base type is ``Class`` (possibly; protocol-qualified), the type is adjusted to have ``__unsafe_unretained``; qualification instead. .. _arc.ownership.inference.indirect_parameters:. Indirect parameters; ^^^^^^^^^^^^^^^^^^^. If a function or method parameter has type ``T*``, where ``T`` is an; ownership-unqualified retainable object pointer type, then:. * if ``T`` is ``const``-qualified or ``Class``, then it is implicitly; qualified with ``__unsafe_unretained``;; * otherwise, it is implicitly qualified with ``__autoreleasing``. .. admonition:: Rationale. ``__autoreleasing`` exists mostly for this case, the Cocoa convention for; out-parameters. Since a pointer to ``const`` is obviously not an; out-parameter, we instead use a type more useful for passing arrays. If the; user instead intends to pass in a *mutable* array, inferring; ``__autoreleasing`` is the wrong thing to do; this directs some of the; caution in the following rules about writeback. Such a type written anywhere else would be ill-formed by the general rule; requiring own",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:65054,protocol,protocol-qualified,65054,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['protocol'],['protocol-qualified']
Integrability,"he master to enable the parallel startup of workers using threads; set next to ""`yes`"" (default is ""`no`""):. ``` {.cpp}; Proof.ParallelStartup: no; ```. ``` {.cpp}; Proof.StatsHist: no; Proof.StatsTrace: no; Proof.SlaveStatsTrace: no; ```. ``` {.cpp}; Proof.CondorHome: /opt/condor; Proof.CondorConfig: /opt/condor/etc/condor_config; ```. ``` {.cpp}; PEAC.GmUrl: http://somewhere:8080/clarens/; PEAC.LmUrl: http://elsewhere:8080/clarens/; ```. #### Server Authentication in TServerSocket. General setting: file with server access rules. ``` {.cpp}; SrvAuth.DaemonRc: /etc/root/system.daemonrc; ```. Check of host equivalence via `/etc/hosts`.`equiv` or `$HOME/.rhosts`. ``` {.cpp}; SrvAuth.CheckHostsEquivalence: 1; ```. Force file opening via **`TNetFile`** (**`TNetXNGFile`**) if a hostname is; specified in the Url. By default, for local files `TFile::Open()`; invokes directly **`TFile.`**. ``` {.cpp}; TFile.ForceRemote: yes; ```. Special cases for the **`TUrl`** parser, where the special cases are; parsed in a protocol + file part, like rfio:host:/path/file.root,; castor:/path/file.root or /alien/path/file.root. In case the file; namespace descriptor ends with - the namespace is not a part of the; filename. Extend in private .rootrc with a +Url.Special line. ``` {.cpp}; Url.Special: file: rfio: hpss: castor: dcache:; +Url.Special: /alien/- /castor/; ```. #### PROOF XRD Client Variables. Debug level (if \<=0 : none, 1 : low, 2 : medium, 3 : high). ``` {.cpp}; XProof.Debug: 0; ```. Socket read timeout [in secs: default 10 secs]. ``` {.cpp}; XProof.ReadTimeout: 10; ```. `XNet.PrintTAG` - Print a particular string the developers can choose to; quickly recognize the version at run time [default - 0]. Example of custom setting for the Rint application (root.exe). This; overrides the default specified above for a generic application. Color 5; is yellow. ``` {.cpp}; Rint.Canvas.HighLightColor: 5; ```. ## Documentation to Download. - The latest ROOT Users Guide. - <https://root.cern.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:14680,protocol,protocol,14680,documentation/users-guide/InstallandBuild.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md,1,['protocol'],['protocol']
Integrability,"he new flag `RSnapshotOption::fOverwriteIfExists` to `true` to force the deletion of the TTree that is; already present and the writing of a new TTree with the same name. See; [ROOT-10573](https://sft.its.cern.ch/jira/browse/ROOT-10573) for more details.; - RDataFrame changed its error handling strategy in case of unreadable input files. Instead of simply logging an error; and skipping the file, it now throws an exception if any of the input files is unreadable (this could also happen in; the middle of an event loop). See [ROOT-10549](https://sft.its.cern.ch/jira/browse/ROOT-10549) for more details.; - New analysis examples based on the recent ATLAS Open Data release ([`Higgs to two photons`](https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html), [`W boson analysis`](https://root.cern/doc/master/df105__WBosonAnalysis_8py.html), [`Higgs to four leptons`](https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html)); - An exception is now thrown in case the size of ROOT's thread-pool changes between RDataFrame construction time and the time the event loop begins.; - Just-in-time compilation of large portions of the computation graph has been optimized, and it is now much faster. Please report any regressions you might encounter on [our issue tracker](https://sft.its.cern.ch/jira/projects/ROOT).; - `MakeRootDataFrame` is now a safe way to construct RDFs. It used to return RDFs with more limited functionality. ## PyROOT. - Introduce the `ROOT.Numba.Declare` decorator which provides a simple way to call Python callables from C++. The Python callables are; just-in-time compiled with [numba](http://numba.pydata.org/), which ensures a runtime performance similar to a C++ implementation.; The feature is targeted to improve the performance of Python based analyses, e.g., allows seamless integration into `RDataFrame` workflows.; See the tutorial [`pyroot004_NumbaDeclare.py`](https://root.cern/doc/master/pyroot004__NumbaDeclare_8py.html) for further information.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:11267,integrat,integration,11267,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['integrat'],['integration']
Integrability,"he non-vectorizable part (which otherwise would make the entire; loop non-vectorizable). Conceptually, it transforms a loop such as. .. code-block:: c. for (int i = 1; i < n; i+=1) { // original loop; A[i] = i;; B[i] = 2 + B[i];; C[i] = 3 + C[i - 1];; }. into the following code:. .. code-block:: c. if (rtc) {; for (int i = 1; i < n; i+=1) // coincident loop; A[i] = i;; for (int i = 1; i < n; i+=1) // coincident loop; B[i] = 2 + B[i];; for (int i = 1; i < n; i+=1) // sequential loop; C[i] = 3 + C[i - 1];; } else {; for (int i = 1; i < n; i+=1) { // fallback loop; A[i] = i;; B[i] = 2 + B[i];; C[i] = 3 + C[i - 1];; }; }. where ``rtc`` is a generated runtime check. ``llvm.loop.distribute.followup_coincident`` sets the loop attributes of; all loops without loop-carried dependencies (i.e. vectorizable loops).; There might be more than one such loops. If not defined, the loops will; inherit the original loop's attributes. ``llvm.loop.distribute.followup_sequential`` sets the loop attributes of the; loop with potentially unsafe dependencies. There should be at most one; such loop. If not defined, the loop will inherit the original loop's; attributes. ``llvm.loop.distribute.followup_fallback`` defines the loop attributes; for the fallback loop, which is a copy of the original loop for when; loop versioning is required. If undefined, the fallback loop inherits; all attributes from the original loop. Attributes defined in ``llvm.loop.distribute.followup_all`` are added to; all of the aforementioned output loops. It is recommended to add ``llvm.loop.disable_nonforced`` to; ``llvm.loop.distribute.followup_fallback``. This avoids that the; fallback version (which is likely never executed) is further optimized; which would increase the code size. Versioning LICM; ---------------. The pass hoists code out of loops that are only loop-invariant when; dynamic conditions apply. For instance, it transforms the loop. .. code-block:: c. for (int i = 0; i < n; i+=1) // original loop; A[i] =",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:12019,depend,dependencies,12019,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['depend'],['dependencies']
Integrability,"he other hand, in ``void foo(int; **)``, the parameter type is a pointer to ``int *__single`` (i.e., ``void; foo(int *__single *__single)``) (or a pointer to ``int *__unsafe_indexable`` if; it's from a system header). The compiler reports an error for casts between; pointers whose elements have incompatible pointer attributes. This way,; ``-fbounds-safety`` prevents pointers that are implicitly ``__bidi_indexable``; from silently escaping thereby breaking the ABI. .. code-block:: c. void foo(int **);. void bar(void) {; int *local = 0;; // error: passing 'int *__bidi_indexable*__bidi_indexable' to parameter of; // incompatible nested pointer type 'int *__single*__single'; foo(&local);; }. A local variable may still be exposed to the ABI if ``typeof()`` takes the type; of local variable to define an interface as shown in the following example. .. code-block:: C. // bar.c; void bar(int *) { ... }. // foo.c; void foo(void) {; int *p; // implicitly `int *__bidi_indexable p`; extern void bar(typeof(p)); // creates an interface of type; // `void bar(int *__bidi_indexable)`; }. Doing this may break the ABI if the parameter is not ``__bidi_indexable`` at the; definition of function ``bar()`` which is likely the case because parameters are; ``__single`` by default without an explicit annotation. In order to avoid an implicitly wide pointer from silently breaking the ABI, the; compiler reports a warning when ``typeof()`` is used on an implicit wide pointer; at any ABI visible context (e.g., function prototype, struct definition, etc.). .. _Default pointer types in typeof:. Default pointer types in ``typeof()``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When ``typeof()`` takes an expression, it respects the bounds annotation on; the expression type, including the bounds annotation is implcit. For example,; the global variable ``g`` in the following code is implicitly ``__single`` so; ``typeof(g)`` gets ``char *__single``. The similar is true for the parameter; ``p``, so ``typeof(p)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:24841,interface,interface,24841,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['interface'],['interface']
Integrability,"he section on; :ref:`modules <pchinternals-modules>`. Clang's AST files are designed with a compact on-disk representation, which; minimizes both creation time and the time required to initially load the AST; file. The AST file itself contains a serialized representation of Clang's; abstract syntax trees and supporting data structures, stored using the same; compressed bitstream as `LLVM's bitcode file format; <https://llvm.org/docs/BitCodeFormat.html>`_. Clang's AST files are loaded ""lazily"" from disk. When an AST file is initially; loaded, Clang reads only a small amount of data from the AST file to establish; where certain important data structures are stored. The amount of data read in; this initial load is independent of the size of the AST file, such that a; larger AST file does not lead to longer AST load times. The actual header data; in the AST file --- macros, functions, variables, types, etc. --- is loaded; only when it is referenced from the user's code, at which point only that; entity (and those entities it depends on) are deserialized from the AST file.; With this approach, the cost of using an AST file for a translation unit is; proportional to the amount of code actually used from the AST file, rather than; being proportional to the size of the AST file itself. When given the `-print-stats` option, Clang produces statistics; describing how much of the AST file was actually loaded from disk. For a; simple ""Hello, World!"" program that includes the Apple ``Cocoa.h`` header; (which is built as a precompiled header), this option illustrates how little of; the actual precompiled header is required:. .. code-block:: none. *** AST File Statistics:; 895/39981 source location entries read (2.238563%); 19/15315 types read (0.124061%); 20/82685 declarations read (0.024188%); 154/58070 identifiers read (0.265197%); 0/7260 selectors read (0.000000%); 0/30842 statements read (0.000000%); 4/8400 macros read (0.047619%); 1/4995 lexical declcontexts read (0.020020%);",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:3966,depend,depends,3966,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['depend'],['depends']
Integrability,"he sequence of '1' and '0' bits in the mask. E.g., if the mask vector is '10010001', ""expandload"" reads 3 values from memory addresses ptr, ptr+1, ptr+2 and places them in lanes 0, 3 and 7 accordingly. The masked-off lanes are filled by elements from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is the base pointer for the load. It has the same underlying type as the element of the returned vector. The second operand, mask, is a vector of boolean values with the same number of elements as the return type. The third is a pass-through value that is used to fill the masked-off lanes of the result. The return type and the type of the '``passthru``' operand have the same vector type. Semantics:; """""""""""""""""""". The '``llvm.masked.expandload``' intrinsic is designed for reading multiple scalar values from adjacent memory addresses into possibly non-adjacent vector lanes. It is useful for targets that support vector expanding loads and allows vectorizing loop with cross-iteration dependency like in the following example:. .. code-block:: c. // In this loop we load from B and spread the elements into array A.; double *A, B; int *C;; for (int i = 0; i < size; ++i) {; if (C[i] != 0); A[i] = B[j++];; }. .. code-block:: llvm. ; Load several elements from array B and expand them in a vector.; ; The number of loaded elements is equal to the number of '1' elements in the Mask.; %Tmp = call <8 x double> @llvm.masked.expandload.v8f64(ptr %Bptr, <8 x i1> %Mask, <8 x double> poison); ; Store the result in A; call void @llvm.masked.store.v8f64.p0(<8 x double> %Tmp, ptr %Aptr, i32 8, <8 x i1> %Mask). ; %Bptr should be increased on each iteration according to the number of '1' elements in the Mask.; %MaskI = bitcast <8 x i1> %Mask to i8; %MaskIPopcnt = call i8 @llvm.ctpop.i8(i8 %MaskI); %MaskI64 = zext i8 %MaskIPopcnt to i64; %BNextInd = add i64 %BInd, %MaskI64. Other targets may support this intrinsic differently, for example, by lowering it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:857017,depend,dependency,857017,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['dependency']
Integrability,"he similar is true for the parameter; ``p``, so ``typeof(p)`` returns ``void *__single``. The local variable ``l`` is; implicitly ``__bidi_indexable``, so ``typeof(l)`` becomes; ``int *__bidi_indexable``. .. code-block:: C. char *g; // typeof(g) == char *__single. void foo(void *p) {; // typeof(p) == void *__single. int *l; // typeof(l) == int *__bidi_indexable; }. When the type of expression has an ""external"" bounds annotation, e.g.,; ``__sized_by``, ``__counted_by``, etc., the compiler may report an error on; ``typeof`` if the annotation creates a dependency with another declaration or; variable. For example, the compiler reports an error on ``typeof(p1)`` shown in; the following code because allowing it can potentially create another type; dependent on the parameter ``size`` in a different context (Please note that an; external bounds annotation on a parameter may only refer to another parameter of; the same function). On the other hand, ``typeof(p2)`` works resulting in ``int; *__counted_by(10)``, since it doesn't depend on any other declaration. .. TODO: add a section describing constraints on external bounds annotations. .. code-block:: C. void foo(int *__counted_by(size) p1, size_t size) {; // typeof(p1) == int *__counted_by(size); // -> a compiler error as it tries to create another type; // dependent on `size`. int *__counted_by(10) p2; // typeof(p2) == int *__counted_by(10); // -> no error. }. When ``typeof()`` takes a type name, the compiler doesn't apply an implicit; bounds annotation on the named pointer types. For example, ``typeof(int*)``; returns ``int *`` without any bounds annotation. A bounds annotation may be; added after the fact depending on the context. In the following example,; ``typeof(int *)`` returns ``int *`` so it's equivalent as the local variable is; declared as ``int *l``, so it eventually becomes implicitly; ``__bidi_indexable``. .. code-block:: c. void foo(void) {; typeof(int *) l; // `int *__bidi_indexable` (same as `int *l`); }. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:26790,depend,depend,26790,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['depend'],['depend']
Integrability,"he specified flags will generate four intermediate bytecode files:. #. a.out.0.0.preopt.bc (Before any link-time optimizations (LTO) are applied); #. a.out.0.2.internalize.bc (After initial optimizations are applied); #. a.out.0.4.opt.bc (After an extensive set of optimizations); #. a.out.0.5.precodegen.bc (After LTO but before translating into machine code). Execute one of the following commands to identify the source of the problem:. #. ``opt ""-passes=lto<O3>"" a.out.0.2.internalize.bc``; #. ``llc a.out.0.5.precodegen.bc``. If one of these do crash, you should be able to reduce; this with :program:`llvm-reduce`; command line (use the bc file corresponding to the command above that failed):. .. code-block:: bash. llvm-reduce --test reduce.sh a.out.0.2.internalize.bc. Example of reduce.sh script. .. code-block:: bash. $ cat reduce.sh; #!/bin/bash -e. path/to/not --crash path/to/opt ""-passes=lto<O3>"" $1 -o temp.bc 2> err.log; grep -q ""It->second == &Insn"" err.log. Here we have grepped the failed assert message. Please run this, then file a bug with the instructions and reduced .bc file; that llvm-reduce emits. .. _miscompiling:. Miscompilations; ===============. If clang successfully produces an executable, but that executable doesn't run; right, this is either a bug in the code or a bug in the compiler. The first; thing to check is to make sure it is not using undefined behavior (e.g.; reading a variable before it is defined). In particular, check to see if the; program is clean under various `sanitizers; <https://github.com/google/sanitizers>`_ (e.g. ``clang; -fsanitize=undefined,address``) and `valgrind <http://valgrind.org/>`_. Many; ""LLVM bugs"" that we have chased down ended up being bugs in the program being; compiled, not LLVM. Once you determine that the program itself is not buggy, you should choose; which code generator you wish to compile the program with (e.g. LLC or the JIT); and optionally a series of LLVM passes to run. For example:. .. code-block:: bas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst:7814,message,message,7814,interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,1,['message'],['message']
Integrability,"he text representation (IFS) of a shared object produced; by the :program:`llvm-ifs`:. ::. --- !ifs-v1; IFSVersion: 3.0; SoName: libtest.so /* Optional */; Target: x86_64-unknown-linux-gnu /* Optional, format 1, same format as llvm target triple */; Target: { Arch: x86_64, Endianness: little, Bitwidth: 64 } /* Optional, format 2 */; NeededLibs:; - libc.so.6; Symbols:; - { Name: sym0, Type: Notype }; - { Name: sym1, Type: Object, Size: 0 }; - { Name: sym2, Type: Func, Weak: false }; - { Name: sym3, Type: TLS }; - { Name: sym4, Type: Unknown, Warning: foo }; ... * ``IFSVersion``: Version of the IFS file for reader compatibility. * ``SoName`` (optional): Name of the shared object file that is being stubbed. * ``Target`` (optional): The architecture, endianness and bitwise information of; this shared object. It can be either in explicit format or in implicit LLVM; triple format. It can be optional and can be overridden from command line; options. * ``NeededLibs``: The list of the external shared objects that this library depends on. * ``Symbols``: A collection of all data needed to link objects for each symbol, sorted by name in ascending order. + ``Name``: Symbol name. + ``Type``: Whether the symbol is an object, function, no-type, thread local storage, or unknown. Symbol types not explicitly supported are mapped as unknown to improve signal-to-noise ratio. + ``Size``: The size of the symbol in question, doesn't apply to functions, and is optional for NoType symbols. + ``Undefined``: Whether or not the symbol is defined in this shared object file. + ``Weak``: Whether or not the symbol should be treated as weak. + ``Warning`` (optional): Warning text to output when this symbol is linked against. This YAML based text format contains everything that is needed to generate a; linkable ELF shared object as well as an Apple TAPI format file. The ordering; of symbols is sorted, so these files can be easily compared using diff tools.; If the content of the file changes, it indi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ifs.rst:1695,depend,depends,1695,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ifs.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ifs.rst,1,['depend'],['depends']
Integrability,"he version info is provided by the ``LLVM_REVISION`` macro in; ``llvm/include/llvm/Support/VCSRevision.h``. Developers using git who don't; need revision info can disable this option to avoid re-linking most binaries; after a branch switch. Defaults to ON. **LLVM_FORCE_VC_REVISION**:STRING; Force a specific Git revision id rather than calling to git to determine it.; This is useful in environments where git is not available or non-functional; but the VC revision is available through other means. **LLVM_FORCE_VC_REPOSITORY**:STRING; Set the git repository to include in version info rather than calling git to; determine it. **LLVM_BUILD_32_BITS**:BOOL; Build 32-bit executables and libraries on 64-bit systems. This option is; available only on some 64-bit Unix systems. Defaults to OFF. **LLVM_BUILD_BENCHMARKS**:BOOL; Adds benchmarks to the list of default targets. Defaults to OFF. **LLVM_BUILD_DOCS**:BOOL; Adds all *enabled* documentation targets (i.e. Doxgyen and Sphinx targets) as; dependencies of the default build targets. This results in all of the (enabled); documentation targets being as part of a normal build. If the ``install``; target is run then this also enables all built documentation targets to be; installed. Defaults to OFF. To enable a particular documentation target, see; see LLVM_ENABLE_SPHINX and LLVM_ENABLE_DOXYGEN. **LLVM_BUILD_EXAMPLES**:BOOL; Build LLVM examples. Defaults to OFF. Targets for building each example are; generated in any case. See documentation for *LLVM_BUILD_TOOLS* above for more; details. **LLVM_BUILD_INSTRUMENTED_COVERAGE**:BOOL; If enabled, `source-based code coverage; <https://clang.llvm.org/docs/SourceBasedCodeCoverage.html>`_ instrumentation; is enabled while building llvm. If CMake can locate the code coverage; scripts and the llvm-cov and llvm-profdata tools that pair to your compiler,; the build will also generate the `generate-coverage-report` target to generate; the code coverage report for LLVM, and the `clear-profile-da",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:14123,depend,dependencies,14123,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['depend'],['dependencies']
Integrability,"he; MnUserParameterState. ### Access values, errors, covariance ###. The result can be accessed via methods like; MnUserParameterState::value(unsigned int n) and; MnUserParameterState::error(unsigned int n), where $n$ is the index of; the parameter in the list of parameters defined by the user. ### Printout of the result ###. The FunctionMinimum can be printed on the output simply via std::cout.; It will print both the internal and external state, that is parameters,; errors and the covariance matrix (if available). It also tells the user; if M did converge or not by issuing an appropriate message. If a; covariance matrix is available, the global correlation coefficients are; printed as well. ### Global correlation coefficients ###. The global correlation coefficient for parameter $n$ is a number between; zero and one which gives the correlation between parameter $n$ and that; linear combination of all other parameters which is most strongly; correlated with $n$. # M application programming interface (API) #. [api:api]. ## FunctionMinimum ##. [api:fm] The FunctionMinimum is the output of the minimizers and; contains the minimization result. The state at the minimum is available; both in internal and external representations. For the external; representations the return methods. - FunctionMinimum::userState(),. - FunctionMinimum::userParameters() and. - FunctionMinimum::userCovariance(). are provided. These can be used as new input to a new minimization after; some manipulation. The parameters and/or the FunctionMinimum can be; printed using std::cout. ### isValid() ###. In general, if the method bool FunctionMinimum::isValid() returns; ""true"", the minimizer did find a minimum without running into troubles.; However, in some cases it may happen that a minimum cannot be found,; then the return value will be ""false"". Reasons for the minimization to; fail are. - the number of allowed function calls has been exhausted. - the minimizer could not improve the values of the p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:37035,interface,interface,37035,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['interface'],['interface']
Integrability,"he; point of evaluation of the return statement, before leaving all local scopes. When receiving a return result from such a function or method, ARC releases the; value at the end of the full-expression it is contained within, subject to the; usual optimizations for local values. .. admonition:: Rationale. This formalizes direct transfers of ownership from a callee to a caller. The; most common scenario this models is the retained return from ``init``,; ``alloc``, ``new``, and ``copy`` methods, but there are other cases in the; frameworks. After optimization there are typically no extra retains and; releases required. Methods in the ``alloc``, ``copy``, ``init``, ``mutableCopy``, and ``new``; :ref:`families <arc.method-families>` are implicitly marked; ``__attribute__((ns_returns_retained))``. This may be suppressed by explicitly; marking the method ``__attribute__((ns_returns_not_retained))``. It is undefined behavior if the method to which an Objective-C message send; statically resolves has different retain semantics on its result from the; method it dynamically resolves to. It is undefined behavior if a block or; function call is made through a static type with different retain semantics on; its result from the implementation of the called block or function. .. admonition:: Rationale. Mismatches with returned results will cause over-retains or over-releases,; depending on the direction. Again, the rule about function calls is really; just an application of the existing C/C++ rule about calling functions; through an incompatible function type. .. _arc.objects.operands.unretained-returns:. Unretained return values; ^^^^^^^^^^^^^^^^^^^^^^^^. A method or function which returns a retainable object type but does not return; a retained value must ensure that the object is still valid across the return; boundary. When returning from such a function or method, ARC retains the value at the; point of evaluation of the return statement, then leaves all local scopes, and; the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:20639,message,message,20639,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"heir inclusion through; ``lib/Support`` interfaces. High Level Interface; --------------------. The entry points specified in the interface of ``lib/Support`` must be aimed at; completing some reasonably high level task needed by LLVM. We do not want to; simply wrap each operating system call. It would be preferable to wrap several; operating system calls that are always used in conjunction with one another by; LLVM. For example, consider what is needed to execute a program, wait for it to; complete, and return its result code. On Unix, this involves the following; operating system calls: ``getenv``, ``fork``, ``execve``, and ``wait``. The; correct thing for ``lib/Support`` to provide is a function, say; ``ExecuteProgramAndWait``, that implements the functionality completely. what; we don't want is wrappers for the operating system calls involved. There must **not** be a one-to-one relationship between operating system; calls and the Support library's interface. Any such interface function will be; suspicious. No Unused Functionality; -----------------------. There must be no functionality specified in the interface of ``lib/Support``; that isn't actually used by LLVM. We're not writing a general purpose operating; system wrapper here, just enough to satisfy LLVM's needs. And, LLVM doesn't; need much. This design goal aims to keep the ``lib/Support`` interface small and; understandable which should foster its actual use and adoption. No Duplicate Implementations; ----------------------------. The implementation of a function for a given platform must be written exactly; once. This implies that it must be possible to apply a function's; implementation to multiple operating systems if those operating systems can; share the same implementation. This rule applies to the set of operating; systems supported for a given class of operating system (e.g. Unix, Win32). No Virtual Methods; ------------------. The Support Library interfaces can be called quite frequently by LLVM.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:4830,interface,interface,4830,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interface']
Integrability,"hen the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointer is not null) prior to performing; some action that depends on that condition (e.g., dereferencing a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does not support; these attributes on Objective-C methods and C++ methods.; Attribute 'noreturn'; The 'noreturn' attribute is a GCC-attribute that can be placed on the; declarations of functions. It means exactly what its name implies: a function; with a 'noreturn' attribute should never return.; Specific details of the syntax of using the 'noreturn' attribute can be found; in GCC's; documentation.; Not only does the analyzer exploit this information when pruning false paths,; but the compiler also takes it seriously and will generate different code (and; possibly better optimized) under the assumption that the function does not; re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:21423,depend,depends,21423,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['depend'],['depends']
Integrability,"her; does the same job as `scan-build` does. So, you can expect the same output; from this line as simple `scan-build` would do:. $ intercept-build <your build command> && analyze-build. The major difference is how and when the analyzer is run. The `scan-build`; tool has three distinct model to run the analyzer:. 1. Use compiler wrappers to make actions.; The compiler wrappers does run the real compiler and the analyzer.; This is the default behaviour, can be enforced with `--override-compiler`; flag. 2. Use special library to intercept compiler calls during the build process.; The analyzer run against each modules after the build finished.; Use `--intercept-first` flag to get this model. 3. Use compiler wrappers to intercept compiler calls during the build process.; The analyzer run against each modules after the build finished.; Use `--intercept-first` and `--override-compiler` flags together to get; this model. The 1. and 3. are using compiler wrappers, which works only if the build; process respects the `CC` and `CXX` environment variables. (Some build; process can override these variable as command line parameter only. This case; you need to pass the compiler wrappers manually. eg.: `intercept-build; --override-compiler make CC=intercept-cc CXX=intercept-c++ all` where the; original build command would have been `make all` only.). The 1. runs the analyzer right after the real compilation. So, if the build; process removes removes intermediate modules (generated sources) the analyzer; output still kept. The 2. and 3. generate the compilation database first, and filters out those; modules which are not exists. So, it's suitable for incremental analysis during; the development. The 2. mode is available only on FreeBSD and Linux. Where library preload; is available from the dynamic loader. Not supported on OS X (unless System; Integrity Protection feature is turned off). `intercept-build` command uses only the 2. and 3. mode to generate the; compilation database. `a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/README.md:2933,wrap,wrappers,2933,interpreter/llvm-project/clang/tools/scan-build-py/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/README.md,1,['wrap'],['wrappers']
Integrability,"here a variable takes a particular value. Similarly, Assignment Tracking; marks out the position of assignments with a new intrinsic called; `llvm.dbg.assign`. In order to know where in IR it is appropriate to use a memory location for a; variable, each assignment marker must in some way refer to the store, if any; (or multiple!), that performs the assignment. That way, the position of the; store and marker can be considered together when making that choice. Another; important benefit of referring to the store is that we can then build a two-way; mapping of stores<->markers that can be used to find markers that need to be; updated when stores are modified. An `llvm.dbg.assign` marker that is not linked to any instruction signals that; the store that performed the assignment has been optimised out, and therefore; the memory location will not be valid for at least some part of the program. Here's the `llvm.dbg.assign` signature. Each parameter is wrapped in; `MetadataAsValue`, and `Value *` type parameters are first wrapped in; `ValueAsMetadata`:. ```; void @llvm.dbg.assign(Value *Value,; DIExpression *ValueExpression,; DILocalVariable *Variable,; DIAssignID *ID,; Value *Address,; DIExpression *AddressExpression); ```. The first three parameters look and behave like an `llvm.dbg.value`. `ID` is a; reference to a store (see next section). `Address` is the destination address; of the store and it is modified by `AddressExpression`. An empty/undef/poison; address means the address component has been killed (the memory address is no; longer a valid location). LLVM currently encodes variable fragment information; in `DIExpression`s, so as an implementation quirk the `FragmentInfo` for; `Variable` is contained within `ValueExpression` only. The formal LLVM-IR signature is:; ```; void @llvm.dbg.assign(metadata, metadata, metadata, metadata, metadata, metadata); ```. ### Instruction link: `DIAssignID`. `DIAssignID` metadata is the mechanism that is currently used to encode the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:2787,wrap,wrapped,2787,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,2,['wrap'],['wrapped']
Integrability,"here are different ways that the wavefront scratch base address is determined; by a wavefront (see :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). This; memory can be accessed in an interleaved manner using buffer instruction with; the scratch buffer descriptor and per wavefront scratch offset, by the scratch; instructions, or by flat instructions. If each lane of a wavefront accesses the; same private address, the interleaving results in adjacent dwords being accessed; and hence requires fewer cache lines to be fetched. Multi-dword access is not; supported except by flat and scratch instructions in GFX9-GFX11. The generic address space uses the hardware flat address support available in; GFX7-GFX11. This uses two fixed ranges of virtual addresses (the private and; local apertures), that are outside the range of addressible global memory, to; map from a flat address to a private or local address. FLAT instructions can take a flat address and access global, private (scratch); and group (LDS) memory depending on if the address is within one of the; aperture ranges. Flat access to scratch requires hardware aperture setup and; setup in the kernel prologue (see; :ref:`amdgpu-amdhsa-kernel-prolog-flat-scratch`). Flat access to LDS requires; hardware aperture setup and M0 (GFX7-GFX8) register setup (see; :ref:`amdgpu-amdhsa-kernel-prolog-m0`). To convert between a segment address and a flat address the base address of the; apertures address can be used. For GFX7-GFX8 these are available in the; :ref:`amdgpu-amdhsa-hsa-aql-queue` the address of which can be obtained with; Queue Ptr SGPR (see :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). For; GFX9-GFX11 the aperture base addresses are directly available as inline constant; registers ``SRC_SHARED_BASE/LIMIT`` and ``SRC_PRIVATE_BASE/LIMIT``. In 64 bit; address mode the aperture sizes are 2^32 bytes and the base is aligned to 2^32; which makes it easier to convert from flat to segment or segment to flat. Image and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:155749,depend,depending,155749,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['depend'],['depending']
Integrability,"hes int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropertyDecl>, Matcher<TemplateArgumentLoc>,; Matcher<TypedefNameDecl>. Matcher<CXXUnresolvedConstructExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<CXXUnresolvedConstructExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a constructor; call expression. Example matches y in x(y); (matcher = callExpr(hasArgument(0, declRefExpr()))); void x(int) { int y; x(y); }. Matcher<CXXUnresolvedConstructExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:170823,interface,interface,170823,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['interface'],['interface']
Integrability,"hidden_global_offset_z""; The OpenCL grid dispatch; global offset for the Z; dimension is passed in the; kernarg. ""hidden_none""; An argument that is not used; by the kernel. Space needs to; be left for it, but it does; not need to be set up. ""hidden_printf_buffer""; A global address space pointer; to the runtime printf buffer; is passed in kernarg. Mutually; exclusive with; ""hidden_hostcall_buffer""; before Code Object V5. ""hidden_hostcall_buffer""; A global address space pointer; to the runtime hostcall buffer; is passed in kernarg. Mutually; exclusive with; ""hidden_printf_buffer""; before Code Object V5. ""hidden_default_queue""; A global address space pointer; to the OpenCL device enqueue; queue that should be used by; the kernel by default is; passed in the kernarg. ""hidden_completion_action""; A global address space pointer; to help link enqueued kernels into; the ancestor tree for determining; when the parent kernel has finished. ""hidden_multigrid_sync_arg""; A global address space pointer for; multi-grid synchronization is; passed in the kernarg. "".value_type"" string Unused and deprecated. This should no longer; be emitted, but is accepted for compatibility. "".pointee_align"" integer Alignment in bytes of pointee; type for pointer type kernel; argument. Must be a power; of 2. Only present if; "".value_kind"" is; ""dynamic_shared_pointer"".; "".address_space"" string Kernel argument address space; qualifier. Only present if; "".value_kind"" is ""global_buffer"" or; ""dynamic_shared_pointer"". Values; are:. - ""private""; - ""global""; - ""constant""; - ""local""; - ""generic""; - ""region"". .. TODO::. Is ""global_buffer"" only ""global""; or ""constant""? Is; ""dynamic_shared_pointer"" always; ""local""? Can HCC allow ""generic""?; How can ""private"" or ""region""; ever happen?. "".access"" string Kernel argument access; qualifier. Only present if; "".value_kind"" is ""image"" or; ""pipe"". Values; are:. - ""read_only""; - ""write_only""; - ""read_write"". .. TODO::. Does this apply to; ""global_buffer""?. "".actual_access"" ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:138771,synchroniz,synchronization,138771,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronization']
Integrability,"his allows dynamic types of nodes. But the YAML I/O model uses; static typing, so there are limits to how you can use tags with the YAML I/O; model. Recently, we added support to YAML I/O for checking/setting the optional; tag on a map. Using this functionality it is even possible to support different; mappings, as long as they are convertible. To check a tag, inside your mapping() method you can use io.mapTag() to specify; what the tag should be. This will also add that tag when writing yaml. Validation; ----------. Sometimes in a YAML map, each key/value pair is valid, but the combination is; not. This is similar to something having no syntax errors, but still having; semantic errors. To support semantic level checking, YAML I/O allows; an optional ``validate()`` method in a MappingTraits template specialization. When parsing YAML, the ``validate()`` method is call *after* all key/values in; the map have been processed. Any error message returned by the ``validate()``; method during input will be printed just a like a syntax error would be printed.; When writing YAML, the ``validate()`` method is called *before* the YAML; key/values are written. Any error during output will trigger an ``assert()``; because it is a programming error to have invalid struct values. .. code-block:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. struct Stuff {; ...; };. template <>; struct MappingTraits<Stuff> {; static void mapping(IO &io, Stuff &stuff) {; ...; }; static std::string validate(IO &io, Stuff &stuff) {; // Look at all fields in 'stuff' and if there; // are any bad values return a string describing; // the error. Otherwise return an empty string.; return std::string{};; }; };. Flow Mapping; ------------; A YAML ""flow mapping"" is a mapping that uses the inline notation; (e.g { x: 1, y: 0 } ) when written to YAML. To specify that a type should be; written in YAML using flow mapping, your MappingTraits specialization should; add ""static const bool flow = true;"".",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:23463,message,message,23463,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['message'],['message']
Integrability,"his new version provides all the functionality present in the old; FORTRAN version, with almost equivalent numerical accuracy and; computational performances.; Furthermore, it contains some fixes and small improvements and this new functionality:; * The possibility to set single side parameter limits; * the FUMILI algorithm (see the next paragraph ""FUMILI Minimization Package""),; which is an optimized method for least square and log; likelihood minimizations. Minuit2 has been originally developed by M.; Winkler and F. James in the SEAL project. More information can be found; on the [MINUIT Web Site](MINUIT Web Site) and in particular at the; following documentation page at; <http://www.cern.ch/minuit/doc/doc.html>. A detailed User Guide for Minuit2 exists, describing the API of the internal classes.; ROOT uses `Minuit2` for fitting via the `Minuit2Minimizer` class which implements; the `ROOT::Math::Minimizer` interface. `Minuit2` is also distributed as an independent package of ROOT and can be built; without any other dependency on the ROOT libraries. Examples on how to use the `Minuit2` and `Fumili2` plug-ins are provided; in the tutorials' directory `$ROOTSYS/tutorials/fit`:; `minuit2FitBench.C`, `minuit2FitBench2D.C` and `minuit2GausFit.C`.; More information on the classes and functions present in `Minuit2` is; available at; [online reference documentation](online reference documentation). Useful information on MINUIT and minimization in general is provided in the; following documents:. F. James, *Minuit Tutorial on Function Minimization* (; <http://seal.cern.ch/documents/minuit/mntutorial.pdf>); F. James, *The; Interpretation of Errors in Minuit* (; <http://seal.cern.ch/documents/minuit/mnerror.pdf>);. ## FUMILI Minimization Package. FUMILI is used to minimize Chi-square function or to search maximum of; likelihood function. Experimentally measured values $F_{i}$ are fitted; with theoretical; functions $f_{i}(\vec{x_{i}},\vec{\theta})$, where $\vec{x_{i}}$ are; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:65921,depend,dependency,65921,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['depend'],['dependency']
Integrability,"his set of function analyses. The ``doInitialization(Loop *, LPPassManager &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(Loop *, LPPassManager &LPM);. The ``doInitialization`` method is designed to do simple initialization type of; stuff that does not depend on the functions being processed. The; ``doInitialization`` method call is not scheduled to overlap with any other; pass executions (thus it should be very fast). ``LPPassManager`` interface; should be used to access ``Function`` or ``Module`` level analysis information. .. _writing-an-llvm-pass-runOnLoop:. The ``runOnLoop`` method; ^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnLoop(Loop *, LPPassManager &LPM) = 0;. The ``runOnLoop`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a ``true`` value; should be returned if the function is modified. ``LPPassManager`` interface; should be used to update loop nest. The ``doFinalization()`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization();. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnLoop; <writing-an-llvm-pass-runOnLoop>` for every loop in the program being compiled. .. _writing-an-llvm-pass-RegionPass:. The ``RegionPass`` class; ------------------------. ``RegionPass`` is similar to :ref:`LoopPass <writing-an-llvm-pass-LoopPass>`,; but executes on each single entry single exit region in the function.; ``RegionPass`` processes regions in nested order such that the outer most; region is processed last. ``RegionPass`` subclasses are allowed to update the region tree by using the; ``RGPassManager`` interface. You may override three virtual methods of; ``RegionPass`` to implement your own region pass. All these methods should; return ``true`` if they modified the program, or ``false`` if ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:22268,interface,interface,22268,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['interface'],['interface']
Integrability,"his version the ""*Undo*"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection of components before creating the object. ### Editing Volumes. Volumes are hierarchical components in the geometry, therefore their; editor is more complex. It provides the following functionalities:. - *General*. This category allows changing the name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""*Position*"" allows editing the; positioning matrix of a given node. ![Setting volume properties and modifying volume hierarchy](pictures/020001F5.jpg); ![Setting volume properties and modifying volume hierarchy](pictures/020001F6.jpg). - *Visualization*. This category allows changing the visibility of the; edited volume or for its daughters, as well as other visuali",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:171961,depend,depend,171961,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['depend'],['depend']
Integrability,"histogram. Therefore, the original `HistoToWorkspaceFactory` is now removed to avoid; confusion and maintainance burden. #### Removing constant parameter flag from RooStats:HistFactory::NormFactor. As printed out by the HistFactory in a warning message for a long time already,; setting the `Const` attribute to the `<NormFactor>` tag is deprecated and it; will be ignored. Instead, add `<ParamSetting Const=""True""> myparam </ParamSetting>` to your top-level XML's `<Measurement>` entry. This deprecation implied that the constant parameter flag in the; `RooStats:HistFactory::NormFactor` class had no effect as well. To avoid; ambiguity in the future, the possibility to set and retrieve this flag with; `NormFactor::SetConst()` and `NormFactor::GetConst()` was removed, as well as the; `Sample::AddNormFactor(std::string Name, double Val, double Low, double High, bool Const)`; overload. Also, the aforementioned deprecation warning is not printed anymore. ### Removal of `RooAbsMinimizerFcn` and `RooMinimizerFcn` from the public interface. The `RooAbsMinimizerFcn` class and its implementation `RooMinimizerFcn` were removed from the public interface.; These classes are implementation details of the RooMinimizer and should not be used in your code.; In the unlikely case that this causes any problem for you, please open a GitHub issue requesting to extend the RooMinimizer by the needed functionality. ### Vectorize `RooAbsBinning` interface for bin index lookups. The `RooAbsBinning` interface for bin index lookups was changed to enable vectorized implementations.; Instead of having the override `RooAbsBinning::binNumber()`, the binning implementations now have to override the `RooAbsBinning::binNumbers()` function to evaluate the bin indices of multiple values in one function call. ### Disable relative and absolute epsilon in `RooAbsRealLValue::inRange()`. So far, the `RooAbsRealLValue::inRange()` function used the following; undocumented convention to check whether a value `x` is i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:24203,interface,interface,24203,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['interface'],['interface']
Integrability,"hm. The class inherits from a virtual interface, which is also implemented by the MathMore root finder methods. The user can instantiate, via the common ROOT::Math::RootFinder class, all the various root finder algorithms. The BrentRootFinder class is used by TF1::GetX . ; A similar class, BrentMinimizer1D, provides the possibility to find the minimum of one-dimensional functions using the Brent algorithm. This class is used by TF1::GetMinimum or TF1::GetMaximum; Use ROOT convention for all enumeration names defining the type of numerical algorithms (start with k, like kADAPTIVE for the integration type). This affects both MathCore and MathMore.; . In addition we use now the ROOT convention for all enumeration names defining the type of numerical algorithms. The names start with k, like kADAPTIVE for the integration type. This change affects both MathCore and MathMore and it breaks backward compatibility. MathCore Function interfaces; Mathcore provides as well interfaces for the evaluation of mathematical and parametric functions to be used in the numerical methods. This release contains the following changes:. The ROOT::Math::IParamFunction, ROOT::Math::IParamMultiFunction interfaces (used mainly for fitting) require now a pointer to the parameters (type const double *), when evaluating the function. The derived classes must implement now the const; method DoEvalPar (and not DoEval as before). In addition the method; operator()(const double * x, const double * p) is now const. This change makes the caching of parameter not hidden and the interface is now; thread-safe. ; A similar change in the ROOT::Math::IParamGradFunction, ROOT::Math::IParamMultiGradFunction interfaces, where the parameter values are now required for calculating the partial derivatives with respect to the parameters.; This changes the signature of the pure abstract method, DoParameterDerivative(const double *x, const double * p, , which takes also a pointer (type const double *) to the parameters",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:8720,interface,interfaces,8720,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,2,['interface'],['interfaces']
Integrability,"ho are unfamiliar with either are; encouraged to start with the recommended references in `Related Reading`_. Example: style-checking names; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Assume you have a style-guide rule which forbids functions from being named; ""MkX"" and you want to write a check that catches any violations of this rule. We; can express this a Transformer rewrite rule:. .. code-block:: c++. makeRule(functionDecl(hasName(""MkX"").bind(""fun""),; 	 noopEdit(node(""fun"")),; 	 cat(""The name ``MkX`` is not allowed for functions; please rename""));. ``makeRule`` is our go-to function for generating rewrite rules. It takes three; arguments: the pattern, the edit, and (optionally) an explanatory note. In our; example, the pattern (``functionDecl(...)``) identifies the declaration of the; function ``MkX``. Since we're just diagnosing the problem, but not suggesting a; fix, our edit is an no-op. But, it contains an *anchor* for the diagnostic; message: ``node(""fun"")`` says to associate the message with the source range of; the AST node bound to ""fun""; in this case, the ill-named function declaration.; Finally, we use ``cat`` to build a message that explains the change. Regarding the; name ``cat`` -- we'll discuss it in more detail below, but suffice it to say that; it can also take multiple arguments and concatenate their results. Note that the result of ``makeRule`` is a value of type; ``clang::transformer::RewriteRule``, but most users don't need to care about the; details of this type. Example: renaming a function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Now, let's extend this example to a *transformation*; specifically, the second; example above:. .. code-block:: c++. makeRule(declRefExpr(to(functionDecl(hasName(""MkX"")))),; 	 changeTo(cat(""MakeX"")),; 	 cat(""MkX has been renamed MakeX""));. In this example, the pattern (``declRefExpr(...)``) identifies any *reference* to; the function ``MkX``, rather than the declaration itself, as in our previous; example. Our edit (``changeTo(...)``) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:3804,message,message,3804,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,2,['message'],['message']
Integrability,"hod; that still applies one can also edit drawn geometry objects. For this,; the menu entry View/Editor of the canvas containing for instance a drawn; volume must be activated. For starting the volume editor one can click; on a volume. The GUI of the TGeoManager class can be started by; clicking on the top-right `40x40` pixels corner of the pad with a drawn; geometry. This is the main entry point for editing the geometry or creating new; objects. Once the interface is created (using one of the methods; described above), several categories can be accessed via a shutter GUI; widget:. - *General.* This allows changing the name/title of the geometry,; setting the top volume, closing the geometry and saving the geometry; in a file. The file name is formed by `geometry_name.C` or `.root`; depending if the geometry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of properties related to tracking); - *Matrices.* Allows creation of translations, rotations or combined; transformations. Existing matrices can also be browser/edited. \anchor GP08c; ### Editing Existing Objects. For editing an existing object from one of the categories described; above, the interface imposes first a selection among all objects of the; corresponding type stored in the geometry. This can be done by clicking; the button next to the blue label *Select \<object\>*. The di",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:128451,interface,interface,128451,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['interface'],['interface']
Integrability,"hods. This release contains the following changes:. The ROOT::Math::IParamFunction, ROOT::Math::IParamMultiFunction interfaces (used mainly for fitting) require now a pointer to the parameters (type const double *), when evaluating the function. The derived classes must implement now the const; method DoEvalPar (and not DoEval as before). In addition the method; operator()(const double * x, const double * p) is now const. This change makes the caching of parameter not hidden and the interface is now; thread-safe. ; A similar change in the ROOT::Math::IParamGradFunction, ROOT::Math::IParamMultiGradFunction interfaces, where the parameter values are now required for calculating the partial derivatives with respect to the parameters.; This changes the signature of the pure abstract method, DoParameterDerivative(const double *x, const double * p, , which takes also a pointer (type const double *) to the parameters.; In addition, these classes do not inherit anymore from the function gradient interface (ROOT::Math::IGradFunction and ROOT::Math::IMultiGradFunction). They define only the parameter gradient which is needed for fitting and not the coordinate gradient. A derived class, like ROOT::Math::Polynomial, implementing both functionality (coordinate and parameter gradient) inherits then from both interfaces.; . More detailed description of the current MathCore release can be found at this location. MathMore; This new release contains:. Modify and rename the class ROOT::Math::RootFinder to ROOT::Math::GSLRootFinder to distinguish from the main interface class which has been put in the Mathcore library and it can create the GSLRootFinder using the plug-in manager. Furthermore, the class ROOT::Math::GSLRootFinder is not anymore a template class on the algorithm. They type of root-finder algorithm can now be selected via an enumeration; Fixed a bug in the ROOT::Math::GSLNLSMultiFi class.; Changes also in the class for the new enumeration names (all names start with k, lik",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:9863,interface,interface,9863,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['interface'],['interface']
Integrability,"hon-related cmake variables; are now just the ones automatically produced by cmake (see https://cmake.org/cmake/help/latest/module/FindPython.html). ### More usage of the public cppyy API. Many implementation details of the ROOT pythonizations were moved from C++ functions to pure Python bindings using the; public cppyy API. This helps in the integration with the tool but also improves code efficiency and memory usage. ## Class Reference Guide. - Define missing doxygen groups.; - Fix a few typos in the `THStack` documentation.; - Small fixes in the `THistPainter` documentation.; - Improve the `TColor` documentation: use modern C++ in the examples.; - Make sure the python examples do not generate wrong namespaces in the documentation.; - The dataframe tutorials json spec files were not displayed properly. Moreover there was; no direct correspondence between the code source and the json file. Those files do not; have any doc in them. With a direct link to the GitHub source file the dependency between source; code and json is now more obvious.; - Document how to remove shadow of `TPave`, as it was not evident (only explanations were hidden here and there in the forum).; - Improve the `SetFillColorAlpha` documentation.; - Simplify some graphics examples: arrow.C, crown.C, diamond.C and ellipse.C.; - Fix a typo in the documentation of `TGraph::SetHighlight` in `TGraph.cxx`.; - Change the marker style in the tutorial `df014_CSVDataSource`.; - Remove useless settings in the tutorial `scatter.C`.; - Fix the tutorial `h1analysisTreeReader.C`.; - Fix doxygen formatting in `TGNumberEntry.cxx`.; - Avoid the CDT documentation to appear in the reference guide.; - Remove last references to the old ROOT `drupal` website. ## Build, Configuration and Testing Infrastructure. Release v6.32.00 is the first one integrated and tested entirely through the new GitHub based build system. ## Bugs and Issues fixed in this release. More than 200 items were addressed for this release. The full li",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:23844,depend,dependency,23844,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['depend'],['dependency']
Integrability,"honor-infinities``. * ``-fno-honor-nans``. * ``-fapprox-func``. * ``-fno-math-errno``. * ``-ffinite-math-only``. * ``-fassociative-math``. * ``-freciprocal-math``. * ``-fno-signed-zeros``. * ``-fno-trapping-math``. * ``-fno-rounding-math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-contract``. Note: ``-fno-fast-math`` implies ``-fdenormal-fp-math=ieee``.; ``-fno-fast-math`` causes ``crtfastmath.o`` to not be linked with code. .. option:: -fdenormal-fp-math=<value>. Select which denormal n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:53636,contract,contract,53636,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['contract'],['contract']
Integrability,"hough it has some holes (it allows ""``123KKK``"" for example),; it is good enough for this example. Note that we use the option itself to print; out the error message (the ``error`` method always returns true) in order to get; a nice error message (shown below). Now that we have our parser class, we can; use it like this:. .. code-block:: c++. static cl::opt<unsigned, false, FileSizeParser>; MFS(""max-file-size"", cl::desc(""Maximum file size to accept""),; cl::value_desc(""size""));. Which adds this to the output of our program:. ::. OPTIONS:; -help - display available options (-help-hidden for more); ...; -max-file-size=<size> - Maximum file size to accept. And we can test that our parse works correctly now (the test program just prints; out the max-file-size argument value):. ::. $ ./test; MFS: 0; $ ./test -max-file-size=123MB; MFS: 128974848; $ ./test -max-file-size=3G; MFS: 3221225472; $ ./test -max-file-size=dog; -max-file-size option: 'dog' value invalid for file size argument!. It looks like it works. The error message that we get is nice and helpful, and; we seem to accept reasonable file sizes. This wraps up the ""custom parser""; tutorial. Exploiting external storage; ---------------------------. Several of the LLVM libraries define static ``cl::opt`` instances that will; automatically be included in any program that links with that library. This is; a feature. However, sometimes it is necessary to know the value of the command; line option outside of the library. In these cases the library does or should; provide an external storage location that is accessible to users of the; library. Examples of this include the ``llvm::DebugFlag`` exported by the; ``lib/Support/Debug.cpp`` file and the ``llvm::TimePassesIsEnabled`` flag; exported by the ``lib/IR/PassManager.cpp`` file. .. todo::. TODO: complete this section. .. _dynamically loaded options:. Dynamically adding command line options; ---------------------------------------. .. todo::. TODO: fill in this section; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:66302,message,message,66302,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,2,"['message', 'wrap']","['message', 'wraps']"
Integrability,"hould be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true:; switch (foo) { vs. switch (foo) {; case 1: { case 1:; bar(); {; break; bar();; } break;; default: { }; plop(); default:; } {; } plop();; }; }. * ``bool AfterClass`` Wrap class definitions. .. code-block:: c++. true:; class foo; {};. false:; class foo {};. * ``BraceWrappingAfterControlStatementStyle AfterControlStatement``; Wrap control statements (``if``/``for``/``while``/``switch``/..). Possible values:. * ``BWACS_Never`` (in configuration: ``Never``); Never wrap braces after a control statement. .. code-block:: c++. if (foo()) {; } else {; }; for (int i = 0; i < 10; ++i) {; }. * ``BWACS_MultiLine`` (in configuration: ``MultiLine``); Only wrap braces after a multi-line control statement. .. code-block:: c++. if (foo && bar &&; baz); {; quux();; }; while (foo || bar) {; }. * ``BWACS_Always`` (in configuration: ``Always``); Always wrap braces after a control statement. .. code-block:: c++. if (foo()); {; } else; {}; for (int i = 0; i < 10; ++i); {}. * ``bool AfterEnum`` Wrap enum definitions. .. code-block:: c++. true:; enum X : int; {; B; };. false:; enum X : int { B };. * ``bool AfterFunction`` Wrap function definitions. .. code-block:: c++. true:; void foo(); {; bar();; bar2();; }. false:; void foo() {; bar();; bar2();; }. * ``bool AfterNamespace`` Wrap namespace definitions. .. code-block:: c++. true:; namespace; {; int foo();; int bar();; }. false:; namespace {; int foo();; int bar();; }. * ``bool AfterObjCDeclaration`` Wrap ObjC definitions (interfaces, implementations...). .. note::. @autoreleasepool and @synchronized blocks are wrapped; according to ``AfterControlStatement`` flag. * ``bool AfterStruct`` Wrap struct definitions. .. code-block:: c++. true:; struct foo; {; int x;; };. false:; struct foo {; int x;; };. * ``bool AfterUnion`` Wrap union definitions. .. code-block:: c++. true:; union ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:39859,wrap,wrap,39859,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrap']
Integrability,"hould be:; #. A proposal for removal / deactivation should be made to the Discourse forums ; (under the appropriate category), with a clear; statement of the maintenance costs imposed and the alternatives, if; applicable.; #. There must be enough consensus on the list that removal is warranted, and no; pending proposals to fix the situation from a sub-community.; #. An announcement for removal must be made on the same lists, with ample time; for downstream users to take action on their local infrastructure. The time; will depend on what is being removed. #. If a script or documents are to be removed, they can always be pulled; from previous revision, and can be removed within days.; #. if a whole target is removed, we need to first announce publicly, and; potentially mark as deprecated in one release, only to remove on the; next release.; #. Everything else will fall in between those two extremes.; #. The removal is made by either the proposer or the sub-community that used to; maintain it, with replacements and arrangements made atomically on the same; commit. If a proposal for removal is delayed by the promise a sub-community will take; care of the code affected, the sub-community will have a time to fix all the; issues (depending on each case, as above), and if those are not fixed in time, a; subsequent request for removal should be made and the community may elect to; eject the component without further attempts to fix. Reinstatement; -------------. If a component is removed from LLVM, it may, at a later date, request inclusion; of a modified version, with evidence that all of the issues were fixed and that; there is a clear sub-community that will maintain it. By consequence, the pressure on such sub-community will be higher to keep; overall maintenance costs to a minimum and will need to show steps to mitigate; all of the issues that were listed as reasons for its original removal. Failing on those again, will lead to become a candidate for removal yet again. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:10650,depend,depending,10650,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['depend'],['depending']
Integrability,"hould have its ``__creates__`` flag set through its; :doc:`pythonization <pythonizations>`.; Well-written APIs will have clear clues in their naming convention about the; ownership rules.; For example, functions called ``New...``, ``Clone...``, etc. can be expected; to return freshly allocated objects.; A basic name-matching in the pythonization then makes it simple to mark all; these functions as creators. The return values are :ref:`auto-casted <sec-auto-casting-label>`. `\*args and \*\*kwds`; ---------------------. C++ default arguments work as expected.; Keywords, however, are a Python language feature that does not exist in C++.; Many C++ function declarations do have formal arguments, but these are not; part of the C++ interface (the argument names are repeated in the definition,; making the names in the declaration irrelevant: they do not even need to be; provided).; Thus, although ``cppyy`` will map keyword argument names to formal argument; names from the C++ declaration, use of this feature is not recommended unless; you have a guarantee that the names in C++ the interface are maintained.; Example:. .. code-block:: python. >>> from cppyy.gbl import Concrete; >>> c = Concrete() # uses default argument; >>> c.m_int; 42; >>> c = Concrete(13) # uses provided argument; >>> c.m_int; 13; >>> args = (27,); >>> c = Concrete(*args) # argument pack; >>> c.m_int; 27; >>> c = Concrete(n=17); >>> c.m_int; 17; >>> kwds = {'n' : 18}; >>> c = Concrete(**kwds); >>> c.m_int; 18; >>>. `Callbacks`; -----------. Python callables (functions/lambdas/instances) can be passed to C++ through; function pointers and/or ``std::function``.; This involves creation of a temporary wrapper, which has the same life time as; the Python callable it wraps, so the callable needs to be kept alive on the; Python side if the C++ side stores the callback.; Example:. .. code-block:: python. >>> from cppyy.gbl import call_int_int; >>> print(call_int_int.__doc__); int ::call_int_int(int(*)(int,int) f, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst:13734,interface,interface,13734,bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,1,['interface'],['interface']
Integrability,"hould; use the constructor:. ~~~{.cpp}; TGeoMaterial(const char *name, TGeoElement *elem, Double_t density); ~~~. To create a radioactive mixture, one can use radionuclides as well as; stable elements:. ~~~{.cpp}; TGeoMixture(const char *name, Int_t nelements, Double_t density);; TGeoMixture::AddElement(TGeoElement *elem,; Double_t weight_fraction);; ~~~. Once defined, one can retrieve the time evolution for the radioactive; materials/mixtures by using one of the next two methods:. #### Method 1. ~~~{.cpp}; TGeoMaterial::FillMaterialEvolution(TObjArray *population, Double_t precision=0.001); ~~~. To use this method, one has to provide an empty TObjArray object; that will be filled with all elements coming from the decay chain of the; initial radionuclides contained by the material/mixture. The precision; represent the cumulative branching ratio for which decay products are; still considered. \image html geometry003.png width=600px. The population list may contain stable elements as well as; radionuclides, depending on the initial elements. To test if an element; is a radionuclide:. ~~~{.cpp}; Bool_t TGeoElement::IsRadioNuclide() const; ~~~. All radionuclides in the output population list have attached objects; that represent the time evolution of their fraction of nuclei with; respect to the top radionuclide in the decay chain. These objects; (Bateman solutions) can be retrieved and drawn:. ~~~{.cpp}; TGeoBatemanSol *TGeoElementRN::Ratio();; void TGeoBatemanSol::Draw();; ~~~. #### Method 2. Another method allows to create the evolution of a given radioactive; material/mixture at a given moment in time:. ~~~{.cpp}; TGeoMaterial::DecayMaterial(Double_t time, Double_t precision=0.001); ~~~. The method will create the mixture that result from the decay of a; initial material/mixture at time, while all resulting elements having a; fractional weight less than precision are excluded. A demo macro for radioactive material features is; `$ROOTSYS/tutorials/geom/RadioNuclides.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md:8045,depend,depending,8045,geom/geom/doc/materials.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md,1,['depend'],['depending']
Integrability,"hread local. This fixes [ROOT-7791].; * Fix some bugs in TF1NormSum (to fit normalized sum of functions) and in TF1Convolution; * Add a new histogram fitting option, `WIDTH` to fit directly density. The bin content in this case is scaled by the histogram bin width. ### TFormula. * Fix several bugs in the new TFormula class.; * Add as new pre-defined functions: `crystalball`, `breitwigner` and `cheb0,cheb1,...cheb10` for the Chebyshev polynomials. . ## Math Libraries. ### Random numbers. * Move from MathMore to MathCore the class `ROOT::Math::Random`. Make it a new interface class for random number generation. Add interfaces for standard; ROOT random engines, GSL random engines and random engines provided by the C++ standard library (`std::random`).; * Add a new randomengine, `MIXMAX` based on matrix-recursive random number generator from Kostas and George Savvidy. See this [paper](http://dx.doi.org/10.1016/j.cpc.2015.06.003). ## R Interface. Apply several improvements in the interface to R, allowing to use R functions within ROOT.; See more at the [ROOT-R User Guide](http://oproject.org/tiki-index.php?page=ROOT%20R%20Users%20Guide). . ## TMVA. Add new TMVA plug-in based on R and Python (using Scikit-Learn) ; * See the [RMVA Web page](http://oproject.org/tiki-index.php?page=RMVA) for a detailed description of the new TMVA method based on R; * See the [PyMVA Web page](http://oproject.org/tiki-index.php?page=PyMVA) for detailed description of the machine learning methods added in TMVA and based on the Python Scikit-Learn package. ## RooFit Libraries; . ## 2D Graphics Libraries. ### THistPainter. Improve the algorithm to compute the lower limit of an axis in log scale when its; real lower limit is 0. The problem was reported in ROOT-7414. Using the `COL` option with histograms having some negative bins; the empty bins; (containing 0) are drawn. In some cases one wants to not draw empty bins; (containing 0) of histograms having a negative minimum. The option `1`, used wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:13897,interface,interface,13897,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['interface'],['interface']
Integrability,"https://cmake.org/cmake/help/v3.4/module/CMakeParseArguments.html>`_. .. note::; As of CMake 3.5 the cmake_parse_arguments command has become a native command; and the CMakeParseArguments module is empty and only left around for; compatibility. Functions Vs Macros; -------------------. Functions and Macros look very similar in how they are used, but there is one; fundamental difference between the two. Functions have their own scope, and; macros don't. This means variables set in macros will bleed out into the calling; scope. That makes macros suitable for defining very small bits of functionality; only. The other difference between CMake functions and macros is how arguments are; passed. Arguments to macros are not set as variables, instead dereferences to; the parameters are resolved across the macro before executing it. This can; result in some unexpected behavior if using unreferenced variables. For example:. .. code-block:: cmake. macro(print_list my_list); foreach(var IN LISTS my_list); message(""${var}""); endforeach(); endmacro(). set(my_list a b c d); set(my_list_of_numbers 1 2 3 4); print_list(my_list_of_numbers); # prints:; # a; # b; # c; # d. Generally speaking this issue is uncommon because it requires using; non-dereferenced variables with names that overlap in the parent scope, but it; is important to be aware of because it can lead to subtle bugs. LLVM Project Wrappers; =====================. LLVM projects provide lots of wrappers around critical CMake built-in commands.; We use these wrappers to provide consistent behaviors across LLVM components; and to reduce code duplication. We generally (but not always) follow the convention that commands prefaced with; ``llvm_`` are intended to be used only as building blocks for other commands.; Wrapper commands that are intended for direct use are generally named following; with the project in the middle of the command name (i.e. ``add_llvm_executable``; is the wrapper for ``add_executable``). The LLVM ``add_*`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:12709,message,message,12709,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['message'],['message']
Integrability,"hub.com/root-project/root/issues/14385)] - Strange behavior with TF1 and SetParameters; * [[#14381](https://github.com/root-project/root/issues/14381)] - Legend entry for exclusion graph; * [[#14376](https://github.com/root-project/root/issues/14376)] - build failure with `mysql 8.3`; * [[#14372](https://github.com/root-project/root/issues/14372)] - File with mtime equal to 0 are ignored by Cling.; * [[#14333](https://github.com/root-project/root/issues/14333)] - ""Empty plot"" for df014_CSVDataSource.C ; * [[#14331](https://github.com/root-project/root/issues/14331)] - Unexpected behaviour when using the Project3D function to make a TH2 from a TH3; * [[#14329](https://github.com/root-project/root/issues/14329)] - [RF] RDataFrameToRooFit - Clarification on returned object; * [[#14324](https://github.com/root-project/root/issues/14324)] - Compatibility Issue with thisroot.sh and zsh ; * [[#14320](https://github.com/root-project/root/issues/14320)] - [RF] Wrong analytic integrals when using Gaussians with sigma depending on the observable; * [[#14303](https://github.com/root-project/root/issues/14303)] - Test failure with `nbconvert-7.14`; * [[#14302](https://github.com/root-project/root/issues/14302)] - The command ""root --notebook"" is not allowed on Windows 11; * [[#14277](https://github.com/root-project/root/issues/14277)] - Cling triggers a huge number of `openat` calls when loading libraries; * [[#14263](https://github.com/root-project/root/issues/14263)] - [tmva] When using DNN_USE_CBLAS, CMakeLists should link publicly to gsl instead of privately; * [[#14256](https://github.com/root-project/root/issues/14256)] - TAxis::GetTicks and TAxis::SetTicks are inconsistent. Significantly so.; * [[#14244](https://github.com/root-project/root/issues/14244)] - String comparison operators defined in TString.h should be defined as constexpr; * [[#14229](https://github.com/root-project/root/issues/14229)] - [6.30] root-config --git-revision broken; * [[#14225](https://github.com",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:33265,depend,depending,33265,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['depend'],['depending']
Integrability,"hub.com/vmc-project/vmc](https://github.com/vmc-project/vmc); to replace the deprecated version in ROOT. ### Removed packages. Support for the following optional components of ROOT has been removed:. * afdsmgrd (Dataset manager for PROOF-based analysis facilities); * bonjour (Avahi/Bonjour/Zeroconf); * castor (CERN Advanced STORage manager); * geocad (OpenCascade); * globus (Globus authentication); * hdfs (Hadoop Distributed File System); * krb5 (Kerberos 5 authentication); * ldap (OpenLDAP authentication); * memstat (legacy memory statistics utility); * qt, qtgsi, qtroot (Qt4-based GUI components); * rfio (Remote File IO for CASTOR); * table (libTable contrib library). In addition, the following deprecated parts of ROOT components have been; removed:. * PROOF's PQ2 module; * `THttpServer::ExecuteHttp()` and `THttpServer::SubmitHttp` from `THttpServer`. ### Other changes. The deprecation of the GraphViz integration has been reverted since the code is; still in use. The ODBC interface, deprecated in ROOT 6.16, is no longer deprecated in ROOT 6.18.; It is the main option to support databases on Windows, so the decision to deprecate; it was reverted. The `xft` option has been merged into `x11` and is no longer used (its value is; now ignored by ROOT). ## Preprocessor deprecation macros; ### Deprecated Classes; * `R__SUGGEST_ALTERNATIVE(""Suggestion text"")` macro allows to suggest alternatives to classes. It must be used after the class definition and before the final semicolon:; ```{.cpp}; class DoNotUseClass {; } R__SUGGEST_ALTERNATIVE(""Use ... instead."");; ```; It is activated by the preprocessor defines `R__SUGGEST_NEW_INTERFACE`. The former is useful when deprecation warnings should be activated/deactivated at global level, for example for an entire project. This could be done by defining `R__SUGGEST_NEW_INTERFACE` in the build system. ; If the warning needs to be confined within single translation units, irrespective of the definition of `R__SUGGEST_NEW_INTERFACE`,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md:2627,interface,interface,2627,README/ReleaseNotes/v618/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v618/index.md,1,['interface'],['interface']
Integrability,"iable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may; mean that the solution is not well defined, for example that there are; more unknowns than there are data points, or that the parameterization; of the fit contains a linear dependence. If this is the case, then; `Minuit` (or any other program) cannot solve your problem uniquely.; The error matrix will necessarily be largely meaningless, so the user; must remove the under determinedness by reformulating the; parameterization. `Minuit` cannot do this itself. #### Numerical Inaccuracies. It is possible that the apparent lack of positive-definiteness is due; to excessive round off errors in numerical calculations (in the user; function), or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or; if the parameters are badly scaled (not all of the same order of; magnitude), and correlations are large. In any case, whether the; non-positive-definiteness is real or only numerical is largely; irrelevant, since in both cases the error matrix will be unreliable; and the minimum sus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:63248,depend,dependence,63248,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['depend'],['dependence']
Integrability,"iagnostics. For example:. .. code-block:: C++. unknownFunction().size() // .size() is a CXXDependentScopeMemberExpr; std::string(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new “ContainsErrors” bit to; express “Does this expression or anything within it contain errors” semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89598,depend,dependent,89598,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['depend'],['dependent']
Integrability,"iasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected nested type; Clang 3.1. 162; CD1; (&C::f)() with nonstatic members; No. 163; TC1; Description of subaggregate initializer; N/A. 164; TC1; Overlap between Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static functions; Superseded by 1012. 168; NAD; C linkage for static member functions; No. 169; NAD; template-ids in using-declarations; Yes. 170; DRWP; Pointer-to-member conversions; Unknown. 171; TC1; Global namespace scope; Clang 3.4. 172; CD1; Unsigned int as underlying type of enum; Yes. 173; TC1; Constraints on execution character set; Yes. 174; NAD; Undeprecating global static; Superseded by 1012. 175; CD1; Class name injection and base name access; Clang 2.8. 176; TC1; Name injection and templates; Clang 3.1. 177; CD1; Lvalues vs rvalues in copy-initialization; Yes. 178; TC1; More on value-initialization; Yes. 179; TC1; Function pointers and subtraction; Yes. 180; CD1; typename and elaborated types; Clang 2.8. 181; TC1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup in parameters; Unknown. 193; TC1; Order of destruction of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:11784,inject,injection,11784,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['inject'],['injection']
Integrability,"ible in the output of the; program, since the order in which outputs appear in the buffer is changed.; However, this does not break the overall contract that ``@reserveSpaceInBuffer``; has with its caller -- which makes sense: the order of outputs is; non-deterministic anyway because of the atomic operation that is involved. If the function is inlined, the use of the anchor intrinsic similarly indicates; that certain transforms which are usually forbidden by the presence of; convergent operations are in fact allowed, as long as they don't break up the; region of code that is controlled by the anchor. .. _convergence_high-level_break:. Extended Cycles: Divergent Exit from a Loop; -------------------------------------------. High-level languages typically provide a ``break`` statement that transfers; control out of a loop statement. In most cases, the loop is structured and hence; there is no ambiguity about convergence inside the loop. But an ambiguity arises; when a ``break`` is control dependent on a divergent condition inside the loop.; Consider the following example:. .. code-block:: c++. void example() {; // A; ...; for (...) {; // B; if (condition) { // divergent condition; // C; convergent_op();; break;; }; // D; ...; }; // E; }. In this program, the call to convergent_op() is lexically ""inside"" the ``for``; loop. But when translated to LLVM IR, the basic block B is an exiting block; ending in a divergent branch, and the basic block C is an exit of the loop.; Thus, the call to convergent_op() is outside the loop. This causes a mismatch; between the programmer's expectation and the compiled program. The call should; be executed convergently on every iteration of the loop, by threads that; together take the branch to exit the loop. But when compiled, all threads that; take the divergent exit on different iterations first converge at the beginning; of basic block C and then together execute the call to convergent_op(). In this case, :ref:`llvm.experimental.converg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst:15900,depend,dependent,15900,interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ConvergentOperations.rst,1,['depend'],['dependent']
Integrability,"ibrary and other code. This change also affects the `RooNumber::isInfinite()` function. ### Remove `add(row, weight, weightError)` from RooAbsData interface. It was not good to have this signature in RooAbsData, because the; implementations in the two derived classes RooDataHist and RooDataSet were; inconsistent. The RooDataSet indeed took the weight error as the third argument, but; the RooDataHist version instead took the sum of weights squared, which; is equivalent to the squared weight error. Therefore, the virtual `RooAbsData::add(row, weight, weightError)` function was removed. ### Removal of `RooMomentMorphND` class. The `RooMomentMorphND` and `RooMomentMorphFuncND` were almost exactly the same,; only that one inherited from `RooAbsPdf` and the other from `RooAbsReal`. Thanks to the `RooWrapperPdf`, this code duplication in the RooFit implementation can now be avoided.; Instead of using the removed `RooMomentMorphND` (which is the pdf), you now need to use the `RooMomentMorphFuncND`,; change its behavior to exactly match the formter `RooMomentMorphND`, and then wrap it into a pdf object:. ```C++; RooMomentMorphFuncND func{<constructor args you previously passed to RooMomentMorphFunc>};. func.setPdfMode(); // change behavior to be exactly like the former RooMomentMorphND. // Pass the selfNormalized=true` flag to the wrapper because the; RooMomentMorphFuncND already normalizes itself in pdf mode.; RooWrapperPdf pdf{""pdf_name"", ""pdf_name"", func, /*selfNormalized=*/true};; ```. ### Removal of several internal classes from the public RooFit interface. Several RooFit classes of which the headers are publicly exposed in the interface were only meant as implementation details of other RooFit classes.; Some of these classes are now removed from the public interface:. 1. `RooGenProdProj`, which was an implementation detail of the `RooProdPdf`; 2. `RooScaledFunc`, which was an implementation detail of the plotting in RooFit; In the supposedly very rare case where you us",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:14260,wrap,wrap,14260,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['wrap'],['wrap']
Integrability,"ibutors see $ROOTSYS/README/CREDITS. set(CFITSIO_VERSION 4.4.0). set(CFITSIO_PREFIX ${CMAKE_BINARY_DIR}/CFITSIO-prefix); set(CFITSIO_LIBRARIES ${CFITSIO_PREFIX}/lib/${CMAKE_STATIC_LIBRARY_PREFIX}cfitsio${CMAKE_STATIC_LIBRARY_SUFFIX}). if(NOT WIN32); set(CFITSIO_C_FLAGS -fPIC); endif(). if(WIN32 AND NOT CMAKE_GENERATOR MATCHES Ninja); if(winrtdebug); set(CFITSIO_BUILD_COMMAND_FLAGS ""--config Debug""); else(); set(CFITSIO_BUILD_COMMAND_FLAGS ""--config Release""); endif(); endif(). ExternalProject_Add(; BUILTIN_CFITSIO; PREFIX ${CFITSIO_PREFIX}; URL https://heasarc.gsfc.nasa.gov/FTP/software/fitsio/c/cfitsio-${CFITSIO_VERSION}.tar.gz; URL_HASH SHA256=95900cf95ae760839e7cb9678a7b2fad0858d6ac12234f934bd1cb6bfc246ba9; CMAKE_ARGS -G ${CMAKE_GENERATOR}; -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}; -DCMAKE_C_FLAGS=${CFITSIO_C_FLAGS}; -DCMAKE_INSTALL_PREFIX=<INSTALL_DIR>; -DCMAKE_INSTALL_LIBDIR=<INSTALL_DIR>/lib; -DBUILD_SHARED_LIBS=OFF; -DUSE_CURL=OFF; -DZLIB_FOUND=TRUE; -DZLIB_INCLUDE_DIR=${ZLIB_INCLUDE_DIRS}; -DZLIB_LIBRARIES=$<TARGET_FILE:ZLIB::ZLIB>; # Skip the find_package(ZLIB REQUIRED), because we feed CFITSIO our own ZLIB flags.; PATCH_COMMAND git apply --ignore-space-change --ignore-whitespace; ${CMAKE_CURRENT_SOURCE_DIR}/cfitsio-no-find-zlib.diff; ${CMAKE_CURRENT_SOURCE_DIR}/no-fortran-wrapper.diff; BUILD_COMMAND ${CMAKE_COMMAND} --build . ${CFITSIO_BUILD_COMMAND_FLAGS}; INSTALL_COMMAND ${CMAKE_COMMAND} --build . ${CFITSIO_BUILD_COMMAND_FLAGS} --target install; LOG_DOWNLOAD 1 LOG_CONFIGURE 1 LOG_BUILD 1 LOG_INSTALL 1 LOG_OUTPUT_ON_FAILURE 1; BUILD_BYPRODUCTS ${CFITSIO_LIBRARIES}; TIMEOUT 600; ). add_dependencies(BUILTIN_CFITSIO ZLIB::ZLIB). add_dependencies(CFITSIO::CFITSIO BUILTIN_CFITSIO); set(CFITSIO_INCLUDE_DIRS ${CFITSIO_PREFIX}/include); file(MAKE_DIRECTORY ${CFITSIO_INCLUDE_DIRS}); set_target_properties(CFITSIO::CFITSIO PROPERTIES; IMPORTED_LOCATION ${CFITSIO_LIBRARIES}; INTERFACE_INCLUDE_DIRECTORIES ${CFITSIO_INCLUDE_DIRS}; INTERFACE_LINK_LIBRARIES ZLIB::ZLIB; ); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/builtins/cfitsio/CMakeLists.txt:1459,wrap,wrapper,1459,builtins/cfitsio/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/builtins/cfitsio/CMakeLists.txt,1,['wrap'],['wrapper']
Integrability,"ic Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have multiple; copies of your libraries and (possibly) headers. Some Linux distributions have support for Multilib, which handle that; for you in an easier way, but if you're not careful and, for instance,; forget to specify ``-ccc-gcc-name armv7l-linux-gnueabihf-gcc`` (which; uses hard-float), Clang will pick the ``armv7l-linux-gnueabi-ld``; (which uses soft-float) and linker errors will happen. The same is true if you're compiling for different environments, like; ``gnueabi`` and ``androideabi``, and might even link and run, but produce; run-time errors, which ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:8498,depend,dependencies,8498,interpreter/llvm-project/clang/docs/CrossCompilation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst,2,['depend'],['dependencies']
Integrability,"ical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Derivation. There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library.; * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function.; * GSLDerivator of *MathMore* based on GSL. ## Numerical Minimization. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while; the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes `TMinuitMinimizer` implemented using `TMinuit`, `TFumiliMinimizer`; implemented using `TFumili` for least square or likelihood minimizations.; We encourage the use of the GSL algorithms for one dimensional minimization and `Minuit2` (or the old version`Minuit`) for multi dimensional minimization. ![Numerical Minimization classes](pictures/Minimization.png). ### One-Dimensional Minimization. These algorithms are for finding the minimum of a one-dimensional minimization function.; The function to minimize must be given to the class implementing the algorithm as a; `ROOT::Math::IBaseFunctionOneDim` object.; The algorithms supported are only bracketing algorithm which do not use derivatives information. Two classes exist. One in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:62836,integrat,integration,62836,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integration']
Integrability,"icate the needed directory). Note that your python interpreter (whether CPython or ``pypy-c``) may not have; been linked by the C++ compiler.; This can lead to problems during loading of C++ libraries and program shutdown.; In that case, re-linking is highly recommended. Very old versions of PyPy (5.6.0 and earlier) have a built-in ``cppyy`` based; on `Reflex`_, which is less feature-rich and no longer supported.; However, both the :doc:`distribution utilities <utilities>` and user-facing; Python codes are very backwards compatible, making migration straightforward. Precompiled header; ------------------. For performance reasons (reduced memory and CPU usage), a precompiled header; (PCH) of the system and compiler header files will be installed or, failing; that, generated on startup.; Obviously, this PCH is not portable and should not be part of any wheel. Some compiler features, such as AVX, OpenMP, fast math, etc. need to be; active during compilation of the PCH, as they depend both on compiler flags; and system headers (for intrinsics, or API calls).; You can control compiler flags through the ``EXTRA_CLING_ARGS`` envar and thus; what is active in the PCH.; In principle, you can also change the C++ language standard by setting the; appropriate flag on ``EXTRA_CLING_ARGS`` and rebuilding the PCH.; However, if done at this stage, that disables some automatic conversion for; C++ types that were introduced after C++11 (such as ``string_view`` and; ``optional``). If you want multiple PCHs living side-by-side, you can generate them; yourself (note that the given path must be absolute)::. >>> import cppyy_backend.loader as l; >>> l.set_cling_compile_options(True) # adds defaults to EXTRA_CLING_ARGS; >>> install_path = '/full/path/to/target/location/for/PCH'; >>> l.ensure_precompiled_header(install_path). You can then select the appropriate PCH with the ``CLING_STANDARD_PCH`` envar::. $ export CLING_STANDARD_PCH=/full/path/to/target/location/for/PCH/allDict.cxx.pch. Or ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/installation.rst:7892,depend,depend,7892,bindings/pyroot/cppyy/cppyy/doc/source/installation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/installation.rst,1,['depend'],['depend']
Integrability,"ication does not alter the storage requirements for objects,; except that it is undefined behavior if a ``__weak`` object is inadequately; aligned for an object of type ``id``. The other qualifiers may be used on; explicitly under-aligned memory. The runtime tracks ``__weak`` objects which holds non-null values. It is; undefined behavior to direct modify a ``__weak`` object which is being tracked; by the runtime except through an; :ref:`objc_storeWeak <arc.runtime.objc_storeWeak>`,; :ref:`objc_destroyWeak <arc.runtime.objc_destroyWeak>`, or; :ref:`objc_moveWeak <arc.runtime.objc_moveWeak>` call. The runtime must provide a number of new entrypoints which the compiler may; emit, which are described in the remainder of this section. .. admonition:: Rationale. Several of these functions are semantically equivalent to a message send; we; emit calls to C functions instead because:. * the machine code to do so is significantly smaller,; * it is much easier to recognize the C functions in the ARC optimizer, and; * a sufficient sophisticated runtime may be able to avoid the message send in; common cases. Several other of these functions are ""fused"" operations which can be; described entirely in terms of other operations. We use the fused operations; primarily as a code-size optimization, although in some cases there is also a; real potential for avoiding redundant operations in the runtime. .. _arc.runtime.objc_autorelease:. ``id objc_autorelease(id value);``; ----------------------------------. *Precondition:* ``value`` is null or a pointer to a valid object. If ``value`` is null, this call has no effect. Otherwise, it adds the object; to the innermost autorelease pool exactly as if the object had been sent the; ``autorelease`` message. Always returns ``value``. .. _arc.runtime.objc_autoreleasePoolPop:. ``void objc_autoreleasePoolPop(void *pool);``; ---------------------------------------------. *Precondition:* ``pool`` is the result of a previous call to; :ref:`objc_autore",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:106619,message,message,106619,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"ice`, `legalized`, `regBankSelected`, `selected`.; The whole `frameInfo` section is often unnecessary if there is no special; frame usage in the function. `tracksRegLiveness` on the other hand is often; necessary for some passes that care about block livein lists. - The (global) `liveins:` list is typically only interesting for early; instruction selection passes and can be removed when testing later passes.; The per-block `liveins:` on the other hand are necessary if; `tracksRegLiveness` is true. - Branch probability data in block `successors:` lists can be dropped if the; test doesn't depend on it. Example:; `successors: %bb.1(0x40000000), %bb.2(0x40000000)` can be replaced with; `successors: %bb.1, %bb.2`. - MIR code contains a whole IR module. This is necessary because there are; no equivalents in MIR for global variables, references to external functions,; function attributes, metadata, debug info. Instead some MIR data references; the IR constructs. You can often remove them if the test doesn't depend on; them. - Alias Analysis is performed on IR values. These are referenced by memory; operands in MIR. Example: `:: (load 8 from %ir.foobar, !alias.scope !9)`.; If the test doesn't depend on (good) alias analysis the references can be; dropped: `:: (load 8)`. - MIR blocks can reference IR blocks for debug printing, profile information; or debug locations. Example: `bb.42.myblock` in MIR references the IR block; `myblock`. It is usually possible to drop the `.myblock` reference and simply; use `bb.42`. - If there are no memory operands or blocks referencing the IR then the; IR function can be replaced by a parameterless dummy function like; `define @func() { ret void }`. - It is possible to drop the whole IR section of the MIR file if it only; contains dummy functions (see above). The .mir loader will create the; IR functions automatically in this case. .. _limitations:. Limitations; -----------. Currently the MIR format has several limitations in terms of which st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:4384,depend,depend,4384,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['depend'],['depend']
Integrability,"ich don't depend on template parameters; must be complete when a template is defined if they affect the; program's behavior. However, the standard also says that compilers; are free to not enforce this rule. Most compilers enforce it to some; extent; for example, it would be an error in GCC to; write opts.ForceReads in the code above. In Clang, we feel; that enforcing the rule consistently lets us provide a better; experience, but unfortunately it also means we reject some code that; other compilers accept. We've explained the rule here in very imprecise terms; see; [temp.res]p8 for details. Templates with no valid instantiations. The following code contains a typo: the programmer; meant init() but wrote innit() instead. template <class T> class Processor {; ...; void init();; ...; };; ...; template <class T> void process() {; Processor<T> processor;; processor.innit(); // <-- should be 'init()'; ...; }. Unfortunately, we can't flag this mistake as soon as we see it: inside; a template, we're not allowed to make assumptions about ""dependent; types"" like Processor<T>. Suppose that later on in; this file the programmer adds an explicit specialization; of Processor, like so:. template <> class Processor<char*> {; void innit();; };. Now the program will work — as long as the programmer only ever; instantiates process() with T = char*! This is why; it's hard, and sometimes impossible, to diagnose mistakes in a; template definition before it's instantiated. The standard says that a template with no valid instantiations is; ill-formed. Clang tries to do as much checking as possible at; definition-time instead of instantiation-time: not only does this; produce clearer diagnostics, but it also substantially improves; compile times when using pre-compiled headers. The downside to this; philosophy is that Clang sometimes fails to process files because they; contain broken templates that are no longer used. The solution is; simple: since the code is unused, just remove it. Defa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:18995,depend,dependent,18995,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['depend'],['dependent']
Integrability,"ich they must check. During import of a specific declaration, it may happen that some AST nodes had; already been created before we recognize an error. In this case, we signal back; the error to the caller, but the ""to"" context remains polluted with those nodes; which had been created. Ideally, those nodes should not had been created, but; that time we did not know about the error, the error happened later. Since the; AST is immutable (most of the cases we can't remove existing nodes) we choose; to mark these nodes as erroneous. We cache the errors associated with declarations in the ""from"" context in; ``ASTImporter::ImportDeclErrors`` and the ones which are associated with the; ""to"" context in ``ASTImporterSharedState::ImportErrors``. Note that, there may; be several ASTImporter objects which import into the same ""to"" context but from; different ""from"" contexts; in this case, they have to share the associated; errors of the ""to"" context. When an error happens, that propagates through the call stack, through all the; dependant nodes. However, in case of dependency cycles, this is not enough,; because we strive to mark the erroneous nodes so clients can act upon. In those; cases, we have to keep track of the errors for those nodes which are; intermediate nodes of a cycle. An **import path** is the list of the AST nodes which we visit during an Import; call. If node ``A`` depends on node ``B`` then the path contains an ``A->B``; edge. From the call stack of the import functions, we can read the very same; path. Now imagine the following AST, where the ``->`` represents dependency in terms; of the import (all nodes are declarations). .. code-block:: text. A->B->C->D; `->E. We would like to import A.; The import behaves like a DFS, so we will visit the nodes in this order: ABCDE.; During the visitation we will have the following import paths:. .. code-block:: text. A; AB; ABC; ABCD; ABC; AB; ABE; AB; A. If during the visit of E there is an error then we set an error for ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:101875,depend,dependant,101875,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['depend'],['dependant']
Integrability,"icit iterator-based loop, pay close attention to whether; ``end()`` is re-evaluated on each loop iteration. One common mistake is to; write a loop in this style:. .. code-block:: c++. BasicBlock *BB = ...; for (auto I = BB->begin(); I != BB->end(); ++I); ... use I ... The problem with this construct is that it evaluates ""``BB->end()``"" every time; through the loop. Instead of writing the loop like this, we strongly prefer; loops to be written so that they evaluate it once before the loop starts. A; convenient way to do this is like so:. .. code-block:: c++. BasicBlock *BB = ...; for (auto I = BB->begin(), E = BB->end(); I != E; ++I); ... use I ... The observant may quickly point out that these two loops may have different; semantics: if the container (a basic block in this case) is being mutated, then; ""``BB->end()``"" may change its value every time through the loop and the second; loop may not in fact be correct. If you actually do depend on this behavior,; please write the loop in the first form and add a comment indicating that you; did it intentionally. Why do we prefer the second form (when correct)? Writing the loop in the first; form has two problems. First it may be less efficient than evaluating it at the; start of the loop. In this case, the cost is probably minor --- a few extra; loads every time through the loop. However, if the base expression is more; complex, then the cost can rise quickly. I've seen loops where the end; expression was actually something like: ""``SomeMap[X]->end()``"" and map lookups; really aren't cheap. By writing it in the second form consistently, you; eliminate the issue entirely and don't even have to think about it. The second (even bigger) issue is that writing the loop in the first form hints; to the reader that the loop is mutating the container (a fact that a comment; would handily confirm!). If you write the loop in the second form, it is; immediately obvious without even looking at the body of the loop that the; container ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:53727,depend,depend,53727,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['depend'],['depend']
Integrability,"ics:; """""""""""""""""""". The '``bitcast``' instruction converts ``value`` to type ``ty2``. It; is always a *no-op cast* because no bits change with this; conversion. The conversion is done as if the ``value`` had been stored; to memory and read back as type ``ty2``. Pointer (or vector of; pointers) types may only be converted to other pointer (or vector of; pointers) types with the same address space through this instruction.; To convert pointers to other types, use the :ref:`inttoptr <i_inttoptr>`; or :ref:`ptrtoint <i_ptrtoint>` instructions first. There is a caveat for bitcasts involving vector types in relation to; endianness. For example ``bitcast <2 x i8> <value> to i16`` puts element zero; of the vector in the least significant bits of the i16 for little-endian while; element zero ends up in the most significant bits for big-endian. Example:; """""""""""""""". .. code-block:: text. %X = bitcast i8 255 to i8 ; yields i8 :-1; %Y = bitcast i32* %x to i16* ; yields i16*:%x; %Z = bitcast <2 x i32> %V to i64; ; yields i64: %V (depends on endianness); %Z = bitcast <2 x i32*> %V to <2 x i64*> ; yields <2 x i64*>. .. _i_addrspacecast:. '``addrspacecast .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = addrspacecast <pty> <ptrval> to <pty2> ; yields pty2. Overview:; """""""""""""""""". The '``addrspacecast``' instruction converts ``ptrval`` from ``pty`` in; address space ``n`` to type ``pty2`` in address space ``m``. Arguments:; """""""""""""""""""". The '``addrspacecast``' instruction takes a pointer or vector of pointer value; to cast and a pointer type to cast it to, which must have a different; address space. Semantics:; """""""""""""""""""". The '``addrspacecast``' instruction converts the pointer value; ``ptrval`` to type ``pty2``. It can be a *no-op cast* or a complex; value modification, depending on the target and the address space; pair. Pointer conversions within the same address space must be; performed with the ``bitcast`` instruction. Note that if the add",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:457505,depend,depends,457505,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['depend'],['depends']
Integrability,"icularly important when; using clang as a compiler, since the clang compiler does not support; anywhere near all the options that gcc does, and we want to make sure; users know which ones are being used. To support this, the driver maintains a bit associated with each; argument of whether it has been used (at all) during the compilation.; This bit usually doesn't need to be set by hand, as the key ArgList; accessors will set it automatically. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief; overview of how things from the gcc driver map to the clang driver. - **Driver Driver**. The driver driver is fully integrated into the clang driver. The; driver simply constructs additional Actions to bind the architecture; during the *Pipeline* phase. The tool chain specific argument; translation is responsible for handling ``-Xarch_``. The one caveat is that this approach requires ``-Xarch_`` not be used; to alter the compilation itself (for example, one cannot provide; ``-S`` as an ``-Xarch_`` argument). The driver attempts to reject; such invocations, and overall there isn't a good reason to abuse; ``-Xarch_`` to that end in practice. The upside is that the clang driver is more efficient and does little; extra work to support universal builds. It also provides better error; reporting and UI consistency. - **Specs**. The clang driver has no direct correspondent for ""specs"". The; majority of the functionality that is embedded in specs is in the; Tool specific argument translation routines. The parts of specs which; control the compilation pipeline are generally part of the *Pipeline*; stage. - **Too",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:15293,integrat,integrated,15293,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['integrat'],['integrated']
Integrability,"id (*foo)(void);; foo(); // warn: function pointer is uninitialized; }. // C; void test() {; void (*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1.x; // warn: uninitialized object pointer; }. // Objective-C; @interface Subscriptable : NSObject; - (id)objectAtIndexedSubscript:(unsigned int)index;; @end. @interface MyClass : Subscriptable; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1[0]; // warn: uninitialized object pointer; }. core.DivideZero; (C, C++, ObjC); Check for division by zero.co. void test(int z) {; if (z == 0); int x = 1 / z; // warn; }. void test() {; int x = 1;; int y = x % 0; // warn; }. core.NonNullParamChecker; (C, C++, ObjC); Check for null pointers passed as arguments to a function whose arguments are; marked with the nonnull attribute. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. core.NullDereference; (C, C++, ObjC); Check for dereferences of null pointers. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. core.StackAdd",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:2569,interface,interface,2569,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['interface'],['interface']
Integrability,"idatable instance variables are; invalidated in the methods annotated with objc_instance_variable_invalidator. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. .. _alpha-osx-cocoa-MissingInvalidationMethod:. alpha.osx.cocoa.MissingInvalidationMethod (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidation methods are present in classes that contain invalidatable instance variables. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. .. _alpha-osx-cocoa-localizability-PluralMisuseChecker:. alpha.osx.cocoa.localizability.PluralMisuseChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns against using one vs. many plural pattern in code when generating localized strings. .. code-block:: objc. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple rem",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:59229,interface,interface,59229,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['interface'],['interface']
Integrability,"ide from all but 'admin' account:. ```cpp; serv->Restrict(""/Folder"", ""visible=admin"");; ```. Hidden folders or objects can not be accessed via http protocol. By default server runs in readonly mode and do not allow methods execution via 'exe.json' or 'exe.bin' requests. To allow such action, one could either grant generic access for all or one could allow to execute only special method:. ```cpp; serv->Restrict(""/Folder/histo1"", ""allow=all"");; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle"");; ```. One could provide several options for the same item, separating them with '&' sign:. ```cpp; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle&hide=guest"");; ```. Complete list of supported options could be found in [TRootSniffer:Restrict()](https://root.cern/doc/master/classTRootSniffer.html#a8af1f11cbfb9c895f968ec0594794120) method documentation. ## Using FastCGI interface. [FastCGI](http://en.wikipedia.org/wiki/FastCGI) is a protocol for interfacing interactive programs with a web server like `Apache`, `lighttpd`, `Microsoft ISS` and many others. When starting THttpServer, one could specify:. ```cpp; serv = new THttpServer(""fastcgi:9000"");; ```. In fact, the FastCGI interface can run in parallel to http server. One can just call:. ```cpp; serv = new THttpServer(""http:8080"");; serv->CreateEngine(""fastcgi:9000"");; ```. One could specify a debug parameter to be able to adjust the FastCGI configuration on the web server:. ```cpp; serv->CreateEngine(""fastcgi:9000?debug=1"");; ```. By default 10 threads are used to process FastCGI requests. This number can be changed with ""thrds"" url parameter:. ```cpp; serv->CreateEngine(""fastcgi:9000?thrds=20"");; ```. If `thrds=0` parameter specified, the only thread will be use to received and process all requests. All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer. ### Configure fastcgi with Apache2. Since Apache version 2.4 FastCGI is d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:10052,protocol,protocol,10052,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['protocol'],['protocol']
Integrability,"ide.; set(LIT_ARGS_DEFAULT ""-sv""); if (MSVC OR XCODE); set(LIT_ARGS_DEFAULT ""${LIT_ARGS_DEFAULT} --no-progress-bar""); endif(); set(LLVM_LIT_ARGS ""${LIT_ARGS_DEFAULT}"" CACHE STRING ""Default options for lit""). get_errc_messages(LLVM_LIT_ERRC_MESSAGES). # On Win32 hosts, provide an option to specify the path to the GnuWin32 tools.; if( WIN32 AND NOT CYGWIN ); set(LLVM_LIT_TOOLS_DIR """" CACHE PATH ""Path to GnuWin32 tools""); endif(); else(); set(LLVM_INCLUDE_TESTS OFF); endif(). umbrella_lit_testsuite_begin(check-all); endif() # LLVM_INCLUDE_TESTS; endif() # standalone. # Make sure that our source directory is on the current cmake module path so that; # we can include cmake files from this directory.; list(INSERT CMAKE_MODULE_PATH 0; ""${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules""; ""${LLVM_COMMON_CMAKE_UTILS}/Modules""; ). # This allows disabling clang's XML dependency even if LLVM finds libxml2.; # By default, clang depends on libxml2 if LLVM does.; option(CLANG_ENABLE_LIBXML2 ""Whether libclang may depend on libxml2""; ${LLVM_ENABLE_LIBXML2}). if(CLANG_ENABLE_LIBXML2); # Don't look for libxml if we're using MSan, since uninstrumented third party; # code may call MSan interceptors like strlen, leading to false positives.; if(NOT LLVM_USE_SANITIZER MATCHES ""Memory.*""); set (LIBXML2_FOUND 0); find_package(LibXml2 2.5.3 QUIET); if (LIBXML2_FOUND); set(CLANG_HAVE_LIBXML 1); endif(); endif(); endif(). include(CheckIncludeFile); check_include_file(sys/resource.h CLANG_HAVE_RLIMITS). # This check requires _GNU_SOURCE on linux; check_include_file(dlfcn.h CLANG_HAVE_DLFCN_H); if( CLANG_HAVE_DLFCN_H ); include(CheckLibraryExists); include(CheckSymbolExists); check_library_exists(dl dlopen """" HAVE_LIBDL); if( HAVE_LIBDL ); list(APPEND CMAKE_REQUIRED_LIBRARIES dl); endif(); list(APPEND CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE); check_symbol_exists(dladdr dlfcn.h CLANG_HAVE_DLADDR); list(REMOVE_ITEM CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE); if( HAVE_LIBDL ); list(REMOVE_ITEM CMAKE_REQUIRED",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:5406,depend,depend,5406,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['depend'],['depend']
Integrability,"ided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a telephone. If you are interested in doing physics, a good HEP framework will save; you much work. Next is a list of the more commonly used components of; ROOT: Command Line Interpreter, Histograms and Fitting, Writing a; Graphical User Interface, 2D Graphics, Input/Output , Collection; Classes, Script Processor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent and modular code - the code reuse provides; consistency and common capabilities between programs, no matter; who writes them. Frameworks make it easier to break programs into; smaller pieces. - More focus on areas of expertise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:7487,integrat,integrated,7487,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['integrat'],['integrated']
Integrability,"idered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new “ContainsErrors” bit to; express “Does this expression or anything within it contain errors” semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRecordDecl``. The *templated*; ``CXXRecordDecl`` represents all the fields and methods inside the class; template, while the ``ClassTemplateDecl`` holds the information which is; related to being a template, i.e. template arguments, etc. We can get the; *",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89848,depend,dependent,89848,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['depend'],['dependent']
Integrability,"idget's layout and add it to the parent list of children. - Set main window attributes. - Map all sub windows. - Initialize the layout algorithm via `Resize(GetDefaultSize())`; method. - Map the main frame. - Execution of the even-processing loop. ### A Standalone Version. As usual a standalone program in C++ has to contain a main() function -; the starting point for the application execution. In this case it is; better to separate the program code creating a program header file; example2a.h with the `MyMainFrame` class declaration and; `example2a.cxx `- with the class methods implementation. To run our; simple example as a standalone application we need to create in addition; an object of class **`TApplication`**. It will make a correct; initialization of the dictionaries if it is not yet done. It will be; responsible for holding everything together and to handle all events in; the application. Its environment provides an interface to the ROOT; graphics system and by calling the `Run()` method the event loop starts; and the application program is waiting for the user action. The; application exits only if the top level window is not closed. Two header; files are used in addition: `TApplication.h` - for the class; **`TApplication`** and `TGClient.h` that is used to make initial; connection to the graphics system. The class **`TApplication`** must be; instantiated only once in any given application. The original list of; argument options can be retrieved via the `Argc()` and `Argv()` methods. Note: to have signals/slots working we need to create a dictionary for; the class `MyMainFrame`, i.e. we create the file `ex2aLinkDef.h`; containing the line:. ``` {.cpp}; #pragma link C++ class MyMainFrame;; ```. We compile the example:. ``` {.cpp}; rootcling -f ex2aDict.cxx -c example2a.h ex2aLinkDef.h; g++ -o example2a example2a.cxx ex2aDict.cxx `root-config --cflags --glibs`; ```. `example2a.h`. ``` {.cpp}; #include <TQObject.h>; #include <RQ_OBJECT.h>. class TGWindow;; clas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:16066,interface,interface,16066,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['interface'],['interface']
Integrability,"ieces of code generation algorithms. All of the target description classes (except the :raw-html:`<tt>` `DataLayout`_; :raw-html:`</tt>` class) are designed to be subclassed by the concrete target; implementation, and have virtual methods implemented. To get to these; implementations, the :raw-html:`<tt>` `TargetMachine`_ :raw-html:`</tt>` class; provides accessors that should be implemented by the target. .. _TargetMachine:. The ``TargetMachine`` class; ---------------------------. The ``TargetMachine`` class provides virtual methods that are used to access the; target-specific implementations of the various target description classes via; the ``get*Info`` methods (``getInstrInfo``, ``getRegisterInfo``,; ``getFrameInfo``, etc.). This class is designed to be specialized by a concrete; target implementation (e.g., ``X86TargetMachine``) which implements the various; virtual methods. The only required target description class is the; :raw-html:`<tt>` `DataLayout`_ :raw-html:`</tt>` class, but if the code; generator components are to be used, the other interfaces should be implemented; as well. .. _DataLayout:. The ``DataLayout`` class; ------------------------. The ``DataLayout`` class is the only required target description class, and it; is the only class that is not extensible (you cannot derive a new class from; it). ``DataLayout`` specifies information about how the target lays out memory; for structures, the alignment requirements for various data types, the size of; pointers in the target, and whether the target is little-endian or; big-endian. .. _TargetLowering:. The ``TargetLowering`` class; ----------------------------. The ``TargetLowering`` class is used by SelectionDAG based instruction selectors; primarily to describe how LLVM code should be lowered to SelectionDAG; operations. Among other things, this class indicates:. * an initial register class to use for various ``ValueType``\s,. * which operations are natively supported by the target machine,. * the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:10900,interface,interfaces,10900,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['interface'],['interfaces']
Integrability,"iew comments. Consider using the; `built-in support for fixups <https://git-scm.com/docs/git-commit#Documentation/git-commit.txt---fixupamendrewordltcommitgt>`_; in git. If you do this, you must squash and merge before landing the PR and; you must use the pull request title and description as the commit message.; You can do this manually with an interactive git rebase or with GitHub's; built-in tool. See the section about landing your fix below. When pushing to your branch, make sure you push to the correct fork. Check your; remotes with:. ::. git remote -v. And make sure you push to the remote that's pointing to your fork. Rebasing Pull Requests and Force Pushes; ---------------------------------------; In general, you should avoid rebasing a Pull Request and force pushing to the; branch that's the root of the Pull Request during the review. This action will; make the context of the old changes and comments harder to find and read. Sometimes, a rebase might be needed to update your branch with a fix for a test; or in some dependent code. After your PR is reviewed and accepted, you want to rebase your branch to ensure; you won't encounter merge conflicts when landing the PR. Landing your change; -------------------; When your PR has been accepted you can use the web interface to land your change.; If you have created multiple commits to address feedback at this point you need; to consolidate those commits into one commit. There are two different ways to; do this:. `Interactive rebase <https://git-scm.com/docs/git-rebase#_interactive_mode>`_; with fixup's. This is the recommended method since you can control the final; commit message and inspect that the final commit looks as you expect. When; your local state is correct, remember to force-push to your branch and press; the merge button afterwards. Use the button `Squash and merge` in GitHub's web interface, if you do this; remember to review the commit message when prompted. Afterwards you can select the option `Del",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:4605,depend,dependent,4605,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['depend'],['dependent']
Integrability,"iewer, then this is returned - hence once a viewer is created; it can be obtained elsewhere by:. ``` {.cpp}; TVirtualViewer3D * v = gPad->GetViewer3D();; ```. #### Opening / Closing Scenes. Objects must be added to viewer between `BeginScene()` and `EndScene()`; calls e.g. ``` {.cpp}; viewer->BeginScene();; // Add objects; viewer ->EndScene();; ```. These calls enable the viewer to suspend redraws, and perform internal; caching/setup. If the object you attach to the pad derives from; **`TAtt3D`**, then the pad will take responsibility for calling; `BeginScene()` and `EndScene()` for you. You can always test if the; scene is already open for object addition with:. ``` {.cpp}; viewer->BuildingScene();; ```. ![Overview of 3D viewer architecture](pictures/030000DF.png). Note: the x3d viewer does not support rebuilding of scenes - objects; added after the first Open/Close Scene pair will be ignored. #### Describing Objects - Filling TBuffer3D. The viewers behind the **`TVirtualViewer3D`** interface differ greatly; in their capabilities e.g. - Some support native shape (e.g. spheres/tubes in OpenGL) and can; draw these based on an abstract description. Others always require a; tessellation description based on **`TBuffer3D`**'s `kRaw` /; `kRawSizes` points/lines/segments sections. - Some need the 3D object positions in the master (world) frame,; others can cope with local frames and a translation matrix to place; the object. - Some require bounding boxes for objects - others do not. Similarly some viewer clients are only capable of providing positions in; master frame, cannot provide bounding boxes etc. Additionally we do not; want to incur the cost of expensive tessellation operations if the; viewer does not require them. To cope with these variations the; **`TBuffer3D`** objects are filled by negotiation with the viewer. ![TBuffer3D class hierarchy](pictures/030000E0.png). **`TBuffer3D`** classes are conceptually divided into enumerated; sections: `kCore`, `kBoundingBox`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:126295,interface,interface,126295,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['interface'],['interface']
Integrability,"if (DEFINED LLVM_HAVE_TF_AOT OR LLVM_HAVE_TFLITE); include(TensorFlowCompile); set(LLVM_RAEVICT_MODEL_PATH_DEFAULT ""models/regalloc-eviction""). set(LLVM_RAEVICT_MODEL_CURRENT_URL ""<UNSPECIFIED>"" CACHE STRING ""URL to download the LLVM register allocator eviction model""). if (DEFINED LLVM_HAVE_TF_AOT); tf_find_and_compile(; ${LLVM_RAEVICT_MODEL_PATH}; ${LLVM_RAEVICT_MODEL_CURRENT_URL}; ${LLVM_RAEVICT_MODEL_PATH_DEFAULT}; ""../Analysis/models/gen-regalloc-eviction-test-model.py""; serve; action; RegAllocEvictModel; llvm::RegAllocEvictModel; ); endif(). if (LLVM_HAVE_TFLITE); list(APPEND MLLinkDeps ${tensorflow_c_api} ${tensorflow_fx}); endif(); endif(). # This provides the implementation of MVT and LLT.; # Be careful to append deps on this, since Targets' tablegens depend on this.; add_llvm_component_library(LLVMCodeGenTypes; LowLevelType.cpp; PARTIAL_SOURCES_INTENDED. DEPENDS; vt_gen. LINK_COMPONENTS; Support; ). add_llvm_component_library(LLVMCodeGen; AggressiveAntiDepBreaker.cpp; AllocationOrder.cpp; Analysis.cpp; AssignmentTrackingAnalysis.cpp; AtomicExpandPass.cpp; BasicTargetTransformInfo.cpp; BranchFolding.cpp; BranchRelaxation.cpp; BreakFalseDeps.cpp; BasicBlockSections.cpp; BasicBlockPathCloning.cpp; BasicBlockSectionsProfileReader.cpp; CalcSpillWeights.cpp; CallBrPrepare.cpp; CallingConvLower.cpp; CFGuardLongjmp.cpp; CFIFixup.cpp; CFIInstrInserter.cpp; CodeGen.cpp; CodeGenCommonISel.cpp; CodeGenPassBuilder.cpp; CodeGenPrepare.cpp; CommandFlags.cpp; ComplexDeinterleavingPass.cpp; CriticalAntiDepBreaker.cpp; DeadMachineInstructionElim.cpp; DetectDeadLanes.cpp; DFAPacketizer.cpp; DwarfEHPrepare.cpp; EarlyIfConversion.cpp; EdgeBundles.cpp; EHContGuardCatchret.cpp; ExecutionDomainFix.cpp; ExpandLargeDivRem.cpp; ExpandLargeFpConvert.cpp; ExpandMemCmp.cpp; ExpandPostRAPseudos.cpp; ExpandReductions.cpp; ExpandVectorPredication.cpp; FaultMaps.cpp; FEntryInserter.cpp; FinalizeISel.cpp; FixupStatepointCallerSaved.cpp; FuncletLayout.cpp; GCMetadata.cpp; GCMetadataPrinter.cp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CMakeLists.txt:771,depend,depend,771,interpreter/llvm-project/llvm/lib/CodeGen/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CMakeLists.txt,1,['depend'],['depend']
Integrability,"if a few conditions are true:. #. The pointer stored through is loop invariant.; #. There are no stores or loads in the loop which *may* alias the pointer.; There are no calls in the loop which mod/ref the pointer. If these conditions are true, we can promote the loads and stores in the; loop of the pointer to use a temporary alloca'd variable. We then use the; :ref:`mem2reg <passes-mem2reg>` functionality to construct the appropriate; SSA form for the variable. ``loop-deletion``: Delete dead loops; ------------------------------------. This file implements the Dead Loop Deletion Pass. This pass is responsible for; eliminating loops with non-infinite computable trip counts that have no side; effects or volatile instructions, and do not contribute to the computation of; the function's return value. .. _passes-loop-extract:. ``loop-extract``: Extract loops into new functions; --------------------------------------------------. A pass wrapper around the ``ExtractLoop()`` scalar transformation to extract; each top-level loop into its own new function. If the loop is the *only* loop; in a given function, it is not touched. This is a pass most useful for; debugging via bugpoint. ``loop-reduce``: Loop Strength Reduction; ----------------------------------------. This pass performs a strength reduction on array references inside loops that; have as one or more of their components the loop induction variable. This is; accomplished by creating a new value to hold the initial value of the array; access for the first iteration, and then creating a new GEP instruction in the; loop to increment the value by the appropriate amount. .. _passes-loop-rotate:. ``loop-rotate``: Rotate Loops; -----------------------------. A simple loop rotation transformation. A summary of it can be found in; :ref:`Loop Terminology for Rotated Loops <loop-terminology-loop-rotate>`. .. _passes-loop-simplify:. ``loop-simplify``: Canonicalize natural loops; ---------------------------------------------. Th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:25641,wrap,wrapper,25641,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['wrap'],['wrapper']
Integrability,"if the pattern starts with a slash). Patterns; containing drive names (e.g. ``C:``) are not supported.; * Patterns follow the rules specified in `POSIX 2.13.1, 2.13.2, and Rule 1 of; 2.13.3 <https://pubs.opengroup.org/onlinepubs/9699919799/utilities/; V3_chap02.html#tag_18_13>`_.; * A pattern is negated if it starts with a bang (``!``). To match all files in a directory, use e.g. ``foo/bar/*``. To match all files in; the directory of the ``.clang-format-ignore`` file, use ``*``.; Multiple ``.clang-format-ignore`` files are supported similar to the; ``.clang-format`` files, with a lower directory level file voiding the higher; level ones. Vim Integration; ===============. There is an integration for :program:`vim` which lets you run the; :program:`clang-format` standalone tool on your current buffer, optionally; selecting regions to reformat. The integration has the form of a `python`-file; which can be found under `clang/tools/clang-format/clang-format.py`. This can be integrated by adding the following to your `.vimrc`:. .. code-block:: vim. if has('python'); map <C-K> :pyf <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; elseif has('python3'); map <C-K> :py3f <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; endif. The first line enables :program:`clang-format` for NORMAL and VISUAL mode, the; second line adds support for INSERT mode. Change ""C-K"" to another binding if; you need :program:`clang-format` on a different key (C-K stands for Ctrl+k). With this integration you can press the bound key and clang-format will; format the current line in NORMAL and INSERT mode or the selected region in; VISUAL mode. The line or region is extended to the next bigger syntactic; entity. It operates on the current, potentially unsaved buffer and does not create; or save any files. To revert a formatting, just undo. An alternative option is to format changes when saving a f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:6652,integrat,integrated,6652,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['integrat'],['integrated']
Integrability,"if(). include(HandleLLVMOptions). ######. # Configure all of the various header file fragments LLVM uses which depend on; # configuration variables.; set(LLVM_ENUM_TARGETS """"); set(LLVM_ENUM_ASM_PRINTERS """"); set(LLVM_ENUM_ASM_PARSERS """"); set(LLVM_ENUM_DISASSEMBLERS """"); set(LLVM_ENUM_TARGETMCAS """"); set(LLVM_ENUM_EXEGESIS """"); foreach(t ${LLVM_TARGETS_TO_BUILD}); set( td ${LLVM_MAIN_SRC_DIR}/lib/Target/${t} ). # Make sure that any experimental targets were passed via; # LLVM_EXPERIMENTAL_TARGETS_TO_BUILD, not LLVM_TARGETS_TO_BUILD.; # We allow experimental targets that are not in LLVM_ALL_EXPERIMENTAL_TARGETS,; # as long as they are passed via LLVM_EXPERIMENTAL_TARGETS_TO_BUILD.; if ( NOT ""${t}"" IN_LIST LLVM_ALL_TARGETS AND NOT ""${t}"" IN_LIST LLVM_EXPERIMENTAL_TARGETS_TO_BUILD ); if( ""${t}"" IN_LIST LLVM_ALL_EXPERIMENTAL_TARGETS ); message(FATAL_ERROR ""The target `${t}' is experimental and must be passed ""; ""via LLVM_EXPERIMENTAL_TARGETS_TO_BUILD.""); else(); message(FATAL_ERROR ""The target `${t}' is not a core tier target. It may be ""; ""experimental, if so it must be passed via ""; ""LLVM_EXPERIMENTAL_TARGETS_TO_BUILD.\n""; ""Core tier targets: ${LLVM_ALL_TARGETS}\n""; ""Known experimental targets: ${LLVM_ALL_EXPERIMENTAL_TARGETS}""); endif(); else(); set(LLVM_ENUM_TARGETS ""${LLVM_ENUM_TARGETS}LLVM_TARGET(${t})\n""); string(TOUPPER ${t} T_UPPER); set(LLVM_HAS_${T_UPPER}_TARGET 1); endif(). file(GLOB asmp_file ""${td}/*AsmPrinter.cpp""); if( asmp_file ); set(LLVM_ENUM_ASM_PRINTERS; ""${LLVM_ENUM_ASM_PRINTERS}LLVM_ASM_PRINTER(${t})\n""); endif(); if( EXISTS ${td}/AsmParser/CMakeLists.txt ); set(LLVM_ENUM_ASM_PARSERS; ""${LLVM_ENUM_ASM_PARSERS}LLVM_ASM_PARSER(${t})\n""); endif(); if( EXISTS ${td}/Disassembler/CMakeLists.txt ); set(LLVM_ENUM_DISASSEMBLERS; ""${LLVM_ENUM_DISASSEMBLERS}LLVM_DISASSEMBLER(${t})\n""); endif(); if( EXISTS ${td}/MCA/CMakeLists.txt ); set(LLVM_ENUM_TARGETMCAS; ""${LLVM_ENUM_TARGETMCAS}LLVM_TARGETMCA(${t})\n""); endif(); if( EXISTS ${LLVM_MAIN_SRC_DIR}/tools/llvm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:40230,message,message,40230,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"if(); endif( LLVM_USE_INTEL_JITEVENTS ). option(LLVM_USE_OPROFILE; ""Use opagent JIT interface to inform OProfile about JIT code"" OFF). option(LLVM_EXTERNALIZE_DEBUGINFO; ""Generate dSYM files and strip executables and libraries (Darwin Only)"" OFF). option(LLVM_EXPERIMENTAL_DEBUGINFO_ITERATORS; ""Add extra Booleans to ilist_iterators to communicate facts for debug-info"" OFF). set(LLVM_CODESIGNING_IDENTITY """" CACHE STRING; ""Sign executables and dylibs with the given identity or skip if empty (Darwin Only)""). # If enabled, verify we are on a platform that supports oprofile.; if( LLVM_USE_OPROFILE ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""OProfile support is available on Linux only.""); endif( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); endif( LLVM_USE_OPROFILE ). option(LLVM_USE_PERF; ""Use perf JIT interface to inform perf about JIT code"" OFF). # If enabled, verify we are on a platform that supports perf.; if( LLVM_USE_PERF ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""perf support is available on Linux only.""); endif( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); endif( LLVM_USE_PERF ). set(LLVM_USE_SANITIZER """" CACHE STRING; ""Define the sanitizer used to build binaries and tests.""); option(LLVM_OPTIMIZE_SANITIZED_BUILDS ""Pass -O1 on debug sanitizer builds"" ON); set(LLVM_UBSAN_FLAGS; ""-fsanitize=undefined -fno-sanitize=vptr,function -fno-sanitize-recover=all""; CACHE STRING; ""Compile flags set to enable UBSan. Only used if LLVM_USE_SANITIZER contains 'Undefined'.""); set(LLVM_LIB_FUZZING_ENGINE """" CACHE PATH; ""Path to fuzzing library for linking with fuzz targets""). option(LLVM_USE_SPLIT_DWARF; ""Use -gsplit-dwarf when compiling llvm and --gdb-index when linking."" OFF). # Define an option controlling whether we should build for 32-bit on 64-bit; # platforms, where supported.; if( CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT (WIN32 OR ${CMAKE_SYSTEM_NAME} MATCHES ""AIX"")); # TODO: support other platforms and toolchains.; option(LLVM_BUILD_32_BI",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:28118,message,message,28118,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['message'],['message']
Integrability,"if(LLVM_BYE_LINK_INTO_TOOLS); message(WARNING ""Setting LLVM_BYE_LINK_INTO_TOOLS=ON only makes sense for testing purpose""); endif(). # The plugin expects to not link against the Support and Core libraries,; # but expects them to exist in the process loading the plugin. This doesn't; # work with DLLs on Windows (where a shared library can't have undefined; # references), so just skip this example on Windows.; if (NOT WIN32 AND NOT CYGWIN); add_llvm_pass_plugin(Bye; Bye.cpp; DEPENDS; intrinsics_gen; BUILDTREE_ONLY; ). install(TARGETS ${name} RUNTIME DESTINATION ""${LLVM_EXAMPLES_INSTALL_DIR}""); set_target_properties(${name} PROPERTIES FOLDER ""Examples""); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Bye/CMakeLists.txt:30,message,message,30,interpreter/llvm-project/llvm/examples/Bye/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Bye/CMakeLists.txt,1,['message'],['message']
Integrability,"if(LLVM_EXAMPLEIRTRANSFORMS_LINK_INTO_TOOLS); message(WARNING ""Setting LLVM_EXAMPLEIRTRANSFORMS_LINK_INTO_TOOLS=ON only makes sense for testing purpose""); endif(). # The plugin expects to not link against the Support and Core libraries,; # but expects them to exist in the process loading the plugin. This doesn't; # work with DLLs on Windows (where a shared library can't have undefined; # references), so just skip this example on Windows.; if (NOT WIN32 AND NOT CYGWIN); add_llvm_pass_plugin(ExampleIRTransforms; SimplifyCFG.cpp; DEPENDS; intrinsics_gen; BUILDTREE_ONLY; ). install(TARGETS ${name} RUNTIME DESTINATION ""${LLVM_EXAMPLES_INSTALL_DIR}""); set_target_properties(${name} PROPERTIES FOLDER ""Examples""); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/CMakeLists.txt:46,message,message,46,interpreter/llvm-project/llvm/examples/IRTransforms/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/CMakeLists.txt,1,['message'],['message']
Integrability,"if(WIN32); # We need cmake to support exporting of symbols not only from libraries but; # from executables too. This way cling can find symbols from its own; # executable during runtime.; cmake_minimum_required(VERSION 3.6.2); else(WIN32); # support of earlier cmake versions will be removed soon; cmake_minimum_required(VERSION 3.5); endif(WIN32). # If we are not building as a part of LLVM, build Cling as an; # standalone project, using LLVM as an external library:; if( CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR ); project(Cling). # See <https://llvm.org/docs/CMake.html#embedding-llvm-in-your-project>.; find_package(LLVM REQUIRED CONFIG); message(STATUS ""Found LLVM ${LLVM_PACKAGE_VERSION}""); message(STATUS ""Using LLVMConfig.cmake in: ${LLVM_DIR}""). separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS}); add_definitions(${LLVM_DEFINITIONS_LIST}). find_package(Clang REQUIRED CONFIG); message(STATUS ""Found supported version: Clang ${CLANG_PACKAGE_VERSION}""); message(STATUS ""Using ClangConfig.cmake in: ${Clang_DIR}""). find_program(LLVM_TABLEGEN_EXE ""llvm-tblgen"" ${LLVM_TOOLS_BINARY_DIR}; NO_DEFAULT_PATH). list(APPEND CMAKE_MODULE_PATH ""${LLVM_CMAKE_DIR}""); include(AddLLVM); include(TableGen); include(HandleLLVMOptions); include(VersionFromVCS). set(PACKAGE_VERSION ""${LLVM_PACKAGE_VERSION}""). if (NOT DEFINED LLVM_INCLUDE_TESTS); set(LLVM_INCLUDE_TESTS ON); endif(). include_directories(""${LLVM_INCLUDE_DIRS}""); link_directories(""${LLVM_LIBRARY_DIR}""). set( CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin ); set( CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib${LLVM_LIBDIR_SUFFIX} ); set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib${LLVM_LIBDIR_SUFFIX} ). if(LLVM_INCLUDE_TESTS); find_package(Python3 3.8 REQUIRED COMPONENTS Interpreter). # Check prebuilt llvm/utils.; if(EXISTS ${LLVM_TOOLS_BINARY_DIR}/FileCheck${CMAKE_EXECUTABLE_SUFFIX}; AND EXISTS ${LLVM_TOOLS_BINARY_DIR}/count${CMAKE_EXECUTABLE_SUFFIX}; AND EXISTS ${LLVM_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/CMakeLists.txt:654,message,message,654,interpreter/cling/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/CMakeLists.txt,4,['message'],['message']
Integrability,"ific that will be seen afterwards for the one dimensional one. ![ROOT::Math Numerical Integrator classes](pictures/Integration.png). The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important; to notice that the two grayed classes (the one which name starts by GSL) are part of the *MathMore* library.; We will later show in more detail the differences between the implementations. ### Integration of One-dimensional Functions. #### Using `ROOT::Math::IntegratorOneDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT.; If no algorithm is specified, the default one is used. The default Integrator together with other integration options; such as relative and absolute tolerance, can be specified using the static method of the; `ROOT::Math::IntegratorOneDimOptions`. ```{.cpp}; #include ""Math/Integrator.h"". const double ERRORLIMIT = 1E-3;. double f(double x) {; return x;; }. double f2(const double * x) {; return x[0] + x[1];; }. int testIntegration1D() {. const double RESULT = 0.5;; int status = 0;. // set default tolerances for all integrators; ROOT::Math::IntegratorOneDimOptions::SetDefaultAbsTolerance(1.E-6);; ROOT::Math::IntegratorOneDimOptions::SetDefaultRelTolerance(1.E-6);. ROOT::Math::Functor1D wf(&f);; ROOT::Math::Integrator ig(ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR);; ig.SetFunction(wf);; double val = ig.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::Integrator ig2(ROOT::Math::IntegrationOneDim::kNONADAPTIVE);; ig2.SetFunction(wf);; val = ig2.Integral(0,1);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ER",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:50876,integrat,integration,50876,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['integrat'],['integration']
Integrability,"ification string. MODULE_CODE_ASM Record; ^^^^^^^^^^^^^^^^^^^^^^. ``[ASM, ...string...]``. The ``ASM`` record (code 4) contains a variable number of values representing; the bytes of ``module asm`` strings, with individual assembly blocks separated; by newline (ASCII 10) characters. .. _MODULE_CODE_SECTIONNAME:. MODULE_CODE_SECTIONNAME Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[SECTIONNAME, ...string...]``. The ``SECTIONNAME`` record (code 5) contains a variable number of values; representing the bytes of a single section name string. There should be one; ``SECTIONNAME`` record for each section name referenced (e.g., in global; variable or function ``section`` attributes) within the module. These records; can be referenced by the 1-based index in the *section* fields of ``GLOBALVAR``; or ``FUNCTION`` records. MODULE_CODE_DEPLIB Record; ^^^^^^^^^^^^^^^^^^^^^^^^^. ``[DEPLIB, ...string...]``. The ``DEPLIB`` record (code 6) contains a variable number of values representing; the bytes of a single dependent library name string, one of the libraries; mentioned in a ``deplibs`` declaration. There should be one ``DEPLIB`` record; for each library name referenced. MODULE_CODE_GLOBALVAR Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[GLOBALVAR, strtab offset, strtab size, pointer type, isconst, initid, linkage, alignment, section, visibility, threadlocal, unnamed_addr, externally_initialized, dllstorageclass, comdat, attributes, preemptionspecifier]``. The ``GLOBALVAR`` record (code 7) marks the declaration or definition of a; global variable. The operand fields are:. * *strtab offset*, *strtab size*: Specifies the name of the global variable.; See `STRTAB_BLOCK Contents`_. * *pointer type*: The type index of the pointer type used to point to this; global variable. * *isconst*: Non-zero if the variable is treated as constant within the module,; or zero if it is not. * *initid*: If non-zero, the value index of the initializer for this variable,; plus 1. .. _linkage type:. * *linkage*: ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:26763,depend,dependent,26763,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['depend'],['dependent']
Integrability,"ig/Disassemblers.def; ); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/Targets.def.in; ${LLVM_INCLUDE_DIR}/llvm/Config/Targets.def; ); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/TargetMCAs.def.in; ${LLVM_INCLUDE_DIR}/llvm/Config/TargetMCAs.def; ); configure_file(; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Config/TargetExegesis.def.in; ${LLVM_INCLUDE_DIR}/llvm/Config/TargetExegesis.def; ). # They are not referenced. See set_output_directory().; set( CMAKE_RUNTIME_OUTPUT_DIRECTORY ${LLVM_TOOLS_BINARY_DIR} ); set( CMAKE_LIBRARY_OUTPUT_DIRECTORY ${LLVM_LIBRARY_DIR} ); set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${LLVM_LIBRARY_DIR} ). # For up-to-date instructions for installing the TFLite dependency, refer to; # the bot setup script: https://github.com/google/ml-compiler-opt/blob/main/buildbot/buildbot_init.sh; set(LLVM_HAVE_TFLITE """" CACHE BOOL ""Use tflite""); if (LLVM_HAVE_TFLITE); find_package(tensorflow-lite REQUIRED); endif(). # For up-to-date instructions for installing the Tensorflow dependency, refer to; # the bot setup script: https://github.com/google/ml-compiler-opt/blob/main/buildbot/buildbot_init.sh; # Specifically, assuming python3 is installed:; # python3 -m pip install --upgrade pip && python3 -m pip install --user tf_nightly==2.3.0.dev20200528; # Then set TENSORFLOW_AOT_PATH to the package install - usually it's ~/.local/lib/python3.7/site-packages/tensorflow; #; set(TENSORFLOW_AOT_PATH """" CACHE PATH ""Path to TensorFlow pip install dir""). if (NOT TENSORFLOW_AOT_PATH STREQUAL """"); set(LLVM_HAVE_TF_AOT ""ON"" CACHE BOOL ""Tensorflow AOT available""); set(TENSORFLOW_AOT_COMPILER; ""${TENSORFLOW_AOT_PATH}/../../../../bin/saved_model_cli""; CACHE PATH ""Path to the Tensorflow AOT compiler""); include_directories(${TENSORFLOW_AOT_PATH}/include); add_subdirectory(${TENSORFLOW_AOT_PATH}/xla_aot_runtime_src; ${CMAKE_ARCHIVE_OUTPUT_DIRECTORY}/tf_runtime); install(TARGETS tf_xla_runtime EXPORT LLVMExports; ARCHIVE DESTINATION lib${LLVM_LIBDIR_SUFFIX} COMPONENT tf_xla_runtim",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:42977,depend,dependency,42977,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['depend'],['dependency']
Integrability,"ight less than precision are excluded. A demo macro for radioactive material features is; `$ROOTSYS/tutorials/geom/RadioNuclides.C` It demonstrates also the decay; of a mixture made of radionuclides. ![Concentracion of elements derived; fromCa53+Sr78](pictures/030001B4.png). ### Tracking Media. The class **`TGeoMedium`** describes tracking media properties. This has; a pointer to a material and the additional data members representing the; properties related to tracking. ``` {.cpp}; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);; ```. - `name:` name assigned to the medium; - `mat:` pointer to a material; - `params:` array of additional parameters. Another constructor allows effectively defining tracking parameters in; GEANT3 style:. ``` {.cpp}; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; ```. This constructor is reserved for creating tracking media from the VMC; interface [...]:. - `numed:` user-defined medium index; - `imat:` unique ID of the material; - `others:` see G3 documentation. Looking at our simple world example, one can see that for creating; volumes one needs to create tracking media before. The way to proceed; for those not interested in performing tracking with external MC's is to; define and use only one `dummy tracking medium` as in the example (or a; `NULL` pointer). ### User Interface for Handling Materials and Media. The **`TGeoManager`** class contains the API for accessing and handling; defined materials:. ``` {.cpp}; TGeoManager::GetMaterial(name);; ```. ## Shapes. Shapes are geometrical objects that provide the basic modeling; functionality. They provide the definition of the `local` coordinate; system of the volume. Any volume must have a shape. Any shape recognized; by the modeller has to derive from the base **`TGeoShape`** class,; providing methods for:. - Finding out if a point defined ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:22505,interface,interface,22505,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability,"ihood ratio. The boundary of the interval is equivalent to a MINUIT/MINOS contour about the maximum likelihood estimator. . HybridCalculator: hypothesis test calculator using a Bayesian-frequentist hybrid method (often called in HEP as CLs method). This class extends the functionality of the TLimit class by taking advantage of the RooFit package. The result of the calculator is returned as an HybridResult pointer. HybridResult implements the HypoTestResult interface. The class HybridPlot allows for a graphical representation of a HybridResult.; ; HybridCalculator implements the interface class HypoTestCalculator. A constructor exists taking as input the pdf's (expressed as RooAbsPdf instances) for the signal+background (alternate) and background only (null) hypothesis and the data set (as RooAbsData instance). One can provide optionally also the nuisance parameters and its pdf which will be marginalized by the calculator. The HypoTestCalculator interface provides also the possibility of setting the model via a Rooworkspace class and names of the pdf. This possibility is not yet supported for the HybridCalculator class. ; ; . Additional classes or functions provided by RooStats are: ; ; NumberCountingUtils: a collection of number counting statistical utilities; 	NumberCountingPdfFactory: a factory for building ; 	the PDF and the data for a number counting combination and adding them in a RooWorkspace. ; 	SPlot: implementation of the SPlot statistical tool to unfold data distributions and based on RooFit. This class uses the same statistical algorithm used in the class TSPlot, but in addition it provides the possibility to model the input distributions using RooFit model classes. This class can then be used in combination of a RooFit maximum likelihood fit. ; 	. RooStats tutorials macros; 	Tutorials are provided in the tutorials/roostats directory:. 	; rs100_numbercounting.C: an example of a combination of two searches using number counting with background uncertainty.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:11827,interface,interface,11827,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['interface'],['interface']
Integrability,"ike so:. .. code-block:: objc. [receiver foo: fooArg bar: barArg baz: bazArg]. This looks in the dynamic class of the receiver for a method with this name,; then in that class's superclass, etc., until it finds something it can execute.; The receiver ""expression"" may also be the name of a class, in which case the; actual receiver is the class object for that class, or (within method; definitions) it may be ``super``, in which case the lookup algorithm starts; with the static superclass instead of the dynamic class. The actual methods; dynamically found in a class are not those declared in the ``@interface``, but; those defined in a separate ``@implementation`` declaration; however, when; compiling a call, typechecking is done based on the methods declared in the; ``@interface``. Method declarations may also be grouped into :arc-term:`protocols`, which are not; inherently associated with any class, but which classes may claim to follow.; Object pointer types may be qualified with additional protocols that the object; is known to support. :arc-term:`Class extensions` are collections of ivars and methods, designed to; allow a class's ``@interface`` to be split across multiple files; however,; there is still a primary implementation file which must see the; ``@interface``\ s of all class extensions. :arc-term:`Categories` allow; methods (but not ivars) to be declared *post hoc* on an arbitrary class; the; methods in the category's ``@implementation`` will be dynamically added to that; class's method tables which the category is loaded at runtime, replacing those; methods in case of a collision. In the standard environment, objects are allocated on the heap, and their; lifetime is manually managed using a reference count. This is done using two; instance methods which all classes are expected to implement: ``retain``; increases the object's reference count by 1, whereas ``release`` decreases it; by 1 and calls the instance method ``dealloc`` if the count reaches 0. To; si",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:5980,protocol,protocols,5980,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['protocol'],['protocols']
Integrability,"il, GSoC, \; Axel Naumann, CERN/SFT,\; Simon Pfreundschuh, GSoC, CERN/SFT,\; Danilo Piparo, CERN/SFT,\; Timur Pocheptsov, CERN/SFT,\; Fons Rademakers, CERN/IT,\; Paul Russo, Fermilab,\; Enric Tejedor Saavedra, CERN/SFT,\; George Troska, Dortmund Univ.,\; Liza Sakellari, CERN/SFT,\; Alex Saperstein, ANL,\; Manuel Tobias Schiller, CERN/LHCb,\; David Smith, CERN/IT,\; Peter Speckmayer,\; Tom Stevenson, Queen Mary University of London, ATLAS\; Matevz Tadel, UCSD/CMS, Eve,\; Peter van Gemmeren, ANL, ATLAS,\; Xavier Valls, CERN/SFT, \; Vassil Vassilev, Fermilab/CMS,\; Stefan Wunsch, KIT, CMS\; Omar Zapata, University of Antioquia, CERN/SFT.; . <a name=""core-libs""></a>. ## General. * Remove many instances of new warnings issued by gcc 6.1; * Significant update of the valgrind suppression file to hide intentional lack; of delete of some entities at the end of the process.; * Resolved several memory leaks.; * Added deprecation system: when compiling against interfaces marked R__DEPRECATED, the compiler will issue a warning showing the ROOT version when the interface will be removed.; * From this version on, building ROOT with CMake requires CMake &gt;= 3.4.3. ## Core Libraries. ROOT prepares for [cxx modules](http://clang.llvm.org/docs/Modules.html). One of; the first requirements is its header files to be self-contained (section ""Missing; Includes""). ROOT header files were cleaned up from extra includes and the missing; includes were added. This could be considered as backward incompatibility (for good however). User; code may need to add extra includes, which were previously resolved indirectly; by including a ROOT header. For example:. * TBuffer.h - TObject.h doesn't include TBuffer.h anymore. Third party code,; replying on the definition of TBufer will need to include TBuffer.h, along; with TObject.h.; * TSystem.h - for some uses of gSystem.; * GeneticMinimizer.h; * ... Other improvements, which may cause compilation errors in third party code:. * If you get `std::type_i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:1853,interface,interfaces,1853,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,2,['interface'],"['interface', 'interfaces']"
Integrability,"il; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:3706,message,message,3706,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,1,['message'],['message']
Integrability,"il; the *absolute* time in seconds and nanoseconds since beginning of; the epoch (January, 1st, 1970) is reached; to use relative timeouts; ‘‘delta'', it is required to calculate the absolute time at the; beginning of waiting ‘‘now''; for example:. ``` {.cpp}; Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970; ```. - Return value wait of `MyCondition.TimedWait` should be 0, if; `MyCondition.Signal()` was received, and should be nonzero, if; timeout was reached. The conditions example shows how three threaded functions are; synchronized using **`TCondition`**: a ROOT script `condstart.C` starts; the threads, which are defined in a shared library; (`conditions.cxx, conditions.h`). #### Xlib Connections. Usually `Xlib` is not thread safe. This means that calls to the X could; fail, when it receives X-messages from different threads. The actual; result depends strongly on which version of `Xlib` has been installed on; your system. The only thing we can do here within ROOT is calling a; special function `XInitThreads() `(which is part of the `Xlib`), which; should (!) prepare the `Xlib` for the usage with threads. To avoid further problems within ROOT some redefinition of the; ***`gPad`*** pointer was done (that's the main reason for the; recompilation). When a thread creates a **`TCanvas`**, this object is; actually created in the main thread; this should be transparent to the; user. Actions on the canvas are controlled via a function, which returns; a pointer to either thread specific data (TSD) or the main thread; pointer. This mechanism works currently only for ***`gPad`***,; ***`gDirectory`***, ***`gFile`*** and will be implemented soon for other; global Objects as e.g. ***`gVirtualX`***. #### Canceling a TThread. Canceling of a thread is a rather dangerous action. In **`TThread`**; canceling is forbidden by default. The user can change this default by; calli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:10126,depend,depends,10126,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['depend'],['depends']
Integrability,"ilable; transformations are:. - 3D rotation classes. - rotation described by a 3x3 matrix (**`ROOT::Math::Rotation3D`**). - rotation described by Euler angles (**`ROOT::Math::EulerAngles`**). - rotation described by a direction axis and an angle; (**`ROOT::Math::AxisAngle`**). - rotation described by a quaternion (**`ROOT::Math::Quaternion`**). - optimized rotation around `x` (**`ROOT::Math::RotationX`**), `y`; (**`ROOT::Math::RotationY`**) and `z` (**`ROOT::Math::RotationZ`**); and described by just one angle. - 3D transformation: we describe the transformations defined as a; composition between a rotation and a translation using the class; **`ROOT::Math::Transform3D`**. It is important to note that; transformations act differently on vectors and points. The vectors only; rotate, therefore when applying a transformation (rotation +; translation) on a vector, only the rotation operates while the; translation has no effect. The **`Transform3D`** class interface is; similar to the one used in the CLHEP Geometry package (class; <HepGeom::Transform3D>). - Lorentz rotation:. - generic Lorentz rotation described by a `4x4` matrix containing a 3D; rotation part and a boost part (class; **`ROOT::Math::LorentzRotation`**). - a pure boost in an arbitrary direction and described by a 4x4; symmetric matrix or 10 numbers (class **`ROOT::Math::Boost`**). - boost along the axis:` x `(**`ROOT::Math::BoostX`**),; `y `(**`ROOT::Math::BoostY`**) and `z `(**`ROOT::Math::BoostZ`**). #### Minimal Vector Classes Interface. We have tried to keep the interface to a minimal level by:. - Avoiding methods that provide the same functionality but use; different names (like `getX()` and `x()`). - Minimizing the number of setter methods, avoiding methods, which can; be ambiguous and can set the vector classes in an inconsistent; state. We provide only methods which set all the coordinates at the; same time or set only the coordinates on which the vector is based,; for example `SetX()` for a Cartesi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:74071,interface,interface,74071,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interface']
Integrability,"ild; system can cache the resource directory by itself and pass ``-resource-dir <resource-dir>``; explicitly in the command line options:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 -resource-dir <resource-dir> mod.cppm -c -o mod.o. Possible Questions; ==================. How modules speed up compilation; --------------------------------. A classic theory for the reason why modules speed up the compilation is:; if there are ``n`` headers and ``m`` source files and each header is included by each source file,; then the complexity of the compilation is ``O(n*m)``;; But if there are ``n`` module interfaces and ``m`` source files, the complexity of the compilation is; ``O(n+m)``. So, using modules would be a big win when scaling.; In a simpler word, we could get rid of many redundant compilations by using modules. Roughly, this theory is correct. But the problem is that it is too rough.; The behavior depends on the optimization level, as we will illustrate below. First is ``O0``. The compilation process is described in the following graph. .. code-block:: none. ├-------------frontend----------┼-------------middle end----------------┼----backend----┤; │ │ │ │; └---parsing----sema----codegen--┴----- transformations ---- codegen ----┴---- codegen --┘. ┌---------------------------------------------------------------------------------------┐; | │; | source file │; | │; └---------------------------------------------------------------------------------------┘. ┌--------┐; │ │; │imported│; │ │; │ code │; │ │; └--------┘. Here we can see that the source file (could be a non-module unit or a module unit) would get processed by the; whole pipeline.; But the imported code would only get involved in semantic analysis, which is mainly about name lookup,; overload resolution and template instantiation.; All of these processes are fast relative to the whole compilation process.; More importantly, the imported code only n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:40203,depend,depends,40203,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['depend'],['depends']
Integrability,"ile changes (and none of the headers it; depends on), reparsing of that source file can use the precompiled preamble and; start parsing after the ``#include``\ s, so parsing time is proportional to the; size of the source file (rather than all of its includes). However, the; compilation of that translation unit may already use a precompiled header: in; this case, Clang will create the precompiled preamble as a chained precompiled; header that refers to the original precompiled header. This drastically; reduces the time needed to serialize the precompiled preamble for use in; reparsing. Chained precompiled headers get their name because each precompiled header can; depend on one other precompiled header, forming a chain of dependencies. A; translation unit will then include the precompiled header that starts the chain; (i.e., nothing depends on it). This linearity of dependencies is important for; the semantic model of chained precompiled headers, because the most-recent; precompiled header can provide information that overrides the information; provided by the precompiled headers it depends on, just like a header file; ``B.h`` that includes another header ``A.h`` can modify the state produced by; parsing ``A.h``, e.g., by ``#undef``'ing a macro defined in ``A.h``. There are several ways in which chained precompiled headers generalize the AST; file model:. Numbering of IDs; Many different kinds of entities --- identifiers, declarations, types, etc.; --- have ID numbers that start at 1 or some other predefined constant and; grow upward. Each precompiled header records the maximum ID number it has; assigned in each category. Then, when a new precompiled header is generated; that depends on (chains to) another precompiled header, it will start; counting at the next available ID number. This way, one can determine, given; an ID number, which AST file actually contains the entity. Name lookup; When writing a chained precompiled header, Clang attempts to write only; informa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:24963,depend,dependencies,24963,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,2,['depend'],"['dependencies', 'depends']"
Integrability,"ile lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the case of the presence of singularities.It uses the; Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that when using the common `ROOT::Math::IntegratorOneDIm` class the enumeration type defining the algorithm must be defined in the namespace `ROOT::Math::IntegrationOneDim` (to distinguish from; the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the `ROOT::Math::IntegratorOneDIm`. ### Multi-dimensional Integration. The multi-dimensional integration algorithm should be applied to functions with dimension larger than one.; Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions. #### Using `ROOT::Math::IntegratorMultiDim`. Here is a code example on how to use the `ROOT::Math::IntegratorOneDim` class; (note that the class is defined in the header file `Math/Integrator.h`). In this example we create; different instance of the class using some of the available algorithms in ROOT. ```{.cpp}; #include ""Math/IntegratorMultiDim.h""; #include ""Math/Functor.h"". double f2(const double * x) {; return x[0] + x[1];; }. int testIntegrationMultiDim() {. const double RESULT = 1.0;; const double ERRORLIMIT = 1E-3;; int status = 0;. ROOT::Math::Functor wf(&f2,2);; double a[2] = {0,0};; double b[2] = {1,1};. ROOT::Math::IntegratorMultiDim ig(ROOT::Math::IntegrationMultiDim::kADAPTIVE);; ig.SetFunction(wf);; double val = ig.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig2(ROOT::Math::IntegrationMultiDim::kVEGAS",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:58290,integrat,integration,58290,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,2,['integrat'],['integration']
Integrability,"ile those with the *`quantile_c`* extension calculate the inverse of; the complement of the cumulative distribution (upper tail integral). All; the inverse distributions are in the MathMore library and are defined in; the header file `Math/ProbFuncInv.h`. The following picture illustrates the available statistical functions; (PDF, CDF and quantiles) in the case of the normal distribution. ![PDF, CDF and quantiles in the case of the normal distribution](pictures/03000128.png). ## Numerical Algorithms. ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:. * Evaluation of function derivatives.; * Evaluation of integrals.; * Finding the roots of a function; * Finding the minimum/maximum of a function. In order to use these algorithm the user needs to provide a function.; ROOT provides a common way of specifying them via some interfaces. ## ROOT::Math Function interfaces. To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function.; In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ![ROOT::Math Function interface structure](pictures/function-hierarchy.png). ### One-dimensional Function Interfaces. These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions.; For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. * `ROOT::Math::IBaseFunctionOneDim`: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing; `double operator() (const double )`. The user class defined only needs to reimplement the pure abstract method `double DoEval(double x)`,; that will do the work of evaluating the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:34849,interface,interfaces,34849,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['interface'],['interfaces']
Integrability,"ile. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part""; }; ]; }; ],; ""version"": 1; }. In this way, we can pass the single command line options after the ``--``.; Then clang-scan-deps will extract the necessary information from the options.; Note that we need to specify the path to the compiler executable instead of saying; ``clang++`` simply. The users may want the scanner to get the transitional dependency information for headers.; Otherwise, the users have to scan twice for the project, once for headers and once for modules.; To address the requirement, clang-scan-deps will recognize the specified preprocessor options; in the given command line and generate the corresponding dependency information. For example,. .. code-block:: console. $ clang-scan-deps -format=p1689 -- ../bin/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o -MD -MT impl_part.ddi -MF impl_part.dep; $ cat impl_part.dep. We will get:. .. code-block:: text. impl_part.ddi: \; /usr/include/bits/wchar.h /usr/include/bits/types/wint_t.h \; /usr/include/bits/types/mbstate_t.h \; /usr/include/bits/types/__mbstate_t.h /usr/include/bits/types/__FILE.h \; /usr/include/bits/types/FILE.h /usr/include/bits/types/locale_t.h \; /usr/include/bits/types/__locale_t.h \; ... When clang-scan-deps detects ``-MF`` option, clang-scan-deps will try to write the; dependency information for headers to the file specified by ``-MF``. Possible Issues: Failed to find system headers; ----------------------------------------------. In case the users encounter errors like ``fatal error: 'stddef.h' file not found``,; probably the specified ``<path-to-compil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:37301,depend,dependency,37301,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['depend'],['dependency']
Integrability,"iled.; Linkage relationships between ``JITDylibs`` determine how inter-module; references are resolved, and symbol resolvers are no longer used. See the; section `Design Overview`_ for more details. Unless multiple JITDylibs are needed to model linkage relationships, ORCv1; clients should place all code in a single JITDylib.; MCJIT clients should use LLJIT (see `LLJIT and LLLazyJIT`_), and can place; code in LLJIT's default created main JITDylib (See; ``LLJIT::getMainJITDylib()``). 2. All JIT stacks now need an ``ExecutionSession`` instance. ExecutionSession; manages the string pool, error reporting, synchronization, and symbol; lookup. 3. ORCv2 uses uniqued strings (``SymbolStringPtr`` instances) rather than; string values in order to reduce memory overhead and improve lookup; performance. See the subsection `How to manage symbol strings`_. 4. IR layers require ThreadSafeModule instances, rather than; std::unique_ptr<Module>s. ThreadSafeModule is a wrapper that ensures that; Modules that use the same LLVMContext are not accessed concurrently.; See `How to use ThreadSafeModule and ThreadSafeContext`_. 5. Symbol lookup is no longer handled by layers. Instead, there is a; ``lookup`` method on JITDylib that takes a list of JITDylibs to scan. .. code-block:: c++. ExecutionSession ES;; JITDylib &JD1 = ...;; JITDylib &JD2 = ...;. auto Sym = ES.lookup({&JD1, &JD2}, ES.intern(""_main""));. 6. The removeModule/removeObject methods are replaced by; ``ResourceTracker::remove``.; See the subsection `How to remove code`_. For code examples and suggestions of how to use the ORCv2 APIs, please see; the section `How-tos`_. How-tos; =======. How to manage symbol strings; ----------------------------. Symbol strings in ORC are uniqued to improve lookup performance, reduce memory; overhead, and allow symbol names to function as efficient keys. To get the; unique ``SymbolStringPtr`` for a string value, call the; ``ExecutionSession::intern`` method:. .. code-block:: c++. ExecutionSession ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:21287,wrap,wrapper,21287,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['wrap'],['wrapper']
Integrability,"iler and standard library provide an implmentation, it is used. The type string_view describes an object that can refer to a constant contiguous sequence of char-like objects with the first element of the sequence at position zero. This type is used throughout the ROOT code to avoid copying strings when a; sub-string is needed and to extent interfaces that uses to take a const char*; to take a std::string_view as thus be able to be directly directly passed a; TString, a std::string or a std::string_view. Usage example:. ``` {.cpp}; // With SetName(std::string_view); std::string str; …; obj.SetName( str );; obj.SetName( {str.data()+pos, len} );; ```. ### Meta library. #### Backward Incompatibilities. TIsAProxy's constructor no longer take the optional and unused 2nd argument which was reserved for a 'context'. This context was unused in TIsAProxy itself and was not accessible from derived classes. #### Interpreter. The new interface `TInterpreter::Declare(const char* code)` will declare the; code to the interpreter with all interpreter extensions disabled, i.e. as; ""proper"" C++ code. No autoloading or synamic lookup will be performed. A new R__LOAD_LIBRARY(libWhatever) will load libWhatever at parse time. This allows ROOT to resolve symbols from this library very early on. It is a work-around for the following code from ROOT 5:. ``` {.cpp}; // ROOT 5:; void func() {; gSystem->Load(""libEvent"");; Event* e = new Event;; }; ```. Instead, write:. ``` {.cpp}; // ROOT 6:; R__LOAD_LIBRARY(libEvent); #include ""Event.h"". void func() {; Event* e = new Event;; }; ```. #### TClass. Introduced new overload for calculating the TClass CheckSum:. ``` {.cpp}; UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const;; ```. which indicates via the 'isvalid' boolean whether the checksum could be; calculated correctly or not. ### TROOT. Implemented new gROOT->GetTutorialsDir() static method to return the actual location of the tutorials directory.; This is $ROOTSYS/tutorials when ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:2724,interface,interface,2724,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['interface'],['interface']
Integrability,"iling; all back-ends. For that reason, you should also set the; ``TARGETS_TO_BUILD`` to only build the back-end you're targeting to. You must set the ``CMAKE_INSTALL_PREFIX``, otherwise a ``ninja install``; will copy ARM binaries to your root filesystem, which is not what you; want. Hacks; -----. There are some bugs in current LLVM, which require some fiddling before; running CMake:. #. If you're using Clang as the cross-compiler, there is a problem in; the LLVM ARM back-end that is producing absolute relocations on; position-independent code (``R_ARM_THM_MOVW_ABS_NC``), so for now, you; should disable PIC:. .. code-block:: bash. -DLLVM_ENABLE_PIC=False. This is not a problem, since Clang/LLVM libraries are statically; linked anyway, it shouldn't affect much. #. The ARM libraries won't be installed in your system.; But the CMake prepare step, which checks for; dependencies, will check the *host* libraries, not the *target*; ones. Below there's a list of some dependencies, but your project could; have more, or this document could be outdated. You'll see the errors; while linking as an indication of that. Debian based distros have a way to add ``multiarch``, which adds; a new architecture and allows you to install packages for those; systems. See https://wiki.debian.org/Multiarch/HOWTO for more info. But not all distros will have that, and possibly not an easy way to; install them in any anyway, so you'll have to build/download; them separately. A quick way of getting the libraries is to download them from; a distribution repository, like Debian (http://packages.debian.org/jessie/),; and download the missing libraries. Note that the ``libXXX``; will have the shared objects (``.so``) and the ``libXXX-dev`` will; give you the headers and the static (``.a``) library. Just in; case, download both. The ones you need for ARM are: ``libtinfo``, ``zlib1g``,; ``libxml2`` and ``liblzma``. In the Debian repository you'll; find downloads for all architectures. After you download ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst:4873,depend,dependencies,4873,interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,1,['depend'],['dependencies']
Integrability,"ill able to; benefit from their use. The **`TThread`** class is available on all; platforms, which provide a POSIX compliant thread implementation. On; Linux, Xavier Leroy's Linux Threads implementation is widely used, but; the **`TThread`** implementation should be usable on all platforms that; provide `pthread`. **Linux Xlib on SMP machines** is not yet thread-safe. This may cause; crashes during threaded graphics operations; this problem is independent; of ROOT. **Object instantiation:** there is no implicit locking mechanism for; memory allocation and global ROOT lists. The user has to explicitly; protect their code when using them. ## The Signals of ROOT. The list of default signals handled by ROOT is:. ``` {.cpp}; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingException; kSigSystemkSigWindowChanged; ```. The signals ***`kSigFloatingException`***,; ***`kSigSegmentationViolation`***, ***`kSigIllegalInstruction`***, and; ***`kSigBus`*** cause the printing of the ***`*** Break *** `*** message; and make a long jump back to the ROOT prompt. No other custom; **`TSignalHandler`** can be added to these signals. The ***`kSigAlarm`*** signal handles asynchronous timers. The; ***`kSigWindowChanged`*** signal handles the resizing of the terminal; window. The other signals have no other behavior then that to call any; registered **`TSignalHandler`*****`::Notify()`***. When building in interactive application the use of the **`TRint`**; object handles the `kSigInterrupt` signal. It causes the printing of the; message: ***`*** Break *** keyboard interrupt `***and makes a long jump; back to the ROOT command prompt. If no **`TRint`** object is created,; there will be no `kSigInterrupt` handling. All signals can be reset to; their default UNIX behavior via the call of; **`TSytem`**`::ResetSignal()`. All signals can be ignored via; `TSytem::IgnoreSignal()`. The **`TSytem::IgnoreInterrupt()`** is a method; to toggle the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:18219,message,message,18219,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['message'],['message']
Integrability,"implementation extends its corresponding; node and edge types resulting in the inheritance relationship depicted; in the UML diagram below:. .. image:: uml_nodes_and_edges.png. Graph Construction; ------------------. The graph build algorithm considers dependencies between elements of; a given set of instructions or basic blocks. Any dependencies coming; into or going out of instructions that do not belong to that range; are ignored. The steps in the build algorithm for the DDG are very; similar to the steps in the build algorithm for the PDG. As such,; one of the design goals is to reuse the build algorithm code to; allow creation of both DDG and PDG representations while allowing; the two implementations to define their own distinct and independent; node and edge types. This is achieved by using the well-known builder; design pattern to isolate the construction of the dependence graph; from its concrete representation. The following UML diagram depicts the overall structure of the design; pattern as it applies to the dependence graph implementation. .. image:: uml_builder_pattern.png. Notice that the common code for building the two types of graphs are; provided in the ``DependenceGraphBuilder`` class, while the ``DDGBuilder``; and ``PDGBuilder`` control some aspects of how the graph is constructed; by the way of overriding virtual methods defined in ``DependenceGraphBuilder``. Note also that the steps and the names used in this diagram are for; illustrative purposes and may be different from those in the actual; implementation. Design Trade-offs; -----------------. Advantages:; ^^^^^^^^^^^; - Builder allows graph construction code to be reused for DDG and PDG.; - Builder allows us to create DDG and PDG as separate graphs.; - DDG nodes and edges are completely disjoint from PDG nodes and edges allowing them to change easily and independently. Disadvantages:; ^^^^^^^^^^^^^^; - Builder may be perceived as over-engineering at first.; - There are some similarities betw",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:3575,depend,dependence,3575,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,1,['depend'],['dependence']
Integrability,"imulated; hardware resources. The processor dispatch width defaults to the value; of the ``IssueWidth`` in LLVM's scheduling model. An instruction can be dispatched if:. * The size of the dispatch group is smaller than processor's dispatch width.; * There are enough entries in the reorder buffer.; * There are enough physical registers to do register renaming.; * The schedulers are not full. Scheduling models can optionally specify which register files are available on; the processor. :program:`llvm-mca` uses that information to initialize register; file descriptors. Users can limit the number of physical registers that are; globally available for register renaming by using the command option; ``-register-file-size``. A value of zero for this option means *unbounded*. By; knowing how many registers are available for renaming, the tool can predict; dispatch stalls caused by the lack of physical registers. The number of reorder buffer entries consumed by an instruction depends on the; number of micro-opcodes specified for that instruction by the target scheduling; model. The reorder buffer is responsible for tracking the progress of; instructions that are ""in-flight"", and retiring them in program order. The; number of entries in the reorder buffer defaults to the value specified by field; `MicroOpBufferSize` in the target scheduling model. Instructions that are dispatched to the schedulers consume scheduler buffer; entries. :program:`llvm-mca` queries the scheduling model to determine the set; of buffered resources consumed by an instruction. Buffered resources are; treated like scheduler resources. Instruction Issue; """"""""""""""""""""""""""""""""""; Each processor scheduler implements a buffer of instructions. An instruction; has to wait in the scheduler's buffer until input register operands become; available. Only at that point, does the instruction becomes eligible for; execution and may be issued (potentially out-of-order) for execution.; Instruction latencies are computed by :",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:36146,depend,depends,36146,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['depend'],['depends']
Integrability,"in RooStats are provided in the namespace RooStats.; ; RooStats interfaces. ConfInterval: interface for describing a confidence interval. ; IntervalCalculator: interface for a statistical tool producing confidence intervals (class ConfInterval).; HypoTestResult: interface for representing results of a hypothesis test; HypoTestCalculator: interface for a statistical tool performing an hypothesis test. ; CombinedCalculator: interface for a statistical tool which can produce both hypothesis test results and confidence intervals. ; RooStats concrete classes. The concrete classes describing statistical tools implementing the above interfaces are:; ; ProfileLikelihoodCalculator: it is an implementation of a CombinedCalculator using the profile likelihood ratio as a test statistics. After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer).; LikelihoodInterval: concrete implementation of a ConfInterval interface. It implements connected N-dimensional intervals based on the contour of a likelihood ratio. The boundary of the interval is equivalent to a MINUIT/MINOS contour about the maximum likelihood estimator. . HybridCalculator: hypothesis test calculator using a Bayesian-frequentist hybrid method (often called in HEP as CLs method). This class extends the functionality of the TLimit class by taking advantage of the RooFit package. The result of the calculator is returned as an HybridResult pointer. HybridResult implements the HypoTestResult interface. The class HybridPlot allows for a graphical representation of a HybridResult.; ; HybridCalculator implements the interface class HypoTestCalculator. A constructor exists taking as input the pdf's (expressed as RooAbsPdf instances) for the signal+background (alternate) and background only (null) hypothesis and the data set (as RooAbsData instance). One can provide optionally also the nuisance parameters and i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:10778,interface,interface,10778,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['interface'],['interface']
Integrability,"in other namespaces). .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. * ``NI_All`` (in configuration: ``All``); Indent in all namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. .. _NamespaceMacros:. **NamespaceMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <NamespaceMacros>`; A vector of macros which are used to open namespace blocks. These are expected to be macros of the form:. .. code-block:: c++. NAMESPACE(<namespace-name>, ...) {; <namespace-content>; }. For example: TESTSUITE. .. _ObjCBinPackProtocolList:. **ObjCBinPackProtocolList** (``BinPackStyle``) :versionbadge:`clang-format 7` :ref:`¶ <ObjCBinPackProtocolList>`; Controls bin-packing Objective-C protocol conformance list; items into as few lines as possible when they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conformance; list items into as few lines as possible whenever they go over; ``ColumnLimit``. If ``Never``, lays out Objective-C protocol conformance list items; onto individual lines whenever they go over ``ColumnLimit``. .. code-block:: objc. Always (or Auto, if BinPackParameters=true):; @interface ccccccccccccc () <; ccccccccccccc, ccccccccccccc,; ccccccccccccc, ccccccccccccc> {; }. Never (or Auto, if BinPackParameters=false):; @interface ddddddddddddd () <; ddddddddddddd,; ddddddddddddd,; ddddddddddddd,; ddddddddddddd> {; }. Possible values:. * ``BPS_Auto`` (in configuration: ``Auto``); Automatically determine parameter bin-packing behavior. * ``BPS_Always`` (in configuration: ``Always``); Always bin-pack parameters. * ``BPS_Never`` (in configuration: ``Never``); Never bin-pack parameters. .. _ObjCBlockIndentWidth:. **ObjCBlockIndentWidth** (``Unsigned``) :",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:88343,protocol,protocol,88343,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['protocol'],['protocol']
Integrability,"in the code or a bug in the compiler. The first; thing to check is to make sure it is not using undefined behavior (e.g.; reading a variable before it is defined). In particular, check to see if the; program is clean under various `sanitizers; <https://github.com/google/sanitizers>`_ (e.g. ``clang; -fsanitize=undefined,address``) and `valgrind <http://valgrind.org/>`_. Many; ""LLVM bugs"" that we have chased down ended up being bugs in the program being; compiled, not LLVM. Once you determine that the program itself is not buggy, you should choose; which code generator you wish to compile the program with (e.g. LLC or the JIT); and optionally a series of LLVM passes to run. For example:. .. code-block:: bash. bugpoint -run-llc [... optzn passes ...] file-to-test.bc --args -- [program arguments]. bugpoint will try to narrow down your list of passes to the one pass that; causes an error, and simplify the bitcode file as much as it can to assist; you. It will print a message letting you know how to reproduce the; resulting error. The :doc:`OptBisect <OptBisect>` page shows an alternative method for finding; incorrect optimization passes. Incorrect code generation; =========================. Similarly to debugging incorrect compilation by mis-behaving passes, you; can debug incorrect code generation by either LLC or the JIT, using; ``bugpoint``. The process ``bugpoint`` follows in this case is to try to; narrow the code down to a function that is miscompiled by one or the other; method, but since for correctness, the entire program must be run,; ``bugpoint`` will compile the code it deems to not be affected with the C; Backend, and then link in the shared object it generates. To debug the JIT:. .. code-block:: bash. bugpoint -run-jit -output=[correct output file] [bitcode file] \; --tool-args -- [arguments to pass to lli] \; --args -- [program arguments]. Similarly, to debug the LLC, one would run:. .. code-block:: bash. bugpoint -run-llc -output=[correct output file] [bi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst:9061,message,message,9061,interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,1,['message'],['message']
Integrability,"in to align the behavior with a TTree. You need to call; TTree::SetCacheSize to enable the TTreeCache.; Correct and clarify the relationship between AutoFlush and AutoSave:; ; Both the AutoFlush and AutoSave interval can be specified in; terms of bytes (a negative value for fAutoFlush or fAutoSave); or in terms of the number of entries (positive values).; An AutoFlush is always done with an AutoSave.; If the interval specified for AutoSave is less than that for; AutoFlush, the AutoSave interval is used for both.; If the AutoFlush interval is less than the AutoSave interval,; the AutoSave interval is adjusted to the largest integer; multiple of the AutoFlush interval that is less than or equal; to the original value of the AutoSave interval. Update MakeProxy so that the resulting skeleton is useable with Proof.; Update MakeProxy, MakeClass and MakeSelector to support more cases of branches names (that includes characters illegal in a C++ symbol); Replace the ReadLeaves virtual function by a fReadLeaves pointer to member function,; this allows the customization of the ReadLeaves function at run-time depending on the; underlying user class layout in TBranchElement. This removes many if statements whose; 'answer' is known at initialization time. Add support for 'array' formula in TTree::Query.; Set the initial value of fCacheSize to zero to indicate clearly that the TreeCache is disabled.; In TChain::SetEntryList use only the treename to lookup the (sub)entryList (instead subdir/treename).; Add support for the branch creation syntax:; TString rootString;; t->Branch(""rootString"",""TString"",&rootString, 1600, 0);; which is 'natural' as it uses the legacy syntax (branch_name,class_name, user_data); but did not work because 'rootString' is an object rather than a pointer to an; object. (However the simplier form:; t->Branch(""rootString"",&rootString, 1600, 0);; works/worked fine). Add type information to the result of TTree::Print in the case of; TBranchElement:; *Br 17 :fH : ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html:4008,depend,depending,4008,tree/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v528/index.html,1,['depend'],['depending']
Integrability,"in::GetAsDataHist` functions are deprecated and will be removed in ROOT 6.36. The same functionality can be implemented by calling `RooAbsData::reduce` on the Markov Chain's `RooDataSet*` (obtained using `MarkovChain::GetAsConstDataSet`) and then obtaining its binned clone(for `RooDataHist`). An example in Python would be:. ```py; mcInt = mc.GetInterval() # Obtain the MCMCInterval from a configured MCMCCalculator; mkc = mcInt.GetChain() # Obtain the MarkovChain; mkcData = mkc.GetAsConstDataSet(); mcIntParams = mcInt.GetParameters(). chainDataset = mkcData.reduce(SelectVars=mcIntParams, EventRange=(mcInt.GetNumBurnInSteps(), mkc.Size())); chainDataHist = chainDataset.binnedClone(); ```. * The following methods related to the RooAbsArg interface are deprecated and will be removed in ROOT 6.36.; They should be replaced with the suitable alternatives interfaces:. - `RooAbsArg::getDependents()`: use `getObservables()`; - `RooAbsArg::dependentOverlaps()`: use `observableOverlaps()`; - `RooAbsArg::checkDependents()`: use `checkObservables()`; - `RooAbsArg::recursiveCheckDependents()`: use `recursiveCheckObservables()`. ## Graphics Backends. ## 2D Graphics Libraries. ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## PyROOT. ### Typesafe `TTree::SetBranchAddress()` for array inputs. If you call `TTree::SetBranchAddress` with NumPy array or `array.array` inputs, ROOT will now check if the array type matches with the column type.; If it doesn't, `SetBranchAddress()` will return a negative status code and print an error.; Take for example this code snippet:; ```python; arr = array.array(typecode, ""d""); status = t.SetBranchAddress(""name"", arr); print(""Status = %s"" % (status, )); ```; If the branch type is also `double` (like the type of the array indicated by `""d""`), the call to `SetBranchAddress()` would succeed with status code zero.; If the type doesn't match, you ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md:6539,depend,dependentOverlaps,6539,README/ReleaseNotes/v634/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md,1,['depend'],['dependentOverlaps']
Integrability,"inatorTree`` is called by pass; manager before returning a reference to the desired pass. If your pass is capable of updating analyses if they exist (e.g.,; ``BreakCriticalEdges``, as described above), you can use the; ``getAnalysisIfAvailable`` method, which returns a pointer to the analysis if; it is active. For example:. .. code-block:: c++. if (DominatorSet *DS = getAnalysisIfAvailable<DominatorSet>()) {; // A DominatorSet is active. This code will update it.; }. Implementing Analysis Groups; ----------------------------. Now that we understand the basics of how passes are defined, how they are used,; and how they are required from other passes, it's time to get a little bit; fancier. All of the pass relationships that we have seen so far are very; simple: one pass depends on one other specific pass to be run before it can; run. For many applications, this is great, for others, more flexibility is; required. In particular, some analyses are defined such that there is a single simple; interface to the analysis results, but multiple ways of calculating them.; Consider alias analysis for example. The most trivial alias analysis returns; ""may alias"" for any alias query. The most sophisticated analysis a; flow-sensitive, context-sensitive interprocedural analysis that can take a; significant amount of time to execute (and obviously, there is a lot of room; between these two extremes for other implementations). To cleanly support; situations like this, the LLVM Pass Infrastructure supports the notion of; Analysis Groups. Analysis Group Concepts; ^^^^^^^^^^^^^^^^^^^^^^^. An Analysis Group is a single simple interface that may be implemented by; multiple different passes. Analysis Groups can be given human readable names; just like passes, but unlike passes, they need not derive from the ``Pass``; class. An analysis group may have one or more implementations, one of which is; the ""default"" implementation. Analysis groups are used by client passes just like other passes a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:35079,interface,interface,35079,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['interface'],['interface']
Integrability,"include distributed RDataFrame in the ROOT build is Python 3.8. More information in the relative; [github issue](https://github.com/root-project/root/issues/11515).; - `Stats` and `StdDev` operations are now available in distributed mode.; - `GetColumnNames` operation is now available in distributed mode. ## Histogram Libraries. - New class `TGraph2DAsymmErrors` to create TGraph2D with asymmetric errors.; ![TGraph2DAsymmErrors](TGraph2DAsymmErrors.png). ## Math Libraries. ### Fitter class. Some improvements and small fixes to the internal object memory management have been applied to the `ROOT::Fit::Fitter` class.; - When setting an external FCN (objective function) to the Fitter, the function object is not cloned anymore.; - A memory leak has been fixed, when using the `GSLMultiFit` class.; - A bug has been resolved in setting fixed variables when using the linear fitter (via the `TLinearMinimizer` class). Support for providing the second derivatives (Hessian matrix) from the model function is added to the `Fitter` class and the corresponding function interfaces. The functionality it is then propagated in the implementation of the `FitMethod` classes and it is also added to the `Minimizer` classes for providing a user computed Hessian of the objective functions to the minimizers. Only Minuit2 (see below) has the capabilities of using this external Hessian. The `GradFunctor` class has been improved by providing a new constructor taking an `std::function` implementing the full gradient calculations instead of the single partial derivative. The specialized methods for least-square/likelihood functions such as Fumili, Fumili2 and GSLMultiFit have been improved in case of binned likelihood fits, where a better approximation is used than before. This makes these method work better (conerging with less number of function calls) for these types of fits. ### Minuit2. The support for using an External Hessian calculator has been added. The external Hessian can be used for bo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:15458,interface,interfaces,15458,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['interface'],['interfaces']
Integrability,"include(LLVMExternalProjectUtils). set(CLANG_PGO_TRAINING_DATA ""${CMAKE_CURRENT_SOURCE_DIR}"" CACHE PATH; ""The path to a lit testsuite containing samples for PGO and order file generation""; ); set(CLANG_PGO_TRAINING_DATA_SOURCE_DIR OFF CACHE STRING ""Path to source directory containing cmake project with source files to use for generating pgo data""); set(CLANG_PGO_TRAINING_DEPS """" CACHE STRING ""Extra dependencies needed to build the PGO training data.""). if(LLVM_BUILD_INSTRUMENTED); configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/pgo-data/lit.site.cfg; ). add_lit_testsuite(generate-profraw ""Generating clang PGO data""; ${CMAKE_CURRENT_BINARY_DIR}/pgo-data/; EXCLUDE_FROM_CHECK_ALL; DEPENDS clang clear-profraw ${CLANG_PGO_TRAINING_DEPS}; ). add_custom_target(clear-profraw; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py clean ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_BINARY_DIR}/profiles/ profraw; COMMENT ""Clearing old profraw data""). if(NOT LLVM_PROFDATA); find_program(LLVM_PROFDATA llvm-profdata); endif(). if(NOT LLVM_PROFDATA); message(STATUS ""To enable merging PGO data LLVM_PROFDATA has to point to llvm-profdata""); else(); add_custom_target(generate-profdata; COMMAND ""${Python3_EXECUTABLE}"" ${CMAKE_CURRENT_SOURCE_DIR}/perf-helper.py merge ${LLVM_PROFDATA} ${CMAKE_CURRENT_BINARY_DIR}/clang.profdata ${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_BINARY_DIR}/profiles/; COMMENT ""Merging profdata""; DEPENDS generate-profraw); if (CLANG_PGO_TRAINING_DATA_SOURCE_DIR); llvm_ExternalProject_Add(generate-profraw-external ${CLANG_PGO_TRAINING_DATA_SOURCE_DIR}; USE_TOOLCHAIN EXLUDE_FROM_ALL NO_INSTALL DEPENDS generate-profraw); add_dependencies(generate-profdata generate-profraw-external); endif(); endif(); endif(). find_program(DTRACE dtrace); # TODO: Look into supporting this for the driver build. It will require changing; # the perf-helper.py file to understand to call `llvm` as `llvm clang`.; if(APPLE AND DTRACE AND N",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt:402,depend,dependencies,402,interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/perf-training/CMakeLists.txt,1,['depend'],['dependencies']
Integrability,"include_directories( ${CMAKE_CURRENT_SOURCE_DIR}/.. ). if(NOT DEFINED ITTAPI_GIT_REPOSITORY); set(ITTAPI_GIT_REPOSITORY https://github.com/intel/ittapi.git); endif(). if(NOT DEFINED ITTAPI_GIT_TAG); set(ITTAPI_GIT_TAG v3.18.12); endif(). if(NOT DEFINED ITTAPI_SOURCE_DIR); set(ITTAPI_SOURCE_DIR ${PROJECT_BINARY_DIR}); endif(). if(NOT EXISTS ${ITTAPI_SOURCE_DIR}/ittapi); execute_process(COMMAND ${GIT_EXECUTABLE} clone ${ITTAPI_GIT_REPOSITORY}; WORKING_DIRECTORY ${ITTAPI_SOURCE_DIR}; RESULT_VARIABLE GIT_CLONE_RESULT); if(NOT GIT_CLONE_RESULT EQUAL ""0""); message(FATAL_ERROR ""git clone ${ITTAPI_GIT_REPOSITORY} failed with ${GIT_CLONE_RESULT}, please clone ${ITTAPI_GIT_REPOSITORY}""); endif(); endif(). execute_process(COMMAND ${GIT_EXECUTABLE} checkout ${ITTAPI_GIT_TAG}; WORKING_DIRECTORY ${ITTAPI_SOURCE_DIR}/ittapi; RESULT_VARIABLE GIT_CHECKOUT_RESULT); if(NOT GIT_CHECKOUT_RESULT EQUAL ""0""); message(FATAL_ERROR ""git checkout ${ITTAPI_GIT_TAG} failed with ${GIT_CHECKOUT_RESULT}, please checkout ${ITTAPI_GIT_TAG} at ${ITTAPI_SOURCE_DIR}/ittapi""); endif(). include_directories( ${ITTAPI_SOURCE_DIR}/ittapi/include/ ). if( HAVE_LIBDL ); set(LLVM_INTEL_JIT_LIBS ${CMAKE_DL_LIBS}); endif(). set(LLVM_INTEL_JIT_LIBS ${LLVM_PTHREAD_LIB} ${LLVM_INTEL_JIT_LIBS}). add_llvm_component_library(LLVMIntelJITEvents; IntelJITEventListener.cpp; jitprofiling.c; ${ITTAPI_SOURCE_DIR}/ittapi/src/ittnotify/ittnotify_static.c. LINK_LIBS ${LLVM_INTEL_JIT_LIBS}. LINK_COMPONENTS; CodeGen; Core; DebugInfoDWARF; Support; Object; ExecutionEngine; ). add_dependencies(LLVMIntelJITEvents LLVMCodeGen); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/CMakeLists.txt:557,message,message,557,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/CMakeLists.txt,2,['message'],['message']
Integrability,"include`` a; system header. Care has been taken to remove all such ``#includes`` from LLVM; while ``lib/Support`` was being developed. Specifically this means that header; files like ""``unistd.h``"", ""``windows.h``"", ""``stdio.h``"", and ""``string.h``""; are forbidden to be included by LLVM source code outside the implementation of; ``lib/Support``. To obtain system-dependent functionality, existing interfaces to the system; found in ``include/llvm/Support`` should be used. If an appropriate interface is; not available, it should be added to ``include/llvm/Support`` and implemented in; ``lib/Support`` for all supported platforms. Don't Expose System Headers; ---------------------------. The Support Library must shield LLVM from **all** system headers. To obtain; system level functionality, LLVM source must; ``#include ""llvm/Support/Thing.h""`` and nothing else. This means that; ``Thing.h`` cannot expose any system header files. This protects LLVM from; accidentally using system specific functionality and only allows it via; the ``lib/Support`` interface. Use Standard C Headers; ----------------------. The **standard** C headers (the ones beginning with ""c"") are allowed to be; exposed through the ``lib/Support`` interface. These headers and the things they; declare are considered to be platform agnostic. LLVM source files may include; them directly or obtain their inclusion through ``lib/Support`` interfaces. Use Standard C++ Headers; ------------------------. The **standard** C++ headers from the standard C++ library and standard; template library may be exposed through the ``lib/Support`` interface. These; headers and the things they declare are considered to be platform agnostic.; LLVM source files may include them or obtain their inclusion through; ``lib/Support`` interfaces. High Level Interface; --------------------. The entry points specified in the interface of ``lib/Support`` must be aimed at; completing some reasonably high level task needed by LLVM. We do not wa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:3146,interface,interface,3146,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interface']
Integrability,"ine the matchers for what the next inner node you want to match is.; #. Repeat until the matcher is finished. .. _astmatchers-bind:. Binding nodes in match expressions; ----------------------------------. Matcher expressions allow you to specify which parts of the AST are interesting; for a certain task. Often you will want to then do something with the nodes; that were matched, like building source code transformations. To that end, matchers that match specific AST nodes (so called node matchers); are bindable; for example, ``recordDecl(hasName(""MyClass"")).bind(""id"")`` will; bind the matched ``recordDecl`` node to the string ""``id``"", to be later; retrieved in the `match callback; <https://clang.llvm.org/doxygen/classclang_1_1ast__matchers_1_1MatchFinder_1_1MatchCallback.html>`_. .. FIXME: Introduce link to ASTMatchersTutorial.html; .. FIXME: Introduce link to ASTMatchersCookbook.html. Writing your own matchers; -------------------------. There are multiple different ways to define a matcher, depending on its type; and flexibility. ``VariadicDynCastAllOfMatcher<Base, Derived>``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Those match all nodes of type *Base* if they can be dynamically casted to; *Derived*. The names of those matchers are nouns, which closely resemble; *Derived*. ``VariadicDynCastAllOfMatchers`` are the backbone of the matcher; hierarchy. Most often, your match expression will start with one of them, and; you can :ref:`bind <astmatchers-bind>` the node they represent to ids for later; processing. ``VariadicDynCastAllOfMatchers`` are callable classes that model variadic; template functions in C++03. They take an arbitrary number of; ``Matcher<Derived>`` and return a ``Matcher<Base>``. ``AST_MATCHER_P(Type, Name, ParamType, Param)``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Most matcher definitions use the matcher creation macros. Those define both; the matcher of type ``Matcher<Type>`` itself, and a matcher-creation function; named *Name* ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst:4252,depend,depending,4252,interpreter/llvm-project/clang/docs/LibASTMatchers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchers.rst,1,['depend'],['depending']
Integrability,"ing ""``+``"". **""objcinstance"" format**. Example:; ``""method %objcinstance0 not found""``; Class:; ``DeclarationName``; Description:; This is a simple formatter that indicates the ``DeclarationName`` corresponds; to an Objective-C instance method selector. As such, it prints the selector; with a leading ""``-``"". **""q"" format**. Example:; ``""candidate found by name lookup is %q0""``; Class:; ``NamedDecl *``; Description:; This formatter indicates that the fully-qualified name of the declaration; should be printed, e.g., ""``std::vector``"" rather than ""``vector``"". **""diff"" format**. Example:; ``""no known conversion %diff{from $ to $|from argument type to parameter type}1,2""``; Class:; ``QualType``; Description:; This formatter takes two ``QualType``\ s and attempts to print a template; difference between the two. If tree printing is off, the text inside the; braces before the pipe is printed, with the formatted text replacing the $.; If tree printing is on, the text after the pipe is printed and a type tree is; printed after the diagnostic message. **""sub"" format**. Example:; Given the following record definition of type ``TextSubstitution``:. .. code-block:: text. def select_ovl_candidate : TextSubstitution<; ""%select{function|constructor}0%select{| template| %2}1"">;. which can be used as. .. code-block:: text. def note_ovl_candidate : Note<; ""candidate %sub{select_ovl_candidate}3,2,1 not viable"">;. and will act as if it was written; ``""candidate %select{function|constructor}3%select{| template| %1}2 not viable""``.; Description:; This format specifier is used to avoid repeating strings verbatim in multiple; diagnostics. The argument to ``%sub`` must name a ``TextSubstitution`` tblgen; record. The substitution must specify all arguments used by the substitution,; and the modifier indexes in the substitution are re-numbered accordingly. The; substituted text must itself be a valid format string before substitution. .. _internals-producing-diag:. Producing the Diagnostic; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:15036,message,message,15036,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['message'],['message']
Integrability,"ing and objects drawing, one can provide number of URL parameters in address string like:. - file - name of the file, which will be automatically open with page loading; - files - array of file names for loading; - json - name of JSON file with stored ROOT object like histogram or canvas; - item - item name to be displayed; - opt - drawing option for the item; - items - array of items name to be displayed; - opts - array of drawing options for the items; - expand - item name(s) to be expanded in the hierarchy browser; - focus - item name to be focused on in the hierarchy browser; - title - set browser title; - dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; - layout - can be 'simple', 'flex', 'tabs', 'gridNxM', 'horizNMK', 'vertNMK'; - browser - layout of the browser 'fix' (default), 'float', 'no' (hidden), 'off' (fully disabled); - nobrowser - do not display file browser (same as browser=no); - float - display floating browser (same as browser=float); - status - configure status line 'no' (default), 'off' (completely disable), 'size'; - inject - name of extra JavaScript to load, see several examples in demo/ subdir; - optimize - drawing optimization 0:off, 1:only large histograms (default), 2:always; - palette - id of default color palette, 51..121 - new ROOT6 palette (default 57); - interactive - enable/disable interactive functions 0 - disable all, 1 - enable all; - noselect - hide file-selection part in the browser (only when file name is specified); - mathjax - use MathJax for latex output; - latex - 'off', 'symbols', 'normal', 'mathjax', 'alwaysmath' control of TLatex processor; - style - name of TStyle object to define global JSROOT style; - toolbar - show canvas tool buttons 'off', 'on' and 'popup', 'left' or 'right' for position, 'vert' for vertical; - divsize - fixed size in pixels for main div element like &dvisize=1500x800; - canvsize - default canvas size in pixels like &canvsize=1200x800; - optstat - ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:2099,inject,inject,2099,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['inject'],['inject']
Integrability,"ing correctly in the past,; so it's not clear if this is something that will be supported going forward. Monorepo Drawbacks; ------------------. * Using the monolithic repository may add overhead for those contributing to a; standalone sub-project, particularly on runtimes like libcxx and compiler-rt; that don't rely on LLVM; currently, a fresh clone of libcxx is only 15MB (vs.; 1GB for the monorepo), and the commit rate of LLVM may cause more frequent; `git push` collisions when upstreaming. Affected contributors may be able to; use the SVN bridge or the single-subproject Git mirrors. However, it's; undecided if these projects will continue to be maintained.; * Using the monolithic repository may add overhead for those *integrating* a; standalone sub-project, even if they aren't contributing to it, due to the; same disk space concern as the point above. The availability of the; sub-project Git mirrors would addresses this.; * Preservation of the existing read/write SVN-based workflows relies on the; GitHub SVN bridge, which is an extra dependency. Maintaining this locks us; into GitHub and could restrict future workflow changes. Workflows; ^^^^^^^^^. * :ref:`Checkout/Clone a Single Project, without Commit Access <workflow-checkout-commit>`.; * :ref:`Checkout/Clone Multiple Projects, with Commit Access <workflow-monocheckout-multicommit>`.; * :ref:`Commit an API Change in LLVM and Update the Sub-projects <workflow-cross-repo-commit>`.; * :ref:`Branching/Stashing/Updating for Local Development or Experiments <workflow-mono-branching>`.; * :ref:`Bisecting <workflow-mono-bisecting>`. Workflow Before/After; =====================. This section goes through a few examples of workflows, intended to illustrate; how end-users or developers would interact with the repository for; various use-cases. .. _workflow-checkout-commit:. Checkout/Clone a Single Project, with Commit Access; ---------------------------------------------------. Currently; ^^^^^^^^^. ::. # direct SVN check",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:11947,bridg,bridge,11947,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,2,"['bridg', 'depend']","['bridge', 'dependency']"
Integrability,"ing different; categories of editable objects](pictures/020001EB.jpg); ![Accessing/creating different categories of editable; objects](pictures/020001EC.jpg) ![Accessing/creating different; categories of editable objects](pictures/020001ED.jpg); ![Accessing/creating different categories of editable; objects](pictures/020001EE.jpg). The second use case applies when starting to edit an existing geometry.; Supposing the geometry was loaded into memory, besides the first method; that still applies one can also edit drawn geometry objects. For this,; the menu entry View/Editor of the canvas containing for instance a drawn; volume must be activated. For starting the volume editor one can click; on a volume. The GUI of the **`TGeoManager`** class can be started by; clicking on the top-right `40x40` pixels corner of the pad with a drawn; geometry. This is the main entry point for editing the geometry or creating new; objects. Once the interface is created (using one of the methods; described above), several categories can be accessed via a shutter GUI; widget:. - *General.* This allows changing the name/title of the geometry,; setting the top volume, closing the geometry and saving the geometry; in a file. The file name is formed by `geometry_name.C` or `.root`; depending if the geometry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of proper",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:167714,interface,interface,167714,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability,"ing if the geometry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of properties related to tracking); - *Matrices.* Allows creation of translations, rotations or combined; transformations. Existing matrices can also be browser/edited. ### Editing Existing Objects. For editing an existing object from one of the categories described; above, the interface imposes first a selection among all objects of the; corresponding type stored in the geometry. This can be done by clicking; the button next to the blue label *Select \<object\>*. The dialog; interfaces are generally different for different types of objects. The; volume selection dialog offers the possibility to select either a volume; already connected to the geometry hierarchy or non-connected ones.; Selection for shapes and matrices is split into categories represented; by top-level list tree items for: boxes, tubes, translations, rotations,; etc. ![Selection dialogs for different TGeo objects](pictures/030001EF.png). Once a selection is made and the dialog is closed, the selected item; name will appear in the corresponding label and the button Edit will; start the object editor in a transient frame. Closing these transient; frames will not delete, but just hide existing opened editors for later; reuse. Their lifetime is determined by the canvas to which the manager; editor is attache",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:169043,interface,interface,169043,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability,"ing initial patches can help with; discussions on an RFC. Code-Review Workflow; ====================. Code review can be an iterative process, which continues until the patch is; ready to be committed. Specifically, once a patch is sent out for review, it; needs an explicit approval before it is committed. Do not assume silent; approval, or solicit objections to a patch with a deadline. Acknowledge All Reviewer Feedback; ---------------------------------. All comments by reviewers should be acknowledged by the patch author. It is; generally expected that suggested changes will be incorporated into a future; revision of the patch unless the author and/or other reviewers can articulate a; good reason to do otherwise (and then the reviewers must agree). If a new patch; does not address all outstanding feedback, the author should explicitly state; that when providing the updated patch. When using the web-based code-review; tool, such notes can be provided in the ""Diff"" description (which is different; from the description of the ""Differential Revision"" as a whole used for the; commit message). If you suggest changes in a code review, but don't wish the suggestion to be; interpreted this strongly, please state so explicitly. Aim to Make Efficient Use of Everyone's Time; --------------------------------------------. Aim to limit the number of iterations in the review process. For example, when; suggesting a change, if you want the author to make a similar set of changes at; other places in the code, please explain the requested set of changes so that; the author can make all of the changes at once. If a patch will require; multiple steps prior to approval (e.g., splitting, refactoring, posting data; from specific performance tests), please explain as many of these up front as; possible. This allows the patch author and reviewers to make the most efficient; use of their time. LGTM - How a Patch Is Accepted; ------------------------------. A patch is approved to be committe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:5597,message,message,5597,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,1,['message'],['message']
Integrability,"ing of C++ code into Numba traces, for further; expected speedups. Why Numba?; ----------. The advertised premise of Numba is that it ""makes Python code fast.""; However, there is a much more compelling reason: Numba allows developers to; stay in their chosen ecosystem, be it Python or C++, in mixed environments,; without paying for their choice in lost performance.; For example, a Python developer using Numba does not need to rewrite a kernel; into C++ just to run performantly in a C++ framework.; Similarly, a C++ developer can use Numba to compile and create function; pointers to Python code for easy, performant, access.; This becomes even more compelling if the deployment target is a GPU, which; would otherwise certainly require a rewrite of the Python code.; Add that Numba, as a JIT-compiler, is fully run-time just like ``cppyy``,; and the use case for integration is clear.; (Numba does not currently provide support for C++.). Usage; -------. ``cppyy`` does not use Numba extension hooks to minimize accidental; dependencies.; Instead, it requires that the extensions are loaded explicitly by any code; that uses it::. import cppyy.numba_ext. After that, Numba is able to trace ``cppyy`` bound code when applying the; usual ``numba.njit`` decorator. Numba type declarations are done lazily, with the ``numba_ext`` module only; initially registering hooks on proxy base classes, to keep overheads in; Numba's type-resolution to a minimum.; On use in a JITed trace, each C++ type or function call is refined to the; actual, concrete types and type-specific overloads, with templates; instantiated as-needed.; Where possible, lowering is kept generic to reduce the number of callbacks; in Numba's compilation chain. Examples; --------. The following, non-exhaustive, set of examples gives an idea of the; current level of support.; More examples can be found in the `test suite`_. C++ free (global) functions can be called and overloads will be selected, or; a template will be instantia",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst:2319,depend,dependencies,2319,bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,1,['depend'],['dependencies']
Integrability,"ing of other preprocessor directives. The; output of this stage is typically called a "".i"" (for C), "".ii"" (for C++),; "".mi"" (for Objective-C), or "".mii"" (for Objective-C++) file. Parsing and Semantic Analysis; This stage parses the input file, translating preprocessor tokens into a; parse tree. Once in the form of a parse tree, it applies semantic; analysis to compute types for expressions as well and determine whether; the code is well formed. This stage is responsible for generating most of; the compiler warnings as well as parse errors. The output of this stage is; an ""Abstract Syntax Tree"" (AST). Code Generation and Optimization; This stage translates an AST into low-level intermediate code (known as; ""LLVM IR"") and ultimately to machine code. This phase is responsible for; optimizing the generated code and handling target-specific code generation.; The output of this stage is typically called a "".s"" file or ""assembly"" file. Clang also supports the use of an integrated assembler, in which the code; generator produces object files directly. This avoids the overhead of; generating the "".s"" file and of calling the target assembler. Assembler; This stage runs the target assembler to translate the output of the; compiler into a target object file. The output of this stage is typically; called a "".o"" file or ""object"" file. Linker; This stage runs the target linker to merge multiple object files into an; executable or dynamic library. The output of this stage is typically called; an ""a.out"", "".dylib"" or "".so"" file. :program:`Clang Static Analyzer`. The Clang Static Analyzer is a tool that scans source code to try to find bugs; through code analysis. This tool uses many parts of Clang and is built into; the same driver. Please see <https://clang-analyzer.llvm.org> for more details; on how to use the static analyzer. OPTIONS; -------. Stage Selection Options; ~~~~~~~~~~~~~~~~~~~~~~~. .. option:: -E. Run the preprocessor stage. .. option:: -fsyntax-only. Run the preprocess",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:1948,integrat,integrated,1948,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,1,['integrat'],['integrated']
Integrability,"ing slot where the workload is executed; - Add `DefineSlotEntry`, a `Define` transformation that is aware of the multi-threading slot and of the current entry number; - Add `GetColumnsNames`: users can now get the names of the available columns coming from trees, data sources or `Define`d columns; - Add `OnPartialResult` and `OnPartialResultSlot`: users can now register one or more functions to be executed on partial results of TDF actions during the event loop.; This mechanism is meant to be used to inspect partial results of the analysis or print useful debug information.; For example, both in single- and multi-thread event loops, one can draw a result histogram and update the canvas every 100 entries like this:; ```c++; auto h = tdf.Histo1D(""x"");; TCanvas c(""c"",""x hist"");; h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; ```; See the tutorials for more examples.; - Add `Sum`, an action that sums all values of a column for the processed entries; - The new TDataSource interface allows developers to pipe any kind of columnar data format into TDataFrame. Two example data sources have been provided: the TRootDS and the TTrivialDS. The former allows to read via the novel data source mechanism ROOT data, while the latter is a simple generator, created for testing and didactic purposes. It is therefore now possible to interface *any* kind of dataset/data format to ROOT as long as an adaptor which implements the pure virtual methods of the TDataSource interface can be written in C++.; - TDF can now read CSV files through a specialized TDataSource. Just create the TDF with `MakeCsvDataFrame(""f.csv"")`. Just create the TDF with MakeCsvDataFrame(""f.csv""). The data types of the CSV columns are automatically inferred. You can also specify if you want to use a different delimiter or if your file does not have headers.; - Users can now configure Snapshot to use different file open modes (""RECREATE"" or ""UPDATE""), compression level, compression algorithm,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:12428,interface,interface,12428,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['interface'],['interface']
Integrability,"ing the block ID we are describing, *not* the ``BLOCKINFO`` block; itself. The abbreviations defined in ``BLOCKINFO`` blocks receive abbreviation; IDs as described in `DEFINE_ABBREV`_. The ``BLOCKNAME`` record (code 2) can optionally occur in this block. The; elements of the record are the bytes of the string name of the block.; llvm-bcanalyzer can use this to dump out bitcode files symbolically. The ``SETRECORDNAME`` record (code 3) can also optionally occur in this block.; The first operand value is a record ID number, and the rest of the elements of; the record are the bytes for the string name of the record. llvm-bcanalyzer can; use this to dump out bitcode files symbolically. Note that although the data in ``BLOCKINFO`` blocks is described as ""metadata,""; the abbreviations they contain are essential for parsing records from the; corresponding blocks. It is not safe to skip them. .. _wrapper:. Bitcode Wrapper Format; ======================. Bitcode files for LLVM IR may optionally be wrapped in a simple wrapper; structure. This structure contains a simple header that indicates the offset; and size of the embedded BC file. This allows additional information to be; stored alongside the BC file. The structure of this file header is:. :raw-html:`<tt><blockquote>`; [Magic\ :sub:`32`, Version\ :sub:`32`, Offset\ :sub:`32`, Size\ :sub:`32`, CPUType\ :sub:`32`]; :raw-html:`</blockquote></tt>`. Each of the fields are 32-bit fields stored in little endian form (as with the; rest of the bitcode file fields). The Magic number is always ``0x0B17C0DE`` and; the version is currently always ``0``. The Offset field is the offset in bytes; to the start of the bitcode stream in the file, and the Size field is the size; in bytes of the stream. CPUType is a target-specific value that can be used to; encode the CPU of the target. .. _native object file:. Native Object File Wrapper Format; =================================. Bitcode files for LLVM IR may also be wrapped in a native obj",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:18034,wrap,wrapped,18034,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,2,['wrap'],"['wrapped', 'wrapper']"
Integrability,"ing the libraries using standalone builds. This assumes; that we are building libunwind and ibc++ as DLLs and statically linking libc++abi into; libc++. Other build configurations are possible, but they are not discussed here. Common CMake configuration options:; -----------------------------------. * ``-D_LIBCPP_ABI_FORCE_ITANIUM'``. Tell the libc++ headers that the Itanium C++ ABI is being used. * ``-DCMAKE_C_FLAGS=""-lmsvcrt -llegacy_stdio_definitions -D_NO_CRT_STDIO_INLINE""``. Supply CRT definitions including stdio definitions that have been removed from the MS VS CRT.; We don't want the stdio functions declared inline as they will cause multiple definition; errors when the same symbols are pulled in from legacy_stdio_definitions.ib. * ``-DCMAKE_INSTALL_PREFIX=<install path>``. Where to install the library and headers. Building libunwind:; -------------------. * ``-DLIBUNWIND_ENABLE_SHARED=ON``; * ``-DLIBUNWIND_ENABLE_STATIC=OFF``. libunwind can be built as a DLL. It is not dependent on other projects. * ``-DLIBUNWIND_USE_COMPILER_RT=OFF``. We use the MS runtime. The CMake files will need to be edited to prevent them adding GNU specific libraries to the link line. Building libc++abi:; -------------------. * ``-DLIBCXXABI_ENABLE_SHARED=OFF``; * ``-DLIBCXXABI_ENABLE_STATIC=ON``; * ``-DLIBCXX_ENABLE_SHARED=ON'``; * ``-DLIBCXX_ENABLE_STATIC_ABI_LIBRARY=ON``. To break the symbol dependency between libc++abi and libc++ we; build libc++abi as a static library and then statically link it; into the libc++ DLL. This necessitates setting the CMake file; to ensure that the visibility macros (which expand to dllexport/import); are expanded as they will be needed when creating the final libc++; DLL later, see: https://reviews.llvm.org/D90021. * ``-DLIBCXXABI_LIBCXX_INCLUDES=<path to libcxx>/include``. Where to find the libc++ headers. Building libc++:; ----------------. * ``-DLIBCXX_ENABLE_SHARED=ON``; * ``-DLIBCXX_ENABLE_STATIC=OFF``. We build libc++ as a DLL and statically li",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst:4838,depend,dependent,4838,interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst,1,['depend'],['dependent']
Integrability,"ing values not to be believed, and `APPROXIMATE ERROR` means; that they have been calculated but there is reason to believe that; they may not be accurate. If no mitigating adjective is given, then at least `Minuit` believes; the errors are accurate, although there is always a small chance that; `Minuit` has been fooled. Some visible signs that `Minuit` may have; been fooled:. - Warning messages produced during the minimization or error; analysis. - Failure to find new minimum. - Value of EDM too big (estimated Distance to Minimum). - Correlation coefficients exactly equal to zero, unless some; parameters are known to be uncorrelated with the others. - Correlation coefficients very close to one (greater than 0.99).; This indicates both an exceptionally difficult problem, and one; which has been badly parameterized so that individual errors are; not very meaningful because they are so highly correlated. - Parameter at limit. This condition, signaled by a `Minuit` warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:62060,message,message,62060,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['message'],['message']
Integrability,"ing(42).size() // .size() is a resolved MemberExpr. Whether or not the ``RecoveryExpr`` has a dependent type, it is always; considered value-dependent, because its value isn't well-defined until the error; is resolved. Among other things, this means that clang doesn't emit more errors; where a RecoveryExpr is used as a constant (e.g. array size), but also won't try; to evaluate it. ContainsErrors bit; ^^^^^^^^^^^^^^^^^^. Beyond the template dependence bits, we add a new “ContainsErrors” bit to; express “Does this expression or anything within it contain errors” semantic,; this bit is always set for RecoveryExpr, and propagated to other related nodes.; This provides a fast way to query whether any (recursive) child of an expression; had an error, which is often used to improve diagnostics. .. code-block:: C++. // C++; void recoveryExpr(int abc) {; unknownFunction(); // type-dependent, value-dependent, contains-errors. std::string(42).size(); // value-dependent, contains-errors,; // not type-dependent, as we know the type is std::string; }. .. code-block:: C. // C; void recoveryExpr(int abc) {; unknownVar + abc; // type-dependent, value-dependent, contains-errors; }. The ASTImporter; ---------------. The ``ASTImporter`` class imports nodes of an ``ASTContext`` into another; ``ASTContext``. Please refer to the document :doc:`ASTImporter: Merging Clang; ASTs <LibASTImporter>` for an introduction. And please read through the; high-level `description of the import algorithm; <LibASTImporter.html#algorithm-of-the-import>`_, this is essential for; understanding further implementation details of the importer. .. _templated:. Abstract Syntax Graph; ^^^^^^^^^^^^^^^^^^^^^. Despite the name, the Clang AST is not a tree. It is a directed graph with; cycles. One example of a cycle is the connection between a; ``ClassTemplateDecl`` and its ""templated"" ``CXXRecordDecl``. The *templated*; ``CXXRecordDecl`` represents all the fields and methods inside the class; template, while the ``C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:89676,depend,dependent,89676,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['depend'],['dependent']
Integrability,"ing. For example, the user can; have. .. code-block:: c. __attribute__((weak)) int __llvm_profile_dump(void);. // Then later in the same source file; if (__llvm_profile_dump); if (__llvm_profile_dump() != 0) { ... }; // The first if condition tests if the symbol is actually defined.; // Profile dumping only happens if the symbol is defined. Hence,; // the user program works correctly during normal (not profile-generate); // executions. Alternatively, the user program can include the header; ``profile/instr_prof_interface.h``, which contains the API names. For example,. .. code-block:: c. #include ""profile/instr_prof_interface.h"". // Then later in the same source file; if (__llvm_profile_dump() != 0) { ... }. The user code does not need to check if the API names are defined, because; these names are automatically replaced by ``(0)`` or the equivalence of noop; if the ``clang`` is not compiling for profile generation. Such replacement can happen because ``clang`` adds one of two macros depending; on the ``-fprofile-generate`` and the ``-fprofile-use`` flags. * ``__LLVM_INSTR_PROFILE_GENERATE``: defined when one of; ``-fprofile[-instr]-generate``/``-fcs-profile-generate`` is in effect.; * ``__LLVM_INSTR_PROFILE_USE``: defined when one of; ``-fprofile-use``/``-fprofile-instr-use`` is in effect. The two macros can be used to provide more flexibiilty so a user program; can execute code specifically intended for profile generate or profile use.; For example, a user program can have special logging during profile generate:. .. code-block:: c. #if __LLVM_INSTR_PROFILE_GENERATE; expensive_logging_of_full_program_state();; #endif. The logging is automatically excluded during a normal build of the program,; hence it does not impact performance during a normal execution. It is advised to use such fine tuning only in a program's cold regions. The weak; symbols can introduce extra control flow (the ``if`` checks), while the macros; (hence declarations they guard in ``profile/instr_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:113637,depend,depending,113637,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['depend'],['depending']
Integrability,"ingle elements can be defined by their atomic mass; (`A`), charge (`Z`) and density (`rh`o). One can also create a material; by specifying the element that it is made of. Optionally the radiation; and absorption lengths can be also provided; otherwise they can be; computed on-demand [`G3`]. The class representing them is; **`TGeoMaterial`**:. ``` {.cpp}; TGeoMaterial(const char *name,Double_t a,Double_t z,; Double_t density, Double_t radlen=0,Double_t intlen=0);; TGeoMaterial(const char *name, TGeoElement *elem,; Double_t density);; TGeoMaterial(const char* name, Double_t a, Double_t z,; Double_t rho,; TGeoMaterial::EGeoMaterialState state,; Double_t temperature = STP_temperature,; Double_t pressure = STP_pressure); ```. Any material or derived class is automatically indexed after creation.; The assigned index is corresponding to the last entry in the list of; materials owned by **`TGeoManager`** class. This can be changed using; the **`TGeoMaterial`**`::SetIndex()` method, however it is not; recommended while using the geometry package interfaced with a transport; MC. Radiation and absorption lengths can be set using:. ``` {.cpp}; TGeoMaterial::SetRadLen(Double_t radlen, Double_t intlen);; ```. - `radlen:` radiation length. If `radlen<=0` the value is computed; using GSMATE algorithm in GEANT3; - `intlen:` absorption length. Material state, temperature and pressure can be changed via setters.; Another material property is transparency. It can be defined and used; while viewing the geometry with OpenGL. ``` {.cpp}; void SetTransparency (Char_t transparency = 0); ```. - `transparency:` between 0 (opaque default) to 100 (fully; transparent). One can attach to a material a user-defined object storing Cerenkov; properties. Another hook for material shading properties is currently; not in use. Mixtures are materials made of several elements. They are; represented by the class **`TGeoMixture`**, deriving from; **`TGeoMaterial`** and defined by their number of components an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:15134,interface,interfaced,15134,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interfaced']
Integrability,"ingle function. Defining total ordering among the functions set allows us to organize; functions into a binary tree. The lookup procedure complexity would be; estimated as O(log(N)) in this case. But how do we define *total-ordering*?. We have to introduce a single rule applicable to every pair of functions, and; following this rule, then evaluate which of them is greater. What kind of rule; could it be? Let's declare it as the ""compare"" method that returns one of 3; possible values:. -1, left is *less* than right,. 0, left and right are *equal*,. 1, left is *greater* than right. Of course it means, that we have to maintain; *strict and non-strict order relation properties*:. * reflexivity (``a <= a``, ``a == a``, ``a >= a``),; * antisymmetry (if ``a <= b`` and ``b <= a`` then ``a == b``),; * transitivity (``a <= b`` and ``b <= c``, then ``a <= c``); * asymmetry (if ``a < b``, then ``a > b`` or ``a == b``). As mentioned before, the comparison routine consists of; ""sub-comparison-routines"", with each of them also consisting of; ""sub-comparison-routines"", and so on. Finally, it ends up with primitive; comparison. Below, we will use the following operations:. #. ``cmpNumbers(number1, number2)`` is a method that returns -1 if left is less; than right; 0, if left and right are equal; and 1 otherwise. #. ``cmpFlags(flag1, flag2)`` is a hypothetical method that compares two flags.; The logic is the same as in ``cmpNumbers``, where ``true`` is 1, and; ``false`` is 0. The rest of the article is based on *MergeFunctions.cpp* source code; (found in *<llvm_dir>/lib/Transforms/IPO/MergeFunctions.cpp*). We would like; to ask reader to keep this file open, so we could use it as a reference; for further explanations. Now, we're ready to proceed to the next chapter and see how it works. Functions comparison; ====================; At first, let's define how exactly we compare complex objects. Complex object comparison (function, basic-block, etc) is mostly based on its; sub-object co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:10326,rout,routine,10326,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,3,['rout'],"['routine', 'routines']"
Integrability,"ings with, other operations; (except image operations) for all address spaces; (except private, or generic that accesses private); provided the other operation's sync scope is:. - ``system``, ``agent`` or ``workgroup`` and; executed by a thread in the same work-group.; - ``wavefront`` and executed by a thread in the; same wavefront. ``wavefront`` Synchronizes with, and participates in modification; and seq_cst total orderings with, other operations; (except image operations) for all address spaces; (except private, or generic that accesses private); provided the other operation's sync scope is:. - ``system``, ``agent``, ``workgroup`` or; ``wavefront`` and executed by a thread in the; same wavefront. ``singlethread`` Only synchronizes with and participates in; modification and seq_cst total orderings with,; other operations (except image operations) running; in the same thread for all address spaces (for; example, in signal handlers). ``one-as`` Same as ``system`` but only synchronizes with other; operations within the same address space. ``agent-one-as`` Same as ``agent`` but only synchronizes with other; operations within the same address space. ``workgroup-one-as`` Same as ``workgroup`` but only synchronizes with; other operations within the same address space. ``wavefront-one-as`` Same as ``wavefront`` but only synchronizes with; other operations within the same address space. ``singlethread-one-as`` Same as ``singlethread`` but only synchronizes with; other operations within the same address space.; ======================= ===================================================. LLVM IR Intrinsics; ------------------. The AMDGPU backend implements the following LLVM IR intrinsics. *This section is WIP.*. .. table:: AMDGPU LLVM IR Intrinsics; :name: amdgpu-llvm-ir-intrinsics-table. ============================================== ==========================================================; LLVM Intrinsic Description; ============================================== ======",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:34737,synchroniz,synchronizes,34737,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronizes']
Integrability,"ings; ^^^^^^^^^^^^^^^^^^. Generate a set of bindings from a set of header files. Somewhat like CMake's; add_library(), the output is a compiler target. In addition ancillary files; are also generated to allow a complete set of bindings to be compiled,; packaged and installed::. cppyy_add_bindings(; pkg; pkg_version; author; author_email; [URL url]; [LICENSE license]; [LANGUAGE_STANDARD std]; [LINKDEFS linkdef...]; [IMPORTS pcm...]; [GENERATE_OPTIONS option...]; [COMPILE_OPTIONS option...]; [INCLUDE_DIRS dir...]; [LINK_LIBRARIES library...]; [H_DIRS H_DIRSectory]; H_FILES h_file...). The bindings are based on https://cppyy.readthedocs.io/en/latest/, and can be; used as per the documentation provided via the cppyy.gbl namespace. First add; the directory of the <pkg>.rootmap file to the LD_LIBRARY_PATH environment; variable, then ""import cppyy; from cppyy.gbl import <some-C++-entity>"". Alternatively, use ""import <pkg>"". This convenience wrapper supports; ""discovery"" of the available C++ entities using, for example Python 3's command; line completion support. The bindings are complete with a setup.py, supporting Wheel-based; packaging, and a test.py supporting pytest/nosetest sanity test of the bindings. The bindings are generated/built/packaged using 3 environments:. - One compatible with the header files being bound. This is used to; generate the generic C++ binding code (and some ancillary files) using; a modified C++ compiler. The needed options must be compatible with the; normal build environment of the header files.; - One to compile the generated, generic C++ binding code using a standard; C++ compiler. The resulting library code is ""universal"" in that it is; compatible with both Python2 and Python3.; - One to package the library and ancillary files into standard Python2/3; wheel format. The packaging is done using native Python tooling. +----------------------+---------------------------------------------------------------------------------------------+; |Argume",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst:4517,wrap,wrapper,4517,bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,1,['wrap'],['wrapper']
Integrability,"ins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactoring tools. Use LibTooling when you...:. * want to run tools over a single file, or a specific subset of files,; independently of the build system; * want full control over the Clang AST; * want to share code with Clang Plugins. Do not use LibTooling when you...:. * want to run as part of the build triggered by dependency changes; * want a stable interface so you don't need to change your code when the AST API; changes; * want high level abstractions like cursors and code completion out of the box; * do not want to write your tools in C++. :doc:`Clang tools <ClangTools>` are a collection of specific developer tools; built on top of the LibTooling infrastructure as part of the Clang project.; They are targeted at automating and improving core development activities of; C/C++ developers. Examples of tools we are building or planning ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:2141,interface,interface,2141,interpreter/llvm-project/clang/docs/Tooling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst,2,"['integrat', 'interface']","['integrating', 'interface']"
Integrability,"insysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which are treated as `-isystem`. - `LIB` (indirectly). The linker `link.exe` or `lld-link.exe` will honour the environment; variable `LIB` which is a path delimiter (`;`) set of paths to consult for; the import libraries to use when linking the final target. The following environment variables will be consulted and used to form paths; to validate and load content from as appropriate:. - `VCToolsInstallDir`; - `VCINSTALLDIR`; - `Path`. 3. Consult `ISetupConfiguration` [Windows Only]. Assuming that the toolchain is built with `USE_MSVC_SETUP_API` defined and; is running on Windows, the Visual Studio COM interface `ISetupConfiguration`; will be used to locate the installation of the MSVC toolset. 4. Fallback to the registry [DEPRECATED]. The registry information is used to help locate the installation as a final; fallback. This is only possible for pre-VS2017 installations and is; considered deprecated. Restrictions and Limitations compared to Clang; ----------------------------------------------. Strict Aliasing; ^^^^^^^^^^^^^^^. Strict aliasing (TBAA) is always off by default in clang-cl. Whereas in clang,; strict aliasing is turned on by default for all optimization levels. To enable LLVM optimizations based on strict aliasing rules (e.g., optimizations; based on type of expressions in C/C++), user will need to explicitly pass; `-fstrict-aliasing` to clang-cl.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:196916,interface,interface,196916,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['interface'],['interface']
Integrability,"integerLiteral(equals(2))); 1 + 2 // Match; 2 + 1 // Match; 1 + 1 // No match; 2 + 2 // No match. Matcher<BinaryOperator>hasRHSMatcher<Expr> InnerMatcher; Matches the right hand side of binary operator expressions. Example matches b (matcher = binaryOperator(hasRHS())); a || b. Matcher<BindingDecl>forDecompositionMatcher<ValueDecl> InnerMatcher; Matches the DecompositionDecl the binding belongs to. For example, in:; void foo(); {; int arr[3];; auto &[f, s, t] = arr;. f = 42;; }; The matcher:; bindingDecl(hasName(""f""),; forDecomposition(decompositionDecl()); matches 'f' in 'auto &[f, s, t]'. Matcher<BlockDecl>hasAnyParameterMatcher<ParmVarDecl> InnerMatcher; Matches any parameter of a function or an ObjC method declaration or a; block. Does not match the 'this' parameter of a method. Given; class X { void f(int x, int y, int z) {} };; cxxMethodDecl(hasAnyParameter(hasName(""y""))); matches f(int x, int y, int z) {}; with hasAnyParameter(...); matching int y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasAnyParameter(hasName(""y""))); matches the declaration of method f with hasParameter; matching y. For blocks, given; b = ^(int y) { printf(""%d"", y) };. the matcher blockDecl(hasAnyParameter(hasName(""y""))); matches the declaration of the block b with hasParameter; matching y. Matcher<BlockDecl>hasParameterunsigned N, Matcher<ParmVarDecl> InnerMatcher; Matches the n'th parameter of a function or an ObjC method; declaration or a block. Given; class X { void f(int x) {} };; cxxMethodDecl(hasParameter(0, hasType(varDecl()))); matches f(int x) {}; with hasParameter(...); matching int x. For ObjectiveC, given; @interface I - (void) f:(int) y; @end. the matcher objcMethodDecl(hasParameter(0, hasName(""y""))); matches the declaration of method f with hasParameter; matching y. Matcher<BlockDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:142522,interface,interface,142522,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['interface'],['interface']
Integrability,"inter**. Additionally, it contains an index into the buffer, which; allows the direct addressing of structured elements. These components appear; in that order, i.e., the descriptor comes first, then the 32-bit offset; followed by the 32-bit index. The bits in the buffer descriptor must meet the following requirements:; the stride is the size of a structured element, the ""add tid"" flag must be 0,; and the swizzle enable bits must be off. **Streamout Registers**; Dedicated registers used by the GS NGG Streamout Instructions. The register; file is modelled as a memory in a distinct address space because it is indexed; by an address-like offset in place of named registers, and because register; accesses affect LGKMcnt. This is an internal address space used only by the; compiler. Do not use this address space for IR pointers. .. _amdgpu-memory-scopes:. Memory Scopes; -------------. This section provides LLVM memory synchronization scopes supported by the AMDGPU; backend memory model when the target triple OS is ``amdhsa`` (see; :ref:`amdgpu-amdhsa-memory-model` and :ref:`amdgpu-target-triples`). The memory model supported is based on the HSA memory model [HSA]_ which is; based in turn on HRF-indirect with scope inclusion [HRF]_. The happens-before; relation is transitive over the synchronizes-with relation independent of scope; and synchronizes-with allows the memory scope instances to be inclusive (see; table :ref:`amdgpu-amdhsa-llvm-sync-scopes-table`). This is different to the OpenCL [OpenCL]_ memory model which does not have scope; inclusion and requires the memory scopes to exactly match. However, this; is conservatively correct for OpenCL. .. table:: AMDHSA LLVM Sync Scopes; :name: amdgpu-amdhsa-llvm-sync-scopes-table. ======================= ===================================================; LLVM Sync Scope Description; ======================= ===================================================; *none* The default: ``system``. Synchronizes with, and participat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:31692,synchroniz,synchronization,31692,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['synchroniz'],['synchronization']
Integrability,"inter`** client). This; is linked with ROOT graphical libraries loaded on demand in order to; control visualization actions. ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position $\vec{r}$ and direction $\vec{n}$ with respect to the world; reference frame. The direction $\vec{n}$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of **`TGeo`** to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with ROOT. The interface methods related to tracking are incorporated into; **`TGeoManager`** class and implemented in the navigator class; **`TGeoNavigator`**. In order to be able to start tracking, one has to; define the initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoMa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:101728,interface,interface,101728,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interface']
Integrability,"into a `ROOT::Math::IParametricGradFunctionMultiDim`.; Example:. ```{.cpp}; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; ```. ## Numerical Integration. The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image.; `ROOT::Math::VirtualIntegrator` defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in; `ROOT::Math::VirtualIntegratorOneDim` and `ROOT::Math::VirtualIntegratorMultiDim`.; These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance.; These methods must be implemented in the concrete classes existing for the different integration algorithms.; The user cannot create directly these virtual integrator interfaces. He needs to create the; `ROOT::Math::IntegratorOneDim` class for integrating one-dimensional functions and `ROOT::Math::IntegratorMultiDim` for multi-dimensional functions.; Through the ROOT Plug-In Manager, the user can initialize `ROOT::Math::IntegratorOneDim` or `ROOT::Math::IntegratorMultiDim` with; any of the concrete integration classes without dealing with them directly.; These two classes provide the same interface as in `VirtualIntegratorOneDim` and `VirtualIntegratorMultiDim`, but with the possibility to choose in the constructor,; which method will be used to perform the integration. The method to set the function to be integrated, must be of the function interface type described before.; `ROOT::Math::IBaseFunctionOneDimFunction` is used for `ROOT::Math::IBaseFunctionMultiDim` and; The only difference between the `ROOT::Math::IntegratorOneDim` and `ROOT::Math::IntegratorMultiDim` resides; in the dimensionality of that function and some spe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:48940,integrat,integrator,48940,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,2,"['integrat', 'interface']","['integrator', 'interfaces']"
Integrability,"invoked by; providing an object (called the :arc-term:`receiver`) and a list of formal; arguments interspersed with the selector, like so:. .. code-block:: objc. [receiver foo: fooArg bar: barArg baz: bazArg]. This looks in the dynamic class of the receiver for a method with this name,; then in that class's superclass, etc., until it finds something it can execute.; The receiver ""expression"" may also be the name of a class, in which case the; actual receiver is the class object for that class, or (within method; definitions) it may be ``super``, in which case the lookup algorithm starts; with the static superclass instead of the dynamic class. The actual methods; dynamically found in a class are not those declared in the ``@interface``, but; those defined in a separate ``@implementation`` declaration; however, when; compiling a call, typechecking is done based on the methods declared in the; ``@interface``. Method declarations may also be grouped into :arc-term:`protocols`, which are not; inherently associated with any class, but which classes may claim to follow.; Object pointer types may be qualified with additional protocols that the object; is known to support. :arc-term:`Class extensions` are collections of ivars and methods, designed to; allow a class's ``@interface`` to be split across multiple files; however,; there is still a primary implementation file which must see the; ``@interface``\ s of all class extensions. :arc-term:`Categories` allow; methods (but not ivars) to be declared *post hoc* on an arbitrary class; the; methods in the category's ``@implementation`` will be dynamically added to that; class's method tables which the category is loaded at runtime, replacing those; methods in case of a collision. In the standard environment, objects are allocated on the heap, and their; lifetime is manually managed using a reference count. This is done using two; instance methods which all classes are expected to implement: ``retain``; increases the object's r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:5821,protocol,protocols,5821,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['protocol'],['protocols']
Integrability,"ion & integration of p.d.f.s, construction of cumulative distribution functions.; rf111_numintconfig.C - Configuration and customization of how numeric (partial) integrals. ; ADDITION AND CONVOLUTION. rf201_composite.C - Composite p.d.f with signal and background component; rf202_extendedmlfit.C - Setting up an extended maximum likelihood fit; rf203_ranges.C - Fitting and plotting in sub ranges; rf204_extrangefit.C - Extended maximum likelihood fit with alternate range definition; rf205_compplot.C - Options for plotting components of composite p.d.f.s.; rf206_treevistools.C - Tools for visualization of RooAbsArg expression trees; rf207_comptools.C - Tools and utilities for manipulation of composite objects; rf208_convolution.C - One-dimensional numeric convolution; rf209_anaconv.C - Decay function p.d.fs with optional B physics. ; MULTIDIMENSIONAL MODELS. rf301_composition.C - Multi-dimensional p.d.f.s through composition, e.g. substituting a p.d.f parameter with a function that depends on other observables; rf302_utilfuncs.C - Utility functions classes available for use in tailoring; rf303_conditional.C - Use of tailored p.d.f as conditional p.d.fs.s; rf304_uncorrprod.C - Simple uncorrelated multi-dimensional p.d.f.s; rf305_condcorrprod.C - Multi-dimensional p.d.f.s with conditional p.d.fs in product; rf306_condpereventerrors.C - Complete example with use of conditional p.d.f. with per-event errors; rf307_fullpereventerrors.C -Complete example with use of full p.d.f. with per-event errors; rf308_normintegration2d.C - Examples on normalization of p.d.f.s in more than one dimension; rf309_ndimplot.C - Making 2 and 3 dimensional plots of p.d.f.s and datasets; rf310_sliceplot.C -Projecting p.d.f and data slices in discrete observables; rf311_rangeplot.C -Projecting p.d.f and data ranges in continuous observables; rf312_multirangefit.C - Performing fits in multiple (disjoint) ranges in one or more dimensions; rf313_paramranges.C - Working with parameterized ranges to def",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:2212,depend,depends,2212,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['depend'],['depends']
Integrability,"ion followed by forward/back-substitution. `ROOT v3.10`; is using the slower Gaussian elimination method. The numerical accuracy; of the `CLHEP` routine is poor:. - up to 6x6 the numerical imprecise Cramer multiplication is hard-coded.; For instance, calculating `U=H*H-1`, where `H` is a (5x5) Hilbert; matrix, results in off-diagonal elements of $10^{-7}$ instead of the $10^{-13}$; using an `LU `according to `Crout`. - scaling protection is non-existent and limits are hard-coded, as a; consequence inversion of a Hilbert matrix for `sizes>(12x12)` fails. In; order to gain speed the `CLHEP` algorithm stores its permutation info of; the pivots points in a static array, making multi-threading not; possible. `GSL` uses LU decomposition without the implicit scaling of `Crout`.; Therefore, its accuracy is not as good. For instance a (10x10) Hilbert; matrix has errors 10 times larger than the `LU Crout` result. In; `ROOT v4.0`, the user can choose between the `Invert()` and; `IvertFast()` routines, where the latter is using the Cramer algorithm; for `sizes<7x7`. The speed graph shows the result for `InvertFast()`. 3. `A*x=b` the execution time is measured for solving the linear; equation `A*x=b`. The same factorizations are used as in the matrix; inversion. However, only 1 forward/back-substitution has to be used; instead of msize as in the inversion of (msize x msize) matrix. As a; consequence the same differences are observed but less amplified. CLHEP; shows the same numerical issues as in step the matrix inversion. Since; ROOT3.10 has no dedicated equation solver, the solution is calculated; through `x=A-1*b`. This will be slower and numerically not as stable. 4. $(A^{T}*A)^{-1}*A^{T}$ timing results for calculation of the pseudo inverse; of matrix a. The sequence of operations measures the impact of several; calls to constructors and destructors in the `C++` packages versus a `C`; library like `GSL`. ![Speed comparison between the different matrix packages](pictures/030",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:51717,rout,routines,51717,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['rout'],['routines']
Integrability,ion for importing data from ROOT TTree and THx histograms; rf402_datahandling.C - Tools for manipulation of (un)binned datasets; rf403_weightedevts.C - Using weights in unbinned datasets; rf404_categories.C - Working with RooCategory objects to describe discrete variables; rf405_realtocatfuncs.C - Demonstration of real-->discrete mapping functions; rf406_cattocatfuncs.C - Demonstration of discrete-->discrete (invertable) functions; rf407_latextables.C - Latex printing of lists and sets of RooArgSets; ; ORGANIZATION AND SIMULTANEOUS FITS. rf501_simultaneouspdf.C - Using simultaneous p.d.f.s to describe simultaneous fits to multiple datasets; rf502_wspacewrite.C - Creating and writing a workspace; rf503_wspaceread.C - Reading and using a workspace; rf504_simwstool.C - Using RooSimWSTool to construct a simultaneous p.d.f that is built of variations of an input p.d.f; rf505_asciicfg.C - Reading and writing ASCII configuration files; rf506_msgservice.C - Tuning and customizing the RooFit message logging facility; rf507_debugtools.C - Using the RooFit memory tracing debug tool; rf508_listsetmanip.C - RooArgSet and RooArgList tools and tricks; ; LIKELIHOOD AND MINIMIZATION. rf601_intminuit.C - Interactive minimization with MINUIT; rf602_chi2fit.C - Setting up a binning chi^2 fit; rf603_multicpu.C - Setting up a multi-core parallelized unbinned maximum likelihood fit; rf604_constraints.C - Fitting with constraints; rf605_profilell.C - Working with the profile likelihood estimator; rf606_nllerrorhandling.C - Understanding and customizing error handling in likelihood evaluations; rf607_fitresult.C - Demonstration of options of the RooFitResult class; ; SPECIAL PDFS. rf701_efficiencyfit.C - Unbinned maximum likelihood fit of an efficiency eff(x) function; rf702_efficiencyfit_2D.C - Unbinned maximum likelihood fit of an efficiency eff(x) function to; rf703_effpdfprod.C - Using a product of an (acceptance) efficiency and a p.d.f as p.d.f.; rf704_amplitudefit.C - Using a p.d.f def,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:4611,message,message,4611,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['message'],['message']
Integrability,"ion level with; the parameter PROOF_MonitorPerPacket .; Improve treatment of the case when temporary files are asked to be; created on a shared file system not containing the sandboxes. This; case, which seems to be a rather common one, should be now fully; supported.; Correctly honour selector abort status settings; TSelector::kAbortProcess and TSelector::kAbortFile.; Improve reporting of the non-processed {files, events} in the final; 'MissingFiles' list.  ; Improved algorithm for TPacketizerUnit to fix issue with non; homogeneous machines.; Improve the way the information about log files is saved in case of; failures. The log paths for these failing now should be now correctly; saved and accessible via TProofLog.; Improve merging of histograms. Just use TH1::Add whne the axis are; equal; much faster than TH1::Merge. Fixes; ; In TDataSetManagerFile::NotifyUpdate fix handling of the case when; the global list file does not exist yet (new dataset directory). Fixes; error messages during editing dataset operations.; Fix issue with machine names consistency when working on a local; machine ('localhost' or 'localhost.localdomain' are mapped to; gSystem->HostName()); solves possible matching problems in the; packetizer.; In TProofServ, fill the ""grand total"" message with more blanks, so; that no remnants of the previous message are visible on the screen.; In the autoconf/bonjour interface, fix issue preventing the correct; port (the protocol one, which may be different from the application; default) being used when registering the service. . In TProofPlayer::AddQueryResult, fix a bug affecting the order in; whihc query results are registered when the start time is within 1; second.; Fix worker name in TSlaveLite.; Fix problem with enabling packages with option 'notOnClient' in; PROOF-Lite .; Make sure the log file is flushed at the end of startup to avoid; spurious log messages on next commands .; In CreateSession(), fix an issue with the validity check for existing; ses",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html:5399,message,messages,5399,proof/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html,1,['message'],['messages']
Integrability,"ion needed when binding reference to class rvalue; Duplicate of 391. 292; CD3; Deallocation on exception in new before arguments evaluated; Unknown. 293; open; Syntax of explicit instantiation/specialization too permissive; Not resolved. 294; NAD; Can static_cast drop exception specifications?; No. 295; CD1; cv-qualifiers on function types; Clang 3.7. 296; CD1; Can conversion functions be static?; Yes. 297; NAD; Which template does an explicit specialization specialize?; Unknown. 298; CD1; T::x when T is cv-qualified; Clang 3.1. 299; CD1; Conversion on array bound expression in new; Clang 2.8 (C++11 onwards). 300; CD1; References to functions in template argument deduction; Yes. 301; CD1; Syntax for template-name; Clang 3.5. 302; CD1; Value-initialization and generation of default constructor; Clang 3.0. 303; NAD; Integral promotions on bit-fields; N/A. 304; TC1; Value-initialization of a reference; Clang 2.9. 305; CD1; Name lookup in destructor call; No. 306; CD1; Ambiguity by class name injection; Duplicate of 39. 307; NAD; Initialization of a virtual base class subobject; N/A. 308; NAD; Catching exceptions with ambiguous base classes; Clang 3.7. 309; CD1; Linkage of entities whose names are not simply identifiers, in introduction; Duplicate of 485. 310; open; Can function templates differing only in parameter cv-qualifiers be overloaded?; Not resolved. 311; NAD; Using qualified name to reopen nested namespace; Clang 3.0. 312; CD3; “use” of invalid pointer value not defined; Duplicate of 616. 313; dup; Class with single conversion function to integral as array size in new; Duplicate of 299 (C++11 onwards). 314; C++17; template in base class specifier; No. 315; NAD; Is call of static member function through null pointer undefined?; N/A. 316; NAD; Injected-class-name of template used as template template parameter; Superseded by 1004. 317; CD1; Can a function be declared inline after it has been called?; Clang 3.5. 318; CD1; struct A::A should not name the construct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:20182,inject,injection,20182,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['inject'],['injection']
Integrability,"ion of the CERNLIB algorithm; DGAUSS by Sigfried Kolbig, and it is used by the TF1::Integral method. The second one uses the Gauss Legendre quadrature formula. It is used by the TF1::IntegralFast method.; These classes implement both the same virtual interface as the adaptive integration methods provided by the MathMore library. They can all be created and used easily via the common class ROOT::Math::IntegratorOneDim providing the interfaces for numerical integration.; New template methods have been also included in the common Integration class in order to be able to integrate automatically any C++ callable object. ROOT::Math::RichardsonDerivator implementing numerical derivation using the Richardson's extrapolation formula (use 2 derivative estimates to compute a third, more accurate estimation). This is used by the TD1::Derivative method. ; BrentRootFinder for finding the root of one-dimensional function using the Brent algorithm. The class inherits from a virtual interface, which is also implemented by the MathMore root finder methods. The user can instantiate, via the common ROOT::Math::RootFinder class, all the various root finder algorithms. The BrentRootFinder class is used by TF1::GetX . ; A similar class, BrentMinimizer1D, provides the possibility to find the minimum of one-dimensional functions using the Brent algorithm. This class is used by TF1::GetMinimum or TF1::GetMaximum; Use ROOT convention for all enumeration names defining the type of numerical algorithms (start with k, like kADAPTIVE for the integration type). This affects both MathCore and MathMore.; . In addition we use now the ROOT convention for all enumeration names defining the type of numerical algorithms. The names start with k, like kADAPTIVE for the integration type. This change affects both MathCore and MathMore and it breaks backward compatibility. MathCore Function interfaces; Mathcore provides as well interfaces for the evaluation of mathematical and parametric functions to be used ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:7821,interface,interface,7821,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['interface'],['interface']
Integrability,"ion over the range of the X errors, rather than taking the central value by adding; an Integrate(true) argument to chi2FitTo(); Two new arguments, StoreError(const RooArgSet&) and StoreAsymError(const RooArgSet&); have been added to the RooDataSet constructor to simplify the process of storing the errors; of X and Y variables along with their values in a dataset. The newly added tutorial macro rf609_xychi2fit.C illustrates the use of all this; new functionality. Uniform interface for creation of (profile likelihoods) and chi-squared from p.d.f.s; It is now recommended to use the method RooAbsPdf::createNLL(RooAbsData&,...) to; create a likelihood from a p.d.f and a dataset rather than constructing a RooNLLVar; object directly. This is because part of the likelihood construction functionality such a using; multiple Range()s, or the inclusion for constraint terms are only available through; createNLL(). To promote the consistency of this interface, a similar method RooAbsReal::createChi2(); has been added to construct chi-squared functions of a dataset and a function or p.d.f. Along the same lines, it is recommended to use RooAbsReal::createProfile() rather; than constructing a RooProfileLL object directly as the former will efficiently; recast a profile of a profile into a single profile object. Multivariate Gaussian modeling of parameters estimates from a fit; You can now construct a multivariate Gaussian p.d.f on the parameters of a model that; represents the result of a fit, from any RooFitResult object. RooAbsPdf* paramPdf = fitresult->createHessePdf(RooArgSet(a,b)) ;. The returned object is an instance of the newly added class RooMultiVarGaussian, that can; model correlated Gaussian distributions in an arbitrary number of dimensions, given a; vector of mean values and a covariance matrix. Class RooMultivarGaussian implements analytical; integration as well as analytical partial integrals over the first 31 dimensions (if you have; that many) and implements in effe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:9706,interface,interface,9706,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['interface'],['interface']
Integrability,"ion the rights; > to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; > copies of the Software, and to permit persons to whom the Software is; > furnished to do so, subject to the following conditions:; >; > The above copyright notice and this permission notice shall be included in; > all copies or substantial portions of the Software.; >; > THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; > IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; > FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; > AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; > LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; > OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN; > THE SOFTWARE. zlib License; ------. ### Included only if built with zlib support. https://www.zlib.net/zlib_license.html. > zlib.h -- interface of the 'zlib' general purpose compression library; > version 1.2.11, January 15th, 2017; >; > Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler; >; > This software is provided 'as-is', without any express or implied; > warranty. In no event will the authors be held liable for any damages; > arising from the use of this software.; >; > Permission is granted to anyone to use this software for any purpose,; > including commercial applications, and to alter it and redistribute it; > freely, subject to the following restrictions:; >; > 1. The origin of this software must not be misrepresented; you must not; > claim that you wrote the original software. If you use this software; > in a product, an acknowledgment in the product documentation would be; > appreciated but is not required.; > 2. Altered source versions must be plainly marked as such, and must not be; > misrepresented as being the original software.; > 3. This notice may not be removed or altered from any source distribution.; >; > Jean-loup Gailly",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/LICENSE.md:9024,interface,interface,9024,net/http/civetweb/LICENSE.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/LICENSE.md,1,['interface'],['interface']
Integrability,"ion with a explicit cast to the wanted function.; - The system works with templates and the template can not resolve the correct type of function because it is overloaded.; - If you pass a function without the explicit cast you will get a very ugly traceback.; - A lot of common standard functions for example from math.h like sin, cos etc.. are overloaded, take care passing it. ~~~{.cxx}; #include<TRInterface.h>. Double_t myfun(Double_t x); {; return 2*cos(x);; }. Int_t myfun(Int_t x); {; return x;; }. void fun(); {; ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; r[""myfund""]<<(Double_t (*)(Double_t))myfun;; r[""myfuni""]<<(Int_t (*)(Int_t))myfun;. r<<""print(myfund(0.0))"";; r<<""print(myfuni(1))"";; }; ~~~. ## Wrapping a class; You can wrap a class and expose it in R environment using only a pair of macrodefinitions and the template class; `ROOT::R::class_<>`; The `ROOTR_EXPOSED_CLASS(Class)` macro allows you to expose the class as a new datatype of R, but it has to be alongside; the `ROOTR_MODULE(Module)` macro which allows you to create an internal R module and make the class wrapping; To do this you must use inside the `ROOTR_MODULE` braces the class `ROOT::R::class_<>` and specify; each constructor, attribute or method that the class to export has.; Then the macrodefinition `LOAD_ROOTR_MODULE(Module)` can load the module and the class in R's environment.; You can find a more clear instruction by looking at a example below in Functor section. ##DataFrames; DataFrame? is a very important datatype in R and in ROOTR we have a class to manipulate; dataframes called TRDataFrame, with a lot of very useful operators overloaded to work with TRDataFrame's objects; in a similar way that in the R environment but from c++ in ROOT.; Example:. Lets to create need data to play with dataframe features. ~~~{.cxx}; ////////////////////////; //creating variables//; ////////////////////////; TVectorD v1(3);; std::vector<Double_t> v2(3);; std::array<Int_t,3> v3{ {1,2,3} };; std",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md:6751,wrap,wrap,6751,bindings/r/doc/users-guide/ROOTR_Users_Guide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md,2,['wrap'],"['wrap', 'wrapping']"
Integrability,"ion). �; We introduced an interface for any tool that can produce a; SamplingDistribution, called TestStatSampler. �The interface is; essentially GetSamplingDistribution(parameterPoint) which returns a; SamplingDistribution based on a given probability density function. �We; foresee a few versions of this tool based on toy Monte Carlo, importance; sampling, Fourier transforms, etc. �The following concrete implementation; of the TestStatSampler interface are currently available. ToyMCSamplerUses a Toy Monte Carlo approach to build the; sampling distribution. �The pdf's generate method to generate is used to; generate toy data, and then the test statistic is evaluated at the; requested parameter point. ; DebuggingSampler Simply returns a uniform distribution; between 0,1. �Useful for debugging. NeymanConstruction and FeldmanCousins; A flexible framework for the Neyman Construction was added in this; release. The NeymanConstruction is a concrete implementation of the; IntervalCalculator interface, but it needs several; additional components�to be specified before use. The design; factorizes the choice of the parameter points to be tested,�the choice of; the test statistic, and the generation of sampling distribution into; separate parts (described above). �Finally, the NeymanConstruction class; is simply in charge of using these parts (strategies) and constructing; the confidence belt and confidence intervals. �The ConfidenceBelt class; is still under development, but the current version works fine for; producing ConfidenceIntervals. �We are also working to make this class; work with parallelization approaches, which is not yet complete.; The FeldmanCousins class is a separate concrete implementation of the; IntervalCalculator interface. �It uses the NeymanConstruction internally,; and�enforces�specific choices of the test statistic and ordering; principle to realize the Unified intervals described by Feldman and; Cousins in their paper�Phys.Rev.D57:3873-3889,1998. In ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:27866,interface,interface,27866,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['interface'],['interface']
Integrability,"ion, ROOT::Math::IParamMultiGradFunction interfaces, where the parameter values are now required for calculating the partial derivatives with respect to the parameters.; This changes the signature of the pure abstract method, DoParameterDerivative(const double *x, const double * p, , which takes also a pointer (type const double *) to the parameters.; In addition, these classes do not inherit anymore from the function gradient interface (ROOT::Math::IGradFunction and ROOT::Math::IMultiGradFunction). They define only the parameter gradient which is needed for fitting and not the coordinate gradient. A derived class, like ROOT::Math::Polynomial, implementing both functionality (coordinate and parameter gradient) inherits then from both interfaces.; . More detailed description of the current MathCore release can be found at this location. MathMore; This new release contains:. Modify and rename the class ROOT::Math::RootFinder to ROOT::Math::GSLRootFinder to distinguish from the main interface class which has been put in the Mathcore library and it can create the GSLRootFinder using the plug-in manager. Furthermore, the class ROOT::Math::GSLRootFinder is not anymore a template class on the algorithm. They type of root-finder algorithm can now be selected via an enumeration; Fixed a bug in the ROOT::Math::GSLNLSMultiFi class.; Changes also in the class for the new enumeration names (all names start with k, like kADAPTIVE for the integration types).; . More detailed description of the current MathMore release can be found at this location. GenVector; The new physics vector classes have been moved out from the MathCore library in a new library, libGenVector. The library contains as well the CINT dictionary including main instantiations for the template classes. For this release the instantiation of some extra methods, in particular of the class ROOT::Math::TRansform3D have been added in the dictionary library.; Due to a CINT limitation, the dictionary for explicit template ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:10427,interface,interface,10427,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['interface'],['interface']
Integrability,"ion,; * a message send, and the declared method either has the; ``cf_returns_not_retained`` attribute or it has neither the; ``cf_returns_retained`` attribute nor a :ref:`selector family; <arc.method-families>` that implies a retained result, or; * :when-revised:`[beginning LLVM 3.6]` :revision:`a load from a` ``const``; :revision:`non-system global variable.`. An expression is :arc-term:`known retained` if it is an rvalue of :ref:`C; retainable pointer type <arc.misc.c-retainable>` and it is:. * a message send, and the declared method either has the; ``cf_returns_retained`` attribute, or it does not have the; ``cf_returns_not_retained`` attribute but it does have a :ref:`selector; family <arc.method-families>` that implies a retained result. Furthermore:. * a comma expression is classified according to its right-hand side,; * a statement expression is classified according to its result expression, if; it has one,; * an lvalue-to-rvalue conversion applied to an Objective-C property lvalue is; classified according to the underlying message send, and; * a conditional operator is classified according to its second and third; operands, if they agree in classification, or else the other if one is known; retain-agnostic. If the cast operand is known retained, the conversion is treated as a; ``__bridge_transfer`` cast. If the cast operand is known unretained or known; retain-agnostic, the conversion is treated as a ``__bridge`` cast. .. admonition:: Rationale. Bridging casts are annoying. Absent the ability to completely automate the; management of CF objects, however, we are left with relatively poor attempts; to reduce the need for a glut of explicit bridges. Hence these rules. We've so far consciously refrained from implicitly turning retained CF; results from function calls into ``__bridge_transfer`` casts. The worry is; that some code patterns --- for example, creating a CF value, assigning it; to an ObjC-typed local, and then calling ``CFRelease`` when done --- are a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:27735,message,message,27735,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['message'],['message']
Integrability,"ion. This rule applies to the set of operating; systems supported for a given class of operating system (e.g. Unix, Win32). No Virtual Methods; ------------------. The Support Library interfaces can be called quite frequently by LLVM. In order; to make those calls as efficient as possible, we discourage the use of virtual; methods. There is no need to use inheritance for implementation differences, it; just adds complexity. The ``#include`` mechanism works just fine. No Exposed Functions; --------------------. Any functions defined by system libraries (i.e. not defined by ``lib/Support``); must not be exposed through the ``lib/Support`` interface, even if the header; file for that function is not exposed. This prevents inadvertent use of system; specific functionality. For example, the ``stat`` system call is notorious for having variations in the; data it provides. ``lib/Support`` must not declare ``stat`` nor allow it to be; declared. Instead it should provide its own interface to discovering; information about files and directories. Those interfaces may be implemented in; terms of ``stat`` but that is strictly an implementation detail. The interface; provided by the Support Library must be implemented on all platforms (even; those without ``stat``). No Exposed Data; ---------------. Any data defined by system libraries (i.e. not defined by ``lib/Support``) must; not be exposed through the ``lib/Support`` interface, even if the header file; for that function is not exposed. As with functions, this prevents inadvertent; use of data that might not exist on all platforms. Minimize Soft Errors; --------------------. Operating system interfaces will generally provide error results for every; little thing that could go wrong. In almost all cases, you can divide these; error results into two groups: normal/good/soft and abnormal/bad/hard. That is,; some of the errors are simply information like ""file not found"", ""insufficient; privileges"", etc. while other errors are much",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:6596,interface,interface,6596,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['interface'],['interface']
Integrability,"ion.; `Kaleidoscope Tutorial for complete beginner; <https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html>`_. - BuildingAJIT: Examples of the `BuildingAJIT tutorial; <https://llvm.org/docs/tutorial/BuildingAJIT1.html>`_ that shows how LLVM’s; ORC JIT APIs interact with other parts of LLVM. It also, teaches how to; recombine them to build a custom JIT that is suited to your use-case. ``llvm/include``; ----------------. Public header files exported from the LLVM library. The three main subdirectories:. ``llvm/include/llvm``. All LLVM-specific header files, and subdirectories for different portions of; LLVM: ``Analysis``, ``CodeGen``, ``Target``, ``Transforms``, etc... ``llvm/include/llvm/Support``. Generic support libraries provided with LLVM but not necessarily specific to; LLVM. For example, some C++ STL utilities and a Command Line option processing; library store header files here. ``llvm/include/llvm/Config``. Header files configured by ``cmake``. They wrap ""standard"" UNIX and; C header files. Source code can include these header files which; automatically take care of the conditional #includes that ``cmake``; generates. ``llvm/lib``; ------------. Most source files are here. By putting code in libraries, LLVM makes it easy to; share code among the `tools`_. ``llvm/lib/IR/``. Core LLVM source files that implement core classes like Instruction and; BasicBlock. ``llvm/lib/AsmParser/``. Source code for the LLVM assembly language parser library. ``llvm/lib/Bitcode/``. Code for reading and writing bitcode. ``llvm/lib/Analysis/``. A variety of program analyses, such as Call Graphs, Induction Variables,; Natural Loop Identification, etc. ``llvm/lib/Transforms/``. IR-to-IR program transformations, such as Aggressive Dead Code Elimination,; Sparse Conditional Constant Propagation, Inlining, Loop Invariant Code Motion,; Dead Global Elimination, and many others. ``llvm/lib/Target/``. Files describing target architectures for code generation. For example,; ``llvm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:35895,wrap,wrap,35895,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['wrap'],['wrap']
Integrability,"ion.inc.in; ${CMAKE_CURRENT_BINARY_DIR}/include/clang/Basic/Version.inc). # Add appropriate flags for GCC; if (LLVM_COMPILER_IS_GCC_COMPATIBLE); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -fno-common -Woverloaded-virtual""); if (NOT ""${CMAKE_CXX_COMPILER_ID}"" MATCHES ""Clang""); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -fno-strict-aliasing""); endif (). # Enable -pedantic for Clang even if it's not enabled for LLVM.; if (NOT LLVM_ENABLE_PEDANTIC); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -pedantic -Wno-long-long""); endif (). check_cxx_compiler_flag(""-Werror -Wnested-anon-types"" CXX_SUPPORTS_NO_NESTED_ANON_TYPES_FLAG); if( CXX_SUPPORTS_NO_NESTED_ANON_TYPES_FLAG ); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -Wno-nested-anon-types"" ); endif(); endif (). # Determine HOST_LINK_VERSION on Darwin.; set(HOST_LINK_VERSION); if (APPLE AND NOT CMAKE_LINKER MATCHES "".*lld.*""); set(LD_V_OUTPUT); execute_process(; COMMAND sh -c ""${CMAKE_LINKER} -v 2>&1 | head -1""; RESULT_VARIABLE HAD_ERROR; OUTPUT_VARIABLE LD_V_OUTPUT; ); if (HAD_ERROR); message(FATAL_ERROR ""${CMAKE_LINKER} failed with status ${HAD_ERROR}""); endif(); if (""${LD_V_OUTPUT}"" MATCHES "".*ld64-([0-9.]+).*""); string(REGEX REPLACE "".*ld64-([0-9.]+).*"" ""\\1"" HOST_LINK_VERSION ${LD_V_OUTPUT}); elseif (""${LD_V_OUTPUT}"" MATCHES ""[^0-9]*([0-9.]+).*""); string(REGEX REPLACE ""[^0-9]*([0-9.]+).*"" ""\\1"" HOST_LINK_VERSION ${LD_V_OUTPUT}); endif(); message(STATUS ""Host linker version: ${HOST_LINK_VERSION}""); endif(). include(CMakeParseArguments); include(AddClang). set(CMAKE_INCLUDE_CURRENT_DIR ON). include_directories(BEFORE; ${CMAKE_CURRENT_BINARY_DIR}/include; ${CMAKE_CURRENT_SOURCE_DIR}/include; ). if (NOT LLVM_INSTALL_TOOLCHAIN_ONLY); install(DIRECTORY include/clang include/clang-c; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT clang-headers; FILES_MATCHING; PATTERN ""*.def""; PATTERN ""*.h""; PATTERN ""config.h"" EXCLUDE; ). install(DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/include/clang; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT cl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:13124,message,message,13124,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['message'],['message']
Integrability,"ion:. .. code-block:: c++. const DataLayout &DL = getDataLayout();; MangleAndInterner Mangle(ES, DL);. auto &JD = ES.createJITDylib(""main"");. JD.define(; absoluteSymbols({; { Mangle(""puts""), ExecutorAddr::fromPtr(&puts)},; { Mangle(""gets""), ExecutorAddr::fromPtr(&getS)}; }));. Using absoluteSymbols is reasonable if the set of symbols to be reflected is; small and fixed. On the other hand, if the set of symbols is large or variable; it may make more sense to have the definitions added for you on demand by a; *definition generator*.A definition generator is an object that can be attached; to a JITDylib, receiving a callback whenever a lookup within that JITDylib fails; to find one or more symbols. The definition generator is given a chance to; produce a definition of the missing symbol(s) before the lookup proceeds. ORC provides the ``DynamicLibrarySearchGenerator`` utility for reflecting symbols; from the process (or a specific dynamic library) for you. For example, to reflect; the whole interface of a runtime library:. .. code-block:: c++. const DataLayout &DL = getDataLayout();; auto &JD = ES.createJITDylib(""main"");. if (auto DLSGOrErr =; DynamicLibrarySearchGenerator::Load(""/path/to/lib""; DL.getGlobalPrefix())); JD.addGenerator(std::move(*DLSGOrErr);; else; return DLSGOrErr.takeError();. // IR added to JD can now link against all symbols exported by the library; // at '/path/to/lib'.; CompileLayer.add(JD, loadModule(...));. The ``DynamicLibrarySearchGenerator`` utility can also be constructed with a; filter function to restrict the set of symbols that may be reflected. For; example, to expose an allowed set of symbols from the main process:. .. code-block:: c++. const DataLayout &DL = getDataLayout();; MangleAndInterner Mangle(ES, DL);. auto &JD = ES.createJITDylib(""main"");. DenseSet<SymbolStringPtr> AllowList({; Mangle(""puts""),; Mangle(""gets""); });. // Use GetForCurrentProcess with a predicate function that checks the; // allowed list.; JD.addGenerator(cantFail(D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:33115,interface,interface,33115,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['interface'],['interface']
Integrability,"ions can be found in the; :doc:`../TestingGuide`. TEST RUN OUTPUT FORMAT; ~~~~~~~~~~~~~~~~~~~~~~. The :program:`lit` output for a test run conforms to the following schema, in; both short and verbose modes (although in short mode no PASS lines will be; shown). This schema has been chosen to be relatively easy to reliably parse by; a machine (for example in buildbot log scraping), and for other tools to; generate. Each test result is expected to appear on a line that matches:. .. code-block:: none. <result code>: <test name> (<progress info>). where ``<result-code>`` is a standard test result such as PASS, FAIL, XFAIL,; XPASS, UNRESOLVED, or UNSUPPORTED. The performance result codes of IMPROVED and; REGRESSED are also allowed. The ``<test name>`` field can consist of an arbitrary string containing no; newline. The ``<progress info>`` field can be used to report progress information such; as (1/300) or can be empty, but even when empty the parentheses are required. Each test result may include additional (multiline) log information in the; following format:. .. code-block:: none. <log delineator> TEST '(<test name>)' <trailing delineator>; ... log message ...; <log delineator>. where ``<test name>`` should be the name of a preceding reported test, ``<log; delineator>`` is a string of ""*"" characters *at least* four characters long; (the recommended length is 20), and ``<trailing delineator>`` is an arbitrary; (unparsed) string. The following is an example of a test run output which consists of four tests A,; B, C, and D, and a log message for the failing test C:. .. code-block:: none. PASS: A (1 of 4); PASS: B (2 of 4); FAIL: C (3 of 4); ******************** TEST 'C' FAILED ********************; Test 'C' failed as a result of exit code 1.; ********************; PASS: D (4 of 4). LIT EXAMPLE TESTS; ~~~~~~~~~~~~~~~~~. The :program:`lit` distribution contains several example implementations of; test suites in the *ExampleTests* directory. SEE ALSO; --------. valgrind(1); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:23271,message,message,23271,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,2,['message'],['message']
Integrability,"ions of friend function specializations, e.g. ``friend void f<>(int) {}``.; - Clang now diagnoses narrowing conversions involving const references.; (`#63151 <https://github.com/llvm/llvm-project/issues/63151>`_).; - Clang now diagnoses unexpanded packs within the template argument lists of function template specializations.; - The warning `-Wnan-infinity-disabled` is now emitted when ``INFINITY``; or ``NAN`` are used in arithmetic operations or function arguments in; floating-point mode where ``INFINITY`` or ``NAN`` don't have the expected; values. - Clang now diagnoses attempts to bind a bitfield to an NTTP of a reference type as erroneous; converted constant expression and not as a reference to subobject.; - Clang now diagnoses ``auto`` and ``decltype(auto)`` in declarations of conversion function template; (`CWG1878 <https://cplusplus.github.io/CWG/issues/1878.html>`_); - Clang now diagnoses the requirement that non-template friend declarations with requires clauses; and template friend declarations with a constraint that depends on a template parameter from an; enclosing template must be a definition.; - Clang now diagnoses incorrect usage of ``const`` and ``pure`` attributes, so ``-Wignored-attributes`` diagnoses more cases.; - Clang now emits more descriptive diagnostics for 'unusual' expressions (e.g. incomplete index; expressions on matrix types or builtin functions without an argument list) as placement-args; to new-expressions. Before:. .. code-block:: text. error: no matching function for call to 'operator new'; 13 | new (__builtin_memset) S {};; | ^ ~~~~~~~~~~~~~~~~~~. note: candidate function not viable: no known conversion from '<builtin fn type>' to 'int' for 2nd argument; 5 | void* operator new(__SIZE_TYPE__, int);; | ^. After:. .. code-block:: text. error: builtin functions must be directly called; 13 | new (__builtin_memset) S {};; | ^. - Clang now diagnoses import before module declarations but not in global; module fragment.; (`#67627 <https://g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:31123,depend,depends,31123,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['depend'],['depends']
Integrability,"ions(Function*,; Function*)``. Operation affects ``FnTree`` contents with next way: *F* will stay in; ``FnTree``. *G* being equal to *F* will not be added to ``FnTree``. Calls of; *G* would be replaced with something else. It changes bodies of callers. So,; functions that calls *G* would be put into ``Deferred`` set and removed from; ``FnTree``, and analyzed again. The approach is next:. 1. Most wished case: when we can use alias and both of *F* and *G* are weak. We; make both of them with aliases to the third strong function *H*. Actually *H*; is *F*. See below how it's made (but it's better to look straight into the; source code). Well, this is a case when we can just replace *G* with *F*; everywhere, we use ``replaceAllUsesWith`` operation here (*RAUW*). 2. *F* could not be overridden, while *G* could. It would be good to do the; next: after merging the places where overridable function were used, still use; overridable stub. So try to make *G* alias to *F*, or create overridable tail; call wrapper around *F* and replace *G* with that call. 3. Neither *F* nor *G* could be overridden. We can't use *RAUW*. We can just; change the callers: call *F* instead of *G*. That's what; ``replaceDirectCallers`` does. Below is a detailed body description. If “F” may be overridden; ------------------------; As follows from ``mayBeOverridden`` comments: “whether the definition of this; global may be replaced by something non-equivalent at link time”. If so, that's; ok: we can use alias to *F* instead of *G* or change call instructions itself. HasGlobalAliases, removeUsers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; First consider the case when we have global aliases of one function name to; another. Our purpose is make both of them with aliases to the third strong; function. Though if we keep *F* alive and without major changes we can leave it; in ``FnTree``. Try to combine these two goals. Do stub replacement of *F* itself with an alias to *F*. 1. Create stub function *H*, with the same nam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:27231,wrap,wrapper,27231,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['wrap'],['wrapper']
Integrability,"ips: false. TBrowser. Automatically switch to the tab containing the current canvas (if any) when e.g. drawing a histogram by double-clicking on its list tree item in a root file.; Automatically switch to (and update) the list of files in the file browser (left panel) when opening a ROOT file from the ""Open File"" menu. TGListView. Keyboard navigation is now fully working in the list view. TGMainFrame. Allow to save a snapshot of the GUI in a picture file. The supported formats are gif, jpg, png, tiff, and xpm. TGFileDialog. Allow to change directory by typing its name in the text entry field of the dialog. TProofProgressDialog. Added a speedometer widget (TGSpeedo) to display the processing rate; Added a check button to enable/disable smooth update of the speedometer (enabled by default). This could be useful in the case of slow displays (e.g. when using it via ssh); Several layout improvements. TRecorder. Improvements and consolidation of the cross-platform interoperability, allowing to record and replay sessions between different platforms with less side effects. NB: Using different OS/WM (Window Managers) and using different ROOT GUI settings (via e.g. system.rootrc) between recording and replaying may still produce a wrong behavior of the recorder.; New tutorial guitest_playback.C replaying a recorded session showing and validating the GUI (using guitest.C). GUI Builder; New features, new user interface; Several important features have been added to the builder, and its user interface has been redesigned.; Editing modes are now clearly distinguished with enabled and disabled layout mode. Possibility to enable automatic layout fasten the interface development, as the positioning doesn't have to be done manually anymore; Major changes in the user interface:. Added a list tree displaying the complete structure of the GUI; The name of every element of the GUI is now editable; New, more intuitive interface for padding and layout hints; Color settings option was added",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v526/index.html:1340,interoperab,interoperability,1340,gui/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v526/index.html,1,['interoperab'],['interoperability']
Integrability,"ipulation library. - `libCling` is the C++ interpreter (Cling). - `libCore` is the Base classes. - `libEG` is the abstract event generator interface classes. - \*`libEGPythia` is the Pythia5 event generator interface. - \*`libEGPythia6` is the Pythia6 event generator interface. - `libFitPanel` contains the GUI used for fitting. - `libGed` contains the GUI used for editing the properties of; histograms, graphs, etc. - `libGeom` is the geometry package (with builder and painter). - `libGpad` is the pad and canvas classes which depend on low level; graphics. - `libGraf` is the 2D graphics primitives (can be used independent; of libGpad). - `libGraf3d` is the 3D graphics primitives. - `libGui` is the GUI classes (depend on low level graphics). - `libGuiBld` is the GUI designer. - `libGuiHtml` contains the embedded HTML browser. - `libGX11` is the low level graphics interface to the X11 system. - \*`libGX11TTF` is an add-on library to libGX11 providing TrueType; fonts. - `libHbook` is for interface ROOT - HBOOK. - `libHist` is the histogram classes (with accompanying painter; library). - `libHtml` is the HTML documentation generation system. - `libMatrix` is the matrix and vector manipulation. - `libMathCore` contains the core mathematics and physics vector; classes. - `libMathMore` contains additional functions, interfacing the GSL; math library. - `libMinuit` is the MINUIT fitter. - `libNet` contains functionality related to network transfer. - `libNew` is the special global new/delete, provides extra memory; checking and interface for shared memory (optional). - `libPhysics` contains the legacy physics classes (TLorentzVector,; etc.). - `libPostscript` is the PostScript interface. - `libProof` is the parallel ROOT Facility classes. - `libPython` provides the interface to Python. - \*`libRFIO` is the interface to CERN RFIO remote I/O system. - \*`libRGL` is the interface to OpenGL. - `libReflex` is the runtime type database library used by Cling. - `libRint` is the int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:14382,interface,interface,14382,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['interface'],['interface']
Integrability,"ird_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part""; }; ]; }; ],; ""version"": 1; }. In this way, we can pass the single command line options after the ``--``.; Then clang-scan-deps will extract the necessary information from the options.; Note that we need to specify the path to the compiler executable instead of saying; ``clang++`` simply. The users may want the scanner to get the transitional dependency information for headers.; Otherwise, the users have to scan twice for the project, once for headers and once for modules.; To address the requirement, clang-scan-deps will recognize the specified preprocessor options; in the given command line and generate the corresponding dependency information. For example,. .. code-block:: console. $ clang-scan-deps -format=p1689 -- ../bin/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o -MD -MT impl_part.ddi -MF impl_part.dep; $ cat impl_part.dep. We will get:. .. code-block:: t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:36525,interface,interface,36525,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['interface'],['interface']
Integrability,"irectives. .. warning::. Setting this option to ``true`` could lead to incorrect code formatting; due to clang-format's lack of complete semantic information. As such,; extra care should be taken to review code changes made by this option. .. code-block:: c++. false: true:. if (isa<FunctionDecl>(D)) vs. if (isa<FunctionDecl>(D)) {; handleFunctionDecl(D); handleFunctionDecl(D);; else if (isa<VarDecl>(D)) } else if (isa<VarDecl>(D)) {; handleVarDecl(D); handleVarDecl(D);; else } else {; return; return;; }. while (i--) vs. while (i--) {; for (auto *A : D.attrs()) for (auto *A : D.attrs()) {; handleAttr(A); handleAttr(A);; }; }. do vs. do {; --i; --i;; while (i); } while (i);. .. _InsertNewlineAtEOF:. **InsertNewlineAtEOF** (``Boolean``) :versionbadge:`clang-format 16` :ref:`¶ <InsertNewlineAtEOF>`; Insert a newline at end of file if missing. .. _InsertTrailingCommas:. **InsertTrailingCommas** (``TrailingCommaStyle``) :versionbadge:`clang-format 11` :ref:`¶ <InsertTrailingCommas>`; If set to ``TCS_Wrapped`` will insert trailing commas in container; literals (arrays and objects) that wrap across multiple lines.; It is currently only available for JavaScript; and disabled by default ``TCS_None``.; ``InsertTrailingCommas`` cannot be used together with ``BinPackArguments``; as inserting the comma disables bin-packing. .. code-block:: c++. TSC_Wrapped:; const someArray = [; aaaaaaaaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaa,; aaaaaaaaaaaaaaaaaaaaaaaaaa,; // ^ inserted; ]. Possible values:. * ``TCS_None`` (in configuration: ``None``); Do not insert trailing commas. * ``TCS_Wrapped`` (in configuration: ``Wrapped``); Insert trailing commas in container literals that were wrapped over; multiple lines. Note that this is conceptually incompatible with; bin-packing, because the trailing comma is used as an indicator; that a container should be formatted one-per-line (i.e. not bin-packed).; So inserting a trailing comma counteracts bin-packing. .. _IntegerLiteralSeparator:. **I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:76324,wrap,wrap,76324,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['wrap'],['wrap']
Integrability,"irectory--------; configure_file(${CMAKE_CURRENT_SOURCE_DIR}/CTestCustom.cmake ${CMAKE_CURRENT_BINARY_DIR} COPYONLY). #---Provide a rootlogon.C file in the current build directory that; # will affect the way we run all tutorials.; # This overwrites the existing rootlogon.C and rootalias.C in the; # tutorials directory which is copied to the build area.; #-------------------------------------------------------------------; file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/rootlogon.C ""{; // Needed by ACLiC to use the current directory for scratch area; gSystem->SetBuildDir(\"".\"", kTRUE);; }""); file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/rootalias.C """"); file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/rootlogoff.C ""{}""); file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/.rootrc ""; Proof.Sandbox: /tmp/proof; Rint.History: .root_hist; ACLiC.LinkLibs: 1; ""). #---Tutorials that need substantial network to work------------------; set(need_network dataframe/df027_SQliteDependencyOverVersion.C). #---Tutorials disabled depending on the build components-------------. if(NOT clad); set(clad_veto fit/minuit2GausFit.C; # TODO: the next veto should not be necessary!; # The tutorial should also work without clad.; # See https://github.com/root-project/root/issues/15091.; fit/exampleFit3D.C; ); endif(). if(MSVC AND NOT win_broken_tests); # RBatchGenerator tutorials don't work on Windows at the moment.; list(APPEND dataframe_veto tmva/RBatchGenerator_NumPy.py); list(APPEND dataframe_veto tmva/RBatchGenerator_TensorFlow.py); list(APPEND dataframe_veto tmva/RBatchGenerator_PyTorch.py); list(APPEND dataframe_veto tmva/RBatchGenerator_filters_vectors.py); # df036* and df037* seem to trigger OS errors when trying to delete the; # test files created in the tutorials. It is unclear why.; list(APPEND dataframe_veto dataframe/df036_missingBranches.C); list(APPEND dataframe_veto dataframe/df036_missingBranches.py); list(APPEND dataframe_veto dataframe/df037_TTreeEventMatching.C); list(APPEND dataframe_veto dataframe/df037_TTreeEv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:2741,depend,depending,2741,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['depend'],['depending']
Integrability,"irement, the :ref:`PassManager; <writing-an-llvm-pass-passmanager>` scans the available passes to see if any; implementations of the analysis group are available. If none is available, the; default implementation is created for the pass to use. All standard rules for; :ref:`interaction between passes <writing-an-llvm-pass-interaction>` still; apply. Although :ref:`Pass Registration <writing-an-llvm-pass-registration>` is; optional for normal passes, all analysis group implementations must be; registered, and must use the :ref:`INITIALIZE_AG_PASS; <writing-an-llvm-pass-RegisterAnalysisGroup>` template to join the; implementation pool. Also, a default implementation of the interface **must**; be registered with :ref:`RegisterAnalysisGroup; <writing-an-llvm-pass-RegisterAnalysisGroup>`. As a concrete example of an Analysis Group in action, consider the; `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`_; analysis group. The default implementation of the alias analysis interface; (the `basic-aa <https://llvm.org/doxygen/structBasicAliasAnalysis.html>`_ pass); just does a few simple checks that don't require significant analysis to; compute (such as: two different globals can never alias each other, etc).; Passes that use the `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`_ interface (for; example the `gvn <https://llvm.org/doxygen/classllvm_1_1GVN.html>`_ pass), do not; care which implementation of alias analysis is actually provided, they just use; the designated interface. From the user's perspective, commands work just like normal. Issuing the; command ``opt -gvn ...`` will cause the ``basic-aa`` class to be instantiated; and added to the pass sequence. Issuing the command ``opt -somefancyaa -gvn; ...`` will cause the ``gvn`` pass to use the ``somefancyaa`` alias analysis; (which doesn't actually exist, it's just a hypothetical example) instead. .. _writing-an-llvm-pass-RegisterAnalysisGroup:. Using ``RegisterAnaly",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:37191,interface,interface,37191,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['interface'],['interface']
Integrability,"irrelevant, since in both cases; the error matrix will be unreliable and the minimum suspicious. ## Additional trouble–shooting ##. When M just doesn't work, some of the more common causes are:. - **Precision mismatch.** Make sure your $\mbox{FCN}$ uses; internally the same precision as M . If the problem is only one of precision, and not of word length; mismatch, an appropriate MnMachinePrecision::setPrecision() may fix; it. - **Trivial bugs in $\mbox{FCN}$.** The possibilities for bugs are; numerous. Probably the most common among physicists inexperienced in; is the confusion between double and int types, which you can; sometimes get away with, but not always. [^3] M can spot some; trivial bugs itself, and issues a warning when it detects an unusual; $\mbox{FCN}$ behaviour. Such a warning should be taken; seriously. M also offers some tools (especially $\mbox{SCAN}$) which can; help the user to find trivial bugs. - **An ill–posed problem.** For questions of parameter dependence, see; the discussion above on postive–definiteness. Other mathematical; problems which can arise are: **excessive numerical roundoff** — be; especially careful of exponential and factorial functions which get; big very quickly and lose accuracy; **starting too far from the; solution** — the function may have unphysical local minima,; especially at infinity in some variables; **incorrect; normalization** — in likelihood functions, the probability; distributions must be normalized or at least have an integral which; is independent of the values of the variable parameters. - **A bug in M .** This is unlikely, but it happens. If a bug is; suspected, and all other possible causes can be eliminated, please; try to save a copy of the input and output files, listing of; $\mbox{FCN}$, and other information that may be relevant, and; send them to $\mbox{fred.james@cern.ch}$. # A complete example #. [example:example]. Here a full example of a fit is presented, following the example; DemoGaussSim.cpp. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:74426,depend,dependence,74426,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['depend'],['dependence']
Integrability,"is chapter and later require LLVM 3.7 or; later. LLVM 3.6 and before will not work with it. Also note that you; need to use a version of this tutorial that matches your LLVM release:; If you are using an official LLVM release, use the version of the; documentation included with your release or on the `llvm.org releases; page <https://llvm.org/releases/>`_. Code Generation Setup; =====================. In order to generate LLVM IR, we want some simple setup to get started.; First we define virtual code generation (codegen) methods in each AST; class:. .. code-block:: c++. /// ExprAST - Base class for all expression nodes.; class ExprAST {; public:; virtual ~ExprAST() = default;; virtual Value *codegen() = 0;; };. /// NumberExprAST - Expression class for numeric literals like ""1.0"".; class NumberExprAST : public ExprAST {; double Val;. public:; NumberExprAST(double Val) : Val(Val) {}; Value *codegen() override;; };; ... The codegen() method says to emit IR for that AST node along with all; the things it depends on, and they all return an LLVM Value object.; ""Value"" is the class used to represent a ""`Static Single Assignment; (SSA) <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_; register"" or ""SSA value"" in LLVM. The most distinct aspect of SSA values; is that their value is computed as the related instruction executes, and; it does not get a new value until (and if) the instruction re-executes.; In other words, there is no way to ""change"" an SSA value. For more; information, please read up on `Static Single; Assignment <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_; - the concepts are really quite natural once you grok them. Note that instead of adding virtual methods to the ExprAST class; hierarchy, it could also make sense to use a `visitor; pattern <http://en.wikipedia.org/wiki/Visitor_pattern>`_ or some other; way to model this. Again, this tutorial won't dwell on good software; engineering practices: for our purposes, adding a virtua",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:1658,depend,depends,1658,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['depend'],['depends']
Integrability,"is future demand we can figure out if it makes sense to; introduce a new library, move the general classes somewhere else, or introduce; some other solution. We describe the roles of these classes in order of their dependencies. The Diagnostics Subsystem; -------------------------. The Clang Diagnostics subsystem is an important part of how the compiler; communicates with the human. Diagnostics are the warnings and errors produced; when the code is incorrect or dubious. In Clang, each diagnostic produced has; (at the minimum) a unique ID, an English translation associated with it, a; :ref:`SourceLocation <SourceLocation>` to ""put the caret"", and a severity; (e.g., ``WARNING`` or ``ERROR``). They can also optionally include a number of; arguments to the diagnostic (which fill in ""%0""'s in the string) as well as a; number of source ranges that related to the diagnostic. In this section, we'll be giving examples produced by the Clang command line; driver, but diagnostics can be :ref:`rendered in many different ways; <DiagnosticConsumer>` depending on how the ``DiagnosticConsumer`` interface is; implemented. A representative example of a diagnostic is:. .. code-block:: text. t.c:38:15: error: invalid operands to binary expression ('int *' and '_Complex float'); P = (P-42) + Gamma*4;; ~~~~~~ ^ ~~~~~~~. In this example, you can see the English translation, the severity (error), you; can see the source location (the caret (""``^``"") and file/line/column info),; the source ranges ""``~~~~``"", arguments to the diagnostic (""``int*``"" and; ""``_Complex float``""). You'll have to believe me that there is a unique ID; backing the diagnostic :). Getting all of this to happen has several steps and involves many moving; pieces, this section describes them and talks about best practices when adding; a new diagnostic. The ``Diagnostic*Kinds.td`` files; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Diagnostics are created by adding an entry to one of the; ``clang/Basic/Diagnostic*Kinds.td`` files, de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:2551,depend,depending,2551,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,"['depend', 'interface']","['depending', 'interface']"
Integrability,"is means that; rootcling may now issue:. ``` {.cpp}; Error: in this version of ROOT, the option '!' used in a linkdef file; implies the actual existence of customized operators.; The following declaration is now required:; TBuffer &operator<<(TBuffer &,const THit *);; ```. if the operator `<<` declaration is missing. To steer the parsing done during the execution of rootcling, a new; macro: *\_\_ROOTCLING\_\_* is now defined during the parsing. The macros; *\_\_CINT\_\_* and *\_\_MAKECINT\_\_* are defined only when looking for; `#pragma` statement. The genreflex executable is still available, it preserves the same command; line options as in version 5 and provides new ones. Old selection XML files; are transparently usable by the new implementation. On the other hand some; of the new functionalities can be hardly backported to version 5. See; genreflex help for all the details about commandline switches and selection; files. It is important to note that it is not anymore a python script; interfaced to GCCXML but rather a wrapper around rootcling. In order to specify the classes selection, three methods are available:. 1) Selection XML file. This file can be read by both genreflex and rootcling.; 2) LinkDef file. This file can be read by rootcling.; 3) Selection namespace (also called *dictselection*). Available both for; rootcling and genreflex. See the documentation of the; `ROOT::Meta::Selection` namespace for all the details. *Warning*. It is important to note that during the parsing of the header files,; rootcint no longer defines *\_\_CINT\_\_* and genreflex no longer defines; *\_\_GCCXML\_\_*. This means in particular that data members that were; made transient by hiding them from rootcint or genreflex now *must* be; *explicitly* marked as transient. For rootcint or rootcling use:. ``` {.cpp}; sometype datamember; //! The exclamation mark signals the transientness; ```. and for genreflex. ``` {.cpp}; <class name=""edm::Particle"" >; <field name=""m_calculated"" tr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md:7803,interface,interfaced,7803,core/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md,2,"['interface', 'wrap']","['interfaced', 'wrapper']"
Integrability,"is not considered reasonable to revert without at least the promise to; provide a means for the patch author to debug the root issue. If a situation; arises where a public reproducer can not be shared for some reason (e.g.; requires hardware patch author doesn't have access to, sharp regression in; compile time of internal workload, etc.), the reverter is expected to be; proactive about working with the patch author to debug and test candidate; patches.; * Reverts should be reasonably timely. A change submitted two hours ago; can be reverted without prior discussion. A change submitted two years ago; should not be. Where exactly the transition point is is hard to say, but; it's probably in the handful of days in tree territory. If you are unsure,; we encourage you to reply to the commit thread, give the author a bit to; respond, and then proceed with the revert if the author doesn't seem to be; actively responding.; * When re-applying a reverted patch, the commit message should be updated to; indicate the problem that was addressed and how it was addressed. Obtaining Commit Access; -----------------------. We grant commit access to contributors with a track record of submitting high; quality patches. If you would like commit access, please send an email to; `Chris <mailto:clattner@llvm.org>`_ with your GitHub username. This is true; for former contributors with SVN access as well as new contributors. If; approved, a GitHub invitation will be sent to your GitHub account. In case you; don't get notification from GitHub, go to; `Invitation Link <https://github.com/orgs/llvm/invitation>`_ directly. Once; accept the invitation, you'll get commit access. Prior to obtaining commit access, it is common practice to request that; someone with commit access commits on your behalf. When doing so, please; provide the name and email address you would like to use in the Author; property of the commit. For external tracking purposes, committed changes are automatically reflected; on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:22839,message,message,22839,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['message'],['message']
Integrability,"is relative to the directory of the ``.clang-format-ignore`` file; (or the root directory if the pattern starts with a slash). Patterns; containing drive names (e.g. ``C:``) are not supported.; * Patterns follow the rules specified in `POSIX 2.13.1, 2.13.2, and Rule 1 of; 2.13.3 <https://pubs.opengroup.org/onlinepubs/9699919799/utilities/; V3_chap02.html#tag_18_13>`_.; * A pattern is negated if it starts with a bang (``!``). To match all files in a directory, use e.g. ``foo/bar/*``. To match all files in; the directory of the ``.clang-format-ignore`` file, use ``*``.; Multiple ``.clang-format-ignore`` files are supported similar to the; ``.clang-format`` files, with a lower directory level file voiding the higher; level ones. Vim Integration; ===============. There is an integration for :program:`vim` which lets you run the; :program:`clang-format` standalone tool on your current buffer, optionally; selecting regions to reformat. The integration has the form of a `python`-file; which can be found under `clang/tools/clang-format/clang-format.py`. This can be integrated by adding the following to your `.vimrc`:. .. code-block:: vim. if has('python'); map <C-K> :pyf <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:pyf <path-to-this-file>/clang-format.py<cr>; elseif has('python3'); map <C-K> :py3f <path-to-this-file>/clang-format.py<cr>; imap <C-K> <c-o>:py3f <path-to-this-file>/clang-format.py<cr>; endif. The first line enables :program:`clang-format` for NORMAL and VISUAL mode, the; second line adds support for INSERT mode. Change ""C-K"" to another binding if; you need :program:`clang-format` on a different key (C-K stands for Ctrl+k). With this integration you can press the bound key and clang-format will; format the current line in NORMAL and INSERT mode or the selected region in; VISUAL mode. The line or region is extended to the next bigger syntactic; entity. It operates on the current, potentially unsaved buffer and does not create; or save any files. To ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:6526,integrat,integration,6526,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['integrat'],['integration']
Integrability,"is the next crossed one, but the physical path (state) AFTER crossing; the boundary is not determined. In order to find out this new state, one; has to propagate the point with a distance slightly bigger that the; computed step value (which is accurate within numerical precision). A; method that performs this task finding the next location is; `TGeoManager::Step()`, described in "" Making a Step "", but users may; implement more precise methods to insure post-step boundary crossing. ## Geometry Graphical User Interface. The geombuilder package allows you to create and edit geometries. The; package provides a library of all GUI classes related to geometry. Each; editable geometry class **`TGeoXXX`** have a correspondent editor; **`TGeoXXXEditor`** that provides a graphics user interface allowing to; edit some (or all) parameters of a geometry object. The editable objects; are geometry manager, volumes, nodes, shapes, media, materials and; matrices. The interfaces provide also access to specific functionality; of geometry objects. The editing mechanism is based on ROOT GED; (Graphics Editors) functionality and the library is loaded using the; plug-in mechanism. ### Editing a Geometry. There are two different use cases having different ways of invoking the; geometry editors. The first one applies when starting with geometry from; scratch and using the builder functionality to create new geometry; objects. In this case, one should use the sequence:. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; ```. The lines above will create a new **`TGeoManager`** class, create an; empty canvas and start the editor in the left-sided editor frame; attached to the canvas. To open the editor in a separate frame one; should provide a non-empty string as option to the `Edit()` method. ![The geometry manager editor](pictures/030001E9.png). ### The Geometry Manager Editor. ![Accessing/creating different categories o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:165675,interface,interfaces,165675,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['interface'],['interfaces']
Integrability,"is transformation analyzes and transforms the induction variables (and; computations derived from them) into simpler forms suitable for subsequent; analysis and transformation. This transformation makes the following changes to each loop with an; identifiable induction variable:. * All loops are transformed to have a *single* canonical induction variable; which starts at zero and steps by one.; * The canonical induction variable is guaranteed to be the first PHI node in; the loop header block.; * Any pointer arithmetic recurrences are raised to use array subscripts. If the trip count of a loop is computable, this pass also makes the following; changes:. * The exit condition for the loop is canonicalized to compare the induction; value against the exit value. This turns loops like:. .. code-block:: c++. for (i = 7; i*i < 1000; ++i). into. .. code-block:: c++. for (i = 0; i != 25; ++i). * Any use outside of the loop of an expression derived from the indvar is; changed to compute the derived value outside of the loop, eliminating the; dependence on the exit value of the induction variable. If the only purpose; of the loop is to compute the exit value of some derived expression, this; transformation will make the loop dead. This transformation should be followed by strength reduction after all of the; desired loop transformations have been performed. Additionally, on targets; where it is profitable, the loop could be transformed to count down to zero; (the ""do loop"" optimization). ``inline``: Function Integration/Inlining; -----------------------------------------. Bottom-up inlining of functions into callees. .. _passes-instcombine:. ``instcombine``: Combine redundant instructions; -----------------------------------------------. Combine instructions to form fewer, simple instructions. This pass does not; modify the CFG. This pass is where algebraic simplification happens. This pass combines things like:. .. code-block:: llvm. %Y = add i32 %X, 1; %Z = add i32 %Y, 1. in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:18681,depend,dependence,18681,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['depend'],['dependence']
Integrability,"is very infrequently used, it is important for; providing information about the current target machine being compiled for, and; other static information that can affect the various transformations. ``ImmutablePass``\ es never invalidate other transformations, are never; invalidated, and are never ""run"". .. _writing-an-llvm-pass-ModulePass:. The ``ModulePass`` class; ------------------------. The `ModulePass <https://llvm.org/doxygen/classllvm_1_1ModulePass.html>`_ class; is the most general of all superclasses that you can use. Deriving from; ``ModulePass`` indicates that your pass uses the entire program as a unit,; referring to function bodies in no predictable order, or adding and removing; functions. Because nothing is known about the behavior of ``ModulePass``; subclasses, no optimization can be done for their execution. A module pass can use function level passes (e.g. dominators) using the; ``getAnalysis`` interface ``getAnalysis<DominatorTree>(llvm::Function *)`` to; provide the function to retrieve analysis result for, if the function pass does; not require any module or immutable passes. Note that this can only be done; for functions for which the analysis ran, e.g. in the case of dominators you; should only ask for the ``DominatorTree`` for function definitions, not; declarations. To write a correct ``ModulePass`` subclass, derive from ``ModulePass`` and; override the ``runOnModule`` method with the following signature:. The ``runOnModule`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnModule(Module &M) = 0;. The ``runOnModule`` method performs the interesting work of the pass. It; should return ``true`` if the module was modified by the transformation and; ``false`` otherwise. .. _writing-an-llvm-pass-CallGraphSCCPass:. The ``CallGraphSCCPass`` class; ------------------------------. The `CallGraphSCCPass; <https://llvm.org/doxygen/classllvm_1_1CallGraphSCCPass.html>`_ is used by; passes that need to traverse the program bottom",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:13242,interface,interface,13242,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['interface'],['interface']
Integrability,"isible context (e.g., function prototype, struct definition, etc.). .. _Default pointer types in typeof:. Default pointer types in ``typeof()``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When ``typeof()`` takes an expression, it respects the bounds annotation on; the expression type, including the bounds annotation is implcit. For example,; the global variable ``g`` in the following code is implicitly ``__single`` so; ``typeof(g)`` gets ``char *__single``. The similar is true for the parameter; ``p``, so ``typeof(p)`` returns ``void *__single``. The local variable ``l`` is; implicitly ``__bidi_indexable``, so ``typeof(l)`` becomes; ``int *__bidi_indexable``. .. code-block:: C. char *g; // typeof(g) == char *__single. void foo(void *p) {; // typeof(p) == void *__single. int *l; // typeof(l) == int *__bidi_indexable; }. When the type of expression has an ""external"" bounds annotation, e.g.,; ``__sized_by``, ``__counted_by``, etc., the compiler may report an error on; ``typeof`` if the annotation creates a dependency with another declaration or; variable. For example, the compiler reports an error on ``typeof(p1)`` shown in; the following code because allowing it can potentially create another type; dependent on the parameter ``size`` in a different context (Please note that an; external bounds annotation on a parameter may only refer to another parameter of; the same function). On the other hand, ``typeof(p2)`` works resulting in ``int; *__counted_by(10)``, since it doesn't depend on any other declaration. .. TODO: add a section describing constraints on external bounds annotations. .. code-block:: C. void foo(int *__counted_by(size) p1, size_t size) {; // typeof(p1) == int *__counted_by(size); // -> a compiler error as it tries to create another type; // dependent on `size`. int *__counted_by(10) p2; // typeof(p2) == int *__counted_by(10); // -> no error. }. When ``typeof()`` takes a type name, the compiler doesn't apply an implicit; bounds annotation on the named pointer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:26312,depend,dependency,26312,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['depend'],['dependency']
Integrability,"ist. * Text formatting and spelling should follow the same rules as documentation; and in-code comments, ex. capitalization, full stop, etc. * If the commit is a bug fix on top of another recently committed patch, or a; revert or reapply of a patch, include the git commit hash of the prior; related commit. This could be as simple as ""Revert commit NNNN because it; caused PR#"". * If the patch has been reviewed, add a link to its review page, as shown; `here <https://www.llvm.org/docs/Phabricator.html#committing-a-change>`__.; If the patch fixes a bug in GitHub Issues, we encourage adding a reference to; the issue being closed, as described; `here <https://llvm.org/docs/BugLifeCycle.html#resolving-closing-bugs>`__. * It is also acceptable to add other metadata to the commit message to automate; processes, including for downstream consumers. This metadata can include; links to resources that are not available to the entire community. However,; such links and/or metadata should not be used in place of making the commit; message self-explanatory. Note that such non-public links should not be; included in the submitted code. For minor violations of these recommendations, the community normally favors; reminding the contributor of this policy over reverting. Minor corrections and; omissions can be handled by sending a reply to the commits mailing list. .. _revert_policy:. Patch reversion policy; ----------------------. As a community, we strongly value having the tip of tree in a good state while; allowing rapid iterative development. As such, we tend to make much heavier; use of reverts to keep the tree healthy than some other open source projects,; and our norms are a bit different. How should you respond if someone reverted your change?. * Remember, it is normal and healthy to have patches reverted. Having a patch; reverted does not necessarily mean you did anything wrong.; * We encourage explicitly thanking the person who reverted the patch for doing; the task on your b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:18111,message,message,18111,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['message'],['message']
Integrability,"isualisation settings and division interface for volumes"" width=600px. - *Division*. Allows dividing the edited volume according a given; pattern. The division axes that are allowed are presented in a; radio-button group. The number entries labeled ""From"", ""Step""; and ""Nslices"" correspond to the divisioning parameters on the; selected axis. The range of the division is between `start` and; `start+ndiv*step` values and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by typing a number, press; ENTER at the end to validate. This applies for taking into account and; validation of any number change in the geometry editors. \anchor GP08f; ### How to Create a Valid Geometry with Geometry Editors. 1. Create a new geometry manager and start the editor as described at; the beginning. 2. Create at least one material from the ""Materials"" shutter item; category. Generally, for creating objects, the interface is always in; the TGeoManagerEditor in different categories - one should just; provide a name and requested parameters. 3. Create a shape that will be used for the top volume within the; ""Shapes"" category. For the moment, the shapes that have editors are; Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype,; Pcon, Torus and Sphere. 4. Create a medium from one of the existing materials from the; ""Medium"" category. You will notice that some categories as ""Volume""; and ""Medium"" are inactive at the beginning because at that time there; is no material yet (for making a medium) and no shape (for making a; volume). These categories are dynamically activated once all the; required components are defined. 5. Create a volume from the ""Volumes"" category. You will notice that; contrary to the other editors, the volume editor is opened in a tab, not; transient - this is because it is more complex. 6. Go back to ""General"" category and select the newly created volume; as the top one (you can do it also from the volume c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:134342,interface,interface,134342,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['interface'],['interface']
Integrability,"it clone https://github.com/wlav/cppyy-backend.git; $ cd cppyy-backend/cling; $ python setup.py egg_info; $ python create_src_directory.py; $ python setup.py bdist_wheel; $ python -m pip install dist/cppyy_cling-* --upgrade. .. note::; ``cppyy-cling`` wheels do not depend on the Python interpreter and can; thus be re-used for any version of Python or PyPy. The ``egg_info`` setup command is needed for ``create_src_directory.py`` to; find the right version.; That script in turn downloads the proper release from `upstream`_, trims and; patches it,; and installs the result in the ""src"" directory.; When done, the structure of ``cppyy-cling`` looks again like a PyPA package; and can be used/installed as expected, here done with ``pip``. By default, the setup script will use all cores (x2 if hyperthreading is; enabled).; You can change this behavior by setting the ``MAKE_NPROCS`` envar to the; desired number of allowable sub jobs. If on the other hand you are building from source to develop/modify; ``cppyy-cling``, consider using the ``cmake`` interface.; The first installation will still be just as slow, but subsequent builds can; be incremental and thus much faster.; For this use, first install the latest version from a pre-built wheel, which; will setup the proper directory structure, then use cmake to build and; install the latest or modified version of ``cppyy-cling`` into that::. $ python -m pip install cppyy-cling; $ git clone https://github.com/wlav/cppyy-backend.git; $ cd cppyy-backend/cling; $ python setup.py egg_info; $ python create_src_directory.py; $ mkdir dev; $ cd dev; $ cmake ../src -Wno-dev -DCMAKE_CXX_STANDARD=17 -DLLVM_ENABLE_EH=0 -DLLVM_ENABLE_RTTI=0 -DLLVM_ENABLE_TERMINFO=0 -DLLVM_ENABLE_ASSERTIONS=0 -Dminimal=ON -Druntime_cxxmodules=OFF -Dbuiltin_zlib=ON -Dbuiltin_cling=ON -DCMAKE_BUILD_TYPE=RelWithDebInfo -DCMAKE_INSTALL_PREFIX=<path to environment python site-packages>; $ make -j <N> install. where the ``cmake`` command needs to be given the full p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst:3931,interface,interface,3931,bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/repositories.rst,1,['interface'],['interface']
Integrability,"it does have problems. In particular, because the; conservative garbage collector cannot *know* that a particular word in the; machine is a pointer, it cannot move live objects in the heap (preventing the; use of compacting and generational GC algorithms) and it can occasionally suffer; from memory leaks due to integer values that happen to point to objects in the; program. In addition, some aggressive compiler transformations can break; conservative garbage collectors (though these seem rare in practice). Accurate garbage collectors do not suffer from any of these problems, but they; can suffer from degraded scalar optimization of the program. In particular,; because the runtime must be able to identify and update all pointers active in; the program, some optimizations are less effective. In practice, however, the; locality and performance benefits of using aggressive garbage collection; techniques dominates any low-level losses. This document describes the mechanisms and interfaces provided by LLVM to; support accurate garbage collection. Goals and non-goals; -------------------. LLVM's intermediate representation provides :ref:`garbage collection intrinsics; <gc_intrinsics>` that offer support for a broad class of collector models. For; instance, the intrinsics permit:. * semi-space collectors. * mark-sweep collectors. * generational collectors. * incremental collectors. * concurrent collectors. * cooperative collectors. * reference counting. We hope that the support built into the LLVM IR is sufficient to support a; broad class of garbage collected languages including Scheme, ML, Java, C#,; Perl, Python, Lua, Ruby, other scripting languages, and more. Note that LLVM **does not itself provide a garbage collector** --- this should; be part of your language's runtime library. LLVM provides a framework for; describing the garbage collectors requirements to the compiler. In particular,; LLVM provides support for generating stack maps at call sites, polling for a; saf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:4923,interface,interfaces,4923,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['interface'],['interfaces']
Integrability,"it. There's no need to worry; about the index of these loops, because they get propagated. For example, if; you want to iterate over a vector of RooFit objects using a loop, you don't; have to think about indexing them properly because the `beginLoop()` function; takes care of that. Simply call this function, place your function call in a; scope and after the scope ends, the loop will also end. - `addToCodeBody()` helps add things to the body of the C++ function that; you're creating. It takes whatever string is computed in its arguments and; adds it to the overall function string (which will later be just-in-time; compiled). The `addToCodeBody()` function is important since not everything; can be added in-line and this function helps split the code into multiple; lines. ### Step 3. analyticalIntegral() Use Case. > Besides the `evaluate()` function, this tutorial illustrates how the; `analyticalIntegral()` can be updated. This highly dependent on the class that; is being transformed for AD support, but will be necessary in those specific; instances. Let's consider a fictional class RooFoo, that performs some arbitrary; mathematical operations called 'Foo' (as seen in doFoo() function below). > Note that doFoo is a simplified example, in many cases the mathematical; operations are not limited to a single function, so they need to be spotted; within the `evaluate()` function. ``` {.cpp}; class RooFoo : public RooAbsReal {; int a;; int b;; int doFoo() { return a* b + a + b; }; int integralFoo() { return /* whatever */;}; public:; // Other functions...; double evaluate() override {; // Do some bookkeeping; return doFoo();; };; double analyticalIntegral(Int_t code, const char* rangeName) override {; // Select the right paths for integration using codes or whatever.; return integralFoo();; }; };; ```. \note All RooFit classes are deriving from the RooAbsReal object, but; its details are not relevant to the current example. Note how the `evaluate()` function overrides the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:18870,depend,dependent,18870,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['depend'],['dependent']
Integrability,"ith C++ Modules which is important but; unfair comparison. As we noted earlier, PCH is very efficient, it cannot be; extended to the experiments’ software stacks because of its design constraints.; On the contrary, the C++ Modules can be used in third-party code where the PCH; is not available. The comparisons are to give a good metric when we are ready to switch ROOT to use; C++ Modules by default. However, since it is essentially the same technology,; optimizations of C++ Modules also affect the PCH. We have a few tricks up in; the sleeves to but they come with given trade-offs. #### Preloading of C++ Modules. The main focus for the technology preview was not in performance until recently.; We have invested some resources in optimizations and we would like to show you; (probably outdated) performance results:. * Memory footprint -- mostly due to importing all C++ Modules at startup; we see overhead which depends on the number of preloaded modules. For; ROOT it is between 40-60 MB depending on the concrete configuration.; When the workload increases we notice that the overall memory performance; decreases in number of cases.; * Execution times -- likewise we have an execution overhead. For ; workflows which take ms the slowdown can be 2x. Increasing of the work; to seconds shows 50-60% slowdowns. The performance is dependent on many factors such as configuration of ROOT and; workflow. You can read more at our Intel IPCC-ROOT Showcase presentation; here (pp 25-33)[[8]]. #### Loading C++ Modules on Demand. In long term, we should optimize the preloading of modules to be a no-op and; avoid recursive behavior based on identifier lookup callbacks. Unfortunately,; at the moment the loading of C++ modules on demand shows significantly better; performance results. You can visit our continuous performance monitoring tool where we compare; the performance of ROOT against ROOT with a PCH [[9]].; *Note: if you get error 400, clean your cache or open a private browser session.*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:18349,depend,depending,18349,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['depend'],['depending']
Integrability,"ith `&storage_prefix=name` URL #290; 7. Let customize URL for ""Show in new tab"" menu command; 8. Support both new and old TRatioPlot drawings; 10. Synchronize X/Y range selection with native ROOT; 11. Proper handle attributes from TH2Poly bins, support ""p"" for markers drawing; 12. Correctly scale size of axis ticks - take into account NDC axis length; 13. Set name and userData in geometry `build()` function #303; 14. Draw histogram title afterwards - place in front of stats box; 15. Upgrade three.js r158 -> r162, last with WebGL1 support; 16. Split extras into three_addons.mjs, provide jsroot geometry build without three.js; 17. Fix - correctly draw only grids with AXIG draw option; 18. Fix - log scales on TH3 drawings #306; 19. Fix - draw geometry top node volume if all childs not visible #308; 20. Fix - properly process 206 server response without Accept-Ranges header https://root-forum.cern.ch/t/59426/. ## Changes in 7.6.1; 1. Remove source_dir output in node.js #296; 2. Fully integrate svg2pdf.js into jsroot repo; 3. Fix - support plain TRI option for TGraph2D; 4. Fix - let read object from ROOT file with empty name; 5. Fix - graph drawing fix custom labels on X axis #297; 6. Fix - draw at least line for TGraphErrors ROOT-8131; 7. Fix - preserve attributes and draw options when call drawingJSON() #307; 8. Fix - menu for text align selection typo. ## Changes in 7.6.0; 1. Implement ""tickz"" draw option, used for color palette ticks; 2. Implement skewness and kurtosis calculations for histogram stats box; 3. Introduce ""logv"" draw option for `TH3`, configures logarithmic scale for box volume; 4. Implement color palette drawing for `TH3`; 5. Implement cutg draw option for `TH2`/`TF2` surface plots; 6. Implement `TMath::Sq()` function and several others like SinH, ASinH, ...; 7. Implement histogram drawing build from `TGraph2D` using Delaunay interpolation; 8. Provide preliminary `TF3` support; 9. Support `TLinearGradient` and `TRadialGradient` colors; 10. Support LZMA ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:5457,integrat,integrate,5457,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['integrat'],['integrate']
Integrability,"ither the variable stops; being used completely or a new value is stored in the variable. The intent of the third rule is to say that return values may be; released after they've been used. A computation history depends on a pointer value ``P`` if it:. * performs a pointer comparison with ``P``,; * loads from ``P``,; * stores to ``P``,; * depends on a pointer value ``Q`` derived via pointer arithmetic; from ``P`` (including an instance-variable or field access), or; * depends on a pointer value ``Q`` loaded from ``P``. Dependency applies only to values derived directly or indirectly from; a particular expression result and does not occur merely because a; separate pointer value dynamically aliases ``P``. Furthermore, this; dependency is not carried by values that are stored to objects. .. admonition:: Rationale. The restrictions on dependency are intended to make this analysis; feasible by an optimizer with only incomplete information about a; program. Essentially, dependence is carried to ""obvious"" uses of a; pointer. Merely passing a pointer argument to a function does not; itself cause dependence, but since generally the optimizer will not; be able to prove that the function doesn't depend on that parameter,; it will be forced to conservatively assume it does. Dependency propagates to values loaded from a pointer because those; values might be invalidated by deallocating the object. For; example, given the code ``__strong id x = p->ivar;``, ARC must not; move the release of ``p`` to between the load of ``p->ivar`` and the; retain of that value for storing into ``x``. Dependency does not propagate through stores of dependent pointer; values because doing so would allow dependency to outlive the; full-expression which produced the original value. For example, the; address of an instance variable could be written to some global; location and then freely accessed during the lifetime of the local,; or a function could return an inner pointer of an object and store; it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:80600,depend,dependence,80600,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['depend'],['dependence']
Integrability,"itial adjustment. .. code-block:: c++. enum RelocationType {; reloc_pcrel_word = 0, // add reloc value after adjusting for the PC loc; reloc_picrel_word = 1, // add reloc value after adjusting for the PIC base; reloc_absolute_word = 2, // absolute relocation; no additional adjustment; reloc_absolute_dword = 3 // absolute relocation; no additional adjustment; };. Target JIT Info; ---------------. ``XXXJITInfo.cpp`` implements the JIT interfaces for target-specific; code-generation activities, such as emitting machine code and stubs. At; minimum, a target-specific version of ``XXXJITInfo`` implements the following:. * ``getLazyResolverFunction`` --- Initializes the JIT, gives the target a; function that is used for compilation. * ``emitFunctionStub`` --- Returns a native function with a specified address; for a callback function. * ``relocate`` --- Changes the addresses of referenced globals, based on; relocation types. * Callback function that are wrappers to a function stub that is used when the; real target is not initially known. ``getLazyResolverFunction`` is generally trivial to implement. It makes the; incoming parameter as the global ``JITCompilerFunction`` and returns the; callback function that will be used a function wrapper. For the Alpha target; (in ``AlphaJITInfo.cpp``), the ``getLazyResolverFunction`` implementation is; simply:. .. code-block:: c++. TargetJITInfo::LazyResolverFn AlphaJITInfo::getLazyResolverFunction(; JITCompilerFn F) {; JITCompilerFunction = F;; return AlphaCompilationCallback;; }. For the X86 target, the ``getLazyResolverFunction`` implementation is a little; more complicated, because it returns a different callback function for; processors with SSE instructions and XMM registers. The callback function initially saves and later restores the callee register; values, incoming arguments, and frame and return address. The callback; function needs low-level access to the registers or stack, so it is typically; implemented with assembler.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:82915,wrap,wrapper,82915,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['wrap'],['wrapper']
