quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Usability,"static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGTextEdit(const TGWindow* parent = 0, UInt_t w = 1, UInt_t h = 1, Int_t id = -1, UInt_t sboptions = 0, Pixel_t back = GetWhitePixel()); Create a text edit widget. TGTextEdit(const TGWindow* parent, UInt_t w, UInt_t h, TGText* text, Int_t id = -1, UInt_t sboptions = 0, Pixel_t back = GetWhitePixel()); Create a text edit widget. Initialize it with the specified text buffer. TGTextEdit(const TGWindow* parent, UInt_t w, UInt_t h, const char* string, Int_t id = -1, UInt_t sboptions = 0, Pixel_t back = GetWhitePixel()); Create a text edit widget. Initialize it with the specified string. ~TGTextEdit(); Cleanup text edit widget. void Init(); Initiliaze a text edit widget. void SetMenuState(); Enable/disable menu items in function of what is possible. Long_t ReturnLongestLineWidth(); Return width of longest line in widget. void Clear(Option_t* = """"); Clear text edit widget. Bool_t SaveFile(const char* fname, Bool_t saveas = kFALSE); Save file. If filename==0 ask user via dialog for a filename, if in; addition saveas==kTRUE always ask for new filename. Returns; kTRUE if file was correctly saved, kFALSE otherwise. Bool_t Copy(); Copy text. Bool_t Cut(); Cut text. Bool_t Paste(); Paste text into widget. void Print(Option_t* = """") const; Send current buffer to printer. void Delete(Option_t* = """"); Delete selection. Bool_t Search(const char* string, Bool_t direction = kTRUE, Bool_t caseSensitive = kFALSE); Search for string in the specified direction. If direction is true; the search will be in forward direction. Bool_t Replace(TGLongPosition pos, const char* oldText, const char* newText, Bool_t direction, Bool_t caseSensitive); Replace text starting at textPos. Bool_t Goto(Long_t line, Long_t column = 0); Goto the specified line. void SetInsertMode(TGTextEdit::EInsertMode mode = kInsert); Sets the mode how characters are entered. vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTextEdit.html:29428,Clear,Clear,29428,root/html602/TGTextEdit.html,https://root.cern,https://root.cern/root/html602/TGTextEdit.html,4,['Clear'],['Clear']
Usability,"static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_tTGeoBBox::fDXX half-length; Double_tTGeoBBox::fDYY half-length; Double_tTGeoBBox::fDZZ half-length; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. private:. TGeoBoolNode*fNodetop boolean node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const; Needed just for cleanup. void CreateThreadData(Int_t nthreads); Needed just for cleanup. TGeoCompositeShape(); Default constructor. TGeoCompositeShape(const char* name, const char* expression); Default constructor. TGeoCompositeShape(const char* expression); Default constructor. TGeoCompositeShape(const char* name, TGeoBoolNode* node); Constructor with a Boolean node. ~TGeoCompositeShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3] by sampling with 1% error. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Computes normal vector in POINT to the composite shape. Bool_t Contains(const Double_t* point) const; Tests if point is inside the shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoCompositeShape.html:20093,Clear,ClearThreadData,20093,root/html602/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html602/TGeoCompositeShape.html,2,['Clear'],['ClearThreadData']
Usability,static TTabCom::EContext_tkNUM_PAT; static TTabCom::EContext_tkROOT_Load; static TTabCom::EContext_tkSYS_EnvVar; static TTabCom::EContext_tkSYS_FileName; static TTabCom::EContext_tkSYS_UserName; static TTabCom::EContext_tkUNKNOWN_CONTEXT. private:. char*fBufinitialized by Hook(); Int_tfLastIterfrodo: iteration counter for recursive MakeClassFromVarName; Pattern_tfPat[25][1024]array of patterns; ULong64_tfPrevInterpMarker; const char*fRegExp[25]corresponding regular expression plain text; Bool_tfVarIsPointerfrodo: pointer or not flag; TSeqCollection*fpClasses; TSeqCollection*fpDirectives; TSeqCollection*fpEnvVars; TSeqCollection*fpFiles; TSeqCollection*fpGlobals; int*fpLocinitialized by Hook(); TSeqCollection*fpPragmas; TSeqCollection*fpSysIncFiles; TSeqCollection*fpUsers. Class Charts. Inheritance Chart:. TTabCom. Function documentation; TTabCom(); Default constructor. ~TTabCom(); Destructor. void ClearClasses(); Clear classes and namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far.; Not needed anymore. Use gROOT->GetListOfGlobalFunctions(). void ClearGlobals(); Forget all global variables seen so far.; With teh new implamentation the list is gROOT->GetListOfGlobals(true). void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void Rehas,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTabCom.html:7660,Clear,ClearCppDirectives,7660,root/html602/TTabCom.html,https://root.cern,https://root.cern/root/html602/TTabCom.html,2,['Clear'],['ClearCppDirectives']
Usability,"static voidblockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; const TMatrixDSym&covarianceMatrix() const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMultiVarGaussian.html:3321,clear,clearEvalErrorLog,3321,root/html534/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html534/RooMultiVarGaussian.html,6,['clear'],['clearEvalErrorLog']
Usability,"statistic histograms need a special treatment when using autobin. ;  ; Bool_t HistoSameAxis (TH1 *h0, TH1 *h1);  Return kTRUE is the histograms 'h0' and 'h1' have the same binning and ranges on the axis (i.e. ;  ; Int_t Incorporate (TObject *obj, TList *out, Bool_t &merged);  Incorporate object 'newobj' in the list 'outlist'. ;  ; Bool_t IsClient () const override;  Is the player running on the client? ;  ; Bool_t JoinProcess (TList *workers) override;  Prepares the given list of new workers to join a progressing process. ;  ; void MergeOutput (Bool_t savememvalues=kFALSE) override;  Merge objects in output the lists. ;  ; void RedirectOutput (Bool_t on=kTRUE);  Control output redirection to TProof::fLogFileW. ;  ; void SetInitTime () override;  Set init time. ;  ; void SetMerging (Bool_t on=kTRUE) override;  Switch on/off merge timer. ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1) override;  Stop process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback results from the specified slave. ;  ; void StoreOutput (TList *out) override;  Store received output list. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayer;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t GetCacheSize () override;  Return the size in byte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerSuperMaster.html:3835,feedback,feedback,3835,doc/master/classTProofPlayerSuperMaster.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerSuperMaster.html,1,['feedback'],['feedback']
Usability,"statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:19973,simpl,simply,19973,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,2,"['clear', 'simpl']","['clear', 'simply']"
Usability,"status. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Connect (const char *sender_class, const char *signal, const char *receiver_class, void *receiver, const char *slot);  This method allows to make a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; TProof * GetProof () const;  ; Bool_t HandleTimer (TTimer *timer) override;  Send feedback objects to client. ;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notified in case of exception. ;  ; void SetSelectorDataMembersFromOutputList ();  Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ;  ; void SetupFeedback () override;  Setup reporting of feedback object",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerRemote.html:19402,feedback,feedback,19402,doc/master/classTProofPlayerRemote.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerRemote.html,1,['feedback'],['feedback']
Usability,"steepest descent - Default=50; TStringfStructureString containing the network structure; TObjArrayfSynapsesCollection of all the synapses in the network; Double_tfTau! Tau - used in line search - Default=3.; TEventList*fTest! EventList defining the events in the test dataset; Bool_tfTestOwner! internal flag whether one has to delete fTest or not; TEventList*fTraining! EventList defining the events in the training dataset; Bool_tfTrainingOwner! internal flag whether one has to delete fTraining or not; TNeuron::ENeuronTypefTypeType of hidden neurons; TStringfWeightString containing the event weight; TStringfextDString containing the derivative name; TStringfextFString containing the function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiLayerPerceptron(); Default constructor. TMultiLayerPerceptron(const char* layout, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:19021,simpl,simple,19021,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,10,['simpl'],['simple']
Usability,"step->Fill(destep);; }. // we do not close the file; we want to keep the generated histograms;; // we fill a 3-d scatter plot with the particle step coordinates; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,800);; c1->SetFillColor(42);; c1->Divide(1,2);. c1->cd(1);; hdestep->SetFillColor(45);; hdestep->Fit(""gaus"");. c1->cd(2);; gPad->SetFillColor(37); // continued...; t2->SetMarkerColor(kRed);; t2->Draw(""vect[0]:vect[1]:vect[2]"");; if (gROOT->IsBatch()) return;. // invoke the x3d viewer; gPad->GetViewer3D(""x3d"");; }; 12.16 Example 3: Adding Friends to Trees; In this example, we will show how to extend a tree with a branch from another tree with the Friends feature.; 12.16.1 Adding a Branch to an Existing Tree; You may want to add a branch to an existing tree. For example, if one variable in the tree was computed with a certain algorithm, you may want to try another algorithm and compare the results. One solution is to add a new branch, fill it, and save the tree. The code below adds a simple branch to an existing tree. Note that the kOverwrite option in the Write method overwrites the existing tree. If it is not specified, two copies of the tree headers are saved.; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the tree; }; Adding a branch is often not possible because the tree is in a read-only file and you do not have permission to save the modified tree with the new branch. Even if you do have the permission, you risk loosing the original tree with an unsuccessful attempt to save the modification. Since trees are usually large, adding a branch could extend it over the 2GB limit. In this case, the attempt to w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:568302,simpl,simple,568302,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"stered; to the analysis manager but have to be cleaned-up by the user via ClearTracks(). Int_t AddTrack(TVirtualGeoTrack* track); Add a track to the list of tracks. TVirtualGeoTrack * MakeTrack(Int_t id, Int_t pdgcode, TObject* particle); Makes a primary track but do not attach it to the list of tracks. The track; can be attached as daughter to another one with TVirtualGeoTrack::AddTrack. Int_t AddVolume(TGeoVolume* volume); Add a volume to the list. Returns index of the volume in list. TGeoNavigator * AddNavigator(); Add a navigator in the list of navigators. If it is the first one make it; current navigator. TGeoNavigator * GetCurrentNavigator() const; Returns current navigator for the calling thread. TGeoNavigatorArray * GetListOfNavigators() const; Get list of navigators for the calling thread. Bool_t SetCurrentNavigator(Int_t index); Switch to another existing navigator for the calling thread. void SetNavigatorsLock(Bool_t flag); Set the lock for navigators. void ClearNavigators(); Clear all navigators. void RemoveNavigator(const TGeoNavigator* nav); Clear a single navigator. void SetMaxThreads(Int_t nthreads); Set maximum number of threads for navigation. void ClearThreadData() const. void CreateThreadData() const; Create thread private data for all geometry objects. void ClearThreadsMap(); Clear the current map of threads. This will be filled again by the calling; threads via ThreadId calls. Int_t ThreadId(); Translates the current thread id to an ordinal number. This can be used to; manage data which is pspecific for a given thread.; static __thread Int_t tid = -1;; if (tid > -1) return tid;. void Browse(TBrowser* b); Describe how to browse this object. void Edit(Option_t* option = """"); Append a pad for this geometry. void SetVisibility(TObject* obj, Bool_t vis); Set visibility for a volume. void BombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'bombed' translation vector according current exploded view mode. void UnbombTranslation(const Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoManager.html:38903,Clear,ClearNavigators,38903,root/html534/TGeoManager.html,https://root.cern,https://root.cern/root/html534/TGeoManager.html,6,['Clear'],"['Clear', 'ClearNavigators']"
Usability,"stfix);; 3122 TH1 *newth1 = (TH1 *)Clone(newName.Data());; 3123 newth1->SetDirectory(nullptr);; 3124 newth1->SetBit(kCanDelete);; 3125 if (gPad) gPad->IncrementPaletteColor(1, opt);; 3126 ; 3127 newth1->AppendPad(option);; 3128 return newth1;; 3129}; 3130 ; 3131////////////////////////////////////////////////////////////////////////////////; 3132/// Draw a normalized copy of this histogram.; 3133///; 3134/// A clone of this histogram is normalized to norm and drawn with option.; 3135/// A pointer to the normalized histogram is returned.; 3136/// The contents of the histogram copy are scaled such that the new; 3137/// sum of weights (excluding under and overflow) is equal to norm.; 3138/// Note that the returned normalized histogram is not added to the list; 3139/// of histograms in the current directory in memory.; 3140/// It is the user's responsibility to delete this histogram.; 3141/// The kCanDelete bit is set for the returned object. If a pad containing; 3142/// this copy is cleared, the histogram will be automatically deleted.; 3143///; 3144/// See Draw for the list of options; 3145 ; 3146TH1 *TH1::DrawNormalized(Option_t *option, Double_t norm) const; 3147{; 3148 Double_t sum = GetSumOfWeights();; 3149 if (sum == 0) {; 3150 Error(""DrawNormalized"",""Sum of weights is null. Cannot normalize histogram: %s"",GetName());; 3151 return nullptr;; 3152 }; 3153 Bool_t addStatus = TH1::AddDirectoryStatus();; 3154 TH1::AddDirectory(kFALSE);; 3155 TH1 *h = (TH1*)Clone();; 3156 h->SetBit(kCanDelete);; 3157 // in case of drawing with error options - scale correctly the error; 3158 TString opt(option); opt.ToUpper();; 3159 if (fSumw2.fN == 0) {; 3160 h->Sumw2();; 3161 // do not use in this case the ""Error option "" for drawing which is enabled by default since the normalized histogram has now errors; 3162 if (opt.IsNull() || opt == ""SAME"") opt += ""HIST"";; 3163 }; 3164 h->Scale(norm/sum);; 3165 if (TMath::Abs(fMaximum+1111) > 1e-3) h->SetMaximum(fMaximum*norm/sum);; 3166 if (TMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:125209,clear,cleared,125209,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['clear'],['cleared']
Usability,"stogram uncertainties). Also see method SubtractBackground() ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1229 of file TUnfoldSys.cxx. ◆ GetEmatrixSysSource(). void TUnfoldSys::GetEmatrixSysSource ; (; TH2 * ; ematrix, . const char * ; name, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from a systematic variation of the response matrix ; Parameters. [in,out]ematrixcovariance matrix histogram ; [in]nameidentifier of the systematic variation ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram prior to adding the covariance matrix contribution. Returns the covariance matrix contribution from shifting the given uncertainty source within one sigma ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1113 of file TUnfoldSys.cxx. ◆ GetEmatrixSysTau(). void TUnfoldSys::GetEmatrixSysTau ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance matrix contribution from error on regularisation parameter ; Parameters. [in,out]ematrixoutput histogram ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result from the assigned uncertainty on the parameter tau, see method SetTauError(). ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1176 of file TUnfoldSys.cxx. ◆ GetEmatrixSysUncorr(). void TUnfoldSys::GetEmatrixSysUncorr ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). Covariance co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:40800,clear,clearEmat,40800,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearEmat']
Usability,"stogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2*GetEmatrixInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); voidTUnfoldSys::GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); TH2*GetEmatrixSysBackgroundUncorr(const char* bgrSource, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); voidTUnfoldSys::GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidTUnfoldSys::GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); TH2*GetEmatrixSysUncorr(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); TH2*GetEmatrixTotal(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); Double_tTUnfold::GetEpsMatrix() const; TH1*GetFoldedOutput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE, Bool_t addBgr = kFALSE) const; virtual const char*TObject::GetIconName() const; TH1*GetInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE) const; const TUnfoldBinning*GetInputBinning(const char* distributionName = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); TH2*GetL(const char* histog",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldDensity.html:8779,clear,clearEmat,8779,root/html534/TUnfoldDensity.html,https://root.cern,https://root.cern/root/html534/TUnfoldDensity.html,6,['clear'],['clearEmat']
Usability,"stract class describing PROOF resources; TProofResourcesStatic Class to handle PROOF static config; TProofServ PROOF Server Application Interface; TProofServLite PROOF-Lite Server Application Interface; TProofSuperMaster PROOF control class for making submasters; TProofVectorContainer<TProofDrawListOfGraphs::Point3D_t> Class describing a vector container; TProofVectorContainer<TProofDrawListOfPolyMarkers3D::Point4D_t> Class describing a vector container; TPyDispatcher Python dispatcher class; TPyMultiGenFunction Python for Math::IMultiGenFunction equivalent; TPyMultiGradFunction Python for Math::IMultiGradFunction equivalent; TPyReturn Python morphing return object; TPySelector Python equivalent base class for PROOF; TPythia6 Interface to Pythia6.1 Event Generator; TPythia6Decayer Particle Decayer Base Class; TPythia8 Interface class of Pythia8; TPythia8Decayer Particle Decayer using Pythia8; TPython Access to the python interpreter; TQApplication creates ROOT environement with the Qt windowing system; TQCanvasImp ABC describing Qt GUI independent main window; TQCanvasMenu interface to Qt based context sensitive popup menus; TQClass Class with connections; TQCommand encapsulates the information for undo/redo a single action.; TQConnection Internal class used in the object communication mechanism; TQMimeTypes Pool of mime type objects; TQObjSender Used to ""delegate"" TQObject functionality; TQObject Base class for object communication mechanism; TQRootApplication creates Qt environement interface with the ROOT windowing system; TQRootCanvas interface to Qt eventloop to handle user input; TQRootDialog prompt for the arguments of an object's member function; TQRootGuiFactory Qt ROOT Gui factory; TQUndoManager recorder of operations for undo and redo; TQpDataBase Qp Base Data class; TQpDataDens Qp Data class for Dens formulation; TQpDataSparse Qp Data class for Sparse formulation; TQpLinSolverBase Qp linear solver base class; TQpLinSolverDens Qp linear solver class for De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:115901,undo,undo,115901,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,2,['undo'],['undo']
Usability,"stract interface for shared property implementations; RooSharedPropertiesList Manager for shared properties among clones of certain RooAbsArg-derived types; RooSimGenContext Context for efficiently generating a dataset from a RooSimultaneous PDF; RooSimPdfBuilder RooSimultaneous PDF Builder (obsolete); RooSimWSTool Workspace oriented tool for customized cloning of p.d.f. into a simultaneous p.d.f; RooSimWSTool::BuildConfig Build configuration object for RooSimWSTool; RooSimWSTool::MultiBuildConfig Build configuration object for RooSimWSTool with multiple prototype p.d.f.; RooSimWSTool::ObjBuildConfig Validated RooSimWSTool build configuration; RooSimWSTool::ObjSplitRule Validated RooSimWSTool split rule; RooSimWSTool::SplitRule Split rule specification for prototype p.d.f; RooSimultaneous Simultaneous operator p.d.f, functions like C++ 'switch()' on input p.d.fs operating on index category5A; RooStats ; RooStats::AcceptanceRegion A simple class for acceptance regions used for ConfidenceBelt; RooStats::BernsteinCorrection A utility to add polynomial corrrection terms to a model to improve the description of data.; RooStats::CombinedCalculator A base class that is for tools that can be both HypoTestCalculators and IntervalCalculators; RooStats::ConfInterval Interface for Confidence Intervals; RooStats::ConfidenceBelt A confidence belt for the Neyman Construction; RooStats::DebuggingSampler A simple implementation of the DistributionCreator interface; RooStats::DebuggingTestStat A concrete implementation of the TestStatistic interface, useful for debugging.; RooStats::FeldmanCousins Interface for tools setting limits (producing confidence intervals); RooStats::HybridCalculator Hypothesis test calculator using a Bayesian-frequentist hybrid method; RooStats::HybridPlot Provides the plots for an HybridResult; RooStats::HybridResult Class containing the results of the HybridCalculator; RooStats::HypoTestCalculator Interface for tools doing hypothesis tests; RooStats::HypoTe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:41561,simpl,simple,41561,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['simpl'],['simple']
Usability,"stribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0, const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfold.html:25841,clear,cleared,25841,root/html534/TUnfold.html,https://root.cern,https://root.cern/root/html534/TUnfold.html,3,"['Clear', 'clear']","['ClearResults', 'cleared']"
Usability,"stricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. Obtaining fit results. The fit is carried out through; Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. TFractionFitter(); TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFractionFitter.html:4649,simpl,simple,4649,root/html530/TFractionFitter.html,https://root.cern,https://root.cern/root/html530/TFractionFitter.html,5,['simpl'],['simple']
Usability,"stricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. Obtaining fit results. The fit is carried out through; Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFractionFitter.html:4659,simpl,simple,4659,root/html602/TFractionFitter.html,https://root.cern,https://root.cern/root/html602/TFractionFitter.html,4,['simpl'],['simple']
Usability,"string filename); FILE * pFile;. RooWorkspace* MakeSingleChannelModel(vector<RooStats::HistFactory::EstimateSummary> summary, vector<string> systToFix, bool doRatio = false); to time the macro. void GuessObsNameVec(TH1* hist). RooWorkspace* MakeCombinedModel(vector<string> , vector<RooWorkspace*> ). void FitModel(RooWorkspace* , string , string , string , bool = false). void FormatFrameForLikelihood(RooPlot* frame, string XTitle = string(""#sigma / #sigma_{SM}""), string YTitle = string(""-log likelihood"")). TH1* MakeAbsolUncertaintyHist(const string& Name, const TH1* Hist). TH1* MakeScaledUncertaintyHist(const string& Name, vector<std::pair<TH1*,TH1*> > HistVec). RooArgList createStatConstraintTerms(RooWorkspace* proto, vector<string>& constraintTerms, ParamHistFunc& paramHist, TH1* uncertHist, RooStats::HistFactory::EstimateSummary::ConstraintType type, Double_t minSigma); Take a RooArgList of RooAbsReal's and; create N constraint terms (one for; each gamma) whose relative uncertainty; is the value of the ith RooAbsReal. The integer ""type"" controls the type; of constraint term:. type == 0 : NONE; type == 1 : Gaussian; type == 2 : Poisson; type == 3 : LogNormal. TDirectory * Makedirs(TDirectory* file, vector<string> names). TDirectory * Mkdir(TDirectory* file, string name). void SetFunctionsToPreprocess(vector<string> lines); { fPreprocessFunctions = lines;}. void SetObsNameVec(const vector<std::string>& obsNameVec); { fObsNameVec = obsNameVec; }. void SetObsName(const string& obsName); { fObsNameVec.clear(); fObsNameVec.push_back(obsName); fObsName = obsName; }. void AddObsName(const string& obsName); { fObsNameVec.push_back(obsName); }. » Author: Kyle Cranmer, Akira Shibata » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: cranmer $ » Last generated: 2011-12-02 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html:12607,clear,clear,12607,root/html532/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,https://root.cern,https://root.cern/root/html532/RooStats__HistFactory__HistoToWorkspaceFactoryFast.html,2,['clear'],['clear']
Usability,"struct or other type as an object in 3D space.; At the top of the scene we can see objects which is our pointer. Under it we see; pointers and collection elements. Collection must inherit from TCollection; or be STL collecion. We can change the number of visible levels or objects on the scene with the GUI or; methods. The size of geometry objects is proportional to the memory taken by this object; or to the number of members inside this object. An easy way to find some class in the viewer is to change the color of the type.; We can connect for example a TF2 class with red color or connect all classes; inheriting from TF2 by adding plus to name. For example typename ""TF2+"" tells us; that all classes inheriting from TF2 will be red. Navigation in viewer is very simple like in usual GLViewer. When you put the mouse over; some object you can see some information about it (e.g. name, size, actual level).; When you double click this object, it becames top object on scene.; Undo and redo operation are supported. In this picture we can see TStructViewer with pointer to TList which contains; other collections and objects of various classes. Other screenshot presents opened TStructNodeEditor. Function Members (Methods); public:. TStructViewer(void* ptr = NULL, const char* clname = NULL); virtual~TStructViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStructViewer.html:1325,Undo,Undo,1325,root/html532/TStructViewer.html,https://root.cern,https://root.cern/root/html532/TStructViewer.html,2,['Undo'],['Undo']
Usability,"struct or other type as an object in 3D space.; At the top of the scene we can see objects which is our pointer. Under it we see; pointers and collection elements. Collection must inherit from TCollection; or be STL collecion. We can change the number of visible levels or objects on the scene with the GUI or; methods. The size of geometry objects is proportional to the memory taken by this object; or to the number of members inside this object. An easy way to find some class in the viewer is to change the color of the type.; We can connect for example a TF2 class with red color or connect all classes; inheriting from TF2 by adding plus to name. For example typename ""TF2+"" tells us; that all classes inheriting from TF2 will be red. Navigation in viewer is very simple like in usual GLViewer. When you put the mouse over; some object you can see some information about it (e.g. name, size, actual level).; When you double click this object, it becames top object on scene.; Undo and redo operation are supported. In this picture we can see TStructViewer with pointer to TList which contains; other collections and objects of various classes. Other screenshot presents opened TStructNodeEditor. Function Members (Methods); public:. virtual~TStructViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Du",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStructViewer.html:1349,Undo,Undo,1349,root/html602/TStructViewer.html,https://root.cern,https://root.cern/root/html602/TStructViewer.html,2,['Undo'],['Undo']
Usability,"structor. TTreeViewer(const TTree* tree); TTreeViewer constructor with a pointer to a Tree. void AppendTree(TTree* tree); Allow geting the tree from the context menu. void SetNexpressions(Int_t expr); Change the number of expression widgets. void SetScanFileName(const char* name = """"); Set the name of the file where to redirect <Scan> output. void SetScanRedirect(Bool_t mode); Set the state of Scan check button. void SetTreeName(const char* treeName); Allow geting the tree from the context menu. void SetFile(); Set file name containing the tree. void BuildInterface(); Create all viewer widgets. ~TTreeViewer(); TTreeViewer destructor. void ActivateButtons(Bool_t first, Bool_t previous, Bool_t next, Bool_t last); Enable/disable session buttons. const char* Cut(); Apply Cut. const char* ScanList(); returns scanlist. void SetSession(TTVSession* session); Set current session. const char* EmptyBrackets(const char* name); Empty the bracket content of a string. void EmptyAll(); Clear the content of all items in the list view. void Empty(); Empty the content of the selected expression. TTVLVEntry * ExpressionItem(Int_t index); Get the item from a specific position. TList* ExpressionList(); Get the list of expression items. Int_t Dimension(); Compute dimension of the histogram. void ExecuteDraw(); Called when the DRAW button is executed. void ExecuteSpider(); Draw a spider plot for the selected entries. const char* Ex(); Get the expression to be drawn on X axis. const char* Ey(); Get the expression to be drawn on Y axis. const char* Ez(); Get the expression to be drawn on Z axis. const char* En(Int_t n); Get the n'th expression. void EditExpression(); Start the expression editor. Int_t MakeSelector(const char* selector = 0); Get use of TTree::MakeSelector() via the context menu. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Get use of TTree::Process() via the context menu. const char * GetGrOpt(); Get g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeViewer.html:34956,Clear,Clear,34956,root/html532/TTreeViewer.html,https://root.cern,https://root.cern/root/html532/TTreeViewer.html,1,['Clear'],['Clear']
Usability,"sultPtr::GetPtrT * GetPtr()Get the pointer to the encapsulated object.Definition RResultPtr.hxx:236; ROOT::RDF::RResultPtr::ThrowIfNullvoid ThrowIfNull()Definition RResultPtr.hxx:193; ROOT::RDF::RResultPtr::OnPartialResultRResultPtr< T > & OnPartialResult(ULong64_t everyNEvents, std::function< void(T &)> callback)Register a callback that RDataFrame will execute ""everyNEvents"" on a partial result.Definition RResultPtr.hxx:318; ROOT::RDF::RResultPtr::fLoopManagerRDFDetail::RLoopManager * fLoopManagerNon-owning pointer to the RLoopManager at the root of this computation graph.Definition RResultPtr.hxx:174; ROOT::RDF::RResultPtr::operator!=friend bool operator!=(const RResultPtr< T1 > &lhs, const RResultPtr< T2 > &rhs)Definition RResultPtr.hxx:407; ROOT::RDF::RResultPtr::beginRIterationHelper< T >::Iterator_t begin()Return an iterator to the beginning of the contained object if this makes sense, throw a compilation ...Definition RResultPtr.hxx:257; ROOT::RDF::RResultPtr::Value_tT Value_tConvenience alias to simplify access to proxied type.Definition RResultPtr.hxx:206; ROOT::RDF::RResultPtr::GetT * Get()Get the pointer to the encapsulated result.Definition RResultPtr.hxx:186; ROOT::RDF::RResultPtr::GetValueconst T & GetValue()Get a const reference to the encapsulated object.Definition RResultPtr.hxx:228; ROOT::RDF::RResultPtr::RResultPtrRResultPtr(const RResultPtr &)=default; ROOT::RDF::RResultPtr::operator*T & operator*()Get a pointer to the encapsulated object.Definition RResultPtr.hxx:240; ROOT::RDF::RResultPtr::operator=RResultPtr & operator=(const RResultPtr &)=default; ROOT::RDF::RResultPtr::OnPartialResultSlotRResultPtr< T > & OnPartialResultSlot(ULong64_t everyNEvents, std::function< void(unsigned int, T &)> callback)Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's ...Definition RResultPtr.hxx:364; ROOT::RDF::RResultPtr::operator=RResultPtr & operator=(RResultPtr &&)=default; ROOT::RDF::RResultPtr::operator==fri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultPtr_8hxx_source.html:23787,simpl,simplify,23787,doc/master/RResultPtr_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html,1,['simpl'],['simplify']
Usability,"svoid MapSubwindows() overrideMap all sub windows that are part of the composite frame.Definition TGFrame.cxx:1164; TGCompositeFrame::Layoutvoid Layout() overrideLayout the elements of the composite frame.Definition TGFrame.cxx:1257; TGCompositeFrame::SetCleanupvoid SetCleanup(Int_t mode=kLocalCleanup) overrideTurn on automatic cleanup of child frames in dtor.Definition TGFrame.cxx:1072; TGFrame::Resizevoid Resize(UInt_t w=0, UInt_t h=0) overrideResize the frame.Definition TGFrame.cxx:605; TGFrame::MapWindowvoid MapWindow() overridemap windowDefinition TGFrame.h:204; TGLayoutHintsThis class describes layout hints used by the layout classes.Definition TGLayout.h:50; TGMainFrameDefines top level windows that interact with the system Window Manager.Definition TGFrame.h:397; TGMainFrame::SetWindowNamevoid SetWindowName(const char *name=nullptr) overrideSet window name. This is typically done via the window manager.Definition TGFrame.cxx:1788; TGSimpleTableInterfaceTGSimpleTableInterface is a very simple implementation of a TVirtualTableInterface.Definition TGSimpleTableInterface.h:18; TGTableCreate an array to hold a bunch of numbers.Definition TGTable.h:34; TGTable::Updatevirtual void Update()Update the range of the available data and refresh the current view.Definition TGTable.cxx:1529; double; int; unsigned int; It is also possible to visualise data from a tree. A simple macro showing the use of a TTreeTableInterface follows.; {; // Open a root file.; TFile *file = new TFile(""$ROOTSYS/tutorials/hsimple.root"");; // Load a tree from the file; TNtuple *ntuple = (TNtuple *)file->Get(""ntuple"");; ; // Create an interface; TTreeTableInterface *iface = new TTreeTableInterface(ntuple);; ; // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;; ; // Create the table; TGTable *table = new TGTable(mainframe, 999, iface, 10, 6);; ; // Add the table to the main frame; mainframe->AddFrame(table, new ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTable.html:4137,simpl,simple,4137,doc/master/classTGTable.html,https://root.cern,https://root.cern/doc/master/classTGTable.html,1,['simpl'],['simple']
Usability,"synchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache. ;  ; Long64_t * fSeek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static TTreeCacheUnzip::EParUnzipMode fgParallel = TTreeCacheUnzip::kDisable;  Indicate if we want to activate the parallelism. ;  ; static Double_t fgRelBuffSize = .5;  This is the percentage of the TTreeCacheUnzip that will be used. ;  ;  Static Protected Attributes inherited from TTreeCache; static Int_t fgLearnEntries = 100;  number of entries used for learning mode ;  . Private Member Functions;  TTreeCacheUnzip (const TTreeCacheUnzip &)=delete;  ; void Init ();  Initialization procedure common to all the constructors. ;  ; TTreeCacheUnzip & operator= (const TTreeCacheUnzip &)=delete;  . Private Attributes; char * fCompBuffer;  ; Int_t fCompBufferSize;  . Additional Inherited Members;  Protected Member Functions inherited from TFileCacheRead; void SetEnablePrefetchingImpl (Bool_t setPrefetching=kFALSE);  TFileCacheRead implementation of SetEnablePrefetching. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TTreeCacheUnzip.h>. Inheritance diagram for TTreeCacheUnzip:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ UnzipState_t. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:25156,learn,learning,25156,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,2,['learn'],['learning']
Usability,"t &obs) const override;  Check if all components that depend on obs are binned. ;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &, double, double) const override;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the product operator construction. ;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setCacheAndTrackHints (RooArgSet &) override;  Label OK'ed components of a RooRealSumPdf with cache-and-track. ;  ; void setFloor (bool flag);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;  ; virtual RooAbsGenContext * binnedGenContext (const RooArgSet &vars, bool verbose=false) const;  Return a binned generator context. ;  ; bool canBeExtended () const;  If true, PDF can provide extended likelihood term. ;  ; RooFit::OwningPtr< RooAbsReal > createCdf (const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumPdf.html:5847,simpl,simple,5847,doc/v632/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumPdf.html,2,['simpl'],['simple']
Usability,"t (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t GetLearnEntries ();  Static function returning the number of entries used to train the cache see SetLearnEntries. ;  ; static void SetLearnEntries (Int_t n=10);  Static function to set the number of entries to be used in learning mode The default value for n is 10. ;  ;  Static Public Member Functions inherited from TFileCacheRead; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:26467,learn,learning,26467,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['learn'],['learning']
Usability,t . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome ROOT 6 Analysis Workshop. Abstract; This tutorial will guide you through an example analysis with ROOT 6. It shows the recommended practices for analyzing data stored in ROOT TTrees - the most common format for High Energy Physics data.; It requires ROOT 6 as it uses several of its features.; . 0. Setting up ROOT ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/root-6-analysis-workshop-1.html:2733,guid,guidelines,2733,d/root-6-analysis-workshop-1.html,https://root.cern,https://root.cern/d/root-6-analysis-workshop-1.html,2,['guid'],['guidelines']
Usability,"t = 0, Bool_t clipInvalid = kFALSE) const; static voidblockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; const TMatrixDSym&covarianceMatrix() const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMultiVarGaussian.html:3280,clear,clearEvalError,3280,root/html534/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html534/RooMultiVarGaussian.html,6,['clear'],['clearEvalError']
Usability,"t = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsAnaConvPdf.html:4403,clear,clearValueDirty,4403,root/html602/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsAnaConvPdf.html,2,['clear'],['clearValueDirty']
Usability,"t = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedPdf.html:3508,clear,clearValueDirty,3508,root/html534/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html,12,['clear'],['clearValueDirty']
Usability,"t = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsAnaConvPdf::coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDecay.html:2912,clear,clearValueDirty,2912,root/html534/RooDecay.html,https://root.cern,https://root.cern/root/html534/RooDecay.html,6,['clear'],['clearValueDirty']
Usability,"t = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBCPEffDecay.html:3214,clear,clearValueDirty,3214,root/html534/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html534/RooBCPEffDecay.html,24,['clear'],['clearValueDirty']
Usability,"t = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBDecay.html:3112,clear,clearValueDirty,3112,root/html534/RooBDecay.html,https://root.cern,https://root.cern/root/html534/RooBDecay.html,6,['clear'],['clearValueDirty']
Usability,"t = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooArgusBG.html:2936,clear,clearValueDirty,2936,root/html534/RooArgusBG.html,https://root.cern,https://root.cern/root/html534/RooArgusBG.html,266,['clear'],['clearValueDirty']
Usability,"t = 700); virtual~TEveGListTreeEditorFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTGMainFrame::CloseWindow()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); voidConnectSignals(); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveGListTreeEditorFrame.html:1526,Clear,Clear,1526,root/html532/TEveGListTreeEditorFrame.html,https://root.cern,https://root.cern/root/html532/TEveGListTreeEditorFrame.html,2,['Clear'],['Clear']
Usability,"t >::max()) override;  Load values from dataset 't' into this data collection, optionally selecting events using 'select' RooFormulaVar. ;  ; void loadValues (const TTree *t, const RooFormulaVar *select=nullptr, const char *rangeName=nullptr, Int_t nStart=0, Int_t nStop=2000000000);  Load values from tree 't' into this data collection, optionally selecting events using the RooFormulaVar 'select'. ;  ; RooAbsDataStore * merge (const RooArgSet &allvars, std::list< RooAbsDataStore * > dstoreList) override;  Merge columns of supplied data set(s) with this data set. ;  ; Int_t numEntries () const override;  ; std::unique_ptr< RooAbsDataStore > reduce (RooStringView name, RooStringView title, const RooArgSet &vars, const RooFormulaVar *cutVar, const char *cutRange, std::size_t nStart, std::size_t nStop) override;  ; void reset () override;  ; void Reset (Option_t *option=nullptr);  Interface function to TTree::Reset. ;  ; void resetBuffers () override;  ; void resetCache () override;  Remove tree with values of cached observables and clear list of cached observables. ;  ; void restoreAlternateBuffers ();  ; const RooArgSet & row ();  ; void setArgStatus (const RooArgSet &set, bool active) override;  Activate or deactivate the branch status of the TTree branch associated with the given set of dataset observables. ;  ; void setExternalWeightArray (const double *arrayWgt, const double *arrayWgtErrLo, const double *arrayWgtErrHi, const double *arraySumW2) override;  ; void Streamer (TBuffer &) override;  Stream an object of class RooTreeDataStore. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; double sumEntries () const override;  ; TTree & tree ();  ; const TTree * tree () const override;  ; double weight () const override;  Return the weight of the n-th data point (n='index') in memory. ;  ; virtual double weight () const=0;  ; double weight (Int_t index) const;  ; void weightError (double &lo, double &hi, RooAbsData::ErrorType etype=RooAbsData::Poisso",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:6011,clear,clear,6011,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['clear'],['clear']
Usability,"t AddOutputObject(TObject* obj); Incorporate output object (may not be used in this class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Int_t SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); Save the partial results of this query to a dedicated file under the user; data directory. The file name has the form; <session_tag>.q<query_seq_num>.root; The file pat and the file are created if not existing already.; Only objects in the outputlist not being TProofOutputFile are saved.; The packets list 'packets' is saved if given.; Trees not attached to any file are attached to the open file.; If 'queryend' is kTRUE evrything is written out (TTrees included).; The actual saving action is controlled by 'force' and by fSavePartialResults; fSaveResultsPerPacket:. fSavePartialResults = kFALSE/kTRUE no-saving/saving; fSaveResultsPerPacket = kFALSE/kTRUE save-per-query/save-per-packet. The function CheckMemUsage sets fSavePartialResults = 1 if fSaveMemThreshold > 0 and; ProcInfo_t::fMemResident >= fSa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:17769,feedback,feedback,17769,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,6,['feedback'],['feedback']
Usability,"t AddOutputObject(TObject* obj); Incorporate output object (may not be used in this class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF worker.; The return value is -1 in case of error and TSelector::GetStatus(); in case of success. Bool_t CheckMemUsage(Long64_t& mfreq, Bool_t& w80r, Bool_t& w80v, TString& wmsg); Check the memory usage, if requested.; Return kTRUE if OK, kFALSE if above 95% of at least one between virtual or; resident limits are depassed. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); Finalize query (may not be used in this class). Long64_t Finalize(TQueryResult* qr); Finalize query (may not be used in this class). void MergeOutput(); Merge output (may not be used in this class). void MapOutputListToDataMembers() const. void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayer.html:16410,feedback,feedback,16410,root/html528/TProofPlayer.html,https://root.cern,https://root.cern/root/html528/TProofPlayer.html,4,['feedback'],['feedback']
Usability,"t Descent algorithm (SGD)Definition NeuralNet.h:334; TMVA::DNN::Steepest::m_repetitionssize_t m_repetitionsDefinition NeuralNet.h:337; TMVA::DNN::Steepest::m_betadouble m_betainternal parameter (momentum)Definition NeuralNet.h:372; TMVA::DNN::Steepest::m_localGradientsstd::vector< double > m_localGradientslocal gradients for reuse in thread.Definition NeuralNet.h:376; TMVA::DNN::Steepest::m_prevGradientsstd::vector< double > m_prevGradientsvector remembers the gradients of the previous stepDefinition NeuralNet.h:373; TMVA::DNN::Steepest::m_alphadouble m_alphainternal parameter (learningRate)Definition NeuralNet.h:371; TMVA::DNN::Steepest::m_localWeightsstd::vector< double > m_localWeightslocal weights for reuse in thread.Definition NeuralNet.h:375; TMVA::DNN::Steepest::operator()double operator()(Function &fitnessFunction, Weights &weights, PassThrough &passThrough)operator to call the steepest gradient descent algorithmDefinition NeuralNet.icc:271; TMVA::DNN::Steepest::SteepestSteepest(double learningRate=1e-4, double momentum=0.5, size_t repetitions=10)c'torDefinition NeuralNet.h:348; TMVA::IPythonInteractiveThis class is needed by JsMVA, and it's a helper class for tracking errors during the training in Jup...Definition MethodBase.h:94; TMVA::TimerTiming information for training and evaluation of MVA methods.Definition Timer.h:58; TMVA::Timer::DrawProgressBarvoid DrawProgressBar(Int_t, const TString &comment="""")draws progress bar in color or B&W caution:Definition Timer.cxx:202; TStringBasic string class.Definition TString.h:139; double; unsigned int; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMVA::DNN::sumOfSquaresdouble sumOfSquares(ItOutput itOutputBegin, ItOutput itOutputEnd, ItTruth itTruthBegin, ItTruth itTruthEnd, ItDelta itDelta, ItDelta itDeltaEnd, ItInvActFnc itInvActFnc, double patternWeight); TMVA::DNN::uniformDoubledouble uniformDouble(double minValue, double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:79247,learn,learningRate,79247,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['learn'],['learningRate']
Usability,"t Dropout probability. ;  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t &matrix);  ; void WriteTensorToXML (void *node, const char *name, const std::vector< Matrix_t > &tensor);  helper functions for XML ;  . Static Protected Member Functions; static size_t CalculateNormDim (int axis, size_t c, size_t h, size_t w);  . Private Attributes; Tensor_t fDerivatives;  First fDerivatives of the activations of this layer. ;  ; TDescriptors * fDescriptors = nullptr;  ; Scalar_t fEpsilon;  ; Matrix_t fIVar;  ; Scalar_t fMomentum;  The weight decay. ;  ; Matrix_t fMu;  ; Matrix_t fMu_Training;  ; int fNormAxis;  Normalization axis. For each element of this axis we will compute mean and stddev. ;  ; Tensor_t fReshapedData;  ; int fTrainedBatches = 0;  ; Matrix_t fVar;  ; Matrix_t fVar_Training;  . Additional Inherited Members;  Protected Attributes inherited from TMVA::DNN::VGeneralLayer< Architecture_t >; Tensor_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html:8006,learn,learningRate,8006,doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"t HasUnCheckedChild(Bool_t first = kFALSE); Add all child items of 'item' into the list 'checked'. void UpdateState(); Update the state of the node 'item' according to the children states. void CheckAllChildren(Bool_t state = kTRUE); Set all child items of this one checked if state=kTRUE,; unchecked if state=kFALSE. void CheckChildren(TGListTreeItem* item, Bool_t state); Set all child items of 'item' checked if state=kTRUE;; unchecked if state=kFALSE. void SetCheckBox(Bool_t on = kTRUE); Set a check box on the tree node. void SetCheckBoxPictures(const TGPicture* checked, const TGPicture* unchecked); Change list tree check item icons. void SetPictures(const TGPicture* opened, const TGPicture* closed); Change list tree item icons. void SavePrimitive(ostream& out, Option_t* option, Int_t n); Save a list tree item attributes as a C++ statements on output stream. TGListTreeItem& operator=(const TGListTreeItemStd& ). Bool_t IsActive() const. void SetActive(Bool_t a); {}. const char * GetText() const. Int_t GetTextLength() const. const char * GetTipText() const. Int_t GetTipTextLength() const. void SetText(const char* text); {}. void SetTipText(const char* tip); {}. void SetUserData(void* userData, Bool_t own = kFALSE); {}. void * GetUserData() const. const TGPicture* GetPicture() const. const TGPicture* GetCheckBoxPicture() const. Bool_t HasCheckBox() const. void CheckItem(Bool_t checked = kTRUE). void Toggle(); { SetCheckBox( ! IsChecked()); }. Bool_t IsChecked() const. Bool_t HasColor() const; Item coloration (underline + minibox). Color_t GetColor() const. void SetColor(Color_t color); {}. void ClearColor(); {}. TGListTreeItemStd(const TGListTreeItemStd& ). » Author: Fons Rademakers 25/02/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 15:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGListTreeItemStd.html:6827,Clear,ClearColor,6827,root/html604/TGListTreeItemStd.html,https://root.cern,https://root.cern/root/html604/TGListTreeItemStd.html,1,['Clear'],['ClearColor']
Usability,"t HasUnCheckedChild(Bool_t first = kFALSE); Add all child items of 'item' into the list 'checked'. void UpdateState(); Update the state of the node 'item' according to the children states. void CheckAllChildren(Bool_t state = kTRUE); Set all child items of this one checked if state=kTRUE,; unchecked if state=kFALSE. void CheckChildren(TGListTreeItem* item, Bool_t state); Set all child items of 'item' checked if state=kTRUE;; unchecked if state=kFALSE. void SetCheckBox(Bool_t on = kTRUE); Set a check box on the tree node. void SetCheckBoxPictures(const TGPicture* checked, const TGPicture* unchecked); Change list tree check item icons. void SetPictures(const TGPicture* opened, const TGPicture* closed); Change list tree item icons. void SavePrimitive(ostream& out, Option_t* option, Int_t n); Save a list tree item attributes as a C++ statements on output stream. TGListTreeItem& operator=(const TGListTreeItemStd& ). Bool_t IsActive() const. void SetActive(Bool_t a); {}. const char * GetText() const. Int_t GetTextLength() const. const char * GetTipText() const. Int_t GetTipTextLength() const. void SetText(const char* text); {}. void SetTipText(const char* tip); {}. void SetUserData(void* userData, Bool_t own = kFALSE); {}. void * GetUserData() const. const TGPicture* GetPicture() const. const TGPicture* GetCheckBoxPicture() const. Bool_t HasCheckBox() const. void CheckItem(Bool_t checked = kTRUE). void Toggle(); { SetCheckBox( ! IsChecked()); }. Bool_t IsChecked() const. Bool_t HasColor() const; Item coloration (underline + minibox). Color_t GetColor() const. void SetColor(Color_t color); {}. void ClearColor(); {}. TGListTreeItemStd(const TGListTreeItemStd& ). » Author: Fons Rademakers 25/02/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-04 16:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGListTreeItemStd.html:6786,Clear,ClearColor,6786,root/html534/TGListTreeItemStd.html,https://root.cern,https://root.cern/root/html534/TGListTreeItemStd.html,1,['Clear'],['ClearColor']
Usability,"t HasUnCheckedChild(Bool_t first = kFALSE); Add all child items of 'item' into the list 'checked'. void UpdateState(); Update the state of the node 'item' according to the children states. void CheckAllChildren(Bool_t state = kTRUE); Set all child items of this one checked if state=kTRUE,; unchecked if state=kFALSE. void CheckChildren(TGListTreeItem* item, Bool_t state); Set all child items of 'item' checked if state=kTRUE;; unchecked if state=kFALSE. void SetCheckBox(Bool_t on = kTRUE); Set a check box on the tree node. void SetCheckBoxPictures(const TGPicture* checked, const TGPicture* unchecked); Change list tree check item icons. void SetPictures(const TGPicture* opened, const TGPicture* closed); Change list tree item icons. void SavePrimitive(ostream& out, Option_t* option, Int_t n); Save a list tree item attributes as a C++ statements on output stream. TGListTreeItem& operator=(const TGListTreeItemStd& ). Bool_t IsActive() const. void SetActive(Bool_t a); {}. const char * GetText() const. Int_t GetTextLength() const. const char * GetTipText() const. Int_t GetTipTextLength() const. void SetText(const char* text); {}. void SetTipText(const char* tip); {}. void SetUserData(void* userData, Bool_t own = kFALSE); {}. void * GetUserData() const. const TGPicture* GetPicture() const. const TGPicture* GetCheckBoxPicture() const. Bool_t HasCheckBox() const. void CheckItem(Bool_t checked = kTRUE). void Toggle(); { SetCheckBox( ! IsChecked()); }. Bool_t IsChecked() const. Bool_t HasColor() const; Item coloration (underline + minibox). Color_t GetColor() const. void SetColor(Color_t color); {}. void ClearColor(); {}. TGListTreeItemStd(const TGListTreeItemStd& ). » Author: Fons Rademakers 25/02/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGListTreeItemStd.html:6827,Clear,ClearColor,6827,root/html602/TGListTreeItemStd.html,https://root.cern,https://root.cern/root/html602/TGListTreeItemStd.html,1,['Clear'],['ClearColor']
Usability,"t Layout manager for number entry widget; TGNumberFormat Class defining namespace for several enums used by TGNumberEntry; TGObject ROOT GUI base class; TGPack Horizontal or vertical stack of frames.; TGPasswdDialog Dialog for entering passwords; TGPicture Pictures and icons used by the GUI classes; TGPictureButton A picture button widget; TGPicturePool Picture and icon cache; TGPopupMenu Popup menu; TGPosition Position object (x and y are Int_t); TGPrintDialog Print dialog used by TGTextEdit widget; TGProgressBar Progress bar abstract base class; TGQt Interface to Qt GUI; TGRadioButton A radio button widget; TGRecorder GUI class of the event recorder.; TGRectMap Rectangle used in TMap; TGRectangle Rectangle object; TGRedirectOutputGuard Exception safe output redirection; TGRegion Describes a region; TGRegionWithId Region with id, tooltip text and popup menu; TGResourcePool Graphics resource pool; TGRowLayout Row layout manager; TGScrollBar Scrollbar widget; TGScrollBarElement Scrollbar element (head, tail, slider); TGSearchDialog Text search dialog used by TGTextEdit widget; TGSearchType ; TGSelectBox TreeView dialog widget; TGSelectedPicture Selected looking picture; TGShapedFrame Shaped composite frame; TGShutter Shutter widget; TGShutterItem Shutter widget item; TGSimpleTable A simple table that owns it's interface.; TGSimpleTableInterface Interface to data in a 2D array of Double_t; TGSlider Slider widget abstract base class; TGSpeedo Base class for analog meter widget; TGSplitButton a split button widget; TGSplitFrame Splittable composite frame; TGSplitTool Split frame tool utility; TGSplitter A frame splitter abstract base class; TGStatusBar Status bar widget; TGString Graphics string; TGTRA GTRA shape; TGTab Tab widget; TGTabElement Little tab on tab widget; TGTabLayout Layout manager for TGTab widget; TGTable A table used to visualize data from diffent sources.; TGTableCell A single cell in a TGTable.; TGTableFrame A frame used internally by TGTable.; TGTabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:78230,simpl,simple,78230,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,8,['simpl'],['simple']
Usability,"t NDim() const = 0;; 76 ; 77 /// Evaluate the function at a point x[].; 78 /// Use the pure virtual private method DoEval which must be implemented by the sub-classes.; 79 T operator()(const T *x) const { return DoEval(x); }; 80 ; 81#ifdef LATER; 82 /// Template method to evaluate the function using the begin of an iterator.; 83 /// User is responsible to provide correct size for the iterator.; 84 template <class Iterator>; 85 T operator()(const Iterator it) const { return DoEval(&(*it)); }; 86#endif; 87 ; 88 // Indicate whether this class supports gradient calculations, i.e.,; 89 // if it inherits from ROOT::Math::IGradientFunctionMultiDim.; 90 virtual bool HasGradient() const { return false; }; 91 ; 92 private:; 93 ; 94 /// Implementation of the evaluation function. Must be implemented by derived classes.; 95 virtual T DoEval(const T *x) const = 0;; 96 };; 97 ; 98 ; 99//___________________________________________________________________________________; 100 /**; 101 Interface (abstract class) for generic functions objects of one-dimension; 102 Provides a method to evaluate the function given a value (simple double); 103 by implementing operator() (const double ).; 104 In addition it defines the interface for copying functions via the pure virtual method Clone().; 105 Derived classes must implement the pure virtual private method DoEval(double ) for the; 106 function evaluation in addition to Clone().; 107 An interface for evaluating the function passing a vector (like for multidim functions) is also; 108 provided; 109 ; 110 @ingroup GenFunc; 111 */; 112 class IBaseFunctionOneDim {; 113 ; 114 public:; 115 ; 116 typedef IBaseFunctionOneDim BaseFunc;; 117 ; 118 virtual ~IBaseFunctionOneDim() = default;; 119 ; 120 /// Clone a function.; 121 /// Each derived class will implement their version of the private DoClone method.; 122 virtual IBaseFunctionOneDim *Clone() const = 0;; 123 ; 124 /// Evaluate the function at a point x.; 125 /// Use the a pure virtual private metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/IFunction_8h_source.html:3907,simpl,simple,3907,doc/master/IFunction_8h_source.html,https://root.cern,https://root.cern/doc/master/IFunction_8h_source.html,1,['simpl'],['simple']
Usability,"t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the branches in the cache. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). const TObjArray * GetCachedBranches() const; { return fBranches; }. Bool_t IsLearning() const; {return fIsLearning;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TTreeCache.h 41101 2011-10-03 16:23:48Z pcanal $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:23550,learn,learning,23550,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,2,['learn'],['learning']
Usability,"t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TCanvasThe Canvas class.Definition TCanvas.h:23; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TViewSee TView3D.Definition TView.h:25; TView::CreateViewstatic TView * CreateView(Int_t system=1, const Double_t *rmin=nullptr, const Double_t *rmax=nullptr)Create a concrete default 3-d view via the plug-in manager.Definition TView.cxx:27; TView::SetRangevirtual void SetRange(const Double_t *min, const Double_t *max)=0; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; lTLine lDefinition textangle.C:4. TPolyLine3D is a basic graphics primitive which ignores the fact the current pad has logarithmic scale(s). It simply draws the 3D line in the current user coordinates. If logarithmic scale is set along one of the three axis, the logarithm of vector coordinates along this axis should be use. Alternatively and higher level class, knowing about logarithmic scales, might be used. For instance TGraph2D with option L. ; Definition at line 32 of file TPolyLine3D.h. Public Member Functions;  TPolyLine3D ();  3-D polyline default constructor. ;  ;  TPolyLine3D (const TPolyLine3D &polylin);  3-D polyline copy ctor. ;  ;  TPolyLine3D (Int_t n, Double_t const *p, Option_t *option="""");  3-D polyline normal constructor. ;  ;  TPolyLine3D (Int_t n, Double_t const *x, Double_t const *y, Double_t const *z, Option_t *option="""");  3-D polyline normal constructor. ;  ;  TPolyLine3D (Int_t n, Float_t const *p, Option_t *option="""");  3-D polyline normal constructor. ;  ;  TPolyLine3D (Int_t n, Float_t const *x, Float_t const *y, Float_t const *z, Option_t *option="""");  3-D polyline normal constructor. ;  ;  TPolyLine3D (Int_t n, Option_t *op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPolyLine3D.html:2791,simpl,simply,2791,doc/master/classTPolyLine3D.html,https://root.cern,https://root.cern/doc/master/classTPolyLine3D.html,1,['simpl'],['simply']
Usability,"t RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:4046,clear,clearShapeDirty,4046,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,1,['clear'],['clearShapeDirty']
Usability,"t RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedPdf.html:3146,clear,clearShapeDirty,3146,root/html526/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedPdf.html,2,['clear'],['clearShapeDirty']
Usability,"t RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsAnaConvPdf::coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDecay.html:2550,clear,clearShapeDirty,2550,root/html526/RooDecay.html,https://root.cern,https://root.cern/root/html526/RooDecay.html,1,['clear'],['clearShapeDirty']
Usability,"t RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBCPEffDecay.html:2852,clear,clearShapeDirty,2852,root/html526/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html526/RooBCPEffDecay.html,4,['clear'],['clearShapeDirty']
Usability,"t RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::non",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBDecay.html:2750,clear,clearShapeDirty,2750,root/html526/RooBDecay.html,https://root.cern,https://root.cern/root/html526/RooBDecay.html,1,['clear'],['clearShapeDirty']
Usability,"t RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooArgusBG.html:2574,clear,clearShapeDirty,2574,root/html526/RooArgusBG.html,https://root.cern,https://root.cern/root/html526/RooArgusBG.html,49,['clear'],['clearShapeDirty']
Usability,"t RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsPdf.html:6466,Clear,Clear,6466,root/html602/RooAbsPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html,1,['Clear'],['Clear']
Usability,"t RooArgList& inCoefList, Bool_t extended); Constructor p.d.f implementing sum_i [ coef_i * func_i ], if N_coef==N_func; or sum_i [ coef_i * func_i ] + (1 - sum_i [ coef_i ] )* func_N if Ncoef==N_func-1. All coefficients and functions are allowed to be negative; but the sum is not, which is enforced at runtime. RooRealSumPdf(const RooRealSumPdf& other, const char* name); Copy constructor. ~RooRealSumPdf(); Destructor. RooAbsPdf::ExtendMode extendMode() const. Double_t evaluate() const; Calculate the current value. Bool_t checkObservables(const RooArgSet* nset) const; Check if FUNC is valid for given normalization set.; Coeffient and FUNC must be non-overlapping, but func-coefficient; pairs may overlap each other. In the present implementation, coefficients may not be observables or derive; from observables. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implement analytical integrations by deferring integration of component; functions to integrators of components. Double_t expectedEvents(const RooArgSet* nset). void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooRealSumPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; { return kTRUE ; }. const RooArgList& funcList() const; { return _funcList ; }. const RooArgList& coefList() const; { return _coefList ; }. Double_t expectedEvents(const RooArgSet* nset). » Last changed: Mon Dec 7 13:48:54 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealSumPdf.html:42103,intuit,intuitively,42103,root/html526/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html526/RooRealSumPdf.html,1,['intuit'],['intuitively']
Usability,"t RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:3814,clear,clearValueDirty,3814,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,6,['clear'],['clearValueDirty']
Usability,"t RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsReal.html:3750,clear,clearValueDirty,3750,root/html532/RooAbsReal.html,https://root.cern,https://root.cern/root/html532/RooAbsReal.html,1,['clear'],['clearValueDirty']
Usability,"t RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearAbsMin(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProfileLL.html:4022,clear,clearValueDirty,4022,root/html532/RooProfileLL.html,https://root.cern,https://root.cern/root/html532/RooProfileLL.html,2,['clear'],['clearValueDirty']
Usability,"t RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearAbsMin(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProfileLL.html:4181,clear,clearValueDirty,4181,root/html534/RooProfileLL.html,https://root.cern,https://root.cern/root/html534/RooProfileLL.html,6,['clear'],['clearValueDirty']
Usability,"t TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp); voidRooCacheManager<RooAbsCacheElement>::sterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Bool_t_clearOnRedirect; Int_tRooCacheManager<RooAbsCacheElement>::_lastIndexLast slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSizeMaximum size; RooNormSetCache*RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; RooAbsCacheElement**RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen; list<RooArgSet*>_optCacheObsList! list of all optCacheObservables owned; RooArgSet*_optCacheObservables! current optCacheObservables ; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooObjCacheManager.html:3617,clear,clearCacheOnServerRedirect,3617,root/html528/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html528/RooObjCacheManager.html,1,['clear'],['clearCacheOnServerRedirect']
Usability,"t TProfile3D::GetBinError(Int_t bin) const; 746{; 747 return TProfileHelper::GetBinError((TProfile3D*)this, bin);; 748}; 749 ; 750////////////////////////////////////////////////////////////////////////////////; 751/// Return option to compute profile2D errors.; 752 ; 753Option_t *TProfile3D::GetErrorOption() const; 754{; 755 if (fErrorMode == kERRORSPREAD) return ""s"";; 756 if (fErrorMode == kERRORSPREADI) return ""i"";; 757 if (fErrorMode == kERRORSPREADG) return ""g"";; 758 return """";; 759}; 760 ; 761////////////////////////////////////////////////////////////////////////////////; 762/// fill the array stats from the contents of this profile.; 763///; 764/// The array stats must be correctly dimensioned in the calling program.; 765///; 766/// - stats[0] = sumw; 767/// - stats[1] = sumw2; 768/// - stats[2] = sumwx; 769/// - stats[3] = sumwx2; 770/// - stats[4] = sumwy; 771/// - stats[5] = sumwy2; 772/// - stats[6] = sumwxy; 773/// - stats[7] = sumwz; 774/// - stats[8] = sumwz2; 775/// - stats[9] = sumwxz; 776/// - stats[10]= sumwyz; 777/// - stats[11]= sumwt; 778/// - stats[12]= sumwt2; 779///; 780/// If no axis-subrange is specified (via TAxis::SetRange), the array stats; 781/// is simply a copy of the statistics quantities computed at filling time.; 782/// If a sub-range is specified, the function recomputes these quantities; 783/// from the bin contents in the current axis range.; 784 ; 785void TProfile3D::GetStats(Double_t *stats) const; 786{; 787 if (fBuffer) ((TProfile3D*)this)->BufferEmpty();; 788 ; 789 // Loop on bins; 790 if ( (fTsumw == 0 /* && fEntries > 0 */) || fXaxis.TestBit(TAxis::kAxisRange) || fYaxis.TestBit(TAxis::kAxisRange)) {; 791 ; 792 // check for labels axis . In that case corresponding statistics do not make sense and it is set to zero; 793 Bool_t labelXaxis = ((const_cast<TAxis &>(fXaxis)).GetLabels() && fXaxis.CanExtend());; 794 Bool_t labelYaxis = ((const_cast<TAxis &>(fYaxis)).GetLabels() && fYaxis.CanExtend());; 795 Bool_t labelZaxis = ((co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:27267,simpl,simply,27267,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,1,['simpl'],['simply']
Usability,"t TString& fallback_tag = """"); Float_t*TAttBBox::AssertBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; static voidTEveShape::CheckAndFixBoxOrientationEv(TEveVector[8] box); static voidTEveShape::CheckAndFixBoxOrientationFv(Float_t[8][3] box); virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveShape::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveBox.html:2681,Clear,ClearProjectedList,2681,root/html602/TEveBox.html,https://root.cern,https://root.cern/root/html602/TEveBox.html,14,['Clear'],['ClearProjectedList']
Usability,"t TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); the standard constructor for just an ordinar ""decision trees"". MethodDT(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from Reader. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void DeclareOptions(); define the options (their key words) that can be set in the option string; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enouth such that overtraining is avoided"");. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void SetMinNodeSize(Double_t sizeInPercent). void SetMinNodeSize(TString sizeInPercent). void Init( void ); common initialisation with defaults for the DT-Method. ~MethodDT( void ); destructor. void Train( void ). Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodDT.html:23341,simpl,simply,23341,root/html602/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodDT.html,4,['simpl'],['simply']
Usability,"t a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation Reference Guide. The Reference Guide is available for all major ROOT releases, and for the current HEAD of the git master:. HEAD of the git master - browse; 6.20 - browse | download; 6.18 - browse | download; 6.16 - browse | download; 6.14 - browse | download; 6.12 - browse | download; 6.10 - browse | download; 6.08 - browse | download; 6.06 - browse | download; 6.04 - browse | download; 6.02 - browse | download; 5.34 - browse | download; 5.32 - browse | download; 5.30 - browse | download; 5.28 - browse | download; 5.26 - browse | download; 5.24 - browse | download. Additionally, the source code is accessible via:. Browsing the Git repository using gitweb; Github. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/guides/reference-guide.html:2775,guid,guidelines,2775,d/guides/reference-guide.html,https://root.cern,https://root.cern/d/guides/reference-guide.html,1,['guid'],['guidelines']
Usability,"t be unique and stable - i.e. the IDs of a published object is consistent, regardless of changes in termination of contained child geometry branches. In this case the viewer can safely cache the physical objects across scene rebuilds, discarding those no longer of interest.; 9.13.4.10 Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer is not interested in a certain object due to limits/size then it will also not be interest in any of the contained branch of siblings. Both TBuffer3D::AddObject() methods have an addChildren return parameter. The viewer will complete this (if passed) indicating if children of the object just sent are worth sending.; 9.13.4.11 Recycling TBuffer3D; Once add TBuffer3D::AddObject() has been called, the contents are copied to the viewer’s internal data structures. You are free to destroy this TBuffer3D, or recycle it for the next object if suitable.; 9.13.4.12 Examples; For an example of a simple geometry, working in master reference frame examine the code under $ROOTSYS/g3d. For a more complex example, which works in both master and local frames, and uses logical/physical division of shape geometry and placement, examine the code under $ROOTSYS/geom - in particular TGeoShape hierarchy, and the painter object TGeoPainter (under geopainter) where the negotiation with the viewer is performed.; 10 Folders and Tasks; 10.1 Folders. A TFolder is a collection of objects visible and expandable in the ROOT object browser. Folders have a name and a title and are identified in the folder hierarchy by an “UNIX-like” naming convention. The base of all folders is //root. It is visible at the top of the left panel in the browser. The browser shows several folders under //root.; New folders can be added and removed to/from a folder.; 10.2 Why Use Folders?; One reason to use folders is to reduce class dependencies and improve modularity. Each set of data has a producer class and one or many consumer classes. When ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:417934,simpl,simple,417934,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"t be used.; 4.3.1 What the user must supply; The user must supply to M. a valid implementation of the FCNBase base class; parameters with their starting values; expected uncertainties on the parameters. The input parameters can be simply defined via an std::vector\(<\)double\(>\), which means that all parameters are variables. If the user wants fix a parameter or put limits on it before minimization, they have to instantiate a MnUserParameters object and then add parameters one by one, giving them a name, value, uncertainty. Once all parameters are added to MnUserParameters, they can fix a parameter or put limits on another one before handing them over to Minuit for minimization.; 4.3.2 What the user can supply; Optionally the user can supply their own gradient calculator by implementing the FCNGradientBase interface or supply a full covariance matrix for input if one is available. The covariance matrix can be supplied in form of a std::vector\(<\)double\(>\) in packed storage format (upper triangular), or in a more user-friendly way by using the interface provided by the MnUserCovariance.; 4.4 Running a M minimization; Two use cases are addressed for minimization:. The user just wants the function to be minimized in one go.; The user wants to minimize the \(\mbox{FCN}\) in several minimization steps, re-using the result of the preceeding minimization in the next step and change parameters in between (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main].; 4.4.1 Direct usage of minimizers; Minimizers such as the VariableMetricMinimizer are designed as state-less minimization engines, which means that they do not depend on the current function and its parameters. Any \(\mbox{FCN}\) function can be minimized with the same minimizer. The interface is restricted to minimization and no parameter interaction is possible.; 4.4.2 Using an application (MnMigrad); MnMigrad uses the VariableMetricMinimizer for minimization but a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:34603,user-friendly,user-friendly,34603,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,2,['user-friendly'],['user-friendly']
Usability,"t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayF::Adopt(Int_t n, Float_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Float_tTArrayF::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH1::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; virtual TH1*TH1::DrawNorm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1F.html:1797,Clear,ClearUnderflowAndOverflow,1797,root/html602/TH1F.html,https://root.cern,https://root.cern/root/html602/TH1F.html,2,['Clear'],['ClearUnderflowAndOverflow']
Usability,"t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayF::Adopt(Int_t n, Float_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Float_tTArrayF::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH1::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& obj) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; virtual TH1*TH1::DrawNorma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1K.html:2280,Clear,ClearUnderflowAndOverflow,2280,root/html602/TH1K.html,https://root.cern,https://root.cern/root/html602/TH1K.html,2,['Clear'],['ClearUnderflowAndOverflow']
Usability,"t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayF::Adopt(Int_t n, Float_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Float_tTArrayF::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH2::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; virtual TH1*TH1::DrawNorm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2F.html:1778,Clear,ClearUnderflowAndOverflow,1778,root/html602/TH2F.html,https://root.cern,https://root.cern/root/html602/TH2F.html,2,['Clear'],['ClearUnderflowAndOverflow']
Usability,"t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayF::Adopt(Int_t n, Float_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Float_tTArrayF::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH3::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; virtual TH1*TH1::DrawNorm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH3F.html:1778,Clear,ClearUnderflowAndOverflow,1778,root/html602/TH3F.html,https://root.cern,https://root.cern/root/html602/TH3F.html,2,['Clear'],['ClearUnderflowAndOverflow']
Usability,"t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayS::Adopt(Int_t n, Short_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Short_tTArrayS::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH1::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; virtual TH1*TH1::DrawNorm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1S.html:1798,Clear,ClearUnderflowAndOverflow,1798,root/html602/TH1S.html,https://root.cern,https://root.cern/root/html602/TH1S.html,2,['Clear'],['ClearUnderflowAndOverflow']
Usability,"t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayS::Adopt(Int_t n, Short_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Short_tTArrayS::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH2::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; virtual TH1*TH1::DrawNorm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2S.html:1785,Clear,ClearUnderflowAndOverflow,1785,root/html602/TH2S.html,https://root.cern,https://root.cern/root/html602/TH2S.html,2,['Clear'],['ClearUnderflowAndOverflow']
Usability,"t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayS::Adopt(Int_t n, Short_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Short_tTArrayS::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH3::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; virtual TH1*TH1::DrawNorm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH3S.html:1785,Clear,ClearUnderflowAndOverflow,1785,root/html602/TH3S.html,https://root.cern,https://root.cern/root/html602/TH3S.html,2,['Clear'],['ClearUnderflowAndOverflow']
Usability,"t bufsize = 32000); TBranch*TTree::Branch(const char* name, Long_t address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, int address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, const char* classname, void** obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser* b); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNtuple.html:2949,Clear,Clear,2949,root/html534/TNtuple.html,https://root.cern,https://root.cern/root/html534/TNtuple.html,1,['Clear'],['Clear']
Usability,"t bufsize = 32000); TBranch*TTree::Branch(const char* name, Long_t address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, int address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, const char* classname, void** obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser* b); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* vare",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNtupleD.html:2960,Clear,Clear,2960,root/html534/TNtupleD.html,https://root.cern,https://root.cern/root/html534/TNtupleD.html,1,['Clear'],['Clear']
Usability,"t called Boolean node. A composite shape has a pointer to such a Boolean node. Since the shape components may also be composites, they will also contain binary Boolean nodes branching out other two shapes in the hierarchy. Any such branch ends-up when the final leaves are no longer composite shapes, but basic primitives. The figure shows the composite shapes structure. The composite shapes structure. Suppose that A, B, C and D represent basic shapes, we will illustrate how the internal representation of few combinations look like. We do this only for understanding how to create them in a proper way, since the user interface for this purpose is in fact very simple. We will ignore for the time being the positioning of components. The definition of a composite shape takes an expression where the identifiers are shape names. The expression is parsed and decomposed in 2 sub-expressions and the top-level Boolean operator. Union: A+B+C. Just to illustrate the Boolean expression parsing and the composite shape structure, let’s take a simple example. We will describe the union of A, B and C. Both union operators are at the same level. Since:; A+B+C = (A+B)+C = A+(B+C); The first(+) is taken as separator, hence the expression split in: A and (B+C). A Boolean node of type TGeoUnion(""A"",""B+C"") is created. This tries to replace the 2 expressions by actual pointers to corresponding shapes. The first expression (A) contains no operators therefore is interpreted as representing a shape. The shape named “A” is searched into the list of shapes handled by the manager class and stored as the “left” shape in the Boolean union node. Since the second expression is not yet fully decomposed, the “right” shape in the combination is created as a new composite shape. This will split at its turn B+C into B and C and create a TGeoUnion(""B"",""C""). The B and C identifiers will be looked for and replaced by the pointers to the actual shapes into the new node. Finally, the composite “A+B+C” will be r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:916566,simpl,simple,916566,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"t called Boolean node. A composite shape has a pointer to such a Boolean node. Since the shape components may also be composites, they will also contain binary Boolean nodes branching out other two shapes in the hierarchy. Any such branch ends-up when the final leaves are no longer composite shapes, but basic primitives. The figure shows the composite shapes structure. The composite shapes structure; Suppose that A, B, C and D represent basic shapes, we will illustrate how the internal representation of few combinations look like. We do this only for understanding how to create them in a proper way, since the user interface for this purpose is in fact very simple. We will ignore for the time being the positioning of components. The definition of a composite shape takes an expression where the identifiers are shape names. The expression is parsed and decomposed in 2 sub-expressions and the top-level Boolean operator. Union: A+B+C. Just to illustrate the Boolean expression parsing and the composite shape structure, let's take a simple example. We will describe the union of A, B and C. Both union operators are at the same level. Since:; A+B+C = (A+B)+C = A+(B+C); The first(+) is taken as separator, hence the expression split in: A and (B+C). A Boolean node of type **TGeoUnion**(""A"",""B+C"") is created. This tries to replace the 2 expressions by actual pointers to corresponding shapes. The first expression (A) contains no operators therefore is interpreted as representing a shape. The shape named ""A"" is searched into the list of shapes handled by the manager class and stored as the ""left"" shape in the Boolean union node. Since the second expression is not yet fully decomposed, the ""right"" shape in the combination is created as a new composite shape. This will split at its turn B+C into B and C and create a **TGeoUnion**(""B"",""C""). The B and C identifiers will be looked for and replaced by the pointers to the actual shapes into the new node. Finally, the composite ""`A+B+C`""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCompositeShape.html:2756,simpl,simple,2756,doc/master/classTGeoCompositeShape.html,https://root.cern,https://root.cern/doc/master/classTGeoCompositeShape.html,1,['simpl'],['simple']
Usability,"t char * RooObjCacheManager::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooObjCacheManager::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 62 of file RooObjCacheManager.h. ◆ clearObsList(). static bool RooObjCacheManager::clearObsList ; (; ). inlinestatic . Definition at line 48 of file RooObjCacheManager.h. ◆ DeclFileName(). static const char * RooObjCacheManager::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 62 of file RooObjCacheManager.h. ◆ doClearObsList(). static void RooObjCacheManager::doClearObsList ; (; bool ; flag). inlinestatic . Definition at line 47 of file RooObjCacheManager.h. ◆ findConstantNodes(). void RooObjCacheManager::findConstantNodes ; (; const RooArgSet & ; obs, . RooArgSet & ; cacheList, . RooLinkedList & ; processedNodes . ). overridevirtual . If clearOnRedirect is false, forward constant term optimization calls to cache elements. ; Reimplemented from RooAbsCache.; Definition at line 209 of file RooObjCacheManager.cxx. ◆ insertObjectHook(). void RooObjCacheManager::insertObjectHook ; (; RooAbsCacheElement & ; obj). overridevirtual . Set owner link on all object inserted into cache. ; Also if cache mode optimization was requested, apply it now to cache element being inserted ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 175 of file RooObjCacheManager.cxx. ◆ IsA(). TClass * RooObjCacheManager::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 62 of file RooObjCacheManager.h. ◆ operModeHook(). void RooObjCacheManager::operModeHook ; (; ). overridevirtual . Intercept changes to cache operation mode and forward to cache elements. ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 108 of file RooObjCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:9075,clear,clearOnRedirect,9075,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['clear'],['clearOnRedirect']
Usability,"t char * getPlotLabel() constGet the label associated with the variable.Definition RooAbsReal.cxx:406; RooAbsReal::createRunningIntegralRooFit::OwningPtr< RooAbsReal > createRunningIntegral(const RooArgSet &iset, const RooArgSet &nset={})Calls createRunningIntegral(const RooArgSet&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&,...Definition RooAbsReal.cxx:3706; RooAbsReal::_specIntegratorConfigstd::unique_ptr< RooNumIntConfig > _specIntegratorConfigDefinition RooAbsReal.h:540; RooAbsReal::getAnalyticalIntegralvirtual Int_t getAnalyticalIntegral(RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) constInterface function getAnalyticalIntergral advertises the analytical integrals that are supported.Definition RooAbsReal.cxx:368; RooAbsReal::evalErrorIterstatic std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter()Definition RooAbsReal.cxx:181; RooAbsReal::numEvalErrorsstatic Int_t numEvalErrors()Return the number of logged evaluation errors since the last clearing.Definition RooAbsReal.cxx:3624; RooAbsReal::setEvalErrorLoggingModestatic void setEvalErrorLoggingMode(ErrorLoggingMode m)Set evaluation error logging mode.Definition RooAbsReal.cxx:4316; RooAbsReal::preferredObservableScanOrdervirtual void preferredObservableScanOrder(const RooArgSet &obs, RooArgSet &orderedObs) constInterface method for function objects to indicate their preferred order of observables for scanning t...Definition RooAbsReal.cxx:3694; RooAbsReal::maxValvirtual double maxVal(Int_t code) constReturn maximum value for set of observables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::findInnerMostIntegrationvoid findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constUtility function for createIntObj() that aids in the construct of recursive integrals over functions ...Definition RooAbsReal.cxx:701; RooAbsReal::integralNameSuffi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:229443,clear,clearing,229443,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['clear'],['clearing']
Usability,"t char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static bool getFloorGlobal ();  ; static void setFloorGlobal (bool flag);  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static EvalErrorIter evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last cle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumFunc.html:46595,clear,clearEvalErrorLog,46595,doc/v632/classRooRealSumFunc.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumFunc.html,1,['clear'],['clearEvalErrorLog']
Usability,"t char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static bool getFloorGlobal ();  ; static void setFloorGlobal (bool flag);  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealSumFunc.html:45401,clear,clearEvalErrorLog,45401,doc/master/classRooRealSumFunc.html,https://root.cern,https://root.cern/doc/master/classRooRealSumFunc.html,1,['clear'],['clearEvalErrorLog']
Usability,"t char *slot)`; 3121 ; 3122 c1->HighlightConnect(""UserFunction(TVirtualPad*,TObject*,Int_t,Int_t)"");; 3123 ; 3124NOTE the signal and slot string must have a form; 3125""(TVirtualPad*,TObject*,Int_t,Int_t)""; 3126 ; 3127 root [0] .x $ROOTSYS/tutorials/hsimple.C; 3128 root [1] hpx->SetHighlight(kTRUE); 3129 root [2] .x hlprint.C; 3130 ; 3131file `hlprint.C`; 3132~~~ {.cpp}; 3133void PrintInfo(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y); 3134{; 3135 auto h = (TH1F *)obj;; 3136 if (!h->IsHighlight()) // after highlight disabled; 3137 h->SetTitle(""highlight disable"");; 3138 else; 3139 h->SetTitle(TString::Format(""bin[%03d] (%5.2f) content %g"", x,; 3140 h->GetBinCenter(x), h->GetBinContent(x)));; 3141 pad->Update();; 3142}; 3143 ; 3144void hlprint(); 3145{; 3146 if (!gPad) return;; 3147 gPad->GetCanvas()->HighlightConnect(""PrintInfo(TVirtualPad*,TObject*,Int_t,Int_t)"");; 3148}; 3149~~~; 3150 ; 3151\image html hlsimple.gif ""Highlight mode and simple user function""; 3152 ; 3153For more complex demo please see for example `$ROOTSYS/tutorials/tree/temperature.C` file.; 3154 ; 3155*/; 3156 ; 3157TH1 *gCurrentHist = nullptr;; 3158 ; 3159Hoption_t Hoption;; 3160Hparam_t Hparam;; 3161 ; 3162const Int_t kNMAX = 2000;; 3163 ; 3164const Int_t kMAXCONTOUR = 104;; 3165const UInt_t kCannotRotate = BIT(11);; 3166 ; 3167static std::unique_ptr<TBox> gXHighlightBox, gYHighlightBox; // highlight X and Y box; 3168 ; 3169static TString gStringEntries;; 3170static TString gStringMean;; 3171static TString gStringMeanX;; 3172static TString gStringMeanY;; 3173static TString gStringMeanZ;; 3174static TString gStringStdDev;; 3175static TString gStringStdDevX;; 3176static TString gStringStdDevY;; 3177static TString gStringStdDevZ;; 3178static TString gStringUnderflow;; 3179static TString gStringOverflow;; 3180static TString gStringIntegral;; 3181static TString gStringIntegralBinWidth;; 3182static TString gStringSkewness;; 3183static TString gStringSkewnessX;; 3184static TString gStringSkewnessY;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:124641,simpl,simple,124641,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['simpl'],['simple']
Usability,"t char* bgrSource, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); TH1*GetDeltaSysSource(const char* source, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); TH1*GetDeltaSysTau(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2*GetEmatrixInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); voidTUnfoldSys::GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); TH2*GetEmatrixSysBackgroundUncorr(const char* bgrSource, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); voidTUnfoldSys::GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidTUnfoldSys::GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); TH2*GetEmatrixSysUncorr(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); TH2*GetEmatrixTotal(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); Double_tTUnfold::GetEpsMatrix() const; TH1*GetFoldedOutput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldDensity.html:8344,clear,clearEmat,8344,root/html534/TUnfoldDensity.html,https://root.cern,https://root.cern/root/html534/TUnfoldDensity.html,6,['clear'],['clearEmat']
Usability,"t char* classname, void** obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*BranchRef(); virtual TBranch*Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser*); virtual Int_tBuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tCopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*CreateBasket(TBranch*); Int_tDebug() const; virtual voidDelete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:13973,undo,undo,13973,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,5,['undo'],['undo']
Usability,"t char* method) const; virtual voidTH1::Add(const TH1* h1, Double_t c1 = 1); virtual voidTH1::Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual voidTH1::Add(const TH1* h, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; voidTArrayI::AddAt(Int_t c, Int_t i); virtual voidAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayI::Adopt(Int_t n, Int_t* array); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTArrayI::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH1::BufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH1I.html:1735,Clear,Clear,1735,root/html532/TH1I.html,https://root.cern,https://root.cern/root/html532/TH1I.html,1,['Clear'],['Clear']
Usability,"t char* method) const; virtual voidTH1::Add(const TH1* h1, Double_t c1 = 1); virtual voidTH1::Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual voidTH1::Add(const TH1* h, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; voidTArrayI::AddAt(Int_t c, Int_t i); virtual voidAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayI::Adopt(Int_t n, Int_t* array); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTArrayI::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH2::BufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH2I.html:2084,Clear,Clear,2084,root/html532/TH2I.html,https://root.cern,https://root.cern/root/html532/TH2I.html,1,['Clear'],['Clear']
Usability,"t char* method) const; virtual voidTH1::Add(const TH1* h1, Double_t c1 = 1); virtual voidTH1::Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual voidTH1::Add(const TH1* h, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; voidTArrayI::AddAt(Int_t c, Int_t i); virtual voidAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayI::Adopt(Int_t n, Int_t* array); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTArrayI::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH3::BufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH3I.html:1954,Clear,Clear,1954,root/html532/TH3I.html,https://root.cern,https://root.cern/root/html532/TH3I.html,1,['Clear'],['Clear']
Usability,"t char* methodName = 0); virtual~TF2(); voidTObject::AbstractMethod(const char* method) const; static voidTF1::AbsValue(Bool_t reject = kTRUE); virtual voidTFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tTFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTF1::Browse(TBrowser* b); static voidTF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t* x, Double_t* w, Double_t eps = 3.0e-11); virtual Double_tTF1::CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); virtual Double_tCentralMoment2(Double_t nx, Double_t ax, Double_t bx, Double_t ny, Double_t ay, Double_t by, Double_t epsilon = 0.000001); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tTFormula::Compile(const char* expression = """"); virtual voidCopy(TObject& f2) const; virtual Double_tCovariance2XY(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t epsilon = 0.000001); virtual TH1*CreateHistogram(); virtual char*TFormula::DefinedString(Int_t code); virtual Double_tTFormula::DefinedValue(Int_t code); virtual Int_tTFormula::DefinedVariable(TString& variable, Int_t& action); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTF1::Derivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tTF1::Derivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tTF1::Derivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; static Double_tTF1::DerivativeError(); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TF2.html:2102,Clear,Clear,2102,root/html532/TF2.html,https://root.cern,https://root.cern/root/html532/TF2.html,2,['Clear'],['Clear']
Usability,"t char* name, Long_t address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, int address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, const char* classname, void** obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual voidCanDeleteRefs(Bool_t flag = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); virtual voidCreatePackets(); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TChain.html:3377,Clear,Clear,3377,root/html534/TChain.html,https://root.cern,https://root.cern/root/html534/TChain.html,1,['Clear'],['Clear']
Usability,"t char* par, Long_t value); Set an input list parameter. void SetParameter(const char* par, Long64_t value); Set an input list parameter. void SetParameter(const char* par, Double_t value); Set an input list parameter. TObject * GetParameter(const char* par) const; Get specified parameter. A parameter set via SetParameter() is either; a TParameter or a TNamed or 0 in case par is not defined. void DeleteParameters(const char* wildcard); Delete the input list parameters specified by a wildcard (e.g. PROOF_*); or exact name (e.g. PROOF_MaxSlavesPerNode). void ShowParameters(const char* wildcard = ""PROOF_*"") const; Show the input list parameters specified by the wildcard.; Default is the special PROOF control parameters (PROOF_*). void AddFeedback(const char* name); Add object to feedback list. void RemoveFeedback(const char* name); Remove object from feedback list. void ClearFeedback(); Clear feedback list. void ShowFeedback() const; Show items in feedback list. TList * GetFeedbackList() const; Return feedback list. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. TDrawFeedback * CreateDrawFeedback(); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. TList * GetOutputNames(); FIXME: to be written. void Browse(TBrowser* b); Build the PROOF's structure in the browser. void SetPlayer(TVirtualProofPlayer* player); Set a new PROOF player. TVirtualProofPlayer * MakePlayer(const char* player = 0, TSocket* s = 0); Construct a TProofPlayer object. The player string specifies which; player should be created: remote, slave, sm (supermaster) or base.; Default is remote. Socket is needed in case a slave player is created. void AddChain(TChain* chain); Add chain to data set. void RemoveChain(TChain* chain); Remove ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:74798,feedback,feedback,74798,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,10,['feedback'],['feedback']
Usability,"t char* stateNameList); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearRange(const char* name, Bool_t silent); voidRooAbsArg::clearShapeDirty() const; voidclearTypes(); voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; Bool_tdefineType(const char* label); Bool_tdefineType(const char* label, Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCategory.html:2126,clear,clearValueDirty,2126,root/html528/RooCategory.html,https://root.cern,https://root.cern/root/html528/RooCategory.html,2,['clear'],['clearValueDirty']
Usability,"t editor global. ; Reimplemented from TVirtualPadEditor.; Definition at line 267 of file TGedEditor.cxx. ◆ SetModel(). void TGedEditor::SetModel ; (; TVirtualPad * ; pad, . TObject * ; obj, . Int_t ; event, . Bool_t ; force = kFALSE . ). virtual . Activate object editors according to the selected object. ; Reimplemented in TEveGedEditor.; Definition at line 345 of file TGedEditor.cxx. ◆ Show(). void TGedEditor::Show ; (; ). overridevirtual . Show editor. ; Reimplemented from TVirtualPadEditor.; Definition at line 420 of file TGedEditor.cxx. ◆ Streamer(). void TGedEditor::Streamer ; (; TBuffer & ; ). overridevirtual . Reimplemented from TVirtualPadEditor. ◆ StreamerNVirtual(). void TGedEditor::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 98 of file TGedEditor.h. ◆ Update(). void TGedEditor::Update ; (; TGedFrame * ; frame = nullptr). virtual . Virtual method that is called on any change in the dependent frames. ; This implementation simply calls fPad Modified()/Update(). ; Reimplemented in TEveGedEditor.; Definition at line 173 of file TGedEditor.cxx. Member Data Documentation. ◆ fCan. TGCanvas* TGedEditor::fCan. protected . provides scroll bars ; Definition at line 41 of file TGedEditor.h. ◆ fCanvas. TCanvas* TGedEditor::fCanvas. protected . canvas related to the editor ; Definition at line 50 of file TGedEditor.h. ◆ fClass. TClass* TGedEditor::fClass. protected . class of the selected object ; Definition at line 51 of file TGedEditor.h. ◆ fCreatedTabs. TList TGedEditor::fCreatedTabs. protected . list of created tabs ; Definition at line 44 of file TGedEditor.h. ◆ fExclMap. TMap TGedEditor::fExclMap. protected . map of excluded editors for selected model ; Definition at line 38 of file TGedEditor.h. ◆ fFrameMap. TMap TGedEditor::fFrameMap. protected . global map of available frames ; Definition at line 37 of file TGedEditor.h. ◆ fGedFrames. TList TGedEditor::fGedFrames. protected . list visible of frames ; Definition at ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGedEditor.html:48040,simpl,simply,48040,doc/master/classTGedEditor.html,https://root.cern,https://root.cern/doc/master/classTGedEditor.html,1,['simpl'],['simply']
Usability,"t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddOutput (TList *out) override;  Incorporate output list (may not be used in this class). ;  ; Int_t AddOutputObject (TObject *obj) override;  Incorporate output object (may not be used in this class). ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; Long64_t DrawSelect (TDSet *set, const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Draw (may not be used in this class). ;  ; void Feedback (TList *objs) override;  Set feedback list (may not be used in this class). ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize query (may not be used in this class). ;  ; Long64_t Finalize (TQueryResult *qr) override;  Finalize query (may not be used in this class). ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TDSetElement * GetNextPacket (TSlave *slave, TMessage *r) override;  Get next packet (may",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:3282,feedback,feedback,3282,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,3,['feedback'],['feedback']
Usability,"t example ;  polytest1.C This macro is testing the ""compacting"" algorithm in TPadPainter ;  polytest2.C This macro is testing the ""compacting"" algorithm in TPadPainter ;  pstable.C Display all possible types of ROOT/Postscript characters ;  psview.C An example how to display PS, EPS, PDF files in canvas ;  quarks.C Example illustrating divided pads and Latex ;  tmathtext.CThis macro draws various formula in a canvas ;  tmathtext2.C This macro draw all possible symbols provided by TMathtext ;  tornado.C Show 3-d polymarker ;  transparency.C This macro demonstrates the use of color transparency ;  triangles.C Generate small triangles randomly in the canvas ;  ► graphs;  approx.C Macro to test interpolation function Approx ;  bent.C Bent error bars ;  exclusiongraph.C Draw three graphs with an exclusion zone ;  exclusiongraph2.C Draw several graphs with an exclusion zones ;  gerrors.C Draw a graph with error bars ;  gerrors2.C Draw two graphs with error bars ;  graph.C Draw a simple graph ;  graph2derrorsfit.C Draw and fit a TGraph2DErrors ;  graphApply.C A macro to demonstrate the functionality of TGraph::Apply() method ;  graphpolar.C Create and draw a polar graph ;  graphpolar2.C Create and draw a polar graph with PI axis ;  graphpolar3.C Create and draw a polar graph with PI axis using a TF1 ;  graphShade.C Show how to shade an area between two graphs ;  graphstruct.C Draw a simple graph structure ;  graphtext.C Draw a graph with text attached to each point ;  gtime.C Example of TGraphTime ;  gtime2.C Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program ;  labels1.C Setting alphanumeric labels in a 1-d histogram ;  labels2.C Setting alphanumeric labels ;  motorcycle.C Macro to test scatterplot smoothers: ksmooth, lowess, supsmu as described in: ;  multigraph.C Create and Draw a TMultiGraph ;  multipalette.C Draw color plots using different color palettes ;  seism.C Strip chart exampl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:115872,simpl,simple,115872,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['simpl'],['simple']
Usability,"t extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. Function Members (Methods); public:. ~THnT<long long>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnT_Long64_t_.html:2026,Clear,Clear,2026,root/html534/THnT_Long64_t_.html,https://root.cern,https://root.cern/root/html534/THnT_Long64_t_.html,1,['Clear'],['Clear']
Usability,"t file. When providing these; in a script, HistFactory doesn't load the histogram from the file; right away. Instead, once all such histograms have been supplied,; one should run this method to open all ROOT files and to copy and; save all necessary histograms. Measurement(); Measurement( const Measurement& other ); // Copy. Measurement(const char* Name, const char* Title = """"). void SetOutputFilePrefix(const string& prefix); set output prefix. { fOutputFilePrefix = prefix; }. std::string GetOutputFilePrefix(); retrieve prefix for output files. { return fOutputFilePrefix; }. void SetPOI(const string& POI); insert PoI at beginning of vector of PoIs. { fPOI.insert( fPOI.begin(), POI ); }. void AddPOI(const string& POI); append parameter to vector of PoIs. { fPOI.push_back(POI); }. std::string GetPOI(unsigned int i = 0); get name of PoI at given index. { return fPOI.at(i); }. std::vector<std::string>& GetPOIList(); get vector of PoI names. { return fPOI; }. void ClearConstantParams(); empty vector of constant parameters. { fConstantParams.clear(); }. std::vector< std::string >& GetConstantParams(); get vector of all constant parameters. { return fConstantParams; }. std::map<std::string, double>& GetParamValues(); get map: parameter name <--> parameter value. { return fParamValues; }. void ClearParamValues(); clear map of parameter values. { fParamValues.clear(); }. void AddFunctionObject(const RooStats::HistFactory::PreprocessFunction function); add a preprocess function object. { fFunctionObjects.push_back( function ); }. void SetFunctionObjects(vector<RooStats::HistFactory::PreprocessFunction> objects); get vector of defined function objects. { fFunctionObjects = objects; }. std::vector< RooStats::HistFactory::PreprocessFunction >& GetFunctionObjects(); { return fFunctionObjects; }. std::vector< RooStats::HistFactory::Asimov >& GetAsimovDatasets(); get vector of defined Asimov Datasets. { return fAsimovDatasets; }. void AddAsimovDataset(RooStats::HistFactory::Asimov d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__Measurement.html:12487,Clear,ClearConstantParams,12487,root/html602/RooStats__HistFactory__Measurement.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__Measurement.html,2,['Clear'],['ClearConstantParams']
Usability,"t for clang that verifies that each implicitly build module is a system module.Definition rootcling_impl.cxx:3569; CheckModuleBuildClient::CheckModuleBuildClientCheckModuleBuildClient(clang::DiagnosticConsumer *Child, bool OwnsChild, clang::ModuleMap &Map)Definition rootcling_impl.cxx:3575; CheckModuleBuildClient::fChildclang::DiagnosticConsumer * fChildDefinition rootcling_impl.cxx:3570; CheckModuleBuildClient::~CheckModuleBuildClient~CheckModuleBuildClient()Definition rootcling_impl.cxx:3580; CheckModuleBuildClient::BeginSourceFilevirtual void BeginSourceFile(const clang::LangOptions &LangOpts, const clang::Preprocessor *PP) overrideDefinition rootcling_impl.cxx:3654; CheckModuleBuildClient::finishvirtual void finish() overrideDefinition rootcling_impl.cxx:3666; CheckModuleBuildClient::HandleDiagnosticvirtual void HandleDiagnostic(clang::DiagnosticsEngine::Level DiagLevel, const clang::Diagnostic &Info) overrideDefinition rootcling_impl.cxx:3586; CheckModuleBuildClient::clearvirtual void clear() overrideDefinition rootcling_impl.cxx:3648; CheckModuleBuildClient::IncludeInDiagnosticCountsvirtual bool IncludeInDiagnosticCounts() const overrideDefinition rootcling_impl.cxx:3672; CheckModuleBuildClient::fMapclang::ModuleMap & fMapDefinition rootcling_impl.cxx:3572; CheckModuleBuildClient::EndSourceFilevirtual void EndSourceFile() overrideDefinition rootcling_impl.cxx:3660; CheckModuleBuildClient::fOwnsChildbool fOwnsChildDefinition rootcling_impl.cxx:3571; ClassSelectionRuleDefinition ClassSelectionRule.h:34; ClassSelectionRule::GetFieldSelectionRulesconst std::list< VariableSelectionRule > & GetFieldSelectionRules() constDefinition ClassSelectionRule.cxx:32; LinkdefReaderDefinition LinkdefReader.h:41; LinkdefReader::LoadIncludesbool LoadIncludes(std::string &extraInclude)Definition LinkdefReader.cxx:511; LinkdefReader::Parsebool Parse(SelectionRules &sr, llvm::StringRef code, const std::vector< std::string > &parserArgs, const char *llvmdir)Definition LinkdefReader.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:252816,clear,clearvirtual,252816,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,2,['clear'],"['clear', 'clearvirtual']"
Usability,"t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of conditional product terms. void fixRefRange(const char* rangeName). std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooProdPdf with cache-and-track, _and_ label all RooProdPdf; descendants with extra informationa about (conditional) normalization, needed to be able; to Cache-And-Track them outside the RooprodPdf context. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProdPdf to more intuitively reflect the contents of the; product operator construction. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Implement support for node removal. TObject* clone(const char* newname) const; { return new RooProdPdf(*this,newname) ; }. Bool_t selfNormalized() const; { return _selfNorm ; }. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; { return _pdfList ; }. void setSelfNormalized(Bool_t flag); { _selfNorm = flag ; }. void setDefNormSet(const RooArgSet& nset); { _defNormSet.removeAll() ; _defNormSet.addClone(nset) ; }. CacheMode canNodeBeCached() const; { return RooAbsArg::NotAdvised ; }. void useDefaultGen(Bool_t flag = kTRUE); { _useDefaultGen = flag ; }. » Last changed: Tue Jun 30 14:35:01 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProdPdf.html:61060,intuit,intuitively,61060,root/html602/RooProdPdf.html,https://root.cern,https://root.cern/root/html602/RooProdPdf.html,2,['intuit'],['intuitively']
Usability,"t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of conditional product terms. void fixRefRange(const char* rangeName). std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooProdPdf with cache-and-track, _and_ label all RooProdPdf; descendants with extra informationa about (conditional) normalization, needed to be able; to Cache-And-Track them outside the RooprodPdf context. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProdPdf to more intuitively reflect the contents of the; product operator construction. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Implement support for node removal. TObject* clone(const char* newname) const; { return new RooProdPdf(*this,newname) ; }. Bool_t selfNormalized() const; { return _selfNorm ; }. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; { return _pdfList ; }. void setSelfNormalized(Bool_t flag); { _selfNorm = flag ; }. void setDefNormSet(const RooArgSet& nset); { _defNormSet.removeAll() ; _defNormSet.addClone(nset) ; }. CacheMode canNodeBeCached() const; { return RooAbsArg::NotAdvised ; }. void useDefaultGen(Bool_t flag = kTRUE); { _useDefaultGen = flag ; }. » Last changed: Tue Mar 10 17:18:32 2015 » Last generated: 2015-03-10 17:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:59405,intuit,intuitively,59405,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,2,['intuit'],['intuitively']
Usability,"t in a conflict during the application of a particular change from the remote branch. Follow the on-screen instructions to resolve problems. This will usually consist of doing a git status to list conflicts, editing the files and using git add to mark each conflict resolved. The process must either be allowed to continue by issuing a git rebase --continue or git merge --continue command, or the operation can be reverted with --abort instead of --continue. If in doubt, copy your repository.; Making a new remote branch. Create a new local branch based on an existing one:; git checkout -b <branch>. Do stuff.; Push the branch to the remote:; git push <remote> <local-branch-name>[:<new-remote-branch-name>]. Tagging. Tag the current state of a branch (eg for release):; git tag -am <message> <version>. Note that the -a creates an annotated tag, which is itself a commit with a hash and a commit message. This is the closest analogue to the CVS tag command. Omitting the -a option will create a, ""simple tag"" which is actually a branch. In general, you will probably prefer annotated tags with version-branches created explicitly as desired.; Push the tag to the remote:; git push --tags. Special notes on mis-tagging.; There are several things that can go wrong with tagging:. One can omit an intended -a option;; One can misspell the tag; or; One can omit or (horror!) fix a file and wish to update the tag. If you have not pushed tags yet (See above) then the fix is trivial: for the first two cases, remove the erroneous tag with git tag -d <tag>; for the third, re-tag with git tag -am <mesasge> [<tree-ish>]. However, if you have already pushed tags, there are wider consequences. For this reason, altering pushed tags is emphatically discouraged: create a new tag. However, since you're going to ignore me and do it anyway, here's how to do what you want without getting into too much of a mess:. To remove an erroneous tag, someone with the manager rôle on the project must log into cdcvsd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:13753,simpl,simple,13753,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['simpl'],['simple']
Usability,"t in cache elements can get very complicated, especially if there are (cyclical) reference back to the owning object ; Definition at line 47 of file RooObjCacheManager.cxx. ◆ RooObjCacheManager() [2/2]. RooObjCacheManager::RooObjCacheManager ; (; const RooObjCacheManager & ; other, . RooAbsArg * ; owner = nullptr . ). Copy constructor. ; Definition at line 59 of file RooObjCacheManager.cxx. ◆ ~RooObjCacheManager(). RooObjCacheManager::~RooObjCacheManager ; (; ). override . Destructor. ; Definition at line 71 of file RooObjCacheManager.cxx. Member Function Documentation. ◆ Class(). static TClass * RooObjCacheManager::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooObjCacheManager::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooObjCacheManager::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 62 of file RooObjCacheManager.h. ◆ clearObsList(). static bool RooObjCacheManager::clearObsList ; (; ). inlinestatic . Definition at line 48 of file RooObjCacheManager.h. ◆ DeclFileName(). static const char * RooObjCacheManager::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 62 of file RooObjCacheManager.h. ◆ doClearObsList(). static void RooObjCacheManager::doClearObsList ; (; bool ; flag). inlinestatic . Definition at line 47 of file RooObjCacheManager.h. ◆ findConstantNodes(). void RooObjCacheManager::findConstantNodes ; (; const RooArgSet & ; obs, . RooArgSet & ; cacheList, . RooLinkedList & ; processedNodes . ). overridevirtual . If clearOnRedirect is false, forward constant term optimization calls to cache elements. ; Reimplemented from RooAbsCache.; Definition at line 209 of file RooObjCacheManager.cxx. ◆ insertObjectHook(). void RooObjCacheManager::insertObjectHook ; (; RooAbsCacheElement & ; obj). overridevirtual . Set owner link on all object inserte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:8397,clear,clearObsList,8397,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['clear'],['clearObsList']
Usability,"t is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes. Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; TGeoManager::GetMasterVolumeTGeoVolume * GetMasterVolume() constDefinition TGeoManager.h:511; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; Doing this ensures that the original top-level volume of the geometry is drawn, even if another volume is currently the geometry root. OK, I suppose you already did that with your simple geometry and immediately noticed a new ROOT canvas popping-up and having some more or less strange picture inside. Here are few questions that might come:; Q: ""The picture is strangely rotated; where are the coordinate axes?""; A: If drawn in a new canvas, any view has some default viewpoint, center of view and size. One can then perform mouse/keyboard actions to change them:. Mouse left-click and drag will rotate the view;; Some keys can be pressed when the view canvas is selected: J/K zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes display as well as changing top or side viewpoints can be activated from the **TView** context menu: right-click on the picture when no object is selected;. Q: ""Every line is black! I cannot figure out what is what...""; A: Volumes can have different colors (those known by ROOT of course). Think at using them after each volume creation: myvolume->SetLineColor(Int_t color); otherwise everything is by default black.; Q: ""The top volume of my geometry is a box but I ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:107278,simpl,simple,107278,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simple']
Usability,"t is important to note that no check is done on the validity of the pointer value. In particular if the pointer points, directly or indirectly, back to the current object, this will result in an infinite recursion and the abrupt end of the process.; TClonesArray *fTracks; //->; TH1F *fH; //->; 11.3.4 Variable Length Array; When the Streamercomes across a pointer to a simple type, it assumes it is an array. Somehow, it has to know how many elements are in the array to reserve enough space in the buffer and write out the appropriate number of elements. This is done in the class definition. For example:; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; ...; Float_t *fClosestDistance; //[fNvertex]; The array fClosestDistance is defined as a pointer of floating point numbers. A comment mark (//), and the number in square brackets tell the Streamerthe length of the array for this object. In general the syntax is:; <simple type> *<name>//[<length>]; The length cannot be an expression. If a variable is used, it needs to be an integer data member of the class. It must be defined ahead of its use, or in a base class.; The same notation also applies to variable length array of object and variable length array of pointer to objects.; MyObject *obj; //[fNojbs]; MyObject **objs; //[fDatas]; 11.3.5 Double32_t; Math operations very often require double precision, but on saving single usually precision is sufficient. For this purpose we support the typedef Double32_t which is stored in memory as a double and on disk as a float or integer. The actual size of disk (before compression) is determined by the parameter next to the data member declaration. For example:; Double32_t m_data; //[min,max<,nbits>]; If the comment is absent or does not contain min, max, nbits, the member is saved as a float.; If min and max are present, they are saved with 32 bits precision. min and max can be explicit values or expressions of values known ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:470725,simpl,simple,470725,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"t is required to distinguish unambiguously p.d.f in terms; of observables and parameters, which are not constraints, and p.d.fs in terms; of parameters only, which can serve as constraints p.d.f.s. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t stripDisconnected) const. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of conditional product terms. void fixRefRange(const char* rangeName). std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProdPdf to more intuitively reflect the contents of the; product operator construction. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Implement support for node removal. TObject* clone(const char* newname) const; { return new RooProdPdf(*this,newname) ; }. Bool_t selfNormalized() const; { return _selfNorm ; }. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; { return _pdfList ; }. void setSelfNormalized(Bool_t flag); { _selfNorm = flag ; }. void setDefNormSet(const RooArgSet& nset); { _defNormSet.removeAll() ; _defNormSet.addClone(nset) ; }. void useDefaultGen(Bool_t flag = kTRUE); { _useDefaultGen = flag ; }. » Last changed: Fri Dec 2 14:26:57 2011 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProdPdf.html:57648,intuit,intuitively,57648,root/html532/RooProdPdf.html,https://root.cern,https://root.cern/root/html532/RooProdPdf.html,2,['intuit'],['intuitively']
Usability,"t line 1906 of file TCling.cxx. ◆ RegisterRdictForLoadPCM(). void TCling::RegisterRdictForLoadPCM ; (; const std::string & ; pcmFileNameFullPath, . llvm::StringRef * ; pcmContent . ). private . Register Rdict data for future loading by LoadPCM;. ; Definition at line 1678 of file TCling.cxx. ◆ RegisterTClassUpdate(). void TCling::RegisterTClassUpdate ; (; TClass * ; oldcl, . DictFuncPtr_t ; dict . ). finalvirtual . Register classes that already existed prior to their dictionary loading and that already had a ClassInfo (and thus would not be refresh via UpdateClassInfo. ; Implements TInterpreter.; Definition at line 2384 of file TCling.cxx. ◆ RegisterTemporary() [1/2]. void TCling::RegisterTemporary ; (; const cling::Value & ; value). Register value as a temporary, extending its lifetime to that of the interpreter. ; This is needed for TCling's compatibility interfaces returning long - the address of the temporary objects. As such, ""simple"" types don't need to be stored; they are returned by value; only pointers / references / objects need to be stored. ; Definition at line 7701 of file TCling.cxx. ◆ RegisterTemporary() [2/2]. void TCling::RegisterTemporary ; (; const TInterpreterValue & ; value). Definition at line 7687 of file TCling.cxx. ◆ ReloadAllSharedLibraryMaps(). Int_t TCling::ReloadAllSharedLibraryMaps ; (; ). finalvirtual . Reload the library map entries coming from all the loaded shared libraries, after first unloading the current ones. ; In case of error -1 is returned, 0 otherwise. ; Implements TInterpreter.; Definition at line 5937 of file TCling.cxx. ◆ RemoveAndInvalidateObject(). template<typename List , typename Object > . static void TCling::RemoveAndInvalidateObject ; (; List & ; L, . Object * ; O . ). inlinestaticprivate . Definition at line 591 of file TCling.h. ◆ ReportDiagnosticsToErrorHandler(). void TCling::ReportDiagnosticsToErrorHandler ; (; bool ; = true). finalvirtual . Report diagnostics to the ROOT error handler (see TError.h). ; Reimple",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:126643,simpl,simple,126643,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['simpl'],['simple']
Usability,"t line 445 of file TSpline.cxx. ◆ TSpline3() [6/8]. TSpline3::TSpline3 ; (; const char * ; title, . const TGraph * ; g, . const char * ; opt = nullptr, . Double_t ; valbeg = 0, . Double_t ; valend = 0 . ). Third spline creator given a TGraph with abscissa in increasing order and possibly end point conditions. ; Definition at line 479 of file TSpline.cxx. ◆ TSpline3() [7/8]. TSpline3::TSpline3 ; (; const TH1 * ; h, . const char * ; opt = nullptr, . Double_t ; valbeg = 0, . Double_t ; valend = 0 . ). Third spline creator given a TH1. ; Definition at line 510 of file TSpline.cxx. ◆ TSpline3() [8/8]. TSpline3::TSpline3 ; (; const TSpline3 & ; sp3). Copy constructor. ; Definition at line 538 of file TSpline.cxx. ◆ ~TSpline3(). TSpline3::~TSpline3 ; (; ). inlineoverride . Definition at line 219 of file TSpline.h. Member Function Documentation. ◆ BuildCoeff(). void TSpline3::BuildCoeff ; (; void ; ). overrideprotectedvirtual . Build coefficients. ; subroutine cubspl ( tau, c, n, ibcbeg, ibcend ); from * a practical guide to splines * by c. de boor; ************************ input ***************************; n = number of data points. assumed to be .ge. 2.; (tau(i), c(1,i), i=1,...,n) = abscissae and ordinates of the; data points. tau is assumed to be strictly increasing.; ibcbeg, ibcend = boundary condition indicators, and; c(2,1), c(2,n) = boundary condition information. specifically,; ibcbeg = 0 means no boundary condition at tau(1) is given.; in this case, the not-a-knot condition is used, i.e. the; jump in the third derivative across tau(2) is forced to; zero, thus the first and the second cubic polynomial pieces; are made to coincide.); ibcbeg = 1 means that the slope at tau(1) is made to equal; c(2,1), supplied by input.; ibcbeg = 2 means that the second derivative at tau(1) is; made to equal c(2,1), supplied by input.; ibcend = 0, 1, or 2 has analogous meaning concerning the; boundary condition at tau(n), with the additional infor-; mation taken from c(2,n).; *******",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpline3.html:23842,guid,guide,23842,doc/master/classTSpline3.html,https://root.cern,https://root.cern/doc/master/classTSpline3.html,1,['guid'],['guide']
Usability,"t menu. void SetNexpressions(Int_t expr); Change the number of expression widgets. void SetScanFileName(const char* name = """"); Set the name of the file where to redirect <Scan> output. void SetScanRedirect(Bool_t mode); Set the state of Scan check button. void SetTree(TTree* tree); Assign the fTree member from existing tree, e.g. when calling; tree->StartViewer() from the browser, or even from the command line. void SetTreeName(const char* treeName); Allow geting the tree from the context menu. void SetFile(); Set file name containing the tree. void BuildInterface(); Create all viewer widgets. ~TTreeViewer(); TTreeViewer destructor. void ActivateButtons(Bool_t first, Bool_t previous, Bool_t next, Bool_t last); Enable/disable session buttons. const char* Cut(); Apply Cut. const char* ScanList(); returns scanlist. void SetSession(TTVSession* session); Set current session. const char* EmptyBrackets(const char* name); Empty the bracket content of a string. void EmptyAll(); Clear the content of all items in the list view. void Empty(); Empty the content of the selected expression. TTVLVEntry * ExpressionItem(Int_t index); Get the item from a specific position. TList* ExpressionList(); Get the list of expression items. Int_t Dimension(); Compute dimension of the histogram. void ExecuteDraw(); Called when the DRAW button is executed. void ExecuteSpider(); Draw a spider plot for the selected entries. const char* Ex(); Get the expression to be drawn on X axis. const char* Ey(); Get the expression to be drawn on Y axis. const char* Ez(); Get the expression to be drawn on Z axis. const char* En(Int_t n); Get the n'th expression. void EditExpression(); Start the expression editor. Int_t MakeSelector(const char* selector = 0); Get use of TTree::MakeSelector() via the context menu. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Get use of TTree::Process() via the context menu. const char * GetGrOpt(); Get g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeViewer.html:35159,Clear,Clear,35159,root/html534/TTreeViewer.html,https://root.cern,https://root.cern/root/html534/TTreeViewer.html,3,['Clear'],['Clear']
Usability,"t mode. classname does not have to derive from TObject. The function is based on the new TStreamerInfo.; Build a TBranchElement for an object of class classname.; addr is the address of a pointer to an object of class classname. The class dictionary must be available (ClassDef in class header).; Note: See the comments in TBranchElement::SetAddress() for a more detailed discussion of the meaning of the addr parameter.; This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file; IMPORTANT NOTE about branch names:; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; bufsize is the buffer size in bytes for this branch The default value is 32000 bytes and should be ok for most cases. You can specify a larger value (e.g. 256000) if your Tree is not split and each entry is large (Megabytes) A small value for bufsize is optimum if you intend to access the entries in the Tree randomly and your Tree is in split mode.; Use splitlevel < 0 instead of splitlevel=0 when the class has a custom Streamer; Note: if the split level is set to the default (99), TTree::Branch will not issue a warning if the class can not be spli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:96817,simpl,simply,96817,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['simpl'],['simply']
Usability,"t of a Tree to a new Tree, one branch in a separate file. ;  ;  copytree3.C;   Example of Root macro to copy a subset of a Tree to a new Tree, selecting entries. ;  ;  drawsparse.C;   Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord. ;  ;  h1analysis.C;   Example of analysis class for the H1 data. ;  ;  h1analysis.h;  ;  h1analysisProxy.C;  Example of analysis class for the H1 data using code generated by MakeProxy. ;  ;  h1analysisProxy.h;  ;  h1analysisProxyCut.C;  ;  h1analysisTreeReader.C;  H1 analysis example expressed in terms of TTreeReader (see h1analysis.C). ;  ;  h1analysisTreeReader.h;  ;  h1chain.C;   Creates a TChain to be used by the h1analysis.C class the symbol H1 must point to a directory where the H1 data sets have been installed. ;  ;  hsimpleProxy.C;   Used by hsimpleProxyDriver.C. ;  ;  hsimpleProxyDriver.C;   This is the driver of the hsimpleProxy example. ;  ;  hsimpleReader.C;   TTreeReader simplest example. ;  ;  htest.C;   Save histograms in Tree branches ;  ;  hvector.C;   Write and read STL vectors in a tree. ;  ;  JetEvent.cxx;  ;  JetEvent.h;  ;  jets.C;  Usage of a Tree using the JetEvent class. ;  ;  ntuple1.C;   Simple tree analysis. ;  ;  parallelcoord.C;   Script illustrating the use of the TParallelCoord class ;  ;  parallelcoordtrans.C;   Use of transparency with ||-Coord. ;  ;  printSizes.C;   This macro can be used to get aggregate information on the size take on disk or in memory by the various branches in a TTree. ;  ;  run_h1analysis.C;   Macro driving the analysis can specify file name and type ;  ;  spider.C;   TSpider example. ;  ;  staff.C;   Create a plot of the data in cernstaff.root To create cernstaff.root, execute tutorial $ROOTSYS/tutorials/tree/cernbuild.C ;  ;  tcl.C;   How to write a TClonesArray to a TTree ;  ;  temperature.C;  This tutorial illustrates how to use the highlight mode with trees. ;  ;  tree.C;   Display the Tree data structur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html:2018,simpl,simplest,2018,doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html,https://root.cern,https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html,1,['simpl'],['simplest']
Usability,"t of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Static Protected Member Functions |; Protected Attributes |; Private Attributes |; Friends |; List of all members ; RooAbsCategory Class ReferenceabstractRooFit » RooFit Core. ; A space to attach TBranches. ; RooAbsCategory is the base class for objects that represent a discrete value with a finite number of states.; Each state is denoted by an integer and a name. Both can be used to retrieve and set states, but referring to states by index is more efficient. Conversion between index and name can be done using lookupName() or lookupIndex(). It is possible to iterate through all defined states using begin() and end().; For category classes deriving from RooAbsCategory, states can only be evaluated, i.e., queried. Refer to RooAbsCategoryLValue and its derived classes for categories where states can also be set. The simplest category class whose states can be set, queried and saved in a dataset, refer to RooCategory. Interface change in ROOT-6.22; Category data were based in the class RooCatType, holding an index state and a category name truncated to 256 characters. This wastes 64 bytes of storage space per entry, and prevents fast retrieval of category data. Since ROOT-6.22, categories are only represented by an integer. RooAbsCategory::lookupName() can be used to retrieve the corresponding state name. There is no limit for the length of the state name.; To not break old code, the old RooCatType interfaces are still available. Whenever possible, the following replacements should be used:; lookupType() \( \rightarrow \) lookupName() / lookupIndex(); typeIterator() \( \rightarrow \) range-based for loop / begin() / end(); isValidIndex(Int_t index) \( \rightarrow \) hasIndex(); isValid(const RooCatType&) \( \rightarrow \) hasIndex() / hasLabel() . Definition at line 33 of file RooAbsCategory.h. Public Types; using value_type = int;  The type used",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategory.html:1076,simpl,simplest,1076,doc/master/classRooAbsCategory.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategory.html,1,['simpl'],['simplest']
Usability,"t of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGProgressBar;  TGProgressBar (const TGWindow *p, UInt_t w, UInt_t h, Pixel_t back=GetWhitePixel(), Pixel_t barcolor=GetDefaultSelectedBackground(), GContext_t norm=GetDefaultGC()(), FontStruct_t font=GetDefaultFontStruct(), UInt_t options=kDoubleBorder|kSunkenFrame);  Create progress bar. ;  ;  ~TGProgressBar () override;  ; virtual void Format (const char *format=""%.2f"");  Set format for displaying a value. ;  ; Pixel_t GetBarColor () const;  ; EBarType GetBarType () const;  ; EFillType GetFillType () const;  ; FontStruct_t GetFontStruct () const;  ; TString GetFormat () const;  ; Float_t GetMax () const;  ; Float_t GetMin () const;  ; GContext_t GetNormGC () const;  ; Float_t GetPosition () const;  ; Bool_t GetShowPos () const;  ; const char * GetValueFormat () const;  ; void Increment (Float_t inc);  Increment progress position. ;  ; virtual void Reset ();  Reset progress bar (i.e. set pos to 0). ;  ; void SetBarColor (const char *color=""blue"");  Set progress bar color. ;  ; virtual void SetBarColor (Pixel_t color);  Set progress bar color. ;  ; void SetBarType (EBarType type);  Set bar type. ;  ; void SetFillType (EFillType type);  Set fill type. ;  ; void SetForegroundColor (Pixel_t pixel) override;  Change text color drawing. ;  ; void SetMax (Float_t max);  ; void SetMin (Float_t min);  ; void SetPosition (Float_t pos);  Set progress position between [min,max]. ;  ; void SetRange (Float_t min, Float_t max);  Set min and max of progress bar. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Bool_t UsePercent () const;  ;  Public Member Functions inherited from TGFrame;  TGFrame (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=0, Pixel_t back=GetDefaultFrameBackground());  Create a TGFrame object. Options is an OR of the EFrameTypes. ;  ;  TGFrame (TGClient *c, Window_t id, const TGWindow *paren",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGVProgressBar.html:2403,progress bar,progress bar,2403,doc/master/classTGVProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGVProgressBar.html,1,['progress bar'],['progress bar']
Usability,"t of merged commands. ; This make it possible to group complex actions together so an end user can undo and redo them with one command. Execution of TQUndoManager::Undo(), TQUndoManager::Redo() methods only invokes the top level command as a whole.; Merge method is analogous to logical join operation.; Note: Merge method invokes redo action. ; Definition at line 329 of file TQCommand.cxx. ◆ operator=(). TQCommand & TQCommand::operator= ; (; const TQCommand & ; ). private . ◆ PrintCollectionHeader(). void TQCommand::PrintCollectionHeader ; (; Option_t * ; option); const. overrideprotectedvirtual . Print collection header. ; Reimplemented from TCollection.; Definition at line 864 of file TQCommand.cxx. ◆ Redo(). void TQCommand::Redo ; (; Option_t * ; option = """"). virtual . Execute command and then merge commands. ; Reimplemented in TQUndoManager.; Definition at line 588 of file TQCommand.cxx. ◆ SetArgs(). void TQCommand::SetArgs ; (; Int_t ; narg, .  ; ... . ). virtual . Set do/redo and undo parameters. ; The format is SetArgs(number_of_params, redo_params, undo_params); Example: move_command->SetArgs(2, 100, 100, 200, 200);; 2 params, (100,100) - do/redo position, (200,200) - undo position ; Definition at line 465 of file TQCommand.cxx. ◆ SetName(). void TQCommand::SetName ; (; const char * ; name). virtual . Sets name of the command. ; Definition at line 832 of file TQCommand.cxx. ◆ SetRedoArgs(). void TQCommand::SetRedoArgs ; (; Int_t ; narg, .  ; ... . ). virtual . Set redo parameters. ; The format is SetRedoArgs(number_of_params, params); Example: move_command->SetRedoArgs(2, 100, 100);. Definition at line 508 of file TQCommand.cxx. ◆ SetTitle(). void TQCommand::SetTitle ; (; const char * ; title). virtual . Sets description of the command. ; Definition at line 840 of file TQCommand.cxx. ◆ SetUndoArgs(). void TQCommand::SetUndoArgs ; (; Int_t ; narg, .  ; ... . ). virtual . Set undo parameters. ; The format is SetUndoArgs(number_of_params, params); Example: move_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:42608,undo,undo,42608,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"t of the algorithms:. 0 = RGB Smooth,; 1 = RGB Modulo,; 2 = CMY Smooth,; 3 = CMY Modulo,; 4 = CIE Smooth; 5 = CIE Modulo,; 6 = YIQ Smooth,; 7 = YIQ Modulo,; 8 = HVS Smooth,; 9 = HVS Modulo. This function does not apply on Simple display modes group. Default value is 0. Example choosing CMY Modulo to paint the 2D histogram:; h2->Draw(""SPEC c1(3) dm(0,1) a(30,30,0)"");; The operator “lp(x,y,z)” sets the light position. In Light and LightHeight display modes groups the color palette is calculated according to the fictive light source position in 3-d space. Using this function one can change the source’s position and thus achieve various graphical effects. This function does not apply for Simple and Height display modes groups. Default is: lp(1000,1000,100) .; The operator “s(shading,shadow)” allows to set the shading. The surface picture is composed of triangles. The edges of the neighboring triangles can be smoothed (shaded). The shadow can be painted as well. The function does not apply on Simple display modes group. The possible values for shading are:. 0 = Not Shaded,; 1 = Shaded. The possible values for shadow are:. 0 = Shadows are not painted,; 1 = Shadows are painted. Default values: s(1,0) .; The operator “b(bezier)” sets the Bezier smoothing. For Simple display modes group and for Grid, LinesX and LinesY display modes one can smooth data using Bezier smoothing algorithm. The function does not apply on other display modes groups and display modes. Possible values are: 0 = No bezier smoothing, 1 = Bezier smoothing. Default value is: b(0).; The operator “cw(width)” sets the contour width. This function applies only on for the Contours display mode. One can change the width between horizontal slices and thus their density. Default value: cw(50) .; The operator “lhw(weight)” sets the light height weight. For LightHeight display modes group one can change the weight between both shading algorithms. The function does not apply on other display modes groups. Default val",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:106109,Simpl,Simple,106109,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Simpl'],['Simple']
Usability,"t of the branch. ; If a Data Model Evolution conversion is involved, reset the fInfo of the branch. The return values are:; kMissingBranch (-5) : Missing branch; kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; kMatch (0) : perfect match; kMatchConversion (1) : match with (I/O) conversion; kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; kMakeClass (3) : MakeClass mode so we can not check.; kVoidPtr (4) : void* passed so no check was made.; kNoCheck (5) : Underlying TBranch not yet available so no check was made. In addition this can be multiplexed with the two bits:; kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode. This bits can be masked out by using kDecomposedObjMask . Definition at line 2867 of file TTree.cxx. ◆ Class(). static TClass * TTree::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTree::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTree::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 659 of file TTree.h. ◆ CloneTree(). TTree * TTree::CloneTree ; (; Long64_t ; nentries = -1, . Option_t * ; option = """" . ). virtual . Create a clone of this tree and copy nentries. ; By default copy all entries. The compression level of the cloned tree is set to the destination file's compression level.; NOTE:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:102856,usab,usable,102856,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['usab'],['usable']
Usability,"t of the branch. ; If a Data Model Evolution conversion is involved, reset the fInfo of the branch. The return values are:; kMissingBranch (-5) : Missing branch; kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; kMatch (0) : perfect match; kMatchConversion (1) : match with (I/O) conversion; kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; kMakeClass (3) : MakeClass mode so we can not check.; kVoidPtr (4) : void* passed so no check was made.; kNoCheck (5) : Underlying TBranch not yet available so no check was made. In addition this can be multiplexed with the two bits:; kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode. This bits can be masked out by using kDecomposedObjMask . Definition at line 2867 of file TTree.cxx. ◆ Class(). static TClass * TTree::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTree::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTree::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 705 of file TTree.h. ◆ CloneTree(). TTree * TTree::CloneTree ; (; Long64_t ; nentries = -1, . Option_t * ; option = """" . ). virtual . Create a clone of this tree and copy nentries. ; By default copy all entries. The compression level of the cloned tree is set to the destination file's compression level.; NOTE:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:103029,usab,usable,103029,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['usab'],['usable']
Usability,"t or a TOrdCollection. void AddAfter(const TObject* after, TObject* obj); Add object in the slot after object after. If after=0 add object in; the last empty slot. Note that this will overwrite any object that; might have already been in this slot. For insertion semantics use; either a TList or a TOrdCollection. void AddAtAndExpand(TObject* obj, Int_t idx); Add object at position idx. If idx is larger than the current size; of the array, expand the array (double its size). void AddAt(TObject* obj, Int_t idx); Add object at position ids. Give an error when idx is out of bounds; (i.e. the array is not expanded). Int_t AddAtFree(TObject* obj); Return the position of the new object.; Find the first empty cell or AddLast if there is no empty cell. TObject * After(const TObject* obj) const; Return the object after obj. Returns 0 if obj is last object. TObject * Before(const TObject* obj) const; Return the object before obj. Returns 0 if obj is first object. void Clear(Option_t* option = """"); Remove all objects from the array. Does not delete the objects; unless the TObjArray is the owner (set via SetOwner()). void Compress(); Remove empty slots from array. void Delete(Option_t* option = """"); Remove all objects from the array AND delete all heap based objects. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. TObject * FindObject(const char* name) const; Find an object in this collection using its name. Requires a sequential; scan till the object has been found. Returns 0 if object with specified; name is not found. TObject * FindObject(const TObject* obj) const; Find an object in this collection using the object's IsEqual(); member function. Requires a sequential scan till the object has; been found. Returns 0 if object is not found.; Typically this function is overridden by a more efficient version; in concrete collection classes (e.g. THashTable). void Streamer(TBuffer& ); Stream all objects in the array to or from the I/O buffer. TObject * Fir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TObjArray.html:13131,Clear,Clear,13131,root/html534/TObjArray.html,https://root.cern,https://root.cern/root/html534/TObjArray.html,3,['Clear'],['Clear']
Usability,"t or a TOrdCollection. void AddAfter(const TObject* after, TObject* obj); Add object in the slot after object after. If after=0 add object in; the last empty slot. Note that this will overwrite any object that; might have already been in this slot. For insertion semantics use; either a TList or a TOrdCollection. void AddAtAndExpand(TObject* obj, Int_t idx); Add object at position idx. If idx is larger than the current size; of the array, expand the array (double its size). void AddAt(TObject* obj, Int_t idx); Add object at position ids. Give an error when idx is out of bounds; (i.e. the array is not expanded). Int_t AddAtFree(TObject* obj); Return the position of the new object.; Find the first empty cell or AddLast if there is no empty cell. TObject * After(const TObject* obj) const; Return the object after obj. Returns 0 if obj is last object. TObject * Before(const TObject* obj) const; Return the object before obj. Returns 0 if obj is first object. void Clear(Option_t* option = """"); Remove all objects from the array. Does not delete the objects; unless the TObjArray is the owner (set via SetOwner()). void Compress(); Remove empty slots from array. void Delete(Option_t* option = """"); Remove all objects from the array AND delete all heap based objects. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. TObject * FindObject(const char* name) const; Find an object in this collection using its name. Requires a sequential; scan till the object has been found. Returns 0 if object with specified; name is not found. TObject * FindObject(const TObject* obj) const; Find an object in this collection using the object's IsEqual(); member function. Requires a sequential scan till the object has; been found. Returns 0 if object is not found.; Typically this function is overridden by a more efficient version; in concrete collection classes (e.g. THashTable). void Streamer(TBuffer& b); Stream all objects in the array to or from the I/O buffer. TObject * Fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TObjArray.html:13112,Clear,Clear,13112,root/html532/TObjArray.html,https://root.cern,https://root.cern/root/html532/TObjArray.html,1,['Clear'],['Clear']
Usability,"t or a TOrdCollection. void AddAfter(const TObject* after, TObject* obj); Add object in the slot after object after. If after=0 add object in; the last empty slot. Note that this will overwrite any object that; might have already been in this slot. For insertion semantics use; either a TList or a TOrdCollection. void AddAtAndExpand(TObject* obj, Int_t idx); Add object at position idx. If idx is larger than the current size; of the array, expand the array (double its size). void AddAt(TObject* obj, Int_t idx); Add object at position ids. Give an error when idx is out of bounds; (i.e. the array is not expanded). Int_t AddAtFree(TObject* obj); Return the position of the new object.; Find the first empty cell or AddLast if there is no empty cell. TObject * After(const TObject* obj) const; Return the object after obj. Returns 0 if obj is last object. TObject * Before(const TObject* obj) const; Return the object before obj. Returns 0 if obj is first object. void Clear(Option_t* option = """"); Remove all objects from the array. void Compress(); Remove empty slots from array. void Delete(Option_t* option = """"); Remove all objects from the array and free the internal memory. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. TObject * GetFromTable(Int_t idx) const; the reference may be in the TRefTable. void Streamer(TBuffer& ); Stream all objects in the array to or from the I/O buffer. TObject * First() const; Return the object in the first slot. TObject * Last() const; Return the object in the last filled slot. Returns 0 if no entries. Int_t GetEntries() const; Return the number of objects in array (i.e. number of non-empty slots).; Attention: use this method ONLY if you want to know the number of; non-empty slots. This function loops over the complete array and; is therefore very slow when applied in a loop. Most of the time you; better use GetLast()+1. Int_t GetAbsLast() const; Return absolute index to last object in array. Returns -1 in case; arr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRefArray.html:14963,Clear,Clear,14963,root/html534/TRefArray.html,https://root.cern,https://root.cern/root/html534/TRefArray.html,3,['Clear'],['Clear']
Usability,"t or a TOrdCollection. void AddAfter(const TObject* after, TObject* obj); Add object in the slot after object after. If after=0 add object in; the last empty slot. Note that this will overwrite any object that; might have already been in this slot. For insertion semantics use; either a TList or a TOrdCollection. void AddAtAndExpand(TObject* obj, Int_t idx); Add object at position idx. If idx is larger than the current size; of the array, expand the array (double its size). void AddAt(TObject* obj, Int_t idx); Add object at position ids. Give an error when idx is out of bounds; (i.e. the array is not expanded). Int_t AddAtFree(TObject* obj); Return the position of the new object.; Find the first empty cell or AddLast if there is no empty cell. TObject * After(const TObject* obj) const; Return the object after obj. Returns 0 if obj is last object. TObject * Before(const TObject* obj) const; Return the object before obj. Returns 0 if obj is first object. void Clear(Option_t* option = """"); Remove all objects from the array. void Compress(); Remove empty slots from array. void Delete(Option_t* option = """"); Remove all objects from the array and free the internal memory. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. TObject * GetFromTable(Int_t idx) const; the reference may be in the TRefTable. void Streamer(TBuffer& b); Stream all objects in the array to or from the I/O buffer. TObject * First() const; Return the object in the first slot. TObject * Last() const; Return the object in the last filled slot. Returns 0 if no entries. Int_t GetEntries() const; Return the number of objects in array (i.e. number of non-empty slots).; Attention: use this method ONLY if you want to know the number of; non-empty slots. This function loops over the complete array and; is therefore very slow when applied in a loop. Most of the time you; better use GetLast()+1. Int_t GetAbsLast() const; Return absolute index to last object in array. Returns -1 in case; ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRefArray.html:13492,Clear,Clear,13492,root/html532/TRefArray.html,https://root.cern,https://root.cern/root/html532/TRefArray.html,1,['Clear'],['Clear']
Usability,"t override;  Equal comparison. ;  ; Bool_t IsExecuting () const;  Returns kTRUE if command execution is in progress. ;  ; Bool_t IsMacro () const;  Returns kTRUE if neither redo nor undo action specified. ;  ; Bool_t IsRedoing () const;  Redo action is in progress. ;  ; virtual Bool_t IsSetter () const;  Returns kTRUE is command if Redo is the same as Undo function and is the setter action. ;  ; Bool_t IsUndoing () const;  Undo action is in progress. ;  ; virtual Long64_t Merge (TCollection *, TFileMergeInfo *);  Merge a collection of TQCommand. ;  ; virtual void Merge (TQCommand *c);  Add command to the list of merged commands. ;  ; virtual void SetArgs (Int_t nargs,...);  Set do/redo and undo parameters. ;  ; virtual void SetName (const char *name);  Sets name of the command. ;  ; virtual void SetRedoArgs (Int_t nargs,...);  Set redo parameters. ;  ; virtual void SetTitle (const char *title);  Sets description of the command. ;  ; virtual void SetUndoArgs (Int_t nargs,...);  Set undo parameters. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void AddAfter (const TObject *after, TObject *obj) override;  Insert object after object after in the list. ;  ; virtual void AddAfter (TObjLink *after, TObject *obj);  Insert object after the specified ObjLink object. ;  ; void AddAt (TObject *obj, Int_t idx) override;  Insert object at position idx in the list. ;  ; void AddBefore (const TObject *before, TObject *obj) override;  Insert object before object before in the list. ;  ; virtual void AddBefore (TObjLink *before, TObject *obj);  Insert object before the specified ObjLink object. ;  ; void AddFirst (TObject *obj) override;  Add object at the beginning of the list. ;  ; virtual void AddFirst (TObject *obj, Option_t *opt);  Add object at t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:4627,undo,undo,4627,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['undo'],['undo']
Usability,"t passed explicitely, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis. The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by. TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );. where kreg determines the regularisation of the unfolding. In general, overregularisation (too small kreg) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large kreg) will lead to large fluctuations in the unfolded spectrum. The optimal regularisation can be determined following guidelines in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] using the distribution of the |d_i|<\tt> that can be obtained by tsvdunf->GetD() and/or using pseudo-experiments. Covariance matrices on the measured spectrum (for either the total uncertainties or individual sources of uncertainties) can be propagated to covariance matrices using the GetUnfoldCovMatrix method, which uses pseudo experiments for the propagation. In addition, GetAdetCovMatrix allows for the propagation of the statistical uncertainties on the response matrix using pseudo experiments. The covariance matrix corresponding to Bcov is also computed as described in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] and can be obtained from tsvdunf->GetXtau() and its (regularisation independent) inverse from tsvdunf->GetXinv(). The distribution of singular values can be retrieved using tsvdunf->GetSV(). See also the tutorial for a toy example.; . Function Members (Methods); public:. TSVDUn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSVDUnfold.html:2068,guid,guidelines,2068,root/html532/TSVDUnfold.html,https://root.cern,https://root.cern/root/html532/TSVDUnfold.html,2,['guid'],['guidelines']
Usability,"t pixel_object_scale=kTRUE);  Save picture with given width (height scaled proportionally). ;  ; virtual void SelectionChanged ();  Update GUI components for embedded viewer selection change. ;  ; void SetAutoRotator (TGLAutoRotator *ar);  Set the auto-rotator for this viewer. The old rotator is deleted. ;  ; void SetCameraOverlay (TGLCameraOverlay *m);  ; void SetClearColor (Color_t col);  Set background method. ;  ; void SetClipAutoUpdate (Bool_t x);  ; void SetCurrentCamera (ECameraType camera);  Set current active camera - 'cameraType' one of: kCameraPerspX, kCameraPerspY, kCameraPerspZ, kCameraOrthoXOY, kCameraOrthoXOZ, kCameraOrthoZOY, kCameraOrthoXnOY, kCameraOrthoXnOZ, kCameraOrthoZnOY. ;  ; void SetDrawCameraCenter (Bool_t x);  Draw camera look at and rotation point. ;  ; virtual void SetEventHandler (TGEventHandler *handler);  Set the event-handler. ;  ; void SetFader (Float_t x);  ; virtual void SetGedEditor (TGedEditor *ed);  ; void SetGuideState (Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t *referencePos);  Set the state of guides (axes & reference markers) from arguments. ;  ; void SetIgnoreSizesOnUpdate (Bool_t v);  ; void SetLineScale (Float_t s);  ; void SetMaxSceneDrawTimeHQ (Float_t t);  ; void SetMaxSceneDrawTimeLQ (Float_t t);  ; void SetOrthoCamera (ECameraType camera, Double_t zoom, Double_t dolly, Double_t center[3], Double_t hRotate, Double_t vRotate);  Set an orthographic camera to supplied configuration - note this does not need to be the current camera - though you will not see the effect if it is not. ;  ; void SetPerspectiveCamera (ECameraType camera, Double_t fov, Double_t dolly, Double_t center[3], Double_t hRotate, Double_t vRotate);  Set a perspective camera to supplied configuration - note this does not need to be the current camera - though you will not see the effect if it is not. ;  ; void SetPictureFileName (const TString &f);  ; void SetPointScale (Float_t s);  ; void SetResetCamerasOnUpdate (Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLEmbeddedViewer.html:10467,guid,guides,10467,doc/master/classTGLEmbeddedViewer.html,https://root.cern,https://root.cern/doc/master/classTGLEmbeddedViewer.html,2,['guid'],['guides']
Usability,"t provide per-bin statistics ;  ►CTHistStatUncertaintyHistogram statistics to keep track of the Poisson uncertainty per bin ;  CTBinStatModifying view on a THistStatUncertainty for a given bin ;  CTConstBinStatConst view on a THistStatUncertainty for a given bin ;  CTHistViewA view on a histogram, selecting a range on a subset of dimensions ;  CTHistViewOutOfRange;  CTLogEntry;  CTLogHandlerAbstract TLogHandler base class ;  CTLogManager;  ►NFitNamespace for the fitting classes ;  CBasicFCNBasicFCN class: base class for the objective functions used in the fits It has a reference to the data and th emodel function used in the fit ;  CBinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y values and error on coordinates The dimension of the coordinate is free There are 4 different options: ;  CBinPointObsolete class, no more in use ;  CChi2FCNChi2FCN class for binnned fits using the least square methods ;  CDataOptionsDataOptions : simple structure holding the options on how the data are filled ;  CDataRangeClass describing the range in the coordinates it supports multiple range in a coordinate ;  CDataVectorClass holding the fit data points ;  CDataWrapperClass maintaining a pointer to external data Using this class avoids copying the data when performing a fit NOTE: this class is not thread-safe and should not be used in parallel fits ;  CDummyDeleter;  CFcnAdapter;  CFitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::ParameterSettings class ;  CFitDataBase class for all the fit data types ;  CFitResultClass containg the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values ;  CFitterFitter class, entry point for performing all type of fits ;  CLogLikelihoodFCNLogLikelihoodFCN class for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:16959,simpl,simple,16959,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['simpl'],['simple']
Usability,"t really use it as is. Let's see what it looks like:; // This lambda defines the values of the function. For now we don't use p:; auto myErf0Lambda = [](double* x, double* p) { return TMath::Erf(x[0]); };; // When drawing, show between -10..10; TF1* myErf0 = new TF1(""myErf0"", myErf0Lambda, -10, 10);; myErf0->Draw();. This is the same one but moved around to match the concept of efficiencies:; auto myErf1Lambda = [](double* x, double* p) ; { return (TMath::Erf((x[0]-5)/3) + 1)/2 * 0.8; };; TF1* myErf1 = new TF1(""myErf1"", myErf1Lambda, -10, 10);; myErf1->Draw();. We can re-write this using parameter notation:; auto myErf2Lambda = [](double* x, double* p) { ; return (TMath::Erf((x[0]-p[0])/p[1]) + 1)/2 * p[2]; };; TF1* myErf2 = new TF1(""myErf2"", myErf2Lambda, ; -10, 10, 3 /*number of parameters*/);; myErf2->SetParameter(0, 5.);; myErf2->SetParameter(1, 3.);; myErf2->SetParameter(2, 0.8);; myErf2->Draw();. Try out what happens when you change the values for 5, 3 and 0.8 (simply by calling myErf2->SetParameter(...);)!; Fitting a TF1; Now that we have a nice TF1 we can fit it to the TEfficiency object by calling eff->Fit(). Here is the complete code you need to add to the end of effX():; ...; void effX() {; ...; auto effErf = [](double* x, double* p) {; return (TMath::Erf((x[0] - p[0]) / p[1]) + 1) / 2. * p[2];; };. TF1* myErf = new TF1(""myErf"", effErf, 0., 10., 3);; myErf->SetParameter(0, 5.);; myErf->SetParameter(1, 5.);; myErf->SetParameter(2, 1.);. eff->Fit(myErf);; }. Parameter Initialization and Fitting; You must initialize the parameters to sensible values - this is especially important for higher dimensional fits, e.g. with a TF2. Fitting is magic, but only within limits. Try with completely bogus parameters and you'll see how the fit fails!; . ‹ 8. Efficiency Calculation; up; 10. Go Parallel! ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/9-fitting-coding.html:3094,simpl,simply,3094,d/9-fitting-coding.html,https://root.cern,https://root.cern/d/9-fitting-coding.html,1,['simpl'],['simply']
Usability,"t reported number of bytes read; TList*TEventIter::fPacketslist of packets processed packets; TStringTEventIter::fPathPath to current TDirectory; TSelector*TEventIter::fSelselector to be used; Bool_tTEventIter::fStoptermination of run requested. private:. Long64_tfCacheSizeCache size; Bool_tfDontCacheFilesControl OS caching of read files (Mac Os X only); TList*fFileTreesFiles && Trees currently open; TTree*fTreetree we are iterating over; TTreeCache*fTreeCacheinstance of the tree cache for the tree; Bool_tfTreeCacheIsLearningWhether cache is in learning phase; TStringfTreeNamename of the tree object to iterate over; Bool_tfUseParallelUnzipControl usage of parallel unzip; Bool_tfUseTreeCacheControl usage of the tree cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIterTree(); Default ctor. TEventIterTree(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIterTree(); Destructor. Long64_t GetCacheSize(); Return the size in bytes of the cache, if any; Return -1 if not used. Int_t GetLearnEntries(); Return the number of entries in the learning phase. TTree* GetTrees(TDSetElement* elem); Create a Tree for the main TDSetElement and for all the friends.; Returns the main tree or 0 in case of an error. TTree* Load(TDSetElement* elem, Bool_t& localfile); Load a tree from s TDSetElement. Int_t GetNextPacket(Long64_t& first, Long64_t& num, TEntryList** enl = 0, TEventList** evl = 0); Get loop range. void PreProcessEvent(Long64_t ent); Actions to be done just before processing entry 'entry'.; Called by TProofPlayer. Long64_t GetNextEvent(); Get next event. TEventIterTree(). » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-04 16:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEventIterTree.html:7987,learn,learning,7987,root/html534/TEventIterTree.html,https://root.cern,https://root.cern/root/html534/TEventIterTree.html,2,['learn'],['learning']
Usability,"t rmin, Double_t rmax, Double_t tmin, Double_t tmax);  TGraphPolargram Constructor. ;  ;  TGraphPolargram (const char *name="""");  Short constructor used in the case of a spider plot. ;  ;  ~TGraphPolargram () override;  TGraphPolargram destructor. ;  ; void ChangeRangePolar (Double_t tmin, Double_t tmax);  Set the Polar range. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Everything within the circle belongs to the TGraphPolargram. ;  ; void Draw (Option_t *options="""") override;  Draw Polargram. ;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Indicate that there is something to click here. ;  ; Double_t GetAngle ();  ; Int_t GetNdivPolar ();  ; Int_t GetNdivRadial ();  ; Color_t GetPolarColorLabel ();  ; Font_t GetPolarLabelFont ();  ; Double_t GetPolarLabelSize ();  ; Double_t GetPolarOffset ();  ; Color_t GetRadialColorLabel ();  ; Font_t GetRadialLabelFont ();  ; Double_t GetRadialLabelSize ();  ; Double_t GetRadialOffset ();  ; Double_t GetRMax ();  ; Double_t GetRMin ();  ; Double_t GetTickpolarSize ();  ; Double_t GetTMax ();  ; Double_t GetTMin ();  ; TClass * IsA () const override;  ; Bool_t IsDegree ();  ; Bool_t IsGrad ();  ; Bool_t IsRadian ();  ; void PaintCircle (Double_t x, Double_t y, Double_t r, Double_t phimin, Double_t phimax, Double_t theta);  This is simplified from TEllipse::PaintEllipse. ;  ; void SetAxisAngle (Double_t angle=0);  Set axis angle. ;  ; void SetNdivPolar (Int_t Ndiv=508);  Set the number of Polar divisions: enter a number ij with 0<i<99 and 0<j<99. ;  ; void SetNdivRadial (Int_t Ndiv=508);  Set the number of radial divisions: enter a number ij with 0<i<99 and 0<j<99. ;  ; void SetPolarLabel (Int_t div, const TString &label);  Set some specified polar labels, used in the case of a spider plot. ;  ; void SetPolarLabelColor (Color_t tcolorangular=1);  Set Polar labels color. ;  ; void SetPolarLabelFont (Font_t tfontangular=62);  ; void SetPolarLabelSize (Double_t angularsize=0.04);  Set angular l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPolargram.html:3981,simpl,simplified,3981,doc/master/classTGraphPolargram.html,https://root.cern,https://root.cern/doc/master/classTGraphPolargram.html,1,['simpl'],['simplified']
Usability,"t set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf.html:6489,clear,clearEvalErrorLog,6489,root/html532/RooAbsPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategoryLValue.html:2346,clear,clearValueAndShapeDirty,2346,root/html534/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategory.html:2277,clear,clearValueAndShapeDirty,2277,root/html534/RooAbsCategory.html,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsString.html:2105,clear,clearValueAndShapeDirty,2105,root/html534/RooAbsString.html,https://root.cern,https://root.cern/root/html534/RooAbsString.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBinningCategory.html:2145,clear,clearValueAndShapeDirty,2145,root/html534/RooBinningCategory.html,https://root.cern,https://root.cern/root/html534/RooBinningCategory.html,10,['clear'],['clearValueAndShapeDirty']
Usability,"t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStringVar.html:2000,clear,clearValueAndShapeDirty,2000,root/html534/RooStringVar.html,https://root.cern,https://root.cern/root/html534/RooStringVar.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"t splitlevel = 99); virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser* b); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNtuple.html:3275,undo,undo,3275,root/html528/TNtuple.html,https://root.cern,https://root.cern/root/html528/TNtuple.html,12,['undo'],['undo']
Usability,"t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static EvalErrorIter evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:60738,clear,clearing,60738,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['clear'],['clearing']
Usability,"t status and parameters if option Save() is used, nullptr otherwise. The user takes ownership of the fit result.; Template Parameters. CmdArgs_tTemplate types for optional command arguments. Can either be an arbitrary number of RooCmdArg or a single RooLinkedList. NoteThis front-end function should not be re-implemented in derived PDF types. If you mean to customize the likelihood fitting routine, you need to override the virtual RooAbsPdf::fitToImpl() method.; The following named arguments are supported:. Type of CmdArg Options to control construction of -log(L) . All command arguments that can also be passed to the NLL creation method. See alsoRooAbsPdf::createNLL(). Options to control flow of fit procedure . Minimizer(""<type>"", ""<algo>"") Choose minimization package and optionally the algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer interface, but others can be specified (through RooMinimizer interface). . Type Algorithm . Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve) . Minuit2 migrad, simplex, minimize, scan . GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent . GSLSimAn - . InitialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Optimize(bool flag) Activate constant term optimization of test statistic during minimization (on by default) . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, off by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 to 2, default is 1) . MaxCalls(int n) Change maximum number of likelihood function calls from MINUIT (if n <= 0, the default of 500 * #parameters is used) . EvalErrorWall(bool flag=true) When parameters are in disallowed regions (e.g. PDF is negative), return very ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:105567,simpl,simplex,105567,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,2,['simpl'],['simplex']
Usability,"t std::string &display_id) const;  Find primitive with unique id, produce for RDisplayItem Such id used for client-server identification of objects. ;  ; std::shared_ptr< RFrame > GetFrame ();  Get a frame object if exists. ;  ; const std::shared_ptr< RFrame > GetFrame () const;  Get a frame object if exists. ;  ; std::shared_ptr< RDrawable > GetPrimitive (unsigned num) const;  returns primitive of given number ;  ; auto GetPrimitives () const;  Get all primitives contained in the pad. ;  ; unsigned NumPrimitives () const;  returns number of primitives in the pad ;  ; bool Remove (const std::shared_ptr< RDrawable > &drawable);  Remove drawable from list of primitives. ;  ; bool Remove (const std::string &id);  Remove an object from the list of primitives. ;  ; bool RemoveAt (unsigned indx);  Remove drawable at specified position. ;  ; void UseStyle (const std::shared_ptr< RStyle > &style) override;  Use provided style for pad and all primitives inside. ;  ; void Wipe ();  Wipe the pad by clearing the list of primitives. ;  ;  Public Member Functions inherited from ROOT::Experimental::RDrawable;  RDrawable (const char *csstype);  ; virtual ~RDrawable ();  ; void ClearStyle ();  ; const std::string & GetCssClass () const;  ; const char * GetCssType () const;  ; const std::string & GetId () const;  ; void SetCssClass (const std::string &cl);  ; void SetId (const std::string &id);  . Public Attributes; RAttrBorder border {this, ""border""};  ! border attributes ;  . Protected Member Functions; std::unique_ptr< RDisplayItem > Display (const RDisplayContext &) final;  Create pad display item. ;  ;  Protected Member Functions inherited from ROOT::Experimental::RPadBase;  RPadBase (const char *csstype);  Allow derived classes to default construct a RPadBase. ;  ; void CollectShared (Internal::RIOSharedVector_t &) override;  Collect all shared items to resolve shared_ptr after IO. ;  ; void DisplayPrimitives (RPadBaseDisplayItem &paditem, RDisplayContext &ctxt);  Create display",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RPad.html:3834,clear,clearing,3834,doc/master/classROOT_1_1Experimental_1_1RPad.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RPad.html,1,['clear'],['clearing']
Usability,"t std::string &display_id) const;  Find primitive with unique id, produce for RDisplayItem Such id used for client-server identification of objects. ;  ; std::shared_ptr< RFrame > GetFrame ();  Get a frame object if exists. ;  ; const std::shared_ptr< RFrame > GetFrame () const;  Get a frame object if exists. ;  ; std::shared_ptr< RDrawable > GetPrimitive (unsigned num) const;  returns primitive of given number ;  ; auto GetPrimitives () const;  Get all primitives contained in the pad. ;  ; unsigned NumPrimitives () const;  returns number of primitives in the pad ;  ; bool Remove (const std::shared_ptr< RDrawable > &drawable);  Remove drawable from list of primitives. ;  ; bool Remove (const std::string &id);  Remove an object from the list of primitives. ;  ; bool RemoveAt (unsigned indx);  Remove drawable at specified position. ;  ; void UseStyle (const std::shared_ptr< RStyle > &style) override;  Use provided style for pad and all primitives inside. ;  ; void Wipe ();  Wipe the pad by clearing the list of primitives. ;  ;  Public Member Functions inherited from ROOT::Experimental::RDrawable;  RDrawable (const char *csstype);  ; virtual ~RDrawable ();  ; void ClearStyle ();  ; const std::string & GetCssClass () const;  ; const char * GetCssType () const;  ; const std::string & GetId () const;  ; void SetCssClass (const std::string &cl);  ; void SetId (const std::string &id);  . Static Public Member Functions; static std::shared_ptr< RCanvas > Create (const std::string &title);  Create new canvas instance. ;  ; static const std::vector< std::shared_ptr< RCanvas > > GetCanvases ();  Returns list of created canvases. ;  ; static void ReleaseHeldCanvases ();  Release list of held canvases pointers If no other shared pointers exists on the canvas, object will be destroyed. ;  . Private Member Functions;  RCanvas (const RCanvas &)=delete;  Disable copy construction for now. ;  ; uint64_t IncModified ();  ; RCanvas & operator= (const RCanvas &)=delete;  Disable assignment",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvas.html:5587,clear,clearing,5587,doc/master/classROOT_1_1Experimental_1_1RCanvas.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvas.html,1,['clear'],['clearing']
Usability,"t style gStyle; 100```; 101 ; 102In your [rootlogon.C](https://root.cern/doc/master/classexamples/startsession.log.html); 103file, you can redefine the default parameters via statements like:; 104 ; 105```; 106 gStyle->SetStatX(0.7);; 107 gStyle->SetStatW(0.2);; 108 gStyle->SetLabelOffset(1.2);; 109 gStyle->SetLabelFont(72);; 110```; 111 ; 112Note that when an object is created, its attributes are taken from the current; 113style. For example, you may have created an histogram in a previous session,; 114saved it in a file. Meanwhile, if you have changed the style, the histogram will; 115be drawn with the old attributes. You can force the current style attributes to; 116be set when you read an object from a file by calling:; 117 ; 118```; 119gROOT->ForceStyle();; 120```; 121 ; 122before reading the objects from the file.; 123 ; 124Let's assume you have a canvas or pad with your histogram or any other object,; 125you can force these objects to get the attributes of the current style via:; 126 ; 127```; 128canvas->UseCurrentStyle();; 129```; 130 ; 131The description of the style functions should be clear from the name of the; 132TStyle Setters or Getters. Some functions have an extended description, in particular:; 133 ; 134 - TStyle:SetLabelFont.; 135 - TStyle:SetLineStyleString, to set the format of dashed lines.; 136 - TStyle:SetOptStat.; 137 - TStyle:SetPalette to change the colors palette.; 138 - TStyle:SetTitleOffset.; 139 ; 140*/; 141 ; 142////////////////////////////////////////////////////////////////////////////////; 143/// Default constructor.; 144 ; 145TStyle::TStyle() :TNamed(); 146{; 147 Reset();; 148}; 149 ; 150////////////////////////////////////////////////////////////////////////////////; 151/// Create a new TStyle.; 152/// The following names are reserved to create special styles:; 153///; 154/// - `Classic`: Similar to `Default` style set in TStyle::Reset; 155/// - `Plain`: a black&white oriented style; 156/// - `Bold`; 157/// - `Video`; 158/// - `Pu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStyle_8cxx_source.html:4142,clear,clear,4142,doc/master/TStyle_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStyle_8cxx_source.html,1,['clear'],['clear']
Usability,"t the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 554 of file h1analysis.h. ◆ Process(). Bool_t h1analysis::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used.; WARNING when a selector is used with a TChain, you must use the pointer to the current TTree to call GetEntry(entry). The entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use: fChain->GetTree()->GetEntry(entry). ; Reimplemented from TSelector. ◆ Reset(). void h1analysis::Reset ; (; ). Definition at line 376 of file h1analysis.h. ◆ SetInputList(). void h1analysis::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 356 of file h1analysis.h. ◆ SetObject(). void h1analysis::SetObject ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 355 of file h1analysis.h. ◆ SetOption(). void h1analysis::SetOptio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classh1analysis.html:22194,simpl,simple,22194,doc/master/classh1analysis.html,https://root.cern,https://root.cern/doc/master/classh1analysis.html,1,['simpl'],['simple']
Usability,"t tree. The tree name may contain; subdir specification in the form ""subdir/name"".; Returns 0 on success, -1 otherwise. Bool_t ExistsDataSet(const char* uri); Returns kTRUE if 'dataset' described by 'uri' exists, kFALSE otherwise. TMap * GetDataSets(const char* uri = """", const char* = 0); lists all datasets that match given uri. void ShowDataSets(const char* uri = """", const char* = 0); Shows datasets in locations that match the uri; By default shows the user's datasets and global ones. TFileCollection * GetDataSet(const char* uri, const char* = 0); Get a list of TFileInfo objects describing the files of the specified; dataset. Int_t RemoveDataSet(const char* uri, const char* = 0); Remove the specified dataset from the PROOF cluster.; Files are not deleted. Int_t VerifyDataSet(const char* uri, const char* = 0); Verify if all files in the specified dataset are available.; Print a list and return the number of missing files. void ClearDataSetCache(const char* dataset = 0); Clear the content of the dataset cache, if any (matching 'dataset', if defined). void ShowDataSetCache(const char* dataset = 0); Display the content of the dataset cache, if any (matching 'dataset', if defined). void SendInputDataFile(); Make sure that the input data objects are available to the workers in a; dedicated file in the cache; the objects are taken from the dedicated list; and / or the specified file.; If the fInputData is empty the specified file is sent over.; If there is no specified file, a file named ""inputdata.root"" is created locally; with the content of fInputData and sent over to the master.; If both fInputData and the specified file are not empty, a copy of the file; is made locally and augmented with the content of fInputData. Int_t Remove(const char* ref, Bool_t all); Handle remove request. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. void FindUniqueSlaves(); Add to the fUniqueSlave list the active slaves th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofLite.html:31615,Clear,ClearDataSetCache,31615,root/html532/TProofLite.html,https://root.cern,https://root.cern/root/html532/TProofLite.html,2,['Clear'],"['Clear', 'ClearDataSetCache']"
Usability,"t widgetId = -1); virtual~TEveGValuator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidBuild(Bool_t connect = kTRUE); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal = 0, void* receive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveGValuator.html:1514,Clear,Clear,1514,root/html532/TEveGValuator.html,https://root.cern,https://root.cern/root/html532/TEveGValuator.html,2,['Clear'],['Clear']
Usability,"t will check as well whether the document is well formated. ;  . Private Attributes; _xmlSAXHandler * fSAXHandler;  libxml2 SAX handler ;  . Friends; class TSAXParserCallback;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TXMLParser; virtual void InitializeContext ();  Initialize parser parameters, such as, disactivate non-standards libxml1 features, on/off validation, clear error and warning messages. ;  ; virtual void OnValidateError (const TString &message);  This function is called when an error from the parser has occurred. ;  ; virtual void OnValidateWarning (const TString &message);  This function is called when a warning from the parser has occurred. ;  ; virtual void ReleaseUnderlying ();  To release any existing document. ;  ; virtual void SetParseCode (Int_t code);  Set the parse code: ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  ;  Static Protected Member Functions inherited from TQObject; static Int_t CheckConne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSAXParser.html:16726,clear,clear,16726,doc/master/classTSAXParser.html,https://root.cern,https://root.cern/doc/master/classTSAXParser.html,1,['clear'],['clear']
Usability,"t with an application: the keyboard and the mouse. The Graphical User Interface is as a bridge between the user and the program - it provides methods to detect the user actions and instruments that do something as a reaction of these actions. The user communicates with an application through the window system. The window system reports interaction events to the application. The application in turn forwards them to the currently active window. The objects/widgets receive the events and react to them according to the application functionality. The signals/slot communication mechanism is an advanced object communication concept; it largely replaces the concept of callback functions to handle actions in GUI’s. Signals and slots are just like any object-oriented methods implemented in C++. The objects are the instances of classes that don’t know anything about each other. They interact and allow method calls of other object’s methods. The idea is simple: any object can send out (emit) a signal in certain situations saying that something happened. This is all it does to communicate and it does not know whether anything is interested in this information. On the other side there might be an object waiting for that signal and ready to react to it. This object disposes of special instruments to listen to the sent out signals. To have a communication we need a message transmission between the objects. In this simple example we use signals and slots. The code of the method TGButton::Clicked() is:; virtual void Clicked() { Emit(""Clicked()""); } // *SIGNAL*; I.e. any button emits the signal Clicked() any time someone clicks on it. As you can see this method is virtual and could be overridden if you need to. In our simple example we call the Connect() method to connect the Clicked() signal of Draw button with MyMainFrame::DoDraw():; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; In the same way we can connect to the signal Clicked() of the Exit button with the system ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1163605,simpl,simple,1163605,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"t x2, Double_t y2); virtual voidTH1::AddBinContent(Int_t bin); virtual voidTH1::AddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH2::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; voidChangePartition(Int_t n, Int_t m); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidClearBinContents(); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidTH2::Copy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2Poly.html:6658,Clear,Clear,6658,root/html602/TH2Poly.html,https://root.cern,https://root.cern/root/html602/TH2Poly.html,2,['Clear'],['Clear']
Usability,"t"",""Track.h;vector"");; gInterpreter->GenerateDictionary(""myclass"",""myheader.h"");. To generate the dictionary from a Makefile, you can use the following rule to generate a dictionary for the headers $(HEADERS) and a library containing the dictionary and the compiled $(SOURCES):. MyDict.cxx: $(HEADERS) Linkdef.h; [TAB] rootcint -f $@ -c $(CXXFLAGS) -p $^. libMyLib.so: MyDict.cxx $(SOURCES); [TAB] g++ -shared -o$@ `root-config --ldflags` $(CXXFLAGS) -I$(ROOTSYS)/include $^. See Interacting with Shared Libraries: rootcint for more details. ; . How can I fix the problem leading to :Error: Can't call vector<...>::push_back . This usually indicates that some classes dictionary refer and/or use this particular instance of std::vector. To solve the problem, you will need to generate a dictionary for this particular instance. With ROOT v5.27/06 and above this can be done by executing:gInterpreter->GenerateDictionary(""vector<Track&gt"",""Track.h;vector"");. With older version of ROOT ; this can simply be done using ACLiC and a simple loader.C script:// File loader.C; #include ; #include ; #ifdef __MAKECINT__; #pragma link C++ class vector<Track>+;; #endifI am defining a vector for my custom type (for example Track) in a root macro but when I push_back a Track object in the vector, CINT complains. e.g.; vector testVector;; Track obj;; ...; testVector.push_back(obj);; gives:Error: Can't call vector::push_back(timeStamp) in current scope MyAnalysisMasterTreeMaker.C:358:; Possible candidates are...; (in vector); *** Interpreter error recovered ***. Although, if I use a vector or vector or vector push_back works fine.; ; . What is the difference between a TFolder and a TDirectory? . TFolder manages a hierrachy of objects in memory.; TDirectory is doing it for a file.; One can save the TFolder structure to a directory in a file.; ; . Ubuntu: No backtrace (stacktrace) when ROOT crashes . Enable /proc/sys/kernel/yama/ptrace_scope or edit /etc/sysctl.d/10-ptrace.conf. See this blog entry ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/faq-page.html:3653,simpl,simply,3653,d/faq-page.html,https://root.cern,https://root.cern/d/faq-page.html,2,['simpl'],"['simple', 'simply']"
Usability,"t& fx, Int_t& fy); voidUndockContainer(); virtual voidUndocked()SIGNAL ; virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGDockableFrame(const TGDockableFrame&); TGDockableFrame&operator=(const TGDockableFrame&). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGDockableFrame.html:15886,Clear,ClearFlags,15886,root/html532/TGDockableFrame.html,https://root.cern,https://root.cern/root/html532/TGDockableFrame.html,2,['Clear'],['ClearFlags']
Usability,"t() const; Get output list. Int_t ReinitSelector(TQueryResult* qr); Reinitialize fSelector using the selector files in the query result.; Needed when Finalize is called after a Process execution for the same; selector name. Int_t AddOutputObject(TObject* obj); Incorporate output object (may not be used in this class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Int_t SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); Save the partial results of this query to a dedicated file under the user; data directory. The file name has the form; <session_tag>.q<query_seq_num>.root; The file pat and the file are created if not existing already.; Only objects in the outputlist not being TProofOutputFile are saved.; The packets list 'packets' is saved if given.; Trees not attached to any file are attached to the open file.; If 'queryend' is kTRUE evrything is written out (TTrees included).; The actual saving action is controlled by 'force' and by fSavePartialResults; fSaveResultsPerPacket:. fSavePartia",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:17507,feedback,feedback,17507,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,9,"['Feedback', 'feedback']","['Feedback', 'feedback']"
Usability,"t() const; Get output list. Int_t ReinitSelector(TQueryResult* qr); Reinitialize fSelector using the selector files in the query result.; Needed when Finalize is called after a Process execution for the same; selector name. Int_t AddOutputObject(TObject* obj); Incorporate output object (may not be used in this class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF worker.; The return value is -1 in case of error and TSelector::GetStatus(); in case of success. Bool_t CheckMemUsage(Long64_t& mfreq, Bool_t& w80r, Bool_t& w80v, TString& wmsg); Check the memory usage, if requested.; Return kTRUE if OK, kFALSE if above 95% of at least one between virtual or; resident limits are depassed. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); Finalize query (may not be used in this class). Long64_t Finalize(TQueryResult* qr); Finalize query (may not be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayer.html:16148,feedback,feedback,16148,root/html528/TProofPlayer.html,https://root.cern,https://root.cern/root/html528/TProofPlayer.html,5,"['Feedback', 'feedback']","['Feedback', 'feedback']"
Usability,"t(0.5);; h2bh->SetStats(0);; for (i=1;i<=nx;i++) h2bh->Fill(os_X[i-1].c_str(), d_35_1[i-1]);. h2bh->Draw(""hbar same"");. return cbh;; }; TH2Poly Drawing; The following options are supported:. ""SCAT""; Draw a scatter plot (default). ""COL""; Draw a color plot. All the none empty bins are painted. Empty bins are not; painted. ""COLZ""; Same as ""COL"". In addition the color palette is also drawn. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTN""; Draw bin names as text. ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""L""; Draw the bins boundaries as lines.; The lines attibutes are the TGraphs ones. ""P""; Draw the bins boundaries as markers.; The markers attibutes are the TGraphs ones. ""F""; Draw the bins boundaries as filled polygons.; The filled polygons attibutes are the TGraphs ones. TH2Poly can; be drawn as a color plot (option COL). TH2Poly bins can have any; shapes. The bins are defined as graphs. The following macro is a very simple; example showing how to book a TH2Poly and draw it. Picture; Source. {; TCanvas *ch2p1 = new TCanvas(""ch2p1"",""ch2p1"",600,400);; TH2Poly *h2p = new TH2Poly();; h2p->SetName(""h2poly_name"");; h2p->SetTitle(""h2poly_title"");; Double_t px1[] = {0, 5, 6};; Double_t py1[] = {0, 0, 5};; Double_t px2[] = {0, -1, -1, 0};; Double_t py2[] = {0, 0, -1, 3};; Double_t px3[] = {4, 3, 0, 1, 2.4};; Double_t py3[] = {4, 3.7, 1, 3.7, 2.5};; h2p->AddBin(3, px1, py1);; h2p->AddBin(4, px2, py2);; h2p->AddBin(5, px3, py3);; h2p->Fill(0.1, 0.01, 3);; h2p->Fill(-0.5, -0.5, 7);; h2p->Fill(-0.7, -0.5, 1);; h2p->Fill(1, 3, 1.5);; Double_t fx[] = {0.1, -0.5, -0.7, 1};; Double_t fy[] = {0.01, -0.5, -0.5, 3};; Double_t fw[] = {3, 1, 1, 1.5};; h2p->FillN(4, fx, fy, fw);; gStyle->SetPalette(57);; h2p->Draw(""col"");; return ch2p1;; }; Rectangular bins are a frequent case. The special version of; the AddBin method allows to define them more easily like; shown in the following example. Picture; Source. //This tutorial illustrates ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THistPainter.html:62735,simpl,simple,62735,root/html604/THistPainter.html,https://root.cern,https://root.cern/root/html604/THistPainter.html,2,['simpl'],['simple']
Usability,"t(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFFTConvPdf.html:7523,clear,clearValueAndShapeDirty,7523,root/html534/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html534/RooFFTConvPdf.html,6,['clear'],['clearValueAndShapeDirty']
Usability,"t(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFeedback(TList* objs)SIGNAL ; voidTProofPlayer::FeedBackCanvas(const char* name, Bool_t create); virtual Long64_tFinalize(TQueryResult* qr); virtual Long64_tFinalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tTProofPlayer::GetCacheSize(); virtual TQueryResult*TProofPlayer::GetCurrentQuery() const; virtual Int_tTProofPlayer::GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tTProofPlayer::GetEventsProcessed() const; virtual TVirtualProofPlayer::EExitStatusTProofPlayer::GetExitStatus() const; virtual const char*TObject::GetIconName() const; virtual TList*TProofPlayer::GetInputList() const; virtual Int_tTProofPlayer::GetLearnEntries(); TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; virtual TList*TProofPlayer::G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofPlayerRemote.html:5092,FeedBack,FeedBackCanvas,5092,root/html532/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html532/TProofPlayerRemote.html,2,['FeedBack'],['FeedBackCanvas']
Usability,"t). During Undo, they are executed in reverse order (last in first out).; Undo manager. TQUndoManager is recorder of undo and redo operations. This is command history list which can be traversed backwards and upwards performing undo and redo operations. To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);; TQCommand::TQUndoManagerfriend class TQUndoManagerDefinition TQCommand.h:29; TQUndoManagerRecorder of operations for undo and redo.Definition TQCommand.h:103; TQUndoManager::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the stack of commands.Definition TQCommand.cxx:959; TQUndoManager::Add automatically invokes execution of command's Redo method. Use TQUndoManager::Undo to undo commands in history list. Redo is Undo for undo action. Use TQUndoManager::Redo method for that ; Definition at line 27 of file TQCommand.h. Public Member Functions;  TQCommand (const char *cl=nullptr, void *object=nullptr, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ;  TQCommand (const TQCommand &com);  Copy constructor. ;  ;  TQCommand (TObject *obj, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ; virtual ~TQCommand ();  dtor. ;  ; void Add (TObject *obj) override;  ; void Add (TObject *obj, Option_t *opt) override;  Add command to the list of merged commands. ;  ; virtual Bool_t CanCompress (TQCommand *c) const;  By default, commands can be compressed if they are: ;  ; virtual Bool_t CanMerge (TQCommand *c) const;  Two commands can be merged if they can be composed into a single command (Macro command). ;  ; virtual Bool_t CanRedo () const;  Returns kTRUE if Redo action is possible, kFALSE if it's not. ;  ; virtual Bool_t CanUndo () const;  Returns kTRUE if Undo action is possible, kFALSE if it's not. ;  ; virtual void Compress (TQCommand *c);  Compress command. ;  ; void Delete (Option_t *option="""") override;  If ""opt"" is not zero delete every",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:4802,undo,undo,4802,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"t).; Event- or Entry-lists should be set in the data set object using; TDSet::SetEntryList.; Returns -1 in case of error or number of selected events otherwise. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Int_t CreateSymLinks(TList* files); Create in each worker sandbox symlinks to the files in the list; Used to make the caceh information available to workers. Int_t InitDataSetManager(); Initialize the dataset manager from directives or from defaults; Return 0 on success, -1 on failure. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove files from all file caches. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Copy the specified macro in the cache directory. The macro file is; uploaded if new or updated. If existing, the corresponding header; basename(macro).h or .hh, is also uploaded. For the other arguments; see TProof::Load().; Returns 0 in case of success and -1 in case of error. Int_t CopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0); Copy a macro, and its possible associated .h[h] file,; to the cache directory, from where the workers can get the file.; If headerRequired is 1, return -1 in case the header is not found.; If headerRequired is 0, try to copy header too.; If headerRequired is -1, don't look for header, only copy macro.; If the selector pionter is not 0, consider the macro to be a selector; and try to load the selector and set it to the pointer.; The mask 'opt' is an or of ESendFileO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofLite.html:28772,Clear,ClearCache,28772,root/html532/TProofLite.html,https://root.cern,https://root.cern/root/html532/TProofLite.html,1,['Clear'],['ClearCache']
Usability,"t).; Event- or Entry-lists should be set in the data set object using; TDSet::SetEntryList.; Returns -1 in case of error or number of selected events otherwise. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Int_t CreateSymLinks(TList* files); Create in each worker sandbox symlinks to the files in the list; Used to make the cache information available to workers. Int_t InitDataSetManager(); Initialize the dataset manager from directives or from defaults; Return 0 on success, -1 on failure. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove files from all file caches. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Copy the specified macro in the cache directory. The macro file is; uploaded if new or updated. If existing, the corresponding header; basename(macro).h or .hh, is also uploaded. For the other arguments; see TProof::Load().; Returns 0 in case of success and -1 in case of error. Int_t CopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0); Copy a macro, and its possible associated .h[h] file,; to the cache directory, from where the workers can get the file.; If headerRequired is 1, return -1 in case the header is not found.; If headerRequired is 0, try to copy header too.; If headerRequired is -1, don't look for header, only copy macro.; If the selector pionter is not 0, consider the macro to be a selector; and try to load the selector and set it to the pointer.; The mask 'opt' is an or of ESendFileO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofLite.html:32306,Clear,ClearCache,32306,root/html602/TProofLite.html,https://root.cern,https://root.cern/root/html602/TProofLite.html,1,['Clear'],['ClearCache']
Usability,"t); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tShutdown(); virtual Bool_tStartTransaction(); virtual TSQLStatement*Statement(const char* sql, Int_t = 100); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMySQLServer(const TMySQLServer&); TMySQLServer(const char* db, const char* uid, const char* pw); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTSQLServer::ClearError(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidTSQLServer::SetError(Int_t code, const char* msg, const char* method = 0). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_BINARY; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_CHAR; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_DOUBLE; static TSQLServer::ESQLDataTypesTSQLServer::kSQL_FLOAT; static TSQLServer::ESQLDataTypesTSQLServer::kS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMySQLServer.html:7384,Clear,ClearError,7384,root/html602/TMySQLServer.html,https://root.cern,https://root.cern/root/html602/TMySQLServer.html,2,['Clear'],['ClearError']
Usability,"t* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTObjArray::AddAt(TObject* obj, Int_t idx); virtual voidTObjArray::AddAtAndExpand(TObject* obj, Int_t idx); virtual Int_tTObjArray::AddAtFree(TObject* obj); virtual voidTObjArray::AddBefore(const TObject* before, TObject* obj); virtual voidTObjArray::AddFirst(TObject* obj); virtual voidTObjArray::AddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*TObjArray::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TObjArray::At(Int_t idx) const; virtual TObject*TObjArray::Before(const TObject* obj) const; TIterTCollection::begin() const; virtual Int_tTObjArray::BinarySearch(TObject* obj, Int_t upto = kMaxInt); virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObjArray::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidTObjArray::Compress(); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObjArray::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRefArray.html:2279,Clear,Clear,2279,root/html602/RooRefArray.html,https://root.cern,https://root.cern/root/html602/RooRefArray.html,4,['Clear'],['Clear']
Usability,"t* option = """"); virtual Bool_tTH1::Add(const TH1* h, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; virtual voidTH1::AddBinContent(Int_t bin); virtual voidTH1::AddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTH1::Browse(TBrowser* b); virtual Int_tBufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH2.html:1833,Clear,Clear,1833,root/html534/TH2.html,https://root.cern,https://root.cern/root/html534/TH2.html,2,['Clear'],['Clear']
Usability,"t* working_space, Int_t num, Int_t hartley, Int_t direction, Int_t zt_clear). AUXILIARY FUNCION. This function calculates Fourier based transform of a part of data; Function parameters:; -working_space-pointer to vector of transformed data; -num-length of processed data; -hartley-1 if it is Hartley transform, 0 othewise; -direction-forward or inverse transform. void BitReverseHaar(Double_t* working_space, Int_t shift, Int_t num, Int_t start). AUXILIARY FUNCION. This function carries out bir-reverse reordering for Haar transform; Function parameters:; -working_space-pointer to vector of processed data; -shift-shift of position of processing; -start-initial position of processed data; -num-length of processed data. Int_t GeneralExe(Double_t* working_space, Int_t zt_clear, Int_t num, Int_t degree, Int_t type). AUXILIARY FUNCION. This function calculates generalized (mixed) transforms of different degrees; Function parameters:; -working_space-pointer to vector of transformed data; -zt_clear-flag to clear imaginary data before staring; -num-length of processed data; -degree-degree of transform (see manual); -type-type of mixed transform (see manual). Int_t GeneralInv(Double_t* working_space, Int_t num, Int_t degree, Int_t type). AUXILIARY FUNCION. This function calculates inverse generalized (mixed) transforms; Function parameters:; -working_space-pointer to vector of transformed data; -num-length of processed data; -degree-degree of transform (see manual); -type-type of mixed transform (see manual). void HaarWalsh2(Double_t** working_matrix, Double_t* working_vector, Int_t numx, Int_t numy, Int_t direction, Int_t type). AUXILIARY FUNCION. This function calculates 2D Haar and Walsh transforms; Function parameters:; -working_matrix-pointer to matrix of transformed data; -working_vector-pointer to vector where the data are processed; -numx,numy-lengths of processed data; -direction-forward or inverse; -type-type of transform (see manual). void FourCos2(Double_t** working_m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum2Transform.html:11950,clear,clear,11950,root/html602/TSpectrum2Transform.html,https://root.cern,https://root.cern/root/html602/TSpectrum2Transform.html,4,['clear'],['clear']
Usability,"t, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; voidTGLPlotPainter::SetDrawAxes(Bool_t s); voidTGLPlotPainter::SetDrawBackBox(Bool_t b); voidTGLPlotPainter::SetDrawFrontBox(Bool_t b); virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); voidTGLPlotPainter::SetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLTF3Painter(const TGLTF3Painter&); TGLTF3Painter(TGLTF3Painter&&); TGLTF3Painter(TF3* fun, TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; virtual voidTGLPlotPainter::DrawPaletteAxis() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlotPainter::RestoreProjectionMatrix() const; voidTGLPlotPainter::SaveModelviewMatrix() const; voidTGLPlotPainter::SaveProjectionMatrix() const. private:. virtual voidDeInitGL() const; voidDrawDefaultPlot() const; voidDrawMaplePlot() const; virtual voidDrawPlot() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; voidDrawToSelectionBuffer() const; Bool_tHasSections() const; virtual voidInitGL() const; voidSetSurfaceColor() const. Data Members; public:. static TGLPlotPainter::ECutAxisIDTGLPlotPainter::kXAxis; static TGLPlotPainter::ECutAxisIDTGLPlotPainter::kYAxis; static TGLPlotPainter::ECutAxisIDTGLPlotPainter::kZAxis. protected:. TGLPlotBoxTGLPlotPainter::fBackBox; TGLBoxCutTGLPlotPainter::fBoxCut; TGLPlotCamera*TGLPlotPainter::fCamera; TGLPlotCoordinates*TGLPlotPainter::fCoord; Bool_tTGLPlotPainter::fDrawAxes; Bool_tTGLP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLTF3Painter.html:1753,Clear,ClearBuffers,1753,root/html602/TGLTF3Painter.html,https://root.cern,https://root.cern/root/html602/TGLTF3Painter.html,2,['Clear'],['ClearBuffers']
Usability,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecExtraEvent(); TRecExtraEvent(const TRecExtraEvent&); ~TRecExtraEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRecExtraEvent.html:2399,pause,pause,2399,root/html528/TRecExtraEvent.html,https://root.cern,https://root.cern/root/html528/TRecExtraEvent.html,6,['pause'],['pause']
Usability,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecGuiEvent(); TRecGuiEvent(const TRecGuiEvent&); ~TRecGuiEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static Event_t*CreateEvent(TRecGuiEvent* ge); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRecGuiEvent.html:2419,pause,pause,2419,root/html528/TRecGuiEvent.html,https://root.cern,https://root.cern/root/html528/TRecGuiEvent.html,6,['pause'],['pause']
Usability,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecWinPair(const TRecWinPair&); TRecWinPair(Window_t key, Window_t value); ~TRecWinPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRecWinPair.html:2414,pause,pause,2414,root/html528/TRecWinPair.html,https://root.cern,https://root.cern/root/html528/TRecWinPair.html,6,['pause'],['pause']
Usability,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecorder(); TRecorder(const TRecorder&); TRecorder(const char* filename, Option_t* option = ""READ""); virtual~TRecorder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRecorder.html:2408,pause,pause,2408,root/html528/TRecorder.html,https://root.cern,https://root.cern/root/html528/TRecorder.html,4,['pause'],['pause']
Usability,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecorder(); TRecorder(const char* filename, Option_t* option = ""READ""); virtual~TRecorder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMEN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRecorder.html:2408,pause,pause,2408,root/html534/TRecorder.html,https://root.cern,https://root.cern/root/html534/TRecorder.html,2,['pause'],['pause']
Usability,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. virtual~TRecExtraEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecExtraEvent.html:2449,pause,pause,2449,root/html602/TRecExtraEvent.html,https://root.cern,https://root.cern/root/html602/TRecExtraEvent.html,4,['pause'],['pause']
Usability,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. virtual~TRecGuiEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static Event_t*CreateEvent(TRecGuiEvent* ge); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecGuiEvent.html:2443,pause,pause,2443,root/html602/TRecGuiEvent.html,https://root.cern,https://root.cern/root/html602/TRecGuiEvent.html,4,['pause'],['pause']
Usability,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. virtual~TRecWinPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """"",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecWinPair.html:2438,pause,pause,2438,root/html602/TRecWinPair.html,https://root.cern,https://root.cern/root/html602/TRecWinPair.html,4,['pause'],['pause']
Usability,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. virtual~TRecorder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecorder.html:2432,pause,pause,2432,root/html602/TRecorder.html,https://root.cern,https://root.cern/root/html602/TRecorder.html,4,['pause'],['pause']
Usability,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TRecEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecEvent.html:2432,pause,pause,2432,root/html602/TRecEvent.html,https://root.cern,https://root.cern/root/html602/TRecEvent.html,4,['pause'],['pause']
Usability,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TRecorderState(); static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidListCmd(const char*); virtual voidListGui(const char*); TRecorderState&operator=(const TRecorderState&); virtual voidPause(TRecorder*); virtual voidPrevCanvases(const char*, Option_t*); virtual Bool_tReplay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder*); virtual voidResume(TRecorder*); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStart(TRecorder*, const char*, Option_t*, Window_t*, Int_t)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecorderState.html:2431,pause,pause,2431,root/html602/TRecorderState.html,https://root.cern,https://root.cern/root/html602/TRecorderState.html,4,['pause'],['pause']
Usability,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TRecorderState(); static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidListCmd(const char*); virtual voidListGui(const char*); TRecorderState&operator=(const TRecorderState&); virtual voidPause(TRecorder*); virtual voidPrevCanvases(const char*, Option_t*); virtual Bool_tReplay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder*); virtual voidResume(TRecorder*); virtual voidShowMembers(TMemberInspector& insp); virtual voidStart(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRecorderState.html:2381,pause,pause,2381,root/html528/TRecorderState.html,https://root.cern,https://root.cern/root/html528/TRecorderState.html,4,['pause'],['pause']
Usability,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TRecorderState(); static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidListCmd(const char*); virtual voidListGui(const char*); TRecorderState&operator=(const TRecorderState&); virtual voidPause(TRecorder*); virtual voidPrevCanvases(const char*, Option_t*); virtual Bool_tReplay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder*); virtual voidResume(TRecorder*); virtual voidShowMembers(TMemberInspector&); virtual voidStart(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRecorderState.html:2383,pause,pause,2383,root/html534/TRecorderState.html,https://root.cern,https://root.cern/root/html534/TRecorderState.html,2,['pause'],['pause']
Usability,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TRecEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRecEvent.html:2382,pause,pause,2382,root/html528/TRecEvent.html,https://root.cern,https://root.cern/root/html528/TRecEvent.html,6,['pause'],['pause']
Usability,"t, it will be changed even on the graphs already defined; gStyle->SetTimeOffset(script_time);. TCanvas *ct = new TCanvas(""ct"",""Time on axis"",10,10,700,900);; ct->Divide(1,3);; ct->SetFillColor(28);. int i;. //======= Build a signal : noisy damped sine ======; // Time interval : 30 minutes. gStyle->SetTitleH(0.08);; float noise;; TH1F *ht = new TH1F(""ht"",""Love at first sight"",3000,0.,2000.);; for (i=1;i<3000;i++) {; noise = gRandom->Gaus(0,120);; if (i>700) {; noise += 1000*sin((i-700)*6.28/30)*exp((double)(700-i)/300);; }; ht->SetBinContent(i,noise);; }; ct->cd(1);; gPad->SetFillColor(41);; gPad->SetFrameFillColor(33);; ht->SetLineColor(2);; ht->GetXaxis()->SetLabelSize(0.05);; ht->Draw();; // Sets time on the X axis; // The time used is the one set as time offset added to the value; // of the axis. This is converted into day/month/year hour:min:sec and; // a reasonnable tick interval value is chosen.; ht->GetXaxis()->SetTimeDisplay(1);. //======= Build a simple graph beginning at a different time ======; // Time interval : 5 seconds. float x[100], t[100];; for (i=0;i<100;i++) {; x[i] = sin(i*4*3.1415926/50)*exp(-(double)i/20);; t[i] = 6000+(double)i/20;; }; TGraph *gt = new TGraph(100,t,x);; gt->SetTitle(""Politics"");; ct->cd(2);; gPad->SetFillColor(41);; gPad->SetFrameFillColor(33);; gt->SetFillColor(19);; gt->SetLineColor(5);; gt->SetLineWidth(2);; gt->Draw(""AL"");; gt->GetXaxis()->SetLabelSize(0.05);; // Sets time on the X axis; gt->GetXaxis()->SetTimeDisplay(1);; gPad->Modified();. //======= Build a second simple graph for a very long time interval ======; // Time interval : a few years. float x2[10], t2[10];; for (i=0;i<10;i++) {; x2[i] = gRandom->Gaus(500,100)*i;; t2[i] = i*365*86400;; }; TGraph *gt2 = new TGraph(10,t2,x2);; gt2->SetTitle(""Number of monkeys on the moon"");; ct->cd(3);; gPad->SetFillColor(41);; gPad->SetFrameFillColor(33);; gt2->SetFillColor(19);; gt2->SetMarkerColor(4);; gt2->SetMarkerStyle(29);; gt2->SetMarkerSize(1.3);; gt2->Draw(""AP"");; gt2->G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGaxis.html:19056,simpl,simple,19056,root/html604/TGaxis.html,https://root.cern,https://root.cern/root/html604/TGaxis.html,2,['simpl'],['simple']
Usability,"t.; Those events will not be used for the minimization but for control.; Note that the tree must be already defined. void SetLearningMethod(TMultiLayerPerceptron::ELearningMethod method); Sets the learning method.; Available methods are: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS.; (look at the constructor for the complete description; of learning methods and parameters). void SetEta(Double_t eta); Sets Eta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEpsilon(Double_t eps); Sets Epsilon - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetDelta(Double_t delta); Sets Delta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEtaDecay(Double_t ed); Sets EtaDecay - Eta *= EtaDecay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at the constructor for the complete description; of learning methods and parameters). void GetEntry(Int_t ) const; Load an entry into the network. void Train(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); Train the network.; nEpoch is the number of iterations.; option can contain:; - ""text"" (simple text output); - ""graph"" (evoluting graphical training curves); - ""update=X"" (step for the text/graph output update); - ""+"" will skip the randomisation and start from the previous values.; - ""current"" (draw in the current canvas); - ""minErrorTrain"" (stop when NN error on the training sample gets below minE; - ""minErrorTest",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:24282,learn,learning,24282,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,10,['learn'],['learning']
Usability,"t.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  box.cxxThis ROOT 7 example demonstrates how to create a ROOT 7 canvas (RCanvas) and draw ROOT 7 boxes in it (RBox) ;  concurrentfill.cxx;  draw.cxx;  draw_mt.cxxThis macro demonstrate usage of ROOT7 graphics from many threads Three different canvases in three different threads are started and regularly updated ;  draw_rh1.cxxThis macro generates a small V7 TH1D, fills it and draw it in a V7 canvas ;  draw_subpads.cxx;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  line.cxxThis ROOT 7 example demonstrates how to create a ROOT 7 canvas (RCanvas) and draw ROOT 7 lines in it (RLine) ;  lineStyle.cxx;  lineWidth.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  vo004_SortAndSelect.C In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo004_SortAndSelect.py In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo005_Combinations.C In this tutorial we learn how combinations of RVecs can be build ;  vo005_Combinations.py In this tutorial we learn how combinations of RVecs can be build ;  vo006_IndexManipulation.C In this tutorial we demonstrate RVec helpers for index manipulation ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlmo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:172213,learn,learn,172213,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['learn'],['learn']
Usability,"t::DataRange &range);  fitting function for a MultiGraph (called from TMultiGraph::Fit) ;  ; void FitOptionsMake (EFitObjectType type, const char *option, Foption_t &fitOption);  Decode list of options into fitOption. ;  ; bool GetConfidenceIntervals (const TH1 *h1, const ROOT::Fit::FitResult &r, TGraphErrors *gr, double cl=0.95);  compute confidence intervals at level cl for a fitted histogram h1 in a TGraphErrors gr ;  ; BinData::ErrorType GetDataType (const TGraph *gr, DataOptions &fitOpt);  ; BinData::ErrorType GetDataType (const TGraph2D *gr, const DataOptions &fitOpt);  ; void Init2DGaus (const ROOT::Fit::BinData &data, TF1 *f1);  compute initial parameter for 2D gaussian function given the fit data Set the sigma limits for zero top 10* initial rms values Set the initial parameter values in the TF1 ;  ; void InitExpo (const ROOT::Fit::BinData &data, TF1 *f1);  compute initial parameter for an exponential function given the fit data Set the constant and slope assuming a simple exponential going through xmin and xmax of the data set ;  ; void InitGaus (const ROOT::Fit::BinData &data, TF1 *f1);  compute initial parameter for gaussian function given the fit data Set the sigma limits for zero top 10* initial rms values Set the initial parameter values in the TF1 ;  ; bool lessRange (const std::pair< double, double > &r1, const std::pair< double, double > &r2);  ; ostream & operator<< (ostream &os, const ROOT::Fit::Box &b);  ; TFitResultPtr UnBinFit (ROOT::Fit::UnBinData *data, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption);  fit an unbin data set (from tree or from histogram buffer) using a TF1 pointer and fit options. ;  . Variables; double gDefaultErrorDef = ROOT::Math::MinimizerOptions::DefaultErrorDef();  ; const int gInitialResultStatus = -99;  . Detailed Description; Namespace for the fitting classes. ; Typedef Documentation. ◆ Chi2Function. typedef Chi2FCN<ROOT::Math::IMultiGenFunction,ROOT::Math::IParamMultiFunction> ROOT::Fit::Chi2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Fit.html:7285,simpl,simple,7285,doc/master/namespaceROOT_1_1Fit.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Fit.html,2,['simpl'],['simple']
Usability,"t::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero delete every merged command which option string is; equal to ""opt"". If ""opt"" is zero - delete all merged commands. Bool_t CanMerge(TQCommand* c) const; Two commands can be merged if they can be composed into; a single command (Macro command). To allow merging commands user might override this function. void Merge(TQCommand* c); Add command to the list of merged commands.; This make it possible to group complex actions together so an end user; can undo and redo them with one command. Execution of TQUndoManager::Undo(),; TQUndoManager::Redo() methods only invokes the top level command as a whole. Merge method is analogous to logical join operation. Note: Merge method invokes redo action. void Add(TObject* obj, Option_t* opt); Add command to the list of merged commands. Option string can contain substrings:; ""compress"" - try to compress input command; ""radd"" - execute redo action of input command; ""uadd"" - execute undo action of input command. Bool_t CanCompress(TQCommand* c) const; By default, commands can be compressed if they are:. - equal; - setter commands. More complicated commands might want to override this function. void Compress(TQCommand* c); Compress command. Compression is analogous to arithmetic ""addition operation"". Note:; - The compressed command will be deleted.; - Execution Compress method invokes Redo action with new redo arguments; inheritied from compressed command. More complicated commands might want to override this function. Bool_t IsEqual(const TObject* obj) const; Equal comparison. The commands are equal if they are; applied to the same object and have the same Redo/Undo actions. More complicated commands might want to override this function. Bool_t IsSetter() const; Returns kTRUE is command if Redo is the same as Undo function; and is the setter action. By default, all functions with names like ""SetXXX"" or ""se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:20649,undo,undo,20649,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,1,['undo'],['undo']
Usability,"t::FitData>fFitData! data of the fit (managed by TBackCompFitter); auto_ptr<ROOT::Fit::Fitter>fFitter! pointer to fitter object (managed by TBackCompFitter); ROOT::Math::Minimizer*fMinimizer; ROOT::Math::IParamMultiFunction*fModelFunc; ROOT::Math::IMultiGenFunction*fObjFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBackCompFitter(); Constructur needed by TVirtualFitter interface. Same behavior as default constructor.; initialize setting name and the global pointer. TBackCompFitter(auto_ptr<ROOT::Fit::Fitter> fitter, auto_ptr<ROOT::Fit::FitData> data); constructor used after having fit using directly ROOT::Fit::Fitter; will create a dummy fitter copying configuration and parameter settings. ~TBackCompFitter(); data are own here; if (fFitData) delete fFitData;. Double_t Chisquare(Int_t npar, Double_t* params) const; do chisquare calculations in case of likelihood fits; do evaluation a the minimum only. void Clear(Option_t* option = """"); clear resources for consecutive fits. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); execute the command (Fortran Minuit compatible interface). bool ValidParameterIndex(int ipar) const; check if ipar is a valid parameter index. void FixParameter(Int_t ipar); fix the paramter; std::cout<<""FixParameter""<<std::endl;. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.94999999999999996); Computes confidence intervals at level cl. Default is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBackCompFitter.html:13397,clear,clear,13397,root/html602/TBackCompFitter.html,https://root.cern,https://root.cern/root/html602/TBackCompFitter.html,3,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"t::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveEventManager(const char* n = ""TEveEventManager"", const char* t = """"); Constructor. void AfterNewEventLoaded(); Virtual function to be called after a new event is loaded.; It iterates over the list of registered commands; (fNewEventCommands) and executes them in given order. void AddNewEventCommand(const TString& cmd); Register a command to be executed on each new event. void RemoveNewEventCommand(const TString& cmd); Remove the first command equal to cmd. void ClearNewEventCommands(); Clear the list of commands to be executed on each new event. virtual ~TEveEventManager(); {}. std::vector<TString>& GetNewEventCommands(); { return fNewEventCommands; }. void Open(); {}. void GotoEvent(Int_t ); {}. void NextEvent(); {}. void PrevEvent(); {}. void Close(); {}. » Last changed: root/eve:$Id: TEveEventManager.h 27157 2009-01-15 14:05:12Z brun $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveEventManager.html:20405,Clear,ClearNewEventCommands,20405,root/html532/TEveEventManager.html,https://root.cern,https://root.cern/root/html532/TEveEventManager.html,2,['Clear'],"['Clear', 'ClearNewEventCommands']"
Usability,"t; 537{; 538 std::vector<Double_t> cMin( GetNvar() );; 539 std::vector<Double_t> cMax( GetNvar() );; 540 Double_t trueEffS = GetCuts( effS, cMin, cMax );; 541 for (UInt_t ivar=0; ivar<GetNvar(); ivar++) {; 542 cutMin[ivar] = cMin[ivar];; 543 cutMax[ivar] = cMax[ivar];; 544 }; 545 return trueEffS;; 546}; 547 ; 548////////////////////////////////////////////////////////////////////////////////; 549/// retrieve cut values for given signal efficiency; 550 ; 551Double_t TMVA::MethodCuts::GetCuts( Double_t effS,; 552 std::vector<Double_t>& cutMin,; 553 std::vector<Double_t>& cutMax ) const; 554{; 555 // find corresponding bin; 556 Int_t ibin = fEffBvsSLocal->FindBin( effS );; 557 ; 558 // get the true efficiency which is the one on the ""left hand"" side of the bin; 559 Double_t trueEffS = fEffBvsSLocal->GetBinLowEdge( ibin );; 560 ; 561 ibin--; // the 'cut' vector has 0...fNbins indices; 562 if (ibin < 0 ) ibin = 0;; 563 else if (ibin >= fNbins) ibin = fNbins - 1;; 564 ; 565 cutMin.clear();; 566 cutMax.clear();; 567 for (UInt_t ivar=0; ivar<GetNvar(); ivar++) {; 568 cutMin.push_back( fCutMin[ivar][ibin] );; 569 cutMax.push_back( fCutMax[ivar][ibin] );; 570 }; 571 ; 572 return trueEffS;; 573}; 574 ; 575////////////////////////////////////////////////////////////////////////////////; 576/// training method: here the cuts are optimised for the training sample; 577 ; 578void TMVA::MethodCuts::Train( void ); 579{; 580 if (fEffMethod == kUsePDFs) CreateVariablePDFs(); // create PDFs for variables; 581 ; 582 // create binary trees (global member variables) for signal and background; 583 if (fBinaryTreeS != 0) { delete fBinaryTreeS; fBinaryTreeS = 0; }; 584 if (fBinaryTreeB != 0) { delete fBinaryTreeB; fBinaryTreeB = 0; }; 585 ; 586 // the variables may be transformed by a transformation method: to coherently; 587 // treat signal and background one must decide which transformation type shall; 588 // be used: our default is signal-type; 589 ; 590 fBinaryTreeS = new BinarySearchTree(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:21263,clear,clear,21263,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['clear'],['clear']
Usability,"t; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; static voidblockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); const TMatrixDSym&covarianceMatrix() const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMultiVarGaussian.html:3011,clear,clearEvalErrorLog,3011,root/html526/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html526/RooMultiVarGaussian.html,1,['clear'],['clearEvalErrorLog']
Usability,"t; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumConvPdf.html:4911,clear,clearValueAndShapeDirty,4911,root/html532/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html532/RooNumConvPdf.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"t; virtual Int_tbasisCode(const char* name) const; const RooRealVar&basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooResolutionModel.html:4349,clear,clearEvalErrorLog,4349,root/html528/RooResolutionModel.html,https://root.cern,https://root.cern/root/html528/RooResolutionModel.html,1,['clear'],['clearEvalErrorLog']
Usability,"t; virtual Int_tbasisCode(const char* name) const; const RooRealVar&basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooResolutionModel.html:4349,clear,clearEvalErrorLog,4349,root/html530/RooResolutionModel.html,https://root.cern,https://root.cern/root/html530/RooResolutionModel.html,1,['clear'],['clearEvalErrorLog']
Usability,"t; virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); voidDrawNeedle(); voidDrawText(); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); TGWindow&TGWindow::operator=(const TGWindow& tgw); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE); voidTranslate(Float_t val, Float_t angle, Int_t* x, Int_t* y). Data Members; public:. enum EGlowColor { kNoglow; kGreen; kOrange; kRed; };; enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGSpeedo.html:15162,Clear,ClearFlags,15162,root/html532/TGSpeedo.html,https://root.cern,https://root.cern/root/html532/TGSpeedo.html,2,['Clear'],['ClearFlags']
Usability,"t; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidDrawBottomLeft(); virtual voidDrawBottomRight(); virtual voidDrawCenterX(); virtual voidDrawCenterY(); virtual voidDrawExpandX(); virtual voidDrawExpandY(); virtual voidDrawTopLeft(); virtual voidDrawTopRight(); virtual voidTGButton::EmitSignals(Bool_t wasUp); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); TGWindow&TGWindow::operator=(const TGWindow& tgw); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGButton::SetToggleButton(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGuiBldHintsButton.html:15086,Clear,ClearFlags,15086,root/html532/TGuiBldHintsButton.html,https://root.cern,https://root.cern/root/html532/TGuiBldHintsButton.html,2,['Clear'],['ClearFlags']
Usability,"t;  Returns state of flag determining if the element will be destroyed when reference count reaches zero. ;  ; virtual TObject * GetEditorObject (const TEveException &eh) const;  ; virtual TString GetHighlightTooltip ();  ; virtual const TGPicture * GetListTreeCheckBoxIcon ();  Returns list-tree-item check-box picture appropriate for given rendering state. ;  ; virtual const TGPicture * GetListTreeIcon (Bool_t open=kFALSE);  Returns pointer to first listtreeicon. ;  ; virtual Color_t GetMainColor () const;  ; Color_t * GetMainColorPtr () const;  ; virtual Char_t GetMainTransparency () const;  ; TEveElement * GetMaster ();  Returns the master element - that is: ;  ; virtual Int_t GetNItems () const;  ; Int_t GetParentIgnoreCnt () const;  Get number of parents that should be ignored in doing reference-counting. ;  ; virtual TObject * GetRenderObject (const TEveException &eh) const;  ; virtual Bool_t GetRnrAnything () const;  ; virtual Bool_t GetRnrChildren () const;  ; virtual Bool_t GetRnrSelf () const;  ; virtual Bool_t GetRnrState () const;  ; virtual UChar_t GetSelectedLevel () const;  Get selection level, needed for rendering selection and highlight feedback. ;  ; TRef & GetSource ();  ; TObject * GetSourceObject () const;  ; void * GetUserData () const;  ; TEveElement * GetVizModel () const;  ; const TString & GetVizTag () const;  ; Bool_t HasChild (TEveElement *el);  Check if element el is a child of this element. ;  ; Bool_t HasChildren () const;  ; virtual Bool_t HasMainColor () const;  ; virtual Bool_t HasMainTrans () const;  ; Bool_t HasParents () const;  ; virtual void HighlightElement (Bool_t state);  Set element's highlight state. Stamp appropriately. ;  ; void IncDenyDestroy ();  Increases the deny-destroy count of the element. ;  ; virtual void IncImpliedHighlighted ();  Increase element's implied-highlight count. Stamp appropriately. ;  ; virtual void IncImpliedSelected ();  Increase element's implied-selection count. Stamp appropriately. ;  ; void In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveProjectionManager.html:12132,feedback,feedback,12132,doc/master/classTEveProjectionManager.html,https://root.cern,https://root.cern/doc/master/classTEveProjectionManager.html,1,['feedback'],['feedback']
Usability,"t;  Returns state of flag determining if the element will be destroyed when reference count reaches zero. ;  ; virtual TObject * GetEditorObject (const TEveException &eh) const;  ; virtual TString GetHighlightTooltip ();  ; virtual const TGPicture * GetListTreeCheckBoxIcon ();  Returns list-tree-item check-box picture appropriate for given rendering state. ;  ; virtual const TGPicture * GetListTreeIcon (Bool_t open=kFALSE);  Returns pointer to first listtreeicon. ;  ; virtual Color_t GetMainColor () const;  ; Color_t * GetMainColorPtr () const;  ; virtual Char_t GetMainTransparency () const;  ; TEveElement * GetMaster ();  Returns the master element - that is: ;  ; virtual Int_t GetNItems () const;  ; Int_t GetParentIgnoreCnt () const;  Get number of parents that should be ignored in doing reference-counting. ;  ; virtual TObject * GetRenderObject (const TEveException &eh) const;  ; virtual Bool_t GetRnrAnything () const;  ; virtual Bool_t GetRnrChildren () const;  ; virtual Bool_t GetRnrSelf () const;  ; virtual Bool_t GetRnrState () const;  ; virtual UChar_t GetSelectedLevel () const;  Get selection level, needed for rendering selection and highlight feedback. ;  ; TRef & GetSource ();  ; TObject * GetSourceObject () const;  ; void * GetUserData () const;  ; TEveElement * GetVizModel () const;  ; const TString & GetVizTag () const;  ; virtual Bool_t HandleElementPaste (TEveElement *el);  React to element being pasted or dnd-ed. ;  ; Bool_t HasChild (TEveElement *el);  Check if element el is a child of this element. ;  ; Bool_t HasChildren () const;  ; virtual Bool_t HasMainColor () const;  ; virtual Bool_t HasMainTrans () const;  ; Bool_t HasParents () const;  ; virtual void HighlightElement (Bool_t state);  Set element's highlight state. Stamp appropriately. ;  ; void IncDenyDestroy ();  Increases the deny-destroy count of the element. ;  ; virtual void IncImpliedHighlighted ();  Increase element's implied-highlight count. Stamp appropriately. ;  ; virtual void I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveBox.html:11899,feedback,feedback,11899,doc/master/classTEveBox.html,https://root.cern,https://root.cern/doc/master/classTEveBox.html,27,['feedback'],['feedback']
Usability,"t<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; static voidblockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); const TMatrixDSym&covarianceMatrix() const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMultiVarGaussian.html:2970,clear,clearEvalError,2970,root/html526/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html526/RooMultiVarGaussian.html,1,['clear'],['clearEvalError']
Usability,"t>& other, RooAbsArg* owner = 0); Int_tsetObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidsterilize(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. Int_t_lastIndex! Last slot accessed; Int_t_maxSize! Maximum size; vector<RooNormSetCache>_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_size! Actual use; Bool_t_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCacheManager_RooAbsCacheElement_.html:3576,Clear,Clear,3576,root/html602/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html602/RooCacheManager_RooAbsCacheElement_.html,2,['Clear'],['Clear']
Usability,"tAddRange); {; return mustAddRange ? df.Range(1) : df;; }; // use as :; ROOT::RDataFrame df(10);; auto maybeRangedDF = MaybeAddRange(df, true);; The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function ROOT.RDF.AsRNode. Storing RDataFrame objects in collections; ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a std::vector<RNode> or a std::map<std::string, RNode>:; std::vector<ROOT::RDF::RNode> dfs;; dfs.emplace_back(ROOT::RDataFrame(10));; dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));. Executing callbacks every N events; It's possible to schedule execution of arbitrary functions (callbacks) during the event loop. Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running, drawing a partially-filled histogram every time a certain number of new entries is processed, or displaying a progress bar while the event loop runs.; For example one can draw an up-to-date version of a result histogram every 100 entries like this: auto h = df.Histo1D(""x"");; TCanvas c(""c"",""x hist"");; h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; // event loop runs here, this final `Draw` is executed after the event loop is finished; h->Draw();; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:669; Callbacks are registered to a ROOT::RDF::RResultPtr and must be callables that takes a reference to the result type as argument and return nothing. RDataFrame will invoke registered callbacks passing partial action results as arguments to them (e.g. a histogram filled with a part of the selected events).; Read more on ROOT::RDF::RResultPtr::OnPartialResult() and ROOT::RDF::RResultPtr::OnPartialResultSlot(). Default ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:60112,progress bar,progress bar,60112,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['progress bar'],['progress bar']
Usability,"tAddRange); {; return mustAddRange ? df.Range(1) : df;; }; // use as :; ROOT::RDataFrame df(10);; auto maybeRangedDF = MaybeAddRange(df, true);; The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function ROOT.RDF.AsRNode. Storing RDataFrame objects in collections; ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a std::vector<RNode> or a std::map<std::string, RNode>:; std::vector<ROOT::RDF::RNode> dfs;; dfs.emplace_back(ROOT::RDataFrame(10));; dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));. Executing callbacks every N events; It's possible to schedule execution of arbitrary functions (callbacks) during the event loop. Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running, drawing a partially-filled histogram every time a certain number of new entries is processed, or displaying a progress bar while the event loop runs.; For example one can draw an up-to-date version of a result histogram every 100 entries like this: auto h = df.Histo1D(""x"");; TCanvas c(""c"",""x hist"");; h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; // event loop runs here, this final `Draw` is executed after the event loop is finished; h->Draw();; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; Callbacks are registered to a ROOT::RDF::RResultPtr and must be callables that takes a reference to the result type as argument and return nothing. RDataFrame will invoke registered callbacks passing partial action results as arguments to them (e.g. a histogram filled with a part of the selected events).; Read more on ROOT::RDF::RResultPtr::OnPartialResult() and ROOT::RDF::RResultPtr::OnPartialResultSlot(). Default ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:61534,progress bar,progress bar,61534,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['progress bar'],['progress bar']
Usability,"tBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveStraightLineSet.html:3083,Clear,ClearStamps,3083,root/html532/TEveStraightLineSet.html,https://root.cern,https://root.cern/root/html532/TEveStraightLineSet.html,4,['Clear'],['ClearStamps']
Usability,"tBBox(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTEveStraightLineSet::ComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* recei",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveScalableStraightLineSet.html:3184,Clear,ClearStamps,3184,root/html532/TEveScalableStraightLineSet.html,https://root.cern,https://root.cern/root/html532/TEveScalableStraightLineSet.html,8,['Clear'],['ClearStamps']
Usability,"tBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCLsCleanupThreshold(Double_t th); virtual voidSetConfidenceLevel(Double_t cl); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetInterpolationOption(RooStats::HypoTestInverterResult::InterpolOption_t opt); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetTestSize(Double_t size); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const char* name = 0); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const RooStats::SimpleInterval&); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const RooStats::SimpleInterval& other, const char* name); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const char* name, const RooRealVar& var, Double_t lower, Double_t upper, Double_t cl); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Double_tUpperLimit(); Double_tUpperLimitEstimatedError(); voidUseCLs(bool on = true); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestInverterResult.html:6994,Simpl,SimpleIntervalRooStats,6994,root/html534/RooStats__HypoTestInverterResult.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestInverterResult.html,1,['Simpl'],['SimpleIntervalRooStats']
Usability,"tBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Protected Member Functions; void AddToSscp (TMatrixD &sscp, TVectorD &vec);  update the sscp matrix with vector vec ;  ; void Classic ();  called when h=n. ;  ; void ClearSscp (TMatrixD &sscp);  clear the sscp matrix, used for covariance and mean calculation ;  ; void Correl ();  transforms covariance matrix into correlation matrix ;  ; void Covar (TMatrixD &sscp, TVectorD &m, TMatrixDSym &cov, TVectorD &sd, Int_t nvec);  calculates mean and covariance ;  ; void CreateOrtSubset (TMatrixD &dat, Int_t *index, Int_t hmerged, Int_t nmerged, TMatrixD &sscp, Double_t *ndist);  creates a subset of hmerged vectors with smallest orthogonal distances to the hyperplane hyp[1]*(x1-mean[1])+...+hyp[nvar]*(xnvar-mean[nvar])=0 This function is called in case when less than fH samples lie on a hyperplane. ;  ; void CreateSubset (Int_t ntotal, Int_t htotal, Int_t p, Int_t *index, TMatrixD &data, TMatrixD &sscp, Double_t *ndist);  creates a subset of htotal elements from ntotal elements first, p+1 elements are drawn randomly(without repetitions) if their covariance matrix is singular, more elements are added one by one, until their covariance matrix becomes regular or it becomes clear that htotal observations lie on a hyperplane If covariance matrix determinant!=0, distances of all ntotal elements are calculated, using formula d_i=Sqrt((x_i-M)*S_inv*(x_i-M)), where M is mean and S_inv is the inverse of the covariance",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRobustEstimator.html:14849,clear,clear,14849,doc/master/classTRobustEstimator.html,https://root.cern,https://root.cern/doc/master/classTRobustEstimator.html,1,['clear'],['clear']
Usability,"tBrush create QBrush object based on the ROOT ""fill"" attributes; TQtClientFilter Map Qt and ROOT event; TQtClientWidget QFrame implementation backing ROOT TGWindow objects; TQtMarker Convert ROOT TMarker objects on to QPointArray; TQtPadFont < Create Qt QFont object based on ROOT TAttText attributes; TQtRootGuiFactory Factory for Qt-based ROOT GUI components; TQtRootSlot ; TQtTimer QTimer to awake the ROOT event loop from Qt event loop; TQtWidget QWidget to back ROOT TCanvas (Can be used with Qt designer); TQuaternion a quaternion class; TQueryDescription Query description; TQueryResult Class describing a query; TQueryResultManager PROOF query result manager; TROOT Top level (or root) structure for all classes; TRWLock Reader/writer lock; TRadialGradient Radial gradient fill.; TRandom Simple Random number generator (periodicity = 10**9); TRandom1 Ranlux Random number generators with periodicity > 10**14; TRandom2 Random number generator with periodicity of 10**26; TRandom3 Random number generator: Mersenne Twister; TRealData Description of persistent data members; TRecCmdEvent Class stores information about 1 commandline event (= 1 command typed by user in commandline); TRecEvent Abstract class. Defines basic interface for storing information about ROOT events; TRecExtraEvent Class stores information about extra events; TRecGuiEvent Class stores information about 1 GUI event in ROOT; TRecWinPair Class used for storing of window IDs mapping. Needed for replaying events.; TRecorder Class provides direct recorder/replayer interface for a user.; TRecorderInactive Represents state of TRecorder after its creation; TRecorderPaused Represents state of TRecorder when paused; TRecorderRecording Represents state of TRecorder when recording events; TRecorderReplaying Represents state of TRecorder when replaying; TRecorderState Abstract class that defines interface for a state of recorder; TRedirectOutputGuard Exception safe output redirection; TRef Persistent Reference link to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:120611,Simpl,Simple,120611,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['Simpl'],['Simple']
Usability,"tCache.h. ◆ RooExpensiveObjectCache() [2/2]. RooExpensiveObjectCache::RooExpensiveObjectCache ; (; const RooExpensiveObjectCache & ; other). inline . Definition at line 28 of file RooExpensiveObjectCache.h. ◆ ~RooExpensiveObjectCache(). RooExpensiveObjectCache::~RooExpensiveObjectCache ; (; ). override . Destructor. ; Definition at line 45 of file RooExpensiveObjectCache.cxx. Member Function Documentation. ◆ Class(). static TClass * RooExpensiveObjectCache::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooExpensiveObjectCache::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooExpensiveObjectCache::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 81 of file RooExpensiveObjectCache.h. ◆ clearAll(). void RooExpensiveObjectCache::clearAll ; (; ). Clear all cache elements. ; Definition at line 164 of file RooExpensiveObjectCache.cxx. ◆ clearObj(). bool RooExpensiveObjectCache::clearObj ; (; Int_t ; uniqueID). Clear cache element with given unique ID Retrieve payload object of cache element with given unique ID. ; Definition at line 131 of file RooExpensiveObjectCache.cxx. ◆ DeclFileName(). static const char * RooExpensiveObjectCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 81 of file RooExpensiveObjectCache.h. ◆ empty(). bool RooExpensiveObjectCache::empty ; (; ); const. inline . Definition at line 44 of file RooExpensiveObjectCache.h. ◆ getObj(). const TObject * RooExpensiveObjectCache::getObj ; (; Int_t ; uniqueID). Retrieve payload object of cache element with given unique ID. ; Definition at line 115 of file RooExpensiveObjectCache.cxx. ◆ importCacheObjects(). void RooExpensiveObjectCache::importCacheObjects ; (; RooExpensiveObjectCache & ; other, . const char * ; ownerName, . bool ; verbose = false . ). Definition at line 296 of file RooExpens",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExpensiveObjectCache.html:12943,clear,clearObj,12943,doc/master/classRooExpensiveObjectCache.html,https://root.cern,https://root.cern/doc/master/classRooExpensiveObjectCache.html,1,['clear'],['clearObj']
Usability,"tCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Bool_tfColourfulOutputflag for use of colors; TMVA::MsgLogger*fLoggerthe output logger; Int_tfNcountsreference number of ""counts"" ; TStringfPrefixprefix for outputs; static const TStringfgClassNameused for output; static const Int_tfgNbinsnumber of bins in progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE); constructor. Timer(Int_t ncounts, const char* prefix = """", Bool_t colourfulOutput = kTRUE); standard constructor: ncounts gives the total number of counts that; the loop will iterate through. At each call of the timer, the current; number of counts is provided by the user, so that the timer can obtain; the due time from linearly interpolating the spent time. ~Timer( void ); destructor. void Init(Int_t ncounts); timer initialisation. void Reset( void ); resets timer. Double_t ElapsedSeconds( void ); computes elapsed tim in seconds. TString GetElapsedTime(Bool_t Scientific = kTRUE); returns pretty string with elaplsed time. TString GetLeftTime(Int_t icounts); returns pretty string with time left. void DrawProgressBar(); draws the progressbar. void DrawProgressBar(TString ); draws a string in the progress bar. void DrawProgressBar(Int_t , const TString& comment = """"); draws progress bar in color or B&W; caution:. TString SecToText(Double_t , Bool_t ) const; pretty string output. Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2006: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__Timer.html:7626,progress bar,progress bar,7626,root/html534/TMVA__Timer.html,https://root.cern,https://root.cern/root/html534/TMVA__Timer.html,4,['progress bar'],['progress bar']
Usability,"tClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGProgressBar(const TGWindow* p, UInt_t w, UInt_t h, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame); Create progress bar. void SetRange(Float_t min, Float_t max); Set min and max of progress bar. void SetPosition(Float_t pos); Set progress position between [min,max]. void Increment(Float_t inc); Increment progress position. void Reset(); Reset progress bar (i.e. set pos to 0). void SetFillType(TGProgressBar::EFillType type); Set fill type. void SetBarType(TGProgressBar::EBarType type); Set bar type. void SetBarColor(ULong_t color); Set progress bar color. void SetBarColor(const char* color = ""blue""); Set progress bar color. void Format(const char* format = ""%.2f""); Set format for displaying a value. FontStruct_t GetDefaultFontStruct(); Return default font structure in use. const TGGC & GetDefaultGC(); Return default graphics context in use. void SetForegroundColor(Pixel_t pixel); Change text color drawing. void SavePrimitive(ostream& out, Option_t* option = """"); Save progress bar parameters as a C++ statement(s) on output stream out. Bool_t fDrawBar; // if true draw only bar in DoRedraw(). TGProgressBar(const TGWindow* p, UInt_t w, UInt_t h, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame); { }. Float_t GetMin() const; { return fMin; }. Float_t GetMax() const; { return fMax; }. Float_t GetPosition() const; { return fPos; }. EFillType GetFillType() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGProgressBar.html:21203,progress bar,progress bar,21203,root/html602/TGProgressBar.html,https://root.cern,https://root.cern/root/html602/TGProgressBar.html,4,['progress bar'],['progress bar']
Usability,"tColor () const;  ; const char * GetTitle () const override;  Returns title of object. ;  ; virtual TGToolTip * GetToolTip () const;  ; Bool_t HandleButton (Event_t *event) override;  Handle mouse button event in text entry widget. ;  ; Bool_t HandleConfigureNotify (Event_t *event) override;  Handles resize events for this widget. ;  ; Bool_t HandleCrossing (Event_t *event) override;  Handle mouse crossing event. ;  ; Bool_t HandleDoubleClick (Event_t *event) override;  Handle mouse double click event in the text entry widget. ;  ; Bool_t HandleFocusChange (Event_t *event) override;  Handle focus change event in text entry widget. ;  ; Bool_t HandleKey (Event_t *event) override;  The key press event handler converts a key press to some line editor action. ;  ; Bool_t HandleMotion (Event_t *event) override;  Handle mouse motion event in the text entry widget. ;  ; Bool_t HandleSelection (Event_t *event) override;  Handle text selection event. ;  ; Bool_t HandleSelectionClear (Event_t *event) override;  Handle selection clear event. ;  ; Bool_t HandleSelectionRequest (Event_t *event) override;  Handle request to send current clipboard contents to requestor window. ;  ; Bool_t HandleTimer (TTimer *t) override;  Handle cursor blink timer. ;  ; Bool_t HasMarkedText () const;  ; Bool_t HasOwnFont () const;  ; void Home (Bool_t mark=kFALSE);  Moves the text cursor to the left end of the line. ;  ; virtual void Insert (const char *);  Removes any currently selected text, inserts newText, sets it as the new contents of the text entry. ;  ; virtual void InsertText (const char *text, Int_t pos);  Inserts text at position pos, clears the selection and moves the cursor to the end of the line. ;  ; TClass * IsA () const override;  ; Bool_t IsEdited () const;  ; Bool_t IsFrameDrawn () const;  ; void Layout () override;  ; void MarkWord (Int_t pos);  Marks the word nearest to cursor position. ;  ; Int_t MaxMark () const;  ; Int_t MinMark () const;  ; void NewMark (Int_t pos);  New c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGNumberEntryField.html:7650,clear,clear,7650,doc/master/classTGNumberEntryField.html,https://root.cern,https://root.cern/doc/master/classTGNumberEntryField.html,2,['clear'],['clear']
Usability,"tCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero delete every merged command which option string is; equal to ""opt"". If ""opt"" is zero - delete all merged commands. Bool_t CanMerge(TQCommand* c) const; Two commands can be merged if they can be composed into; a single command (Macro command). To allow merging commands user might override this function. void Merge(TQCommand* c); Add command to the list of merged commands.; This make it possible to group complex actions together so an end user; can undo and redo them with one command. Execution of TQUndoManager::Undo(),; TQUndoManager::Redo() methods only invokes the top level command as a whole. Merge method is analogous to logical join operation. Note: Merge method invokes redo action. Long64_t Merge(TCollection* , TFileMergeInfo* ); Merge a collection of TQCommand. void Add(TObject* obj, Option_t* opt); Add command to the list of merged commands. Option string can contain substrings:; ""compress"" - try to compress input command; ""radd"" - execute redo action of input command; ""uadd"" - execute undo action of input command. Bool_t CanCompress(TQCommand* c) const; By default, commands can be compressed if they are:. - equal; - setter commands. More complicated commands might want to override this function. void Compress(TQCommand* c); Compress command. Compression is analogous to arithmetic ""addition operation"". Note:; - The compressed command will be deleted.; - Execution Compress method invokes Redo action wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TQCommand.html:20348,undo,undo,20348,root/html530/TQCommand.html,https://root.cern,https://root.cern/root/html530/TQCommand.html,9,['undo'],['undo']
Usability,"tCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero delete every merged command which option string is; equal to ""opt"". If ""opt"" is zero - delete all merged commands. Bool_t CanMerge(TQCommand* c) const; Two commands can be merged if they can be composed into; a single command (Macro command). To allow merging commands user might override this function. void Merge(TQCommand* c); Add command to the list of merged commands.; This make it possible to group complex actions together so an end user; can undo and redo them with one command. Execution of TQUndoManager::Undo(),; TQUndoManager::Redo() methods only invokes the top level command as a whole. Merge method is analogous to logical join operation. Note: Merge method invokes redo action. void Add(TObject* obj, Option_t* opt); Add command to the list of merged commands. Option string can contain substrings:; ""compress"" - try to compress input command; ""radd"" - execute redo action of input command; ""uadd"" - execute undo action of input command. Bool_t CanCompress(TQCommand* c) const; By default, commands can be compressed if they are:. - equal; - setter commands. More complicated commands might want to override this function. void Compress(TQCommand* c); Compress command. Compression is analogous to arithmetic ""addition operation"". Note:; - The compressed command will be deleted.; - Execution Compress method invokes Redo action with new redo arguments; inheritied from compressed command. More complicated comman",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:20175,undo,undo,20175,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,1,['undo'],['undo']
Usability,"tConfig::SetMinimizer(""minimizerName"") or by using directly the ROOT:Math::MinimizerOptions class.; If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the static function ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName""); 5.7.4 Minimizer Libraries and Algorithms; The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following one. Some minimizers (e.g. Minuit) contain several algorithms that the user can choose. Others are based on a single algorithm (e.g. Fumili). Minuit (library libMinuit). Old version of Minuit, based on the TMinuit class. The list of possible algorithms are:. Migrad (default one); Simplex; Minimize (it is a combination of Migrad and Simplex); MigradImproved; Scan; Seek. Minuit2 (library libMinuit2). New C++ version of Minuit. The list of possible algorithm is :. Migrad (default); Simplex; Minimize; Scan; Fumili . This is the same algorithm of TFumili, but implemented in the Minuit2 library. Fumili. Implement a dedicated minimization algorithm for least-square and likelihood fits. It has requirements on the type of method function to be used. No specific algorithm exists; GSLMultiMin (library libMathMore). Minimizer based on the Multidimensional Minimization routines of the Gnu Scientific Library (GSL). The list of available algorithms is. BFGS2 (default) : second version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; BFGS : old version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; ConjugateFR : Fletcher-Reeves conjugate gradient algorithm;; ConjugatePR : Polak-Ribiere conjugate gradient algorithm;; SteepestDescent: steepest descent algorithm;. GSLMultiFit (library libMathMore). Minimizer based on the Non-Linear Least-Square routines of GSL. This minimizer can be used only for least-square fits.; GSLSimAn (library libMathMore). Mi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:202764,Simpl,Simplex,202764,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Simpl'],['Simplex']
Usability,"tDaily = (TTree*)f->Get(name);; TStockDaily *data = 0;; tDaily->SetBranchAddress(""daily"",&data);; TBranch *b_closeAdj = tDaily->GetBranch(""fCloseAdj"");; TBranch *b_date = tDaily->GetBranch(""fDate"");; ; //read only the ""adjusted close"" branch for all entries; const Int_t nrEntries = (Int_t)tDaily->GetEntries();; TArrayF closeAdj(nrEntries);; for (Int_t i = 0; i < nrEntries; i++) {; b_date->GetEntry(i);; b_closeAdj->GetEntry(i);; if (data->fDate >= sDay && data->fDate <= eDay); closeAdj[i] = data->fCloseAdj/100.;; }; ; TArrayF *r = new TArrayF(nrEntries-1);; for (Int_t i = 1; i < nrEntries; i++); // (*r)[i-1] = closeAdj[i]-closeAdj[i-1];; (*r)[i-1] = closeAdj[i]/closeAdj[i-1];; ; return *r;; }; ; #ifndef __MAKECINT__; //---------------------------------------------------------------------------; TVectorD OptimalInvest(Double_t riskFactor,TVectorD r,TMatrixDSym Covar); {; // what the quadratic programming package will do:; //; // minimize c^T x + ( 1/2 ) x^T Q x; // subject to A x = b; // clo <= C x <= cup; // xlo <= x <= xup; // what we want :; //; // maximize c^T x - k ( 1/2 ) x^T Q x; // subject to sum_x x_i = 1; // 0 <= x_i; ; // We have nrStocks weights to determine,; // 1 equality- and 0 inequality- equations (the simple square boundary; // condition (xlo <= x <= xup) does not count); ; const Int_t nrVar = nrStocks;; const Int_t nrEqual = 1;; const Int_t nrInEqual = 0;; ; // flip the sign of the objective function because we want to maximize; TVectorD c = -1.*r;; TMatrixDSym Q = riskFactor*Covar;; ; // equality equation; TMatrixD A(nrEqual,nrVar); A = 1;; TVectorD b(nrEqual); b = 1;; ; // inequality equation; //; // - although not applicable in the current situation since nrInEqual = 0, one; // has to specify not only clo and cup but also an index vector iclo and icup,; // whose values are either 0 or 1 . If iclo[j] = 1, the lower boundary condition; // is active on x[j], etc. ...; ; TMatrixD C (nrInEqual,nrVar);; TVectorD clo (nrInEqual);; TVectorD cup (nrInEqual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:8062,simpl,simple,8062,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,1,['simpl'],['simple']
Usability,"tEditor constructor with pointer to a TMacro as first argument. ~TGTextEditor(); TGTextEditor destructor. void DeleteWindow(); Delete TGTextEditor Window. void Build(); Build TGTextEditor widget. void DataDropped(char* fname); Update file information when receiving the signal; DataDropped from TGTextEdit widget. void DataChanged(); Slot setting the fTextChanged flag to true when the text has been; modified in fTextEdit. void LoadFile(const char* fname = 0); Load a file into the editor. If fname is 0, a TGFileDialog will popup. void SaveFile(const char* fname); Save the edited text in the file ""fname"". Bool_t SaveFileAs(); Save the edited text in a file selected with TGFileDialog.; Shouldn't we create a backup file?. Int_t IsSaved(); Check if file has to be saved in case of modifications. void PrintText(); Open the print dialog and send current buffer to printer. void CloseWindow(); Close TGTextEditor window. Bool_t HandleKey(Event_t* event); Keyboard event handler. void ClearText(); Clear text edit widget. void Search(Bool_t ret); Invokes search dialog, or just search previous string if again is true. void Goto(); Invokes goto dialog, and go to the specified line. void CompileMacro(); Save the edited text in a temporary macro, then compile it. void ExecuteMacro(); Save the edited text in a temporary macro, execute it, and then delete; the temporary file. void InterruptMacro(); Interrupt execution of a macro. void About(); Display ROOT splash screen. Bool_t HandleTimer(TTimer* t); Handle timer event. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other command generated by the user. TGTextEditor(const char* filename = 0, const TGWindow* p = 0, UInt_t w = 900, UInt_t h = 600). Bool_t LoadBuffer(const char* buf); { return fTextEdit->LoadBuffer(buf); }. void SetText(TGText* text); { fTextEdit->SetText(text); }. void AddText(TGText* text); { fTextEdit->AddText(text); }. void AddLine(const char* string); { fTextEdit->AddLine(string); }. voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTextEditor.html:29266,Clear,ClearText,29266,root/html602/TGTextEditor.html,https://root.cern,https://root.cern/root/html602/TGTextEditor.html,4,['Clear'],"['Clear', 'ClearText']"
Usability,"tEmbeddedCanvas *fEcanvas;; public:; MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h);; virtual ~MyMainFrame();; void DoDraw();; };; MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h) {; // Create a main frame; fMain = new TGMainFrame(p,w,h);. // Create canvas widget; fEcanvas = new TRootEmbeddedCanvas(""Ecanvas"",fMain,200,200);; fMain->AddFrame(fEcanvas, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY, 10,10,10,1));; // Create a horizontal frame widget with buttons; TGHorizontalFrame *hframe = new TGHorizontalFrame(fMain,200,40);; TGTextButton *draw = new TGTextButton(hframe,""&Draw"");; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; hframe->AddFrame(draw, new TGLayoutHints(kLHintsCenterX,; 5,5,3,4));; TGTextButton *exit = new TGTextButton(hframe,""&Exit"",; ""gApplication->Terminate(0)"");; hframe->AddFrame(exit, new TGLayoutHints(kLHintsCenterX,; 5,5,3,4));; fMain->AddFrame(hframe, new TGLayoutHints(kLHintsCenterX,; 2,2,2,2));. // Set a name to the main frame; fMain->SetWindowName(""Simple Example"");. // Map all subwindows of main frame; fMain->MapSubwindows();. // Initialize the layout algorithm; fMain->Resize(fMain->GetDefaultSize());. // Map main frame; fMain->MapWindow();; }; void MyMainFrame::DoDraw() {; // Draws function graphics in randomly chosen interval; TF1 *f1 = new TF1(""f1"",""sin(x)/x"",0,gRandom->Rndm()*10);; f1->SetLineWidth(3);; f1->Draw();; TCanvas *fCanvas = fEcanvas->GetCanvas();; fCanvas->cd();; fCanvas->Update();; }; MyMainFrame::~MyMainFrame() {; // Clean up used widgets: frames, buttons, layout hints; fMain->Cleanup();; delete fMain;; }; void example() {; // Popup the GUI...; new MyMainFrame(gClient->GetRoot(),200,200);; }; The TGMainFrameclass defines a top level window that interacts with the system window manager. Its method CloseWindow() is invoked when Alt+F4 are pressed or a window manager close/exit command is used. To terminate the application when this happens you need to override the CloseWindow() method and call g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1133638,Simpl,Simple,1133638,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Simpl'],['Simple']
Usability,"tEntries(); // read the number of entries in the t3; 253 ; 254 for (Long64_t i = 0; i < nentries; i++) {; 255 new_v = gRandom->Gaus(0, 1);; 256 newBranch->Fill();; 257 }; 258 ; 259 t3->Write("""", TObject::kOverwrite); // save only the new version of the tree; 260 }; 261~~~; 262It is not always possible to add branches to existing datasets stored in TFiles: for example,; 263these files might not be writeable, just readable. In addition, modifying in place a TTree; 264causes a new TTree instance to be written and the previous one to be deleted.; 265For this reasons, ROOT offers the concept of friends for TTree and TChain:; 266if is good practice to rely on friend trees rather than adding a branch manually.; 267 ; 268\anchor fullexample; 269## An Example; 270 ; 271Begin_Macro; 272../../../tutorials/tree/tree.C; 273End_Macro; 274 ; 275~~~ {.cpp}; 276 // A simple example with histograms and a tree; 277 //; 278 // This program creates :; 279 // - a one dimensional histogram; 280 // - a two dimensional histogram; 281 // - a profile histogram; 282 // - a tree; 283 //; 284 // These objects are filled with some random numbers and saved on a file.; 285 ; 286 #include ""TFile.h""; 287 #include ""TH1.h""; 288 #include ""TH2.h""; 289 #include ""TProfile.h""; 290 #include ""TRandom.h""; 291 #include ""TTree.h""; 292 ; 293 //__________________________________________________________________________; 294 main(int argc, char **argv); 295 {; 296 // Create a new ROOT binary machine independent file.; 297 // Note that this file may contain any kind of ROOT objects, histograms,trees; 298 // pictures, graphics objects, detector geometries, tracks, events, etc..; 299 // This file is now becoming the current directory.; 300 TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");; 301 ; 302 // Create some histograms and a profile histogram; 303 TH1F hpx(""hpx"",""This is the px distribution"",100,-4,4);; 304 TH2F hpxpy(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; 305 TProfile hprof(""hprof"",""Pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:13180,simpl,simple,13180,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['simpl'],['simple']
Usability,"tErrHi, const double *arraySumW2) override;  ; std::size_t size () const;  Get size of stored dataset. ;  ; void Streamer (TBuffer &) override;  Stream an object of class RooVectorDataStore. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; double sumEntries () const override;  ; double weight () const override;  Return the weight of the last-retrieved data point. ;  ; virtual double weight () const=0;  ; double weight (Int_t index) const;  ; void weightError (double &lo, double &hi, RooAbsData::ErrorType etype=RooAbsData::Poisson) const override;  ; double weightError (RooAbsData::ErrorType etype=RooAbsData::Poisson) const override;  Return the error of the current weight. ;  ; Internal RooFit interface.; The classes and functions in the internal RooFit interface are implementation details and not part of the public user interface.; Everything in this group might change without warning. . ArraysStruct getArrays () const;  Exports all arrays in this RooVectorDataStore into a simple datastructure to be used by RooFit internal export functions. ;  ; void recomputeSumWeight ();  Trigger a recomputation of the cached weight sums. ;  ;  Public Member Functions inherited from RooAbsDataStore;  RooAbsDataStore ();  ;  RooAbsDataStore (const RooAbsDataStore &other, const char *newname=nullptr);  ;  RooAbsDataStore (const RooAbsDataStore &other, const RooArgSet &vars, const char *newname=nullptr);  ;  RooAbsDataStore (RooStringView name, RooStringView title, const RooArgSet &vars);  ; RooArgSet * addColumns (const RooArgList &varList);  ; const RooArgSet & cachedVars () const;  ; virtual void checkInit () const;  ; int defaultPrintContents (Option_t *) const override;  Define default print options, for a given print style. ;  ; bool dirtyProp () const;  ; void Print (Option_t *options=nullptr) const override;  This method must be overridden when a class wants to print itself. ;  ; void printArgs (std::ostream &os) const override;  Print argument of datase",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:6487,simpl,simple,6487,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,1,['simpl'],['simple']
Usability,"tEvent. Reads both from CmdTree and GuiTree and chooses that event that becomes; earlier; - fCmdTreeCounter determines actual position in fCmdTree; - fGuiTreeCounter determines actual position in fCmdTree. If GUI event should be replayed, we must first make sure that there is; appropriate mapping for this event. RETURN VALUE:; kFALSE = there is no event to be replayed; kTRUE = there is still at least one event to be replayed. Cases:; - fNextEvent = 0 => We are waiting for the appropriate; window to be registered; - fNextEvent != 0 => fNextEvent can be replayed (windows are; ready). Bool_t CanOverlap(); ButtonPress and ButtonRelease must be sometimes replayed more times; Example: pressing of a button opens small window and user chooses; something from that window (color); Window must be opened while user is choosing. void ReplayRealtime(); Replays the next event. It is called when fTimer times out.; Every time fTimer is set again to time equal to time difference between; current two events being replayed. It can happen that execution of an event lasts different time during the; recording and during the replaying.; If fTimer times out too early and the previous event has not been yet; replayed, it is usually postponed in order; to keep events execution in the right order.; The excpetions are determined by TRecorderReplaying::CanOverlap(). void Pause(TRecorder* r); Pauses replaying. void ReplayStop(TRecorder* r); Cancels replaying. void Continue(); Continues previously paused replaying. TRecorder & operator=(const TRecorderReplaying& ). TRecorder::ERecorderState GetState() const; Gets current state of recorder. TRecorderReplaying(const char* filename). » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 16:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRecorderReplaying.html:6281,pause,paused,6281,root/html604/TRecorderReplaying.html,https://root.cern,https://root.cern/root/html604/TRecorderReplaying.html,4,"['Pause', 'pause']","['Pause', 'Pauses', 'paused']"
Usability,"tEvent. Reads both from CmdTree and GuiTree and chooses that event that becomes; earlier; - fCmdTreeCounter determines actual position in fCmdTree; - fGuiTreeCounter determines actual position in fCmdTree. If GUI event should be replayed, we must first make sure that there is; appropriate mapping for this event. RETURN VALUE:; kFALSE = there is no event to be replayed; kTRUE = there is still at least one event to be replayed. Cases:; - fNextEvent = 0 => We are waiting for the appropriate; window to be registered; - fNextEvent != 0 => fNextEvent can be replayed (windows are; ready). Bool_t CanOverlap(); ButtonPress and ButtonRelease must be sometimes replayed more times; Example: pressing of a button opens small window and user chooses; something from that window (color); Window must be opened while user is choosing. void ReplayRealtime(); Replays the next event. It is called when fTimer times out.; Every time fTimer is set again to time equal to time difference between; current two events being replayed. It can happen that execution of an event lasts different time during the; recording and during the replaying.; If fTimer times out too early and the previous event has not been yet; replayed, it is usually postponed in order; to keep events execution in the right order.; The excpetions are determined by TRecorderReplaying::CanOverlap(). void Pause(TRecorder* r); Pauses replaying. void ReplayStop(TRecorder* r); Cancels replaying. void Continue(); Continues previously paused replaying. TRecorder & operator=(const TRecorderReplaying& ). TRecorder::ERecorderState GetState() const; Gets current state of recorder. TRecorderReplaying(const char* filename). » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-05 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRecorderReplaying.html:6122,pause,paused,6122,root/html534/TRecorderReplaying.html,https://root.cern,https://root.cern/root/html534/TRecorderReplaying.html,4,"['Pause', 'pause']","['Pause', 'Pauses', 'paused']"
Usability,"tEvent. Reads both from CmdTree and GuiTree and chooses that event that becomes; earlier; - fCmdTreeCounter determines actual position in fCmdTree; - fGuiTreeCounter determines actual position in fCmdTree. If GUI event should be replayed, we must first make sure that there is; appropriate mapping for this event. RETURN VALUE:; kFALSE = there is no event to be replayed; kTRUE = there is still at least one event to be replayed. Cases:; - fNextEvent = 0 => We are waiting for the appropriate; window to be registered; - fNextEvent != 0 => fNextEvent can be replayed (windows are; ready). Bool_t CanOverlap(); ButtonPress and ButtonRelease must be sometimes replayed more times; Example: pressing of a button opens small window and user chooses; something from that window (color); Window must be opened while user is choosing. void ReplayRealtime(); Replays the next event. It is called when fTimer times out.; Every time fTimer is set again to time equal to time difference between; current two events being replayed. It can happen that execution of an event lasts different time during the; recording and during the replaying.; If fTimer times out too early and the previous event has not been yet; replayed, it is usually postponed in order; to keep events execution in the right order.; The excpetions are determined by TRecorderReplaying::CanOverlap(). void Pause(TRecorder* r); Pauses replaying. void ReplayStop(TRecorder* r); Cancels replaying. void Continue(); Continues previously paused replaying. TRecorder & operator=(const TRecorderReplaying& ). TRecorder::ERecorderState GetState() const; Gets current state of recorder. TRecorderReplaying(const char* filename). » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecorderReplaying.html:6281,pause,paused,6281,root/html602/TRecorderReplaying.html,https://root.cern,https://root.cern/root/html602/TRecorderReplaying.html,4,"['Pause', 'pause']","['Pause', 'Pauses', 'paused']"
Usability,tFunction ; (; DNN::EOutputFunction ; outputFunction). inline . Definition at line 300 of file MethodDL.h. ◆ SetTrainingStrategyString(). void TMVA::MethodDL::SetTrainingStrategyString ; (; TString ; trainingStrategyString). inline . Definition at line 302 of file MethodDL.h. ◆ SetWeightInitialization(). void TMVA::MethodDL::SetWeightInitialization ; (; DNN::EInitialization ; weightInitialization). inline . Definition at line 296 of file MethodDL.h. ◆ SetWeightInitializationString(). void TMVA::MethodDL::SetWeightInitializationString ; (; TString ; weightInitializationString). inline . Definition at line 303 of file MethodDL.h. ◆ Streamer(). virtual void TMVA::MethodDL::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::MethodBase. ◆ StreamerNVirtual(). void TMVA::MethodDL::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 212 of file MethodDL.h. ◆ Train(). void TMVA::MethodDL::Train ; (; void ; ). virtual . Methods for training the deep learning network. ; Implements TMVA::MethodBase.; Definition at line 1659 of file MethodDL.cxx. ◆ TrainDeepNet(). template<typename Architecture_t > . void TMVA::MethodDL::TrainDeepNet. private . train of deep neural network using the defined architecture ; Implementation of architecture specific train method. ; Definition at line 1164 of file MethodDL.cxx. Member Data Documentation. ◆ fArchitectureString. TString TMVA::MethodDL::fArchitectureString. private . The string defining the architecture: CPU or GPU. ; Definition at line 198 of file MethodDL.h. ◆ fBatchDepth. size_t TMVA::MethodDL::fBatchDepth. private . The depth of the batch used to train the deep net. ; Definition at line 182 of file MethodDL.h. ◆ fBatchHeight. size_t TMVA::MethodDL::fBatchHeight. private . The height of the batch used to train the deep net. ; Definition at line 183 of file MethodDL.h. ◆ fBatchLayoutString. TString TMVA::MethodDL::fBatchLayoutString. private . The string defining the layout of the ba,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodDL.html:51533,learn,learning,51533,doc/master/classTMVA_1_1MethodDL.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodDL.html,1,['learn'],['learning']
Usability,"tFunctionMultiDim&); ROOT::Math::IGradientMultiDimROOT::Math::IGradientMultiDim::IGradientMultiDim(); ROOT::Math::IGradientMultiDimROOT::Math::IGradientMultiDim::IGradientMultiDim(const ROOT::Math::IGradientMultiDim&); virtual TClass*IsA() const; virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TPyMultiGradFunction(PyObject* self = 0). private:. TPyMultiGradFunction&operator=(const TPyMultiGradFunction&); TPyMultiGradFunction(const TPyMultiGradFunction& src). Data Members; private:. PyObject*fPySelf! actual python object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPyMultiGradFunction(PyObject* self = 0); Construct a TPyMultiGradFunction derived with <self> as the underlying. ~TPyMultiGradFunction(); Destructor. Only deref if still holding on to Py_None (circular otherwise). unsigned int NDim() const; Simply forward the call to python self. double DoEval(const double* x) const; Simply forward the call to python self. void Gradient(const double* x, double* grad) const; Simply forward the call to python self. void FdF(const double* x, double& f, double* df) const; Simply forward the call to python self. double DoDerivative(const double* x, unsigned int icoord) const; Simply forward the call to python self. ROOT::Math::IBaseFunctionMultiDim* Clone() const; Math::IMultiGenFunction implementation. { return new TPyMultiGenFunction( fPySelf ); }. TPyMultiGenFunction& operator=(const TPyMultiGradFunction& ); { return *this; }. TPyMultiGradFunction(PyObject* self = 0); ctor/dtor, and assignment. » Last changed: Tue Jun 30 15:28:40 2015 » Last generated: 2015-06-30 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPyMultiGradFunction.html:2404,Simpl,Simply,2404,root/html602/TPyMultiGradFunction.html,https://root.cern,https://root.cern/root/html602/TPyMultiGradFunction.html,5,['Simpl'],['Simply']
Usability,"tHub based build system.; Bugs and Issues fixed in this release; More than 200 items were addressed for this release. The full list is:. [#15621] - Buffer overflow in TBranch::Init; [#15610] - Memory leak in TTree getattr pythonization; [#15590] - Infinite recursion in TFile::Open; [#15460] - TEnum::GetEnum(“B”)->GetUnderlyingType() does not following typedefs; [#15413] - Fails to build with cuDNN version 9; [#15406] - TEnum::GetEnum does not seem to see ‘through’ using statements.; [#15399] - Memory leak with jitted nodes if the execution is never triggered; [#15396] - [TMVA] Pymva test (Keras) failing on 632 and main; [#15370] - Broken link in HS3 printout; [#15340] - Webgraphics: canvas displayed, but many error printed; [#15253] - C++ standard not propagated via CMake anymore; [#15197] - RBDT does not support xgboost inference; [#15156] - Segfault in TMVA::Experimental::SOFIE::RModel::Streamer; [#15139] - cmake option -Dall=YES breaks the cmake; [#15118] - jsoninterface does not build if provided with RapidYAML; [#15108] - Turn off clang-format for Linkdef files; [#15090] - TClass::GetClassInfo() is not thread safe; [#15077] - Passing different floating point types to RVec utility functions; [#15048] - [ntuple] Handling of virtual inheritance broken; [#15040] - RDataFrame Inaccurate example of progress bar from documentation; [#15028] - RDataFrame Unable to cacheread remote file; [#15027] - spurrious cmake message about AfterImage with -Dminimal=ON; [#14981] - RVecs leak memory with np.asarray in pyROOT; [#14964] - ROOT-HEAD fails with “cling interactive line includer >>>: fatal error: module file ‘[snip]/Vc.pcm’ not found: module file not found”; [#14958] - ROOT_HEAD failed with error message: Fail to detect cryptographic random generator; [#14921] - ROOT Fails to build macOS 14.4 arm64 Xcode 15.3; [#14914] - VecOps::Take with default argument doesn’t check correctly the out of boundary condition; [#14910] - hadd issue when using parallelization together with in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:25982,progress bar,progress bar,25982,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['progress bar'],['progress bar']
Usability,"tInput); Creates widget with default pixel format. ~TGLWidget(); Destructor. Deletes window ???? and XVisualInfo. void InitGL(); Call glEnable(... in overrider of InitGL. void PaintGL(); Do actual drawing in overrider of PaintGL. Bool_t MakeCurrent(); Make the gl-context current. Bool_t ClearCurrent(); Clear the current gl-context. void SwapBuffers(); Swap buffers. const TGLContext * GetContext() const; Get gl context. const TGLFormat * GetPixelFormat() const; Pixel format. std::pair<void *, void *> GetInnerData() const; Dpy*, XVisualInfo *. void AddContext(TGLContext* ctx); Register gl-context created for this window. void RemoveContext(TGLContext* ctx); Remove context (no real deletion, done by TGLContex dtor). void ExtractViewport(Int_t* vp) const; For camera. Window_t CreateWindow(const TGWindow* parent, const TGLFormat& format, UInt_t width, UInt_t height, pair<void*,void*>& innerData); CreateWidget.; Static function called prior to widget construction,; I've extracted this code from ctors to make WIN32/X11; separation simpler and because of gInterpreter usage.; new, TGLContext can throw; std::bad_alloc and std::runtime_error. Before try block, the only; resource allocated is pointed by fWindowIndex (InitWindow cannot throw).; In try block (and after successful constraction); resources are controlled by std::auto_ptrs and dtor. void SetFormat(); Set pixel format.; Resource - hDC, owned and freed by guard object. void SetEventHandler(TGEventHandler* eh); Set event-handler. All events are passed to this object. Bool_t HandleCrossing(Event_t* ); Handle mouse crossing event. Bool_t HandleButton(Event_t* ev); Delegate call to the owner. Bool_t HandleDoubleClick(Event_t* ev); Delegate call to the owner. Bool_t HandleConfigureNotify(Event_t* ev); Delegate call to the owner. Bool_t HandleFocusChange(Event_t* ); Delegate call to the owner. Bool_t HandleKey(Event_t* ev); Delegate call to the owner. Bool_t HandleMotion(Event_t* ev); Delegate call to the owner. void DoRedr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLWidget.html:20840,simpl,simpler,20840,root/html528/TGLWidget.html,https://root.cern,https://root.cern/root/html528/TGLWidget.html,10,['simpl'],['simpler']
Usability,"tInputBegin (other.m_itInputBegin); 541 , m_itInputEnd (other.m_itInputEnd); 542 , m_deltas (std::move(other.m_deltas)); 543 , m_valueGradients (std::move(other.m_valueGradients)); 544 , m_values (std::move(other.m_values)); 545 , m_itDropOut (other.m_itDropOut); 546 , m_hasDropOut (other.m_hasDropOut); 547 , m_itConstWeightBegin (other.m_itConstWeightBegin); 548 , m_itGradientBegin (other.m_itGradientBegin); 549 , m_activationFunction (std::move(other.m_activationFunction)); 550 , m_inverseActivationFunction (std::move(other.m_inverseActivationFunction)); 551 , m_isInputLayer (other.m_isInputLayer); 552 , m_hasWeights (other.m_hasWeights); 553 , m_hasGradients (other.m_hasGradients); 554 , m_eModeOutput (other.m_eModeOutput); 555 {}; 556 ; 557 ; 558 /*! \brief change the input iterators; 559 *; 560 *; 561 * \param itInputBegin indicates the start of the input node vector; 562 * \param itInputEnd indicates the end of the input node vector; 563 *; 564 */; 565 void setInput (const_iterator_type itInputBegin, const_iterator_type itInputEnd); 566 {; 567 m_isInputLayer = true;; 568 m_itInputBegin = itInputBegin;; 569 m_itInputEnd = itInputEnd;; 570 }; 571 ; 572 /*! \brief clear the values and the deltas; 573 *; 574 *; 575 */; 576 void clear (); 577 {; 578 m_values.assign (m_values.size (), 0.0);; 579 m_deltas.assign (m_deltas.size (), 0.0);; 580 }; 581 ; 582 const_iterator_type valuesBegin () const { return m_isInputLayer ? m_itInputBegin : begin (m_values); } ///< returns const iterator to the begin of the (node) values; 583 const_iterator_type valuesEnd () const { return m_isInputLayer ? m_itInputEnd : end (m_values); } ///< returns iterator to the end of the (node) values; 584 ; 585 iterator_type valuesBegin () { assert (!m_isInputLayer); return begin (m_values); } ///< returns iterator to the begin of the (node) values; 586 iterator_type valuesEnd () { assert (!m_isInputLayer); return end (m_values); } ///< returns iterator to the end of the (node) values; 587 ; 588 M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:17965,clear,clear,17965,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,2,['clear'],['clear']
Usability,"tLayer(j);; 986 TCuda<>::Copy(layer.GetWeights(),; 987 masterLayer.GetWeights());; 988 TCuda<>::Copy(layer.GetBiases(),; 989 masterLayer.GetBiases());; 990 }; 991 }; 992 ; 993 bool converged = false;; 994 size_t stepCount = 0;; 995 size_t batchesInEpoch = nTrainingSamples / net.GetBatchSize();; 996 ; 997 std::chrono::time_point<std::chrono::system_clock> start, end;; 998 start = std::chrono::system_clock::now();; 999 ; 1000 if (!fInteractive) {; 1001 Log() << std::setw(10) << ""Epoch"" << "" | ""; 1002 << std::setw(12) << ""Train Err.""; 1003 << std::setw(12) << ""Test Err.""; 1004 << std::setw(12) << ""GFLOP/s""; 1005 << std::setw(12) << ""Conv. Steps"" << Endl;; 1006 std::string separator(62, '-');; 1007 Log() << separator << Endl;; 1008 }; 1009 ; 1010 while (!converged); 1011 {; 1012 stepCount++;; 1013 ; 1014 // Perform minimization steps for a full epoch.; 1015 trainingData.Shuffle();; 1016 for (size_t i = 0; i < batchesInEpoch; i += nThreads) {; 1017 batches.clear();; 1018 for (size_t j = 0; j < nThreads; j++) {; 1019 batches.reserve(nThreads);; 1020 batches.push_back(trainingData.GetBatch());; 1021 }; 1022 if (settings.momentum > 0.0) {; 1023 minimizer.StepMomentum(net, nets, batches, settings.momentum);; 1024 } else {; 1025 minimizer.Step(net, nets, batches);; 1026 }; 1027 }; 1028 ; 1029 if ((stepCount % minimizer.GetTestInterval()) == 0) {; 1030 ; 1031 // Compute test error.; 1032 Double_t testError = 0.0;; 1033 for (auto batch : testData) {; 1034 auto inputMatrix = batch.GetInput();; 1035 auto outputMatrix = batch.GetOutput();; 1036 testError += testNet.Loss(inputMatrix, outputMatrix);; 1037 }; 1038 testError /= (Double_t) (nTestSamples / settings.batchSize);; 1039 ; 1040 //Log the loss value; 1041 fTrainHistory.AddValue(""testError"",stepCount,testError);; 1042 ; 1043 end = std::chrono::system_clock::now();; 1044 ; 1045 // Compute training error.; 1046 Double_t trainingError = 0.0;; 1047 for (auto batch : trainingData) {; 1048 auto inputMatrix = batch.GetInput();; 1049 a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:36445,clear,clear,36445,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['clear'],['clear']
Usability,"tLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitely, or via; a string containing the formula to be used to define them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :; TMultiLayerPerceptron::kStochastic, ; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS; A weight can be assigned to events, either in the constructor, either; with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; are available. . Example:; net.Train(100,""text, graph, update=10"").; When the neural net is trained, it can be used; directly ( TMultiLayerPerceptron::Evaluate() ) or exported to a; standalone C++ code ( TMultiLayerPerceptron::Export() ).; Finaly, note that even if this implementation is inspired from the mlpfit code,; the feature lists are not exactly matching:. mlpfit hybrid learning method is not implemented; output neurons can be normalized, this is not the case for mlpfit; the neural net is exported in C++, FORTRAN or PYTHON; the drawResult() method allows a fast check of the learning procedure. In addition, the paw version of mlpfit had additional limitations on the number of neurons, hidden layers and inputs/outputs that does not apply to TMultiLayerPerceptron. Function Members (Methods); public:. TMultiLayerPerceptr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:8058,simpl,simple,8058,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,4,['simpl'],['simple']
Usability,"tMethod(const char* method) const; virtual Bool_tAcceptModel(TObject* model); virtual voidTGFrame::Activate(Bool_t); virtual voidActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual TGVerticalFrame*TGedFrame::CreateEditorTabSubFrame(const char* name); virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::Des",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH2Editor.html:5167,Clear,Clear,5167,root/html532/TH2Editor.html,https://root.cern,https://root.cern/root/html532/TH2Editor.html,4,['Clear'],['Clear']
Usability,tMutableField(std::string_view fieldName)Definition RNTupleModel.cxx:406; ROOT::Experimental::RNTupleModel::Freezevoid Freeze()Definition RNTupleModel.cxx:507; ROOT::Experimental::RNTupleModel::CreateBarestatic std::unique_ptr< RNTupleModel > CreateBare()A bare model has no default entry.Definition RNTupleModel.cxx:236; ROOT::Experimental::RNTupleModel::IsFrozenbool IsFrozen() constDefinition RNTupleModel.hxx:363; ROOT::Experimental::RNTupleModel::AddFieldvoid AddField(std::unique_ptr< RFieldBase > field)Adds a field whose type is not known at compile time.Definition RNTupleModel.cxx:312; ROOT::Experimental::RNTupleModel::RegisterSubfieldvoid RegisterSubfield(std::string_view qualifiedFieldName)Register a subfield so it can be accessed directly from entries belonging to the model.Definition RNTupleModel.cxx:335; ROOT::Experimental::RNTupleModel::Unfreezevoid Unfreeze()Definition RNTupleModel.cxx:493; ROOT::Experimental::RNTupleModel::fFieldZerostd::unique_ptr< RFieldZero > fFieldZeroHierarchy of fields consisting of simple types and collections (sub trees)Definition RNTupleModel.hxx:198; ROOT::Experimental::RNTupleWriteOptionsCommon user-tunable settings for storing ntuples.Definition RNTupleWriteOptions.hxx:48; ROOT::Experimental::RNTupleWriteOptions::GetCompressionint GetCompression() constDefinition RNTupleWriteOptions.hxx:105; ROOT::Experimental::RNTupleWriteOptions::GetPageBufferBudgetstd::size_t GetPageBufferBudget() constDefinition RNTupleWriteOptions.cxx:77; ROOT::Experimental::RNTupleWriteOptions::GetApproxZippedClusterSizestd::size_t GetApproxZippedClusterSize() constDefinition RNTupleWriteOptions.hxx:112; ROOT::Experimental::RNTupleWriteOptions::GetInitialNElementsPerPagestd::size_t GetInitialNElementsPerPage() constDefinition RNTupleWriteOptions.hxx:118; ROOT::Experimental::RNTupleWriteOptions::GetUseBufferedWritebool GetUseBufferedWrite() constDefinition RNTupleWriteOptions.hxx:127; ROOT::Experimental::RNTupleWriteOptions::GetMaxUnzippedPageSizestd::size,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleModel_8cxx_source.html:33383,simpl,simple,33383,doc/master/RNTupleModel_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleModel_8cxx_source.html,1,['simpl'],['simple']
Usability,"tNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoomended to re-generate the toy for each poi scanned point of the posterior function. ROOFIT:; use roofit default integration methods which will produce a nested integral (not reccomended for more; than 1 nuisance parameters). if type = 0 use default specified via class IntegratorMultiDimOptions::SetDefaultIntegrator. SimpleInterval* GetInterval() const; Compute the interval. By Default a central interval is computed; and the result is a SimpleInterval object.; Using the method (to be called before SetInterval) SetLeftSideTailFraction the user can choose the type of interval.; By default the returned interval is a central interval with the confidence level specified; previously in the constructor ( LeftSideTailFraction = 0.5).; For lower limit use SetLeftSideTailFraction = 1; For upper limit use SetLeftSideTailFraction = 0; for shortest intervals use SetLeftSideTailFraction = -1 or call the method SetShortestInterval(); NOTE: The BayesianCalculator covers only the case with one; single parameter of interest; NOTE: User takes ownership of the returned object. double GetMode() const; Returns the value of the parameter for the point in; parameter-space that is the most likely.; How do we do if there are points that are equi-probable?; use approximate posterior; t.b.d use real function to find the mode. void ComputeIntervalUsingRoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__BayesianCalculator.html:14087,Simpl,SimpleInterval,14087,root/html532/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html532/RooStats__BayesianCalculator.html,4,['Simpl'],['SimpleInterval']
Usability,"tOfStreamerInfo();; 2988 if (fNumber < 0) {; 2989 ++fgCount;; 2990 fNumber = fgCount;; 2991 }; 2992 if (fNumber >= infos->GetSize()) {; 2993 infos->AddAtAndExpand(this, fNumber);; 2994 } else {; 2995 if (!infos->At(fNumber)) {; 2996 infos->AddAt(this, fNumber);; 2997 }; 2998 }; 2999 ; 3000 assert(fComp == 0 && fCompFull == 0 && fCompOpt == 0);; 3001 ; 3002 ; 3003 Int_t ndata = fElements->GetEntriesFast();; 3004 ; 3005 ; 3006 if (fReadObjectWise) fReadObjectWise->fActions.clear();; 3007 else fReadObjectWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3008 ; 3009 if (fWriteObjectWise) fWriteObjectWise->fActions.clear();; 3010 else fWriteObjectWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3011 ; 3012 if (fReadMemberWise) fReadMemberWise->fActions.clear();; 3013 else fReadMemberWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3014 ; 3015 if (fReadText) fReadText->fActions.clear();; 3016 else fReadText = new TStreamerInfoActions::TActionSequence(this,ndata);; 3017 ; 3018 if (fWriteMemberWise) fWriteMemberWise->fActions.clear();; 3019 else fWriteMemberWise = new TStreamerInfoActions::TActionSequence(this,ndata);; 3020 ; 3021 if (fReadMemberWiseVecPtr) fReadMemberWiseVecPtr->fActions.clear();; 3022 else fReadMemberWiseVecPtr = new TStreamerInfoActions::TActionSequence(this, ndata, kTRUE);; 3023 ; 3024 if (fWriteMemberWiseVecPtr) fWriteMemberWiseVecPtr->fActions.clear();; 3025 else fWriteMemberWiseVecPtr = new TStreamerInfoActions::TActionSequence(this, ndata, kTRUE);; 3026 ; 3027 if (fWriteText) fWriteText->fActions.clear();; 3028 else fWriteText = new TStreamerInfoActions::TActionSequence(this,ndata);; 3029 ; 3030 if (!ndata) {; 3031 // This may be the case for empty classes (e.g., TAtt3D).; 3032 // We still need to properly set the size of emulated classes (i.e. add the virtual table); 3033 if (fClass->GetState() == TClass::kEmulated && fNVirtualInfoLoc!=0) {; 3034 fSize = sizeof(TStreamerInfo*);; 3035 }; 3036 fComp = new TComp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:132071,clear,clear,132071,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['clear'],['clear']
Usability,"tOutputList(). TList * TSelHist::GetOutputList ; (; ); const. inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 56 of file TSelHist.h. ◆ IsA(). TClass * TSelHist::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TSelector.; Definition at line 60 of file TSelHist.h. ◆ Process(). Bool_t TSelHist::Process ; (; Long64_t ; entry). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either TSelHist::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used. ; Reimplemented from TSelector.; Definition at line 267 of file TSelHist.cxx. ◆ SetInputList(). void TSelHist::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 55 of file TSelHist.h. ◆ SetObject(). void TSelHist::SetObject ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 54 of file TSelHist.h. ◆ SetOption(). void TSelHist::SetOption ; (; const char * ; option). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 53 of file TSelHist.h. ◆ SlaveBegin(). void TSelHist::SlaveBegin ; (; TTree * ; tree). overridevirtual . The SlaveBegin() function is called after the Begin() function. ; When running with PROOF SlaveBegin() is called on each slave server.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelHist.html:15280,simpl,simple,15280,doc/master/classTSelHist.html,https://root.cern,https://root.cern/doc/master/classTSelHist.html,1,['simpl'],['simple']
Usability,"tPainter::PlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; voidTGLPlotPainter::SetDrawAxes(Bool_t s); voidTGLPlotPainter::SetDrawBackBox(Bool_t b); voidTGLPlotPainter::SetDrawFrontBox(Bool_t b); virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); voidTGLPlotPainter::SetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLIsoPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; virtual voidTGLPlotPainter::DrawPaletteAxis() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlotPainter::RestoreProjectionMatrix() const; voidTGLPlotPainter::SaveModelviewMatrix() const; voidTGLPlotPainter::SaveProjectionMatrix() const. private:. virtual voidDeInitGL() const; voidDrawMesh(const TGLIsoPainter::Mesh_t& mesh, Int_t level) const; virtual voidDrawPlot() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; voidFindMinMax(); Bool_tHasSections() const; virtual voidInitGL() const; TGLIsoPainter&operator=(const TGLIsoPainter&); voidSetMesh(TGLIsoPainter::Mesh_t& mesh, Double_t isoValue); voidSetSurfaceColor(Int_t ind) const; TGLIsoPainter(const TGLIsoPainter&). Data Members; public:. static TGLPlotPainter::ECutAxisIDTGLPlotPainter::kXAxis; static TGLPlotPainter::ECutAxisIDTGLPlotPainter::kYAxis; static TGLPlotPainter::ECutAxisIDTGLPlotPainter::kZAxis. protected:. TGLPlotBoxTGLPlotPainter::fBackBox; TGLBoxCutT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLIsoPainter.html:1571,Clear,ClearBuffers,1571,root/html602/TGLIsoPainter.html,https://root.cern,https://root.cern/root/html602/TGLIsoPainter.html,2,['Clear'],['ClearBuffers']
Usability,"tPass iopt = kMarked, TVolumeView* root = 0); TVolumeView(Double_t* translate, Double_t* rotate, UInt_t positionId, TVolume* thisNode, const Char_t* thisNodePath, const Char_t* matrixName = 0, Int_t matrixType = 0); virtual~TVolumeView(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TDataSet* dataset); virtual voidAdd(TVolumeView* node); virtual voidAdd(TShape* shape, Bool_t IsMaster = kFALSE); virtual voidTDataSet::AddAt(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual TVolume*AddNode(TVolume* node); virtual TObject*TObjectSet::AddObject(TObject* obj, Bool_t makeOwner = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); TDataSet*TDataSet::At(Int_t idx) const; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObjectSet::Delete(Option_t* opt = """"); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTObjectSet::DoOwner(Bool_t done = kTRUE); virtual voidDraw(Option_t* depth = ""3"")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVolumeView.html:2264,Clear,Clear,2264,root/html532/TVolumeView.html,https://root.cern,https://root.cern/root/html532/TVolumeView.html,2,['Clear'],['Clear']
Usability,"tRooAbsArgvirtual; chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})RooAbsRealvirtual; chi2FitTo(RooDataHist &data, const RooLinkedList &cmdList)RooAbsRealvirtual; chi2FitTo(RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})RooAbsRealvirtual; chi2FitTo(RooDataSet &xydata, const RooLinkedList &cmdList)RooAbsRealvirtual; Class()RooAbsPdfstatic; Class_Name()RooAbsPdfstatic; Class_Version()RooAbsPdfinlinestatic; ClassName() constTObjectvirtual; cleanBranchName() constRooAbsArgprotected; Clear(Option_t *option="""") overrideTNamedvirtual; clearEvalErrorLog()RooAbsRealstatic; clearShapeDirty() constRooAbsArginlineprotected; clearValueAndShapeDirty() constRooAbsArginlineprotected; clearValueDirty() constRooAbsArginlineprotected; clients() constRooAbsArginline; Clone(const char *newname=nullptr) const overrideRooAbsArginlinevirtual; clone(const char *newname=nullptr) const =0RooAbsArgpure virtual; cloneTree(const char *newname=nullptr) constRooAbsArgvirtual; CollectErrors enum valueRooAbsReal; Compare(const TObject *other) const overrideRooAbsArgvirtual; compileForNormSet(RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const overrideRooAbsPdfvirtual; ConfigChange enum valueRooAbsArg; constRooAbsArg; constRooAbsArg; ConstOpCode enum nameRooAbsArg; constOptimizeTestStatistic(ConstOpCode opcode, bool doAlsoTrackingOpt=true)RooAbsArgvirtual; ContentsOption enum nameRooPrintable; Copy(TObject &named) const overrideTNamedvirtual; copyCache(const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) overrideRooAbsRealprotectedvirtual; CountErrors enum valueRooAbsReal; createCdf(const RooArgSet &iset, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf-members.html:6064,clear,clearValueAndShapeDirty,6064,doc/master/classRooAbsPdf-members.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf-members.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"tRooCacheManager<RooAbsCacheElement>::_lastIndex! Last slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSize! Maximum size; vector<RooNormSetCache>RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen! ; RooArgSet*_optCacheObservables! current optCacheObservables ; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_size! Actual use; Bool_tRooCacheManager<RooAbsCacheElement>::_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 2, Bool_t clearCacheOnServerRedirect = kTRUE, Bool_t allowOptimize = kFALSE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooObjCacheManager.html:4228,clear,clearCacheOnServerRedirect,4228,root/html534/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html534/RooObjCacheManager.html,4,['clear'],"['clearCacheOnServerRedirect', 'cleared']"
Usability,"tSession(); Reset Proof session. void DeleteQuery(); Delete query from list tree and ask user if he wants do delete it also; from server. void EditQuery(); Edit currently selected query. void StartViewer(); Start TreeViewer from selected TChain. void ShowPackages(); Query the list of uploaded packages from proof and display it; into a new text window. void UpdateListOfPackages(); Update the list of packages. void ShowEnabledPackages(); Query list of enabled packages from proof and display it; into a new text window. void ShowLog(const char* queryref); Display the content of the temporary log file for queryref; into a new text window. void ShowInfo(const char* txt); Display text in status bar. void ShowStatus(); Retrieve and display Proof status. void StartupMessage(char* msg, Bool_t stat, Int_t curr, Int_t total); Handle startup message (connection progress) coming from Proof session. void MyHandleMenu(Int_t ); Handle session viewer custom popup menus. void OnCascadeMenu(); Handle feedback histograms configuration menu. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle messages send to the TSessionViewer object. E.g. all menu entries; messages. TSessionServerFrame * GetServerFrame() const; { return fServerFrame; }. TSessionFrame * GetSessionFrame() const; { return fSessionFrame; }. TSessionQueryFrame * GetQueryFrame() const; { return fQueryFrame; }. TSessionOutputFrame * GetOutputFrame() const; { return fOutputFrame; }. TSessionInputFrame * GetInputFrame() const; { return fInputFrame; }. TSessionDescription * GetActDesc() const; { return fActDesc; }. TList * GetSessions() const; { return fSessions; }. TGListTree * GetSessionHierarchy() const; { return fSessionHierarchy; }. TGListTreeItem * GetSessionItem() const; { return fSessionItem; }. const TGPicture * GetLocalPict() const; { return fLocal; }. const TGPicture * GetProofConPict() const; { return fProofCon; }. const TGPicture * GetProofDisconPict() const; { return fProofDiscon; }. const TGPicture * G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSessionViewer.html:27992,feedback,feedback,27992,root/html528/TSessionViewer.html,https://root.cern,https://root.cern/root/html528/TSessionViewer.html,6,['feedback'],['feedback']
Usability,"tTBranch::fReadEntry! Current entry number when reading; G__p2memfuncTBranch::fReadLeaves! Pointer to the ReadLeaves implementation to use. ; TRefTable*fRefTablepointer to the TRefTable; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter. private:. Long64_tfRequestedEntry! Cursor indicating which entry is being requested. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeavesImpl(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void FillLeavesImpl(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations); TRefTable is cleared. Int_t SetParent(const TObject* obj, Int_t branchID); -- Set the current parent branch. This function is called by TBranchElement::GetEntry(); and TBranchElement::Fill() when r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBranchRef.html:14139,Clear,Clear,14139,root/html532/TBranchRef.html,https://root.cern,https://root.cern/root/html532/TBranchRef.html,4,['Clear'],['Clear']
Usability,"tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/und",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:18182,undo,undo,18182,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,12,['undo'],['undo']
Usability,"tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPconEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPconEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a given pcon. void CreateSections(Int_t inew); Change dynamically the number of sections. Bool_t CheckSections(Bool_t change = kFALSE); Check validity of sections. void UpdateSections(); Update sections according fShape. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoSectionChange(Int_t i); Change parameters of section isect;. void DoNz(); Change number of sections. void DoPhi(); Change phi range. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); {;}. TGeoPconEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoPconEditor.html:22949,undo,undoing,22949,root/html604/TGeoPconEditor.html,https://root.cern,https://root.cern/root/html604/TGeoPconEditor.html,2,['undo'],['undoing']
Usability,"tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPconEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPconEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a given pcon. void CreateSections(Int_t inew); Change dynamically the number of sections. Bool_t CheckSections(Bool_t change = kFALSE); Check validity of sections. void UpdateSections(); Update sections according fShape. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoSectionChange(Int_t i); Change parameters of section isect;. void DoNz(); Change number of sections. void DoPhi(); Change phi range. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); {;}. TGeoPconEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoPconEditor.html:22949,undo,undoing,22949,root/html602/TGeoPconEditor.html,https://root.cern,https://root.cern/root/html602/TGeoPconEditor.html,2,['undo'],['undoing']
Usability,"tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGVProgressBar(const TGWindow* p = 0, UInt_t w = kProgressBarTextWidth, UInt_t h = 4, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame); cconstructor. TGVProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t h); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void DoRedraw(); Draw vertical progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a vertical progress bar as a C++ statement(s) on output stream out. void Percent(Bool_t ); { fPercent = on; fClient->NeedRedraw(this); }. void ShowPos(Bool_t ); { fShowPos = on; fClient->NeedRedraw(this); }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. TGVProgressBar(const TGWindow* p = 0, UInt_t w = kProgressBarTextWidth, UInt_t h = 4, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame). virtual ~TGVProgressBar(); { }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 15:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGVProgressBar.html:21915,progress bar,progress bar,21915,root/html604/TGVProgressBar.html,https://root.cern,https://root.cern/root/html604/TGVProgressBar.html,2,['progress bar'],['progress bar']
Usability,"tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGVProgressBar(const TGWindow* p = 0, UInt_t w = kProgressBarTextWidth, UInt_t h = 4, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame); cconstructor. TGVProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t h); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void DoRedraw(); Draw vertical progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a vertical progress bar as a C++ statement(s) on output stream out. void Percent(Bool_t ); { fPercent = on; fClient->NeedRedraw(this); }. void ShowPos(Bool_t ); { fShowPos = on; fClient->NeedRedraw(this); }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. TGVProgressBar(const TGWindow* p = 0, UInt_t w = kProgressBarTextWidth, UInt_t h = 4, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame). virtual ~TGVProgressBar(); { }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGVProgressBar.html:21915,progress bar,progress bar,21915,root/html602/TGVProgressBar.html,https://root.cern,https://root.cern/root/html602/TGVProgressBar.html,2,['progress bar'],['progress bar']
Usability,"tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EStatusBits { kFileNotOpen; kFileCorrupted; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Long64_tfBytesRead; Double_tfCPUTime; Long64_tfEntries; Long64_tfLastEntriesLast chunck; Double_tfLastProcTimethe wallclock time of the last addition; Double_tfLastUpdateTimestamp of last change; Double_tfLearnTimethe time spent in learning phase; Double_tfProcTimethe wallclock time; Long64_tfReadCalls. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressStatus(Long64_t fEntries = 0, Long64_t fBytesRead = 0, Long64_t fReadCalls = 0, Double_t fProcTime = 0, Double_t fCPUTime = 0); Main and default constructor. TProofProgressStatus& operator+=(const TProofProgressStatus& st); '+=' operator. TProofProgressStatus& operator-=(const TProofProgressStatus& st); '-=' operator. TProofProgressStatus operator-(TProofProgressStatus& st); '-' operator. void Print(Option_t* option = """") const; Dump the content. void SetLastUpdate(Double_t updtTime = 0); Update time stamp either with the passed value (if > 0) or with; the current time. Double_t GetCurrentRate() const; Get current rate. Rteunr the average rate if the current is not defined. TProofProgressStatus(Long64_t fEntries = 0, Long64_t fBytes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofProgressStatus.html:6596,learn,learning,6596,root/html530/TProofProgressStatus.html,https://root.cern,https://root.cern/root/html530/TProofProgressStatus.html,5,['learn'],['learning']
Usability,"tTObject::TestBits(UInt_t f) const; virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); voidDrawFocusHilite(Int_t onoff); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidGotFocus(); virtual voidLostFocus(); voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGColorPalette(const TGColorPalette&); TGColorPalette&operator=(const TGColorPalette&). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGColorPalette.html:14569,Clear,ClearFlags,14569,root/html532/TGColorPalette.html,https://root.cern,https://root.cern/root/html532/TGColorPalette.html,2,['Clear'],['ClearFlags']
Usability,"tTargetGradient, typename ItGradient>; 281 void update (ItSource itSource, ItSource itSourceEnd,; 282 ItDelta itTargetDeltaBegin, ItDelta itTargetDeltaEnd,; 283 ItTargetGradient itTargetGradientBegin,; 284 ItGradient itGradient);; 285 ; 286 ; 287 ; 288 template <EnumRegularization Regularization, typename ItSource, typename ItDelta, typename ItTargetGradient, typename ItGradient, typename ItWeight>; 289 void update (ItSource itSource, ItSource itSourceEnd,; 290 ItDelta itTargetDeltaBegin, ItDelta itTargetDeltaEnd,; 291 ItTargetGradient itTargetGradientBegin,; 292 ItGradient itGradient,; 293 ItWeight itWeight, double weightDecay);; 294 ; 295 ; 296 ; 297 // ----- signature of a minimizer -------------; 298 // class Minimizer; 299 // {; 300 // public:; 301 ; 302 // template <typename Function, typename Variables, typename PassThrough>; 303 // double operator() (Function& fnc, Variables& vars, PassThrough& passThrough); 304 // {; 305 // // auto itVars = begin (vars);; 306 // // auto itVarsEnd = end (vars);; 307 ; 308 // std::vector<double> myweights;; 309 // std::vector<double> gradients;; 310 ; 311 // double value = fnc (passThrough, myweights);; 312 // value = fnc (passThrough, myweights, gradients);; 313 // return value;; 314 // }; 315 // };; 316 ; 317 ; 318 ; 319 ///< list all the minimizer types; 320 enum MinimizerType; 321 {; 322 fSteepest ///< SGD; 323 };; 324 ; 325 ; 326 ; 327 ; 328 ; 329 /*! \brief Steepest Gradient Descent algorithm (SGD); 330 *; 331 * Implements a steepest gradient descent minimization algorithm; 332 */; 333 class Steepest; 334 {; 335 public:; 336 ; 337 size_t m_repetitions;; 338 ; 339 ; 340 /*! \brief c'tor; 341 *; 342 * C'tor; 343 *; 344 * \param learningRate denotes the learning rate for the SGD algorithm; 345 * \param momentum fraction of the velocity which is taken over from the last step; 346 * \param repetitions re-compute the gradients each ""repetitions"" steps; 347 */; 348 Steepest (double learningRate = 1e-4,; 349 double momentum = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:8818,learn,learningRate,8818,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,3,['learn'],"['learning', 'learningRate']"
Usability,"tUndoArgs(1, character) from inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);; TQCommand::GetCommandstatic TQCommand * GetCommand()Return a command which is doing redo/undo action.Definition TQCommand.cxx:276. Definition at line 276 of file TQCommand.cxx. ◆ GetName(). const char * TQCommand::GetName ; (; ); const. overridevirtual . Returns the command name. ; Default name is ""ClassName::RedoName(args)"" If list of merged commands is not empty the name is ""ClassName::RedoName(args):cname1:cname2 ..."" ; Reimplemented from TCollection.; Definition at line 670 of file TQCommand.cxx. ◆ GetNRargs(). Int_t TQCommand::GetNRargs ; (; ); const. Returns a number of redo arguments. ; Definition at line 768 of file TQCommand.cxx. ◆ GetNUargs(). Int_t TQCommand::GetNUargs ; (; ); const. Returns a number of undo arguments. ; Definition at line 776 of file TQCommand.cxx. ◆ GetObject(). void * TQCommand::GetObject ; (; ); const. Returns an object for which undo redo actions are applied. ; Definition at line 784 of file TQCommand.cxx. ◆ GetRedo(). TQConnection * TQCommand::GetRedo ; (; ); const. inline . Definition at line 75 of file TQCommand.h. ◆ GetRedoArgs(). Long_t * TQCommand::GetRedoArgs ; (; ); const. Returns a pointer to array of redo arguments. ; Definition at line 752 of file TQCommand.cxx. ◆ GetRedoName(). const char * TQCommand::GetRedoName ; (; ); const. Returns the name of redo command. ; Definition at line 736 of file TQCommand.cxx. ◆ GetStatus(). Int_t TQCommand::GetStatus ; (; ); const. Returns a number of sequential undo or redo operations. ; Definition at line 792 of file TQCommand.cxx. ◆ GetTitle(). const char * TQCommand::GetTitle ; (; ); const. overridevirtual . Returns command description. ; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"" ; Reimplemented from TObject.; Definition at line 713 of file TQCommand.cxx. ◆ GetUndo(). TQConnection * TQCommand::GetUndo ; (; ); const. inline . Definition at ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:37937,undo,undo,37937,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"tView*fInfoTextViewsummary on current query; TGLabel*fLabInfosinfos on current process; TGLabel*fLabStatusactual process status; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query information frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSessionQueryFrame.html:21335,feedback,feedback,21335,root/html534/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html534/TSessionQueryFrame.html,2,['feedback'],['feedback']
Usability,"t[] gPad->SetLogx(1); To reset log in the z direction:; root[] gPad->SetLogz(0); If you have a divided pad, you need to set the scale on each of the sub-pads. Setting it on the containing pad does not automatically propagate to the sub-pads. Here is an example of how to set the log scale for the x-axis on a canvas with four sub-pads:; root[] TCanvas MyCanvas(""MyCanvas"",""My Canvas""); root[] MyCanvas->Divide(2,2); root[] MyCanvas->cd(1); root[] gPad->SetLogx(); root[] MyCanvas->cd(2); root[] gPad->SetLogx(); root[] MyCanvas->cd(3); root[] gPad->SetLogx(); 9.3.8 WaitPrimitive method; When the TPad::WaitPrimitive() method is called with no arguments, it will wait until a double click or any key pressed is executed in the canvas. A call to gSystem->Sleep(10) has been added in the loop to avoid consuming at all the CPU. This new option is convenient when executing a macro. By adding statements like:; canvas->WaitPrimitive();; You can monitor the progress of a running macro, stop it at convenient places with the possibility to interact with the canvas and resume the execution with a double click or a key press.; 9.3.9 Locking the Pad; You can make the TPad non-editable. Then no new objects can be added, and the existing objects and the pad can not be changed with the mouse or programmatically. By default the TPad is editable.; TPad::SetEditable(kFALSE); 9.4 Graphical Objects; In this paragraph, we describe the various simple 2D graphical objects defined in ROOT. Usually, one defines these objects with their constructor and draws them with their Draw() method. Therefore, the examples will be very brief. Most graphical objects have line and fill attributes (color, width) that will be described in “Graphical objects attributes”. If the user wants more information, the class names are given and they may refer to the online developer documentation. This is especially true for functions and methods that set and get internal values of the objects described here. By default 2D gra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:318677,resume,resume,318677,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['resume'],['resume']
Usability,"t_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); Float_tTEveLine::CalculateLineLength() const; virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTPointSet3D::ClearIds(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEvePointSet*TEvePointSet::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEvePointSet::ClonePoints(const TEvePointSet& e); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Conne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveTrack.html:2997,Clear,ClearProjectedList,2997,root/html534/TEveTrack.html,https://root.cern,https://root.cern/root/html534/TEveTrack.html,3,['Clear'],['ClearProjectedList']
Usability,"t_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); Float_tTEveLine::CalculateLineLength() const; virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTPointSet3D::ClearIds(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEvePointSet*TEvePointSet::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEvePointSet::ClonePoints(const TEvePointSet& e); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTEveTrack::ComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveTrackProjected.html:2646,Clear,ClearProjectedList,2646,root/html534/TEveTrackProjected.html,https://root.cern,https://root.cern/root/html534/TEveTrackProjected.html,3,['Clear'],['ClearProjectedList']
Usability,"t_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); Float_tTEveLine::CalculateLineLength() const; virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTPointSet3D::ClearIds(); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEvePointSet*TEvePointSet::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEvePointSet::ClonePoints(const TEvePointSet& e); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTPointSet3D::ComputeBBox(); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveLineProjected.html:2534,Clear,ClearProjectedList,2534,root/html534/TEveLineProjected.html,https://root.cern,https://root.cern/root/html534/TEveLineProjected.html,3,['Clear'],['ClearProjectedList']
Usability,"t_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the branches in the cache. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). const TObjArray * GetCachedBranches() const; { return fBranches; }. Bool_t IsLearning() const; {return fIsLearning;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TTreeCache.h 41101 2011-10-03 16:23:48Z pcanal $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the docume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:23431,learn,learning,23431,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,2,['learn'],['learning']
Usability,"t_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayC::Adopt(Int_t n, Char_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Char_tTArrayC::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH1::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; virtual TH1*TH1::DrawNorm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1C.html:1792,Clear,ClearUnderflowAndOverflow,1792,root/html602/TH1C.html,https://root.cern,https://root.cern/root/html602/TH1C.html,2,['Clear'],['ClearUnderflowAndOverflow']
Usability,"t_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayC::Adopt(Int_t n, Char_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Char_tTArrayC::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH2::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; virtual TH1*TH1::DrawNorm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2C.html:1772,Clear,ClearUnderflowAndOverflow,1772,root/html602/TH2C.html,https://root.cern,https://root.cern/root/html602/TH2C.html,2,['Clear'],['ClearUnderflowAndOverflow']
Usability,"t_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayC::Adopt(Int_t n, Char_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Char_tTArrayC::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH3::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; virtual TH1*TH1::DrawNorm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH3C.html:1772,Clear,ClearUnderflowAndOverflow,1772,root/html602/TH3C.html,https://root.cern,https://root.cern/root/html602/TH3C.html,2,['Clear'],['ClearUnderflowAndOverflow']
Usability,"t_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h offsetDefinition TGWin32VirtualXProxy.cxx:245; TGaxis.h; TLatex.h; TLine.h; TString.h; snprintf#define snprintfDefinition civetweb.c:1540; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TGaxis::SetLabelFontvoid SetLabelFont(Int_t labelfont)Definition TGaxis.h:105; TGaxis::SetLabelColorvoid SetLabelColor(Int_t labelcolor)Definition TGaxis.h:104; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexTLatex * DrawLatex(Double_t x, Double_t y, const char *text)Make a copy of this object with the new parameters And copy object attributes.Definition TLatex.cxx:1943; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TStringBasic string class.Definition TString.h:139; TText::SetNDCvirtual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mode on if isNDC = kTRUE, off otherwise.Definition TText.cxx:823; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; ttauto * ttDefinition textangle.C:16; . The following macro illustrates the use, with histograms axis, of the time mode on the axis with different time intervals and time formats.; ; #include <time.h>; ; void timeonaxis(); {; ; time_t script_time;; script_time = time(0);; script_time = 3600*(int)(script_time/3600);; ; // The time offset is the one that will be used by all graphs.; // If one changes it, it will be changed even on th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGaxis.html:31786,simpl,simple,31786,doc/master/classTGaxis.html,https://root.cern,https://root.cern/doc/master/classTGaxis.html,1,['simpl'],['simple']
Usability,"t_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TQueryDescription*fActQuerycurrent (actual) query; TStringfAddressserver address; Bool_tfAttachedkTRUE if attached; Bool_tfAutoEnableenable packages at session startup time; TStringfConfigFileconfiguration file name; Bool_tfConnectedkTRUE if connected; Bool_tfLocalkTRUE if session is local; Int_tfLogLevellog (debug) level; TStringfNamesession name; Int_tfNbHistosnumber of feedback histos; TList*fPackageslist of packages; Int_tfPortcommunication port; TProof*fProofpointer on TProof used by this session; TProofMgr*fProofMgrProof sessions manager; TList*fQuerieslist of queries in this session; Bool_tfSynckTRUE if in sync mode; TStringfTagsession unique identifier; TStringfUserNameuser name (on server). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * GetName() const; { return fQueryName; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSessionDescription.html:5567,feedback,feedback,5567,root/html528/TSessionDescription.html,https://root.cern,https://root.cern/root/html528/TSessionDescription.html,1,['feedback'],['feedback']
Usability,"t_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TQueryDescription*fActQuerycurrent (actual) query; TStringfAddressserver address; Bool_tfAttachedkTRUE if attached; Bool_tfAutoEnableenable packages at session startup time; TStringfConfigFileconfiguration file name; Bool_tfConnectedkTRUE if connected; Bool_tfLocalkTRUE if session is local; Int_tfLogLevellog (debug) level; TStringfNamesession name; Int_tfNbHistosnumber of feedback histos; TList*fPackageslist of packages; Int_tfPortcommunication port; TProof*fProofpointer on TProof used by this session; TProofMgr*fProofMgrProof sessions manager; TList*fQuerieslist of queries in this session; Bool_tfSynckTRUE if in sync mode; TStringfTagsession unique identifier; TStringfUserNameuser name (on server). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * GetName() const; { return fQueryName; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSessionDescription.html:5636,feedback,feedback,5636,root/html530/TSessionDescription.html,https://root.cern,https://root.cern/root/html530/TSessionDescription.html,1,['feedback'],['feedback']
Usability,"t_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. » Last changed: Thu Sep 23 20:00:26 2010 » Last generated: 2010-09-23 20:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooObjCacheManager.html:5273,clear,clearOnRedirect,5273,root/html528/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html528/RooObjCacheManager.html,1,['clear'],['clearOnRedirect']
Usability,"t_t nBins); RooPlot(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax); RooPlot(const char* name, const char* title, const RooAbsRealLValue& var, Double_t xmin, Double_t xmax, Int_t nBins); RooPlot(const RooAbsRealLValue& var1, const RooAbsRealLValue& var2, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax); virtual~RooPlot(); voidTObject::AbstractMethod(const char* method) const; voidaddObject(TObject* obj, Option_t* drawOptions = """", Bool_t invisible = kFALSE); voidaddPlotable(RooPlotable* plotable, Option_t* drawOptions = """", Bool_t invisible = kFALSE, Bool_t refreshNorm = kFALSE); voidaddTH1(TH1* hist, Option_t* drawOptions = """", Bool_t invisible = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); Double_tchiSquare(int nFitParam = 0) const; Double_tchiSquare(const char* pdfname, const char* histname, int nFitParam = 0) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* options = 0); Bool_tdrawAfter(const char* after, const char* target); Bool_tdrawBefore(const char* before, const char* target); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; RooPlot*emptyClone(const char* name); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooPlot.html:2569,Clear,Clear,2569,root/html532/RooPlot.html,https://root.cern,https://root.cern/root/html532/RooPlot.html,1,['Clear'],['Clear']
Usability,"t_t nleaves = fLeaves.GetEntriesFast();; 4536 for (Int_t i = 0; i < nleaves; ++i) {; 4537 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);; 4538 TBranch* branch = (TBranch*) leaf->GetBranch();; 4539 Int_t nbaskets = branch->GetListOfBaskets()->GetEntries();; 4540 for (Int_t j = 0; j < nbaskets - 1; ++j) {; 4541 if ((j == branch->GetReadBasket()) || (j == branch->GetWriteBasket())) {; 4542 continue;; 4543 }; 4544 TBasket* basket = (TBasket*)branch->GetListOfBaskets()->UncheckedAt(j);; 4545 if (basket) {; 4546 basket->DropBuffers();; 4547 if (fTotalBuffers < fMaxVirtualSize) {; 4548 return;; 4549 }; 4550 }; 4551 }; 4552 }; 4553}; 4554 ; 4555////////////////////////////////////////////////////////////////////////////////; 4556/// Fill all branches.; 4557///; 4558/// This function loops on all the branches of this tree. For; 4559/// each branch, it copies to the branch buffer (basket) the current; 4560/// values of the leaves data types. If a leaf is a simple data type,; 4561/// a simple conversion to a machine independent format has to be done.; 4562///; 4563/// This machine independent version of the data is copied into a; 4564/// basket (each branch has its own basket). When a basket is full; 4565/// (32k worth of data by default), it is then optionally compressed; 4566/// and written to disk (this operation is also called committing or; 4567/// 'flushing' the basket). The committed baskets are then; 4568/// immediately removed from memory.; 4569///; 4570/// The function returns the number of bytes committed to the; 4571/// individual branches.; 4572///; 4573/// If a write error occurs, the number of bytes returned is -1.; 4574///; 4575/// If no data are written, because, e.g., the branch is disabled,; 4576/// the number of bytes returned is 0.; 4577///; 4578/// __The baskets are flushed and the Tree header saved at regular intervals__; 4579///; 4580/// At regular intervals, when the amount of data written so far is; 4581/// greater than fAutoFlush (see SetAutoFlush) a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:184688,simpl,simple,184688,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,['simpl'],['simple']
Usability,"t_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; voidTGLPlotPainter::SetDrawAxes(Bool_t s); voidTGLPlotPainter::SetDrawBackBox(Bool_t b); voidTGLPlotPainter::SetDrawFrontBox(Bool_t b); virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); voidTGLPlotPainter::SetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLTH3CompositionPainter(TGLTH3Composition* data, TGLPlotCamera* camera, TGLPlotCoordinates* coord). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; virtual voidTGLPlotPainter::DrawPaletteAxis() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlotPainter::RestoreProjectionMatrix() const; voidTGLPlotPainter::SaveModelviewMatrix() const; voidTGLPlotPainter::SaveProjectionMatrix() const. private:. virtual voidDeInitGL() const; virtual voidDrawPlot() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; virtual voidInitGL() const; TGLTH3CompositionPainter&operator=(const TGLTH3CompositionPainter& rhs); voidSetColor(Int_t color) const; TGLTH3CompositionPainter(const TGLTH3CompositionPainter& rhs). Data Members; public:. static TGLPlotPainter::ECutAxisIDTGLPlotPainter::kXAxis; static TGLPlotPainter::ECutAxisIDTGLPlotPainter::kYAxis; static TGLPlotPainter::ECutAxisIDTGLPlotPainter::kZAxis. protected:. TGLPlotBoxTGLPlotPainter::fBackBox; TGLBoxCutTGLPlotPainter::fBoxCut; TGLPlotCamera*TGLPlotPainter::fCamera; TGLPlotCoordinates*TGLPlotPainter::fCoord; Bool_tTGLPlotPainter:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLTH3CompositionPainter.html:1616,Clear,ClearBuffers,1616,root/html602/TGLTH3CompositionPainter.html,https://root.cern,https://root.cern/root/html602/TGLTH3CompositionPainter.html,2,['Clear'],['ClearBuffers']
Usability,"t_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidSlaveBegin(TTree*); virtual voidTProofDraw::SlaveTerminate(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTerminate(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual intTProofDraw::Version() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTProofDraw::ClearFormula(); virtual Bool_tTProofDraw::CompileVariables(); virtual voidDefVar(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoFill(Long64_t entry, Double_t w, const Double_t* v); voidTProofDraw::FillWeight(); voidTObject::MakeZombie(); virtual Bool_tTProofDraw::ProcessSingle(Long64_t, Int_t); voidTProofDraw::SetCanvas(const char* objname); voidTProofDraw::SetDrawAtt(TObject* o); voidTProofDraw::SetError(const char* sub, const char* mesg). Data Members; public:. enum TProofDraw::[unnamed] { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tTProofDraw::fDimensionDimension of the current expression; TGraph*fGraph; TStringTProofDraw::fInitialExp; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*TProofDraw::fManager; Int_tTProofDraw::fMultiplicityIndicator of the variability of the s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofDrawGraph.html:5736,Clear,ClearFormula,5736,root/html532/TProofDrawGraph.html,https://root.cern,https://root.cern/root/html532/TProofDrawGraph.html,1,['Clear'],['ClearFormula']
Usability,"t_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidSlaveBegin(TTree*); virtual voidTProofDraw::SlaveTerminate(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTerminate(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual intTProofDraw::Version() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTProofDraw::ClearFormula(); virtual Bool_tTProofDraw::CompileVariables(); virtual voidDefVar(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoFill(Long64_t entry, Double_t w, const Double_t* v); voidTProofDraw::FillWeight(); voidTObject::MakeZombie(); virtual Bool_tTProofDraw::ProcessSingle(Long64_t, Int_t); voidTProofDraw::SetCanvas(const char* objname); voidTProofDraw::SetDrawAtt(TObject* o); voidTProofDraw::SetError(const char* sub, const char* mesg). Data Members; public:. enum TProofDraw::[unnamed] { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tTProofDraw::fDimensionDimension of the current expression; TStringTProofDraw::fInitialExp; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*TProofDraw::fManager; Int_tTProofDraw::fMultiplicityIndicator of the variability of the size of entries;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofDrawListOfGraphs.html:5778,Clear,ClearFormula,5778,root/html532/TProofDrawListOfGraphs.html,https://root.cern,https://root.cern/root/html532/TProofDrawListOfGraphs.html,5,['Clear'],['ClearFormula']
Usability,"t_t w, UInt_t h); virtual~TASPaletteEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TASPaletteEditor.html:1532,Clear,Clear,1532,root/html532/TASPaletteEditor.html,https://root.cern,https://root.cern/root/html532/TASPaletteEditor.html,2,['Clear'],['Clear']
Usability,"t_t* working_space, Int_t num, Int_t hartley, Int_t direction, Int_t zt_clear). AUXILIARY FUNCION. This function calculates Fourier based transform of a part of data; Function parameters:; -working_space-pointer to vector of transformed data; -num-length of processed data; -hartley-1 if it is Hartley transform, 0 othewise; -direction-forward or inverse transform. void BitReverseHaar(Float_t* working_space, Int_t shift, Int_t num, Int_t start). AUXILIARY FUNCION. This function carries out bir-reverse reordering for Haar transform; Function parameters:; -working_space-pointer to vector of processed data; -shift-shift of position of processing; -start-initial position of processed data; -num-length of processed data. Int_t GeneralExe(Float_t* working_space, Int_t zt_clear, Int_t num, Int_t degree, Int_t type). AUXILIARY FUNCION. This function calculates generalized (mixed) transforms of different degrees; Function parameters:; -working_space-pointer to vector of transformed data; -zt_clear-flag to clear imaginary data before staring; -num-length of processed data; -degree-degree of transform (see manual); -type-type of mixed transform (see manual). Int_t GeneralInv(Float_t* working_space, Int_t num, Int_t degree, Int_t type). AUXILIARY FUNCION. This function calculates inverse generalized (mixed) transforms; Function parameters:; -working_space-pointer to vector of transformed data; -num-length of processed data; -degree-degree of transform (see manual); -type-type of mixed transform (see manual). void HaarWalsh2(Float_t** working_matrix, Float_t* working_vector, Int_t numx, Int_t numy, Int_t direction, Int_t type). AUXILIARY FUNCION. This function calculates 2D Haar and Walsh transforms; Function parameters:; -working_matrix-pointer to matrix of transformed data; -working_vector-pointer to vector where the data are processed; -numx,numy-lengths of processed data; -direction-forward or inverse; -type-type of transform (see manual). void FourCos2(Float_t** working_matri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Transform.html:10776,clear,clear,10776,root/html528/TSpectrum2Transform.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Transform.html,6,['clear'],['clear']
Usability,"t_t>. Function Members (Methods); public:. THnT<unsigned int>(); THnT<unsigned int>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin, const Double_t* xmax); ~THnT<unsigned int>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnT_unsigned_int_.html:2261,Clear,Clear,2261,root/html534/THnT_unsigned_int_.html,https://root.cern,https://root.cern/root/html534/THnT_unsigned_int_.html,1,['Clear'],['Clear']
Usability,"t_tRooCacheManager<RooAbsCacheElement>::_lastIndex! Last slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSize! Maximum size; vector<RooNormSetCache>RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen!; RooArgSet*_optCacheObservables! current optCacheObservables; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_size! Actual use; Bool_tRooCacheManager<RooAbsCacheElement>::_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 2, Bool_t clearCacheOnServerRedirect = kTRUE, Bool_t allowOptimize = kFALSE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooObjCacheManager.html:4239,clear,clearCacheOnServerRedirect,4239,root/html602/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html602/RooObjCacheManager.html,8,['clear'],"['clearCacheOnServerRedirect', 'cleared']"
Usability,"t_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTranslationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for translation editor. ~TGeoTranslationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the new matrix. void DoName(); Slot for name. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying changes. void DoCancel(); Slot for cancelling last modifications non-applied. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for dx. void DoDy(); Slot for dx. void DoDz(); Slot for dx. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTranslationEditor.html:21404,undo,undoing,21404,root/html534/TGeoTranslationEditor.html,https://root.cern,https://root.cern/root/html534/TGeoTranslationEditor.html,2,['undo'],['undoing']
Usability,t_tfLastIterfrodo: iteration counter for recursive MakeClassFromVarName; unsigned shortfPat[25][1024]array of patterns; const char*fRegExp[25]corresponding regular expression plain text; Bool_tfVarIsPointerfrodo: pointer or not flag; TSeqCollection*fpClasses; TSeqCollection*fpDirectives; TSeqCollection*fpEnvVars; TSeqCollection*fpFiles; TSeqCollection*fpGlobalFuncs; TSeqCollection*fpGlobals; int*fpLocinitialized by Hook(); TSeqCollection*fpNamespacesContains the names of namespaces registered in CINT.; TSeqCollection*fpPragmas; TSeqCollection*fpSysIncFiles; TSeqCollection*fpUsers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTabCom(); Default constructor. ~TTabCom(); Destructor. void ClearClasses(); Clear classes and namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far. void ClearGlobals(); Forget all global variables seen so far. void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. const TSeqCollection * GetListOfCppDirectives(); Return the list of CPP directives. const TSeqCollection *,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTabCom.html:7191,Clear,ClearGlobalFunctions,7191,root/html532/TTabCom.html,https://root.cern,https://root.cern/root/html532/TTabCom.html,2,['Clear'],['ClearGlobalFunctions']
Usability,"t_tfNBinsNumber of signal-color entries.; Color_tfOverColorOverflow color; UChar_tfOverRGBA[4]; Int_tfOverflowAction; Int_tTEveRefCnt::fRefCount; Bool_tfShowDefValueFlags whether signals with default value should be shown.; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Color_tfUnderColorUnderflow color; UChar_tfUnderRGBA[4]; Int_tfUnderflowAction; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TEveRGBAPalette*fgDefaultPalette. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveRGBAPalette(); Constructor. TEveRGBAPalette(Int_t min, Int_t max, Bool_t interp = kTRUE, Bool_t showdef = kTRUE, Bool_t fixcolrng = kFALSE); Constructor. ~TEveRGBAPalette(); Destructor. void SetupColor(Int_t val, UChar_t* pix) const; Set RGBA color 'pixel' for signal-value 'val'. void SetupColorArray() const; Construct internal color array that maps signal value to RGBA color. void ClearColorArray(); Clear internal color array. void SetLimits(Int_t low, Int_t high); Set low/high limits on signal value. Current min/max values are; clamped into the new limits. void SetLimitsScaleMinMax(Int_t low, Int_t high); Set low/high limits and rescale current min/max values. void SetMin(Int_t min); Set current min value. void SetMax(Int_t max); Set current max value. void SetMinMax(Int_t min, Int_t max); Set current min/max values. void SetInterpolate(Bool_t b); Set interpolation flag. This determines how colors from ROOT's; palette are mapped into RGBA values for given signal. void SetFixColorRange(Bool_t v); Set flag specifying how the palette is mapped to signal values:; true - LowLimit -> HighLimit; false - MinValue -> MaxValue. void SetDefaultColor(Color_t ci); Set default color. void SetDefaultColorPixel(Pixel_t pix); Set default color. void SetDefaultColorRGBA(UChar_t r, UChar_t g, UChar_t b, UChar_t a = 255); Set default color. void SetUnderColor(Color_t ci); Set underflow color. void Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveRGBAPalette.html:12290,Clear,ClearColorArray,12290,root/html532/TEveRGBAPalette.html,https://root.cern,https://root.cern/root/html532/TEveRGBAPalette.html,2,['Clear'],"['Clear', 'ClearColorArray']"
Usability,"t_x, dest_y - specify the upper-left corner of the destination; rectangle. GC components in use: function, plane-mask, subwindow-mode,; graphics-exposure, clip-x-origin, clip-y-origin, and clip-mask.; (see also the GCValues_t structure). void ChangeWindowAttributes(Window_t id, SetWindowAttributes_t* attr); Changes the attributes of the specified window ""id"" according the; values provided in ""attr"". The mask data member of ""attr"" specifies; which window attributes are defined in the attributes argument.; This mask is the bitwise inclusive OR of the valid attribute mask; bits; if it is zero, the attributes are ignored. void ChangeProperty(Window_t id, Atom_t property, Atom_t type, UChar_t* data, Int_t len); Alters the property for the specified window and causes the X server; to generate a PropertyNotify event on that window. id - the window whose property you want to change; property - specifies the property name; type - the type of the property; the X server does not; interpret the type but simply passes it back to; an application that might ask about the window; properties; data - the property data; len - the length of the specified data format. void DrawLine(Drawable_t id, GContext_t gc, Int_t x1, Int_t y1, Int_t x2, Int_t y2); Uses the components of the specified GC to draw a line between the; specified set of points (x1, y1) and (x2, y2). GC components in use: function, plane-mask, line-width, line-style,; cap-style, fill-style, subwindow-mode, clip-x-origin, clip-y-origin,; and clip-mask.; GC mode-dependent components: foreground, background, tile, stipple,; tile-stipple-x-origin, tile-stipple-y-origin, dash-offset, dash-list.; (see also the GCValues_t structure). void ClearArea(Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h); Paints a rectangular area in the specified window ""id"" according to; the specified dimensions with the window's background pixel or pixmap. id - specifies the window; x, y - coordinates, which are relative to the origin; w, h - the wid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualX.html:46742,simpl,simply,46742,root/html528/TVirtualX.html,https://root.cern,https://root.cern/root/html528/TVirtualX.html,10,['simpl'],['simply']
Usability,"ta =; 953 std::vector<Event *>(allData.begin(), allData.begin() + nTrainingSamples);; 954 const std::vector<Event *> testInputData =; 955 std::vector<Event *>(allData.begin() + nTrainingSamples, allData.end());; 956 ; 957 if (trainingInputData.size() != nTrainingSamples) {; 958 Log() << kFATAL << ""Inconsistent training sample size"" << Endl;; 959 }; 960 if (testInputData.size() != nTestSamples) {; 961 Log() << kFATAL << ""Inconsistent test sample size"" << Endl;; 962 }; 963 ; 964 size_t nThreads = 1;; 965 TMVAInput_t trainingTuple = std::tie(trainingInputData, DataInfo());; 966 TMVAInput_t testTuple = std::tie(testInputData, DataInfo());; 967 DataLoader_t trainingData(trainingTuple, nTrainingSamples,; 968 net.GetBatchSize(), net.GetInputWidth(),; 969 net.GetOutputWidth(), nThreads);; 970 DataLoader_t testData(testTuple, nTestSamples, testNet.GetBatchSize(),; 971 net.GetInputWidth(), net.GetOutputWidth(),; 972 nThreads);; 973 DNN::TGradientDescent<TCuda<>> minimizer(settings.learningRate,; 974 settings.convergenceSteps,; 975 settings.testInterval);; 976 ; 977 std::vector<TNet<TCuda<>>> nets{};; 978 std::vector<TBatch<TCuda<>>> batches{};; 979 nets.reserve(nThreads);; 980 for (size_t i = 0; i < nThreads; i++) {; 981 nets.push_back(net);; 982 for (size_t j = 0; j < net.GetDepth(); j++); 983 {; 984 auto &masterLayer = net.GetLayer(j);; 985 auto &layer = nets.back().GetLayer(j);; 986 TCuda<>::Copy(layer.GetWeights(),; 987 masterLayer.GetWeights());; 988 TCuda<>::Copy(layer.GetBiases(),; 989 masterLayer.GetBiases());; 990 }; 991 }; 992 ; 993 bool converged = false;; 994 size_t stepCount = 0;; 995 size_t batchesInEpoch = nTrainingSamples / net.GetBatchSize();; 996 ; 997 std::chrono::time_point<std::chrono::system_clock> start, end;; 998 start = std::chrono::system_clock::now();; 999 ; 1000 if (!fInteractive) {; 1001 Log() << std::setw(10) << ""Epoch"" << "" | ""; 1002 << std::setw(12) << ""Train Err.""; 1003 << std::setw(12) << ""Test Err.""; 1004 << std::setw(12) << ""GFLOP/s""; 1005 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:35082,learn,learningRate,35082,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['learn'],['learningRate']
Usability,"ta member of a ClonesArray); Branch_Name.Leaf_Name; Branch_Name.Method_Name; Leaf_Name[index]; Branch_Name.Leaf_Name[index]; Branch_Name.Leaf_Name[index1]; Branch_Name.Leaf_Name[][index2]; Branch_Name.Leaf_Name[index1][index2]. New additions:; Branch_Name.Leaf_Name[OtherLeaf_Name]; Branch_Name.Datamember_Name; '.' can be replaced by '->'; and. Branch_Name[index1].Leaf_Name[index2]; Leaf_name[index].Action().OtherAction(param); Leaf_name[index].Action()[val].OtherAction(param). The expected returned values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized, or is too long, or tree does not exist.; >=0 : the name has been recognized, return the internal code for this name. . Reimplemented from ROOT::v5::TFormula.; Definition at line 2698 of file TTreeFormula.cxx. ◆ EvalClass() [1/2]. TClass * TTreeFormula::EvalClass ; (; ); const. virtual . Evaluate the class of this treeformula. ; If the 'value' of this formula is a simple pointer to an object, this function returns the TClass corresponding to its type. ; Definition at line 3597 of file TTreeFormula.cxx. ◆ EvalClass() [2/2]. TClass * TTreeFormula::EvalClass ; (; Int_t ; oper); const. protectedvirtual . Evaluate the class of the operation oper. ; If the 'value' in the requested operation is a simple pointer to an object, this function returns the TClass corresponding to its type. ; Definition at line 3610 of file TTreeFormula.cxx. ◆ EvalInstance() [1/2]. template<typename T > . T TTreeFormula::EvalInstance ; (; Int_t ; instance = 0, . const char * ; stringStackArg[] = nullptr . ). Evaluate this treeformula. ; Template Parameters. TThe type used to interpret the numbers then used for the operations . Parameters. instanceiteration instance ; stringStackArgformula as string . Returnsthe result of the evaluation ; Definition at line 3977 of file TTreeFormula.cxx. ◆ EvalInstance() [2/2]. virtual Double_t TTreeFormula::EvalInstance ; (; Int_t ; i = 0, . const char * ; stringStac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormula.html:36756,simpl,simple,36756,doc/master/classTTreeFormula.html,https://root.cern,https://root.cern/doc/master/classTTreeFormula.html,1,['simpl'],['simple']
Usability,"ta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighbouring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int zlight; // z position of fictive light source, applies only for rainbowed display; // modes with shading according to light; i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:72626,simpl,simple,72626,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,2,['simpl'],['simple']
Usability,"ta or choices that are discrete, small and fixed in number, not easily remembered. With check boxes all alternatives are visible: it is easy to access and compare choices because they can all be seen together. Each option acts as a switch and can be either “on” or “off”. It is never changed in contents. Checkboxes differ from radio buttons in that they permit selection of more than one alternative. Each box can be switched on or off independently. These buttons can be used alone or grouped in sets. It is good practice to provide default settings for check boxes whenever it is possible. This can be done by:; SetState(EButtonState state); The parameter state can be one of kButtonUp, kButtonDown, kButtonEngaged, kButtonDisabled.; Check boxes can be used to affect other controls. The contents of a list can, for example, be filtered by setting a check box. In any case, use a check box only when both states of a choice are clearly opposite and unambiguous. If opposite states are not clear, it is better to use two radio buttons.; Choice description, i.e. check box label, must be clear, meaningful, fully spelled out, and displayed in mixed-type text. Whenever the use of a given button is inappropriate, for whatever reason, that button should be disabled:; button->SetState(kButtonDisabled);; Never make a button appear and disappear.; In general, option buttons should not offer more than eight choices. If the number of choices exceeds this maximum, it is better to use a multiple selection list box.; The method IsToggleButton() gives the information whether a radio button or a check button is selected. An option button can be set or unset via its method PSetState(EButtonState state).; The method HandleKey(event) is called when the defined hotkey is hit for any button. It sets the selected option button or clicks the selected text button and invokes its defined action.; 25.8.2 Text Entries; A TGTextEntry is a one-line text input widget. It contains text that is entered or modifi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1184454,clear,clear,1184454,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['clear'],['clear']
Usability,"taFrame will execute in each worker thread concurrently on that thread's partial result.; 335 ///; 336 /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; 337 /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; 338 /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; 339 ///; 340 /// See `OnPartialResult` for a generic explanation of the callback mechanism.; 341 /// Compared to `OnPartialResult`, this method has two major differences:; 342 /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; 343 /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); 344 /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; 345 /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; 346 /// callback concurrently but always with different `slot` numbers.; 347 /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; 348 ///; 349 /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; 350 /// \code; 351 /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; 352 /// std::string progress;; 353 /// std::mutex bar_mutex;; 354 /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; 355 /// std::lock_guard<std::mutex> lg(bar_mutex);; 356 /// progress.push_back('#');; 357 /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; 358 /// });; 359 /// std::cout << ""Analysis running..."" << std::endl;; 360 /// *c; // trigger the event loop by accessing an action's result; 361 /// std",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultPtr_8hxx_source.html:15446,simpl,simplify,15446,doc/master/RResultPtr_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html,1,['simpl'],['simplify']
Usability,"taSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProdPdf.html:3140,Clear,Clear,3140,root/html602/RooProdPdf.html,https://root.cern,https://root.cern/root/html602/RooProdPdf.html,2,['Clear'],['Clear']
Usability,"taStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistPdf.html:2573,Clear,Clear,2573,root/html602/RooHistPdf.html,https://root.cern,https://root.cern/root/html602/RooHistPdf.html,2,['Clear'],['Clear']
Usability,"taStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:7132,clear,clearEvalError,7132,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,1,['clear'],['clearEvalError']
Usability,"taStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModecanNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddPdf.html:3457,Clear,Clear,3457,root/html602/RooAddPdf.html,https://root.cern,https://root.cern/root/html602/RooAddPdf.html,4,['Clear'],['Clear']
Usability,"tabase (default kIndexesBasic) . Normally these functions should be called immediately after TSQLFile constructor. When objects data written to database, by default START TRANSACTION/COMMIT SQL commands are used before and after data storage. If TSQLFile detects any problems, ROLLBACK command will be used to restore previous state of data base. If transactions not supported by SQL server, they can be disabled by SetUseTransactions(kTransactionsOff). Or user can take responsibility to use transactions function himself. By default only indexes for basic tables are created. In most cases usage of indexes increase performance to data reading, but it also can increase time of writing data to database. There are several modes of index usage available in SetUseIndexes() method There is MakeSelectQuery(TClass*) method, which produces SELECT statement to get objects data of specified class. Difference from simple statement like: mysql> SELECT * FROM TH1I_ver1 that not only data for that class, but also data from parent classes will be extracted from other tables and combined in single result table. Such select query can be useful for external access to objects data.; Up to now MySQL 4.1 and Oracle 9i were tested. Some extra work is required for other SQL databases. Hopefully, this should be straightforward.; Known problems and open questions.; TTree is not supported by TSQLFile. There is independent development of TTreeSQL class, which allows to store trees directly in SQL database; TClonesArray is store objects in raw format, which can not be accessed outside ROOT. This will be changed later.; TDirectory cannot work. Hopefully, will (changes in ROOT basic I/O is required); Streamer infos are not written to file, therefore schema evolution is not yet supported. All eforts are done to enable this feature in the near future. Example how TSQLFile can be used; A session saving data to a SQL data base; auto dbname = ""mysql://host.domain:3306/dbname"";; auto username = ""username"";;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:5146,simpl,simple,5146,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['simpl'],['simple']
Usability,tabase ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlfilldb.py Fill run catalog with nfiles entries ;  sqlselect.CQuery example to MySQL test database ;  sqlselect.py Query example to MySQL test database ;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► envelope;  classification.C;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVACrossValidationApplication.C This macro provides an example of how to use TMVA for k-folds cross evaluation in application ;  TMVACrossValidationRegression.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAMinimalClassification.C Minimal self-contained example for setting up TMVA with binary classifi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:158516,simpl,simple,158516,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['simpl'],['simple']
Usability,"table is exists or; wildcard with ""%"" (any number of symbols) and ""_"" (exactly one symbol).; Example of vaild wildcards: ""%"", ""%name"",""___user__"".; If wild=="""", list of all available tables will be produced.; List contain just tables names in the TObjString.; List must be deleted by the user.; Example code of method usage:. TList* lst = serv->GetTablesList();; TIter next(lst);; TObject* obj;; while (obj = next()); std::cout << ""Table: "" << obj->GetName() << std::endl;; delete lst;. Bool_t HasTable(const char* tablename); Tests if table of that name exists in database; Return kTRUE, if table exists. TSQLTableInfo* GetTableInfo(const char* tablename); Producec TSQLTableInfo object, which contain info about; table itself and each table column; Object must be deleted by user. void SetFloatFormat(const char* fmt = ""%e""); set printf format for float/double members, default ""%e"". const char* GetFloatFormat(); return current printf format for float/double members, default ""%e"". TSQLServer(); { ClearError(); }. virtual ~TSQLServer(); { }. void Close(Option_t* option = """"). TSQLResult * Query(const char* sql). Bool_t HasStatement() const; { return kFALSE; }. Int_t SelectDataBase(const char* dbname). TSQLResult * GetDataBases(const char* wild = 0). TSQLResult * GetTables(const char* dbname, const char* wild = 0). TSQLResult * GetColumns(const char* dbname, const char* table, const char* wild = 0). Int_t GetMaxIdentifierLength(); { return 20; }. Int_t CreateDataBase(const char* dbname). Int_t DropDataBase(const char* dbname). Int_t Reload(). Int_t Shutdown(). const char * ServerInfo(). Bool_t IsConnected() const; { return fPort == -1 ? kFALSE : kTRUE; }. const char * GetDBMS() const; { return fType.Data(); }. const char * GetDB() const; { return fDB.Data(); }. const char * GetHost() const; { return fHost.Data(); }. Int_t GetPort() const; { return fPort; }. Bool_t IsError() const; { return GetErrorCode()!=0; }. void EnableErrorOutput(Bool_t on = kTRUE); { fErrorOut = on; }. Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLServer.html:11497,Clear,ClearError,11497,root/html602/TSQLServer.html,https://root.cern,https://root.cern/root/html602/TSQLServer.html,2,['Clear'],['ClearError']
Usability,"table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the sie of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. void SetSimpleArray(Int_t arraySize, Int_t firstRow, Int_t numberRows); Set some common parameteres for the ""simple"" arrays. ~TTableSorter(); to be documented. Int_t BSearch(valuetype value). Int_t SelectSearch(valuetype value). Int_t BSearch(const void* value) const; to be documented. Int_t GetIndex(UInt_t sortedIndex) const; returns the original index of the row by its sorted index. Int_t CountKey(const void* key, Int_t firstIndx = 0, Bool_t bSearch = kTRUE, Int_t* firstRow = 0) const. CountKey counts the number of rows with the key value equal ""key"". key - it is a POINTER to the key value; fistIndx - the first index within sorted array to star search; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTableSorter.html:17067,simpl,simpleArray,17067,root/html528/TTableSorter.html,https://root.cern,https://root.cern/root/html528/TTableSorter.html,10,['simpl'],['simpleArray']
Usability,"table. SimpleLightHeightLight-Height. Points XXXX; Grid XXXX; Contours X-X-; Bars X-X-; LinesX XXXX; LinesY XXXX; BarsX X-X-; BarsY X-X-; Needles X---; Surface -XXX; TrianglesXXXX. Function:; void TSpectrum2Painter::SetDisplayMode (Int_t modeGroup, Int_t displayMode). This function controls the display mode group and display mode of the; histogram drawing. To illustrate the possible effects of the various display; modes we introduce a set of examples. Default values:. modeGroup = kModeGroupLightHeight ; displayMode = kDisplayModeSurface . Simple modes group, display mode = points, 256 x 256 channels. Simple modes group, display mode = grid, 64 x 64 channels. Simple modes group, display mode = contours, 64 x 64 channels. Simple modes group, display mode = bars, 64 x 64 channels. Simple modes group, display mode = linesX, 64 x 64 channels. Simple modes group, display mode = linesY, 64 x 64 channels. Simple modes group, display mode = barsX, 64 x 64 channels. Simple modes group, display mode = barsY, 64 x 64 channels. Simple modes group, display mode = needles, 64 x 64 channels. Simple modes group, display mode = triangles, 64 x 64 channels. Light modes group, display mode = points, 256 x 256 channels. Light modes group, display mode = grid, 256 x 256 channels. Light modes group, display mode = surface, 64 x 64 channels. Light modes group, display mode = triangles, 64 x 64 channels. Height modes group, display mode = points, 256 x 256 channels. Height modes group, display mode = grid, 256 x 256 channels. Height modes group, display mode = contours, 64 x 64 channels. Height modes group, display mode = bars, 64 x 64 channels. Height modes group, display mode = surface, 64 x 64 channels. Height modes group, display mode = triangles, 64 x 64 channels. Light - height modes group, display mode = surface, 64 x 64 channels. The weight; between both shading algorithms is set to 0.5. One can observe the influence of; both shadings.; Function:; TSpectrum2Painter::SetPenAttr(Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSpectrum2Painter.html:18255,Simpl,Simple,18255,root/html532/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html532/TSpectrum2Painter.html,4,['Simpl'],['Simple']
Usability,"table::AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidCheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElementList*TEveElementList::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(); voidTEveElement::CSCTakeAny",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveTrackPropagator.html:2911,Clear,ClearStamps,2911,root/html532/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html532/TEveTrackPropagator.html,4,['Clear'],['ClearStamps']
Usability,"tableDescriptor_st *)At(column))->fOffset = offset;}. void SetSize(UInt_t size, Int_t column); {((tableDescriptor_st *)At(column))->fSize = size; }. void SetTypeSize(UInt_t size, Int_t column); {((tableDescriptor_st *)At(column))->fTypeSize = size; }. void SetDimensions(UInt_t dim, Int_t column); {((tableDescriptor_st *)At(column))->fDimensions = dim; }. void SetColumnType(TTable::EColumnType type, Int_t column); {((tableDescriptor_st *)At(column))->fType = type; }. void Init(TClass* classPtr). void SetCommentsSetName(const char* name = "".comments""). TTableDescriptor(const TTable* parentTable). TTableDescriptor(TClass* classPtr). TTableDescriptor(const TTableDescriptor& dsc); {}. virtual ~TTableDescriptor(). Int_t AddAt(const void* c). void AddAt(const void* c, Int_t i). void AddAt(const tableDescriptor_st& element, const char* comment, Int_t indx). void AddAt(TDataSet* dataset, Int_t idx = 0). TString CreateLeafList() const. void LearnTable(const TTable* parentTable). void LearnTable(TClass* classPtr). Int_t ColumnByName(const Char_t* columnName = 0) const. UInt_t Offset(Int_t column) const. UInt_t ColumnSize(Int_t column) const. UInt_t TypeSize(Int_t column) const. UInt_t Dimensions(Int_t column) const. Int_t Sizeof() const. Int_t UpdateOffsets(const TTableDescriptor* newDesciptor). TTableDescriptor * MakeDescriptor(const char* structName). TDataSet * MakeCommentField(Bool_t createFlag = kTRUE). TTableDescriptor * GetDescriptorPointer() const. void SetDescriptorPointer(TTableDescriptor* list). TTableDescriptor(); {SetType(""tableDescriptor_st"");}. TTableDescriptor(const char* name); {SetType(""tableDescriptor_st"");}. TTableDescriptor(Int_t n); {SetType(""tableDescriptor_st"");}. TTableDescriptor(const char* name, Int_t n); {SetType(""tableDescriptor_st"");}. tableDescriptor_st * GetTable(Int_t i = 0) const; { return ((tableDescriptor_st *)GetArray())+i;}. tableDescriptor_st & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const tableDescri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTableDescriptor.html:17491,Learn,LearnTable,17491,root/html532/TTableDescriptor.html,https://root.cern,https://root.cern/root/html532/TTableDescriptor.html,1,['Learn'],['LearnTable']
Usability,"tained in this RResultPtr; 338 /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; 339 ///; 340 /// See `OnPartialResult` for a generic explanation of the callback mechanism.; 341 /// Compared to `OnPartialResult`, this method has two major differences:; 342 /// - all worker threads invoke the callback once every specified number of events. The event count is per-thread,; 343 /// and callback invocation might happen concurrently (i.e. the callback must be thread-safe); 344 /// - the callable must take an extra `unsigned int` parameter corresponding to a multi-thread ""processing slot"":; 345 /// this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the; 346 /// callback concurrently but always with different `slot` numbers.; 347 /// - a value of 0 for everyNEvents indicates the callback must be executed once _per slot_.; 348 ///; 349 /// For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame; 350 /// \code; 351 /// auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; 352 /// std::string progress;; 353 /// std::mutex bar_mutex;; 354 /// c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; 355 /// std::lock_guard<std::mutex> lg(bar_mutex);; 356 /// progress.push_back('#');; 357 /// std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; 358 /// });; 359 /// std::cout << ""Analysis running..."" << std::endl;; 360 /// *c; // trigger the event loop by accessing an action's result; 361 /// std::cout << ""\nDone!"" << std::endl;; 362 /// \endcode; 363 // clang-format on; 364 RResultPtr<T> &OnPartialResultSlot(ULong64_t everyNEvents, std::function<void(unsigned int, T &)> callback); 365 {; 366 ThrowIfNull();; 367 auto actionPtr = fActionPtr;; 368 auto c = [actionPtr, callback](unsigned int slot) {; 369 auto partialResult = static_cast<Value_t *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultPtr_8hxx_source.html:15777,progress bar,progress bar,15777,doc/master/RResultPtr_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html,1,['progress bar'],['progress bar']
Usability,"tainer(); virtual voidUndocked()SIGNAL ; virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGDockableFrame&operator=(const TGDockableFrame&); TGDockableFrame(const TGDockableFrame&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditModeTGWindow::kEditDisableEvents; static TGWindow::EEd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGDockableFrame.html:15851,Clear,ClearFlags,15851,root/html602/TGDockableFrame.html,https://root.cern,https://root.cern/root/html602/TGDockableFrame.html,2,['Clear'],['ClearFlags']
Usability,"taining the parameter of interest; Double_tfUpperLimitupper interval limit; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimpleInterval(const char* name = 0); Default constructor. SimpleInterval(const RooStats::SimpleInterval& other, const char* name); fParameters.add( other.fParameters );. operator=(const RooStats::SimpleInterval& other). SimpleInterval(const char* name, const RooRealVar& var, Double_t lower, Double_t upper, Double_t cl); Alternate constructor. ~SimpleInterval(); Destructor. Bool_t IsInInterval(const RooArgSet& ) const. RooArgSet* GetParameters() const; return cloned list of parameters. Bool_t CheckParameters(const RooArgSet& ) const. explicit SimpleInterval(const char* name = 0); default constructors. void SetConfidenceLevel(Double_t ); set the confidence level for the interval. Simple interval is defined at construction time so this function; has no effect. {}. Double_t ConfidenceLevel() const; return the confidence interval. {return fConfidenceLevel;}. Double_t LowerLimit(); return the interval lower limit. {return fLowerLimit;}. Double_t UpperLimit(); return the interval upper limit. {return fUpperL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__SimpleInterval.html:7239,Simpl,SimpleInterval,7239,root/html602/RooStats__SimpleInterval.html,https://root.cern,https://root.cern/root/html602/RooStats__SimpleInterval.html,2,['Simpl'],['SimpleInterval']
Usability,"tance; Inherited Members; Includes; Libraries. Function documentation; TLeafD(); Default constructor for LeafD*-*-*-*-*-*-*-*-; *-* ============================. TLeafD(TBranch* parent, const char* name, const char* type); Create a LeafD*-*-; *-* ==============; -. ~TLeafD(); Default destructor for a LeafD*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* ==========================================. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s); read a double from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Double_t GetValue(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { return fValue[i]; }. TLeafD(). const char * GetTypeName() const; {return ""Double_t"";}. void * GetValuePointer() const; {return fValue;}. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TLeafD.h 36407 2010-10-22 02:04:08Z pcanal $ » Last generated: 2010-10-22 11:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLeafD.html:8984,simpl,simple,8984,root/html528/TLeafD.html,https://root.cern,https://root.cern/root/html528/TLeafD.html,1,['simpl'],['simple']
Usability,"tance; Inherited Members; Includes; Libraries. Function documentation; TLeafD(); Default constructor for LeafD*-*-*-*-*-*-*-*-; *-* ============================. TLeafD(TBranch* parent, const char* name, const char* type); Create a LeafD*-*-; *-* ==============; -. ~TLeafD(); Default destructor for a LeafD*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* ==========================================. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s); read a double from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Double_t GetValue(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { return fValue[i]; }. TLeafD(). const char * GetTypeName() const; {return ""Double_t"";}. void * GetValuePointer() const; {return fValue;}. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TLeafD.h 36407 2010-10-22 02:04:08Z pcanal $ » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TLeafD.html:9053,simpl,simple,9053,root/html530/TLeafD.html,https://root.cern,https://root.cern/root/html530/TLeafD.html,1,['simpl'],['simple']
Usability,"tance; Inherited Members; Includes; Libraries. Function documentation; TLeafD(); Default constructor for LeafD*-*-*-*-*-*-*-*-; *-* ============================. TLeafD(TBranch* parent, const char* name, const char* type); Create a LeafD*-*-; *-* ==============; -. ~TLeafD(); Default destructor for a LeafD*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* ==========================================. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s); read a double from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Double_t GetValue(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { return fValue[i]; }. TLeafD(). const char * GetTypeName() const; {return ""Double_t"";}. void * GetValuePointer() const; {return fValue;}. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TLeafD.h 36407 2010-10-22 02:04:08Z pcanal $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLeafD.html:9053,simpl,simple,9053,root/html532/TLeafD.html,https://root.cern,https://root.cern/root/html532/TLeafD.html,2,['simpl'],['simple']
Usability,"tas (back-propagation)Definition NeuralNet.h:595; TMVA::DNN::LayerData::m_hasDropOutbool m_hasDropOutdropOut is turned on?Definition NeuralNet.h:646; TMVA::DNN::LayerData::m_isInputLayerbool m_isInputLayeris this layer an input layerDefinition NeuralNet.h:654; TMVA::DNN::LayerData::m_sizesize_t m_sizeDefinition NeuralNet.h:637; TMVA::DNN::LayerData::hasDropOutbool hasDropOut() consthas this layer drop-out turned on?Definition NeuralNet.h:622; TMVA::DNN::LayerData::valueGradientsBeginconst_iterator_type valueGradientsBegin() constreturns const iterator to the begin of the gradientsDefinition NeuralNet.h:600; TMVA::DNN::LayerData::valueGradientsEndconst_iterator_type valueGradientsEnd() constreturns const iterator to the end of the gradientsDefinition NeuralNet.h:601; TMVA::DNN::LayerData::probabilitiescontainer_type probabilities() constcomputes the probabilities from the current node values and returns themDefinition NeuralNet.h:589; TMVA::DNN::LayerData::clearDropOutvoid clearDropOut()clear the drop-out-data for this layerDefinition NeuralNet.h:620; TMVA::DNN::LayerData::m_eModeOutputModeOutputValues m_eModeOutputstores the output mode (DIRECT, SIGMOID, SOFTMAX)Definition NeuralNet.h:658; TMVA::DNN::LayerData::m_inverseActivationFunctionstd::shared_ptr< std::function< double(double)> > m_inverseActivationFunctioninverse activation function for this layerDefinition NeuralNet.h:652; TMVA::DNN::LayerData::const_dropout_iteratorDropContainer::const_iterator const_dropout_iteratorDefinition NeuralNet.h:448; TMVA::DNN::LayerData::valuesBeginconst_iterator_type valuesBegin() constreturns const iterator to the begin of the (node) valuesDefinition NeuralNet.h:582; TMVA::DNN::LayerData::m_activationFunctionstd::shared_ptr< std::function< double(double)> > m_activationFunctionactivation function for this layerDefinition NeuralNet.h:651; TMVA::DNN::LayerLayer defines the layout of a layer.Definition NeuralNet.h:673; TMVA::DNN::Layer::modeOutputValuesvoid modeOutputValues(ModeOu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:60373,clear,clearDropOutvoid,60373,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,3,['clear'],"['clear', 'clearDropOut', 'clearDropOutvoid']"
Usability,"taset manager is configured to allow so).; Returns kTRUE on success. Int_t SetDataSetTreeName(const char* dataset, const char* treename); Set/Change the name of the default tree. The tree name may contain; subdir specification in the form ""subdir/name"".; Returns 0 on success, -1 otherwise. TMap * GetDataSets(const char* uri = """", const char* optStr = """"); Lists all datasets that match given uri.; The 'optStr' can contain a comma-separated list of servers for which the; information is wanted. If ':lite:' (case insensitive) is specified in 'optStr'; only the global information in the TFileCollection is retrieved; useful to only; get the list of available datasets. void ShowDataSets(const char* uri = """", const char* optStr = """"); Shows datasets in locations that match the uri.; By default shows the user's datasets and global ones. Bool_t ExistsDataSet(const char* dataset); Returns kTRUE if 'dataset' exists, kFALSE otherwise. void ClearDataSetCache(const char* dataset = 0); Clear the content of the dataset cache, if any (matching 'dataset', if defined). void ShowDataSetCache(const char* dataset = 0); Display the content of the dataset cache, if any (matching 'dataset', if defined). TFileCollection * GetDataSet(const char* dataset, const char* optStr = """"); Get a list of TFileInfo objects describing the files of the specified; dataset.; To get the short version (containing only the global meta information); specify optStr = ""S:"" or optStr = ""short:"".; To get the sub-dataset of files located on a given server(s) specify; the list of servers (comma-separated) in the 'optStr' field. void ShowDataSet(const char* dataset = """", const char* opt = ""M""); display meta-info for given dataset usi. Int_t RemoveDataSet(const char* dataset, const char* optStr = """"); Remove the specified dataset from the PROOF cluster.; Files are not deleted. TList* FindDataSets(const char* searchString, const char* optStr = """"); Find datasets, returns in a TList all found datasets. Int_t VerifyDataSet(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProof.html:82314,Clear,ClearDataSetCache,82314,root/html532/TProof.html,https://root.cern,https://root.cern/root/html532/TProof.html,2,['Clear'],"['Clear', 'ClearDataSetCache']"
Usability,"tate of the edited object, it is possible to undo a sequence of commands by traversing the command stack downwards and calling the ""undo"" method of each command in turn. It is also possible to redo a sequence of commands by traversing the command stack upwards and calling the ""redo"" method of each command.; Examples:. Create a new command TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");; TQCommandThe Command design pattern is based on the idea, that all editing in an application is done by creati...Definition TQCommand.h:27. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");; For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color; ; com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);; Color_tshort Color_tDefinition RtypesCore.h:85; TQCommand::SetRedoArgsvirtual void SetRedoArgs(Int_t nargs,...)Set redo parameters.Definition TQCommand.cxx:508; TQCommand::SetUndoArgsvirtual void SetUndoArgs(Int_t nargs,...)Set undo parameters.Definition TQCommand.cxx:542; 1st argument - the number of undo, redo parameters the other arguments - undo, redo values Since the number of undo,redo parameters is the same one can use com->SetArgs(1, new_color, old_color);; TQCommand::SetArgsvirtual void SetArgs(Int_t nargs,...)Set do/redo and undo parameters.Definition TQCommand.cxx:465. Undo, redo method execution com->Redo(); // execute redo method; com->Undo(); // execute undo method; TQCommand::Undovirtual void Undo(Option_t *option="""")Un-execute all merged commands and the command.Definition TQCommand.cxx:626; TQCommand::Redovi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:1781,undo,undo,1781,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"tatement() method; should be used. Depending on the driver used for an ODBC connection,; the appropriate object instance will be created. For the moment there are; six different implementations of the TSQLStatement class: for MySQL,; Oracle, SAPDB, PostgreSQL, SQLite3 and ODBC. Hopefully, support of ODBC will allow usage of; statements for most existing RDBMS. // first, connect to the database; TSQLServer* serv = TSQLServer::Connect(""mysql://hostname.domain:3306/test"",; ""user"", ""pass"");; // check if connection is ok; if ((serv!=0) && serv->IsConnected()) {; // create instance of sql-statement; TSQLStatement* stmt = serv->Statement(""CREATE TABLE TESTTABLE (ID1 INT, ID2 INT, FFIELD VARCHAR(255), FVALUE VARCHAR(255))"";; // process statement; stmt->Process();; // destroy object; delete stmt;; }; delete serv;. 2. Insert data to data base. There is a special syntax of SQL queries which allows to use values; provided as parameters. For instance, to insert one row into the TESTTABLE created; with the previous example, one can simply execute a query like:. serv->Query(""INSERT INTO TESTTABLE VALUES (1, 2, \""name1\"", \""value1\"""");. However, when many (100-1000) rows should be inserted, each call of; TSQLServer::Query() method will cause communication loop with database; server, and the statement has to be evaluated each time instead of using a prepared statement.; As a result, insertion of data takes too much time. TSQLStatement provides a mechanism to insert many rows at once.; First of all, an appropriate statement should be created:. TSQLStatement* stmt = serv->Statement(""INSERT INTO TESTTABLE (ID1, ID2, FFIELD, FVALUE) VALUES (?, ?, ?, ?)"", 100);. Here question marks ""?"" indicate where statement parameters can be inserted.; To specify values of parameters, SetInt(), SetDouble(), SetString() and other; methods of the TSQLStatement class should be used. Before parameters values; can be specified, the NextIteration() method of statement class should be called.; For each new ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLStatement.html:1947,simpl,simply,1947,root/html534/TSQLStatement.html,https://root.cern,https://root.cern/root/html534/TSQLStatement.html,6,['simpl'],['simply']
Usability,"tatic Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHtml(const TGWindow* p, int w, int h, int id = -1); HTML Widget constructor. ~TGHtml(); HTML widget destructor. void UpdateBackgroundStart(); Start background update. void FreeColor(ColorStruct_t* color); Free system color. ColorStruct_t * AllocColor(const char* name); Allocate system color by name. ColorStruct_t * AllocColorByValue(ColorStruct_t* color); Allocate system color by value. void Clear(Option_t* = """"); Erase all HTML from this widget and clear the screen. This is; typically done before loading a new document. int ParseText(char* text, const char* index = 0); Appends (or insert at the specified position) the given HTML text to the; end of any HTML text that may have been inserted by prior calls to this; command. Then it runs the tokenizer, parser and layout engine as far as; possible with the text that is available. The display is updated; appropriately. void SetTableRelief(int relief); Sets relief mode of html table. void SetRuleRelief(int relief); Sets relief mode of html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGHtml.html:32037,clear,clear,32037,root/html528/TGHtml.html,https://root.cern,https://root.cern/root/html528/TGHtml.html,8,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"tatic TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimpleInterval(const char* name = 0); Default constructor. SimpleInterval(const RooStats::SimpleInterval& other, const char* name); fParameters.add( other.fParameters );. operator=(const RooStats::SimpleInterval& other). SimpleInterval(const char* name, const RooRealVar& var, Double_t lower, Double_t upper, Double_t cl); Alternate constructor. ~SimpleInterval(); Destructor. Bool_t IsInInterval(const RooArgSet& ) const. RooArgSet* GetParameters() const; return cloned list of parameters. Bool_t CheckParameters(const RooArgSet& ) const. explicit SimpleInterval(const char* name = 0); default constructors. void SetConfidenceLevel(Double_t ); set the confidence level for the interval. Simple interval is defined at construction time so this function; has no effect. {}. Double_t ConfidenceLevel() const; return the confidence interval. {return fConfidenceLevel;}. Double_t LowerLimit(); return the interval lower limit. {return fLowerLimit;}. Double_t UpperLimit(); return the interval upper limit. {return fUpperLimit;}. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-02 15:35; This page has been automatically generated. For commen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooStats__SimpleInterval.html:7460,Simpl,SimpleInterval,7460,root/html604/RooStats__SimpleInterval.html,https://root.cern,https://root.cern/root/html604/RooStats__SimpleInterval.html,1,['Simpl'],['SimpleInterval']
Usability,"tatic TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimpleInterval(const char* name = 0); Default constructor. SimpleInterval(const RooStats::SimpleInterval& other, const char* name); fParameters.add( other.fParameters );. operator=(const RooStats::SimpleInterval& other). SimpleInterval(const char* name, const RooRealVar& var, Double_t lower, Double_t upper, Double_t cl); Alternate constructor. ~SimpleInterval(); Destructor. Bool_t IsInInterval(const RooArgSet& ) const. RooArgSet* GetParameters() const; return cloned list of parameters. Bool_t CheckParameters(const RooArgSet& ) const. explicit SimpleInterval(const char* name = 0); default constructors. void SetConfidenceLevel(Double_t ); set the confidence level for the interval. Simple interval is defined at construction time so this function; has no effect. {}. Double_t ConfidenceLevel() const; return the confidence interval. {return fConfidenceLevel;}. Double_t LowerLimit(); return the interval lower limit. {return fLowerLimit;}. Double_t UpperLimit(); return the interval upper limit. {return fUpperLimit;}. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:37; This page has been automatically generated. For commen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__SimpleInterval.html:7460,Simpl,SimpleInterval,7460,root/html602/RooStats__SimpleInterval.html,https://root.cern,https://root.cern/root/html602/RooStats__SimpleInterval.html,1,['Simpl'],['SimpleInterval']
Usability,"tatic TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_tfAreaBin area; Bool_tfChangedFor the 3D Painter; Double_tfContentBin content; Int_tfNumberBin number of the bin in TH2Poly; TObject*fPolyObject holding the polygon definition; Double_tfXmaxX maximum value; Double_tfXminX minimum value; Double_tfYmaxY maximum value; Double_tfYminY minimum value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH2PolyBin(); Default constructor. TH2PolyBin(TObject* poly, Int_t bin_number); Normal constructor. ~TH2PolyBin(); Destructor. Double_t GetArea(); Returns the area of the bin. Double_t GetXMax(); Returns the maximum value for the x coordinates of the bin. Double_t GetXMin(); Returns the minimum value for the x coordinates of the bin. Double_t GetYMax(); Returns the maximum value for the y coordinates of the bin. Double_t GetYMin(); Returns the minimum value for the y coordinates of the bin. Bool_t IsInside(Double_t x, Double_t y) const; Return ""true"" if the point (x,y) is inside the bin. TH2PolyBin(). void ClearContent(); {fContent = 0;}. void Fill(Double_t w); {fContent = fContent+w; SetChanged(true);}. Double_t GetContent() const; {return fContent;}. Bool_t GetChanged() const; {return fChanged;}. Int_t GetBinNumber() const; {return fNumber;}. TObject * GetPolygon() const; {return fPoly;}. void SetChanged(Bool_t flag); {fChanged = flag;}. void SetContent(Double_t content); {fContent = content; SetChanged(true);}. » Author: Olivier Couet, Deniz Gunceler » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-30 15:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2PolyBin.html:11895,Clear,ClearContent,11895,root/html602/TH2PolyBin.html,https://root.cern,https://root.cern/root/html602/TH2PolyBin.html,1,['Clear'],['ClearContent']
Usability,"tatic TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_tfAreaBin area; Bool_tfChangedFor the 3D Painter; Double_tfContentBin content; Int_tfNumberBin number of the bin in TH2Poly; TObject*fPolyObject holding the polygon definition; Double_tfXmaxX maximum value; Double_tfXminX minimum value; Double_tfYmaxY maximum value; Double_tfYminY minimum value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH2PolyBin(); Default constructor. TH2PolyBin(TObject* poly, Int_t bin_number); Normal constructor. ~TH2PolyBin(); Destructor. Double_t GetArea(); Returns the area of the bin. Double_t GetXMax(); Returns the maximum value for the x coordinates of the bin. Double_t GetXMin(); Returns the minimum value for the x coordinates of the bin. Double_t GetYMax(); Returns the maximum value for the y coordinates of the bin. Double_t GetYMin(); Returns the minimum value for the y coordinates of the bin. Bool_t IsInside(Double_t x, Double_t y) const; Return ""true"" if the point (x,y) is inside the bin. TH2PolyBin(). void ClearContent(); {fContent = 0;}. void Fill(Double_t w); {fContent = fContent+w; SetChanged(true);}. Double_t GetContent() const; {return fContent;}. Bool_t GetChanged() const; {return fChanged;}. Int_t GetBinNumber() const; {return fNumber;}. TObject * GetPolygon() const; {return fPoly;}. void SetChanged(Bool_t flag); {fChanged = flag;}. void SetContent(Double_t content); {fContent = content; SetChanged(true);}. » Author: Olivier Couet, Deniz Gunceler » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TH2PolyBin.html:11895,Clear,ClearContent,11895,root/html604/TH2PolyBin.html,https://root.cern,https://root.cern/root/html604/TH2PolyBin.html,1,['Clear'],['ClearContent']
Usability,"tatic const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetRange(Float_t min, Float_t max); Set min and max of progress bar. void SetPosition(Float_t pos); Set progress position between [min,max]. void Increment(Float_t inc); Increment progress position. void Reset(); Reset progress bar (i.e. set pos to 0). void SetFillType(TGProgressBar::EFillType type); Set fill type. void SetBarType(TGProgressBar::EBarType type); Set bar type. void SetBarColor(ULong_t color); Set progress bar color. void SetBarColor(const char* color = ""blue""); Set progress bar color. void Format(const char* format = ""%.2f""); Set format for displaying a value. FontStruct_t GetDefaultFontStruct(); Return default font structure in use. const TGGC & GetDefaultGC(); Return default graphics context in use. void SetForegroundColor(Pixel_t pixel); Change text color drawing. void SavePrimitive(ostream& out, Option_t* option = """"); Save progress bar parameters as a C++ statement(s) on output stream out. Bool_t fDrawBar; // if true draw only bar in DoRedraw(). virtual ~TGProgressBar(); { }. Float_t GetMin() const; { return fMin; }. Float_t GetMax() const; { return fMax; }. Float_t GetPosition() const; { return fPos; }. EFillType GetFillType() const; { return fFillType; }. EBarType GetBarType()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGProgressBar.html:19282,progress bar,progress bar,19282,root/html528/TGProgressBar.html,https://root.cern,https://root.cern/root/html528/TGProgressBar.html,6,['progress bar'],['progress bar']
Usability,"taticInitOK=true) const override;  Query internal generation capabilities of component p.d.f.s and aggregate capabilities into master configuration passed to the generator context. ;  ; void initGenerator (Int_t code) override;  Forward one-time initialization call to component generation initialization methods. ;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  If all components that depend on obs are binned that so is the product. ;  ; bool isDirectGenSafe (const RooAbsArg &arg) const override;  Forward determination of safety of internal generator code to component p.d.f that would generate the given observable. ;  ; const RooArgList & pdfList () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const override;  Forward the plot sampling hint from the p.d.f. that defines the observable obs. ;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooProdPdf to more intuitively reflect the contents of the product operator construction. ;  ; bool redirectServersHook (const RooAbsCollection &, bool, bool, bool) override;  Implement support for node removal. ;  ; void removePdfs (RooAbsCollection const &pdfs);  Remove some PDFs from the factors of this RooProdPdf. ;  ; void selectNormalizationRange (const char *rangeName=nullptr, bool force=false) override;  Interface function used by test statistics to freeze choice of range for interpretation of conditional product terms. ;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setDefNormSet (const RooArgSet &nset);  ; void setSelfNormalized (bool flag);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default construc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:6636,intuit,intuitively,6636,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,1,['intuit'],['intuitively']
Usability,tation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspectorUtility class to plot conditional MLE of nuisance parameters vs ;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset ;  CProofConfigHolds configuration options for proof and proof-lite ;  CProposalFunctionProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ;  CSamplingDistPlotThis class provides simple and straightforward utilities to plot SamplingDistribution objects ;  CSamplingDistributionThis class simply holds a sampling distribution of some test statistic ;  CSamplingSummary;  CSamplingSummaryLookup;  CSequentialProposalClass implementing a proposal function that samples the parameter space by moving only in one coordinate (chosen randomly) at each step ;  CSimpleIntervalSimpleInterval is a concrete implementation of the ConfInterval interface ;  CSimpleLikelihoodRatioTestStatTestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood ;  CSPlotThis class calculates sWeights used to create an sPlot ;  CTestStatisticTestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class ;  CTestStatSamplerTestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions ;  CToyMCImportanceSamplerToyMCImportanceSampler is an extension of the ToyMCSampler for Impor,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:9000,simpl,simple,9000,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,5,['simpl'],['simple']
Usability,"tatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfCounternumber of times the stopwatch was started; Double_tfStartCpuTimecpu start time; Double_tfStartRealTimewall clock start time; TStopwatch::EStatefStatestopwatch state; Double_tfStopCpuTimecpu stop time; Double_tfStopRealTimewall clock stop time; Double_tfTotalCpuTimetotal cpu time; Double_tfTotalRealTimetotal real time. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStopwatch(); Create a stopwatch and start it. void Start(Bool_t reset = kTRUE); Start the stopwatch. If reset is kTRUE reset the stopwatch before; starting it (including the stopwatch counter).; Use kFALSE to continue timing after a Stop() without; resetting the stopwatch. void Stop(); Stop the stopwatch. void Continue(); Resume a stopped stopwatch. The stopwatch continues counting from the last; Start() onwards (this is like the laptimer function). Double_t RealTime(); Stop the stopwatch (if it is running) and return the realtime (in; seconds) passed between the start and stop events. Double_t CpuTime(); Stop the stopwatch (if it is running) and return the cputime (in; seconds) passed between the start and stop events. Double_t GetRealTime(); Private static method returning system realtime. Double_t GetCPUTime(); Private static method returning system CPU time. void Print(Option_t* option = """") const; Print the real and cpu time passed between the start and stop events.; and the number of times (slices) this TStopwatch was called; (if this number > 1). If opt=""m"" print out realtime in milli second; precision. If opt=""u"" print out realtime in micro second precision. TStopwatch(). Int_t Counter() const; { return fCounter; }. void Reset(); { ResetCpuTime(); ResetRealTime(); }. void ResetCpuTime(Double_t time =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStopwatch.html:6231,Resume,Resume,6231,root/html532/TStopwatch.html,https://root.cern,https://root.cern/root/html532/TStopwatch.html,2,['Resume'],['Resume']
Usability,"tatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfRotationMatrix[9]rotation matrix; Double_tfScale[3]scale component; Double_tfTranslation[3]translation component. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHMatrix(); dummy ctor. TGeoHMatrix(const char* name); constructor. TGeoHMatrix(const TGeoMatrix& matrix); assignment. ~TGeoHMatrix(); destructor. TGeoHMatrix & operator=(const TGeoMatrix* matrix); assignment. TGeoHMatrix & operator=(const TGeoMatrix& matrix); assignment. void CopyFrom(const TGeoMatrix* other); Fast copy method. void Clear(Option_t* option = """"); clear the data for this matrix. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void FastRotZ(const Double_t* sincos); Perform a rotation about Z having the sine/cosine of the rotation angle. TGeoMatrix& Inverse() const; Return a temporary inverse of this. Double_t Determinant() const; computes determinant of the rotation matrix. void Multiply(const TGeoMatrix* right); multiply to the right with an other transformation; if right is identity matrix, just return. void MultiplyLeft(const TGeoMatrix* left); multiply to the left with an other transformation; if right is identity matrix, just return. void RotateX(Double_t angle); Rotate about X axis with angle expressed in degrees. void RotateY(Double_t angle); Rotate about Y axis with angle expressed in degrees. void RotateZ(Double_t angle); Rotate about Z axis with angle expressed in degrees. void ReflectX(Bool_t leftside, Bool_t rotonly = kFALSE); Multiply by a reflection respect to YZ. void ReflectY(Bool_t leftside, Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHMatrix.html:16456,clear,clear,16456,root/html602/TGeoHMatrix.html,https://root.cern,https://root.cern/root/html602/TGeoHMatrix.html,6,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"tching bin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidAddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidAddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*CreateIter(Bool_t respectAxisRange) const; static THnSparse*CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024 * 16); static THnSparse*CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024 * 16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THnSparse.html:5513,Clear,Clear,5513,root/html602/THnSparse.html,https://root.cern,https://root.cern/root/html602/THnSparse.html,2,['Clear'],['Clear']
Usability,"tconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::isBinnedDistributionvirtual bool isBinnedDistribution(const RooArgSet &) constTests if the distribution is binned. Unless overridden by derived classes, this always returns false.Definition RooAbsReal.h:346; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr< RooAbsReal > createIntObj(const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) constInternal utility function for createIntegral() that creates the actual integral object.Definition RooAbsReal.cxx:590; RooAbsReal::sigmaRooAbsMoment * sigma(RooRealVar &obs, const RooArgSet &nset)Definition RooAbsReal.h:362; RooAbsReal::functorRooFunctor * functor(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a RooFunctor object bound to this RooAbsReal with given definition of observables and paramete...Definition RooAbsReal.cxx:3887; RooAbsReal::setCachedValuevoid setCachedValue(double value, bool notifyClients=true) finalOverwrite the value stored in this object's cache.Definition RooAbsReal.h:558; RooAbsReal::_plotBinsInt_t _plotBinsNumber of plot bins.Definition RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:51466,clear,clearEvalErrorLogstatic,51466,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,2,['clear'],"['clearEvalErrorLog', 'clearEvalErrorLogstatic']"
Usability,tcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; TGCheckButton*fMarkerOnOffset Marker visible/unvisible; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Int_tTGedFrame::fPrioritylocation in GedEditor; TGRadioButton*fShapejust draw unconnected points; TGRadioButton*fShape0set smooth graph curve; TGRadioButton*fShape1set simple poly-line between every graph point; TGLayoutHints*fShape1lhlayout-hints for fShape1; TGRadioButton*fShape2set graph draw mode to bar chart; TGRadioButton*fShape3set graph draw mode to fill area; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGTextEntry*fTitleContains the title of the graph; Int_tfTitlePrecfont precision level; UInt_tTGFrame::fWidthframe width; TGLineWidthComboBox*fWidthComboExclusion zone width ; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by A,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphEditor.html:19356,simpl,simple,19356,root/html528/TGraphEditor.html,https://root.cern,https://root.cern/root/html528/TGraphEditor.html,6,['simpl'],['simple']
Usability,tcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; TGCheckButton*fMarkerOnOffset Marker visible/unvisible; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Int_tTGedFrame::fPrioritylocation in GedEditor; TGRadioButton*fShapejust draw unconnected points; TGRadioButton*fShape0set smooth graph curve; TGRadioButton*fShape1set simple poly-line between every graph point; TGLayoutHints*fShape1lhlayout-hints for fShape1; TGRadioButton*fShape2set graph draw mode to bar chart; TGRadioButton*fShape3set graph draw mode to fill area; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGTextEntry*fTitleContains the title of the graph; Int_tfTitlePrecfont precision level; UInt_tTGFrame::fWidthframe width; TGLineWidthComboBox*fWidthComboExclusion zone width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by Ad,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphEditor.html:20269,simpl,simple,20269,root/html602/TGraphEditor.html,https://root.cern,https://root.cern/root/html602/TGraphEditor.html,4,['simpl'],['simple']
Usability,"td::string subname = path[pos];; 339 int indx = Browsable::RElement::ExtractItemIndex(subname);; 340 ; 341 auto iter = elem->GetChildsIter();; 342 if (!iter); 343 return nullptr;; 344 ; 345 if (!iter->Find(subname, indx)) {; 346 if (indx < 0); 347 return nullptr;; 348 iter = elem->GetChildsIter();; 349 if (!iter || !iter->Find(subname)); 350 return nullptr;; 351 }; 352 ; 353 elem = iter->GetElement();; 354 ; 355 if (!elem); 356 return nullptr;; 357 ; 358 auto subpath = path;; 359 subpath.resize(pos+1);; 360 fCache.emplace_back(subpath, elem);; 361 pos++; // switch to next element; 362 }; 363 ; 364 return elem;; 365}; 366 ; 367/////////////////////////////////////////////////////////////////////////; 368/// Clear internal objects cache; 369 ; 370void RBrowserData::ClearCache(); 371{; 372 fCache.clear();; 373}; 374 ; 375/////////////////////////////////////////////////////////////////////////; 376/// Remove object from cache; 377/// If nullptr specified - removes no-longer-valid elements; 378/// Returns true if any element was removed; 379 ; 380bool RBrowserData::RemoveFromCache(void *obj); 381{; 382 unsigned pos = 0;; 383 ; 384 bool isany = false;; 385 ; 386 while (pos < fCache.size()) {; 387 if (obj ? !fCache[pos].second->IsObject(obj) : fCache[pos].second->CheckValid()) {; 388 pos++;; 389 continue;; 390 }; 391 ; 392 isany = true;; 393 auto path = fCache[pos].first;; 394 fCache.erase(fCache.begin() + pos);; 395 if (RemoveFromCache(path)); 396 pos = 0; // start scan from the beginning; 397 }; 398 ; 399 return isany;; 400}; 401 ; 402/////////////////////////////////////////////////////////////////////////; 403/// Remove path (and all sub-paths) from cache; 404/// Returns true if any element was removed; 405 ; 406bool RBrowserData::RemoveFromCache(const Browsable::RElementPath_t &path); 407{; 408 if (path.size() == 0); 409 return false;; 410 ; 411 bool isany = false;; 412 unsigned pos = 0;; 413 while (pos < fCache.size()) {; 414 if (Browsable::RElement::ComparePaths(pat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBrowserData_8cxx_source.html:11445,clear,clear,11445,doc/master/RBrowserData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html,2,['clear'],['clear']
Usability,"td::vector<Matrix_t> &inp1, std::vector<Matrix_t> &inp2) = 0;; 117 ; 118 /*! Reset some training flags after a loop on all batches; 119 Some layer (e.g. batchnormalization) might need to implement the function in case some operations; 120 are needed after looping an all batches */; 121 virtual void ResetTraining() {}; 122 ; 123 /*! Updates the weights and biases, given the learning rate */; 124 void Update(const Scalar_t learningRate);; 125 ; 126 /*! Updates the weights, given the gradients and the learning rate, */; 127 void UpdateWeights(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 128 ; 129 /*! Updates the biases, given the gradients and the learning rate. */; 130 void UpdateBiases(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 131 ; 132 /*! Updates the weight gradients, given some other weight gradients and learning rate. */; 133 void UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 134 ; 135 /*! Updates the bias gradients, given some other weight gradients and learning rate. */; 136 void UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 137 ; 138 /*! Copies the weights provided as an input. */; 139 void CopyWeights(const std::vector<Matrix_t> &otherWeights);; 140 ; 141 /*! Copies the biases provided as an input. */; 142 void CopyBiases(const std::vector<Matrix_t> &otherBiases);; 143 ; 144 /*! Copy all trainable weight and biases from another equivalent layer but with different architecture; 145 The function can copy also extra parameters in addition to weights and biases if they are return; 146 by the function GetExtraLayerParameters */; 147 template <typename Arch>; 148 void CopyParameters(const VGeneralLayer<Arch> &layer);; 149 ; 150 /*! Prints the info about the layer. */; 151 virtual void Print() const = 0;; 152 ; 153 /*! Writes the information and the weights about the layer in an XML node. */; 154 virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GeneralLayer_8h_source.html:5705,learn,learningRate,5705,doc/master/GeneralLayer_8h_source.html,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html,2,['learn'],"['learning', 'learningRate']"
Usability,"te a ROOT 7 canvas (RCanvas) and draw ROOT 7 lines in it (RLine) ;  lineStyle.cxx;  lineWidth.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  vo004_SortAndSelect.C In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo004_SortAndSelect.py In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo005_Combinations.C In this tutorial we learn how combinations of RVecs can be build ;  vo005_Combinations.py In this tutorial we learn how combinations of RVecs can be build ;  vo006_IndexManipulation.C In this tutorial we demonstrate RVec helpers for index manipulation ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlmodifyfile.C Example to read, modify and store xml file, using TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run so",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:172829,learn,learn,172829,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['learn'],['learn']
Usability,"te a canvas object. ~TGCanvas(); Delete canvas. void MapSubwindows(); Map all canvas sub windows. void AddFrame(TGFrame* f, TGLayoutHints* l = 0); Adding a frame to a canvas is actually adding the frame to the; viewport container. The viewport container must be at least a; TGCompositeFrame for this method to succeed. void DrawBorder(); Draw canvas border. void Layout(); Create layout for canvas. Depending on the size of the container; we need to add the scrollbars. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle message generated by the canvas scrollbars. Int_t GetHsbPosition() const; Get position of horizontal scrollbar. Int_t GetVsbPosition() const; Get position of vertical scrollbar. void SetHsbPosition(Int_t newPos); Set position of horizontal scrollbar. void SetVsbPosition(Int_t newPos); Set position of vertical scrollbar. void SetScrolling(Int_t scrolling); Set scrolling policy. Use values defined by the enum: kCanvasNoScroll,; kCanvasScrollHorizontal, kCanvasScrollVertical, kCanvasScrollBoth. void ClearViewPort(); Clear view port and redraw content. void SavePrimitive(ostream& out, Option_t* option = """"); Save a canvas widget as a C++ statement(s) on output stream out. TGContainer& operator=(const TGCanvas& ). TGHScrollBar * GetHScrollbar() const. TGVScrollBar * GetVScrollbar() const. TGFrame * GetContainer() const; { return fContainer; }. void SetContainer(TGFrame* f). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fHeight); }. TGCanvas(const TGCanvas& ). TGViewPort * GetViewPort() const; { return fVport; }. Int_t GetScrolling() const; { return fScrolling; }. » Author: Fons Rademakers 11/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGCanvas.h 25499 2008-09-22 19:54:46Z bellenot $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGCanvas.html:19957,Clear,ClearViewPort,19957,root/html532/TGCanvas.html,https://root.cern,https://root.cern/root/html532/TGCanvas.html,2,['Clear'],"['Clear', 'ClearViewPort']"
Usability,"te and read STL vectors in a tree. . ; #include <vector>; ; #include ""TFile.h""; #include ""TTree.h""; #include ""TCanvas.h""; #include ""TFrame.h""; #include ""TH1F.h""; #include ""TBenchmark.h""; #include ""TRandom.h""; #include ""TSystem.h""; ; void write(); {; ; TFile *f = TFile::Open(""hvector.root"",""RECREATE"");; ; if (!f) { return; }; ; // Create one histograms; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",100,-4,4);; hpx->SetFillColor(48);; ; std::vector<float> vpx;; std::vector<float> vpy;; std::vector<float> vpz;; std::vector<float> vrand;; ; // Create a TTree; TTree *t = new TTree(""tvec"",""Tree with vectors"");; t->Branch(""vpx"",&vpx);; t->Branch(""vpy"",&vpy);; t->Branch(""vpz"",&vpz);; t->Branch(""vrand"",&vrand);; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""c1"",""Dynamic Filling Example"",200,10,700,500);; ; gRandom->SetSeed();; const Int_t kUPDATE = 1000;; for (Int_t i = 0; i < 25000; i++) {; Int_t npx = (Int_t)(gRandom->Rndm(1)*15);; ; vpx.clear();; vpy.clear();; vpz.clear();; vrand.clear();; ; for (Int_t j = 0; j < npx; ++j) {; ; Float_t px,py,pz;; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ; hpx->Fill(px);; ; vpx.emplace_back(px);; vpy.emplace_back(py);; vpz.emplace_back(pz);; vrand.emplace_back(random);; ; }; if (i && (i%kUPDATE) == 0) {; if (i == kUPDATE) hpx->Draw();; c1->Modified();; c1->Update();; if (gSystem->ProcessEvents()); break;; }; t->Fill();; }; f->Write();; ; delete f;; }; ; ; void read(); {; ; TFile *f = TFile::Open(""hvector.root"",""READ"");; ; if (!f) { return; }; ; TTree *t; f->GetObject(""tvec"",t);; ; std::vector<float> *vpx = nullptr;; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""c1"",""Dynamic Filling Example"",200,10,700,500);; ; const Int_t kUPDATE = 1000;; ; TBranch *bvpx = nullptr;; t->SetBranchAddress(""vpx"",&vpx,&bvpx);; ; ; // Create one histograms; TH1F *h = new TH1F(""h"",""This is the px distribution"",100,-4,4);; h->SetFillColor(48);; ; for (Int_t i = 0; i < 25000; i++) {; ; Long64_t ten",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hvector_8C.html:1199,clear,clear,1199,doc/master/hvector_8C.html,https://root.cern,https://root.cern/doc/master/hvector_8C.html,1,['clear'],['clear']
Usability,"te configuration. See the following figure: ; For each individual build (select one cell in the matrix) the following information is provided:. Status. Shows a summary of the build (changes, errors, warnings, git revision, test results, etc.); Changes. Shows the details about the changes since the last build.; Console Output/View as plain text. Shows the full log of the build including all the steps (checkout, configuration, build, running tests, etc.); Parsed Console Output. The same as previous but with warnings and errors selected.; Parameters. The parameters used for the job.; Environment variables. A table with all the environment variables defined for the job.; Test Result. An interface to the CTest tests results. All test, failing and not failing can be shown with their output. Starting and stopping jobs. New jobs can be launched at any time independently of their automatic scheduling (time based or triggered by changes in the GIT repository). This is done by selecting Build with Parameters from the selected project page. This only enabled when your are logged in. Typically the default parameters should be sufficient unless you want to launch a special job.; Jobs (single or multi-configuration) can be stopped by pressing the small cross in the job build history or in the job status page. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/how-use-root-jenkins.html:5889,guid,guidelines,5889,d/how-use-root-jenkins.html,https://root.cern,https://root.cern/d/how-use-root-jenkins.html,1,['guid'],['guidelines']
Usability,"te is taken from gStyle. ; Definition at line 105 of file TEveTriangleSet.cxx. ◆ GetNTrings(). Int_t TEveTriangleSet::GetNTrings ; (; ); const. inline . Definition at line 51 of file TEveTriangleSet.h. ◆ GetNVerts(). Int_t TEveTriangleSet::GetNVerts ; (; ); const. inline . Definition at line 50 of file TEveTriangleSet.h. ◆ IsA(). TClass * TEveTriangleSet::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TEveElementList.; Definition at line 77 of file TEveTriangleSet.h. ◆ operator=(). TEveTriangleSet & TEveTriangleSet::operator= ; (; const TEveTriangleSet & ; ). private . ◆ Paint(). void TEveTriangleSet::Paint ; (; Option_t * ; option = """"). overridevirtual . Paint this object. Only direct rendering is supported. ; Reimplemented from TObject.; Definition at line 142 of file TEveTriangleSet.cxx. ◆ ReadTrivialFile(). TEveTriangleSet * TEveTriangleSet::ReadTrivialFile ; (; const char * ; file). static . Read a simple ascii input file describing vertices and triangles. ; Definition at line 150 of file TEveTriangleSet.cxx. ◆ SetTransparency(). void TEveTriangleSet::SetTransparency ; (; Char_t ; tr). inline . Definition at line 73 of file TEveTriangleSet.h. ◆ SetTriangle(). void TEveTriangleSet::SetTriangle ; (; Int_t ; i, . Int_t ; v0, . Int_t ; v1, . Int_t ; v2 . ). inline . Definition at line 60 of file TEveTriangleSet.h. ◆ SetTriangleColor(). void TEveTriangleSet::SetTriangleColor ; (; Int_t ; i, . UChar_t ; r, . UChar_t ; g, . UChar_t ; b, . UChar_t ; a = 255 . ). inline . Definition at line 62 of file TEveTriangleSet.h. ◆ SetVertex(). void TEveTriangleSet::SetVertex ; (; Int_t ; i, . Float_t ; x, . Float_t ; y, . Float_t ; z . ). inline . Definition at line 58 of file TEveTriangleSet.h. ◆ Streamer(). void TEveTriangleSet::Streamer ; (; TBuffer & ; ). overridevirtual . Reimplemented from TEveElementList. ◆ StreamerNVirtual(). void TEveTriangleSet::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTriangleSet.html:39465,simpl,simple,39465,doc/master/classTEveTriangleSet.html,https://root.cern,https://root.cern/doc/master/classTEveTriangleSet.html,1,['simpl'],['simple']
Usability,"te range! The default numeric precision is 1e-7, i.e. the global default for numeric integration but you should experiment with this value to see if it is sufficient for example by studying the number of function calls that MINUIT needs to fit your function as function of the convolution precision. ; Definition at line 26 of file RooNumConvPdf.h. Public Member Functions;  RooNumConvPdf ();  ;  RooNumConvPdf (const char *name, const char *title, RooRealVar &convVar, RooAbsPdf &pdf, RooAbsPdf &resmodel);  ;  RooNumConvPdf (const RooNumConvPdf &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooNumConvPdf () override;  Destructor. ;  ; void clearConvolutionWindow ();  ; TObject * clone (const char *newname) const override;  ; RooNumIntConfig & convIntConfig ();  ; double evaluate () const override;  Calculate and return value of p.d.f. ;  ; TClass * IsA () const override;  ; RooAbsReal & model () const;  ; RooAbsReal & pdf () const;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the product operator construction. ;  ; const TH2 * profileData () const;  ; void setCallProfiling (bool flag, Int_t nbinX=40, Int_t nbinCall=40, Int_t nCallHigh=1000);  ; void setCallWarning (Int_t threshold=2000);  ; void setConvolutionWindow (RooAbsReal &centerParam, RooAbsReal &widthParam, double widthScaleFactor=1);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; RooRealVar & var () const;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalInteg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvPdf.html:3368,intuit,intuitively,3368,doc/master/classRooNumConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooNumConvPdf.html,1,['intuit'],['intuitively']
Usability,"te units of so-called object editors. Any object editor provides an object specific GUI. The main purpose of the ROOT graphics editor is the organization of the object editors’ appearance and the task sequence between them.; 25.9.1 Object Editors; Every object editor follows a simple naming convention: to have as a name the object class name concatenated with ‘Editor’ (e.g. for TGraph objects the object editor is TGraphEditor). Thanks to the signals/slots communication mechanism and to the method DistancetoPrimitive() that computes a ‘‘distance’’ to an object from the mouse position, it was possible to implement a signal method of the canvas that says which is the selected object and to which pad it belongs. Having this information the graphics editor loads the corresponding object editor and the user interface is ready for use. This way after a click on ‘axis’—the axis editor is active; a click on a ‘pad’ activates the pad editor, etc.; The algorithm in use is simple and is based on the object-oriented relationship and communication. When the user activates the editor, according to the selected object <obj> in the canvas it looks for a class name <obj>Editor. For that reason, the correct naming is very important. If a class with this name is found, the editor verifies that this class derives from the base editor class TGedFrame. If all checks are satisfied, the editor makes an instance of the object editor. Then, it scans all object base classes searching the corresponding object editors. When it finds one, it makes an instance of the base class editor too.; Once the object editor is in place, it sets the user interface elements according to the object’s status. After that, it is ready to interact with the object following the user actions.; The graphics editor gives an intuitive way to edit objects in a canvas with immediate feedback. Complexity of some object editors is reduced by hiding GUI elements and revealing them only on users’ requests.; An object in the c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1222193,simpl,simple,1222193,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"te(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If the Tree (Chain) has an associated EventList, the loop is on the nentries; of the EventList, starting at firstentry, otherwise the loop is on the; specified Tree entries. Long64_t Project(const char* hname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Make a projection of a tree using selections. Depending on the value of varexp (described in Draw) a 1-D, 2-D, etc.,; projection of the tree will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. TSQLResult* Query(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over entries and return a TSQLResult object containing entries following selection. Long64_t ReadFile(const char* filename, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:120980,simpl,simply,120980,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,6,['simpl'],['simply']
Usability,"te(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If the Tree (Chain) has an associated EventList, the loop is on the nentries; of the EventList, starting at firstentry, otherwise the loop is on the; specified Tree entries. Long64_t Project(const char* hname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Make a projection of a tree using selections. Depending on the value of varexp (described in Draw) a 1-D, 2-D, etc.,; projection of the tree will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. TSQLResult* Query(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over entries and return a TSQLResult object containing entries following selection. Long64_t ReadFile(const char* filename, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D""; -If the type is a string of characters. This will read; subsequent characters until a whitespace is found (whitespace; characters are considered to be blank, newline and tab). delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """",",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:114630,simpl,simply,114630,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,3,['simpl'],['simply']
Usability,"te(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidExpand(UInt_t nrows, UInt_t ncolumns); virtual voidExpandColumns(UInt_t ncolumns); virtual voidExpandRows(UInt_t nrows); virtual UInt_tGetCHdrWidth() const; static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual UInt_tGetRHdrHeight() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidInit(); voidTObject::MakeZombie(); TGWindow&TGWindow::operator=(const TGWindow& tgw); virtual voidResizeTable(UInt_t nrows, UInt_t ncolumns); Int_tTGWidget::SetFlags(Int_t flags); virtual voidSetInterface(TVirtualTableInterface* interface, UInt_t nrows = 50, UInt_t ncolumns = 20); virtual voidShrink(UInt_t nrows, UInt_t ncolumns); virtual voidShrinkColumns(UInt_t ncolumns); virtual voidShrinkRows(UInt_t nrows); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE); virtual voidUpdateHeaders(EHeaderType type); virtual voidUpdateRangeFrame(). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTable.html:20193,Clear,ClearFlags,20193,root/html532/TGTable.html,https://root.cern,https://root.cern/root/html532/TGTable.html,1,['Clear'],['ClearFlags']
Usability,"te<typename Architecture_t > . void TMVA::DNN::VGeneralLayer< Architecture_t >::SetInputWidth ; (; size_t ; inputWidth). inline . Definition at line 220 of file GeneralLayer.h. ◆ SetIsTraining(). template<typename Architecture_t > . void TMVA::DNN::VGeneralLayer< Architecture_t >::SetIsTraining ; (; bool ; isTraining). inline . Definition at line 224 of file GeneralLayer.h. ◆ SetWidth(). template<typename Architecture_t > . void TMVA::DNN::VGeneralLayer< Architecture_t >::SetWidth ; (; size_t ; width). inline . Definition at line 223 of file GeneralLayer.h. ◆ Update(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::Update ; (; const Scalar_t ; learningRate). Updates the weights and biases, given the learning rate. ; Definition at line 410 of file GeneralLayer.h. ◆ UpdateBiases(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiases ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the biases, given the gradients and the learning rate. ; Definition at line 428 of file GeneralLayer.h. ◆ UpdateBiasGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiasGradients ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the bias gradients, given some other weight gradients and learning rate. ; Definition at line 448 of file GeneralLayer.h. ◆ UpdateWeightGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeightGradients ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weight gradients, given some other weight gradients and learning rate. ; Definition at line 438 of file GeneralLayer.h. ◆ UpdateWeights(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeights ; (; const std::vector< Matrix_t > & ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:25589,learn,learningRate,25589,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,1,['learn'],['learningRate']
Usability,"teFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressMemoryPlot(TProofProgressDialog* d, Int_t w = 700, Int_t h = 300); Main constructor. ~TProofProgressMemoryPlot(); Destructor. TGListBox* BuildLogList(TGFrame* parent); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void Clear(Option_t* = 0); Clear the canvases. void DoPlot(); Draw the plot from the logs. TGraph * DoAveragePlot(Int_t& max_el, Int_t& min_el); Create the average plots. Int_t ParseLine(TString l, Long64_t& v, Long64_t& r, Long64_t& e); Extract from line 'l' the virtual memory 'v', the resident memory 'r' and the; number of events 'e'.; The line is assumed to be in the form; ""... Memory 130868 virtual 31540 ... event 5550""; The fields are only filled if >= 0 .; Return 0 on success, -1 if any of the values coudl not be filled (the output; fields are not touched in such a case). TGraph * DoWorkerPlot(TProofLogElem* ple); Make a memory consumption graph for a worker. TGraph * DoMasterPlot(TProofLogElem* ple); a master or submaster log; display without meaningful labels for now. void Select(Int_t id); actions of select all/clear all button. TGraph* DoAveragePlotOld(Int_t& max_el, Int_t& min_el). » Author: Anna Kreshuk 18/07/2008 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-03-14 16:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofProgressMemoryPlot.html:23819,clear,clear,23819,root/html534/TProofProgressMemoryPlot.html,https://root.cern,https://root.cern/root/html534/TProofProgressMemoryPlot.html,2,['clear'],['clear']
Usability,"teFrames(); voidInit(const TGWindow* parent); TGLEmbeddedViewer&operator=(const TGLEmbeddedViewer&). Data Members; public:. enum TGLViewer::ECameraType { kCameraPerspXOZ; kCameraPerspYOZ; kCameraPerspXOY; kCameraOrthoXOY; kCameraOrthoXOZ; kCameraOrthoZOY; kCameraOrthoXnOY; kCameraOrthoXnOZ; kCameraOrthoZnOY; };; enum TGLViewer::ESecSelType { kOnRequest; kOnKeyMod1; };; enum TGLViewer::EPushAction { kPushStd; kPushCamCenter; kPushAnnotate; };; enum TGLViewer::EDragAction { kDragNone; kDragCameraRotate; kDragCameraTruck; kDragCameraDolly; kDragOverlay; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TGLLockable::ELock { kUnlocked; kDrawLock; kSelectLock; kModifyLock; };. protected:. TGLAutoRotator*TGLViewer::fAutoRotator!; Bool_tTGLViewer::fAxesDepthTest! remove guides hidden-lines; Int_tTGLViewer::fAxesType! axes type; TGLCamera*TGLViewerBase::fCameraCamera for rendering.; TGLCameraOverlay*TGLViewer::fCameraOverlay! markup size of viewport in scene units; Bool_tTGLViewerBase::fChangedChange requiring redraw is pending.; TGLClip*TGLViewerBase::fClipViewer clipping-plane.; TGLClipSet*TGLViewer::fClipSet!; TContextMenu*TGLViewer::fContextMenu!; TGLCamera*TGLViewer::fCurrentCamera!; TGLOverlayElement*TGLViewer::fCurrentOvlElm! current overlay element; TGLSelectRecordTGLViewer::fCurrentSelRec! select record in use as selected; TGLColorSetTGLViewer::fDarkColorSet! color-set with dark background; Bool_tTGLViewer::fDebugMode! debug mode (forced rebuild + draw scene/frustum/interest boxes); TGLViewer::EDragActionTGLViewer::fDragAction; Bool_tTGLViewer::fDrawCameraCenter! reference marker on?; TGEventHandler*TGLViewer::fEventHandler! event handler; Float_tTGLViewer::fFader! fade the view (0 - no fade/default, 1 - full fade/no rendering done); TGLContextIdentity*TGLVi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLEmbeddedViewer.html:19584,guid,guides,19584,root/html528/TGLEmbeddedViewer.html,https://root.cern,https://root.cern/root/html528/TGLEmbeddedViewer.html,6,['guid'],['guides']
Usability,"teNLL(); 975 *; 976 * <tr><th><th> Options to control flow of fit procedure; 977 * <tr><td> `Minimizer(""<type>"", ""<algo>"")` <td> Choose minimization package and optionally the algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer interface,; 978 * but others can be specified (through RooMinimizer interface).; 979 * <table>; 980 * <tr><th> Type <th> Algorithm; 981 * <tr><td> Minuit <td> migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); 982 * <tr><td> Minuit2 <td> migrad, simplex, minimize, scan; 983 * <tr><td> GSLMultiMin <td> conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; 984 * <tr><td> GSLSimAn <td> -; 985 * </table>; 986 *; 987 * <tr><td> `InitialHesse(bool flag)` <td> Flag controls if HESSE before MIGRAD as well, off by default; 988 * <tr><td> `Optimize(bool flag)` <td> Activate constant term optimization of test statistic during minimization (on by default); 989 * <tr><td> `Hesse(bool flag)` <td> Flag controls if HESSE is run after MIGRAD, on by default; 990 * <tr><td> `Minos(bool flag)` <td> Flag controls if MINOS is run after HESSE, off by default; 991 * <tr><td> `Minos(const RooArgSet& set)` <td> Only run MINOS on given subset of arguments; 992 * <tr><td> `Save(bool flag)` <td> Flag controls if RooFitResult object is produced and returned, off by default; 993 * <tr><td> `Strategy(Int_t flag)` <td> Set Minuit strategy (0 to 2, default is 1); 994 * <tr><td> `MaxCalls(int n)` <td> Change maximum number of likelihood function calls from MINUIT (if `n <= 0`, the default of 500 * #%parameters is used); 995 * <tr><td> `EvalErrorWall(bool flag=true)` <td> When parameters are in disallowed regions (e.g. PDF is negative), return very high value to fitter; 996 * to force it out of that region. This can, however, mean that the fitter gets lost in this region. If; 997 * this happens, try switching it off.; 998 * <tr><td> `RecoverFromUndefinedRegions(double strength)` <td> When PDF is invalid (e.g. parameter in undefined r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:45439,simpl,simplex,45439,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,3,['simpl'],['simplex']
Usability,"tected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidExecute(TMethod* method, TObjArray* params, int* error = 0); voidTObject::MakeZombie(). Data Members; public:. enum EErrorCode { kNoError; kRecoverable; kDangerous; kFatal; kProcessing; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TInterpreter *& Instance(); returns gInterpreter global. void Execute(TMethod* method, TObjArray* params, int* error = 0). virtual ~TInterpreter(); { }. void AddIncludePath(const char* path). Int_t AutoLoad(const char* classname). void ClearFileBusy(). void ClearStack(). void EnableAutoLoading(). void EndOfLineAction(). Int_t GetExitCode() const. TEnv * GetMapfile() const; { return 0; }. Int_t GetMore() const. Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0). char * GetPrompt(). const char * GetSharedLibs(). const char * GetClassSharedLibs(const char* cls). const char * GetSharedLibDeps(const char* lib). const char * GetIncludePath(). const char * GetSTLIncludePath() const; { return """"; }. TObjArray * GetRootMapFiles() const. Int_t InitializeDictionaries(). Bool_t IsLoaded(const char* filename) const. Int_t Load(const char* filenam, Bool_t system = kFALSE). void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0). Int_t RescanLibraryMap(). Int_t ReloadAllSharedLibraryMaps(). Int_t UnloadAllSharedLibraryMaps(). Int_t UnloadLibraryMap(const char* library). Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TInterpreter.html:17685,Clear,ClearStack,17685,root/html532/TInterpreter.html,https://root.cern,https://root.cern/root/html532/TInterpreter.html,2,['Clear'],['ClearStack']
Usability,"ted from RooAbsLValue; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; value_type evaluate () const override;  Evaluate the category state and return. ;  ; void recomputeShape () override;  This category's shape does not depend on others, and does not need recomputing. ;  ;  Protected Member Functions inherited from RooAbsCategoryLValue; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ;  Protected Member Functions inherited from RooAbsCategory; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not check if type already exists. ;  ; void fillTreeBranch (TTree &t) override;  Fill tree branches associated with current object with current value. ;  ; bool isValid () const override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; RooCatType * retrieveLegacyState (value_type index) const;  Return the legacy RooCatType corresponding to index. If it doesn't exist, create one. ;  ; void setCachedValue (double value, bool notifyClients=tru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCategory.html:42220,clear,clearTypes,42220,doc/master/classRooCategory.html,https://root.cern,https://root.cern/doc/master/classRooCategory.html,1,['clear'],['clearTypes']
Usability,"ted work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Support Guidelines for submitting a bug. Introduction; The RootTalk mailing list and forum can be used to pass information of general interest to the ROOT user community or to submit problems that you cannot solve with the information provided in the Documentation. Several thousands users read the list and forum and my provide you with solutions to your problem.; Only if you are convinced that your problem is a real bug of the ROOT software then follow the instructions on how to report a bug with JIRA.; When you submit a bug, please follow these guidelines:. If you submit a problem, always indicate your ROOT version number (e.g. 6.02.00, 5.34.22) and the platform you are running on (e.g. Ubuntu 14 gcc49, SLC6 clang35).; The bug title subject line should clearly identify the problem.; If you use a non recent version of ROOT, try to test your problem with newer version. If this is too difficult, consult the release and development notes to check if your problem has not already been solved.; Try to quickly search the internet and look in the forum if your problem has been already solved.; Try to share the maximum amount of information. A bug report which only says ""My macro crashes when running on kubuntu but on windows works"" is much less likely to be solved quickly than a complete message with a gdb stacktrace and a reproducer (see next item).; Send a minimal program or macro reproducing the problem. Make sure that your script can be executed directly. If it uses a data file, send the smallest possible data file as a mail attachment, or indicate how to get this file.; If for some reason it is not possible to share a minimal reproducer, try to make sure that your explanations are sufficient to speed up the whole fixing procedure. Sit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/guidelines-submitting-bug.html:2632,clear,clearly,2632,d/guidelines-submitting-bug.html,https://root.cern,https://root.cern/d/guidelines-submitting-bug.html,1,['clear'],['clearly']
Usability,"tedClass(const TEveProjection* p) const; virtual voidPropagateMainColor(Color_t color, Color_t old_color); virtual voidPropagateMainTransparency(Char_t t, Char_t old_t); virtual voidPropagateRenderState(Bool_t rnr_self, Bool_t rnr_children); virtual voidPropagateVizParams(TEveElement* el = 0); virtual voidRemoveProjected(TEveProjected* p); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TEveProjectable&operator=(const TEveProjectable&). Data Members; protected:. list<TEveProjected*>fProjectedListreferences to projected instances. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TEveProjectable(); Destructor.; Force projected replicas to unreference *this, then destroy them. void AnnihilateProjecteds(); Optimized destroy of projected elements with condition; there is only one parent for projected element. Method is; called from TEveElement::Annihilate(). void ClearProjectedList(). void AddProjectedsToSet(set<TEveElement*>& set); Add the projected elements to the set, dyn-casting them to; TEveElement. void PropagateVizParams(TEveElement* el = 0); Set visualization parameters of projecteds.; Use element el as model. If el == 0 (default), this casted to; TEveElement is used. void PropagateRenderState(Bool_t rnr_self, Bool_t rnr_children); Set render state of projecteds. void PropagateMainColor(Color_t color, Color_t old_color); Set main color of projecteds if their color is the same as old_color. void PropagateMainTransparency(Char_t t, Char_t old_t); Set main transparency of projecteds if their transparecy is the; same as the old one. TEveProjectable& operator=(const TEveProjectable& ). TClass* ProjectedClass(const TEveProjection* p) const. Bool_t HasProjecteds() const; { return ! fProjectedList.empty(); }. ProjList_i BeginProjecteds(); { return fProjectedList.begin(); }. ProjList_i EndProjecteds(); { return fProjectedList.end(); }. void AddProjected",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveProjectable.html:2204,Clear,ClearProjectedList,2204,root/html532/TEveProjectable.html,https://root.cern,https://root.cern/root/html532/TEveProjectable.html,1,['Clear'],['ClearProjectedList']
Usability,"tegory * RooWorkspace::cat ; (; RooStringView ; name); const. Retrieve discrete variable (RooCategory) with given name. A null pointer is returned if not found. ; Definition at line 1241 of file RooWorkspace.cxx. ◆ catfunc(). RooAbsCategory * RooWorkspace::catfunc ; (; RooStringView ; name); const. Retrieve discrete function (RooAbsCategory) with given name. A null pointer is returned if not found. ; Definition at line 1250 of file RooWorkspace.cxx. ◆ cd(). bool RooWorkspace::cd ; (; const char * ; path = nullptr). Definition at line 2044 of file RooWorkspace.cxx. ◆ Class(). static TClass * RooWorkspace::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooWorkspace::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooWorkspace::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 282 of file RooWorkspace.h. ◆ clearStudies(). void RooWorkspace::clearStudies ; (; ). Remove all RooStudyManager modules. ; Definition at line 1996 of file RooWorkspace.cxx. ◆ Clone(). TObject * RooWorkspace::Clone ; (; const char * ; newname = """"); const. overridevirtual . TObject::Clone() needs to be overridden. ; Reimplemented from TObject.; Definition at line 233 of file RooWorkspace.cxx. ◆ commitTransaction(). bool RooWorkspace::commitTransaction ; (; ). Definition at line 1068 of file RooWorkspace.cxx. ◆ components(). const RooArgSet & RooWorkspace::components ; (; ); const. inline . Definition at line 115 of file RooWorkspace.h. ◆ data(). RooAbsData * RooWorkspace::data ; (; RooStringView ; name); const. Retrieve dataset (binned or unbinned) with given name. A null pointer is returned if not found. ; Definition at line 1309 of file RooWorkspace.cxx. ◆ DeclFileName(). static const char * RooWorkspace::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 282 of file RooWorkspace.h. ◆ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWorkspace.html:28112,clear,clearStudies,28112,doc/master/classRooWorkspace.html,https://root.cern,https://root.cern/doc/master/classRooWorkspace.html,1,['clear'],['clearStudies']
Usability,"tegy; TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizerAdaptive::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal data structure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Int_t CalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); The result depends on the fStrategy. Int_t AddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); To be used by GetNextPacket but also in reaction to kPROOF_STOPPROCESS; message (when the worker was asked to stop processing during a packet).; returns the #entries intended in the last packet - #processed entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet;; A meaningfull difference to TPacketizer is the fact that this; packetizer, for each worker, tries to predict whether the worker; will finish processing it's local files before the end of the query.; If yes, it allocates, to those workers, files from non-slave filenodes; or from slaves that are overloaded. The check is done every time a new; file needs to be assigned. Int_t GetActiveWorkers(); Return the number of workers still processing. Float_t GetCurrentRate(Bool_t& all); Get Estimation of the current rate; just summing the current rate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPacketizerAdaptive.html:12413,learn,learnent,12413,root/html528/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html528/TPacketizerAdaptive.html,1,['learn'],['learnent']
Usability,"tem; TGPopupMenu*fSessionMenusession menu entry; TList*fSessionslist of sessions; time_tfStarttime of connection; TGStatusBar*fStatusBarbottom status bar; TTimer*fTimertimer used to change icon picture; TGToolBar*fToolBarapplication tool bar; TGCanvas*fTreeViewmain right sessions/queries tree view; UserGroup_t*fUserGroupuser connected to session; TGVerticalFrame*fV1; TGVerticalFrame*fV2; TEnv*fViewerEnvviewer's configuration. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGMainFrame. ←; TSessionViewer. Function documentation; TSessionViewer(const char* title = ""ROOT Session Viewer"", UInt_t w = 550, UInt_t h = 320); Main Session viewer constructor. TSessionViewer(const char* title, Int_t x, Int_t y, UInt_t w, UInt_t h); Main Session viewer constructor. void ReadConfiguration(const char* filename = 0); Read configuration file and populate list of sessions; list of queries and list of packages.; Read and set also global options as feedback histos. void UpdateListOfProofs(); Update list of existing Proof sessions. void UpdateListOfSessions(); Update list of existing Proof sessions. void WriteConfiguration(const char* filename = 0); Save actual configuration in config file ""filename"". void Build(); Build main session viewer frame and subframes. ~TSessionViewer(); Destructor. void OnListTreeClicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks in list tree. void OnListTreeDoubleClicked(TGListTreeItem* entry, Int_t btn); Handle mouse double clicks in list tree (connect to server). void Terminate(); Terminate Session : save configuration, clean temporary files and close; Proof connections. void CloseWindow(); Close main Session Viewer window. void ChangeRightLogo(const char* name); Change the right logo (used for animation). void EnableTimer(); Enable animation timer. void DisableTimer(); Disable animation timer. Bool_t HandleTimer(TTimer* ); Handle animation timer. void LogMessa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSessionViewer.html:26943,feedback,feedback,26943,root/html602/TSessionViewer.html,https://root.cern,https://root.cern/root/html602/TSessionViewer.html,4,['feedback'],['feedback']
Usability,"template WriteBasicType<Bool_t>, new TConfiguration(info,i,compinfo,offset) ); break;; 2945 case TStreamerInfo::kChar: return TConfiguredAction( Looper::template WriteBasicType<Char_t>, new TConfiguration(info,i,compinfo,offset) ); break;; 2946 case TStreamerInfo::kShort: return TConfiguredAction( Looper::template WriteBasicType<Short_t>, new TConfiguration(info,i,compinfo,offset) ); break;; 2947 case TStreamerInfo::kInt: return TConfiguredAction( Looper::template WriteBasicType<Int_t>, new TConfiguration(info,i,compinfo,offset) ); break;; 2948 case TStreamerInfo::kLong: return TConfiguredAction( Looper::template WriteBasicType<Long_t>, new TConfiguration(info,i,compinfo,offset) ); break;; 2949 case TStreamerInfo::kLong64: return TConfiguredAction( Looper::template WriteBasicType<Long64_t>, new TConfiguration(info,i,compinfo,offset) ); break;; 2950 case TStreamerInfo::kFloat: return TConfiguredAction( Looper::template WriteBasicType<Float_t>, new TConfiguration(info,i,compinfo,offset) ); break;; 2951 case TStreamerInfo::kDouble: return TConfiguredAction( Looper::template WriteBasicType<Double_t>, new TConfiguration(info,i,compinfo,offset) ); break;; 2952 case TStreamerInfo::kUChar: return TConfiguredAction( Looper::template WriteBasicType<UChar_t>, new TConfiguration(info,i,compinfo,offset) ); break;; 2953 case TStreamerInfo::kUShort: return TConfiguredAction( Looper::template WriteBasicType<UShort_t>, new TConfiguration(info,i,compinfo,offset) ); break;; 2954 case TStreamerInfo::kUInt: return TConfiguredAction( Looper::template WriteBasicType<UInt_t>, new TConfiguration(info,i,compinfo,offset) ); break;; 2955 case TStreamerInfo::kULong: return TConfiguredAction( Looper::template WriteBasicType<ULong_t>, new TConfiguration(info,i,compinfo,offset) ); break;; 2956 case TStreamerInfo::kULong64: return TConfiguredAction( Looper::template WriteBasicType<ULong64_t>,new TConfiguration(info,i,compinfo,offset) ); break;; 2957 // the simple type missing are kBits and kCounter.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:129881,simpl,simple,129881,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['simpl'],['simple']
Usability,"tent(const char *filename, Int_t &len); 1558{; 1559 len = 0;; 1560 ; 1561 std::ifstream is(filename, std::ios::in | std::ios::binary);; 1562 if (!is); 1563 return nullptr;; 1564 ; 1565 is.seekg(0, is.end);; 1566 len = is.tellg();; 1567 is.seekg(0, is.beg);; 1568 ; 1569 char *buf = (char *)malloc(len);; 1570 is.read(buf, len);; 1571 if (!is) {; 1572 free(buf);; 1573 len = 0;; 1574 return nullptr;; 1575 }; 1576 ; 1577 return buf;; 1578}; 1579 ; 1580////////////////////////////////////////////////////////////////////////////////; 1581/// Reads file content, using std::string as container; 1582 ; 1583std::string THttpServer::ReadFileContent(const std::string &filename); 1584{; 1585 std::ifstream is(filename, std::ios::in | std::ios::binary);; 1586 std::string res;; 1587 if (is) {; 1588 is.seekg(0, std::ios::end);; 1589 res.resize(is.tellg());; 1590 is.seekg(0, std::ios::beg);; 1591 is.read((char *)res.data(), res.length());; 1592 if (!is); 1593 res.clear();; 1594 }; 1595 return res;; 1596}; Long_tlong Long_tDefinition RtypesCore.h:54; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TCivetweb.h; TClass.h; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; TError.h; TFastCgi.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char dept",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:51731,clear,clear,51731,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['clear'],['clear']
Usability,"tents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for cell I, J. 2; H(I,J,K) = sum T E(I,J,K) = sum T; l(I,J,K) = sum l L(I,J,K) = sum l; h(I,J,K) = H(I,J,K)/L(I,J,K) s(I,J,K) = sqrt(E(I,J,K)/L(I,J,K)- h(I,J,K)**2); e(I,J,K) = s(I,J,K)/sqrt(L(I,J,K)). In the special case where s(I,J,K) is zero (eg, case of 1 entry only in one cell); e(I,J,K) is computed from the average of the s(I,J,K) for all cells.; This simple/crude approximation was suggested in order to keep the cell; during a fit operation. Example of a profile3D histogram; {; TCanvas *c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; hprof3d = new TProfile3D(""hprof3d"",""Profile of pt versus px, py and pz"",40,-4,4,40,-4,4,40,0,20);; Double_t px, py, pz, pt;; TRandom3 r(0);; for ( Int_t i=0; i<25000; i++) {; r.Rannor(px,py);; pz = px*px + py*py;; pt = r.Landau(0,1);; hprof3d->Fill(px,py,pz,pt,1);; }; hprof3d->Draw();; }. NOTE: A TProfile3D is drawn as it was a simple TH3. Function Members (Methods); public:. TProfile3D(); TProfile3D(const TProfile3D& profile); TProfile3D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins, Option_t* option = """"); TProfile3D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup, Option_t* option = """"); virtual~TProfile3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(const TH1* h1, Double_t c1 = 1); virtual voidAdd(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual voidAdd(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; voidTArrayD::AddAt(Double_t c, Int_t i); virtual voidTH3D::AddBinContent(Int_t bin); virtual voidTH3D::AddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectory",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile3D.html:1900,simpl,simple,1900,root/html528/TProfile3D.html,https://root.cern,https://root.cern/root/html528/TProfile3D.html,4,['simpl'],['simple']
Usability,"tentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static RooArgList createParamSet (const std::string &, Int_t, double, double);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars);  Create the list of RooRealVar parameters which represent the height of the histogram bins. ;  ; static RooArgList createParamSet (RooWorkspace &w, const std::string &, const RooArgList &Vars, double, double);  Create the list of RooRealVar parameters which scale the height of histogram bins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classParamHistFunc.html:46917,clear,clearEvalErrorLog,46917,doc/master/classParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html,1,['clear'],['clearEvalErrorLog']
Usability,"ter range.Definition TTree.h:103; TTree::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TTree.cxx:9545; TTree::fIMTZipBytesstd::atomic< Long64_t > fIMTZipBytes! Zip bytes for the IMT flush baskets.Definition TTree.h:161; TTree::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideMake sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree.Definition TTree.cxx:7881; TTree::GetPlayerTVirtualTreePlayer * GetPlayer()Load the TTreePlayer (if not already done).Definition TTree.cxx:6305; TTree::MakeProxyvirtual Int_t MakeProxy(const char *classname, const char *macrofilename=nullptr, const char *cutfilename=nullptr, const char *option=nullptr, Int_t maxUnrolling=3)Generate a skeleton analysis class for this Tree using TBranchProxy.Definition TTree.cxx:6768; TTree::kSplitCollectionOfPointers@ kSplitCollectionOfPointersDefinition TTree.h:266; TTree::ReadStreamvirtual Long64_t ReadStream(std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ')Create or simply read branches from an input stream.Definition TTree.cxx:7615; TTree::SetDebugvirtual void SetDebug(Int_t level=1, Long64_t min=0, Long64_t max=9999999)Set the debug level and the debug range.Definition TTree.cxx:8928; TTree::fScanFieldInt_t fScanFieldNumber of runs before prompting in Scan.Definition TTree.h:92; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTree::GetFriendvirtual TTree * GetFriend(const char *) constReturn a pointer to the TTree friend whose name or alias is friendname.Definition TTree.cxx:5975; TTree::SetNotifyvirtual void SetNotify(TObject *obj)Sets the address of the object to be notified when the tree is loaded.Definition TTree.cxx:9231; TTree::GetMaximumvirtual Double_t GetMaximum(const char *columname)Return maximum of column with name columname.Definition TTree.cxx:6235; TTree::GetEntryNumberWithBestIndexvirtual Long64_t GetEntryNumberWithBestIndex(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:441649,simpl,simply,441649,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['simpl'],['simply']
Usability,"ter. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Protected Types |; Protected Member Functions |; Protected Attributes |; List of all members ; TGHtml Class ReferenceGUI » HTML visualizer. ; The ROOT HTML widget. ; A derivate of TGView. ; Definition at line 873 of file TGHtml.h. Public Member Functions;  TGHtml (const TGWindow *p, int w, int h, int id=-1);  HTML Widget constructor. ;  ;  ~TGHtml () override;  HTML widget destructor. ;  ; void AppendArglist (TGString *str, TGHtmlMarkupElement *pElem);  Append all the arguments of the given markup to the given TGString. ;  ; virtual void ButtonClicked (const char *name, const char *val);  Emit ButtonClicked() signal. ;  ; int CellSpacing (TGHtmlElement *pTable);  Return the appropriate cell spacing for the given table. ;  ; virtual void CheckToggled (const char *name, Bool_t on, const char *val);  Emit CheckToggled() signal. ;  ; void Clear (Option_t *="""") override;  Erase all HTML from this widget and clear the screen. ;  ; void DrawRegion (Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Draw region defined by [x,y] [w,h]. ;  ; char * DumpToken (TGHtmlElement *p);  For debugging purposes, print information about a token. ;  ; int ElementCoords (TGHtmlElement *p, int i, int pct, int *coords);  Return coordinates of item. ;  ; void EncodeText (TGString *str, const char *z);  Append to the given TString an encoded version of the given text. ;  ; TGHtmlElement * FindEndNest (TGHtmlElement *sp, int en, TGHtmlElement *lp);  Find End tag en, but ignore intervening begin/end tag pairs. ;  ; virtual int FormAction (TGHtmlForm *, int);  ; virtual int FormCreate (TGHtmlForm *, const char *, const char *);  ; const char * GetBaseUri () const;  ; virtual TGFont * GetFont (int iFont);  The rendering and layout routines should call this routine in order to get a font structure. ;  ; virtual char * GetFontName ();  ; const char * GetHref (int x, int y, const char **t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:1079,clear,clear,1079,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['clear'],['clear']
Usability,"ter::DrawTextNDCvirtual void DrawTextNDC(Double_t u, Double_t v, const char *text, ETextMode mode)=0; TVirtualPadPainter::GetLineWidthvirtual Width_t GetLineWidth() const =0; TVirtualPadPainter::SelectDrawablevirtual void SelectDrawable(Int_t device)=0; TVirtualPadPainter::DrawPolyMarkervirtual void DrawPolyMarker(Int_t n, const Double_t *x, const Double_t *y)=0; TVirtualPadPainter::DrawTextvirtual void DrawText(Double_t x, Double_t y, const char *text, ETextMode mode)=0; TVirtualPadPainter::GetFillStylevirtual Style_t GetFillStyle() const =0; TVirtualPadPainter::InvalidateCSvirtual void InvalidateCS()Empty definition.Definition TVirtualPadPainter.cxx:44; TVirtualPadPainter::kFilled@ kFilledDefinition TVirtualPadPainter.h:21; TVirtualPadPainter::kHollow@ kHollowDefinition TVirtualPadPainter.h:21; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; TVirtualPad::TContext::PadDeletedvoid PadDeleted(TVirtualPad *pad)Inform context that pad deleted or will be deleted soon Reference on that pad should be cleared.Definition TVirtualPad.cxx:73; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::YtoAbsPixelvirtual Int_t YtoAbsPixel(Double_t y) const =0; TVirtualPad::GetX2virtual Double_t GetX2() const =0; TVirtualPad::cdvirtual TVirtualPad * cd(Int_t subpadnumber=0)=0; TVirtualPad::XtoAbsPixelvirtual Int_t XtoAbsPixel(Double_t x) const =0; TVirtualPad::GetY1virtual Double_t GetY1() const =0; TVirtualPad::GetNumbervirtual Int_t GetNumber() const =0; TVirtualPad::Streamervoid Streamer(TBuffer &) overrideStream an object of class TVirtualPad.Definition TVirtualPad.cxx:124; TVirtualPad::VtoPixelvirtual Int_t VtoPixel(Double_t v) const =0; TVirtualPad::Classstatic TClass * Class(); TVirtualPad::VtoAbsPixelvirtual Int_t VtoAbsPixel(Double_t v) const =0; TVirtualPad::RangeAxisChangedvirtual void RangeAxisChanged()Definition TVirtualPad.h:203; TVirtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:334095,clear,cleared,334095,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['clear'],['cleared']
Usability,"ter::GetBestFormatstatic const char * GetBestFormat(Double_t v, Double_t e, const char *f)This function returns the best format to print the error value (e) knowing the parameter value (v) an...Definition THistPainter.cxx:10714; THistPainter::PaintContourvirtual void PaintContour(Option_t *option)Control function to draw a 2D histogram as a contour plot.Definition THistPainter.cxx:5932; THistPainter::fCutsTCutG * fCuts[kMaxCuts]Pointers to graphical cuts.Definition THistPainter.h:65; THistPainter::PaintTablevirtual void PaintTable(Option_t *option)Control function to draw 2D/3D histograms (tables).Definition THistPainter.cxx:9629; THistPainter::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute the actions corresponding to event.Definition THistPainter.cxx:3464; THistPainter::PaintInitHvirtual Int_t PaintInitH()Compute histogram parameters used by the drawing routines for a rotated pad.Definition THistPainter.cxx:7334; THistPainter::PaintFramevirtual void PaintFrame()Calculate range and clear pad (canvas).Definition THistPainter.cxx:6777; THistPainter::fCutsOptInt_t fCutsOpt[kMaxCuts]Sign of each cut.Definition THistPainter.h:64; THistPainter::GetYHighlightBinvirtual Int_t GetYHighlightBin() constDefinition THistPainter.h:88; THistPainter::PaintH3Isovirtual void PaintH3Iso()Control function to draw a 3D histogram with Iso Surfaces.Definition THistPainter.cxx:7892; THistPainter::fYbufstd::vector< Double_t > fYbufY buffer coordinates.Definition THistPainter.h:62; THistPainter::PaintH3BoxRastervirtual void PaintH3BoxRaster()Control function to draw a 3D histogram with boxes.Definition THistPainter.cxx:7690; THistPainter::PaintHistvirtual void PaintHist(Option_t *option)Control routine to draw 1D histogramsDefinition THistPainter.cxx:6837; THistPainter::SetHighlightvoid SetHighlight() overrideSet highlight (enable/disable) mode for fH.Definition THistPainter.cxx:3857; THistPainter::DefineColorLevelsvirtual void DefineColorLevels(Int_t ndivz)D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8h_source.html:20880,clear,clear,20880,doc/master/THistPainter_8h_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8h_source.html,1,['clear'],['clear']
Usability,"ter::GetBestFormatstatic const char * GetBestFormat(Double_t v, Double_t e, const char *f)This function returns the best format to print the error value (e) knowing the parameter value (v) an...Definition THistPainter.cxx:10714; THistPainter::PaintContourvirtual void PaintContour(Option_t *option)Control function to draw a 2D histogram as a contour plot.Definition THistPainter.cxx:5932; THistPainter::fCutsTCutG * fCuts[kMaxCuts]Pointers to graphical cuts.Definition THistPainter.h:65; THistPainter::PaintTablevirtual void PaintTable(Option_t *option)Control function to draw 2D/3D histograms (tables).Definition THistPainter.cxx:9629; THistPainter::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute the actions corresponding to event.Definition THistPainter.cxx:3464; THistPainter::PaintInitHvirtual Int_t PaintInitH()Compute histogram parameters used by the drawing routines for a rotated pad.Definition THistPainter.cxx:7334; THistPainter::PaintFramevirtual void PaintFrame()Calculate range and clear pad (canvas).Definition THistPainter.cxx:6777; THistPainter::fCutsOptInt_t fCutsOpt[kMaxCuts]Sign of each cut.Definition THistPainter.h:64; THistPainter::PaintH3Isovirtual void PaintH3Iso()Control function to draw a 3D histogram with Iso Surfaces.Definition THistPainter.cxx:7892; THistPainter::fYbufstd::vector< Double_t > fYbufY buffer coordinates.Definition THistPainter.h:62; THistPainter::PaintH3BoxRastervirtual void PaintH3BoxRaster()Control function to draw a 3D histogram with boxes.Definition THistPainter.cxx:7690; THistPainter::PaintHistvirtual void PaintHist(Option_t *option)Control routine to draw 1D histogramsDefinition THistPainter.cxx:6837; THistPainter::SetHighlightvoid SetHighlight() overrideSet highlight (enable/disable) mode for fH.Definition THistPainter.cxx:3857; THistPainter::DefineColorLevelsvirtual void DefineColorLevels(Int_t ndivz)Define the color levels used to paint legos, surfaces etc..Definition THistPainter.cxx:9603; THistP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:474226,clear,clear,474226,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['clear'],['clear']
Usability,"ter::PaintPhysicalNodevoid PaintPhysicalNode(TGeoPhysicalNode *node, Option_t *option="""")Paints a physical node associated with a path.Definition TGeoPainter.cxx:1609; TGeoPainter::fNVisNodesInt_t fNVisNodesDefinition TGeoPainter.h:48; TGeoPainter::fExplodedViewInt_t fExplodedViewDefinition TGeoPainter.h:51; TGeoPainter::GetVolumeInfoconst char * GetVolumeInfo(const TGeoVolume *volume, Int_t px, Int_t py) const overrideGet some info about the current selected volume.Definition TGeoPainter.cxx:1151; TGeoPainter::SetClippingShapevoid SetClippingShape(TGeoShape *shape) overrideDefinition TGeoPainter.h:160; TGeoPainter::DrawCurrentPointvoid DrawCurrentPoint(Int_t color) overrideDraw current point in the same view.Definition TGeoPainter.cxx:1004; TGeoPainter::DrawPathvoid DrawPath(const char *path, Option_t *option="""") overrideDraw all volumes for a given path.Definition TGeoPainter.cxx:1026; TGeoPainter::OpProgressvoid OpProgress(const char *opname, Long64_t current, Long64_t size, TStopwatch *watch=nullptr, Bool_t last=kFALSE, Bool_t refresh=kFALSE, const char *msg="""") overrideText progress bar.Definition TGeoPainter.cxx:1684; TGeoPainter::SetCheckedNodevoid SetCheckedNode(TGeoNode *node) overrideSelect a node to be checked for overlaps.Definition TGeoPainter.cxx:2016; TGeoPainter::DrawBatemanSolvoid DrawBatemanSol(TGeoBatemanSol *sol, Option_t *option="""") overrideDraw the time evolution of a radionuclide.Definition TGeoPainter.cxx:726; TGeoPainter::fCheckerTGeoChecker * fCheckerDefinition TGeoPainter.h:64; TGeoPainter::IsRaytracingBool_t IsRaytracing() const overrideDefinition TGeoPainter.h:137; TGeoPainter::fIsRaytracingBool_t fIsRaytracingDefinition TGeoPainter.h:55; TGeoPainter::ExecuteShapeEventvoid ExecuteShapeEvent(TGeoShape *shape, Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on a given shape.Definition TGeoPainter.cxx:1089; TGeoPainter::GetViewBoxDouble_t * GetViewBox() overrideDefinition TGeoPainter.h:134; TGeoPainter::WeightDouble_t Weight(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8h_source.html:25433,progress bar,progress bar,25433,doc/master/TGeoPainter_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8h_source.html,1,['progress bar'],['progress bar']
Usability,"ter::gxworkstd::vector< Double_t > gxworkDefinition TGraphPainter.h:69; TGraphPainter::gyworkstd::vector< Double_t > gyworkDefinition TGraphPainter.h:69; TGraphPainter::PaintScattervoid PaintScatter(TScatter *theScatter, Option_t *option) overridePaint a scatter plot.Definition TGraphPainter.cxx:4392; TGraphPainter::Smoothvoid Smooth(TGraph *theGraph, Int_t npoints, Double_t *x, Double_t *y, Int_t drawtype)Smooth a curve given by N points.Definition TGraphPainter.cxx:4938; TGraphPainter::gyworklstd::vector< Double_t > gyworklInternal buffers for coordinates. Used for graphs painting.Definition TGraphPainter.h:69; TGraphPainter::SetHighlightvoid SetHighlight(TGraph *theGraph) overrideSet highlight (enable/disable) mode for theGraph.Definition TGraphPainter.cxx:1120; TGraphPainter::GetHighlightPointvirtual Int_t GetHighlightPoint(TGraph *theGraph) constReturn the highlighted point for theGraph.Definition TGraphPainter.cxx:1110; TGraphPainter::PaintGraphSimplevoid PaintGraphSimple(TGraph *theGraph, Option_t *option)Paint a simple graph, without errors bars.Definition TGraphPainter.cxx:4584; TGraphPainter::PaintGraphQQvoid PaintGraphQQ(TGraph *theGraph, Option_t *option)Paint this graphQQ. No options for the time being.Definition TGraphPainter.cxx:4084; TGraphPainter::~TGraphPainter~TGraphPainter() overrideDestructor.Definition TGraphPainter.cxx:675; TGraphPainter::SetMaxPointsPerLinestatic void SetMaxPointsPerLine(Int_t maxp=50)Static function to set fgMaxPointsPerLine for graph painting.Definition TGraphPainter.cxx:5407; TGraphPainter::PaintGraphBentErrorsvoid PaintGraphBentErrors(TGraph *theGraph, Option_t *option)Paint this TGraphBentErrors with its current attributes.Definition TGraphPainter.cxx:3182; TGraphPainter::TGraphPainterTGraphPainter()Default constructor.Definition TGraphPainter.cxx:667; TGraphPainter::PaintHelpervoid PaintHelper(TGraph *theGraph, Option_t *option) overridePaint a any kind of TGraph.Definition TGraphPainter.cxx:1211; TGraphA TGraph is an o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8h_source.html:8019,simpl,simple,8019,doc/master/TGraphPainter_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8h_source.html,1,['simpl'],['simple']
Usability,"ter::gxworkstd::vector< Double_t > gxworkDefinition TGraphPainter.h:69; TGraphPainter::gyworkstd::vector< Double_t > gyworkDefinition TGraphPainter.h:69; TGraphPainter::PaintScattervoid PaintScatter(TScatter *theScatter, Option_t *option) overridePaint a scatter plot.Definition TGraphPainter.cxx:4392; TGraphPainter::Smoothvoid Smooth(TGraph *theGraph, Int_t npoints, Double_t *x, Double_t *y, Int_t drawtype)Smooth a curve given by N points.Definition TGraphPainter.cxx:4938; TGraphPainter::gyworklstd::vector< Double_t > gyworklInternal buffers for coordinates. Used for graphs painting.Definition TGraphPainter.h:69; TGraphPainter::SetHighlightvoid SetHighlight(TGraph *theGraph) overrideSet highlight (enable/disable) mode for theGraph.Definition TGraphPainter.cxx:1120; TGraphPainter::GetHighlightPointvirtual Int_t GetHighlightPoint(TGraph *theGraph) constReturn the highlighted point for theGraph.Definition TGraphPainter.cxx:1110; TGraphPainter::PaintGraphSimplevoid PaintGraphSimple(TGraph *theGraph, Option_t *option)Paint a simple graph, without errors bars.Definition TGraphPainter.cxx:4584; TGraphPainter::PaintGraphQQvoid PaintGraphQQ(TGraph *theGraph, Option_t *option)Paint this graphQQ. No options for the time being.Definition TGraphPainter.cxx:4084; TGraphPainter::~TGraphPainter~TGraphPainter() overrideDestructor.Definition TGraphPainter.cxx:675; TGraphPainter::SetMaxPointsPerLinestatic void SetMaxPointsPerLine(Int_t maxp=50)Static function to set fgMaxPointsPerLine for graph painting.Definition TGraphPainter.cxx:5407; TGraphPainter::PaintGraphBentErrorsvoid PaintGraphBentErrors(TGraph *theGraph, Option_t *option)Paint this TGraphBentErrors with its current attributes.Definition TGraphPainter.cxx:3182; TGraphPainter::TGraphPainterTGraphPainter()Default constructor.Definition TGraphPainter.cxx:667; TGraphPainter::PaintHelpervoid PaintHelper(TGraph *theGraph, Option_t *option) overridePaint a any kind of TGraph.Definition TGraphPainter.cxx:1211; TGraphPolarTo draw a p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:201339,simpl,simple,201339,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['simpl'],['simple']
Usability,"terface; TMVA::Interval Interval definition, continous and discrete; TMVA::KDEKernel Kernel density estimator for PDF smoothing; TMVA::LogInterval Interval definition, continous and discrete; TMVA::MCFitter Fitter using Monte Carlo sampling of parameters ; TMVA::MethodANNBase Base class for TMVA ANNs; TMVA::MethodBDT Analysis of Boosted Decision Trees; TMVA::MethodBase Virtual base class for all TMVA method; TMVA::MethodBayesClassifier Friedman's BayesClassifier method ; TMVA::MethodBoost ; TMVA::MethodCFMlpANN Interface for Clermond-Ferrand artificial neural network; TMVA::MethodCFMlpANN_Utils Implementation of Clermond-Ferrand artificial neural network; TMVA::MethodCategory ; TMVA::MethodCompositeBase ; TMVA::MethodCuts Multivariate optimisation of signal efficiency; TMVA::MethodDT Analysis of Decision Trees ; TMVA::MethodFDA Function Discriminant Analysis; TMVA::MethodFisher Analysis of Fisher discriminant (Fisher or Mahalanobis approach) ; TMVA::MethodHMatrix H-Matrix method, a simple comparison of chi-squared estimators for signal and background; TMVA::MethodKNN k Nearest Neighbour classifier; TMVA::MethodLD Linear discriminant analysis; TMVA::MethodLikelihood Likelihood analysis (""non-parametric approach"") ; TMVA::MethodMLP Multi-layer perceptron implemented specifically for TMVA; TMVA::MethodPDEFoam Multi-dimensional probability density estimator using TFoam (PDE-Foam); TMVA::MethodPDERS Multi-dimensional probability density estimator range search (PDERS) method; TMVA::MethodRuleFit Friedman's RuleFit method; TMVA::MethodSVM Support Vector Machine; TMVA::MethodTMlpANN Implementation of interface for TMultiLayerPerceptron; TMVA::MinuitFitter Fitter using a Genetic Algorithm; TMVA::MinuitWrapper Wrapper around TMinuit; TMVA::MisClassificationError Implementation of the MisClassificationError as separation criterion; TMVA::MsgLogger Ostringstream derivative to redirect and format logging output; TMVA::Node Node for the BinarySearch or Decision Trees; TMVA::Optimi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:106436,simpl,simple,106436,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,4,['simpl'],['simple']
Usability,"terpret the coefficients of RooAddPdf components; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrained() -- Apply all constrained contained in the p.d.f. in the likelihood; Contrain(const RooArgSet&pars) -- Apply constraints to listed parameters in likelihood using internal constrains in p.d.f; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinuit; interface, but others can be specified (through RooMinimizer interface). Type Algorithm; ------ ---------; Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:50979,simpl,simplex,50979,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,9,['simpl'],['simplex']
Usability,"terpreter as a development engine.; 497 ; 498void TPad::AddExec(const char *name, const char *command); 499{; 500 if (!fExecs) fExecs = new TList;; 501 TExec *ex = new TExec(name,command);; 502 fExecs->Add(ex);; 503}; 504 ; 505////////////////////////////////////////////////////////////////////////////////; 506/// Execute the list of Execs when a pad event occurs.; 507 ; 508void TPad::AutoExec(); 509{; 510 if (GetCrosshair()); 511 DrawCrosshair();; 512 ; 513 if (!fExecs); 514 return;; 515 TIter next(fExecs);; 516 while (auto exec = (TExec*)next()); 517 exec->Exec();; 518}; 519 ; 520////////////////////////////////////////////////////////////////////////////////; 521/// Browse pad.; 522 ; 523void TPad::Browse(TBrowser *b); 524{; 525 cd();; 526 if (fPrimitives) fPrimitives->Browse(b);; 527}; 528 ; 529////////////////////////////////////////////////////////////////////////////////; 530/// Build a legend from the graphical objects in the pad.; 531///; 532/// A simple method to build automatically a TLegend from the primitives in a TPad.; 533///; 534/// Only those deriving from TAttLine, TAttMarker and TAttFill are added, excluding; 535/// TPave and TFrame derived classes.; 536///; 537/// \return The built TLegend; 538///; 539/// \param[in] x1, y1, x2, y2 The TLegend coordinates; 540/// \param[in] title The legend title. By default it is "" ""; 541/// \param[in] option The TLegend option; 542///; 543/// The caller program owns the returned TLegend.; 544///; 545/// If the pad contains some TMultiGraph or THStack the individual; 546/// graphs or histograms in them are added to the TLegend.; 547///; 548/// ### Automatic placement of the legend; 549/// If `x1` is equal to `x2` and `y1` is equal to `y2` the legend will be automatically; 550/// placed to avoid overlapping with the existing primitives already displayed.; 551/// `x1` is considered as the width of the legend and `y1` the height. By default; 552/// the legend is automatically placed with width = `x1`= `x2` = 0.3 and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:16127,simpl,simple,16127,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['simpl'],['simple']
Usability,"terval&operator=(const RooStats::SimpleInterval& other); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetConfidenceLevel(Double_t); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); RooStats::SimpleIntervalSimpleInterval(const char* name = 0); RooStats::SimpleIntervalSimpleInterval(const RooStats::SimpleInterval&); RooStats::SimpleIntervalSimpleInterval(const RooStats::SimpleInterval& other, const char* name); RooStats::SimpleIntervalSimpleInterval(const char* name, const RooRealVar& var, Double_t lower, Double_t upper, Double_t cl); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Double_tUpperLimit(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__SimpleInterval.html:4867,Simpl,SimpleIntervalSimpleInterval,4867,root/html534/RooStats__SimpleInterval.html,https://root.cern,https://root.cern/root/html534/RooStats__SimpleInterval.html,6,['Simpl'],"['SimpleInterval', 'SimpleIntervalSimpleInterval']"
Usability,"tes the output for a given event. ; Look at the output neuron designed by index. ; Definition at line 1033 of file TMultiLayerPerceptron.cxx. ◆ SetData(). void TMultiLayerPerceptron::SetData ; (; TTree * ; data). Set the data source. ; Definition at line 590 of file TMultiLayerPerceptron.cxx. ◆ SetDelta(). void TMultiLayerPerceptron::SetDelta ; (; Double_t ; delta). Sets Delta - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 720 of file TMultiLayerPerceptron.cxx. ◆ SetEpsilon(). void TMultiLayerPerceptron::SetEpsilon ; (; Double_t ; eps). Sets Epsilon - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 710 of file TMultiLayerPerceptron.cxx. ◆ SetEta(). void TMultiLayerPerceptron::SetEta ; (; Double_t ; eta). Sets Eta - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 700 of file TMultiLayerPerceptron.cxx. ◆ SetEtaDecay(). void TMultiLayerPerceptron::SetEtaDecay ; (; Double_t ; ed). Sets EtaDecay - Eta *= EtaDecay at each epoch (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 730 of file TMultiLayerPerceptron.cxx. ◆ SetEventWeight(). void TMultiLayerPerceptron::SetEventWeight ; (; const char * ; branch). Set the event weight. ; Definition at line 606 of file TMultiLayerPerceptron.cxx. ◆ SetGammaDelta(). void TMultiLayerPerceptron::SetGammaDelta ; (; TMatrixD & ; gamma, . TMatrixD & ; delta, . Double_t * ; buffer . ). protected . Sets the gamma \((g_{(t+1)}-g_{(t)})\) and delta \((w_{(t+1)}-w_{(t)})\) vectors Gamma is computed here, so ComputeDEDw cannot have been called before, and delta is a direct translation of buffer into a TMatrixD. ; Definition at line 2431 of file TMultiLayerPerceptron.cxx. ◆ SetLearningMethod(). void TMul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:45225,learn,learning,45225,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['learn'],['learning']
Usability,"tes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:7209,clear,clearShapeDirty,7209,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,1,['clear'],['clearShapeDirty']
Usability,"texpr Version_t Class_Version ();  ; static Bool_t Connect (const char *sender_class, const char *signal, const char *receiver_class, void *receiver, const char *slot);  This method allows to make a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; Bool_t HandleTimer (TTimer *timer) override;  Send progress and feedback to client. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects and progress messages. ;  ;  Protected Member Functions inherited from TProofPlayerRemote; TProof * GetProof () const;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notified in case of exception. ;  ; void SetSelectorDataMembersFromOutputList ();  Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerSuperMaster.html:19971,feedback,feedback,19971,doc/master/classTProofPlayerSuperMaster.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerSuperMaster.html,1,['feedback'],['feedback']
Usability,"texpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; value_type evaluate () const override;  Calculate and return the value of the mapping function. ;  ; void recomputeShape () override;  No shape recomputation is necessary. This category does not depend on other categories. ;  ;  Protected Member Functions inherited from RooAbsCategory; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValueDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not check if type already exists. ;  ; void fillTreeBranch (TTree &t) override;  Fill tree branches associated with current object with current value. ;  ; bool isValid () const override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; RooCatType * retrieveLegacyState (value_ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooThresholdCategory.html:35182,clear,clearTypes,35182,doc/master/classRooThresholdCategory.html,https://root.cern,https://root.cern/doc/master/classRooThresholdCategory.html,1,['clear'],['clearTypes']
Usability,"text to the view widget. void AddLine(const char* string); Add a line of text to the view widget. void AddLineFast(const char* string); Add a line of text to the view widget.; Fast version. Use it if you are going to add; several lines, than call Update(). void Update(); update the whole window of text view. Long_t ReturnLongestLineWidth(); Return width of longest line. Bool_t Search(const char* string, Bool_t direction, Bool_t caseSensitive); Search for string in text. If direction is true search forward.; Returns true if string is found. void SetFont(FontStruct_t font); Changes text entry font. Long_t ToScrYCoord(Long_t yCoord); Convert line number to screen coordinate. Long_t ToScrXCoord(Long_t xCoord, Long_t line); Convert column number in specified line to screen coordinate. Long_t ToObjYCoord(Long_t yCoord); Convert y screen coordinate to line number. Long_t ToObjXCoord(Long_t xCoord, Long_t line); Convert x screen coordinate to column in specified line. void Clear(Option_t* = """"); Clear text view widget. Bool_t LoadFile(const char* fname, long startpos = 0, long length = -1); Load a file in the text view widget. Return false in case file does not; exist. Bool_t LoadBuffer(const char* txtbuf); Load text from a text buffer. Return false in case of failure. Bool_t Copy(); Copy selected text to clipboard. Bool_t SelectAll(); Select all text in the viewer. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw lines in exposed region. Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Bool_t HandleTimer(TTimer* t); Handle scroll timer. Bool_t HandleButton(Event_t* event); Handle mouse button event in text editor. Bool_t HandleDoubleClick(Event_t* event); handle double click. Bool_t HandleMotion(Event_t* event); Handle mouse motion event in the text editor widget. Bool_t HandleSelectionClear(Event_t* event); Handle selection clear event. Bool_t HandleSelectionRequest(Event_t* event); Handle request to send current clipboard contents to request",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTextView.html:25974,Clear,Clear,25974,root/html532/TGTextView.html,https://root.cern,https://root.cern/root/html532/TGTextView.html,8,['Clear'],['Clear']
Usability,"th () const;  ; virtual void Initialize ();  Initialize the weights and biases according to the given initialization method. ;  ; bool IsTraining () const;  ; void ReadMatrixXML (void *node, const char *name, Matrix_t &matrix);  ; virtual void ResetTraining ();  Reset some training flags after a loop on all batches Some layer (e.g. ;  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetDepth (size_t depth);  ; virtual void SetDropoutProbability (Scalar_t);  Set Dropout probability. ;  ; virtual void SetExtraLayerParameters (const std::vector< Matrix_t > &);  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t &matrix);  ; void WriteTensorToXML (void *node, const char *name, const std::vector< Matrix_t > &tensor);  helper functions for XML ;  . Private Attributes; bool fFlattening;  Whether the layer is doing flattening. ;  . Additional Inherited Members;  Protected Attributes inherited from TMVA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReshapeLayer.html:6051,learn,learningRate,6051,doc/master/classTMVA_1_1DNN_1_1TReshapeLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReshapeLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"th THttpServer::Restrict() method. Up to now general read-only flag was applied - either everything read-only or everything is fully accessible. Now one could restrict access to different parts of objects hierarchy or even fully ‘hide’ them from the client. Restriction based on user account name, which is applied when htdigest authentication is configured. One also able to allow execution of selected methods.; Implement multi.bin and multi.json requests. One could request many items with single HTTP request. Let optimize communication between server and client.; With SNIFF tag in ClassDef() comments one could expose different properties, which than exposed by the TRootSniffer to the client with h.json requests. Such possibility ease implementation of client-side code for custom classes.; Allow to bind http port with loopback address. This restrict access to http server only from localhost. One could either specify ‘loopback’ option in constructor: new THttpServer(“http:8080?loopback”) or in clear text specify IP address to which http socket should be bind: new THttpServer(“http:127.0.0.1:8080”) If host has several network interfaces, one could select one for binding: new THttpServer(“http:192.168.1.17:8080”); TNetXNGFileStager; Fixed ROOT-7703. This restores the behavior of Locate() to that found with TXNetFileStager: Rather than return only the xrootd server’s reply, the endpoint hostname is looked up and Locate() returns the full url, including the path.; TWebFile; Fixed ROOT-7809. Returns an error for a redirect which does not specify the new URI, rather than going into a loop.; Fixed ROOT-7817. Avoid a crash under some circumstances when trying to open an invalid path.; GUI Libraries; Montecarlo Libraries; Multi-processing; With this version we introduce a new module, core/multiproc, for multi-processing on multi-core machines. This module is based on fork technology and offers an interface inspired from Python multiprocessor module. The new interface, implemente",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:19705,clear,clear,19705,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['clear'],['clear']
Usability,"th an elliptical section. ; It has three parameters: the ellipse semi-axis in X, the ellipse semi-axis in Y and the half length in Z. The equation of the conical curve is: X**2/fRx**2 + Y**2/fRy**2 = 1; ELTU is not divisible. name: name of the shape; title: shape's title; material: (see TMaterial); rx: the ellipse semi-axis in X; ry: the ellipse semi-axis in Y; dz: half-length in z . Definition at line 31 of file TELTU.h. Public Member Functions;  TELTU ();  ELTU shape default constructor. ;  ;  TELTU (const char *name, const char *title, const char *material, Float_t rx, Float_t ry, Float_t dz);  ;  ~TELTU () override;  ELTU shape default destructor. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TTUBE;  TTUBE ();  TUBE shape default constructor. ;  ;  TTUBE (const char *name, const char *title, const char *material, Float_t rmax, Float_t dz);  TUBE shape ""simplified"" constructor. ;  ;  TTUBE (const char *name, const char *title, const char *material, Float_t rmin, Float_t rmax, Float_t dz, Float_t aspect=1);  TUBE shape normal constructor. ;  ;  ~TTUBE () override;  TUBE shape default destructor. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a TUBE. ;  ; virtual Float_t GetAspectRatio () const;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections) const override;  Get buffer 3d. ;  ; virtual Float_t GetDz () const;  ; virtual Int_t GetNdiv () const;  ; virtual Int_t GetNumberOfDivisions () const;  ; virtual Float_t GetRmax () const;  ; virtual Float_t GetRmin () const;  ; TClass * IsA () const override;  ; virtual void SetAspectRatio (Float_t factor=1);  ; virtual void SetNumberOfDivisions (Int_t ndiv);  Set number of divisions used to draw this tube. ;  ; void Sizeof3D () const override;  Return total X3D needed by TNode::ls (when called wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTELTU.html:1343,simpl,simplified,1343,doc/master/classTELTU.html,https://root.cern,https://root.cern/doc/master/classTELTU.html,1,['simpl'],['simplified']
Usability,"th numbering starting at 1) and; character number M (with numbering starting at 0). M.X Like above, but token is markup and X is an attribute. begin The start of all text. end The end of all text. N.last Last character of token number N. N.end One past last character of token number N. sel.first First character of the selection. sel.last Last character of the selection. sel.end On past last character of the selection. insert The character holding the insertion cursor. @X,Y The character a location X,Y of the clipping window. &DOM The DOM Address of a token.; Zero is returned if we are successful and non-zero if there is any kind of error.; If the given token doesn't exist (for example if there are only 10 tokens and 11.5 is requested) then *ppToken is left pointing to NULL. But the function still returns 0 for success. ; Definition at line 342 of file TGHtmlIndex.cxx. ◆ DeleteControls(). void TGHtml::DeleteControls ; (; ). protected . Delete all input controls. ; This happens when the TGHtml widget is cleared. ; Definition at line 103 of file TGHtmlForm.cxx. ◆ DrawImage(). void TGHtml::DrawImage ; (; TGHtmlImageMarkup * ; image, . Drawable_t ; wid, . int ; left, . int ; top, . int ; right, . int ; bottom . ). protected . Draw all or part of an image. ; Definition at line 538 of file TGHtmlDraw.cxx. ◆ DrawRect(). void TGHtml::DrawRect ; (; Drawable_t ; drawable, . TGHtmlElement * ; src, . int ; x, . int ; y, . int ; w, . int ; h, . int ; depth, . int ; relief . ). protected . Draw a rectangle. ; The rectangle will have a 3-D appearance if flat is 0 and a flat appearance if flat is 1.; depth - width of the relief or the flat line ; Definition at line 264 of file TGHtmlDraw.cxx. ◆ DrawRegion(). void TGHtml::DrawRegion ; (; Int_t ; x, . Int_t ; y, . UInt_t ; w, . UInt_t ; h . ). overridevirtual . Draw region defined by [x,y] [w,h]. ; Reimplemented from TGView.; Definition at line 805 of file TGHtml.cxx. ◆ DrawSelectionBackground(). void TGHtml::DrawSelectionBackground ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:59676,clear,cleared,59676,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['clear'],['cleared']
Usability,"th three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; fHProg2->SetBarColor(""lightblue"");; fHProg2->ShowPosition(kTRUE,kFALSE,""%.0f events"");; fHProg3 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg3->SetFillType(TGProgressBar::kBlockFill);. vframe->AddFrame(fHProg1,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->AddFrame(fHProg2,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->AddFrame(fHProg3,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->Resize(200, 200);; 25.8.11 Static Widgets; The classes TGLabel and TGIcon show some information - text or graphics. The line below creates a label object. The syntax is very simple: you specify the parent widget and a string object holding the desired text.; TGLabel *label = new TGLabel(parentWidget, ""Label's string"");; Next sample creates an icon object. First we create an object of type TGPicture. The TGPicture objects are never created directly by the application code. We call TGClient telling it the pixmap’s file name to create a TGPicture object and, in turn, it will return a pointer to the created object. If the pixmap file cannot be found the returned pointer will be NULL. As usual, the first parameter of a TGIcon constructor is the parent frame. The second one is the TGPicture object holding the pixmap we want to show. Last two parameters define the width and height of pixmap in pixels. In the end we add the created icon object to its parent.; // icon widget; const TGPicture *ipic=(TGPicture *)gClient->GetPicture(""leaf.xpm"");; TGIcon *icon = new TGIcon(parent,ipic,40,40);; parent->AddFrame(icon,new TGLayoutHints(kLHintsLeft|kLHintsBottom,; 1, 15, 1, 1));; The TGPicture objects ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1209707,simpl,simple,1209707,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"th, Bool_t onClient = kFALSE, TList* wrks = 0); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearCache(const char* file = 0); voidTProof::ClearData(UInt_t what = kUnregistered, const char* dsname = 0); virtual voidClearDataSetCache(const char* dataset = 0); voidTProof::ClearFeedback(); voidTProof::ClearInput(); voidTProof::ClearInputData(TObject* obj = 0); voidTProof::ClearInputData(const char* name); Int_tTProof::ClearPackage(const char* package); Int_tTProof::ClearPackages(); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTProof::Close(Option_t* option = """"); voidTProof::CloseProgressDialog()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTNamed::Copy(TObject& named) const; TDrawFeedback*TProof::CreateDrawFeedback(); voidTProo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofLite.html:2164,Clear,ClearFeedback,2164,root/html532/TProofLite.html,https://root.cern,https://root.cern/root/html532/TProofLite.html,1,['Clear'],['ClearFeedback']
Usability,"th1->SetTextAlign(11); th1->SetTextSize(0.12);; th1->Draw();; ; auto *th2 = new TText(0.33,0.493,""Center adjusted"");; th2->SetTextAlign(21); th2->SetTextSize(0.12);; th2->Draw();; ; auto *th3 = new TText(0.33,0.823,""Right adjusted"");; th3->SetTextAlign(31); th3->SetTextSize(0.12);; th3->Draw();; ; // Vertical alignment.; auto *tv1 = new TText(0.66,0.165,""Bottom adjusted"");; tv1->SetTextAlign(11); tv1->SetTextSize(0.12);; tv1->Draw();; ; auto *tv2 = new TText(0.66,0.493,""Center adjusted"");; tv2->SetTextAlign(12); tv2->SetTextSize(0.12);; tv2->Draw();; ; auto *tv3 = new TText(0.66,0.823,""Top adjusted"");; tv3->SetTextAlign(13); tv3->SetTextSize(0.12);; tv3->Draw();; }; kBlue@ kBlueDefinition Rtypes.h:66; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TTextBase class for several text objects.Definition TText.h:22; th3auto * th3Definition textalign.C:22; lvTLine lvDefinition textalign.C:5; tv3auto * tv3Definition textalign.C:35; th2auto * th2Definition textalign.C:18; tv1auto * tv1Definition textalign.C:27; tv2auto * tv2Definition textalign.C:31; th1auto * th1Definition textalign.C:14; . Mnemonic constants are available:; kHAlignLeft = 10, kHAlignCenter = 20, kHAlignRight = 30,; kVAlignBottom = 1, kVAlignCenter = 2, kVAlignTop = 3; kVAlignTop@ kVAlignTopDefinition TAttText.h:54; kVAlignCenter@ kVAlignCenterDefinition TAttText.h:54; kHAlignLeft@ kHAlignLeftDefinition TAttText.h:53; kVAlignBottom@ kVAlignBottomDefinition TAttText.h:54; kHAlignCenter@ kHAlignCenterDefinition TAttText.h:53; kHAlignRight@ kHAlignRightDefinition TAttText",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAttText.html:2770,simpl,simple,2770,doc/master/classTAttText.html,https://root.cern,https://root.cern/doc/master/classTAttText.html,1,['simpl'],['simple']
Usability,"the Tree query mechanism and oversee the overall architecture of ROOT.  Philippe coordinates the support for ROOT for all FNAL experiments.; ; . Sergey Linev ; ; Sergey Linev was graduated from the Nuclear Physics Department of Belorussian State University, where he also received his Ph.D. in Physics and Mathematics in 1999. Since 2002 Sergey working in GSI - heavy-ion research center in Darmstadt, Germany, developing software for data acquisition and online analysis for different experiments. From 2004 starts contributing to different ROOT components like I/O with XML, SQL, JSON, THttpServer, JavaScript ROOT. Currently is responsible for the development of new web-based GUIs in ROOT like RCanvas, REve, RFitPanel and many others.; ; . Stephan Hageboeck ; ; Stephan is a particle physicist, and obtained his Ph.D. at the university of Bonn in Germany. He worked in ATLAS to improve the sensitivity in the search for Higgs --> bb decays. His main focus was on analysis frameworks, machine learning, systematic uncertainties and statistical models.; He joined the ROOT team in 2018 to support and improve RooFit. He further looks into math and statistics, as well as into questions regarding performance and programming model.; ; . Vassil Vassilev ; ; Vassil graduated from the University of Plovdiv ""Paisii Hilendarski"", Bulgaria. He received a MSc in Software Technologies and a PhD in Computer Science with specialization in programming languages and visual programming. He joined the ROOT team in 2010, authoring Cling - the interactive, LLVM-based C++ interpreter. He was one of the core engineers involved in ROOT6.; Vassil is responsible for the implementation and adoption of clang's C++ modules (PCMs) in ROOT. He also helps with interpreter and reflection related activities in the ROOT project. He works on the CMS interests in the ROOT collaboration including development, trouble shooting, and any other activities as may be required.   ; From January, 2017, Vassil is employed by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/team.html:10135,learn,learning,10135,d/team.html,https://root.cern,https://root.cern/d/team.html,1,['learn'],['learning']
Usability,"the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLearnPrefill() const; {return fPrefillType;}. TTree * GetTree() const; {return fTree;}. Bool_t IsAutoCreated() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:26039,learn,learning,26039,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['learn'],['learning']
Usability,"the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLearnPrefill() const; {return fPrefillType;}. TTree * GetTree() const; {return fTree;}. Bool_t IsAutoCreated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:26663,learn,learning,26663,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,4,['learn'],['learning']
Usability,"the current state element in the contained seed vector of TRandom3. The return value will now change after every call of TRandom3::Rndm (when generating a random number). Before the function was returning the first element of the state, which was changing only after 624 calls to Rndm().; Fix a bug in ROOT::Fit::BinData copy constructor; Fix a bug in applying a correction factor used for the computation of the fit confidence level in ROOT::Fit::FitResult.; TMatrix: optimize implementation of TPrincipal::AddRow that is heavily used by CMS. Minuit2. Add a new improved message logging system. Debug message now can be enabled in Minuit2 when using maximum print level.; When using external provided gradient, compute in MnSeed still numerical gradients to obtain correct step sizes and initial estimate of covariance matrix. This allows to start with a good first state estimation, reducing significantly the number of subsequent iterations. TMVA. Introducing TMVA PyTorch Interface, a method to use PyTorch internally with TMVA for deep learning. This can be used as an alternative to PyKeras Interface for complex models providing more flexibility and power.; Add support in the TMVA Keras interface for Tensorflow.Keras (the version embedded in Tensorflow) and for standalone Keras versions up to it latest 2.3. For using Tensorflow.Keras one needs to use the booking option tf.keras=True.; Update the TMVA Keras tutorials to use now tensorflow.keras.; Deprecate the MethodDNN in favour of MethodDL supporting both CNN and RNN; Add possibility to customize all relevant minimizer parameters used for training in MethodDL; Add support in MethodDL for the Cudnn version 8 when using the Cuda implementation for CNN and RNN Minuit2; Implement the missing support for MethodCategory for multiclass classifiers.; Add possibility to retrieve a ROC curve made with the training dataset instead of the default test dataset. RooFit Libraries. Extension / updates of the doxygen reference guide.; Allow f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:15404,learn,learning,15404,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['learn'],['learning']
Usability,"the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void recalculateCache(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. void resetCache(). void setArgStatus(const RooArgSet& set, Bool_t active); Disabling of branches is (intentionally) not implemented in vector; data stores (as the doesn't result in a net saving of time). void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void dump(). void Streamer(TBuffer& b); Stream an object of class RooVectorDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooVectorDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooVectorDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. Double_t sumEntries() const; { return _sumWeight ; }. const RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooVectorDataStore.html:15647,clear,cleared,15647,root/html532/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html532/RooVectorDataStore.html,2,['clear'],['cleared']
Usability,"the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeDataStore.html:16708,clear,cleared,16708,root/html526/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html526/RooTreeDataStore.html,3,['clear'],['cleared']
Usability,"the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. vector<double>fCovarcached covariance matrix (NxN); intfDebug; doublefEDMVal; doublefErrorDef; boolfGradient; doublefMinTolerance; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; vector<ROOT::Minuit2::MinosError>fMinosErrors; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::Minuit2::MnUserParameterStatefState; intfStrategy. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitterMinuit(). TFitterMinuit(Int_t maxpar). virtual ~TFitterMinuit(). Double_t Chisquare(Int_t npar, Double_t* params) const; inherited interface. void Clear(Option_t* option = """"). Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). void FixParameter(Int_t ipar). Double_t * GetCovarianceMatrix() const. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1. Int_t GetNumberTotalParameters() const. Int_t GetNumberFreeParameters() const. Double_t GetParError(Int_t ipar) const. Double_t GetParameter(Int_t ipar) const. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const. const char * GetParName(Int_t ipar) const. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const. Double_t GetSumLog(Int_t i). Bool_t IsFixed(Int_t ipar) const; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1. void PrintResults(Int_t level, Double_t amin) const. void Releas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFitterMinuit.html:11720,Clear,Clear,11720,root/html532/TFitterMinuit.html,https://root.cern,https://root.cern/root/html532/TFitterMinuit.html,2,['Clear'],['Clear']
Usability,"the default parameters via statements like:; gStyle->SetStatX(0.7);; gStyle->SetStatW(0.2);; gStyle->SetLabelOffset(1.2);; gStyle->SetLabelFont(72);; Note that when an object is created, its attributes are taken from the current style. For example, you may have created a histogram in a previous session and saved it in a file. Meanwhile, if you have changed the style, the histogram will be drawn with the old attributes. You can force the current style attributes to be set when you read an object from a file by calling ForceStyle before reading the objects from the file.; gROOT->ForceStyle();; When you call gROOT->ForceStyle() and read an object from a ROOT file, the object’s method UseCurrentStyle is called. The attributes saved with the object are replaced by the current style attributes. You call also call myObject->UseCurrentStyle() directly. For example if you have a canvas or pad with your histogram or any other object, you can force these objects to get the attributes of the current style by:; canvas->UseCurrentStyle();; The description of the style functions should be clear from the name of the TStyle setters or getters. Some functions have an extended description, in particular:. TStyle::SetLabelFont; TStyle::SetLineStyleString: set the format of dashed lines.; TStyle::SetOptStat; TStyle::SetPalette to change the colors palette; TStyle::SetTitleOffset; TStyle::SetOptDate(Int_t optdate) to support several date formats. If optdate is non-null, the current date/time will be printed in the canvas. The position of the date string can be controlled by: optdate = 10*format+mode; mode = 1 the date is printed in the bottom/left corner; mode = 2 date is printed in the bottom/right corner; mode = 3 date is printed in the top/right corner; format = 0 (default) date format is like: “Wed Sep 25 17:10:35 2002”; format = 1 date format is: “2002-09-25”; format = 2 date format is: “2002-09-25 17:10:35”. 9.13 3D Viewers; ROOT provides several viewers capable of displaying 3D co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:384462,clear,clear,384462,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['clear'],['clear']
Usability,"the first coordinate icoord ;  ; void AddRange (double xmin, double xmax, double ymin, double ymax);  add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate ;  ; void AddRange (double xmin, double xmax, double ymin, double ymax, double zmin, double zmax);  add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and [zmin,zmax] for the third coordinate ;  ; void AddRange (unsigned int icoord, double xmin, double xmax);  add a range [xmin,xmax] for the new coordinate icoord Adding a range does not delete existing one, but takes the OR with existing ranges. ;  ; void Clear (unsigned int icoord=0);  clear all ranges in one coordinate (is now -inf, +inf) ;  ; void GetRange (double &xmin, double &xmax, double &ymin, double &ymax, double &zmin, double &zmax, unsigned int irange=0) const;  get range for the x and y and z coordinates ;  ; void GetRange (double &xmin, double &xmax, double &ymin, double &ymax, unsigned int irange=0) const;  get range for the x and y coordinates ;  ; void GetRange (double &xmin, double &xmax, unsigned int irange=0) const;  get first range for the x - coordinate ;  ; void GetRange (double *xmin, double *xmax, unsigned int irange=0) const;  get range for coordinates and fill the vector ;  ; void GetRange (unsigned int icoord, double &xmin, double &xmax) const;  get the first range for given coordinate. ;  ; void GetRange (unsigned int irange, unsigned int icoord, double &xmin, double &xmax) const;  get the i-th range for given coordinate. ;  ; bool IsInside (const double *x) const;  check if a multi-dimpoint is inside the range ;  ; bool IsInside (double x, unsigned int icoord=0) const;  check if a point is inside the range for the given coordinate ;  ; bool IsSet () const;  return true if a range has been set in any of the coordinates i.e. ;  ; unsigned int NDim () const;  get range dimension ;  ; std::pair< double, double > operator() (unsigned int icoord=0, unsigned int irange=0) const;  return t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1DataRange.html:2102,clear,clear,2102,doc/master/classROOT_1_1Fit_1_1DataRange.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1DataRange.html,1,['clear'],['clear']
Usability,"the first time. Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate work and then produce all results at the same time, upon first access to any of them.; The following table shows how analyses based on TTreeReader and TTree::Draw() translate to RDataFrame. Follow the crash course to discover more idiomatic and flexible ways to express analyses with RDataFrame. . TTreeReader ROOT::RDataFrame . TTreeReader reader(""myTree"", file);; TTreeReaderValue<A_t> a(reader, ""A"");; TTreeReaderValue<B_t> b(reader, ""B"");; TTreeReaderValue<C_t> c(reader, ""C"");; while(reader.Next()) {; if(IsGoodEvent(*a, *b, *c)); DoStuff(*a, *b, *c);; }; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:146; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:44; ROOT::RDataFrame d(""myTree"", file, {""A"", ""B"", ""C""});; d.Filter(IsGoodEvent).Foreach(DoStuff);; ROOT::RDF::RInterface::FilterRInterface< RDFDetail::RFilter< F, Proxied >, DS_t > Filter(F f, const ColumnNames_t &columns={}, std::string_view name="""")Append a filter to the call graph.Definition RInterface.hxx:216; . TTree::Draw ROOT::RDataFrame . auto *tree = file->Get<TTree>(""myTree"");; tree->Draw(""x"", ""y > 2"");; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; ROOT::RDataFrame df(""myTree"", file);; auto h = df.Filter(""y > 2"").Histo1D(""x"");; h->Draw(); h#define h(i)Definition RSha256.hxx:106; . tree->Draw(""jet_eta"", ""weight*(event == 1)"");; df.Filter(""event == 1"").Histo1D(""jet_eta"", ""weight"");; // or the fully compiled version:; df.Filter([] (ULong64_t e) { return e == 1; }, {""event""}).Histo1D<RVec<float>>(""jet_eta"", ""weight"");; e#define e(i)Definition RSha256.hxx:103; ULong64_tunsigned ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:12052,simpl,simple,12052,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['simpl'],['simple']
Usability,"the first time. Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate work and then produce all results at the same time, upon first access to any of them.; The following table shows how analyses based on TTreeReader and TTree::Draw() translate to RDataFrame. Follow the crash course to discover more idiomatic and flexible ways to express analyses with RDataFrame. . TTreeReader ROOT::RDataFrame . TTreeReader reader(""myTree"", file);; TTreeReaderValue<A_t> a(reader, ""A"");; TTreeReaderValue<B_t> b(reader, ""B"");; TTreeReaderValue<C_t> c(reader, ""C"");; while(reader.Next()) {; if(IsGoodEvent(*a, *b, *c)); DoStuff(*a, *b, *c);; }; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:174; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; ROOT::RDataFrame d(""myTree"", file, {""A"", ""B"", ""C""});; d.Filter(IsGoodEvent).Foreach(DoStuff);; ROOT::RDF::RInterface::FilterRInterface< RDFDetail::RFilter< F, Proxied >, DS_t > Filter(F f, const ColumnNames_t &columns={}, std::string_view name="""")Append a filter to the call graph.Definition RInterface.hxx:219; . TTree::Draw ROOT::RDataFrame . auto *tree = file->Get<TTree>(""myTree"");; tree->Draw(""x"", ""y > 2"");; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; ROOT::RDataFrame df(""myTree"", file);; auto h = df.Filter(""y > 2"").Histo1D(""x"");; h->Draw(); h#define h(i)Definition RSha256.hxx:106; . tree->Draw(""jet_eta"", ""weight*(event == 1)"");; df.Filter(""event == 1"").Histo1D(""jet_eta"", ""weight"");; // or the fully compiled version:; df.Filter([] (ULong64_t e) { return e == 1; }, {""event""}).Histo1D<RVec<float>>(""jet_eta"", ""weight"");; e#define e(i)Definition RSha256.hxx:103; ULong64_tunsigned ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:12441,simpl,simple,12441,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['simpl'],['simple']
Usability,"the head of the list. An ObjLink can be obtained by looping over a list; using the above describe iterator method 3. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after the specified ObjLink object. If after = 0 then add; to the tail of the list. An ObjLink can be obtained by looping over a list; using the above describe iterator method 3. void AddAt(TObject* obj, Int_t idx); Insert object at position idx in the list. TObject * After(const TObject* obj) const; Returns the object after object obj. Obj is found using the; object's IsEqual() method. Returns 0 if obj is last in list. TObject * At(Int_t idx) const; Returns the object at position idx. Returns 0 if idx is out of range. TObject * Before(const TObject* obj) const; Returns the object before object obj. Obj is found using the; object's IsEqual() method. Returns 0 if obj is first in list. void Clear(Option_t* option = """"); Remove all objects from the list. Does not delete the objects; unless the TList is the owner (set via SetOwner()) and option; ""nodelete"" is not set.; If option=""nodelete"" then don't delete any heap objects that were; marked with the kCanDelete bit, otherwise these objects will be; deleted (this option is used by THashTable::Clear()). void Delete(Option_t* option = """"); Remove all objects from the list AND delete all heap based objects.; If option=""slow"" then keep list consistent during delete. This allows; recursive list operations during the delete (e.g. during the dtor; of an object in this list one can still access the list to search for; other not yet deleted objects). void DeleteLink(TObjLink* lnk); Delete a TObjLink object. TObject * FindObject(const char* name) const; Find an object in this list using its name. Requires a sequential; scan till the object has been found. Returns 0 if object with specified; name is not found. This method overrides the generic FindObject(); of TCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TList.html:13364,Clear,Clear,13364,root/html532/TList.html,https://root.cern,https://root.cern/root/html532/TList.html,4,['Clear'],['Clear']
Usability,"the histogram along x, y or z axis.; For axis = 11, 12 or 13 returns the approximate standard error of skewness; of the histogram along x, y or z axis; Note, that since third and fourth moment are not calculated; at the fill time, skewness and its standard error are computed bin by bin. Double_t GetKurtosis(Int_t axis = 1) const; For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.; Kurtosis(gaussian(0, 1)) = 0.; For axis =11, 12 or 13 returns the approximate standard error of kurtosis; of the histogram along x, y or z axis; Note, that since third and fourth moment are not calculated; at the fill time, kurtosis and its standard error are computed bin by bin. void GetStats(Double_t* stats) const; fill the array stats from the contents of this histogram; The array stats must be correctly dimensioned in the calling program.; stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2. If no axis-subrange is specified (via TAxis::SetRange), the array stats; is simply a copy of the statistics quantities computed at filling time.; If a sub-range is specified, the function recomputes these quantities; from the bin contents in the current axis range. Note that the mean value/RMS is computed using the bins in the currently; defined range (see TAxis::SetRange). By default the range includes; all bins from 1 to nbins included, excluding underflows and overflows.; To force the underflows and overflows in the computation, one must; call the static function TH1::StatOverflows(kTRUE) before filling; the histogram. void PutStats(Double_t* stats); Replace current statistics with the values in array stats. void ResetStats(); Reset the statistics including the number of entries; and replace with values calculates from bin content; The number of entries is set to the total bin content or (in case of weighted histogram); to number of effective entries. Double_t GetSumOfWeights() const; -*-*-*-*-*-*Return the sum of weights excluding under/overflows*-*-*-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH1.html:107378,simpl,simply,107378,root/html532/TH1.html,https://root.cern,https://root.cern/root/html532/TH1.html,4,['simpl'],['simply']
Usability,"the histogram along x, y or z axis.; For axis = 11, 12 or 13 returns the approximate standard error of skewness; of the histogram along x, y or z axis; Note, that since third and fourth moment are not calculated; at the fill time, skewness and its standard error are computed bin by bin. Double_t GetKurtosis(Int_t axis = 1) const; For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.; Kurtosis(gaussian(0, 1)) = 0.; For axis =11, 12 or 13 returns the approximate standard error of kurtosis; of the histogram along x, y or z axis; Note, that since third and fourth moment are not calculated; at the fill time, kurtosis and its standard error are computed bin by bin. void GetStats(Double_t* stats) const; fill the array stats from the contents of this histogram; The array stats must be correctly dimensioned in the calling program.; stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2. If no axis-subrange is specified (via TAxis::SetRange), the array stats; is simply a copy of the statistics quantities computed at filling time.; If a sub-range is specified, the function recomputes these quantities; from the bin contents in the current axis range. Note that the mean value/RMS is computed using the bins in the currently; defined range (see TAxis::SetRange). By default the range includes; all bins from 1 to nbins included, excluding underflows and overflows.; To force the underflows and overflows in the computation, one must; call the static function TH1::StatOverflows(kTRUE) before filling; the histogram. void PutStats(Double_t* stats); Replace current statistics with the values in array stats. void ResetStats(); Reset the statistics including the number of entries; and replace with values calculates from bin content; The number of entries is set to the total bin content or (in case of weighted histogram); to number of effective entries. Double_t GetSumOfWeights() const; Return the sum of weights excluding under/overflows. Double_t Integra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:114222,simpl,simply,114222,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['simpl'],['simply']
Usability,"the histogram along x, y or z axis.; For axis = 11, 12 or 13 returns the approximate standard error of skewness; of the histogram along x, y or z axis; Note, that since third and fourth moment are not calculated; at the fill time, skewness and its standard error are computed bin by bin. Double_t GetKurtosis(Int_t axis = 1) const; For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.; Kurtosis(gaussian(0, 1)) = 0.; For axis =11, 12 or 13 returns the approximate standard error of kurtosis; of the histogram along x, y or z axis; Note, that since third and fourth moment are not calculated; at the fill time, kurtosis and its standard error are computed bin by bin. void GetStats(Double_t* stats) const; fill the array stats from the contents of this histogram; The array stats must be correctly dimensioned in the calling program.; stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2. If no axis-subrange is specified (via TAxis::SetRange), the array stats; is simply a copy of the statistics quantities computed at filling time.; If a sub-range is specified, the function recomputes these quantities; from the bin contents in the current axis range. Note that the mean value/StdDev is computed using the bins in the currently; defined range (see TAxis::SetRange). By default the range includes; all bins from 1 to nbins included, excluding underflows and overflows.; To force the underflows and overflows in the computation, one must; call the static function TH1::StatOverflows(kTRUE) before filling; the histogram. void PutStats(Double_t* stats); Replace current statistics with the values in array stats. void ResetStats(); Reset the statistics including the number of entries; and replace with values calculates from bin content; The number of entries is set to the total bin content or (in case of weighted histogram); to number of effective entries. Double_t GetSumOfWeights() const; Return the sum of weights excluding under/overflows. Double_t Inte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TH1.html:114347,simpl,simply,114347,root/html604/TH1.html,https://root.cern,https://root.cern/root/html604/TH1.html,2,['simpl'],['simply']
Usability,"the impatient user; 60You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python.; 61 ; 62## Table of Contents; 63- [Cheat sheet](\ref cheatsheet); 64- [Introduction](\ref introduction); 65- [Crash course](\ref crash-course); 66- [Working with collections](\ref collections); 67- [Transformations: manipulating data](\ref transformations); 68- [Actions: getting results](\ref actions); 69- [Distributed execution in Python](\ref distrdf); 70- [Performance tips and parallel execution](\ref parallel-execution); 71- [More features](\ref more-features); 72 - [Systematic variations](\ref systematics); 73 - [RDataFrame objects as function arguments and return values](\ref rnode); 74 - [Storing RDataFrame objects in collections](\ref RDFCollections); 75 - [Executing callbacks every N events](\ref callbacks); 76 - [Default column lists](\ref default-branches); 77 - [Special helper columns: `rdfentry_` and `rdfslot_`](\ref helper-cols); 78 - [Just-in-time compilation: column type inference and explicit declaration of column types](\ref jitting); 79 - [User-defined custom actions](\ref generic-actions); 80 - [Dataset joins with friend trees](\ref friends); 81 - [Reading data formats other than ROOT trees](\ref other-file-formats); 82 - [Computation graphs (storing and reusing sets of transformations)](\ref callgraphs); 83 - [Visualizing the computation graph](\ref representgraph); 84 - [Activating RDataFrame execution logs](\ref rdf-logging); 85 - [Creating an RDataFrame from a dataset specification file](\ref rdf-from-spec); 86 - [Adding a progress bar](\ref progressbar); 87 - [Working with missing values in the dataset](\ref missing-values); 88- [Efficient analysis in Python](\ref python); 89- <a class=""el"" href=""classROOT_1_1RDataFrame.html#reference"" onclick=""javascript:toggleInherit('pub_methods_classROOT_1_1RDF_1_1RInterface')"">Class reference</a>; 90 ; 91\anchor cheatsheet; 92## Cheat sheet; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:4254,progress bar,progress bar,4254,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,"the labels in case of alphanumeric labels; 4497 if (fXaxis->CanExtend() && fXaxis->IsAlphanumeric()) fH->LabelsDeflate(""X"");; 4498 if (fYaxis->CanExtend() && fYaxis->IsAlphanumeric()) fH->LabelsDeflate(""Y"");; 4499 if (fZaxis->CanExtend() && fZaxis->IsAlphanumeric()) fH->LabelsDeflate(""Z"");; 4500 ; 4501 if (Hoption.Pie) {; 4502 if (fH->GetDimension() == 1) {; 4503 if (!fPie); 4504 fPie = std::make_unique<TPie>(fH);; 4505 fPie->Paint(option);; 4506 } else {; 4507 Error(""Paint"", ""Option PIE is for 1D histograms only"");; 4508 }; 4509 return;; 4510 } else {; 4511 fPie.reset();; 4512 }; 4513 ; 4514 fXbuf.resize(kNMAX);; 4515 fYbuf.resize(kNMAX);; 4516 if (fH->GetDimension() > 2) {; 4517 PaintH3(option);; 4518 fH->SetMinimum(minsav);; 4519 if (Hoption.Func) {; 4520 Hoption_t hoptsave = Hoption;; 4521 Hparam_t hparsave = Hparam;; 4522 PaintFunction(option);; 4523 SetHistogram(hsave);; 4524 Hoption = hoptsave;; 4525 Hparam = hparsave;; 4526 }; 4527 gCurrentHist = oldhist;; 4528 fXbuf.clear();; 4529 fYbuf.clear();; 4530 return;; 4531 }; 4532 TView *view = gPad->GetView();; 4533 if (view) {; 4534 if (!Hoption.Lego && !Hoption.Surf && !Hoption.Tri) {; 4535 delete view;; 4536 gPad->SetView(nullptr);; 4537 }; 4538 }; 4539 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) {; 4540 // In case of 1D histogram, Z axis becomes Y axis.; 4541 Int_t logysav=0, logzsav=0;; 4542 if (fH->GetDimension() == 1) {; 4543 logysav = Hoption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 45",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:172248,clear,clear,172248,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['clear'],['clear']
Usability,"the later case, the function Clear; will be called and passed the value of 'clear_options'. Tests to see if the destructor has been called on the object.; If so, or if the object has never been constructed the class constructor is called using; New(). If not, return a pointer to the correct memory location.; This explicitly to deal with TObject classes that allocate memory; which will be reset (but not deallocated) in their Clear(); functions. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:19809,clear,cleared,19809,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,8,['clear'],['cleared']
Usability,"the list of names of the packages available. TList * GetListOfEnabledPackages(); Get from the master the list of names of the packages enabled. void PrintProgress(Long64_t total, Long64_t processed, Float_t procTime = -1., Long64_t bytesread = -1); Print a progress bar on stderr. Used in batch mode. void Progress(Long64_t total, Long64_t processed); Get query progress information. Connect a slot to this signal; to track progress. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Get query progress information. Connect a slot to this signal; to track progress. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Get query progress information. Connect a slot to this signal; to track progress. void Feedback(TList* objs); Get list of feedback objects. Connect a slot to this signal; to monitor the feedback object. void CloseProgressDialog(); Close progress dialog. void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset progress dialog. void StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total); Send startup message. void DataSetStatus(const char* msg, Bool_t status, Int_t done, Int_t total); Send dataset preparation status. void SendDataSetStatus(const char* msg, UInt_t n, UInt_t tot, Bool_t st); Send or notify data set status. void QueryResultReady(const char* ref); Notify availability of a query result. void ValidateDSet(TDSet* dset); Validate a TDSet. void AddInputData(TObject* obj, Bool_t push = kFALSE); Add data objects that might be needed during the processing of; the selector (see Process()). This object can be very large, so they; are distributed in an optimized way using a dedicated file.; If push is TRUE the input data are sent over even if no apparent change; occured to the list. void ClearInputData(TObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:70543,feedback,feedback,70543,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,10,['feedback'],['feedback']
Usability,"the original assembly using TGeoVolume->AddNode. XMLNodePointer_t TopProcess(TXMLEngine* gdml, XMLNodePointer_t node); In the setup section of the GDML file, the top volume need to be; declared. when the setup keyword is found, this function is called,; and the top volume ref is taken and 'world' is set. XMLNodePointer_t Box(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, a box may be declared.; when the box keyword is found, this function is called, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoBBox and stored in fsolmap map using the name; as its key. XMLNodePointer_t Ellipsoid(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, an ellipsoid may be declared.; Unfortunately, the ellipsoid is not supported under ROOT so,; when the ellipsoid keyword is found, this function is called; to convert it to a simple box with similar dimensions, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoBBox and stored in fsolmap map using the name; as its key. XMLNodePointer_t ElCone(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, an elliptical cone may be declared.; Unfortunately, the elliptical cone is not supported under ROOT so,; when the elcone keyword is found, this function is called; to convert it to a simple box with similar dimensions, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoBBox and stored in fsolmap map using the name; as its key. XMLNodePointer_t Paraboloid(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, a Paraboloid may be declared.; when the paraboloid keyword is found, this function is called, and the; dimensions required are taken and stored, these are then bound and; converted to type TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGDMLParse.html:17064,simpl,simple,17064,root/html534/TGDMLParse.html,https://root.cern,https://root.cern/root/html534/TGDMLParse.html,6,['simpl'],['simple']
Usability,"the original assembly using TGeoVolume->AddNode. XMLNodePointer_t TopProcess(TXMLEngine* gdml, XMLNodePointer_t node); In the setup section of the GDML file, the top volume need to be; declared. when the setup keyword is found, this function is called,; and the top volume ref is taken and 'world' is set. XMLNodePointer_t Box(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, a box may be declared.; when the box keyword is found, this function is called, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoBBox and stored in fsolmap map using the name; as its key. XMLNodePointer_t Ellipsoid(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, an ellipsoid may be declared.; Unfortunately, the ellipsoid is not supported under ROOT so,; when the ellipsoid keyword is found, this function is called; to convert it to a simple box with similar dimensions, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoBBox and stored in fsolmap map using the name; as its key. XMLNodePointer_t Paraboloid(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, a Paraboloid may be declared.; when the paraboloid keyword is found, this function is called, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoParaboloid and stored in fsolmap map using the name; as its key. XMLNodePointer_t Arb8(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, an Arb8 may be declared.; when the arb8 keyword is found, this function is called, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoArb8 and stored in fsolmap map using the name; as its key. XMLNodePointer_t Tube(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGDMLParse.html:17131,simpl,simple,17131,root/html528/TGDMLParse.html,https://root.cern,https://root.cern/root/html528/TGDMLParse.html,4,['simpl'],['simple']
Usability,"the parameter is already; set it will be set to the new value. void SetParameter(const char* par, Int_t value); Set an input list parameter. void SetParameter(const char* par, Long_t value); Set an input list parameter. void SetParameter(const char* par, Long64_t value); Set an input list parameter. void SetParameter(const char* par, Double_t value); Set an input list parameter. TObject * GetParameter(const char* par) const; Get specified parameter. A parameter set via SetParameter() is either; a TParameter or a TNamed or 0 in case par is not defined. void DeleteParameters(const char* wildcard); Delete the input list parameters specified by a wildcard (e.g. PROOF_*); or exact name (e.g. PROOF_MaxSlavesPerNode). void ShowParameters(const char* wildcard = ""PROOF_*"") const; Show the input list parameters specified by the wildcard.; Default is the special PROOF control parameters (PROOF_*). void AddFeedback(const char* name); Add object to feedback list. void RemoveFeedback(const char* name); Remove object from feedback list. void ClearFeedback(); Clear feedback list. void ShowFeedback() const; Show items in feedback list. TList * GetFeedbackList() const; Return feedback list. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. TDrawFeedback * CreateDrawFeedback(); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. TList * GetOutputNames(); FIXME: to be written. void Browse(TBrowser* b); Build the PROOF's structure in the browser. void SetPlayer(TVirtualProofPlayer* player); Set a new PROOF player. TVirtualProofPlayer * MakePlayer(const char* player = 0, TSocket* s = 0); Construct a TProofPlayer object. The player string specifies which; player should be created: remote, slave, sm (supermaster) or base.; D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:74644,feedback,feedback,74644,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,10,['feedback'],['feedback']
Usability,"the picture and beta on the left; side, respectively. One can rotate the 3-d space around vertical axis; going through the center of it employing the view parameter. Allowed; values are 0, 90, 180 and 270 degrees. * * *. zs(scale) changes the scale of the Z-axis Possible values are:. 0 = Linear (default); 1 = Log; 2 = Sqrt. If gPad->SetLogz() has been set, log scale on Z-axis is set automatically.; No need to use the zs() operator. Note that the X and Y axis are always; linear. * * *. ci(r,g,b), were r,g and b are floats defines the colors increments.; For sophisticated shading (Light, Height and LightHeight Display Modes; Groups) the color palette starts from the basic pen color (see pa(); function). There is a predefined number of color levels (256). Color in; every level is calculated by adding the increments of the r, g, b; components to the previous level. Using this function one can change the; color increments between two neighboring color levels. The function does; not apply dor the Simple Display Modes Group. The default values are:; (1,1,1). * * *. ca(color_algorithm) allows to choose the Color Algorithm.; To define the colors one can employ one of the following color algorithms; (RGB, CMY, CIE, YIQ, HVS models). When the level of a component reaches; the limit value one can choose either smooth transition (by decreasing; the limit value) or a sharp modulo transition (continuing with 0 value).; This makes possible to realize various visual effects. One can choose from; the following set of the algorithms:. 0 = RGB Smooth; 1 = RGB Modulo; 2 = CMY Smooth; 3 = CMY Modulo; 4 = CIE Smooth; 5 = CIE Modulo; 6 = YIQ Smooth; 7 = YIQ Modulo; 8 = HVS Smooth; 9 = HVS Modulo. This function does not apply on Simple display modes group. Default; value is 0. Example:. h2->Draw(""SPEC c1(4) dm(0,1) a(30,30,0)"");. choose CMY Modulo to paint the ""h2"" histogram. * * *. lp(x,y,z) set the light position.; In Light and LightHeight display modes groups the color palette is; calcula",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSpectrum2Painter.html:40474,Simpl,Simple,40474,root/html532/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html532/TSpectrum2Painter.html,4,['Simpl'],['Simple']
Usability,"the special case with equidistant points. Graphs are created with the TGraph constructor. First, we define the arrays of coordinates and then create the graph. The coordinates can be arrays of doubles or floats.; Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0; i<n; i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; TGraph *gr1 = new TGraph (n, x, y);; An alternative constructor takes only the number of points n. It is expected that the coordinates will be set later.; TGraph *gr2 = new TGraph(n);; The default constructor can also be used. Further calls to SetPoint() will extend the internal vectors.; TGraph *gr3 = new TGraph();; 4.1.1 Graph Draw Options; The various drawing options for a graph are explained in TGraph::PaintGraph. They are:. “L” A simple poly-line between every points is drawn; “F” A fill area is drawn; “F1” Idem as “F” but fill area is no more repartee around X=0 or Y=0; “F2” draw a fill area poly line connecting the center of bins; “A” Axis are drawn around the graph; “C” A smooth curve is drawn; “*” A star is plotted at each point; “P” The current marker of the graph is plotted at each point; “B” A bar chart is drawn at each point; “[]” Only the end vertical/horizontal lines of the error bars are drawn. This option only applies to the TGraphAsymmErrors.; “1” ylow = rwymin. The options are not case sensitive and they can be concatenated in most cases. Let us look at some examples.; 4.1.1.1 Continuous Line, Axis and Stars (AC*). A graph drawn with axis, * markers and continuous line (option AC*). {; Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }. // create graph; TGraph *gr = new TGraph(n,x,y);; TCanvas *c1 = new TCanvas(""c1"",""Graph Draw Options"",; 200,10,600,400);. // draw the graph with axis, continuous line, and put; // a * at each point; gr->Draw(""AC*"");; }; 4.1.1.2 Bar Graphs (AB). A graph drawn with axis and bar (option AB). root[] TGraph *gr1 = new TGraph(n,x,y);; root[] gr1->Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:142487,simpl,simple,142487,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"the type of FCN function passesd and on the objects used for the parameters ;  CMPIProcess;  CMPITerminate;  CNegativeG2LineSearchIn case that one of the components of the second derivative g2 calculated by the numerical Gradient calculator is negative, a 1dim line search in the direction of that component is done in order to find a better position where g2 is again positive ;  CNumerical2PGradientCalculatorClass performing the numerical gradient calculation ;  CParametricFunctionFunction which has parameters ;  CQuad12F;  CQuad1F;  CQuad4F;  CQuad4FGrad;  CQuad8F;  CScanBuilderPerforms a minimization using the simplex method of Nelder and Mead (ref ;  CScanMinimizerClass implementing the required methods for a minimization using SCAN API is provided in the upper ROOT::Minuit2::ModularFunctionMinimizer class ;  CSimplexBuilderPerforms a minimization using the simplex method of Nelder and Mead (ref ;  CSimplexMinimizerClass implementing the required methods for a minimization using Simplex ;  CSimplexParametersClass describing the simplex set of points (f(x), x ) which evolve during the minimization iteration process ;  CSimplexSeedGeneratorGenerate Simplex starting point (state) ;  CSinParameterTransformationClass for the transformation for double-limited parameter Using a sin function one goes from a double-limited parameter range to an unlimited one ;  CSqrtLowParameterTransformationTransformation from external to internal Parameter based on sqrt(1 + x**2) ;  CSqrtUpParameterTransformationTransformation from external to internal Parameter based on sqrt(1 + x**2) ;  CStackAllocatorStackAllocator controls the memory allocation/deallocation of Minuit ;  CStackAllocatorHolder;  CStackError;  CStackOverflowDefine stack allocator symbol ;  Csym;  CVariableMetricBuilderBuild (find) function minimum using the Variable Metric method (MIGRAD) ;  CVariableMetricEDMEstimator;  CVariableMetricMinimizerInstantiates the SeedGenerator and MinimumBuilder for Variable Metric Minimi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:59463,Simpl,Simplex,59463,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['Simpl'],['Simplex']
Usability,"the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D""; -If the type is a string of characters. This will read; subsequent characters until a whitespace is found (whitespace; characters are considered to be blank, newline and tab). Lines in the input file starting with ""#"" are ignored.; This function will read and ignore any whitespace characters; (this includes blank spaces and the newline and tab characters). A TBranch object is created for each variable in the expression.; The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES. To fill a TTree with multiple input text files, proceed as indicated above; for the first input file and omit the second argument for subsequent calls; T.ReadFile(""file1.dat"",""branch descriptor"");; T.ReadFile(""file2.dat"");. Long64_t ReadStream(istream& inputStream, const char* branchDescriptor = """"); Create or simply read branches from an input stream. See reference information for TTree::ReadFile. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Refresh(); Refresh contents of this tree and its branches from the current status on disk. One can call this function in case the tree file is being; updated by another process. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Reset baskets, buffers and entries count in all branches and leaves. void ResetBranchAddress(TBranch* ); Tell all of our branches to set their addresses to zero. Note: If any of our branches own any objects, they are deleted. void ResetBranchAddresses(); Tell all of our branches to drop their current objects and allocate new ones. Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:112403,simpl,simply,112403,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['simpl'],['simply']
Usability,"the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created for each variable in the expression.; The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES. To fill a TTree with multiple input text files, proceed as indicated above; for the first input file and omit the second argument for subsequent calls; T.ReadFile(""file1.dat"",""branch descriptor"");; T.ReadFile(""file2.dat"");. char GetNewlineValue(istream& inputStream); Determine which newline this file is using.; Return '\r' for Windows '\r\n' as that already terminates. Long64_t ReadStream(istream& inputStream, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from an input stream. See reference information for TTree::ReadFile. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Refresh(); Refresh contents of this tree and its branches from the current status on disk. One can call this function in case the tree file is being; updated by another process. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Reset baskets, buffers and entries count in all branches and leaves. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this TTree after a merge (keep the customization but; forget the data). void ResetBranchAddress(TBranch* ); Tell all of our branches to set their addresses to zero. Note: If any of our branches own any objects, they are deleted. void ResetBranchAddresses(); Tell all of our branches to drop their current objects and alloca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:122970,simpl,simply,122970,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,6,['simpl'],['simply']
Usability,"theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. void Init( void ); default initialisation. void DeclareOptions(); define the options (their key words) that can be set in the option string. format of function string:; ""x0*(0)+((1)/x1)**(2)...""; where ""[i]"" are the parameters, and ""xi"" the input variables. format of parameter string:; ""(-1.2,3.4);(-2.3,4.55);...""; where the numbers in ""(a,b)"" correspond to the a=min, b=max parameter ranges;; each parameter defined in the function string must have a corresponding range. void CreateFormula(); translate formula string into TFormula, and parameter string into par ranges. void ProcessOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". ~MethodFDA( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void ClearAll( void ); delete and clear all class members. void Train( void ); FDA training. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; display fit parameters; check maximum length of variable name. Double_t EstimatorFunction(vector<Double_t>& ); compute estimator for given parameter set (to be minimised); const Double_t sumOfWeights[] = { fSumOfWeightsSig, fSumOfWeightsBkg, fSumOfWeights };. Double_t InterpretFormula(const TMVA::Event* , vector<double,allocator<double> >::iterator begin, vector<double,allocator<double> >::iterator end); formula interpretation. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). const std::vector<Float_t>& GetMulticlassValues(). void CalculateMulticlassValues(const TMVA::Event*& evt, vector<Double_t>& parameters, vector<Float_t>& values); calculate the values for multiclass. void ReadWeightsFromStream(istream& i); read back the training results fro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodFDA.html:18371,clear,clear,18371,root/html528/TMVA__MethodFDA.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodFDA.html,8,"['Clear', 'clear']","['ClearAll', 'clear']"
Usability,"ther objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject. ◆ Process(). Bool_t h1analysisTreeReader::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used.; WARNING when a selector is used with a TChain, you must use the pointer to the current TTree to call GetEntry(entry). The entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use: fChain->GetTree()->GetEntry(entry). ; Reimplemented from TSelector. ◆ Reset(). void h1analysisTreeReader::Reset ; (; ). Definition at line 81 of file h1analysisTreeReader.h. ◆ SetInputList(). void h1analysisTreeReader::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 72 of file h1analysisTreeReader.h. ◆ SetObject(). void h1analysisTreeReader::SetObject ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 71 of file h1analy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classh1analysisTreeReader.html:16529,simpl,simple,16529,doc/master/classh1analysisTreeReader.html,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html,1,['simpl'],['simple']
Usability,"ther so an end user can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; gPad#define gPadDefinition TVirtualPad.h:308; TQCommand::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the list of merged commands.Definition TQCommand.cxx:360. Macro commands ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);; ...; During Redo operation commands composing macro command are executed sequentially in direct order (first in first out). During Undo, they are executed in reverse order (last in first out).; Undo manager. TQUndoManager is recorder of undo and redo operations. This is command history list which can be traversed backwards and upwards performing undo and redo operations. To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);; TQCommand::TQUndoManagerfriend class TQUndoManagerDefinition TQCommand.h:29; TQUndoManagerRecorder of operations for undo and redo.Definition TQCommand.h:103; TQUndoManager::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the stack of commands.Definition TQCommand.cxx:959; TQUndoManager::Add automatically invokes execution of command's Redo method. Use TQUndoManager::Undo to undo commands in history list. Redo is Undo for undo action. Use TQUndoManager::Redo method for that ; Definition at line 27 of file TQCommand.h. Public Member Functions;  TQCommand (const char *cl=nullptr, void *object=nullptr, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ;  TQCommand (const TQCommand &com);  Copy constructor. ;  ;  TQCommand (TObject *obj, const char *redo=nullptr, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:3983,undo,undo,3983,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"these entries / subentries are used to fill histograms. About the class ; The class derives from TEntryList and can be used basically in the same way. This same class is used to keep entries and subentries, so there are two types of TEntryListArray's:. The ones that only hold subentries ; fEntry is set to the entry# for which the subentries correspond; fSubLists must be 0; The ones that hold entries and eventually lists with subentries in fSubLists.; fEntry = -1 for those; If there are no sublists for a given entry, all the subentries will be used in the selection . Additions with respect to TEntryList ; Data members:; fSubLists: a container to hold the sublists; fEntry: the entry number if the list is used to hold subentries; fLastSubListQueried and fSubListIter: a pointer to the last sublist queried and an iterator to resume the loop from the last sublist queried (to speed up selection and insertion in TTree::Draw) ; Public methods:; Contains, Enter and Remove with subentry as argument; GetSubListForEntry: to return the sublist corresponding to the given entry ; Protected methods:; AddEntriesAndSubLists: called by Add when adding two TEntryList arrays with sublists; ConvertToTEntryListArray: convert TEntryList to TEntryListArray; RemoveSubList: to remove the given sublist; RemoveSubListForEntry: to remove the sublist corresponding to the given entry; SetEntry: to get / set a sublist for the given entry . . Function Members (Methods); public:. TEntryListArray(); TEntryListArray(const TTree* tree); TEntryListArray(const TEntryListArray& elist); TEntryListArray(const TEntryList& elist); TEntryListArray(const char* name, const char* title); TEntryListArray(const char* name, const char* title, const TTree* tree); TEntryListArray(const char* name, const char* title, const char* treename, const char* filename); virtual~TEntryListArray(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(const TEntryList* elist); virtual voidTObject::AppendPad(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEntryListArray.html:1978,resume,resume,1978,root/html532/TEntryListArray.html,https://root.cern,https://root.cern/root/html532/TEntryListArray.html,4,['resume'],['resume']
Usability,"they can be edited/moved by pointing; directly to them. The cursor shape is changed to suggest the type of action that; one can do on this object. Clicking with the right mouse button on an object; pops-up a contextmenu with a complete list of actions possible on this object. A graphical editor may be started from the canvas ""View"" menu under the menu; entry ""Toolbar"". An interactive HELP is available by clicking on the HELP button at the top right; of the canvas. It gives a short explanation about the canvas' menus. A canvas may be automatically divided into pads via TPad::Divide. At creation time, in interactive mode, the canvas size defines the size of the; canvas window (including the window manager's decoration). To define precisely; the graphics area size of a canvas, the following four lines of code should be; used:. {; Double_t w = 600;; Double_t h = 600;; TCanvas * c1 = new TCanvas(""c"", ""c"", w, h);; c->SetWindowSize(w + (w - c->GetWw()), h + (h - c->GetWh()));; }. in batch mode simply do:. c->SetCanvasSize(w,h);. . Function Members (Methods); public:. TCanvas(Bool_t build = kTRUE); TCanvas(const char* name, const char* title = """", Int_t form = 1); TCanvas(const char* name, const char* title, Int_t ww, Int_t wh); TCanvas(const char* name, Int_t ww, Int_t wh, Int_t winid); TCanvas(const char* name, const char* title, Int_t wtopx, Int_t wtopy, Int_t ww, Int_t wh); virtual~TCanvas(); virtual voidTPad::AbsCoordinates(Bool_t set); virtual Double_tTPad::AbsPixeltoX(Int_t px); virtual voidTPad::AbsPixeltoXY(Int_t xpixel, Int_t ypixel, Double_t& x, Double_t& y); virtual Double_tTPad::AbsPixeltoY(Int_t py); voidTObject::AbstractMethod(const char* method) const; virtual voidTPad::AddExec(const char* name, const char* command); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTPad::AutoExec(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::Bloc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCanvas.html:2469,simpl,simply,2469,root/html534/TCanvas.html,https://root.cern,https://root.cern/root/html534/TCanvas.html,2,['simpl'],['simply']
Usability,"they can be edited/moved by pointing; directly to them. The cursor shape is changed to suggest the type of action that; one can do on this object. Clicking with the right mouse button on an object; pops-up a contextmenu with a complete list of actions possible on this object. A graphical editor may be started from the canvas ""View"" menu under the menu; entry ""Toolbar"". An interactive HELP is available by clicking on the HELP button at the top right; of the canvas. It gives a short explanation about the canvas' menus. A canvas may be automatically divided into pads via TPad::Divide. At creation time, in interactive mode, the canvas size defines the size of the; canvas window (including the window manager's decoration). To define precisely; the graphics area size of a canvas, the following four lines of code should be; used:. {; Double_t w = 600;; Double_t h = 600;; TCanvas * c1 = new TCanvas(""c"", ""c"", w, h);; c->SetWindowSize(w + (w - c->GetWw()), h + (h - c->GetWh()));; }. in batch mode simply do:. c->SetCanvasSize(w,h);. . Function Members (Methods); public:. virtual~TCanvas(); virtual voidTPad::AbsCoordinates(Bool_t set); virtual Double_tTPad::AbsPixeltoX(Int_t px); virtual voidTPad::AbsPixeltoXY(Int_t xpixel, Int_t ypixel, Double_t& x, Double_t& y); virtual Double_tTPad::AbsPixeltoY(Int_t py); voidTObject::AbstractMethod(const char* method) const; virtual voidTPad::AddExec(const char* name, const char* command); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTPad::AutoExec(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidBrowse(TBrowser* b); virtual TLegend*TPad::BuildLegend(Double_t x1 = 0.5, Double_t y1 = 0.67000000000000004, Double_t x2 = 0.88, Double_t y2 = 0.88, const char* title = """")MENU ; virtual TVirtualPad*cd(Int_t subpadnumber = 0); virtual voidTQObject::ChangedBy(const char* method)SIGNAL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCanvas.html:2469,simpl,simply,2469,root/html602/TCanvas.html,https://root.cern,https://root.cern/root/html602/TCanvas.html,4,['simpl'],['simply']
Usability,"they will either keep or discard an entire entry; 1614based on whether a condition returns true or false. Specifically:; 1615 ; 1616- FilterAvailable: the condition is whether the value of the column is present.; 1617 If so, the entry is kept. Otherwise if the value is missing the entry is; 1618 discarded.; 1619- FilterMissing: the condition is whether the value of the column is missing. If; 1620 so, the entry is kept. Otherwise if the value is present the entry is; 1621 discarded.; 1622 ; 1623\code{.py}; 1624df = ROOT.RDataFrame(dataset); 1625 ; 1626# Anytime an entry from ""col"" is missing, the entire entry will be filtered out; 1627df_available = df.FilterAvailable(""col""); 1628df_available = df_available.Define(""twice"", ""col * 2""); 1629 ; 1630# Conversely, if we want to select the entries for which the column has missing; 1631# values, we do the following; 1632df_missingcol = df.FilterMissing(""col""); 1633# Following operations in the same branch of the computation graph clearly; 1634# cannot access that same column, since there would be no value to read; 1635df_missingcol = df_missingcol.Define(""observable"", ""othercolumn * 2""); 1636\endcode; 1637 ; 1638\code{.cpp}; 1639ROOT::RDataFrame df{dataset};; 1640 ; 1641// Anytime an entry from ""col"" is missing, the entire entry will be filtered out; 1642auto df_available = df.FilterAvailable(""col"");; 1643auto df_twicecol = df_available.Define(""twice"", ""col * 2"");; 1644 ; 1645// Conversely, if we want to select the entries for which the column has missing; 1646// values, we do the following; 1647auto df_missingcol = df.FilterMissing(""col"");; 1648// Following operations in the same branch of the computation graph clearly; 1649// cannot access that same column, since there would be no value to read; 1650auto df_observable = df_missingcol.Define(""observable"", ""othercolumn * 2"");; 1651\endcode; 1652 ; 1653#### DefaultValueFor; 1654 ; 1655DefaultValueFor creates a node of the computation graph which just forwards the; 1656values ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:91151,clear,clearly,91151,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['clear'],['clearly']
Usability,"thframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoEltuEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoEltuEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoName(); Slot for name. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoA(); Slot for A. void DoB(); Slot for B. void DoDz(); Slot for Z. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoEltuEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoEltuEditor.html:21143,undo,undoing,21143,root/html528/TGeoEltuEditor.html,https://root.cern,https://root.cern/root/html528/TGeoEltuEditor.html,1,['undo'],['undoing']
Usability,"thframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoEltuEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoEltuEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoName(); Slot for name. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoA(); Slot for A. void DoB(); Slot for B. void DoDz(); Slot for Z. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoEltuEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoEltuEditor.html:21243,undo,undoing,21243,root/html530/TGeoEltuEditor.html,https://root.cern,https://root.cern/root/html530/TGeoEltuEditor.html,1,['undo'],['undoing']
Usability,"thframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoEltuEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoEltuEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoName(); Slot for name. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoA(); Slot for A. void DoB(); Slot for B. void DoDz(); Slot for Z. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoEltuEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoEltuEditor.html:21243,undo,undoing,21243,root/html532/TGeoEltuEditor.html,https://root.cern,https://root.cern/root/html532/TGeoEltuEditor.html,2,['undo'],['undoing']
Usability,"thin ROOT ;  exec3.CExample of using signal/slot in TCanvas/TPad to get feedback about processed events ;  exec_macro.CThis utility macro executes the macro ""macro"" given as first argument and save a capture in a png file ;  games.CThis macro runs three ""games"" that each nicely illustrate the graphics capabilities of ROOT ;  gtreeTableTest.CThis TableTest class is a simple example of how to use a TGTreeTable ;  guilabels.CThis macro gives an example of how to create different kind of labels and the possibility to enable/disable them ;  guitest.CTest program for ROOT native GUI classes Exactly like $ROOTSYS/test/guitest.cxx but using the new signal and slots communication mechanism ;  guitest_playback.CThis macro plays a recorded ROOT session showing how to perform various interactive GUI operations with the guitest.C macro While replaying the session, several temporary macros (guitest0xx.C) macros will be saved ;  guiWithCINT.CA simple example of entering CINT commands and having the CINT output in a ROOT GUI application window ;  iconAsXPMData.CA simple example of creating icon image from XPM data, included into the code ;  listBox.CThis macro gives an example of how to create a list box and how to set and use its multiple selection feature ;  mditest.CGUI MDI features ;  ntupleTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  numberEntry.CThis macro gives an example of how to create a number entry and how to update a label according to the changed value of this number entry ;  QtFileDialog.CThis is a small ROOT macro to use Qt 3.3 class: QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileName ;  QtMultiFileDialog.CThis is a small ROOT macro to use Qt 3.3 class :QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileNames ;  QtPrintDialog.CThis is a small ROOT macro to use Qt 3.3 class: QPrinter to setup the printer via Qt ""setup printer dialog"" See: Printer setup d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:119289,simpl,simple,119289,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['simpl'],['simple']
Usability,"thing went wrong (-2 if at least one worker was not found) or the number of workers with status change (on master; 0 on client). ; Definition at line 11353 of file TProof.cxx. ◆ AddChain(). void TProof::AddChain ; (; TChain * ; chain). Add chain to data set. ; Definition at line 10223 of file TProof.cxx. ◆ AddDynamicPath(). Int_t TProof::AddDynamicPath ; (; const char * ; libpath, . Bool_t ; onClient = kFALSE, . TList * ; wrks = 0, . Bool_t ; doCollect = kTRUE . ). Add 'libpath' to the lib path search. ; Multiple paths can be specified at once separating them with a comma or a blank. Return 0 on success, -1 otherwise ; Definition at line 8843 of file TProof.cxx. ◆ AddEnvVar(). void TProof::AddEnvVar ; (; const char * ; name, . const char * ; value . ). static . Add an variable to the list of environment variables passed to proofserv on the master and slaves. ; Definition at line 11760 of file TProof.cxx. ◆ AddFeedback(). void TProof::AddFeedback ; (; const char * ; name). Add object to feedback list. ; Definition at line 9989 of file TProof.cxx. ◆ AddIncludePath(). Int_t TProof::AddIncludePath ; (; const char * ; incpath, . Bool_t ; onClient = kFALSE, . TList * ; wrks = 0, . Bool_t ; doCollect = kTRUE . ). Add 'incpath' to the inc path search. ; Multiple paths can be specified at once separating them with a comma or a blank. Return 0 on success, -1 otherwise ; Definition at line 8888 of file TProof.cxx. ◆ AddInput(). void TProof::AddInput ; (; TObject * ; obj). Add objects that might be needed during the processing of the selector (see Process()). ; Definition at line 9734 of file TProof.cxx. ◆ AddInputData(). void TProof::AddInputData ; (; TObject * ; obj, . Bool_t ; push = kFALSE . ). Add data objects that might be needed during the processing of the selector (see Process()). ; This object can be very large, so they are distributed in an optimized way using a dedicated file. If push is TRUE the input data are sent over even if no apparent change occured to the list",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:63373,feedback,feedback,63373,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['feedback'],['feedback']
Usability,"this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooLegendre; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSpHarmonic.html:46714,clear,clearEvalErrorLog,46714,doc/master/classRooSpHarmonic.html,https://root.cern,https://root.cern/doc/master/classRooSpHarmonic.html,1,['clear'],['clearEvalErrorLog']
Usability,"this profile2D by h1*-; *-* =============================. this = this*h1. Bool_t Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this profile2D by multiplication of h1 by h2; *-* ================================================================. this = (c1*h1)*(c2*h2). TH2D * ProjectionXY(const char* name = ""_pxy"", Option_t* option = ""e"") const; Project this profile2D into a 2-D histogram along X,Y*-*-; *-* =====================================================. The projection is always of the type TH2D. if option ""E"" is specified the errors of the projected histogram are computed and set; to be equal to the errors of the profile.; Option ""E"" is defined as the default one in the header file.; if option """" is specified the histogram errors are simply the sqrt of its content; if option ""B"" is specified, the content of bin of the returned histogram; will be equal to the GetBinEntries(bin) of the profile,; if option ""C=E"" the bin contents of the projection are set to the; bin errors of the profile; if option ""W"" is specified the bin content of the projected histogram is set to the; product of the bin content of the profile and the entries.; With this option the returned histogram will be equivalent to the one obtained by; filling directly a TH2D using the 3-rd value as a weight.; This option makes sense only for profile filled with all weights =1.; When the profile is weighted (filled with weights different than 1) the; bin error of the projected histogram (obtained using this option ""W"") cannot be; correctly computed from the information stored in the profile. In that case the; obtained histogram contains as bin error square the weighted sum of the square of the; profiled observable (TProfile2D::fSumw2[bin] ). TProfile * ProfileX(const char* name = ""_pfx"", Int_t firstybin = 0, Int_t lastybin = -1, Option_t* option = """") const; *-*-*-*-*Project a 2-D histogram into a profile histogram along X*-*-*-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile2D.html:40507,simpl,simply,40507,root/html534/TProfile2D.html,https://root.cern,https://root.cern/root/html534/TProfile2D.html,6,['simpl'],['simply']
Usability,"thm to speed up bins' filling; 62(see the ""Partitioning Algorithm"" section for details).; 63The partitioning algorithm divides the histogram into regions called cells.; 64The bins that each cell intersects are recorded in an array of `TList`s.; 65When a coordinate in the histogram is to be filled; the method (quickly) finds; 66which cell the coordinate belongs. It then only loops over the bins; 67intersecting that cell to find the bin the input coordinate corresponds to.; 68The partitioning of the histogram is updated continuously as each bin is added.; 69The default number of cells on each axis is 25. This number could be set to; 70another value in the constructor or adjusted later by calling the; 71`ChangePartition(Int_t, Int_t)` method. The partitioning algorithm is; 72considerably faster than the brute force algorithm (i.e. checking if each bin; 73contains the input coordinates), especially if the histogram is to be filled; 74many times.; 75 ; 76The following very simple macro shows how to build and fill a `TH2Poly`:; 77~~~ {.cpp}; 78{; 79 auto h2p = new TH2Poly();; 80 ; 81 Double_t x1[] = {0, 5, 6};; 82 Double_t y1[] = {0, 0, 5};; 83 Double_t x2[] = {0, -1, -1, 0};; 84 Double_t y2[] = {0, 0, -1, 3};; 85 Double_t x3[] = {4, 3, 0, 1, 2.4};; 86 Double_t y3[] = {4, 3.7, 1, 3.7, 2.5};; 87 ; 88 h2p->AddBin(3, x1, y1);; 89 h2p->AddBin(4, x2, y2);; 90 h2p->AddBin(5, x3, y3);; 91 ; 92 h2p->Fill(0.1, 0.01, 3);; 93 h2p->Fill(-0.5, -0.5, 7);; 94 h2p->Fill(-0.7, -0.5, 1);; 95 h2p->Fill(1, 3, 1.5);; 96}; 97~~~; 98 ; 99More examples can be found in th2polyBoxes.C, th2polyEurope.C, th2polyHoneycomb.C; 100and th2polyUSA.C.; 101 ; 102## Partitioning Algorithm; 103The partitioning algorithm forms an essential part of the `TH2Poly`; 104class. It is implemented to speed up the filling of bins.; 105 ; 106With the brute force approach, the filling is done in the following way: An; 107iterator loops over all bins in the `TH2Poly` and invokes the; 108method `IsInside()` for each of them",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8cxx_source.html:3513,simpl,simple,3513,doc/master/TH2Poly_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html,1,['simpl'],['simple']
Usability,"thod ;  Cvec;  CVectorOuterProduct;  ►NQuartz;  CCGAAStateGuard;  CCGStateGuard;  CTextLine;  ►NRNamespace associated R package for ROOT ;  Cclass_;  ►CTRDataFrameThis is a class to create DataFrames from ROOT to R ;  CBinding;  CTRFunctionExportThis is a class to pass functions from ROOT to R ;  CTRFunctionImportThis is a class to pass functions from ROOT to R ;  ►CTRInterface ;  CBinding;  CTRObjectThis is a class to get ROOT's objects from R's objects ;  ►NTF1Helper;  CTGradientParFunctionFunction class representing the derivative with respect a parameter of a given TF1 ;  ►Nv5;  CTF1Data;  CTFormulaThe FORMULA class (ROOT version 5) ;  CTFormulaPrimitiveThe Formula Primitive class ;  CTOperOffset;  CTExecutorThis class defines an interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTGenericClassInfo;  CTPoolManagerA manager for the scheduler behind ROOT multithreading operations ;  CTProcessExecutorThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTRWSpinLock;  ►CTSchemaRule;  CTSources;  ►CTSeqA pseudo container class which is a generator of indices ;  Citerator;  CTSpinMutexA spin mutex class which respects the STL interface for mutexes ;  CTThreadedObjectA wrapper to make object instances thread private, lazily ;  CTThreadExecutorThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTTreeProcessorMPThis class provides an interface to process a TTree dataset in parallel with multi-process technology ;  CTTreeProcessorMTA class to process the entries of a TTree in parallel ;  ►NROOTwriter;  CROOTwriter;  ►NstdSTL namespace ;  ►N__ROOT;  ►Ntest;  Ctest;  ►NTMath;  CLimits;  ►NTMVAAbstract ClassifierFactory template that handles arbitrary types ;  ►NDNN;  CBatchEncapsulates one mini-batch ;  CClassificationSettingsSettings for clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:67135,simpl,simple,67135,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['simpl'],['simple']
Usability,"thod or function to undo operation. Comments:; if either clname or obj is NULL that means that redo/undo is function; to specify default arguments for redo/undo method/function '=' must precede to argument value. Example: TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");; undo method can be same as redo one. In that case undo parameter can be omitted.; Example: TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. Definition at line 168 of file TQCommand.cxx. ◆ TQCommand() [2/3]. TQCommand::TQCommand ; (; TObject * ; obj, . const char * ; redo = nullptr, . const char * ; undo = nullptr . ). Constructor. ; Input parameters:; obj - an object; redo - method or function to do/redo operation; undo - method or function to undo operation. Comments: to specify default arguments for redo/undo method/function '=' must precede to argument value.; Example: TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");; undo method can be same as redo one. In that case ""undo"" can parameter be omitted.; Example: TQCommand(gPad, ""SetFillStyle(Style_t)"");. Definition at line 199 of file TQCommand.cxx. ◆ TQCommand() [3/3]. TQCommand::TQCommand ; (; const TQCommand & ; com). Copy constructor. ; Definition at line 209 of file TQCommand.cxx. ◆ ~TQCommand(). TQCommand::~TQCommand ; (; ). virtual . dtor. ; Definition at line 249 of file TQCommand.cxx. Member Function Documentation. ◆ Add() [1/2]. void TQCommand::Add ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TList.; Reimplemented in TQUndoManager.; Definition at line 91 of file TQCommand.h. ◆ Add() [2/2]. void TQCommand::Add ; (; TObject * ; obj, . Option_t * ; opt . ). overridevirtual . Add command to the list of merged commands. ; Option string can contain substrings:; ""compress"" - try to compress input command; ""radd"" - execute redo action of input command; ""uadd"" - execute undo action of input command . Reimplemented from TList.; Reimplemented in TQUndoManager.; Definition at line 360 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:33102,undo,undo,33102,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"thod specifies the type of tick marks on the axis. If tx = gPad->GetTickx() and ty = gPad->GetTicky() then: tx = 1; tick marks on top side are drawn (inside); tx = 2; tick marks and labels on top side are drawn; ty = 1; tick marks on right side are drawn (inside); ty = 2; tick marks and labels on right side are drawn; By default only the left Y axis and X bottom axis are drawn (tx = ty = 0); TPad::SetTicks(tx,ty) allows to set these options. See also The TAxis functions to set specific axis attributes.; In case multiple color filled histograms are drawn on the same pad, the fill area may hide the axis tick marks. One can force a redraw of the axis over all the histograms by calling: gPad->RedrawAxis();. Giving titles to the X, Y and Z axis; h->GetXaxis()->SetTitle(""X axis title"");; h->GetYaxis()->SetTitle(""Y axis title"");; The histogram title and the axis titles can be any TLatex string. The titles are part of the persistent histogram. The option ""SAME""; By default, when an histogram is drawn, the current pad is cleared before drawing. In order to keep the previous drawing and draw on top of it the option SAME should be use. The histogram drawn with the option SAME uses the coordinates system available in the current pad.; This option can be used alone or combined with any valid drawing option but some combinations must be use with care.; Limitations. It does not work when combined with the LEGO and SURF options unless the histogram plotted with the option SAME has exactly the same ranges on the X, Y and Z axis as the currently drawn histogram. To superimpose lego plots histograms' stacks should be used. Colors automatically picked in palette; SinceROOT version 6.09/01; When several histograms are painted in the same canvas thanks to the option ""SAME"" or via a THStack it might be useful to have an easy and automatic way to choose their color. The simplest way is to pick colors in the current active color palette. Palette coloring for histogram is activated thanks to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:15897,clear,cleared,15897,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['clear'],['cleared']
Usability,"thod that makes Linux such a success. The essence of that method is: “release early, release often and listen to your customers”. This is precisely how ROOT is being developed. Over the last five years, many of our “customers” became co-developers. Here we would like to thank our main co-developers and contributors:; Masaharu Goto wrote the C++ interpreter CINT that was an essential part of ROOT before ROOT 6. Despite being 8 time zones ahead of us, we have the feeling he has been sitting in the room next door since 1995.; Andrei and Mihaela Gheata (Alice collaboration) are co-authors of the ROOT geometry classes and Virtual Monte-Carlo. They have been working with the ROOT team since 2000.; Olivier Couet, who after a successful development and maintenance of PAW, has joined the ROOT team in 2000 and has been working on the graphics sub-system.; Ilka Antcheva has been working on the Graphical User Interface classes. She is also responsible for this latest edition of the Users Guide with a better style, improved index and several new chapters (since 2002).; Bertrand Bellenot has been developing and maintaining the Win32GDK version of ROOT. Bertrand has also many other contributions like the nice RootShower example (since 2001).; Valeriy Onoutchin has been working on several ROOT packages, in particular the graphics sub-system for Windows and the GUI Builder (since 2000).; Gerri Ganis has been working on the authentication procedures to be used by the root daemons and the PROOF system (since 2002).; Maarten Ballintijn (MIT) is one of the main developers of the PROOF sub-system (since 1995).; Valeri Fine (now at BNL) ported ROOT to Windows and contributed largely to the 3-D graphics. He is currently working on the Qt layer of ROOT (since 1995).; Victor Perevoztchikov (BNL) worked on key elements of the I/O system, in particular the improved support for STL collections (1997-2001).; Nenad Buncic developed the HTML documentation generation system and integrated the X3D v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:3598,Guid,Guide,3598,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Guid'],['Guide']
Usability,"thod with; histograms of dimension >= 2. void Copy(TObject& hnew) const; Copy this histogram structure to newth1. Note that this function does not copy the list of associated functions.; Use TObject::Clone to make a full copy of an histogram. TObject* Clone(const char* newname = 0) const; Make a clone of an object bur for performance we are not using the; Streamer facility for TH1 and derived. Instead we rely on the; (required) implementation of Copy. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the histogram to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a line. Compute the closest distance of approach from point px,py to elements; of an histogram.; The distance is computed in pixels units. Algorithm:; Currently, this simple model computes the distance from the mouse; to the histogram contour only. Bool_t Divide(TF1* f1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. The function return kFALSE if the divide operation failed. Bool_t Divide(const TH1* h1); Divide this histogram by h1. this = this/h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; See the other TH1::Divide that gives the possibility to optionally; compute binomial errors. IMPORTANT NOTE: If you intend to use the errors of this histogram later; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:63326,simpl,simple,63326,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['simpl'],['simple']
Usability,"thod/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero delete every merged command which option string is; equal to ""opt"". If ""opt"" is zero - delete all merged commands. Bool_t CanMerge(TQCommand* c) const; Two commands can be merged if they can be composed into; a single command (Macro command). To allow merging commands user might override this function. void Merge(TQCommand* c); Add command to the list of merged commands.; This make it possible to group complex actions together so an end user; can undo and redo them with one command. Execution of TQUndoManager::Undo(),;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:19249,undo,undo,19249,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,10,['undo'],['undo']
Usability,"tic . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::DecisionTree::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 243 of file DecisionTree.h. ◆ ClassName(). virtual const char * TMVA::DecisionTree::ClassName ; (; ); const. inlinevirtual . Implements TMVA::BinaryTree.; Definition at line 98 of file DecisionTree.h. ◆ CleanTree(). UInt_t TMVA::DecisionTree::CleanTree ; (; DecisionTreeNode * ; node = nullptr). remove those last splits that result in two leaf nodes that are both of the type (i.e. ; both signal or both background) this of course is only a reasonable thing to do when you use ""YesOrNo"" leafs, while it might loose s.th. if you use the purity information in the nodes. --> hence I don't call it automatically in the tree building ; Definition at line 937 of file DecisionTree.cxx. ◆ ClearTree(). void TMVA::DecisionTree::ClearTree ; (; ). clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree ; Definition at line 923 of file DecisionTree.cxx. ◆ CountLeafNodes(). UInt_t TMVA::DecisionTree::CountLeafNodes ; (; TMVA::Node * ; n = nullptr). return the number of terminal nodes in the sub-tree below Node n ; Definition at line 1131 of file DecisionTree.cxx. ◆ CreateFromXML(). TMVA::DecisionTree * TMVA::DecisionTree::CreateFromXML ; (; void * ; node, . UInt_t ; tmva_Version_Code = 262657 . ). static . re-create a new tree (decision tree or search tree) from XML ; Definition at line 281 of file DecisionTree.cxx. ◆ CreateNode(). virtual DecisionTreeNode * TMVA::DecisionTree::CreateNode ; (; UInt_t ; ); const. inlinevirtual . Implements TMVA::BinaryTree.; Definition at line 95 of file DecisionTree.h. ◆ CreateTree(). virtual BinaryTree * TMVA::DecisionTree::CreateTree ; (; ); const. inlinevirtual . Implements TMVA::BinaryTree.; Definition at line 96 of file DecisionTree.h. ◆ DeclFileName(). static const char * TMVA::DecisionTree::DeclFileName ; (; ). inlinestatic . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html:17684,clear,clear,17684,doc/master/classTMVA_1_1DecisionTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html,1,['clear'],['clear']
Usability,"tic . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TProofPlayer::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 228 of file TProofPlayer.h. ◆ ClearInput(). void TProofPlayer::ClearInput ; (; ). overridevirtual . Clear input list. ; Implements TVirtualProofPlayer.; Definition at line 468 of file TProofPlayer.cxx. ◆ CreateDrawFeedback(). TDrawFeedback * TProofPlayer::CreateDrawFeedback ; (; TProof * ; p). overridevirtual . Draw feedback creation proxy. ; When accessed via TProof avoids link dependency on libProofPlayer. ; Implements TVirtualProofPlayer.; Definition at line 733 of file TProofPlayer.cxx. ◆ DeclFileName(). static const char * TProofPlayer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 228 of file TProofPlayer.h. ◆ DeleteDrawFeedback(). void TProofPlayer::DeleteDrawFeedback ; (; TDrawFeedback * ; f). overridevirtual . Delete draw feedback object. ; Implements TVirtualProofPlayer.; Definition at line 750 of file TProofPlayer.cxx. ◆ DrawCanvas(). Int_t TProofPlayer::DrawCanvas ; (; TObject * ; obj). protectedvirtual . Draw the object if it is a canvas. ; Return 0 in case of success, 1 if it is not a canvas or libProofDraw is not available. ; Definition at line 1696 of file TProofPlayer.cxx. ◆ DrawSelect(). Long64_t TProofPlayer::DrawSelect ; (; TDSet * ; set, . const char * ; varexp, . const char * ; selection, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; firstentry = 0 . ). overridevirtual . Draw (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 1658 of file TProofPlayer.cxx. ◆ Feedback(). void TProofPlayer::Feedback ; (; TList * ; objs). overridevirtual . Set feedback list (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 724 of file TProofPl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:27578,feedback,feedback,27578,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['feedback'],['feedback']
Usability,"tic Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedPdf.html:42308,clear,clearCacheObject,42308,root/html528/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedPdf.html,2,['clear'],['clearCacheObject']
Usability,"tic Bool_tTH1::AddDirectoryStatus(); voidAddTH3(const TH3* hist, TGLTH3Composition::ETH3BinShape shape = kBox); voidTArrayC::Adopt(Int_t n, Char_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Char_tTArrayC::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH3::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidTH3C::Copy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; virtual TH1*TH1::DrawNor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLTH3Composition.html:1830,Clear,ClearUnderflowAndOverflow,1830,root/html602/TGLTH3Composition.html,https://root.cern,https://root.cern/root/html602/TGLTH3Composition.html,2,['Clear'],['ClearUnderflowAndOverflow']
Usability,"tic Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedSelect(const TGWindow* p, Int_t id); Create pattern select button. ~TGedSelect(); Destructor of pattern select button. Bool_t HandleButton(Event_t* event); Handle mouse button events in pattern select button. void Enable(); Set widget state flag (kTRUE=enabled, kFALSE=disabled). void Disable(); Clear widget state flag. void DoRedraw(); Draw separator and arrow. void DrawTriangle(GContext_t gc, Int_t x, Int_t y); Draw small triangle. void SetPopup(TGedPopup* p); { fPopup = p; }. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGedPatternSelect.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGedSelect.html:23437,Clear,Clear,23437,root/html532/TGedSelect.html,https://root.cern,https://root.cern/root/html532/TGedSelect.html,1,['Clear'],['Clear']
Usability,"tic Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; bool canBeAdded (RooAbsArg const &, bool) const override;  Determine whether it's possible to add a given RooAbsArg to the collection or not. ;  ;  Protected Member Functions inherited from RooAbsCollection; void clearStructureTags ();  ; void deleteList ();  Delete contents of the list. ;  ; void makeStructureTag ();  ; void makeTypedStructureTag ();  ; TNamed * structureTag ();  ; TNamed * typedStructureTag ();  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; template<class Arg_t > ; void processArg (Arg_t &&arg);  ; void processArg (const char *name);  ; void processArg (const RooAbsArg &arg);  ; void processArg (const RooAbsArg *arg);  ; void processArg (double value);  ; void processArg (RooAbsArg *arg);  ; template<typename... Args_t> ; void processArgs (Args_t &&... args);  . Additional Inherited Members;  Public Types inherited from RooAbsCollection; using const_iterator = Storage_t::const_iterator;  ; using Storage_t = std::vector< RooAbsArg * >;  ;  Public Types inherited from TObject; enum  { ;   k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooArgList.html:24749,clear,clearStructureTags,24749,doc/master/classRooArgList.html,https://root.cern,https://root.cern/doc/master/classRooArgList.html,1,['clear'],['clearStructureTags']
Usability,"tic TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfNRargsnumber of redo arguments; Int_tfNUargsnumber of undo arguments; TStringfNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tfNewDeletekTRUE if Redo/Undo methods are new/delete; void*fObjectobject to which undo/redo actions applied; TQConnection*fRedodo/redo action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQCommand. ←. TQUndoManager. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:17857,undo,undo,17857,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,12,"['Undo', 'undo']","['Undo', 'undo', 'undoing']"
Usability,"tic const TString gClr_whiteonblue = ""\033[1;44m""; // white on blue background; 849 static const TString gClr_whiteongreen = ""\033[1;42m""; // white on green background; 850 static const TString gClr_grey_bg = ""\033[47m""; // grey background; 851 ; 852 static const TString gClr_reset = ""\033[0m""; // reset; 853 ; 854 if (!gConfig().UseColor()) return gClr_none;; 855 ; 856 if (c == ""white"" ) return gClr_white;; 857 if (c == ""blue"" ) return gClr_blue;; 858 if (c == ""black"" ) return gClr_black;; 859 if (c == ""lightblue"") return gClr_cyan_b;; 860 if (c == ""yellow"") return gClr_yellow;; 861 if (c == ""red"" ) return gClr_red;; 862 if (c == ""dred"" ) return gClr_darkred;; 863 if (c == ""dgreen"") return gClr_darkgreen;; 864 if (c == ""lgreenb"") return gClr_lgreen_b;; 865 if (c == ""dyellow"") return gClr_darkyellow;; 866 ; 867 if (c == ""bold"") return gClr_bold;; 868 if (c == ""bblack"") return gClr_black_b;; 869 ; 870 if (c == ""blue_bgd"") return gClr_blue_bg;; 871 if (c == ""red_bgd"" ) return gClr_red_bg;; 872 ; 873 if (c == ""white_on_blue"" ) return gClr_whiteonblue;; 874 if (c == ""white_on_green"") return gClr_whiteongreen;; 875 ; 876 if (c == ""reset"") return gClr_reset;; 877 ; 878 std::cout << ""Unknown color "" << c << std::endl;; 879 exit(1);; 880 ; 881 return gClr_none;; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// formatted output of simple table; 886 ; 887void TMVA::Tools::FormattedOutput( const std::vector<Double_t>& values, const std::vector<TString>& V,; 888 const TString titleVars, const TString titleValues, MsgLogger& logger,; 889 TString format ); 890{; 891 // sanity check; 892 UInt_t nvar = V.size();; 893 if ((UInt_t)values.size() != nvar) {; 894 logger << kFATAL << ""<FormattedOutput> fatal error with dimensions: ""; 895 << values.size() << "" OR "" << "" != "" << nvar << Endl;; 896 }; 897 ; 898 // find maximum length in V (and column title); 899 UInt_t maxL = 7;; 900 std::vector<UInt_t> vLengths;; 901 for (UInt_t ivar=0; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:30625,simpl,simple,30625,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,1,['simpl'],['simple']
Usability,tic const char * TWebPainting::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TWebPainting::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 59 of file TWebPainting.h. ◆ DeclFileName(). static const char * TWebPainting::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 59 of file TWebPainting.h. ◆ FixSize(). void TWebPainting::FixSize ; (; ). inline . Definition at line 54 of file TWebPainting.h. ◆ IsA(). TClass * TWebPainting::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 59 of file TWebPainting.h. ◆ IsEmpty(). Bool_t TWebPainting::IsEmpty ; (; ); const. inline . Definition at line 40 of file TWebPainting.h. ◆ MakeTextOper(). std::string TWebPainting::MakeTextOper ; (; const char * ; str). static . Create text operation If text include special symbols - use simple hex coding. ; Definition at line 64 of file TWebPainting.cxx. ◆ Reserve(). Float_t * TWebPainting::Reserve ; (; Int_t ; sz). Reserve place in the float buffer Returns pointer on first element in reserved area. ; Definition at line 94 of file TWebPainting.cxx. ◆ Streamer(). void TWebPainting::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TWebPainting::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 59 of file TWebPainting.h. Member Data Documentation. ◆ fBuf. TArrayF TWebPainting::fBuf. protected . array of points for all operations ; Definition at line 30 of file TWebPainting.h. ◆ fLastFill. TAttFill TWebPainting::fLastFill. protected . ! last fill attributes ; Definition at line 32 of file TWebPainting.h. ◆ fLastLine. TAttLine TWebPainting::fLastLine. protected . ! last line attributes ; Definition at line 31 of file T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebPainting.html:14809,simpl,simple,14809,doc/master/classTWebPainting.html,https://root.cern,https://root.cern/doc/master/classTWebPainting.html,1,['simpl'],['simple']
Usability,"tic constexpr Version_t Class_Version ();  ; static Bool_t Connect (const char *sender_class, const char *signal, const char *receiver_class, void *receiver, const char *slot);  This method allows to make a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; void SetupFeedback () override;  Set up feedback (may not be used in this class). ;  ; void StopFeedback () override;  Stop feedback (may not be used in this class). ;  ;  Protected Member Functions inherited from TProofPlayer; Int_t AssertSelector (const char *selector_file);  Make sure that a valid selector object Return -1 in case of problems, 0 otherwise. ;  ; Bool_t CheckMemUsage (Long64_t &mfreq, Bool_t &w80r, Bool_t &w80v, TString &wmsg);  Check the memory usage, if requested. ;  ; virtual Int_t DrawCanvas (TObject *obj);  Draw the object if it is a canvas. ;  ; void * GetSender () override;  ; void MapOutputListToDataMembers () const;  ; void MergeOutput (Bool_t savememvalues=kFALSE) override;  Merge output (may not be used in this class). ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual const char * GetSenderClassName () const;  . Private Attributes; Bool_t fIsClient;  . Ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLocal.html:19389,feedback,feedback,19389,doc/master/classTProofPlayerLocal.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLocal.html,1,['feedback'],['feedback']
Usability,"tic that returns maximum likelihood estimate of a specified parameter. More...;  ; class  MCMCCalculator;  Bayesian Calculator estimating an interval or a credible region using the Markov-Chain Monte Carlo method to integrate the likelihood function with the prior to obtain the posterior function. More...;  ; class  MCMCInterval;  MCMCInterval is a concrete implementation of the RooStats::ConfInterval interface. More...;  ; class  MCMCIntervalPlot;  This class provides simple and straightforward utilities to plot a MCMCInterval object. More...;  ; class  MetropolisHastings;  This class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo. More...;  ; class  MinNLLTestStat;  MinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic. More...;  ; class  ModelConfig;  ModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools. More...;  ; class  NeymanConstruction;  NeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction. More...;  ; class  NuisanceParametersSampler;  Helper class for ToyMCSampler. More...;  ; class  NumberCountingPdfFactory;  A factory for building PDFs and data for a number counting combination. More...;  ; class  NumEventsTestStat;  NumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting. More...;  ; class  PdfProposal;  PdfProposal is a concrete implementation of the ProposalFunction interface. More...;  ; class  PointSetInterval;  PointSetInterval is a concrete implementation of the ConfInterval interface. More...;  ; class  PosteriorCdfFunction;  ; class  PosteriorFunction;  ; class  PosteriorFunctionFromToyMC;  Posterior function obtaining sampling toy MC for the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooStats.html:4946,simpl,simple,4946,doc/master/namespaceRooStats.html,https://root.cern,https://root.cern/doc/master/namespaceRooStats.html,1,['simpl'],['simple']
Usability,"ticalFrame Composite frame with vertical child layout; TGVerticalLayout Vertical layout manager; TGView View widget base class; TGViewFrame Frame containing the actual text; TGViewPort Viewport through which to look at a container frame; TGWidget Widget base class; TGWindow GUI Window base class; TGX11 Interface to X11; TGX11TTF Interface to X11 + TTF font handling; TGXYLayout X / Y - layout manager; TGXYLayoutHints Hits for the X / Y - layout manager; TGaxis Graphics axis; TGedEditor ROOT graphics editor; TGedFrame base editor's frame; TGedMarkerPopup marker select popup; TGedMarkerSelect Marker selection button; TGedNameFrame frame showing the selected object name; TGedPatternFrame pattern frame; TGedPatternPopup Color selector popup; TGedPatternSelect pattern selection check-button; TGedPatternSelector select pattern frame; TGedPopup popup window; TGedSelect selection check-button; TGenCollectionProxy ; TGenCollectionProxy::Method ; TGenCollectionProxy::Value ; TGenPhaseSpace Simple Phase Space Generator; TGenerator Event generator interface abstract baseclass; TGenericTable Generic array of C-structure (a'la STL vector); TGenericTable::iterator ; TGeoArb8 arbitrary trapezoid with 8 vertices; TGeoAtt class for visibility, activity and optimization attributes for volumes/nodes; TGeoBBox box primitive; TGeoBBoxEditor TGeoBBox editor; TGeoBatemanSol Solution for the Bateman equation; TGeoBoolNode a boolean node; TGeoBranchArray ; TGeoBuilder geometry builder singleton; TGeoCacheState class storing the cache state; TGeoChecker a simple geometry checker; TGeoCombiTrans rotation + translation; TGeoCombiTransEditor TGeoCombiTrans editor; TGeoCompositeShape boolean composite shape; TGeoCone conical tube class; TGeoConeEditor TGeoCone editor; TGeoConeSeg conical tube segment class; TGeoConeSegEditor TGeoConeSeg editor; TGeoCtub cut tube segment class; TGeoCtubEditor TGeoCtub editor; TGeoDecayChannel Decay channel for Elements; TGeoElemIter Iterator for radionuclide chains.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:86931,simpl,simple,86931,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,4,['simpl'],['simple']
Usability,"ticalFrame*fVworkersVertical frame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display logs. 'grep' is set to kTRUE if it is invoked by pressing the; 'Filter' button. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void SetGrepView(); Sets the view of grep filters according to the value of checkboxes. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild the log info for a new entered session. void SetUrl(const char* url); slots. { fSessionUrl = url; }. » Author: G Ganis, Aug 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: c52dc6cb225c25e34d388329d41570a484d98ce0 $ » Last generated: 2015-03-14 16:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofProgressLog.html:24890,clear,clear,24890,root/html534/TProofProgressLog.html,https://root.cern,https://root.cern/root/html534/TProofProgressLog.html,2,['clear'],['clear']
Usability,"ticalIntegral (Int_t code, const char *rangeName=nullptr) const override;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; std::string buildCallToAnalyticIntegral (Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines the analytical integral translation for the class. ;  ; TObject * clone (const char *newname) const override;  ; RooAbsReal const & coefficient () const;  Get the coefficient ""c"". ;  ; Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const override;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; TClass * IsA () const override;  ; bool negateCoefficient () const;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ; RooAbsReal const & variable () const;  Get the x variable. ;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExponential.html:1985,simpl,simple,1985,doc/master/classRooExponential.html,https://root.cern,https://root.cern/doc/master/classRooExponential.html,1,['simpl'],['simple']
Usability,"ticalIntegralWN(Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Definition RooAbsReal.cxx:380; RooAbsReal::getUnitconst Text_t * getUnit() constDefinition RooAbsReal.h:143; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAbsReal::printEvalErrorsstatic void printEvalErrors(std::ostream &os=std::cout, Int_t maxPerNode=10000000)Print all outstanding logged evaluation error on the given ostream.Definition RooAbsReal.cxx:3582; RooAbsReal::createIntRIRooFit::OwningPtr< RooAbsReal > createIntRI(const RooArgSet &iset, const RooArgSet &nset={})Utility function for createRunningIntegral.Definition RooAbsReal.cxx:3827; RooAbsReal::enableOffsettingvirtual void enableOffsetting(bool)Definition RooAbsReal.cxx:4484; RooAbsReal::clearEvalErrorLogstatic void clearEvalErrorLog()Clear the stack of evaluation error messages.Definition RooAbsReal.cxx:3542; RooAbsReal::createIntObjRooFit::OwningPtr< RooAbsReal > createIntObj(const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) constInternal utility function for createIntegral() that creates the actual integral object.Definition RooAbsReal.cxx:590; RooAbsReal::functorRooFunctor * functor(const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) constReturn a RooFunctor object bound to this RooAbsReal with given definition of observables and paramete...Definition RooAbsReal.cxx:3887; RooAbsReal::createPlotProjectionconst RooAbsReal * createPlotProjection(const RooArgSet &depVars, const RooArgSet &projVars, RooArgSet *&cloneSet) constUtility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a Roo...Definition RooAbsReal.cxx:787; RooAbsReal::plotSamplingHintvirtual std::list< double > * p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:232121,clear,clearEvalErrorLogstatic,232121,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,2,['clear'],"['clearEvalErrorLog', 'clearEvalErrorLogstatic']"
Usability,"tick marks and labels on top side are drawn; 395 ty = 1; tick marks on right side are drawn (inside); 396 ty = 2; tick marks and labels on right side are drawn; 397 ; 398By default only the left Y axis and X bottom axis are drawn; 399(`tx = ty = 0`); 400 ; 401`TPad::SetTicks(tx,ty)` allows to set these options.; 402See also The `TAxis` functions to set specific axis attributes.; 403 ; 404In case multiple color filled histograms are drawn on the same pad, the fill; 405area may hide the axis tick marks. One can force a redraw of the axis over all; 406the histograms by calling:; 407 ; 408 gPad->RedrawAxis();; 409 ; 410 ; 411\anchor HP05; 412### Giving titles to the X, Y and Z axis; 413 ; 414 ; 415 h->GetXaxis()->SetTitle(""X axis title"");; 416 h->GetYaxis()->SetTitle(""Y axis title"");; 417 ; 418The histogram title and the axis titles can be any `TLatex` string.; 419The titles are part of the persistent histogram.; 420 ; 421 ; 422\anchor HP060; 423### The option ""SAME""; 424 ; 425 ; 426By default, when an histogram is drawn, the current pad is cleared before; 427drawing. In order to keep the previous drawing and draw on top of it the; 428option `SAME` should be use. The histogram drawn with the option; 429`SAME` uses the coordinates system available in the current pad.; 430 ; 431This option can be used alone or combined with any valid drawing option but; 432some combinations must be use with care.; 433 ; 434\anchor HP060a; 435#### Limitations; 436 ; 437- It does not work when combined with the `LEGO` and `SURF` options unless the; 438 histogram plotted with the option `SAME` has exactly the same; 439 ranges on the X, Y and Z axis as the currently drawn histogram. To superimpose; 440 lego plots [histograms' stacks](\ref HP26) should be used.; 441 ; 442 ; 443\anchor HP061; 444### Colors automatically picked in palette; 445 ; 446\since **ROOT version 6.09/01**; 447 ; 448When several histograms are painted in the same canvas thanks to the option ""SAME""; 449or via a `THStack` it",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:21147,clear,cleared,21147,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['clear'],['cleared']
Usability,"ticlass;; 195 else if (analysisType == ""auto""); 196 fAnalysisType = Types::kNoAnalysisType;; 197 ; 198 // Greetings();; 199}; 200 ; 201////////////////////////////////////////////////////////////////////////////////; 202/// Constructor.; 203 ; 204TMVA::Factory::Factory(TString jobName, TString theOption); 205 : Configurable(theOption), fTransformations(""I""), fVerbose(kFALSE), fCorrelations(kFALSE), fROC(kTRUE),; 206 fSilentFile(kTRUE), fJobName(jobName), fAnalysisType(Types::kClassification), fModelPersistence(kTRUE); 207{; 208 fName = ""Factory"";; 209 fgTargetFile = nullptr;; 210 fLogger->SetSource(fName.Data());; 211 ; 212 // render silent; 213 if (gTools().CheckForSilentOption(GetOptions())); 214 Log().InhibitOutput(); // make sure is silent if wanted to; 215 ; 216 // init configurable; 217 SetConfigDescription(""Configuration options for Factory running"");; 218 SetConfigName(GetName());; 219 ; 220 // histograms are not automatically associated with the current; 221 // directory and hence don't go out of scope when closing the file; 222 TH1::AddDirectory(kFALSE);; 223 Bool_t silent = kFALSE;; 224#ifdef WIN32; 225 // under Windows, switch progress bar and color off by default, as the typical windows shell doesn't handle these; 226 // (would need different sequences..); 227 Bool_t color = kFALSE;; 228 Bool_t drawProgressBar = kFALSE;; 229#else; 230 Bool_t color = !gROOT->IsBatch();; 231 Bool_t drawProgressBar = kTRUE;; 232#endif; 233 DeclareOptionRef(fVerbose, ""V"", ""Verbose flag"");; 234 DeclareOptionRef(fVerboseLevel = TString(""Info""), ""VerboseLevel"", ""VerboseLevel (Debug/Verbose/Info)"");; 235 AddPreDefVal(TString(""Debug""));; 236 AddPreDefVal(TString(""Verbose""));; 237 AddPreDefVal(TString(""Info""));; 238 DeclareOptionRef(color, ""Color"", ""Flag for coloured screen output (default: True, if in batch mode: False)"");; 239 DeclareOptionRef(; 240 fTransformations, ""Transformations"",; 241 ""List of transformations to test; formatting example: \""Transformations=I;D;P;U;G,D\"", f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:8860,progress bar,progress bar,8860,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,"tils;  ; namespace  TypeTraits;  ROOT type_traits extensions. ;  ; namespace  v5;  ; namespace  VecOps;  . Classes; struct  RCompressionSetting;  The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. More...;  ; class  RDataFrame;  ROOT's RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV's and other data formats. More...;  ; class  ROpaqueTaskArena;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TGenericClassInfo;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel threads, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parallel. Mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:2222,simpl,simple,2222,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['simpl'],['simple']
Usability,"time, the random population created by the constructor is still not evaluated, .. therefore we wait for the second time init is called. ; Definition at line 101 of file GeneticAlgorithm.cxx. ◆ IsA(). virtual TClass * TMVA::GeneticAlgorithm::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 104 of file GeneticAlgorithm.h. ◆ Log(). MsgLogger & TMVA::GeneticAlgorithm::Log ; (; ); const. inlineprotected . message logger ; Definition at line 102 of file GeneticAlgorithm.h. ◆ NewFitness(). Double_t TMVA::GeneticAlgorithm::NewFitness ; (; Double_t ; oldValue, . Double_t ; newValue . ). virtual . if the ""fitnessFunction"" is called multiple times for one set of factors (because i.e. ; each event of a TTree has to be assessed with each set of Factors proposed by the Genetic Algorithm) the value of the current calculation has to be added(? or else) to the value obtained up to now. example: some chi-square is calculated for every event, after every event the new chi-square (newValue) has to be simply added to the oldValue.; this function has to be overridden eventually it might contain only the following return statement. return oldValue + newValue; ; Definition at line 123 of file GeneticAlgorithm.cxx. ◆ SetMakeCopies(). void TMVA::GeneticAlgorithm::SetMakeCopies ; (; Bool_t ; s). inline . Definition at line 72 of file GeneticAlgorithm.h. ◆ SetSpread(). void TMVA::GeneticAlgorithm::SetSpread ; (; Double_t ; s). inline . Definition at line 70 of file GeneticAlgorithm.h. ◆ SpreadControl(). Double_t TMVA::GeneticAlgorithm::SpreadControl ; (; Int_t ; ofSteps, . Int_t ; successSteps, . Double_t ; factor . ). virtual . this function provides the ability to change the stepSize of a mutation according to the success of the last generations. ; Parameters:. int ofSteps : = if OF the number of STEPS given in this variable (ofSteps); int successSteps : >sucessSteps Generations could improve the result; double factor : than multiply the stepSiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1GeneticAlgorithm.html:6847,simpl,simply,6847,doc/master/classTMVA_1_1GeneticAlgorithm.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1GeneticAlgorithm.html,1,['simpl'],['simply']
Usability,"ting and minimisation messages; auto &msgSv = RooMsgService::instance();; msgSv.getStream(1).removeTopic(RooFit::Minimization);; msgSv.getStream(1).removeTopic(RooFit::Fitting);; ; std::cout << ""Running "" << ntoys * 3 << "" toy fits ..."" << std::endl;; ; // M a i n l o o p : r u n p s e u d o e x p e r i m e n t s; //----------------------------------------------------------------; for (std::size_t i = 0; i < ntoys; i++) {; // S e t u p p a r a m e t e r s a n d P D F; //-----------------------------------------------; // angle theta and the weight to account for the acceptance effect; RooRealVar costheta(""costheta"", ""costheta"", -1.0, 1.0);; RooRealVar weight(""weight"", ""weight"", 0.0, 1000.0);; ; // initialise parameters to fit; RooRealVar c0(""c0"", ""0th-order coefficient"", c0gen, -1.0, 1.0);; RooRealVar c1(""c1"", ""1st-order coefficient"", c1gen, -1.0, 1.0);; c0.setError(0.01);; c1.setError(0.01);; // create simple second-order polynomial as probability density function; RooPolynomial pol(""pol"", ""pol"", costheta, {c0, c1}, 1);; ; double ngen = nstats;; if (acceptancemodel == 1); ngen *= 2.0 / (23.0 / 15.0);; else; ngen *= 2.0 / (16.0 / 15.0);; RooRealVar ntot(""ntot"", ""ntot"", ngen, 0.0, 2.0 * ngen);; RooExtendPdf extended(""extended"", ""extended pdf"", pol, ntot);; int npoisson = rnd->Poisson(nstats);; ; // G e n e r a t e d a t a s e t f o r p s e u d o e x p e r i m e n t i; //-------------------------------------------------------------------------------; RooDataSet data(""data"", ""data"", {costheta, weight}, WeightVar(""weight""));; // generate nstats events; for (std::size_t j = 0; j < npoisson; j++) {; bool finished = false;; // use simple accept/reject for generation; while (!finished) {; costheta = 2.0 * rnd->Rndm() - 1.0;; // efficiency for the specific value of cos(theta); double eff = 1.0;; if (acceptancemodel == 1); eff = 1.0 - 0.7 * costheta.getVal() * costheta.getVal();; else; eff = 0.3 + 0.7 * costheta.getVal() * costheta.getVal();; // use 1/eff as weight to account ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf611__weightedfits_8C.html:6496,simpl,simple,6496,doc/master/rf611__weightedfits_8C.html,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html,1,['simpl'],['simple']
Usability,"ting of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example explains how to use the cross-validation feature of TMVA ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algrorithm ;  TMVARegression.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVARegressionApplication.C This macro provides a simple example on how to use the trained regression MVAs within an analysis module ;  ► tree;  basic.C Read data from an ascii file and create a root file with an histogram and an ntuple ;  basic2.C Create can ntuple reading data from an ascii file ;  bill.C Benchmark comparing row-wise and column-wise storage performance ;  cernbuild.C Read data (CERN staff) from an ascii file and create a root file with a Tree ;  cernstaff.C Playing",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:153955,simpl,simple,153955,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,3,['simpl'],['simple']
Usability,"tinline; checkObservables(const RooArgSet *nset) constRooAbsArgvirtual; chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})RooAbsRealvirtual; chi2FitTo(RooDataHist &data, const RooLinkedList &cmdList)RooAbsRealvirtual; chi2FitTo(RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})RooAbsRealvirtual; chi2FitTo(RooDataSet &xydata, const RooLinkedList &cmdList)RooAbsRealvirtual; Class()RooAbsPdfstatic; Class_Name()RooAbsPdfstatic; Class_Version()RooAbsPdfinlinestatic; ClassName() constTObjectvirtual; cleanBranchName() constRooAbsArgprotected; Clear(Option_t *option="""") overrideTNamedvirtual; clearEvalErrorLog()RooAbsRealstatic; clearShapeDirty() constRooAbsArginlineprotected; clearValueAndShapeDirty() constRooAbsArginlineprotected; clearValueDirty() constRooAbsArginlineprotected; clients() constRooAbsArginline; Clone(const char *newname=nullptr) const overrideRooAbsArginlinevirtual; clone(const char *newname=nullptr) const =0RooAbsArgpure virtual; cloneTree(const char *newname=nullptr) constRooAbsArgvirtual; CollectErrors enum valueRooAbsReal; Compare(const TObject *other) const overrideRooAbsArgvirtual; compileForNormSet(RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const overrideRooAbsPdfvirtual; ConfigChange enum valueRooAbsArg; constRooAbsArg; constRooAbsArg; ConstOpCode enum nameRooAbsArg; constOptimizeTestStatistic(ConstOpCode opcode, bool doAlsoTrackingOpt=true)RooAbsArgvirtual; ContentsOption enum nameRooPrintable; Copy(TObject &named) const overrideTNamedvirtual; copyCache(const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) overrideRooAbsRealprotectedvirtual; CountErrors en",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf-members.html:6015,clear,clearShapeDirty,6015,doc/master/classRooAbsPdf-members.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf-members.html,1,['clear'],['clearShapeDirty']
Usability,"tioPlot Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Private Types |; Private Member Functions |; List of all members ; TRatioPlot Class ReferenceGraphics » 2D Graphics » Graphics pad. ; Class for displaying ratios, differences and fit residuals. ; TRatioPlot has two constructors, one which accepts two histograms, and is responsible for setting up the calculation of ratios and differences. This calculation is in part delegated to TEfficiency. A single option can be given as a parameter, that is used to determine which procedure is chosen. The remaining option string is then passed through to the calculation, if applicable. The other constructor uses a fitted histogram to calculate the fit residual and plot it with the histogram and the fit function. Ratios and differences; The simplest case is passing two histograms without specifying any options. This defaults to using TGraphAsymmErrors::Divide. The option variable is passed through, as are the parameters c1 and c2, that you can set via TRatioPlot::SetC1 and TRatioPlot::SetC1. If you set the option to divsym the method TH1::Divide will be used instead, also receiving all the parameters.; Using the option diff or diffsig, both histograms will be subtracted, and in the case of diffsig, the difference will be divided by the uncertainty. c1 and c2 will only be used to scale the histograms using TH1::Scale prior to subtraction.; Available options are for option: . Option Description . divsym uses the histogram TH1::Divide method, yields symmetric errors . diff subtracts the histograms . diffsig subtracts the histograms and divides by the uncertainty . ; void ratioplot1() {; gStyle->SetOptStat(0);; auto C = new TCanvas(""C"", ""A ratio example"");; auto h1 = new TH1D(""h1"", ""TRatioPlot Example; x; y"", 50, 0, 10);; auto h2 = new TH1D(""h2"",",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRatioPlot.html:990,simpl,simplest,990,doc/master/classTRatioPlot.html,https://root.cern,https://root.cern/doc/master/classTRatioPlot.html,1,['simpl'],['simplest']
Usability,"tion GeneralLayer.h:521; TMVA::DNN::VGeneralLayer::GetActivationGradientsAtMatrix_t GetActivationGradientsAt(size_t i)Definition GeneralLayer.h:205; TMVA::DNN::VGeneralLayer::GetWeightGradientsstd::vector< Matrix_t > & GetWeightGradients()Definition GeneralLayer.h:185; TMVA::DNN::VGeneralLayer::GetActivationGradientsconst Tensor_t & GetActivationGradients() constDefinition GeneralLayer.h:199; TMVA::DNN::VGeneralLayer::fInputHeightsize_t fInputHeightThe height of the previous layer or input.Definition GeneralLayer.h:62; TMVA::DNN::VGeneralLayer::fDepthsize_t fDepthThe depth of the layer.Definition GeneralLayer.h:65; TMVA::DNN::VGeneralLayer::Backwardvirtual void Backward(Tensor_t &gradients_backward, const Tensor_t &activations_backward)=0Backpropagates the error.; TMVA::DNN::VGeneralLayer::CopyBiasesvoid CopyBiases(const std::vector< Matrix_t > &otherBiases)Copies the biases provided as an input.Definition GeneralLayer.h:468; TMVA::DNN::VGeneralLayer::Updatevoid Update(const Scalar_t learningRate)Updates the weights and biases, given the learning rate.Definition GeneralLayer.h:410; TMVA::DNN::VGeneralLayer::GetBiasesAtconst Matrix_t & GetBiasesAt(size_t i) constDefinition GeneralLayer.h:181; TMVA::DNN::VGeneralLayer::ResetTrainingvirtual void ResetTraining()Reset some training flags after a loop on all batches Some layer (e.g.Definition GeneralLayer.h:121; TMVA::DNN::VGeneralLayer::GetInputHeightsize_t GetInputHeight() constDefinition GeneralLayer.h:165; TMVA::DNN::VGeneralLayer::SetInputWidthvoid SetInputWidth(size_t inputWidth)Definition GeneralLayer.h:220; TMVA::DNN::VGeneralLayer::GetBiasGradientsAtconst Matrix_t & GetBiasGradientsAt(size_t i) constDefinition GeneralLayer.h:193; TMVA::DNN::VGeneralLayer::WriteTensorToXMLvoid WriteTensorToXML(void *node, const char *name, const std::vector< Matrix_t > &tensor)helper functions for XMLDefinition GeneralLayer.h:496; TMVA::DNN::VGeneralLayer::GetBatchSizesize_t GetBatchSize() constGetters.Definition GeneralLayer.h:163",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GeneralLayer_8h_source.html:34813,learn,learningRate,34813,doc/master/GeneralLayer_8h_source.html,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html,2,['learn'],"['learning', 'learningRate']"
Usability,"tion If there are many connections - only same master is allowed.Definition RWebWindow.cxx:310; ROOT::RWebWindow::fConnMutexstd::mutex fConnMutex! mutex used to protect connection listDefinition RWebWindow.hxx:151; ROOT::RWebWindow::fDataCallbackWebWindowDataCallback_t fDataCallback! main callback when data over channel 1 is arrivedDefinition RWebWindow.hxx:158; ROOT::RWebWindow::CheckInactiveConnectionsvoid CheckInactiveConnections()Check if there are connection which are inactive for longer time For instance, batch browser will be ...Definition RWebWindow.cxx:658; ROOT::RWebWindow::fIdunsigned fId! unique identifierDefinition RWebWindow.hxx:141; ROOT::RWebWindow::fHasWindowThrdbool fHasWindowThrd! indicate if special window thread was startedDefinition RWebWindow.hxx:162; ROOT::RWebWindow::fMasterConnsstd::vector< MasterConn > fMasterConns! master connectionsDefinition RWebWindow.hxx:138; ROOT::RWebWindow::SetClearOnClosevoid SetClearOnClose(const std::shared_ptr< void > &handle=nullptr)Set handle which is cleared when last active connection is closed Typically can be used to destroy we...Definition RWebWindow.cxx:1764; ROOT::RWebWindow::StartThreadvoid StartThread()Start special thread which will be used by the window to handle all callbacks One has to be sure,...Definition RWebWindow.cxx:1680; ROOT::RWebWindow::fConnCntunsigned fConnCnt! counter of new connections to assign idsDefinition RWebWindow.hxx:148; ROOT::RWebWindow::fProtocolConnIdunsigned fProtocolConnId! connection id, which is used for writing protocolDefinition RWebWindow.hxx:172; ROOT::RWebWindow::GetWindowConnectionsConnectionsList_t GetWindowConnections(unsigned connid=0, bool only_active=false) constreturns connection list (or all active connections)Definition RWebWindow.cxx:1458; ROOT::RWebWindow::fSendMTbool fSendMT! true is special threads should be used for sending dataDefinition RWebWindow.hxx:145; ROOT::RWebWindow::fCallbacksThrdIdstd::thread::id fCallbacksThrdId! thread id where callbacks ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:23342,clear,cleared,23342,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['clear'],['cleared']
Usability,"tion If there are many connections - only same master is allowed.Definition RWebWindow.cxx:311; ROOT::RWebWindow::fConnMutexstd::mutex fConnMutex! mutex used to protect connection listDefinition RWebWindow.hxx:154; ROOT::RWebWindow::fDataCallbackWebWindowDataCallback_t fDataCallback! main callback when data over channel 1 is arrivedDefinition RWebWindow.hxx:161; ROOT::RWebWindow::CheckInactiveConnectionsvoid CheckInactiveConnections()Check if there are connection which are inactive for longer time For instance, batch browser will be ...Definition RWebWindow.cxx:659; ROOT::RWebWindow::fIdunsigned fId! unique identifierDefinition RWebWindow.hxx:144; ROOT::RWebWindow::fHasWindowThrdbool fHasWindowThrd! indicate if special window thread was startedDefinition RWebWindow.hxx:165; ROOT::RWebWindow::fMasterConnsstd::vector< MasterConn > fMasterConns! master connectionsDefinition RWebWindow.hxx:141; ROOT::RWebWindow::SetClearOnClosevoid SetClearOnClose(const std::shared_ptr< void > &handle=nullptr)Set handle which is cleared when last active connection is closed Typically can be used to destroy we...Definition RWebWindow.cxx:1806; ROOT::RWebWindow::StartThreadvoid StartThread()Start special thread which will be used by the window to handle all callbacks One has to be sure,...Definition RWebWindow.cxx:1722; ROOT::RWebWindow::fConnCntunsigned fConnCnt! counter of new connections to assign idsDefinition RWebWindow.hxx:151; ROOT::RWebWindow::fProtocolConnIdunsigned fProtocolConnId! connection id, which is used for writing protocolDefinition RWebWindow.hxx:175; ROOT::RWebWindow::GetWindowConnectionsConnectionsList_t GetWindowConnections(unsigned connid=0, bool only_active=false) constreturns connection list (or all active connections)Definition RWebWindow.cxx:1500; ROOT::RWebWindow::fSendMTbool fSendMT! true is special threads should be used for sending dataDefinition RWebWindow.hxx:148; ROOT::RWebWindow::fCallbacksThrdIdstd::thread::id fCallbacksThrdId! thread id where callbacks ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:23731,clear,cleared,23731,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['clear'],['cleared']
Usability,"tion TApplication.cxx:1949; TApplication::ProcessLinevirtual Longptr_t ProcessLine(const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr)Process a single command line, either a C++ statement or an interpreter command starting with a ""....Definition TApplication.cxx:1565; TApplication::fgApplicationsstatic TList * fgApplicationsDefinition TApplication.h:82; TApplication::Closestatic void Close(TApplication *app)Static function used to close a remote application.Definition TApplication.cxx:2070; TApplication::HandleTermInputvirtual Bool_t HandleTermInput()Definition TApplication.h:116; TApplication::IsRunningBool_t IsRunning() constDefinition TApplication.h:152; TApplication::SetEchoModevirtual void SetEchoMode(Bool_t mode)Set console echo mode:Definition TApplication.cxx:1968; TApplication::InputFilesTObjArray * InputFiles() constDefinition TApplication.h:146; TApplication::Helpvirtual void Help(const char *line)The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxy...Definition TApplication.cxx:1208; TApplication::LineProcessedvirtual void LineProcessed(const char *line)Emit signal when a line has been processed.Definition TApplication.cxx:1941; TApplication::ClearInputFilesvoid ClearInputFiles()Clear list containing macro files passed as program arguments.Definition TApplication.cxx:318; TApplication::fAppImpTApplicationImp * fAppImpDefinition TApplication.h:60; TApplication::TApplicationTApplication(const TApplication &)=delete; TApplication::EExitOnExceptionEExitOnExceptionDefinition TApplication.h:51; TApplication::kDontExit@ kDontExitDefinition TApplication.h:52; TApplication::kAbort@ kAbortDefinition TApplication.h:54; TApplication::kExit@ kExitDefinition TApplication.h:53; TApplication::ExecuteFilestatic Longptr_t ExecuteFile(const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE)Execute a file containing a C++ macro (static method).Definition TApplication.cxx:1729; TApplication::GetSignalHandlerTSignalH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8h_source.html:11441,guid,guide,11441,doc/master/TApplication_8h_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html,1,['guid'],['guide']
Usability,"tion TGWin32VirtualXProxy.cxx:68; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; gPad#define gPadDefinition TVirtualPad.h:308; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TAttMarker::SetMarkerSizevirtual void SetMarkerSize(Size_t msize=1)Set the marker size.Definition TAttMarker.h:45; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TF11-Dim function classDefinition TF1.h:233; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TSpline3Class to create third splines to interpolate knots Arbitrary conditions can be introduced for first a...Definition TSpline.h:182; TSpline5Class to create quintic natural splines to interpolate knots Arbitrary conditions can be introduced f...Definition TSpline.h:238; TSpline::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TSpline.cxx:101; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TTextBase class for several text objects.Definition TText.h:22; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; AuthorFederico Carminati ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/splines__test_8C.html:4561,simpl,simple,4561,doc/master/splines__test_8C.html,https://root.cern,https://root.cern/doc/master/splines__test_8C.html,1,['simpl'],['simple']
Usability,"tion and Fitting Libraries: libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional function. The current common interface for fitting is class TVirtualFitter and implemented by derived classes in the minimization and fitting libraries. The fitting in ROOT is being re-organized and new fitting classes are present in MathCore for providing the fitting functionality and the use the minimization libraries via a new common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:. Minuit:library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits. Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions. ; Fumili: library providing the implementation of the original Fumili fitting algorithm. Linear algebra. Two libraries are contained in ROOT for describing linear algebra matrices and vector classes:. Matrix: general matrix package providing matrix TMatrix and vector TVector classes and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMatrix: package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:. Physics: l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/MATH_Index.html:2200,Simpl,Simplex,2200,root/html602/MATH_Index.html,https://root.cern,https://root.cern/root/html602/MATH_Index.html,2,['Simpl'],['Simplex']
Usability,"tion at line 249 of file MethodBDT.h. ◆ fRegressionLossFunctionBDTG. LossFunctionBDT* TMVA::MethodBDT::fRegressionLossFunctionBDTG. private . Definition at line 299 of file MethodBDT.h. ◆ fRegressionLossFunctionBDTGS. TString TMVA::MethodBDT::fRegressionLossFunctionBDTGS. private . the option string determining the loss function for BDT regression ; Definition at line 296 of file MethodBDT.h. ◆ fResiduals. std::map< const TMVA::Event*,std::vector<double> > TMVA::MethodBDT::fResiduals. private . individual event residuals for gradient boost ; Definition at line 226 of file MethodBDT.h. ◆ fSepType. SeparationBase* TMVA::MethodBDT::fSepType. private . the separation used in node splitting ; Definition at line 229 of file MethodBDT.h. ◆ fSepTypeS. TString TMVA::MethodBDT::fSepTypeS. private . the separation (option string) used in node splitting ; Definition at line 230 of file MethodBDT.h. ◆ fShrinkage. Double_t TMVA::MethodBDT::fShrinkage. private . learning rate for gradient boost; ; Definition at line 219 of file MethodBDT.h. ◆ fSigToBkgFraction. Double_t TMVA::MethodBDT::fSigToBkgFraction. private . Signal to Background fraction assumed during training. ; Definition at line 214 of file MethodBDT.h. ◆ fSkipNormalization. Bool_t TMVA::MethodBDT::fSkipNormalization. private . true for skipping normalization at initialization of trees ; Definition at line 276 of file MethodBDT.h. ◆ fSubSample. std::vector<const TMVA::Event*> TMVA::MethodBDT::fSubSample. private . subsample for bagged grad boost ; Definition at line 208 of file MethodBDT.h. ◆ fTrainSample. std::vector<const TMVA::Event*>* TMVA::MethodBDT::fTrainSample. private . pointer to sample actually used in training (fEventSample or fSubSample) for example ; Definition at line 209 of file MethodBDT.h. ◆ fTrainWithNegWeights. Bool_t TMVA::MethodBDT::fTrainWithNegWeights. private . yes there are negative event weights and we don't ignore them ; Definition at line 259 of file MethodBDT.h. ◆ fUseExclusiveVars. Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:68885,learn,learning,68885,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['learn'],['learning']
Usability,"tion for a TH1 (called from TH1::Fit) ;  ; TFitResultPtr ROOT::Fit::FitObject (THnBase *s1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range);  fitting function for a THn / THnSparse (called from THnBase::Fit) ;  ; TFitResultPtr ROOT::Fit::FitObject (TMultiGraph *mg, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range);  fitting function for a MultiGraph (called from TMultiGraph::Fit) ;  ; void ROOT::Fit::FitOptionsMake (EFitObjectType type, const char *option, Foption_t &fitOption);  Decode list of options into fitOption. ;  ; bool ROOT::Fit::GetConfidenceIntervals (const TH1 *h1, const ROOT::Fit::FitResult &r, TGraphErrors *gr, double cl=0.95);  compute confidence intervals at level cl for a fitted histogram h1 in a TGraphErrors gr ;  ; void ROOT::Fit::Init2DGaus (const ROOT::Fit::BinData &data, TF1 *f1);  compute initial parameter for 2D gaussian function given the fit data Set the sigma limits for zero top 10* initial rms values Set the initial parameter values in the TF1 ;  ; void ROOT::Fit::InitExpo (const ROOT::Fit::BinData &data, TF1 *f1);  compute initial parameter for an exponential function given the fit data Set the constant and slope assuming a simple exponential going through xmin and xmax of the data set ;  ; void ROOT::Fit::InitGaus (const ROOT::Fit::BinData &data, TF1 *f1);  compute initial parameter for gaussian function given the fit data Set the sigma limits for zero top 10* initial rms values Set the initial parameter values in the TF1 ;  ; TFitResultPtr ROOT::Fit::UnBinFit (ROOT::Fit::UnBinData *data, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption);  fit an unbin data set (from tree or from histogram buffer) using a TF1 pointer and fit options. ;  . histhistincHFitInterface.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitInterface_8h.html:4236,simpl,simple,4236,doc/master/HFitInterface_8h.html,https://root.cern,https://root.cern/doc/master/HFitInterface_8h.html,1,['simpl'],['simple']
Usability,"tion object is added to the histogram and is drawn in the current pad.; 5.1.2 The TGraph::Fit Method; The signature for fitting a TGraph is exactly the same as for the TH1. Only some options apply only for fitting histograms, these are the options “L”, “WL” and “I”. These options apply instead only for TGraph::Fit, the rest of options (appart from “L”, “WL” and “I” are the same). TGraph specific options. “EX0” When fitting a TGraphErrors or a TgraphAsymErrors the errors on the coordinates are not used in the fit; “ROB” in case of linear fitting use the Robust fitting. Compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points.; “ROB=0.x” as above, but compute the LTS regression coefficients, using 0.x as a fraction of good points. 5.2 The TF1 function class; Here we will show how to create the TF1 class that is used for fitting histograms and graphs.; 5.2.1 Fit with a Predefined Function; To fit a histogram with a predefined function, simply pass the name of the function in the first parameter of TH1::Fit. For example, this line fits histogram object hist with a Gaussian.; root[] hist.Fit(""gaus"");; The initial parameter values (and eventual limits) for pre-defined functions are set automatically. For overriding the default limits values use the fit option B.; The list of pre-defined functions that can be used with the Fit method is the following:. “gaus” Gaussian function with 3 parameters: f(x) = p0*exp(-0.5*((x-p1)/p2)^2); “expo”An Exponential with 2 parameters: f(x) = exp(p0+p1*x); “polN” A polynomial of degree N, where N is a number between 0 and 9: f(x) = p0 + p1*x + p2*x2 +...; “chebyshevN” A Chebyshev polynomial of degree N, where N is a number between 0 and 9: f(x) = p0 + p1*x + p2*(2*x2-1) +...; “landau” Landau function with mean and sigma. This function has been adapted from the CERNLIB routine G110 denlan (see TMath::Landau).; “gausn” Normalized form of the gaussian function with 3 parameters f(x) = p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:167441,simpl,simply,167441,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simply']
Usability,"tion of a ConfInterval based on a likelihood ratio; RooStats::LikelihoodIntervalPlot Class containing the results of the IntervalCalculator; RooStats::MCMCCalculator Markov Chain Monte Carlo calculator for Bayesian credible intervals; RooStats::MCMCInterval Concrete implementation of a ConfInterval based on MCMC calculation; RooStats::MCMCIntervalPlot Class containing the results of the MCMCCalculator; RooStats::MarkovChain ; RooStats::MetropolisHastings Markov Chain Monte Carlo calculator for Bayesian credible intervals; RooStats::ModelConfig A class that holds configuration information for a model using a workspace as a store; RooStats::NeymanConstruction Interface for tools setting limits (producing confidence intervals); RooStats::NumEventsTestStat ; RooStats::NumberCountingPdfFactory A factory specific to common number counting problems.; RooStats::NumberCountingUtils ; RooStats::PdfProposal ; RooStats::PointSetInterval Concrete implementation of ConfInterval for simple 1-D intervals in the form [a,b]; RooStats::ProfileLikelihoodCalculator A concrete implementation of CombinedCalculator that uses the ProfileLikelihood ratio.; RooStats::ProfileLikelihoodTestStat implements the profile likelihood ratio as a test statistic to be used with several tools; RooStats::ProposalFunction Interface for the proposal function used with Markov Chain Monte Carlo; RooStats::ProposalHelper ; RooStats::SPlot Class used for making sPlots; RooStats::SamplingDistPlot Class containing the results of the HybridCalculator; RooStats::SamplingDistribution Class containing the results of the HybridCalculator; RooStats::SamplingSummary A summary of acceptance regions for confidence belt; RooStats::SamplingSummaryLookup A simple class used by ConfidenceBelt; RooStats::SimpleInterval Concrete implementation of ConfInterval for simple 1-D intervals in the form [a,b]; RooStats::TestStatSampler Interface for tools setting limits (producing confidence intervals); RooStats::TestStatistic Interface",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:44691,simpl,simple,44691,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['simpl'],['simple']
Usability,"tion of the RooStats::ConfInterval interface ;  CMCMCIntervalPlotThis class provides simple and straightforward utilities to plot a MCMCInterval object ;  CMetropolisHastingsThis class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo ;  CMinNLLTestStatMinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic ;  CModelConfigModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools ;  CNeymanConstructionNeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactory;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspector;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset ;  CProofConfigHolds configuration options for proof and proof-lite ;  CProposalFunctionProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ;  CSamplingDistPlotThis class provides",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:7643,simpl,simple,7643,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['simpl'],['simple']
Usability,"tion options for proof.; RooStats::ProposalFunction Interface for the proposal function used with Markov Chain Monte Carlo; RooStats::ProposalHelper ; RooStats::RatioOfProfiledLikelihoodsTestStat ; RooStats::SPlot Class used for making sPlots; RooStats::SamplingDistPlot Class containing the results of the HybridCalculator; RooStats::SamplingDistribution Class containing the results of the HybridCalculator; RooStats::SamplingSummary A summary of acceptance regions for confidence belt; RooStats::SamplingSummaryLookup A simple class used by ConfidenceBelt; RooStats::SequentialProposal A concrete implementation of ProposalFunction, that uniformly samples the parameter space.; RooStats::SimpleInterval Concrete implementation of ConfInterval for simple 1-D intervals in the form [a,b]; RooStats::SimpleLikelihoodRatioTestStat ; RooStats::TestStatSampler Interface for tools setting limits (producing confidence intervals); RooStats::TestStatistic Interface for a TestStatistic; RooStats::ToyMCSampler A simple implementation of the TestStatSampler interface; RooStats::ToyMCSamplerOld A simple implementation of the TestStatSampler interface; RooStats::ToyMCStudy toy MC study for parallel processing; RooStats::UniformProposal A concrete implementation of ProposalFunction, that uniformly samples the parameter space.; RooStats::UpperLimitMCSModule MCStudy module to calculate upperlimit of a given poi; RooStepFunction Step Function; RooStreamParser Utility class that parses iostream data into tokens; RooStringVar String-valued variable ; RooStudyManager A general purpose workspace oriented parallelizing study manager; RooStudyPackage A general purpose workspace oriented parallelizing study manager; RooSuperCategory Lvalue product operator for catategory lvalues; RooTFnBinding RooAbsReal binding to ROOT TF[123] functions; RooTFnPdfBinding RooAbsPdf binding to ROOT TF[123] functions; RooTFoamBinding Function binding to RooAbsReal object; RooTObjWrap Container class for Int_t; RooTable ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:47685,simpl,simple,47685,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,6,['simpl'],['simple']
Usability,tion tree processing ;  CTMPWorkerTreeSelTemplated derivation of TMPWorkerTree handlign selector tree processing ;  CTMrbSubevent_Caen;  CTMultiDimFitMultidimensional Fits in ROOT ;  CTMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects ;  CTMultiLayerPerceptron;  CTMutex;  CTMutexImp;  CTMySQLResult;  CTMySQLRow;  CTMySQLServer;  ►CTMySQLStatement;  CTParamData;  CTNamedBase class for all named ROOT classes ;  CTNDArray;  CTNDArrayRef;  CTNDArrayT;  CTNetFile;  CTNetFileStager;  CTNetSystem;  CTNetXNGFile;  CTNetXNGFileStager;  CTNetXNGSystem;  CTNeuron;  CTNewChainDlg;  CTNewQueryDlg;  CTNodeTNode description ;  CTNodeDivDescription of parameters to divide a 3-D geometry object ;  CTNonCopyable;  CTNonSplitBrowsableAllows a TBrowser to browse non-split branches as if they were split ;  CTNotifyLinkLinks multiple listeners to be notified on TChain file changes ;  CTNotifyLinkBase;  CTNtupleA simple TTree restricted to a list of float variables only ;  CTNtupleDA simple TTree restricted to a list of double variables only ;  CTObjArrayAn array of TObjects ;  CTObjArrayIterIterator of object array ;  CTObjectMother of all ROOT objects ;  CTObjectRefSpy;  CTObjectSet;  CTObjectSpyMonitors objects for deletion and reflects the deletion by reverting the internal pointer to zero ;  CTObjectTableThis class registers all instances of TObject and its derived classes in a hash table ;  CTObjLinkWrapper around a TObject so it can be stored in a TList ;  CTObjOptLink;  CTObjStringCollectable string class ;  CTOCCToStepThis class contains implementation of writing OpenCascade's geometry shapes to the STEP file reproducing the original ROOT geometry tree ;  CTODBCResult;  CTODBCRow;  CTODBCServer;  ►CTODBCStatement;  CODBCBufferRec_t;  CToolBarData_t;  CTOptionListItem;  CTOracleResult;  CTOracleRow;  CTOracleServer;  ►CTOracleStatement;  CTBufferRec;  CTOrdCollectionOrdered collection ;  CTOrdCollectionIterIterator of ordered collection ;  CTOutputListSelectorD,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:197077,simpl,simple,197077,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['simpl'],['simple']
Usability,"tion& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategoryLValue.html:2301,clear,clearShapeDirty,2301,root/html602/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html,4,['clear'],['clearShapeDirty']
Usability,"tion& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategory.html:2232,clear,clearShapeDirty,2232,root/html602/RooAbsCategory.html,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html,4,['clear'],['clearShapeDirty']
Usability,"tion& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsString.html:2060,clear,clearShapeDirty,2060,root/html602/RooAbsString.html,https://root.cern,https://root.cern/root/html602/RooAbsString.html,4,['clear'],['clearShapeDirty']
Usability,"tion& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOpti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBinningCategory.html:1860,clear,clearShapeDirty,1860,root/html602/RooBinningCategory.html,https://root.cern,https://root.cern/root/html602/RooBinningCategory.html,16,['clear'],['clearShapeDirty']
Usability,"tion& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStringVar.html:1787,clear,clearShapeDirty,1787,root/html602/RooStringVar.html,https://root.cern,https://root.cern/root/html602/RooStringVar.html,4,['clear'],['clearShapeDirty']
Usability,"tion&, Bool_t, Bool_t, Bool_t); voidreset(); Int_tsetObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector&); virtual voidsterilize(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. Int_t_lastIndex! Last slot accessed; Int_t_maxSize! Maximum size; vector<RooNormSetCache>_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_size! Actual use; Bool_t_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCacheManager_RooAbsCacheElement_.html:3563,Clear,Clear,3563,root/html534/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html534/RooCacheManager_RooAbsCacheElement_.html,1,['Clear'],['Clear']
Usability,"tion' pdf; output is pdf(x) (X) resmodel(x) = Int [ pdf(x') resmodel (x-x') ] dx' ; Definition at line 106 of file RooNumConvolution.cxx. ◆ RooNumConvolution() [3/3]. RooNumConvolution::RooNumConvolution ; (; const RooNumConvolution & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 143 of file RooNumConvolution.cxx. ◆ ~RooNumConvolution(). RooNumConvolution::~RooNumConvolution ; (; ). override . Destructor. ; Definition at line 214 of file RooNumConvolution.cxx. Member Function Documentation. ◆ Class(). static TClass * RooNumConvolution::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooNumConvolution::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooNumConvolution::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 97 of file RooNumConvolution.h. ◆ clearConvolutionWindow(). void RooNumConvolution::clearConvolutionWindow ; (; ). Removes previously defined convolution window, reverting to convolution from -inf to +inf. ; Definition at line 274 of file RooNumConvolution.cxx. ◆ clone(). TObject * RooNumConvolution::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 39 of file RooNumConvolution.h. ◆ cloneModel(). RooAbsReal & RooNumConvolution::cloneModel ; (; ); const. inlineprotected . Definition at line 87 of file RooNumConvolution.h. ◆ clonePdf(). RooAbsReal & RooNumConvolution::clonePdf ; (; ); const. inlineprotected . Definition at line 86 of file RooNumConvolution.h. ◆ cloneVar(). RooRealVar & RooNumConvolution::cloneVar ; (; ); const. inlineprotected . Definition at line 85 of file RooNumConvolution.h. ◆ convIntConfig() [1/2]. RooNumIntConfig & RooNumConvolution::convIntConfig ; (; ). inline . Definition at line 44 of file RooNumConvolution.h. ◆ convIntConfig() [2/2]. const RooNumIntConfig & RooNumConvolution::convIntConf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvolution.html:66089,clear,clearConvolutionWindow,66089,doc/master/classRooNumConvolution.html,https://root.cern,https://root.cern/doc/master/classRooNumConvolution.html,1,['clear'],['clearConvolutionWindow']
Usability,"tion. Double_t Boost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); apply the boosting alogrithim (the algorithm is selecte via the the ""option"" given; in the constructor. The return value is the boosting weight. void BoostMonitor(Int_t iTree); fills the ROCIntegral vs Itree from the testSample for the monitoring plots; during the training .. but using the testing events. Double_t AdaBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaBoost implementation.; a new training sample is generated by weighting; events that are misclassified by the decision tree. The weight; applied is w = (1-err)/err or more general:; w = ((1-err)/err)^beta; where err is the fraction of misclassified events in the tree ( <0.5 assuming; demanding the that previous selection was better than random guessing); and ""beta"" being a free parameter (standard: beta = 1) that modifies the; boosting. Double_t AdaCost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaCost boosting algorithm takes a simple cost Matrix (currently fixed for; all events... later could be modified to use individual cost matrices for each; events as in the original paper... true_signal true_bkg. sel_signal | Css Ctb_ss Cxx.. in the range [0,1]; sel_bkg | Cts_sb Cbb. and takes this into account when calculating the misclass. cost (former: error fraction):. err = sum_events ( weight* y_true*y_sel * beta(event). Double_t Bagging(); call it boot-strapping, re-sampling or whatever you like, in the end it is nothing; else but applying ""random"" poisson weights to each event. void GetBaggedSubSample(vector<const TMVA::Event*>& ); fills fEventSample with fBaggedSampleFraction*NEvents random training events. Double_t RegBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); a special boosting only for Regression ...; maybe I'll implement it later... Double_t AdaBoostR2(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); adaption of the AdaBoost to regression problems (see H",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBDT.html:32463,simpl,simple,32463,root/html534/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBDT.html,6,['simpl'],['simple']
Usability,"tion::add(const RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_tRooAbsCollection::add(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual RooAbsArg*RooAbsCollection::addClone(const RooAbsArg& var, Bool_t silent = kFALSE); virtual voidRooAbsCollection::addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual Bool_tRooAbsCollection::addOwned(RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_tRooAbsCollection::addOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Bool_tRooAbsCollection::allInRange(const char* rangeSpec) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsCollection::assignFast(const RooAbsCollection& other, Bool_t setValDirty = kTRUE); RooAbsCollection&RooAbsCollection::assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); RooAbsArg*at(Int_t idx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsCollection::Clone(const char* newname = 0) const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tRooAbsCollection::contains(const RooAbsArg& var) const; Bool_tRooAbsCollection::containsInstance(const RooAbsArg& var) const; stringRooAbsCollection::contentsString() const; virtual voidTObject::Copy(TObject& object) const; virtual TObject*create(const char* newname) const; TIterator*RooAbsCollection::createIterator(Bool_t dir = kIterForward) const; virtual Int_tRooAbsCollection::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooArgList.html:3765,Clear,Clear,3765,root/html534/RooArgList.html,https://root.cern,https://root.cern/root/html534/RooArgList.html,3,['Clear'],['Clear']
Usability,"tion; BayesianCalculator(); default constructor. Need to call the Setter methods afterwards. BayesianCalculator( /* const char* name, const char* title, */ RooAbsData& data, RooAbsPdf& pdf,						 const RooArgSet& POI,						 RooAbsPdf& priorPOI,						 const RooArgSet* nuisanceParameters ); TNamed( TString(name), TString(title) ),; constructor from data set, model pdf, set with the parameter of interest; (must contain only one parameter for the moment) and prior pdf; Optionally an additional set of parameters can be specified (nuisance parameters); which will be integrated (marginalized) when creating the posterior pdf.; A default size of 0.05 is used (for 95% CL interval). BayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); Same constructor but from data and a ModelConfig describing the model pdf and the prior, the parameter; of interest and the nuisance parameters. ~BayesianCalculator(); destructor cleaning all managed objects. void ClearAll() const; clear cached pdf objects (posterior pdf, Likelihood, NLL, etc.). void SetModel(const RooStats::ModelConfig& model); set the model configuration. RooArgSet* GetMode(RooArgSet* parameters) const; return the mode (not yet implemented) but can be easly obtained from; GetPosteriorPdf()->asTF(poi)->GetMaximumX();. RooAbsPdf* GetPosteriorPdf() const; get the posterior pdf as a RooAbsPdf; the posterior is obtained from the product of the likelihood function and the; prior pdf which is then intergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf object; or in the model itself. If no prior nuisance is specified, but prior parameters are then; the integration is performed assuming a flat prior for the nuisance parameters. RooPlot* GetPosteriorPlot() const; return a RooPlot with the posterior PDF and the credibility region. SimpleInterval* GetInterval() const; returns a SimpleInterval with the lower/upper limit on; the scanned variable (the par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__BayesianCalculator.html:8500,clear,clear,8500,root/html526/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__BayesianCalculator.html,1,['clear'],['clear']
Usability,"tion; function members; data members; class charts. ROOT; » CORE; » CONT; » TClonesArray. class TClonesArray: public TObjArray. An array of clone (identical) objects. Memory for the objects; stored in the array is allocated only once in the lifetime of the; clones array. All objects must be of the same class. For the rest; this class has the same properties as TObjArray. To reduce the very large number of new and delete calls in large; loops like this (O(100000) x O(10000) times new/delete):. TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete(); // or a.Clear() or a.Clear(""C""); }. To reduce the number of call to the constructor (especially useful; if the user class requires memory allocation), the object can be; added (and constructed when needed) using ConstructedAt which only; calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);. }. a.Clear(); // or a.Clear(""C"");; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method or the ConstructedAt method.; The other Add() methods ofTObjArray and its base classes are not; allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offers the possibility of allocating and deleting memory.; Forgetting to delete allocated memory is a programming error called a; ""memory leak"",",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:1165,Clear,Clear,1165,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['Clear'],['Clear']
Usability,"tion; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNodeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for node editor. ~TGeoNodeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a editable object. void DoSelectMother(); Select the mother volume. void DoSelectVolume(); Select the volume. void DoSelectMatrix(); Select the matrix. void DoEditMother(); Edit the mother volume. void DoEditVolume(); Edit selected volume. void DoEditMatrix(); Edit selected material. void DoNodeName(); Change node name. void DoNodeNumber(); Change node copy number. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoNodeEditor.html:21850,undo,undoing,21850,root/html534/TGeoNodeEditor.html,https://root.cern,https://root.cern/root/html534/TGeoNodeEditor.html,2,['undo'],['undoing']
Usability,"tions have an extended description, in particular:. TStyle::SetLabelFont; TStyle::SetLineStyleString: set the format of dashed lines.; TStyle::SetOptStat; TStyle::SetPalette to change the colors palette; TStyle::SetTitleOffset; TStyle::SetOptDate(Int_t optdate) to support several date formats. If optdate is non-null, the current date/time will be printed in the canvas. The position of the date string can be controlled by: optdate = 10*format+mode; mode = 1 the date is printed in the bottom/left corner; mode = 2 date is printed in the bottom/right corner; mode = 3 date is printed in the top/right corner; format = 0 (default) date format is like: “Wed Sep 25 17:10:35 2002”; format = 1 date format is: “2002-09-25”; format = 2 date format is: “2002-09-25 17:10:35”. 9.13 3D Viewers; ROOT provides several viewers capable of displaying 3D content:. the Pad - simple line drawing using TPad and associated projection class TView;; GL Viewer - high quality and performance viewer(See “The GL Viewer”);; X3D viewer - simple legacy viewer (See “The X3D Viewer”);; GL-in-pad - combination of basic GL viewer in TPad, with no hardware acceleration. The X3D and GL viewers are created as external windows, associated with a pad, and displaying the same content as it. Only these external viewers are detailed here - for Pad (TPad, TView classes) you should refer to “Graphical Containers: Canvas and Pad” and the class definitions.; All viewers use a common architecture to publish 3D objects to the viewer - described in “Common 3D Viewer Architecture” below. In most cases, you will not need to use this, working instead with a package, such as the “The Geometry Package”, which provides comprehensive, high level functionality to create and place objects into complex 3D scenes, and uses the viewer architecture internally to show the result in your chosen viewer.; 9.13.1 Invoking a 3D viewer; A 3D viewer can be created in a script by passing the appropriate option to Draw()when attaching the dra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:385389,simpl,simple,385389,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,['simpl'],['simple']
Usability,tions! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGMainFrame::fMWMFuncsMWM functions; UInt_tTGMainFrame::fMWMInputMWM input modes; UInt_tTGMainFrame::fMWMValueMWM decoration hints; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; Double_tfMaxValuemax value of image; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; Double_tfMinValuemin value of image; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; TASPaletteEditor::PaintPalette*fPaintPalette; TImagePalette*fPalettecurrent palette; TRootEmbeddedCanvas*fPaletteCanvascanvas to draw the current palette; TList*fPaletteListlist of palettes for undo and redo; const TGWindow*TGWindow::fParentParent window; Int_tfRampFactor; TGRadioButton*fRamps[3]; TGTextButton*fReDoButton; TStringTGMainFrame::fResourceNameWM resource name; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGCheckButton*fStepButton; TGTextButton*fUnDoButton; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TASPaletteEditor.html:20441,undo,undo,20441,root/html526/TASPaletteEditor.html,https://root.cern,https://root.cern/root/html526/TASPaletteEditor.html,11,['undo'],['undo']
Usability,"tions; A few assumptions need to be made for the fit procedure to be carried out: 1 The total number of events in each template is not too small (so that its Poisson uncertainty can be neglected). 2 The number of events in each bin is much smaller than the total number of events in each template (so that multinomial uncertainties can be replaced with Poisson uncertainties).; Biased fit uncertainties may result if these conditions are not fulfilled (see e.g. arXiv:0803.2711). Instantiation; A fit object is instantiated through TFractionFitter* fit = new TFractionFitter(data, mc); A number of basic checks (intended to ensure that the template histograms represent the same ""kind"" of distribution as the data one) are carried out. The TVirtualFitter object is then addressed and all fit parameters (the template fractions) declared (initially unbounded). Applying constraints; Fit parameters can be constrained through; fit->Constrain(parameter #, lower bound, upper bound);; Setting lower bound = upper bound = 0 removes the constraint (a la Minuit); however, a function fit->Unconstrain(parameter #); is also provided to simplify this. Setting parameter values; The function ROOT::Fit::Fitter* fitter = fit->GetFitter();; is provided for direct access to the ROOT::Fit::Fitter object. This allows to set and fix parameter values, limits and set step sizes directly via fitter->Config().ParSettings(parameter #).Set(const std::string &name, double value, double step, double lower, double upper);; ; Restricting the fit range; The fit range can be restricted through fit->SetRangeX(first bin #, last bin #);; and freed using fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through fit->ExcludeBin(bin #);; where the given bin number is ass",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFractionFitter.html:4107,simpl,simplify,4107,doc/master/classTFractionFitter.html,https://root.cern,https://root.cern/doc/master/classTFractionFitter.html,1,['simpl'],['simplify']
Usability,"tisfy both it and this License would be to; refrain entirely from distribution of the Library. If any portion of this section is held invalid or unenforceable under any; particular circumstance, the balance of the section is intended to apply,; and the section as a whole is intended to apply in other circumstances. It is not the purpose of this section to induce you to infringe any; patents or other property right claims or to contest validity of any; such claims; this section has the sole purpose of protecting the; integrity of the free software distribution system which is; implemented by public license practices. Many people have made; generous contributions to the wide range of software distributed; through that system in reliance on consistent application of that; system; it is up to the author/donor to decide if he or she is willing; to distribute software through any other system and a licensee cannot; impose that choice. This section is intended to make thoroughly clear what is believed to; be a consequence of the rest of this License. 12. If the distribution and/or use of the Library is restricted in; certain countries either by patents or by copyrighted interfaces, the; original copyright holder who places the Library under this License may add; an explicit geographical distribution limitation excluding those countries,; so that distribution is permitted only in or among countries not thus; excluded. In such case, this License incorporates the limitation as if; written in the body of this License. 13. The Free Software Foundation may publish revised and/or new; versions of the Lesser General Public License from time to time.; Such new versions will be similar in spirit to the present version,; but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library; specifies a version number of this License which applies to it and; ""any later version"", you have the option of following the terms and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/license.html:23596,clear,clear,23596,d/license.html,https://root.cern,https://root.cern/d/license.html,1,['clear'],['clear']
Usability,"tities X, Y, Z and T can always; be visualized by a four-dimensional histogram or scatter-plot;; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If T is an unknown (but single-valued); approximate function of X,Y,Z this function is displayed by a profile3D histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for cell I, J. 2; H(I,J,K) = sum T E(I,J,K) = sum T; l(I,J,K) = sum l L(I,J,K) = sum l; h(I,J,K) = H(I,J,K)/L(I,J,K) s(I,J,K) = sqrt(E(I,J,K)/L(I,J,K)- h(I,J,K)**2); e(I,J,K) = s(I,J,K)/sqrt(L(I,J,K)). In the special case where s(I,J,K) is zero (eg, case of 1 entry only in one cell); e(I,J,K) is computed from the average of the s(I,J,K) for all cells,; if the static function TProfile3D::Approximate has been called.; This simple/crude approximation was suggested in order to keep the cell; during a fit operation. But note that this approximation is not the default behaviour. Example of a profile3D histogram; {; TCanvas *c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; hprof3d = new TProfile3D(""hprof3d"",""Profile of pt versus px, py and pz"",40,-4,4,40,-4,4,40,0,20);; Double_t px, py, pz, pt;; TRandom3 r(0);; for ( Int_t i=0; i<25000; i++) {; r.Rannor(px,py);; pz = px*px + py*py;; pt = r.Landau(0,1);; hprof3d->Fill(px,py,pz,pt,1);; }; hprof3d->Draw();; }. NOTE: A TProfile3D is drawn as it was a simple TH3. Function Members (Methods); public:. TProfile3D(); TProfile3D(const TProfile3D& profile); TProfile3D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins, Option_t* option = """"); TProfile3D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t z",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile3D.html:1429,simpl,simple,1429,root/html534/TProfile3D.html,https://root.cern,https://root.cern/root/html534/TProfile3D.html,2,['simpl'],['simple']
Usability,"tities X, Y, Z and T can always; be visualized by a four-dimensional histogram or scatter-plot;; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If T is an unknown (but single-valued); approximate function of X,Y,Z this function is displayed by a profile3D histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for cell I, J. 2; H(I,J,K) = sum T E(I,J,K) = sum T; l(I,J,K) = sum l L(I,J,K) = sum l; h(I,J,K) = H(I,J,K)/L(I,J,K) s(I,J,K) = sqrt(E(I,J,K)/L(I,J,K)- h(I,J,K)**2); e(I,J,K) = s(I,J,K)/sqrt(L(I,J,K)). In the special case where s(I,J,K) is zero (eg, case of 1 entry only in one cell); e(I,J,K) is computed from the average of the s(I,J,K) for all cells,; if the static function TProfile3D::Approximate has been called.; This simple/crude approximation was suggested in order to keep the cell; during a fit operation. But note that this approximation is not the default behaviour. Example of a profile3D histogram; {; TCanvas *c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; hprof3d = new TProfile3D(""hprof3d"",""Profile of pt versus px, py and pz"",40,-4,4,40,-4,4,40,0,20);; Double_t px, py, pz, pt;; TRandom3 r(0);; for ( Int_t i=0; i<25000; i++) {; r.Rannor(px,py);; pz = px*px + py*py;; pt = r.Landau(0,1);; hprof3d->Fill(px,py,pz,pt,1);; }; hprof3d->Draw();; }. NOTE: A TProfile3D is drawn as it was a simple TH3. Function Members (Methods); public:. virtual~TProfile3D(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAdd(const TH1* h1, Double_t c1 = 1); virtual Bool_tAdd(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual Bool_tAdd(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; voidTArrayD::AddAt(Double_t c, Int_t i); virtual voidTH3D::AddBinContent(Int_t bin); virtual voidTH3D::AddBinC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProfile3D.html:1429,simpl,simple,1429,root/html602/TProfile3D.html,https://root.cern,https://root.cern/root/html602/TProfile3D.html,4,['simpl'],['simple']
Usability,"tity; kGeoShared; kGeoTranslation; kGeoRotation; kGeoScale; kGeoReflection; kGeoRegistered; kGeoSavePrimitive; kGeoMatrixOwned; kGeoCombiTrans; kGeoGenTrans; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TGeoRotation*TGeoCombiTrans::fRotationrotation matrix; Double_tfScale[3]scale (x, y, z); TStringTNamed::fTitleobject title; Double_tTGeoCombiTrans::fTranslation[3]translation vector. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGenTrans(); dummy ctor. TGeoGenTrans(const char* name); constructor. TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); constructor. TGeoGenTrans(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); constructor. ~TGeoGenTrans(); destructor. void Clear(Option_t* option = """"); clear the fields of this transformation. void SetScale(Double_t sx, Double_t sy, Double_t sz); set the scale. TGeoMatrix& Inverse() const; Return a temporary inverse of this. Bool_t Normalize(); A scale transformation should be normalized by sx*sy*sz factor. TGeoMatrix& operator=(const TGeoGenTrans& ); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetScale() const. TGeoMatrix * MakeClone() const. void SetScale(Double_t sx, Double_t sy, Double_t sz). TGeoGenTrans(). » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoGenTrans.html:15836,clear,clear,15836,root/html534/TGeoGenTrans.html,https://root.cern,https://root.cern/root/html534/TGeoGenTrans.html,3,"['Clear', 'clear']","['Clear', 'clear']"
Usability,"tives are visible: it is easy to access and compare choices because they can all be seen together. Each option acts as a switch and can be either “on” or “off”. It is never changed in contents. Checkboxes differ from radio buttons in that they permit selection of more than one alternative. Each box can be switched on or off independently. These buttons can be used alone or grouped in sets. It is good practice to provide default settings for check boxes whenever it is possible. This can be done by:; SetState(EButtonState state); The parameter state can be one of kButtonUp, kButtonDown, kButtonEngaged, kButtonDisabled.; Check boxes can be used to affect other controls. The contents of a list can, for example, be filtered by setting a check box. In any case, use a check box only when both states of a choice are clearly opposite and unambiguous. If opposite states are not clear, it is better to use two radio buttons.; Choice description, i.e. check box label, must be clear, meaningful, fully spelled out, and displayed in mixed-type text. Whenever the use of a given button is inappropriate, for whatever reason, that button should be disabled:; button->SetState(kButtonDisabled);; Never make a button appear and disappear.; In general, option buttons should not offer more than eight choices. If the number of choices exceeds this maximum, it is better to use a multiple selection list box.; The method IsToggleButton() gives the information whether a radio button or a check button is selected. An option button can be set or unset via its method PSetState(EButtonState state).; The method HandleKey(event) is called when the defined hotkey is hit for any button. It sets the selected option button or clicks the selected text button and invokes its defined action.; 25.8.2 Text Entries; A TGTextEntry is a one-line text input widget. It contains text that is entered or modified through the keyboard. This text may be displayed in different way according to the set echo mode. Users can ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1184551,clear,clear,1184551,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['clear'],['clear']
Usability,"tle ;  CTClusterIteratorHelper class to iterate over cluster of baskets ;  CTFriendLockHelper class to prevent infinite recursion in the usage of TTree Friends ;  CTTreeCacheA specialized TFileCacheRead object for a TTree ;  CTTreeCacheUnzipSpecialization of TTreeCache for parallel Unzipping ;  ►CTTreeClonerClass implementing or helping the various TTree cloning method ;  CCompareEntry;  CCompareSeek;  CTTreeDrawArgsParserA class that parses all parameters for TTree::Draw() ;  CTTreeFormulaUsed to pass a selection expression to the Tree drawing routine ;  CTTreeFormulaManagerUsed to coordinate one or more TTreeFormula objects ;  CTTreeFriendLeafIterIterator on all the leaves in a TTree and its friend ;  CTTreeIndexA Tree Index with majorname and minorname ;  CTTreeInput;  CTTreePerfStatsTTree I/O performance measurement ;  CTTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram, display, etc) ;  ►CTTreeReaderTTreeReader is a simple, robust and fast interface to read values from a TTree, TChain or TNtuple ;  CIterator_t;  ►CTTreeReaderArrayExtracts array data from a TTree ;  CIterator_t;  CTTreeReaderValueExtracts data from a TTree ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list view container for the ;  CTTVLVEntryThis class represent entries that goes into the TreeViewer listview container ;  CTTVRecordI/O classes for TreeViewer session handling ;  CTTVSessionI/O classes for TreeViewer session handling ;  CTUDPSocket;  CTUnfoldTUnfold",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:159833,simpl,simple,159833,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,2,['simpl'],['simple']
Usability,"tle, RooAbsReal& nll, const RooArgSet& observables); Constructor of profile likelihood given input likelihood nll w.r.t; the given set of variables. The input log likelihood is minimized w.r.t; to all other variables of the likelihood at each evaluation and the; value of the global log likelihood minimum is always subtracted. RooProfileLL(const RooProfileLL& other, const char* name = 0); Copy constructor. ~RooProfileLL(); Destructor. const RooArgSet& bestFitParams() const. const RooArgSet& bestFitObs() const. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Optimized implementation of createProfile for profile likelihoods.; Return profile of original function in terms of stated parameters; of interest rather than profiling recursively. void initializeMinimizer() const. Double_t evaluate() const; Evaluate profile likelihood by minimizing likelihood w.r.t. all; parameters that are not considered observables of this profile; likelihood object. void validateAbsMin() const; Check that parameters and likelihood value for 'best fit' are still valid. If not,; because the best fit has never been calculated, or because constant parameters have; changed value or parameters have changed const/float status, the minimum is recalculated. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ). TObject* clone(const char* newname) const; { return new RooProfileLL(*this,newname); }. void setAlwaysStartFromMin(Bool_t flag); { _startFromMin = flag ; }. Bool_t alwaysStartFromMin() const; { return _startFromMin ; }. MINIMIZER* minimizer(); { return _minimizer ; }. RooAbsReal& nll(); { return const_cast<RooAbsReal&>(_nll.arg()) ; }. void clearAbsMin(); { _absMinValid = kFALSE ; }. Int_t numEval() const; { return _neval ; }. » Last changed: Tue Jun 30 14:35:04 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProfileLL.html:40251,clear,clearAbsMin,40251,root/html602/RooProfileLL.html,https://root.cern,https://root.cern/root/html602/RooProfileLL.html,2,['clear'],['clearAbsMin']
Usability,"tle, RooAbsReal& nll, const RooArgSet& observables); Constructor of profile likelihood given input likelihood nll w.r.t; the given set of variables. The input log likelihood is minimized w.r.t; to all other variables of the likelihood at each evaluation and the; value of the global log likelihood minimum is always subtracted. RooProfileLL(const RooProfileLL& other, const char* name = 0); Copy constructor. ~RooProfileLL(); Destructor. const RooArgSet& bestFitParams() const. const RooArgSet& bestFitObs() const. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Optimized implementation of createProfile for profile likelihoods.; Return profile of original function in terms of stated parameters; of interest rather than profiling recursively. void initializeMinimizer() const. Double_t evaluate() const; Evaluate profile likelihood by minimizing likelihood w.r.t. all; parameters that are not considered observables of this profile; likelihood object. void validateAbsMin() const; Check that parameters and likelihood value for 'best fit' are still valid. If not,; because the best fit has never been calculated, or because constant parameters have; changed value or parameters have changed const/float status, the minimum is recalculated. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ). TObject* clone(const char* newname) const; { return new RooProfileLL(*this,newname); }. void setAlwaysStartFromMin(Bool_t flag); { _startFromMin = flag ; }. Bool_t alwaysStartFromMin() const; { return _startFromMin ; }. MINIMIZER* minimizer(); { return _minimizer ; }. RooAbsReal& nll(); { return const_cast<RooAbsReal&>(_nll.arg()) ; }. void clearAbsMin(); { _absMinValid = kFALSE ; }. Int_t numEval() const; { return _neval ; }. » Last changed: Tue Mar 10 17:18:36 2015 » Last generated: 2015-03-10 17:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProfileLL.html:38749,clear,clearAbsMin,38749,root/html534/RooProfileLL.html,https://root.cern,https://root.cern/root/html534/RooProfileLL.html,2,['clear'],['clearAbsMin']
Usability,"tle="""");  Measurement( const Measurement& other ); // Copy. ;  ; void AddAsimovDataset (RooStats::HistFactory::Asimov dataset);  add an Asimov Dataset ;  ; void AddConstantParam (const std::string &param);  Add a parameter to be set as constant (Similar to ParamSetting method below) ;  ; void AddFunctionObject (const RooStats::HistFactory::PreprocessFunction function);  add a preprocess function object ;  ; void AddPOI (const std::string &POI);  append parameter to vector of PoIs ;  ; void AddPreprocessFunction (std::string name, std::string expression, std::string dependencies);  Add a preprocessed function by giving the function a name, a functional expression, and a string with a bracketed list of dependencies (eg ""SigXsecOverSM[0,3]"") ;  ; void ClearConstantParams ();  empty vector of constant parameters ;  ; void ClearParamValues ();  clear map of parameter values ;  ; std::vector< RooStats::HistFactory::Asimov > & GetAsimovDatasets ();  get vector of defined Asimov Datasets ;  ; int GetBinHigh ();  ; int GetBinLow ();  ; std::vector< std::string > & GetConstantParams ();  get vector of all constant parameters ;  ; std::vector< RooStats::HistFactory::PreprocessFunction > & GetFunctionObjects ();  get vector of defined function objects ;  ; const std::vector< RooStats::HistFactory::PreprocessFunction > & GetFunctionObjects () const;  ; double GetLumi ();  retrieve integrated luminosity ;  ; double GetLumiRelErr ();  retrieve relative uncertainty on luminosity ;  ; std::string GetOutputFilePrefix ();  retrieve prefix for output files ;  ; std::map< std::string, double > & GetParamValues ();  get map: parameter name <--> parameter value ;  ; std::string GetPOI (unsigned int i=0);  get name of PoI at given index ;  ; std::vector< std::string > & GetPOIList ();  get vector of PoI names ;  ; std::vector< std::string > GetPreprocessFunctions () const;  Returns a list of defined preprocess function expressions. ;  ; void SetBinHigh (int BinHigh);  ; void SetBinLow (int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1Measurement.html:1620,clear,clear,1620,doc/master/classRooStats_1_1HistFactory_1_1Measurement.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1Measurement.html,1,['clear'],['clear']
Usability,"tmp) { std::string s(tmp); s.swap(_msg); }; 312 void setServerValues(const char* tmp) { std::string s(tmp); s.swap(_srvval); }; 313 std::string _msg;; 314 std::string _srvval;; 315 } ;; 316 ; 317 enum ErrorLoggingMode { PrintErrors, CollectErrors, CountErrors, Ignore } ;; 318 ; 319 /// Context to temporarily change the error logging mode as long as the context is alive.; 320 class EvalErrorContext {; 321 public:; 322 EvalErrorContext(ErrorLoggingMode m) : _old{evalErrorLoggingMode()} { setEvalErrorLoggingMode(m); }; 323 ; 324 EvalErrorContext(EvalErrorContext const&) = delete;; 325 EvalErrorContext(EvalErrorContext &&) = delete;; 326 EvalErrorContext& operator=(EvalErrorContext const&) = delete;; 327 EvalErrorContext& operator=(EvalErrorContext &&) = delete;; 328 ; 329 ~EvalErrorContext() { setEvalErrorLoggingMode(_old); }; 330 private:; 331 ErrorLoggingMode _old;; 332 };; 333 ; 334 static ErrorLoggingMode evalErrorLoggingMode() ;; 335 static void setEvalErrorLoggingMode(ErrorLoggingMode m) ;; 336 void logEvalError(const char* message, const char* serverValueString=nullptr) const ;; 337 static void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString=nullptr) ;; 338 static void printEvalErrors(std::ostream&os=std::cout, Int_t maxPerNode=10000000) ;; 339 static Int_t numEvalErrors() ;; 340 static Int_t numEvalErrorItems();; 341 static std::map<const RooAbsArg *, std::pair<std::string, std::list<RooAbsReal::EvalError>>>::iterator evalErrorIter();; 342 ; 343 static void clearEvalErrorLog() ;; 344 ; 345 /// Tests if the distribution is binned. Unless overridden by derived classes, this always returns false.; 346 virtual bool isBinnedDistribution(const RooArgSet& /*obs*/) const { return false ; }; 347 virtual std::list<double>* binBoundaries(RooAbsRealLValue& obs, double xlo, double xhi) const;; 348 virtual std::list<double>* plotSamplingHint(RooAbsRealLValue& obs, double xlo, double xhi) const;; 349 ; 350 Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:16895,clear,clearEvalErrorLog,16895,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,1,['clear'],['clearEvalErrorLog']
Usability,"to gVirtualX. Bool_t IsTransparent() const; Delegate to gVirtualX. void SetFillColor(Color_t fcolor); Delegate to gVirtualX. void SetFillStyle(Style_t fstyle); Delegate to gVirtualX. void SetOpacity(Int_t percent); Delegate to gVirtualX. Short_t GetTextAlign() const; Delegate to gVirtualX. Float_t GetTextAngle() const; Delegate to gVirtualX. Color_t GetTextColor() const; Delegate to gVirtualX. Font_t GetTextFont() const; Delegate to gVirtualX. Float_t GetTextSize() const; Delegate to gVirtualX. Float_t GetTextMagnitude() const; Delegate to gVirtualX. void SetTextAlign(Short_t align); Delegate to gVirtualX. void SetTextAngle(Float_t tangle); Delegate to gVirtualX. void SetTextColor(Color_t tcolor); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Create a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Paint polyline. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalize",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPadPainter.html:4763,Clear,ClearDrawable,4763,root/html532/TPadPainter.html,https://root.cern,https://root.cern/root/html532/TPadPainter.html,2,['Clear'],"['Clear', 'ClearDrawable']"
Usability,"to gVirtualX. Bool_t IsTransparent() const; Delegate to gVirtualX. void SetFillColor(Color_t fcolor); Delegate to gVirtualX. void SetFillStyle(Style_t fstyle); Delegate to gVirtualX. void SetOpacity(Int_t percent); Delegate to gVirtualX. Short_t GetTextAlign() const; Delegate to gVirtualX. Float_t GetTextAngle() const; Delegate to gVirtualX. Color_t GetTextColor() const; Delegate to gVirtualX. Font_t GetTextFont() const; Delegate to gVirtualX. Float_t GetTextSize() const; Delegate to gVirtualX. Float_t GetTextMagnitude() const; Delegate to gVirtualX. void SetTextAlign(Short_t align); Delegate to gVirtualX. void SetTextAngle(Float_t tangle); Delegate to gVirtualX. void SetTextColor(Color_t tcolor); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Create a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawPixels(const unsigned char* pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t enableAlphaBlending); Noop, for non-gl pad TASImage calls gVirtualX->CopyArea. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y). void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPadPainter.html:5367,Clear,ClearDrawable,5367,root/html602/TPadPainter.html,https://root.cern,https://root.cern/root/html602/TPadPainter.html,2,['Clear'],"['Clear', 'ClearDrawable']"
Usability,"to gVirtualX. Bool_t IsTransparent() const; Delegate to gVirtualX. void SetFillColor(Color_t fcolor); Delegate to gVirtualX. void SetFillStyle(Style_t fstyle); Delegate to gVirtualX. void SetOpacity(Int_t percent); Delegate to gVirtualX. Short_t GetTextAlign() const; Delegate to gVirtualX. Float_t GetTextAngle() const; Delegate to gVirtualX. Color_t GetTextColor() const; Delegate to gVirtualX. Font_t GetTextFont() const; Delegate to gVirtualX. Float_t GetTextSize() const; Delegate to gVirtualX. Float_t GetTextMagnitude() const; Delegate to gVirtualX. void SetTextAlign(Short_t align); Delegate to gVirtualX. void SetTextAngle(Float_t tangle); Delegate to gVirtualX. void SetTextColor(Color_t tcolor); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Create a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawPixels(const unsigned char* pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t enableAlphaBlending); Noop, for non-gl pad TASImage calls gVirtualX->CopyArea. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Paint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPadPainter.html:5367,Clear,ClearDrawable,5367,root/html604/TPadPainter.html,https://root.cern,https://root.cern/root/html604/TPadPainter.html,2,['Clear'],"['Clear', 'ClearDrawable']"
Usability,"to gVirtualX. Bool_t IsTransparent() const; Delegate to gVirtualX. void SetFillColor(Color_t fcolor); Delegate to gVirtualX. void SetFillStyle(Style_t fstyle); Delegate to gVirtualX. void SetOpacity(Int_t percent); Delegate to gVirtualX. Short_t GetTextAlign() const; Delegate to gVirtualX. Float_t GetTextAngle() const; Delegate to gVirtualX. Color_t GetTextColor() const; Delegate to gVirtualX. Font_t GetTextFont() const; Delegate to gVirtualX. Float_t GetTextSize() const; Delegate to gVirtualX. Float_t GetTextMagnitude() const; Delegate to gVirtualX. void SetTextAlign(Short_t align); Delegate to gVirtualX. void SetTextAngle(Float_t tangle); Delegate to gVirtualX. void SetTextColor(Color_t tcolor); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Create a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawPixels(const unsigned char* pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t enableBlending); Noop, for non-gl pad TASImage calls gVirtualX->CopyArea. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y). void DrawP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPadPainter.html:5129,Clear,ClearDrawable,5129,root/html534/TPadPainter.html,https://root.cern,https://root.cern/root/html534/TPadPainter.html,2,['Clear'],"['Clear', 'ClearDrawable']"
Usability,to illustrate the influence of number of iterations in deconvolution in high resolution peak searching function (class TSpectrum) ;  Smoothing.C Example to illustrate smoothing using Markov algorithm (class TSpectrum) ;  spectrumpainter.C Examples showing how to use TSpectrum2Painter (the SPEC option) ;  ► splot;  TestSPlot.CThis tutorial illustrates the use of class TSPlot and of the sPlots method ;  ► sql;  sqlcanvas.CThis is slight modification of ntuple1.C example ;  sqlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlcreatedb.py Create a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlfilldb.py Fill run catalog with nfiles entries ;  sqlselect.CQuery example to MySQL test database ;  sqlselect.py Query example to MySQL test database ;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► envelope;  classification.C;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This macro provides an example of how,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:157940,simpl,simple,157940,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['simpl'],['simple']
Usability,"to its container reference frame. This frame will be called; 23'master' and the frame of the positioned volume - 'local'. If T is a; 24transformation used for positioning volume daughters, then:; 25 ; 26~~~ {.cpp}; 27 MASTER = T * LOCAL; 28~~~; 29 ; 30 Therefore a local-to-master conversion will be performed by using T, while; 31a master-to-local by using its inverse. The second use case is the computation; 32of the global transformation of a given object in the geometry. Since the; 33geometry is built as 'volumes-inside-volumes', this global transformation; 34represent the pile-up of all local transformations in the corresponding; 35branch. The conversion from the global reference frame and the given object; 36is also called master-to-local, but it is handled by the manager class.; 37 A general homogenous transformation is defined as a 4x4 matrix embedding; 38a rotation, a translation and a scale. The advantage of this description; 39is that each basic transformation can be represented as a homogenous matrix,; 40composition being performed as simple matrix multiplication.; 41 ; 42 Rotation: Inverse rotation:; 43 ; 44~~~ {.cpp}; 45 r11 r12 r13 0 r11 r21 r31 0; 46 r21 r22 r23 0 r12 r22 r32 0; 47 r31 r32 r33 0 r13 r23 r33 0; 48 0 0 0 1 0 0 0 1; 49~~~; 50 ; 51 Translation: Inverse translation:; 52 ; 53~~~ {.cpp}; 54 1 0 0 tx 1 0 0 -tx; 55 0 1 0 ty 0 1 0 -ty; 56 0 0 1 tz 0 0 1 -tz; 57 0 0 0 1 0 0 0 1; 58~~~; 59 ; 60 Scale: Inverse scale:; 61 ; 62~~~ {.cpp}; 63 sx 0 0 0 1/sx 0 0 0; 64 0 sy 0 0 0 1/sy 0 0; 65 0 0 sz 0 0 0 1/sz 0; 66 0 0 0 1 0 0 0 1; 67~~~; 68 ; 69 where:; 70 - `rij` are the 3x3 rotation matrix components,; 71 - `tx`, `ty`, `tz` are the translation components; 72 - `sx`, `sy`, `sz` are arbitrary scale constants on each axis,; 73 ; 74 The disadvantage in using this approach is that computation for 4x4 matrices; 75is expensive. Even combining two translation would become a multiplication; 76of their corresponding matrices, which is quite an undesired effect.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:2185,simpl,simple,2185,doc/master/TGeoMatrix_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html,1,['simpl'],['simple']
Usability,"to line number. Long_t ToObjXCoord(Long_t xCoord, Long_t line); Convert x screen coordinate to column in specified line. void Clear(Option_t* = """"); Clear text view widget. Bool_t LoadFile(const char* fname, long startpos = 0, long length = -1); Load a file in the text view widget. Return false in case file does not; exist. Bool_t LoadBuffer(const char* txtbuf); Load text from a text buffer. Return false in case of failure. Bool_t Copy(); Copy selected text to clipboard. Bool_t SelectAll(); Select all text in the viewer. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw lines in exposed region. Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Bool_t HandleTimer(TTimer* t); Handle scroll timer. Bool_t HandleButton(Event_t* event); Handle mouse button event in text editor. Bool_t HandleDoubleClick(Event_t* event); handle double click. Bool_t HandleMotion(Event_t* event); Handle mouse motion event in the text editor widget. Bool_t HandleSelectionClear(Event_t* event); Handle selection clear event. Bool_t HandleSelectionRequest(Event_t* event); Handle request to send current clipboard contents to requestor window. Bool_t HandleDNDDrop(TDNDData* data); Handle Drop event. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle Drag position event. Atom_t HandleDNDEnter(Atom_t* typelist); Handle Drag Enter event. Bool_t HandleDNDLeave(); Handle Drag Leave event. void Mark(Long_t xPos, Long_t yPos); Mark a text region from xPos to yPos. void UnMark(); Clear marked region. void AdjustWidth(); Adjust widget width to longest line. void Layout(); Layout the components of view. void HLayout(); Horizontal layout of widgets (canvas, scrollbar). void VLayout(); Vertical layout of widgets (canvas, scrollbar). void SetSBRange(Int_t direction); Set the range for the kVertical or kHorizontal scrollbar. void SetHsbPosition(Long_t newPos); Set position of horizontal scrollbar. void SetVsbPosition(Long_t newPos); Set position",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTextView.html:26774,clear,clear,26774,root/html528/TGTextView.html,https://root.cern,https://root.cern/root/html528/TGTextView.html,10,['clear'],['clear']
Usability,"to more compact representation. ; Definition at line 1203 of file TBufferXML.cxx. ◆ PerformPreProcessing(). void TBufferXML::PerformPreProcessing ; (; const TStreamerElement * ; elem, . XMLNodePointer_t ; elemnode . ). protected . Function is unpack TObject and TString structures to be able read them from custom streamers of this objects. ; Definition at line 1321 of file TBufferXML.cxx. ◆ PopStack(). TXMLStackObj * TBufferXML::PopStack ; (; ). protected . Remove one level from xml stack. ; Definition at line 312 of file TBufferXML.cxx. ◆ ProcessPointer(). Bool_t TBufferXML::ProcessPointer ; (; const void * ; ptr, . XMLNodePointer_t ; node . ). protected . Add ""ptr"" attribute to node, if ptr is null or if ptr is pointer on object, which is already saved in buffer Automatically add ""ref"" attribute to node, where referenced object is stored. ; Definition at line 523 of file TBufferXML.cxx. ◆ PushStack(). TXMLStackObj * TBufferXML::PushStack ; (; XMLNodePointer_t ; current, . Bool_t ; simple = kFALSE . ). protected . Add new level to xml stack. ; Definition at line 298 of file TBufferXML.cxx. ◆ ReadArray() [1/13]. Int_t TBufferXML::ReadArray ; (; Bool_t *& ; b). finalvirtual . Read array of Bool_t from buffer. ; Implements TBuffer.; Definition at line 1570 of file TBufferXML.cxx. ◆ ReadArray() [2/13]. Int_t TBufferXML::ReadArray ; (; Char_t *& ; c). finalvirtual . Read array of Char_t from buffer. ; Implements TBuffer.; Definition at line 1578 of file TBufferXML.cxx. ◆ ReadArray() [3/13]. Int_t TBufferXML::ReadArray ; (; Double_t *& ; d). finalvirtual . Read array of Double_t from buffer. ; Implements TBuffer.; Definition at line 1666 of file TBufferXML.cxx. ◆ ReadArray() [4/13]. Int_t TBufferXML::ReadArray ; (; Float_t *& ; f). finalvirtual . Read array of Float_t from buffer. ; Implements TBuffer.; Definition at line 1658 of file TBufferXML.cxx. ◆ ReadArray() [5/13]. Int_t TBufferXML::ReadArray ; (; Int_t *& ; i). finalvirtual . Read array of Int_t from buffer. ; Impl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferXML.html:63625,simpl,simple,63625,doc/master/classTBufferXML.html,https://root.cern,https://root.cern/doc/master/classTBufferXML.html,1,['simpl'],['simple']
Usability,to same file. . OutputStream(ostream&) Send output to given C++ stream. Multiple message streams can write to same c++ stream . The return value is the unique ID of the defined stream. PyROOT; The RooMsgService::addStream() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArg of the function. . Definition at line 177 of file RooMsgService.cxx. ◆ anyDebug(). bool RooMsgService::anyDebug ; (; ). static . Returns true if any debug level stream is active. ; Definition at line 138 of file RooMsgService.cxx. ◆ Class(). static TClass * RooMsgService::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooMsgService::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooMsgService::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 246 of file RooMsgService.h. ◆ clearErrorCount(). void RooMsgService::clearErrorCount ; (; ). inline . Definition at line 200 of file RooMsgService.h. ◆ debugCode(). Int_t & RooMsgService::debugCode ; (; ). inline . Definition at line 207 of file RooMsgService.h. ◆ debugWorkspace(). RooWorkspace * RooMsgService::debugWorkspace ; (; ). Definition at line 147 of file RooMsgService.cxx. ◆ DeclFileName(). static const char * RooMsgService::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 246 of file RooMsgService.h. ◆ deleteStream(). void RooMsgService::deleteStream ; (; Int_t ; id). Delete stream with given unique ID code. ; Definition at line 293 of file RooMsgService.cxx. ◆ errorCount(). Int_t RooMsgService::errorCount ; (; ); const. inline . Definition at line 199 of file RooMsgService.h. ◆ getStream(). StreamConfig & RooMsgService::getStream ; (; Int_t ; id). inline . Definition at line 161 of file RooMsgService.h. ◆ getStreamStatus(). bool RooMsgService::getStreamStatus ; (; Int_t ; id); c,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMsgService.html:18006,clear,clearErrorCount,18006,doc/master/classRooMsgService.html,https://root.cern,https://root.cern/doc/master/classRooMsgService.html,1,['clear'],['clearErrorCount']
Usability,"to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the sie of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. void SetSimpleArray(Int_t arraySize, Int_t firstRow, Int_t numberRows); Set some common parameteres for the ""simple"" arrays. ~TTableSorter(); to be documented. Int_t BSearch(valuetype value). Int_t SelectSearch(valuetype value). Int_t BSearch(const void* value) const; to be documented. Int_t GetIndex(UInt_t sortedIndex) const; returns the original index of the row by its sorted index. Int_t CountKey(const void* key, Int_t firstIndx = 0, Bool_t bSearch = kTRUE, Int_t* firstRow = 0) const. CountKey counts the number of rows with the key value equal ""key"". key - it is a POINTER to the key value; fistIndx - the first index within sorted array to star search; = 0 by default; bSearch = kTRUE - binary search (by default) is used otherwise linear one. Int_t CountKeys() const. Counts the number of different key values. Bool_t FillIndexArray(). File the array of the pointers and check whether; the original table has been sorted to avoid an extra job. Return: kTRUE - the table has been sorted; kFALSE - otherwise. Int_t FindFirstKey(const void* key) const. L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTableSorter.html:17535,simpl,simple,17535,root/html528/TTableSorter.html,https://root.cern,https://root.cern/root/html528/TTableSorter.html,10,['simpl'],['simple']
Usability,"to string. TString & Replace(Ssiz_t pos, Ssiz_t n, const char* s, Ssiz_t ns); Remove at most n1 characters from self beginning at pos,; and replace them with the first n2 characters of cs. TString& ReplaceAll(const char* s1, Ssiz_t ls1, const char* s2, Ssiz_t ls2); Find & Replace ls1 symbols of s1 with ls2 symbols of s2 if any. TString & Remove(TString::EStripType s, char c); Remove char c at begin and/or end of string (like Strip()) but; modifies directly the string. void Resize(Ssiz_t n); Resize the string. Truncate or add blanks as necessary. TSubString Strip(TString::EStripType s = kTrailing, char c = ' ') const; Return a substring of self stripped at beginning and/or end. void ToLower(); Change string to lower-case. void ToUpper(); Change string to upper case. void AssertElement(Ssiz_t nc) const; Check to make sure a string index is in range. Ssiz_t AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap); Calculate a nice capacity greater than or equal to newCap. void Clear(); Clear string without changing its capacity. void Clobber(Ssiz_t nc); Clear string and make sure it has a capacity of nc. void Clone(Ssiz_t nc); Make self a distinct copy with capacity of at least tot, where tot cannot; be smaller than the current length. Preserve previous contents. void FillBuffer(char*& buffer) const; Copy string into I/O buffer. void ReadBuffer(char*& buffer); Read string from I/O buffer. TString * ReadString(TBuffer& b, const TClass* clReq); Read TString object from buffer. Simplified version of; TBuffer::ReadObject (does not keep track of multiple; references to same string). We need to have it here; because TBuffer::ReadObject can only handle descendant; of TObject. Int_t Sizeof() const; Returns size string will occupy on I/O buffer. void Streamer(TBuffer& ); Stream a string object. void WriteString(TBuffer& b, const TString* a); Write TString object to buffer. Simplified version of; TBuffer::WriteObject (does not keep track of multiple; references to the same string). We need ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TString.html:13457,Clear,Clear,13457,root/html534/TString.html,https://root.cern,https://root.cern/root/html534/TString.html,6,['Clear'],['Clear']
Usability,"to string. TString & Replace(Ssiz_t pos, Ssiz_t n, const char* s, Ssiz_t ns); Remove at most n1 characters from self beginning at pos,; and replace them with the first n2 characters of cs. TString& ReplaceAll(const char* s1, Ssiz_t ls1, const char* s2, Ssiz_t ls2); Find & Replace ls1 symbols of s1 with ls2 symbols of s2 if any. TString & Remove(TString::EStripType s, char c); Remove char c at begin and/or end of string (like Strip()) but; modifies directly the string. void Resize(Ssiz_t n); Resize the string. Truncate or add blanks as necessary. TSubString Strip(TString::EStripType s = kTrailing, char c = ' ') const; Return a substring of self stripped at beginning and/or end. void ToLower(); Change string to lower-case. void ToUpper(); Change string to upper case. void AssertElement(Ssiz_t nc) const; Check to make sure a string index is in range. Ssiz_t AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap); Calculate a nice capacity greater than or equal to newCap. void Clear(); Clear string without changing its capacity. void Clobber(Ssiz_t nc); Clear string and make sure it has a capacity of nc. void Clone(Ssiz_t nc); Make self a distinct copy with capacity of at least tot, where tot cannot; be smaller than the current length. Preserve previous contents. void FillBuffer(char*& buffer); Copy string into I/O buffer. void ReadBuffer(char*& buffer); Read string from I/O buffer. TString * ReadString(TBuffer& b, const TClass* clReq); Read TString object from buffer. Simplified version of; TBuffer::ReadObject (does not keep track of multiple; references to same string). We need to have it here; because TBuffer::ReadObject can only handle descendant; of TObject. Int_t Sizeof() const; Returns size string will occupy on I/O buffer. void Streamer(TBuffer& b); Stream a string object. void WriteString(TBuffer& b, const TString* a); Write TString object to buffer. Simplified version of; TBuffer::WriteObject (does not keep track of multiple; references to the same string). We need to ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TString.html:12991,Clear,Clear,12991,root/html532/TString.html,https://root.cern,https://root.cern/root/html532/TString.html,2,['Clear'],['Clear']
Usability,"to the bottom. void PageUp(Bool_t select = kFALSE); Move content one page up. void PageDown(Bool_t select = kFALSE); Move content one page down. void LineUp(Bool_t select = kFALSE); Move content one item-size up. void LineDown(Bool_t select = kFALSE); Move content one item-size down. void AdjustPosition(TGListTreeItem* item); Move content to position of item. If item is 0, move to position; of currently selected item. void Search(Bool_t close = kTRUE); Invokes search dialog. Looks for item with the entered name. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Redraw list tree. void Draw(Handle_t id, Int_t yevent, Int_t hevent); Draw list tree widget. Int_t DrawChildren(Handle_t id, TGListTreeItem* item, Int_t x, Int_t y, Int_t xroot); Draw children of item in list tree. void DrawItem(Handle_t id, TGListTreeItem* item, Int_t x, Int_t y, Int_t* xroot, UInt_t* retwidth, UInt_t* retheight); Draw list tree item. void DrawOutline(Handle_t id, TGListTreeItem* item, Pixel_t col = 0xbbbbbb, Bool_t clear = kFALSE); Draw a outline of color 'col' around an item. void DrawActive(Handle_t id, TGListTreeItem* item); Draw active item with its active color. void DrawItemName(Handle_t id, TGListTreeItem* item); Draw name of list tree item. void DrawNode(Handle_t id, TGListTreeItem* item, Int_t x, Int_t y); Draw node (little + in box). void SetToolTipText(const char* text, Int_t x, Int_t y, Long_t delayms); Set tool tip text associated with this item. The delay is in; milliseconds (minimum 250). To remove tool tip call method with; delayms = 0. To change delayms you first have to call this method; with delayms=0. void RemoveReference(TGListTreeItem* item); This function removes the specified item from the linked list.; It does not do anything with the data contained in the item, though. void PDeleteItem(TGListTreeItem* item); Delete given item. Takes care of list-tree state members; fSelected, fCurrent and fBelowMouse. void PDeleteChildren(TGListTreeItem* item); Recursively del",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGListTree.html:34658,clear,clear,34658,root/html528/TGListTree.html,https://root.cern,https://root.cern/root/html528/TGListTree.html,6,['clear'],['clear']
Usability,"to the bottom. void PageUp(Bool_t select = kFALSE); Move content one page up. void PageDown(Bool_t select = kFALSE); Move content one page down. void LineUp(Bool_t select = kFALSE); Move content one item-size up. void LineDown(Bool_t select = kFALSE); Move content one item-size down. void AdjustPosition(TGListTreeItem* item); Move content to position of item. If item is 0, move to position; of currently selected item. void Search(Bool_t close = kTRUE); Invokes search dialog. Looks for item with the entered name. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Redraw list tree. void Draw(Handle_t id, Int_t yevent, Int_t hevent); Draw list tree widget. Int_t DrawChildren(Handle_t id, TGListTreeItem* item, Int_t x, Int_t y, Int_t xroot); Draw children of item in list tree. void DrawItem(Handle_t id, TGListTreeItem* item, Int_t x, Int_t y, Int_t* xroot, UInt_t* retwidth, UInt_t* retheight); Draw list tree item. void DrawOutline(Handle_t id, TGListTreeItem* item, Pixel_t col = 12303291, Bool_t clear = kFALSE); Draw a outline of color 'col' around an item. void DrawActive(Handle_t id, TGListTreeItem* item); Draw active item with its active color. void DrawItemName(Handle_t id, TGListTreeItem* item); Draw name of list tree item. void DrawNode(Handle_t id, TGListTreeItem* item, Int_t x, Int_t y); Draw node (little + in box). void SetToolTipText(const char* text, Int_t x, Int_t y, Long_t delayms); Set tool tip text associated with this item. The delay is in; milliseconds (minimum 250). To remove tool tip call method with; delayms = 0. To change delayms you first have to call this method; with delayms=0. void RemoveReference(TGListTreeItem* item); This function removes the specified item from the linked list.; It does not do anything with the data contained in the item, though. void PDeleteItem(TGListTreeItem* item); Delete given item. Takes care of list-tree state members; fSelected, fCurrent and fBelowMouse. void PDeleteChildren(TGListTreeItem* item); Recursively del",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGListTree.html:35907,clear,clear,35907,root/html602/TGListTree.html,https://root.cern,https://root.cern/root/html602/TGListTree.html,4,['clear'],['clear']
Usability,"to the list of ROOT browsables by: gROOT->GetListOfBrowsables()->Add(myTopLevelTask). Reimplemented from TObject.; Definition at line 211 of file TTask.cxx. ◆ Class(). static TClass * TTask::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTask::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTask::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 76 of file TTask.h. ◆ CleanTasks(). void TTask::CleanTasks ; (; ). virtual . Reset tasks state: breakpoints and execute flags also invokes the Clear function of each task to clear all data structures created by a previous execution of a task. ; Definition at line 222 of file TTask.cxx. ◆ Clear(). void TTask::Clear ; (; Option_t * ; option = """"). overridevirtual . Recursively call the Clear function of this task and its subtasks. ; The Clear function must be implemented for each derived class to clear all data structures created by a previous execution of a task. This function is automatically called by the CleanTasks function. ; Reimplemented from TNamed.; Definition at line 240 of file TTask.cxx. ◆ Continue(). void TTask::Continue ; (; ). virtual . Resume execution at the current break point. ; Definition at line 247 of file TTask.cxx. ◆ DeclFileName(). static const char * TTask::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 76 of file TTask.h. ◆ Exec(). void TTask::Exec ; (; Option_t * ; option). virtual . Dummy Execute. ; This function must be redefined in the derived classes. ; Definition at line 267 of file TTask.cxx. ◆ ExecuteTask(). void TTask::ExecuteTask ; (; Option_t * ; option = ""0""). virtual . Execute main task and its subtasks. ; When calling this function, the Exec function of the corresponding class is invoked, then the list of its subtasks is executed calling recursively all the subtasks, etc.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTask.html:18050,clear,clear,18050,doc/master/classTTask.html,https://root.cern,https://root.cern/doc/master/classTTask.html,1,['clear'],['clear']
Usability,"to this class)THnT<Int_t>, THnI. Function Members (Methods); public:. THnT<int>(); THnT<int>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin, const Double_t* xmax); ~THnT<int>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnT_int_.html:2212,Clear,Clear,2212,root/html534/THnT_int_.html,https://root.cern,https://root.cern/root/html534/THnT_int_.html,1,['Clear'],['Clear']
Usability,to; kCXX_IndirectProto; kCXX_ScopeMember; kCXX_DirectMember; kCXX_IndirectMember; kCXX_Global; kCXX_GlobalProto; kNUM_PAT; };. private:. char*fBufinitialized by Hook(); Int_tfLastIterfrodo: iteration counter for recursive MakeClassFromVarName; unsigned shortfPat[25][1024]array of patterns; const char*fRegExp[25]corresponding regular expression plain text; Bool_tfVarIsPointerfrodo: pointer or not flag; TSeqCollection*fpClasses; TSeqCollection*fpDirectives; TSeqCollection*fpEnvVars; TSeqCollection*fpFiles; TSeqCollection*fpGlobalFuncs; TSeqCollection*fpGlobals; int*fpLocinitialized by Hook(); TSeqCollection*fpNamespacesContains the names of namespaces registered in CINT.; TSeqCollection*fpPragmas; TSeqCollection*fpSysIncFiles; TSeqCollection*fpUsers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTabCom(); Default constructor. ~TTabCom(); Destructor. void ClearClasses(); Clear classes and namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far. void ClearGlobals(); Forget all global variables seen so far. void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTabCom.html:7022,Clear,ClearCppDirectives,7022,root/html532/TTabCom.html,https://root.cern,https://root.cern/root/html532/TTabCom.html,2,['Clear'],['ClearCppDirectives']
Usability,"together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  parallelMergeTest.C;  pclient.CClient program to test parallel sockets ;  pserv.CServer program to test parallel sockets ;  spy.CClient program which allows the snooping of objects from a spyserv process ;  spyserv.CServer program which allows clients, ""spies"", to connect and snoop objects ;  TestAuth.CMacro test authentication methods stand alone ;  testTUDPSocket.CAs test echo server use udpserver.c in the same directory ;  treeClient.CClient program which creates and fills 2 histograms and a TTree ;  TUriTest.CRudimentary TUri test macro ;  udpserver.c;  ► physics;  PhaseSpace.C Example of use of TGenPhaseSpace ;  ► proof;  EmptyInclude.hEmpty file to test TProof::Load in runProof.C and StressProof.cxx in conjunction with ProcFileElements and ProofEventProc ;  finalizeProof.CMacro to finalize queries run with the macro tutorials/runProof ;  getProof.CAttaches to a PROOF session, possibly at the indicated URL ;  ProcFileElements",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:134730,simpl,simple,134730,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['simpl'],['simple']
Usability,"tolerance}\) value is \(0.1\), and the minimization will stop when the estimated vertical distance to the minimum (\(\mbox{EDM}\)) is less than \(0.001*\)\(\mbox{tolerance}\)\(*\)\(\mbox{up}\) (see [howto:errordef]).; 5.6.5 Parameter interaction; MnMigrad retains the result after each minimization (MnUserParameterStae, see [api:state]) and forwards the interface.; 5.6.6 VariableMetricMinimizer(); The VariableMetricMinimizer is instantiated using default constructor.; 5.6.7 minimize(const FCNBase&, …); The VariableMetricMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.7 MnMinimize and CombinedMinimizer; [api:minimize]; Causes minimization of the function by the method of \(\mbox{MIGRAD}\), as does the MnMigrad class, but switches to the \(\mbox{SIMPLEX}\) method if \(\mbox{MIGRAD}\) fails to converge. Constructor arguments, methods arguments and names of methods are the same as for MnMigrad or MnSimplex and VariableMetricMinimizer or SimplexMinimizer.; 5.8 MnMinos; [api:minos] Causes a \(\mbox{MINOS}\) error analysis to be performed on the parameter whose number is specified. \(\mbox{MINOS}\) errors may be expensive to calculate, but are very reliable since they take account of non-linearities in the problem as well as parameter correlations, and are in general asymmetric. The optional argument \(\mbox{maxcalls}\) specifies the (approximate) maximum number of function calls per parameter requested, after which the calculation will be stopped for that parameter.; 5.8.1 MnMinos(const FCNBase&, const FunctionMinimum&); Construct an MnMinos object from the user’s \(\mbox{FCN}\) and a valid FunctionMinimum. Additional constructors for user specific MnStrategy settings ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:49941,SIMPL,SIMPLEX,49941,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['SIMPL'],['SIMPLEX']
Usability,"tons.py'.; An introduction to mixture models can be found here https://arxiv.org/pdf/1506.02169.; A short summary: We assume the whole probability distribution can be written as a mixture of several components, i.e. $$p(x|\theta)= \sum_{c}w_{c}(\theta)p_{c}(x|\theta)$$ We can write the likelihood ratio in terms of pairwise classification problems \begin{align*} \frac{p(x|\mu)}{p(x|0)}&= \frac{\sum_{c}w_{c}(\mu)p_{c}(x|\mu)}{\sum_{c'}w_{c'}(0)p_{c'}(x|0)}\ &=\sum_{c}\Bigg[\sum_{c'}\frac{w_{c'}(0)}{w_{c}(\mu)}\frac{p_{c'}(x|0)}{p_{c}(x|\mu)}\Bigg]^{-1}, \end{align*} where mu is the signal strength, and a value of 0 corresponds to the background hypothesis. Using this decomposition, one is able to use the pairwise likelihood ratios.; Since the only free parameter in our case is mu, the distributions are independent of this parameter and the dependence on the signal strength can be encoded into the weights. Thus, the subratios simplify dramatically since they are independent of theta and these ratios can be pre-computed and the classifier does not need to be parametrized.; If you wish to see an analysis done with template histograms see 'hf001_example.py'.; ; import ROOT; import os; import numpy as np; import xgboost as xgb; ; # Get Dataframe from tutorial df106_HiggsToFourLeptons.py; # Adjust the path if running locally; df = ROOT.RDataFrame(""tree"", ROOT.gROOT.GetTutorialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root""); ; # Initialize a dictionary to store counts and weight sums for each category; results = {}; ; ; # Extract the relevant columns once and avoid repeated calls; data_dict = df.AsNumpy(columns=[""m4l"", ""sample_category"", ""weight""]); ; ; weights_dict = {; name: data_dict[""weight""][data_dict[""sample_category""] == [name]].sum() for name in (""data"", ""zz"", ""other"", ""higgs""); }; ; # Loop over each sample category; for sample_category in [""data"", ""higgs"", ""zz"", ""other""]:; ; weight_sum = weights_dict[sample_category]; ; mask = data_dict[""sample_category""]",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf618__mixture__models_8py.html:1673,simpl,simplify,1673,doc/master/rf618__mixture__models_8py.html,https://root.cern,https://root.cern/doc/master/rf618__mixture__models_8py.html,1,['simpl'],['simplify']
Usability,"tor *nav = array->SetCurrentNavigator(index);; 860 if (!nav) {; 861 Error(""SetCurrentNavigator"", ""Navigator %d not existing for this thread\n"", index);; 862 std::cout << "" thread id: "" << threadId << std::endl;; 863 return kFALSE;; 864 }; 865 if (!fMultiThread); 866 fCurrentNavigator = nav;; 867 return kTRUE;; 868}; 869 ; 870////////////////////////////////////////////////////////////////////////////////; 871/// Set the lock for navigators.; 872 ; 873void TGeoManager::SetNavigatorsLock(Bool_t flag); 874{; 875 fgLockNavigators = flag;; 876}; 877 ; 878////////////////////////////////////////////////////////////////////////////////; 879/// Clear all navigators.; 880 ; 881void TGeoManager::ClearNavigators(); 882{; 883 if (fMultiThread); 884 fgMutex.lock();; 885 TGeoNavigatorArray *arr = nullptr;; 886 for (NavigatorsMap_t::iterator it = fNavigators.begin(); it != fNavigators.end(); ++it) {; 887 arr = (*it).second;; 888 if (arr); 889 delete arr;; 890 }; 891 fNavigators.clear();; 892 if (fMultiThread); 893 fgMutex.unlock();; 894}; 895 ; 896////////////////////////////////////////////////////////////////////////////////; 897/// Clear a single navigator.; 898 ; 899void TGeoManager::RemoveNavigator(const TGeoNavigator *nav); 900{; 901 if (fMultiThread); 902 fgMutex.lock();; 903 for (NavigatorsMap_t::iterator it = fNavigators.begin(); it != fNavigators.end(); ++it) {; 904 TGeoNavigatorArray *arr = (*it).second;; 905 if (arr) {; 906 if ((TGeoNavigator *)arr->Remove((TObject *)nav)) {; 907 delete nav;; 908 if (!arr->GetEntries()); 909 fNavigators.erase(it);; 910 if (fMultiThread); 911 fgMutex.unlock();; 912 return;; 913 }; 914 }; 915 }; 916 Error(""Remove navigator"", ""Navigator %p not found"", nav);; 917 if (fMultiThread); 918 fgMutex.unlock();; 919}; 920 ; 921////////////////////////////////////////////////////////////////////////////////; 922/// Set maximum number of threads for navigation.; 923 ; 924void TGeoManager::SetMaxThreads(Int_t nthreads); 925{; 926 if (!fClosed) {; 927 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:32979,clear,clear,32979,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['clear'],['clear']
Usability,"tor Documentation. ◆ TStatsFeedback(). TStatsFeedback::TStatsFeedback ; (; TProof * ; proof = 0). Constructor. ; Definition at line 39 of file TStatsFeedback.cxx. ◆ ~TStatsFeedback(). TStatsFeedback::~TStatsFeedback ; (; ). override . Destructor. ; Definition at line 63 of file TStatsFeedback.cxx. Member Function Documentation. ◆ Class(). static TClass * TStatsFeedback::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TStatsFeedback::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TStatsFeedback::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 44 of file TStatsFeedback.h. ◆ DeclFileName(). static const char * TStatsFeedback::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 44 of file TStatsFeedback.h. ◆ Feedback(). void TStatsFeedback::Feedback ; (; TList * ; objs). Display feedback. ; Definition at line 74 of file TStatsFeedback.cxx. ◆ GetName(). const char * TStatsFeedback::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 41 of file TStatsFeedback.h. ◆ Hash(). ULong_t TStatsFeedback::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStatsFeedback.html:15754,feedback,feedback,15754,doc/master/classTStatsFeedback.html,https://root.cern,https://root.cern/doc/master/classTStatsFeedback.html,1,['feedback'],['feedback']
Usability,"tor code to; component p.d.f that would generate the given observable. RooArgSet* findPdfNSet(RooAbsPdf& pdf) const; Look up user specified normalization set for given input PDF component. RooArgSet* getConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected) const; Return all parameter constraint p.d.f.s on parameters listed in constrainedParams; The observables set is required to distinguish unambiguously p.d.f in terms; of observables and parameters, which are not constraints, and p.d.fs in terms; of parameters only, which can serve as constraints p.d.f.s. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t stripDisconnected) const. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of conditional product terms. void fixRefRange(const char* rangeName). std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProdPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooProdPdf(*this,newname) ; }. Bool_t selfNormalized() const; { return _selfNorm ; }. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; { return _pdfList ; }. void setSelfNormalized(Bool_t flag); { _selfNorm = flag ; }. void setDefNormSet(const RooArgSet& nset); { _defNormSet.removeAll() ; _defNormSet.addClone(nset) ; }. void useDefaultGen(Bool_t flag = kTRUE); { _useDefaultGen = flag ; }. » Last changed: Tue Nov 23 08:51:28 2010 » Last generated: 2010-11-23 08:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProdPdf.html:55322,intuit,intuitively,55322,root/html528/RooProdPdf.html,https://root.cern,https://root.cern/root/html528/RooProdPdf.html,1,['intuit'],['intuitively']
Usability,"tor settings. ; Definition at line 2531 of file TSessionViewer.cxx. ◆ OnBtnAbort(). void TSessionQueryFrame::OnBtnAbort ; (; ). Abort processing query. ; Definition at line 3070 of file TSessionViewer.cxx. ◆ OnBtnFinalize(). void TSessionQueryFrame::OnBtnFinalize ; (; ). Finalize query. ; Definition at line 2954 of file TSessionViewer.cxx. ◆ OnBtnRetrieve(). void TSessionQueryFrame::OnBtnRetrieve ; (; ). Retrieve query. ; Definition at line 3018 of file TSessionViewer.cxx. ◆ OnBtnShowLog(). void TSessionQueryFrame::OnBtnShowLog ; (; ). Show query log. ; Definition at line 3004 of file TSessionViewer.cxx. ◆ OnBtnStop(). void TSessionQueryFrame::OnBtnStop ; (; ). Stop processing query. ; Definition at line 2984 of file TSessionViewer.cxx. ◆ OnBtnSubmit(). void TSessionQueryFrame::OnBtnSubmit ; (; ). Submit query. ; Definition at line 3090 of file TSessionViewer.cxx. ◆ Progress() [1/3]. void TSessionQueryFrame::Progress ; (; Long64_t ; total, . Long64_t ; processed . ). Update progress bar and status labels. ; Definition at line 2615 of file TSessionViewer.cxx. ◆ Progress() [2/3]. void TSessionQueryFrame::Progress ; (; Long64_t ; total, . Long64_t ; processed, . Long64_t ; bytesread, . Float_t ; initTime, . Float_t ; procTime, . Float_t ; evtrti, . Float_t ; mbrti . ). inline . Definition at line 428 of file TSessionViewer.h. ◆ Progress() [3/3]. void TSessionQueryFrame::Progress ; (; Long64_t ; total, . Long64_t ; processed, . Long64_t ; bytesread, . Float_t ; initTime, . Float_t ; procTime, . Float_t ; evtrti, . Float_t ; mbrti, . Int_t ; actw, . Int_t ; tses, . Float_t ; eses . ). New version of Progress (just forward to the old version for the time being). ; Definition at line 2733 of file TSessionViewer.cxx. ◆ ProgressLocal(). void TSessionQueryFrame::ProgressLocal ; (; Long64_t ; total, . Long64_t ; processed . ). Update progress bar and status labels. ; Definition at line 2745 of file TSessionViewer.cxx. ◆ ResetProgressDialog(). void TSessionQueryFrame::ResetProgr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionQueryFrame.html:36436,progress bar,progress bar,36436,doc/master/classTSessionQueryFrame.html,https://root.cern,https://root.cern/doc/master/classTSessionQueryFrame.html,1,['progress bar'],['progress bar']
Usability,"tor& insp); virtual voidSlaveBegin(TTree*); virtual voidTProofDraw::SlaveTerminate(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTerminate(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual intTProofDraw::Version() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidBegin1D(TTree* t); virtual voidBegin2D(TTree* t); virtual voidBegin3D(TTree* t); virtual voidTProofDraw::ClearFormula(); virtual Bool_tTProofDraw::CompileVariables(); virtual voidDefVar(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoFill(Long64_t entry, Double_t w, const Double_t* v); voidTProofDraw::FillWeight(); voidTObject::MakeZombie(); virtual Bool_tTProofDraw::ProcessSingle(Long64_t, Int_t); voidTProofDraw::SetCanvas(const char* objname); voidTProofDraw::SetDrawAtt(TObject* o); voidTProofDraw::SetError(const char* sub, const char* mesg). private:. voidDefVar1D(); voidDefVar2D(); voidDefVar3D(). Data Members; public:. enum TProofDraw::[unnamed] { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tTProofDraw::fDimensionDimension of the current expression; TH1*fHistogram; TStringTProofDraw::fInitialExp; TList*TSelector::fInputlist of objects available during processing; TTr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofDrawHist.html:5809,Clear,ClearFormula,5809,root/html532/TProofDrawHist.html,https://root.cern,https://root.cern/root/html532/TProofDrawHist.html,1,['Clear'],['ClearFormula']
Usability,"tor. ;  ; virtual ~TQCommand ();  dtor. ;  ; void Add (TObject *obj) override;  ; void Add (TObject *obj, Option_t *opt) override;  Add command to the list of merged commands. ;  ; virtual Bool_t CanCompress (TQCommand *c) const;  By default, commands can be compressed if they are: ;  ; virtual Bool_t CanMerge (TQCommand *c) const;  Two commands can be merged if they can be composed into a single command (Macro command). ;  ; virtual Bool_t CanRedo () const;  Returns kTRUE if Redo action is possible, kFALSE if it's not. ;  ; virtual Bool_t CanUndo () const;  Returns kTRUE if Undo action is possible, kFALSE if it's not. ;  ; virtual void Compress (TQCommand *c);  Compress command. ;  ; void Delete (Option_t *option="""") override;  If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ;  ; const char * GetName () const override;  Returns the command name. ;  ; Int_t GetNRargs () const;  Returns a number of redo arguments. ;  ; Int_t GetNUargs () const;  Returns a number of undo arguments. ;  ; void * GetObject () const;  Returns an object for which undo redo actions are applied. ;  ; TQConnection * GetRedo () const;  ; Long_t * GetRedoArgs () const;  Returns a pointer to array of redo arguments. ;  ; const char * GetRedoName () const;  Returns the name of redo command. ;  ; Int_t GetStatus () const;  Returns a number of sequential undo or redo operations. ;  ; const char * GetTitle () const override;  Returns command description. ;  ; TQConnection * GetUndo () const;  ; Long_t * GetUndoArgs () const;  Returns a pointer to array of undo arguments. ;  ; const char * GetUndoName () const;  Returns the name of undo command. ;  ; TClass * IsA () const override;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison. ;  ; Bool_t IsExecuting () const;  Returns kTRUE if command execution is in progress. ;  ; Bool_t IsMacro () const;  Returns kTRUE if neither redo nor undo action specified. ;  ; Bool_t IsRedoing () const;  Red",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:6002,undo,undo,6002,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"tor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero delete every merged command which option string is; equal to ""opt"". If ""opt"" is zero - delete all merged commands. Bool_t CanMerge(TQCommand* c) const; Two commands can be merged if they can be composed into; a single command",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:18932,undo,undo,18932,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,10,['undo'],['undo']
Usability,"tor. void * NewArray(Int_t nElements) const; Return a new container object. void * NewArray(Int_t nElements, void* arena) const; Execute the container constructor. void Destructor(void* p, Bool_t dtorOnly = kFALSE) const; Execute the container destructor. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; Execute the container array destructor. UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objectstart); Set the address of the container being proxied and keep track of the previous one. void PopProxy(); Reset the address of the container being proxied to the previous container. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass() const; Return a pointer to the TClass representing the content. EDataType GetType() const; If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete). void Commit(void* ). char * operator[](UInt_t idx) const; { return (char*)(const_cast<TVirtualCollectionProxy*>(this))->At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. CopyIterator",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualCollectionProxy.html:4624,Clear,Clear,4624,root/html534/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TVirtualCollectionProxy.html,2,['Clear'],['Clear']
Usability,"tor. void * NewArray(Int_t nElements) const; Return a new container object. void * NewArray(Int_t nElements, void* arena) const; Execute the container constructor. void Destructor(void* p, Bool_t dtorOnly = kFALSE) const; Execute the container destructor. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; Execute the container array destructor. UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objectstart); Set the address of the container being proxied and keep track of the previous one. void PopProxy(); Reset the address of the container being proxied to the previous container. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass() const; Return a pointer to the TClass representing the content. EDataType GetType() const; If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete). void Commit(void* ). void Insert(const void* data, void* container, size_t size); Insert data into the container where data is a C-style array of the actual type contained in the collection; of the given size. For associative container (map, etc.), the data type is the pair<key,value>. char * operator[](UInt_t idx) const; { return (char*)(const_cast<TVirtualCollectionProxy*>(this))->At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualCollectionProxy.html:5073,Clear,Clear,5073,root/html602/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TVirtualCollectionProxy.html,4,['Clear'],['Clear']
Usability,"tor< Float_t > * fMulticlassReturnVal;  ; Int_t fNbins;  ; Int_t fNbinsH;  ; Int_t fNbinsMVAoutput;  ; Ranking * fRanking;  ; std::vector< Float_t > * fRegressionReturnVal;  ; Results * fResults;  ; UInt_t fSignalClass;  ; DataSet * fTmpData = nullptr;  temporary event when testing on a different DataSet than the own one ;  ; const Event * fTmpEvent;  ;  Protected Attributes inherited from TMVA::Configurable; MsgLogger * fLogger;  ! message logger ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Member Functions; void AddPreLinks (TNeuron *neuron, TObjArray *prevLayer);  add synapses connecting a neuron to its preceding layer ;  ; void BuildLayer (Int_t numNeurons, TObjArray *curLayer, TObjArray *prevLayer, Int_t layerIndex, Int_t numLayers, Bool_t from_file=false);  build a single layer with neurons and synapses connecting this layer to the previous layer ;  ; void BuildLayers (std::vector< Int_t > *layout, Bool_t from_file=false);  build the network layers ;  ; void DeleteNetwork ();  delete/clear network ;  ; void DeleteNetworkLayer (TObjArray *&layer);  delete a network layer ;  ; void ForceWeights (std::vector< Double_t > *weights);  force the synapse weights ;  ; void InitWeights ();  initialize the synapse weights randomly ;  ; void PrintLayer (TObjArray *layer) const;  print a single layer, for debugging ;  ; void PrintNeuron (TNeuron *neuron) const;  print a neuron, for debugging ;  . Private Attributes; TObjArray * fInputLayer;  cache this for fast access ;  ; TString fLayerSpec;  layout specification option ;  ; std::vector< TNeuron * > fOutputNeurons;  cache this for fast access ;  . Static Private Attributes; static const Bool_t fgDEBUG = kTRUE;  debug flag ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TMVA/MethodANNBase.h>. Inheritance diagram for TMVA::MethodANNBase:. This browser is not able to show SVG: try Firefox, Ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodANNBase.html:31118,clear,clear,31118,doc/master/classTMVA_1_1MethodANNBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodANNBase.html,1,['clear'],['clear']
Usability,"tor=(const TMVA::RegressionVariance&); TMVA::RegressionVarianceRegressionVariance(); TMVA::RegressionVarianceRegressionVariance(const TMVA::RegressionVariance& s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationGain(const Double_t& nLeft, const Double_t& targetLeft, const Double_t& target2Left, const Double_t& nTot, const Double_t& targetTot, const Double_t& target2Tot); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system; for the Regression: as the ""Gain is maximised"", the RMS (sqrt(variance)); which is used as a ""separation"" index should be as small as possible.; the ""figure of merit"" here has to be -(rms left+rms-right) or 1/rms... Double_t GetSeparationIndex(const Double_t& n, const Double_t& target, const Double_t& target2); Separation Index: a simple Variance. RegressionVariance(); default constructor. {fName = ""Variance for Regression"";}. RegressionVariance(const TMVA::RegressionVariance& s); copy constructor. {}. virtual ~RegressionVariance(); destructor. {}. TString GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: RegressionVariance.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__RegressionVariance.html:2082,simpl,simple,2082,root/html530/TMVA__RegressionVariance.html,https://root.cern,https://root.cern/root/html530/TMVA__RegressionVariance.html,1,['simpl'],['simple']
Usability,"torDraw::SplitNames(const TString& varexp, vector<TString>& names); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTSelectorDraw::TakeAction(); virtual voidTSelectorDraw::TakeEstimate(); virtual voidTSelectorDraw::Terminate(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TEveSelectorToEventList(TEventList* evl, const char* sel); virtual voidTObject::UseCurrentStyle(); virtual Int_tVersion() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTSelectorDraw::ClearFormula(); virtual Bool_tTSelectorDraw::CompileVariables(const char* varexp = """", const char* selection = """"); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTSelectorDraw::InitArrays(Int_t newsize); voidTObject::MakeZombie(). private:. TEveSelectorToEventList&operator=(const TEveSelectorToEventList&); TEveSelectorToEventList(const TEveSelectorToEventList&). Data Members; public:. static TSelector::EAbortTSelector::kAbortFile; static TSelector::EAbortTSelector::kAbortProcess; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TSelector::EAbortTSelector::kContinue; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveSelectorToEventList.html:7300,Clear,ClearFormula,7300,root/html602/TEveSelectorToEventList.html,https://root.cern,https://root.cern/root/html602/TEveSelectorToEventList.html,2,['Clear'],['ClearFormula']
Usability,"tor[](pos);; 1311 }; 1312 ; 1313 /// No exception thrown. The user specifies the desired value in case the RVecN is shorter than `pos`.; 1314 value_type at(size_type pos, value_type fallback) const; 1315 {; 1316 if (pos >= size_type(this->fSize)); 1317 return fallback;; 1318 return this->operator[](pos);; 1319 }; 1320};; 1321 ; 1322// clang-format off; 1323/**; 1324\class ROOT::VecOps::RVec; 1325\brief A ""std::vector""-like collection of values implementing handy operation to analyse them; 1326\tparam T The type of the contained objects; 1327 ; 1328A RVec is a container designed to make analysis of values' collections fast and easy.; 1329Its storage is contiguous in memory and its interface is designed such to resemble to the one; 1330of the stl vector. In addition the interface features methods and; 1331[external functions](https://root.cern/doc/master/namespaceROOT_1_1VecOps.html) to ease the manipulation and analysis; 1332of the data in the RVec.; 1333 ; 1334\note ROOT::VecOps::RVec can also be spelled simply ROOT::RVec. Shorthand aliases such as ROOT::RVecI or ROOT::RVecD; 1335are also available as template instantiations of RVec of fundamental types. The full list of available aliases:; 1336- RVecB (`bool`); 1337- RVecC (`char`); 1338- RVecD (`double`); 1339- RVecF (`float`); 1340- RVecI (`int`); 1341- RVecL (`long`); 1342- RVecLL (`long long`); 1343- RVecU (`unsigned`); 1344- RVecUL (`unsigned long`); 1345- RVecULL (`unsigned long long`); 1346 ; 1347\note RVec does not attempt to be exception safe. Exceptions thrown by element constructors during insertions, swaps or; 1348other operations will be propagated potentially leaving the RVec object in an invalid state.; 1349 ; 1350\note RVec methods (e.g. `at` or `size`) follow the STL naming convention instead of the ROOT naming convention in order; 1351to make RVec a drop-in replacement for `std::vector`.; 1352 ; 1353\htmlonly; 1354<a href=""https://doi.org/10.5281/zenodo.1253756""><img src=""https://zenodo.org/badge/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:46111,simpl,simply,46111,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['simpl'],['simply']
Usability,"torage provider that writes ntuple pages to into a DAOS container. More...;  ; class  RPageSinkFile;  Storage provider that write ntuple pages into a file. More...;  ; class  RPageSource;  Abstract interface to read data from an ntuple. More...;  ; class  RPageSourceDaos;  Storage provider that reads ntuple pages from a DAOS container. More...;  ; class  RPageSourceFile;  Storage provider that reads ntuple pages from a file. More...;  ; class  RPageSourceFriends;  Virtual storage that combines several other sources horizontally. More...;  ; class  RPageStorage;  Common functionality of an ntuple storage for both reading and writing. More...;  ; class  RProjectedFields;  The projected fields of a RNTupleModel More...;  ; class  RRDFCardinalityField;  An artificial field that transforms an RNTuple column that contains the offset of collections into collection sizes. More...;  ; struct  RSealedPageMergeData;  ; struct  RTestFutureColumn;  ; struct  RTFileControlBlock;  If a TFile container is written by a C stream (simple file), on dataset commit, the file header and the TFile record need to be updated. More...;  ; struct  RVirtualBinsToLocalBins;  Recursively converts zero-based virtual bins where the underflow bin has index 0 and the overflow bin has index N+1 where N is the axis' number of regular bins, to the standard kUnderflowBin/kOverflowBin for under/overflow bin indexing convention. More...;  ; struct  RVirtualBinsToLocalBins<-1, NDIMS, BINS, AXES >;  ; class  RVirtualCanvasPainter;  Abstract interface for painting a canvas. More...;  ; class  RWritePageMemoryManager;  Helper to maintain a memory budget for the write pages of a set of columns. More...;  ; class  TBulkBranchRead;  Helper class for reading many branch entries at once to optimize throughput. More...;  ; class  TTreeReaderValueFastBase;  . Typedefs; using ntuple_index_t = std::uint32_t;  ; using RIOSharedVector_t = std::vector< RIOSharedBase * >;  . Enumerations; enum class  EColumnCppType { ;   kC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html:9523,simpl,simple,9523,doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,1,['simpl'],['simple']
Usability,"tore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo2DKeysPdf.html:2685,clear,clearEvalErrorLog,2685,root/html532/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html532/Roo2DKeysPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"tore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/Roo2DKeysPdf.html:2685,clear,clearEvalErrorLog,2685,root/html528/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html528/Roo2DKeysPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"tore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/Roo2DKeysPdf.html:2685,clear,clearEvalErrorLog,2685,root/html530/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html530/Roo2DKeysPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"tore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Roo2DKeysPdf.html:2606,clear,clearShapeDirty,2606,root/html526/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html526/Roo2DKeysPdf.html,1,['clear'],['clearShapeDirty']
Usability,"tore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealSumPdf.html:3219,clear,clearShapeDirty,3219,root/html528/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html528/RooRealSumPdf.html,1,['clear'],['clearShapeDirty']
Usability,"tore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddPdf.html:3891,clear,clearShapeDirty,3891,root/html528/RooAddPdf.html,https://root.cern,https://root.cern/root/html528/RooAddPdf.html,3,['clear'],['clearShapeDirty']
Usability,"tore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProdPdf.html:4337,clear,clearShapeDirty,4337,root/html528/RooProdPdf.html,https://root.cern,https://root.cern/root/html528/RooProdPdf.html,2,['clear'],['clearShapeDirty']
Usability,"tore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProdPdf.html:3192,clear,clearEvalError,3192,root/html602/RooProdPdf.html,https://root.cern,https://root.cern/root/html602/RooProdPdf.html,4,['clear'],['clearEvalError']
Usability,"tore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeDataStore.html:17567,clear,clear,17567,root/html532/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html,2,['clear'],['clear']
Usability,"toring > ptrMonitoring);  prepared for monitoring ;  ; virtual void setProgressLimits (double minProgress=0, double maxProgress=100);  ; virtual void startTestCycle ();  callback for monitoring and loggging ;  ; virtual void startTrainCycle ();  ; virtual void startTraining ();  ; virtual void testIteration ();  callback for monitoring and loggging ;  ; size_t testRepetitions () const;  how often is the test data tested ;  ; virtual void testSample (double, double, double, double);  virtual function to be used for monitoring (callback) ;  ; bool useMultithreading () const;  is multithreading turned on? ;  . Public Attributes; size_t count_dE;  ; size_t count_E;  ; size_t count_mb_dE;  ; size_t count_mb_E;  ; double fLearningRate;  ; MinimizerType fMinimizerType;  ; double fMomentum;  ; int fRepetitions;  ; size_t m_batchSize;  mini-batch size ;  ; size_t m_convergenceCount;  ; size_t m_convergenceSteps;  number of steps without improvement to consider the DNN to have converged ;  ; std::vector< double > m_dropOut;  ; double m_dropRepetitions;  ; double m_factorWeightDecay;  ; size_t m_maxConvergenceCount;  ; double m_maxProgress;  current limits for the progress bar ;  ; double m_minError;  ; double m_minProgress;  current limits for the progress bar ;  ; EnumRegularization m_regularization;  ; size_t m_testRepetitions;  ; Timer m_timer;  timer for monitoring ;  . Protected Attributes; std::shared_ptr< Monitoring > fMonitoring;  ; bool m_useMultithreading;  . #include <TMVA/NeuralNet.h>. Inheritance diagram for TMVA::DNN::Settings:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ Settings(). TMVA::DNN::Settings::Settings ; (; TString ; name, . size_t ; _convergenceSteps = 15, . size_t ; _batchSize = 10, . size_t ; _testRepetitions = 7, . double ; _factorWeightDecay = 1e-5, . TMVA::DNN::EnumRegularization ; _regularization = TMVA::DNN::EnumRegularization::NONE, . MinimizerType ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:4329,progress bar,progress bar,4329,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,2,['progress bar'],['progress bar']
Usability,"toryvirtual Bool_t ChangeDirectory(const char *path)Change directory.Definition TSystem.cxx:862; TSystem::GetBuildCompilerVersionStrvirtual const char * GetBuildCompilerVersionStr() constReturn the build compiler version identifier string.Definition TSystem.cxx:3899; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::GetBuildArchvirtual const char * GetBuildArch() constReturn the build architecture.Definition TSystem.cxx:3875; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TTabComDefinition TTabCom.h:52; TTabCom::HookInt_t Hook(char *buf, int *pLoc, std::ostream &out)[private]Definition TTabCom.cxx:1567; TTabCom::ClearAllvoid ClearAll()clears all lists except for user names and system include files.Definition TTabCom.cxx:319; TTermInputHandlerDefinition TRint.cxx:121; TTermInputHandler::TTermInputHandlerTTermInputHandler(Int_t fd)Definition TRint.cxx:123; TTermInputHandler::ReadNotifyBool_t ReadNotify() overrideNotify when something can be read from the descriptor associated with this handler.Definition TRint.cxx:125; TTermInputHandler::NotifyBool_t Notify() overrideNotify implementation. Call the application interupt handler.Definition TRint.cxx:131; bool; int; lineTLine * lineDefinition entrylistblock_figure1.C:235; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::gMmallocDescR__EXTERN void * gMmallocDescDefinition TStorage.h:143; TClassEdit::DemangleTypeIdNamechar * DemangleTypeIdName(const std::type_info &ti, int &errorCode)Demangle in a portable way the type id name.Definition TClassEdit.cxx:2148. corerintsrcTRint.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:12 (GVA Time) using Doxygen 1.9.8  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:44407,clear,clears,44407,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,1,['clear'],['clears']
Usability,"tour computations in RooMinimizer[ROOT-7290]. Dictionary Generation. Uniform style of warnings, use standard ROOT logging facilities rather than cout/cerr.; Do not add as autoparse keys stl classes, stl (nested) containers templated with plain old data or integers. Tree. TTreeReaderArray now supports vector<builtin-type>. Graphics. Fix file corruption in TTeXDump::DrawPolyMarker.; Make sure the line width used to draw #sqrt is always >=1. Release 6.04/04; Build System. Fix generation of PCH with CXX flags with spaces ROOT-7478; Implemented option ‘geocad’ with CMake making use of the OpenCASCADE software package.; Fix option ‘rpath’ for CMake and ensure that works for MacOSX 10.11. Core. Fix the location of include files in ROOTINCDIR/include instead of ROOTINCDIR ROOT-7537. Interpreter. Fix redirection ROOT-7053; Take the language and target options from the PCH ROOT-7478 ROOT-6966; Properly recover from a template instantiation failure when looking up a class in the interpreter ROOT-7462; Do not clear pending instantiations upon unloading; fixes missing symbols due to missing function bodies ROOT-7586; Speed up significantly cling’s findType and remove its memory cost in most cases.; Make sure object declared on the interpreter stack are deleted at the end of the process ROOT-7673; Resolve issues with error recovery when the transaction includes template instantiation.; Fix handling of argument that negative integers in TClingCallFunc ROOT-7684. I/O. Fix memory leak in handling of I/O customization rules ROOT-7683; Set CheckSum of StreamerInfo of user classes that have a collection proxy. Tree. Fix ROOT-6885 which affects very large TChain with friend trees.; Fix ROOT-7423 which can stop the TTreeCache from stopping the learning phase when asynchronous prefetching is enabled. TTreeReader. Fix reading of data members of type BasicType[42]; Fix support for large file ROOT-7652. Geom. Fix missing OCC header file for the version ROOT-7536. Bugs. [ROOT-6419] - ROOT-6.00",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:29221,clear,clear,29221,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['clear'],['clear']
Usability,"toy data; without weight. SamplingDistribution* AppendSamplingDistribution(RooArgSet& allParameters, RooStats::SamplingDistribution* last, Int_t additionalMC); Extended interface to append to sampling distribution more samples. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& nullPOI); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; { return fTestStat; }. Double_t ConfidenceLevel() const; { return 1. - fSize; }. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); { return fNToys; }. void SetNToys(const Int_t ntoy); { fNToys = ntoy; }. void SetNEventsPerToy(const Int_t nevents); Forces n events even for extended PDFs. Set NEvents=0 to; use the Poisson distributed events from the extended PDF. void SetParametersForTestStat(const RooArgSet& nullpoi); specify the values of parameters used when evaluating test statistic. void SetPdf(RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. { fPdf = &pdf; ClearCache(); }. void SetPriorNuisance(RooAbsPdf* pdf); How to randomize the prior. Set to NULL to deactivate randomization. { fPriorNuisance = pdf; }. void SetNuisanceParameters(const RooArgSet& np); specify the nuisance parameters (eg. the rest of the parameters). { fNuisancePars = &np; }. void SetObservables(const RooArgSet& o); specify the observables in the dataset (needed to evaluate the test statistic). { fObservables = &o; }. void SetGlobalObservables(const RooArgSet& o); specify the conditional observables. { fGlobalObservables = &o; }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). { fSize = size; }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { fSize = 1. - cl; }. void SetTestStatistic(RooStats::TestStatistic* testStatistic); Set the TestStatistic (want the argument to be a function of the data & parameter points. { fTestS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__ToyMCSampler.html:8125,Clear,ClearCache,8125,root/html532/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html532/RooStats__ToyMCSampler.html,1,['Clear'],['ClearCache']
Usability,"tr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; value_type evaluate () const override;  Calculate and return the value of the mapping function. ;  ; void initialize (const char *catTypeName=nullptr);  Iterator over all bins in input variable and define corresponding state labels. ;  ; void recomputeShape () override;  The shape of this category does not need to be recomputed, as it creates states on the fly. ;  ;  Protected Member Functions inherited from RooAbsCategory; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValueDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not check if type already exists. ;  ; void fillTreeBranch (TTree &t) override;  Fill tree branches associated with current object with current value. ;  ; bool isValid () const override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; RooCatType * retrieveLegacyState (value_ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinningCategory.html:35382,clear,clearTypes,35382,doc/master/classRooBinningCategory.html,https://root.cern,https://root.cern/doc/master/classRooBinningCategory.html,1,['clear'],['clearTypes']
Usability,"tr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from a systematic variation of the response matrix ; Parameters. [in,out]ematrixcovariance matrix histogram ; [in]nameidentifier of the systematic variation ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram prior to adding the covariance matrix contribution. Returns the covariance matrix contribution from shifting the given uncertainty source within one sigma ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1113 of file TUnfoldSys.cxx. ◆ GetEmatrixSysTau(). void TUnfoldSys::GetEmatrixSysTau ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance matrix contribution from error on regularisation parameter ; Parameters. [in,out]ematrixoutput histogram ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result from the assigned uncertainty on the parameter tau, see method SetTauError(). ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1176 of file TUnfoldSys.cxx. ◆ GetEmatrixSysUncorr(). void TUnfoldSys::GetEmatrixSysUncorr ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). Covariance contribution from uncorrelated uncertainties of the response matrix. ; Parameters. [in,out]ematrixcovariance matrix histogram ; [in]binMapmapping of histogram bins ; [in]clearEmatif true, ematrix is cleared prior to adding this covariance matrix contribution. This method propagates the uncertainties of the response matrix histogram, specified with the constructor, to the unfolding result. It is assumed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:41261,clear,clearEmat,41261,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,2,['clear'],"['clear', 'clearEmat']"
Usability,"tr;  ; static UInt_t fgUserColor = 0;  ; static const TGGC * fgWhiteGC = nullptr;  ; static Pixel_t fgWhitePixel = 0;  ;  Static Protected Attributes inherited from TGWindow; static Int_t fgCounter = 0;  counter of created windows in SavePrimitive ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TGProgressBar.h>. Inheritance diagram for TGHProgressBar:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGHProgressBar() [1/2]. TGHProgressBar::TGHProgressBar ; (; const TGWindow * ; p = nullptr, . UInt_t ; w = 4, . UInt_t ; h = kProgressBarTextWidth, . Pixel_t ; back = GetWhitePixel(), . Pixel_t ; barcolor = GetDefaultSelectedBackground(), . GContext_t ; norm = GetDefaultGC()(), . FontStruct_t ; font = GetDefaultFontStruct(), . UInt_t ; options = kDoubleBorder | kSunkenFrame . ). Horizontal progress bar constructor. ; Definition at line 223 of file TGProgressBar.cxx. ◆ TGHProgressBar() [2/2]. TGHProgressBar::TGHProgressBar ; (; const TGWindow * ; p, . EBarType ; type, . UInt_t ; w . ). Simple constructor allow you to create either a standard progress bar, or a more fancy progress bar (fancy means: double sized border, white background and a bit wider to allow for text to be printed in the bar. ; Definition at line 238 of file TGProgressBar.cxx. ◆ ~TGHProgressBar(). TGHProgressBar::~TGHProgressBar ; (; ). inlineoverride . Definition at line 108 of file TGProgressBar.h. Member Function Documentation. ◆ Class(). static TClass * TGHProgressBar::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGHProgressBar::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGHProgressBar::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 118 of file TGPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHProgressBar.html:31793,progress bar,progress bar,31793,doc/master/classTGHProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGHProgressBar.html,1,['progress bar'],['progress bar']
Usability,"tra in suitable visual form; This package has several display mode groups and display modes, which can be; employed for the presentation of 2-dimensional histograms; Display modes groups:. kModeGroupSimple - it covers simple display modes using one; color only; kModeGroupLight - in this group the shading is carried out; according to the position of the fictive; light source; kModeGroupHeight - in this group the shading is carried out; according to the channel contents; kModeGroupLightHeight - combination of two previous shading; algorithms. One can control the weight; between both algorithms. Display modes:. kDisplayModePoints, ; kDisplayModeGrid, ; kDisplayModeContours,; kDisplayModeBars,; kDisplayModeLinesX,; kDisplayModeLinesY,; kDisplayModeBarsX,; kDisplayModeBarsY,; kDisplayModeNeedles,; kDisplayModeSurface,; kDisplayModeTriangles. one can combine the above given modes groups and display modes. The meaningful; combinations (denoted by x) are given in the next table. SimpleLightHeightLight-Height. Points XXXX; Grid XXXX; Contours X-X-; Bars X-X-; LinesX XXXX; LinesY XXXX; BarsX X-X-; BarsY X-X-; Needles X---; Surface -XXX; TrianglesXXXX. Function:; void TSpectrum2Painter::SetDisplayMode (Int_t modeGroup, Int_t displayMode). This function controls the display mode group and display mode of the; histogram drawing. To illustrate the possible effects of the various display; modes we introduce a set of examples. Default values:. modeGroup = kModeGroupLightHeight ; displayMode = kDisplayModeSurface . Simple modes group, display mode = points, 256 x 256 channels. Simple modes group, display mode = grid, 64 x 64 channels. Simple modes group, display mode = contours, 64 x 64 channels. Simple modes group, display mode = bars, 64 x 64 channels. Simple modes group, display mode = linesX, 64 x 64 channels. Simple modes group, display mode = linesY, 64 x 64 channels. Simple modes group, display mode = barsX, 64 x 64 channels. Simple modes group, display mode = barsY, 64 x 64 c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSpectrum2Painter.html:17291,Simpl,SimpleLightHeightLight-Height,17291,root/html532/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html532/TSpectrum2Painter.html,4,['Simpl'],['SimpleLightHeightLight-Height']
Usability,"tractMethod(const char* method) const; voidRooStats::SamplingDistPlot::AddLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2, const char* title = __null); Double_tRooStats::SamplingDistPlot::AddSamplingDistribution(const RooStats::SamplingDistribution* samplingDist, Option_t* drawOptions = ""NORMALIZE HIST""); Double_tRooStats::SamplingDistPlot::AddSamplingDistributionShaded(const RooStats::SamplingDistribution* samplingDist, Double_t minShaded, Double_t maxShaded, Option_t* drawOptions = ""NORMALIZE HIST""); voidRooStats::SamplingDistPlot::AddTF1(TF1* f, const char* title = __null, Option_t* drawOptions = ""SAME""); voidRooStats::SamplingDistPlot::AddTH1(TH1* h, Option_t* drawOptions = """"); virtual voidTObject::AppendPad(Option_t* option = """"); voidApplyDefaultStyle(); voidApplyResult(RooStats::HypoTestResult& result, Option_t* opt = ""NORMALIZE HIST""); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidRooStats::SamplingDistPlot::Draw(Option_t* options = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidRooStats::SamplingDistPlot::DumpToFile(const char* RootFileName, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HypoTestPlot.html:1426,Clear,Clear,1426,root/html602/RooStats__HypoTestPlot.html,https://root.cern,https://root.cern/root/html602/RooStats__HypoTestPlot.html,2,['Clear'],['Clear']
Usability,"traint pdf's will be normalized correctly on the global observables when computing the NLL ; Definition at line 96 of file BayesianCalculator.h. ◆ SetIntegrationType(). void RooStats::BayesianCalculator::SetIntegrationType ; (; const char * ; type). set the integration type (possible type are) : . 1D integration ( used when only one nuisance and when the posterior is scanned): adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration The parameter numIters (settable with SetNumIters) is the max number of function calls. It can be reduced to make the integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC: evaluate posterior by generating toy MC for the nuisance parameters. It is a MC integration, where the function is sampled according to the nuisance. It is convenient to use when all the nuisance are uncorrelated and it is efficient to generate them The toy are generated by default for each poi values (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for each poi value. It can be convenient when the generation time is much larger than the evaluation time, otherwise it is recommended to re-generate the toy for each poi scanned point of the posterior function; ROOFIT: use roofit default integration methods which will produce a nested integral (not recommended for more than 1 nuisance parameters) . Definition at line 1073 of file BayesianCalculator.cxx. ◆ Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html:31090,simpl,simple,31090,doc/master/classRooStats_1_1BayesianCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html,1,['simpl'],['simple']
Usability,"tralIf true, the central moment is given by \( \langle (x- \langle x \rangle )^2 \rangle \) ; [in]takeRootCalculate the square root ; [in]intNormObsIf true, the moment of the function integrated over all normalization observables is returned. . Definition at line 4034 of file RooAbsReal.cxx. ◆ moment() [2/2]. RooAbsMoment * RooAbsReal::moment ; (; RooRealVar & ; obs, . Int_t ; order, . bool ; central, . bool ; takeRoot . ). Return function representing moment of function of given order. ; Parameters. [in]obsObservable to calculate the moments for ; [in]orderOrder of the moment ; [in]centralIf true, the central moment is given by \( \langle (x- \langle x \rangle )^2 \rangle \) ; [in]takeRootCalculate the square root . Definition at line 4015 of file RooAbsReal.cxx. ◆ numEvalErrorItems(). Int_t RooAbsReal::numEvalErrorItems ; (; ). static . Definition at line 176 of file RooAbsReal.cxx. ◆ numEvalErrors(). Int_t RooAbsReal::numEvalErrors ; (; ). static . Return the number of logged evaluation errors since the last clearing. ; Definition at line 3624 of file RooAbsReal.cxx. ◆ offset(). virtual double RooAbsReal::offset ; (; ); const. inlinevirtual . Reimplemented in RooAbsTestStatistic.; Definition at line 371 of file RooAbsReal.h. ◆ operator==() [1/2]. bool RooAbsReal::operator== ; (; const RooAbsArg & ; other); const. overridevirtual . Equality operator when comparing to another RooAbsArg. ; Only functional when the other arg is a RooAbsReal ; Implements RooAbsArg.; Definition at line 261 of file RooAbsReal.cxx. ◆ operator==() [2/2]. bool RooAbsReal::operator== ; (; double ; value); const. Equality operator comparing to a double. ; Definition at line 250 of file RooAbsReal.cxx. ◆ plotAsymOn(). RooPlot * RooAbsReal::plotAsymOn ; (; RooPlot * ; frame, . const RooAbsCategoryLValue & ; asymCat, . PlotOpt ; o . ); const. protectedvirtual . Definition at line 2199 of file RooAbsReal.cxx. ◆ plotOn() [1/3]. RooAbsReal::plotOn ; (; RooPlot * ; frame, . const RooCmdArg & ; arg1 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:126775,clear,clearing,126775,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['clear'],['clearing']
Usability,"tralIf true, the central moment is given by \( \langle (x- \langle x \rangle )^2 \rangle \) ; [in]takeRootCalculate the square root ; [in]intNormObsIf true, the moment of the function integrated over all normalization observables is returned. . Definition at line 4110 of file RooAbsReal.cxx. ◆ moment() [2/2]. RooAbsMoment * RooAbsReal::moment ; (; RooRealVar & ; obs, . Int_t ; order, . bool ; central, . bool ; takeRoot . ). Return function representing moment of function of given order. ; Parameters. [in]obsObservable to calculate the moments for ; [in]orderOrder of the moment ; [in]centralIf true, the central moment is given by \( \langle (x- \langle x \rangle )^2 \rangle \) ; [in]takeRootCalculate the square root . Definition at line 4091 of file RooAbsReal.cxx. ◆ numEvalErrorItems(). Int_t RooAbsReal::numEvalErrorItems ; (; ). static . Definition at line 300 of file RooAbsReal.cxx. ◆ numEvalErrors(). Int_t RooAbsReal::numEvalErrors ; (; ). static . Return the number of logged evaluation errors since the last clearing. ; Definition at line 3701 of file RooAbsReal.cxx. ◆ offset(). virtual double RooAbsReal::offset ; (; ); const. inlinevirtual . Reimplemented in RooAbsTestStatistic.; Definition at line 378 of file RooAbsReal.h. ◆ operator==() [1/2]. bool RooAbsReal::operator== ; (; const RooAbsArg & ; other); const. overridevirtual . Equality operator when comparing to another RooAbsArg. ; Only functional when the other arg is a RooAbsReal ; Implements RooAbsArg.; Definition at line 239 of file RooAbsReal.cxx. ◆ operator==() [2/2]. bool RooAbsReal::operator== ; (; double ; value); const. Equality operator comparing to a double. ; Definition at line 228 of file RooAbsReal.cxx. ◆ plotAsymOn(). RooPlot * RooAbsReal::plotAsymOn ; (; RooPlot * ; frame, . const RooAbsCategoryLValue & ; asymCat, . PlotOpt ; o . ); const. protectedvirtual . Definition at line 2284 of file RooAbsReal.cxx. ◆ plotOn() [1/3]. RooAbsReal::plotOn ; (; RooPlot * ; frame, . const RooCmdArg & ; arg1 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:128105,clear,clearing,128105,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['clear'],['clearing']
Usability,"translation) described by a 3x4 matrix (12 double numbers); ROOT::Math::Translation3D (only translation) described by a 3D Vector. Lorentz rotations and boosts. ROOT::Math::LorentzRotation, 4D rotation (3D rotation plus a boost) described by a 4x4 matrix; ROOT::Math::Boost, a Lorentz boost in an arbitrary direction and described by a 4x4 symmetrix matrix (10 numbers); ROOT::Math::BoostX, a boost in the X axis direction; ROOT::Math::BoostY, a boost in the Y axis direction; ROOT::Math::BoostZ, a boost in the Z axis direction. 13.12.5.1 Constructors; All rotations and transformations are default constructible (giving the identity transformation). All rotations are constructible taking a number of scalar arguments matching the number (and order of components).; Rotation3D rI; //a summy rotation (Identity matrix); RotationX rX(PI); //a RotationX with an angle PI; EulerAngles rE(phi,theta,psi); //an Euler rotation with phi,; //theta,psi angles; XYZVector u(ux,uy,uz);; AxisAngle rA(u,delta); //a rotation based on direction u,; //angle delta; In addition, all rotations and transformations (other than the axial rotations) and transformations are constructible from (begin,end) iterators or from pointers behave like iterators.; double data[9];; //create a rotation from a rotation matrix; Rotation3D r(data,data+9);; std::vector w(12);; //create Transform3D from std::vector content; Transform3D t(w.begin(),w.end());; All rotations, except the axial rotations, are constructible and assigned from any other type of rotation (including the axial):; //create a rotation 3D from a rotation along X axis of angle PI; Rotation3D r(ROOT::Math::RotationX(PI));. //construct an Euler rotation from A Rotation3D; EulerAngles r2(r);. //assign an Axis rotation from an Euler Rotation; AxisAngle r3; r3 = r2;; Transform3D (rotation + translation) can be constructed from a rotation and a translation vector:; Rotation3D r;; XYZVector v;; Transform3D t1(r,v); //construct from rotation and then; //transl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:742412,ux,ux,742412,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['ux'],['ux']
Usability,"trary code in the event loop with Foreach() and ForeachSlot(); 1277 ; 1278Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; 1279executes the callable on the values of those columns for each event that passes all upstream selections.; 1280It can be used to perform actions that are not already available in the interface. For example, the following snippet; 1281evaluates the root mean square of column ""x"":; 1282~~~{.cpp}; 1283// Single-thread evaluation of RMS of column ""x"" using Foreach; 1284double sumSq = 0.;; 1285unsigned int n = 0;; 1286df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; 1287std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1288~~~; 1289In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; 1290thread will execute the expression concurrently.; 1291The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; 1292this is probably too much head-scratch for such a simple operation.; 1293 ; 1294ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; 1295additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; 1296guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; 1297executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; 1298We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; 1299~~~{.cpp}; 1300// Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; 1301ROOT::EnableImplicitMT();; 1302const unsigned int nSlots = df.GetNSlots();; 1303std::vector<double> sumSqs(nSlots, 0.);; 1304std::vector<unsigned int> ns(nSlots, 0);; 1305 ; 1306df.ForeachSlot([&sumSqs, &ns](unsigned int sl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:74976,simpl,simple,74976,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['simpl'],['simple']
Usability,"trary code in the event loop with Foreach() and ForeachSlot(); 1317 ; 1318Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; 1319executes the callable on the values of those columns for each event that passes all upstream selections.; 1320It can be used to perform actions that are not already available in the interface. For example, the following snippet; 1321evaluates the root mean square of column ""x"":; 1322~~~{.cpp}; 1323// Single-thread evaluation of RMS of column ""x"" using Foreach; 1324double sumSq = 0.;; 1325unsigned int n = 0;; 1326df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; 1327std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1328~~~; 1329In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; 1330thread will execute the expression concurrently.; 1331The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; 1332this is probably too much head-scratch for such a simple operation.; 1333 ; 1334ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; 1335additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; 1336guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; 1337executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; 1338We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; 1339~~~{.cpp}; 1340// Thread-safe evaluation of RMS of column ""x"" using ForeachSlot; 1341ROOT::EnableImplicitMT();; 1342const unsigned int nSlots = df.GetNSlots();; 1343std::vector<double> sumSqs(nSlots, 0.);; 1344std::vector<unsigned int> ns(nSlots, 0);; 1345 ; 1346df.ForeachSlot([&sumSqs, &ns](unsigned int sl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:76656,simpl,simple,76656,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['simpl'],['simple']
Usability,trate deconvolution function (class TSpectrum) ;  DeconvolutionRL_wide.C Example to illustrate deconvolution function (class TSpectrum) ;  DeconvolutionRL_wide_boost.C Example to illustrate deconvolution function (class TSpectrum) ;  peaks.C Getting Contours From TH2D ;  peaks2.C Example to illustrate the 2-d peak finder (class TSpectrum2) ;  Smoothing.C Example to illustrate smoothing using Markov algorithm (class TSpectrum) ;  spectrumpainter.C Examples showing how to use TSpectrum2Painter (the SPEC option) ;  ► splot;  TestSPlot.CThis tutorial illustrates the use of class TSPlot and of the sPlots method ;  ► sql;  sqlcanvas.CThis is slight modification of ntuple1.C example ;  sqlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlselect.C;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example ex,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:152492,simpl,simple,152492,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['simpl'],['simple']
Usability,"tream>; 18 ; 19#include <cmath>; 20#include <limits>; 21#include <numeric>; 22 ; 23 ; 24// This can be protected against by defining ROOT_Math_VecTypes; 25// This is only used for the R__HAS_VECCORE define; 26// and a single VecCore function in EvalLog; 27#ifndef ROOT_Math_VecTypes; 28#include ""Types.h""; 29#endif; 30 ; 31 ; 32// for defining unused variables in the interfaces; 33// and have still them in the documentation; 34#define MATH_UNUSED(var) (void)var; 35 ; 36 ; 37namespace ROOT {; 38 ; 39 namespace Math {; 40 ; 41 /**; 42 namespace defining Utility functions needed by mathcore; 43 */; 44 namespace Util {; 45 ; 46 /**; 47 Utility function for conversion to strings; 48 */; 49 template <class T>; 50 std::string ToString(const T &val); 51 {; 52 std::ostringstream buf;; 53 buf << val;; 54 ; 55 std::string ret = buf.str();; 56 return ret;; 57 }; 58 ; 59 /// safe evaluation of log(x) with a protections against negative or zero argument to the log; 60 /// smooth linear extrapolation below function values smaller than epsilon; 61 /// (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Util_8h_source.html:1703,simpl,simple,1703,doc/master/Util_8h_source.html,https://root.cern,https://root.cern/doc/master/Util_8h_source.html,1,['simpl'],['simple']
Usability,"tree; 283 //; 284 // These objects are filled with some random numbers and saved on a file.; 285 ; 286 #include ""TFile.h""; 287 #include ""TH1.h""; 288 #include ""TH2.h""; 289 #include ""TProfile.h""; 290 #include ""TRandom.h""; 291 #include ""TTree.h""; 292 ; 293 //__________________________________________________________________________; 294 main(int argc, char **argv); 295 {; 296 // Create a new ROOT binary machine independent file.; 297 // Note that this file may contain any kind of ROOT objects, histograms,trees; 298 // pictures, graphics objects, detector geometries, tracks, events, etc..; 299 // This file is now becoming the current directory.; 300 TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");; 301 ; 302 // Create some histograms and a profile histogram; 303 TH1F hpx(""hpx"",""This is the px distribution"",100,-4,4);; 304 TH2F hpxpy(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; 305 TProfile hprof(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; 306 ; 307 // Define some simple structures; 308 typedef struct {Float_t x,y,z;} POINT;; 309 typedef struct {; 310 Int_t ntrack,nseg,nvertex;; 311 UInt_t flag;; 312 Float_t temperature;; 313 } EVENTN;; 314 POINT point;; 315 EVENTN eventn;; 316 ; 317 // Create a ROOT Tree; 318 TTree tree(""T"",""An example of ROOT tree with a few branches"");; 319 tree.Branch(""point"",&point,""x:y:z"");; 320 tree.Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; 321 tree.Branch(""hpx"",""TH1F"",&hpx,128000,0);; 322 ; 323 Float_t px,py,pz;; 324 ; 325 // Here we start a loop on 1000 events; 326 for ( Int_t i=0; i<1000; i++) {; 327 gRandom->Rannor(px,py);; 328 pz = px*px + py*py;; 329 const auto random = gRandom->::Rndm(1);; 330 ; 331 // Fill histograms; 332 hpx.Fill(px);; 333 hpxpy.Fill(px,py,1);; 334 hprof.Fill(px,pz,1);; 335 ; 336 // Fill structures; 337 point.x = 10*(random-1);; 338 point.y = 5*random;; 339 point.z = 20*random;; 340 eventn.ntrack = Int_t(100*random);; 341 eventn.nseg = Int_t(2*eventn.ntrack);; 342",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:14383,simpl,simple,14383,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['simpl'],['simple']
Usability,"trees in the TChain instead of the default behaviour using the weights of each tree in the chain (see TChain::SetWeight). ; Reimplemented in TChain.; Definition at line 9364 of file TTree.cxx. ◆ Show(). void TTree::Show ; (; Long64_t ; entry = -1, . Int_t ; lenmax = 20 . ). virtual . Print values of all active leaves for entry. . if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. . Definition at line 9375 of file TTree.cxx. ◆ SortBranchesByTime(). void TTree::SortBranchesByTime ; (; ). private . Sorts top-level branches by the last average task time recorded per branch. ; Definition at line 5834 of file TTree.cxx. ◆ StartViewer(). void TTree::StartViewer ; (; ). virtual . Start the TTreeViewer on this tree. . ww is the width of the canvas in pixels; wh is the height of the canvas in pixels . Definition at line 9449 of file TTree.cxx. ◆ StopCacheLearningPhase(). Int_t TTree::StopCacheLearningPhase ; (; ). virtual . Stop the cache learning phase. ; Returns:; 0 learning phase stopped or not active; -1 on error . Definition at line 9464 of file TTree.cxx. ◆ Streamer(). void TTree::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 9535 of file TTree.cxx. ◆ StreamerNVirtual(). void TTree::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 659 of file TTree.h. ◆ UnbinnedFit(). Int_t TTree::UnbinnedFit ; (; const char * ; funcname, . const char * ; varexp, . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Unbinned fit of one or more variable(s) from a tree. ; funcname is a TF1 function.; See alsoTTree::Draw for explanations of the other parameters.; Fit the variable varexp using the function funcname using the selection cuts given by selection.; The list of fit options is given in parameter o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:218842,learn,learning,218842,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['learn'],['learning']
Usability,"trees in the TChain instead of the default behaviour using the weights of each tree in the chain (see TChain::SetWeight). ; Reimplemented in TChain.; Definition at line 9374 of file TTree.cxx. ◆ Show(). void TTree::Show ; (; Long64_t ; entry = -1, . Int_t ; lenmax = 20 . ). virtual . Print values of all active leaves for entry. . if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. . Definition at line 9385 of file TTree.cxx. ◆ SortBranchesByTime(). void TTree::SortBranchesByTime ; (; ). private . Sorts top-level branches by the last average task time recorded per branch. ; Definition at line 5834 of file TTree.cxx. ◆ StartViewer(). void TTree::StartViewer ; (; ). virtual . Start the TTreeViewer on this tree. . ww is the width of the canvas in pixels; wh is the height of the canvas in pixels . Definition at line 9459 of file TTree.cxx. ◆ StopCacheLearningPhase(). Int_t TTree::StopCacheLearningPhase ; (; ). virtual . Stop the cache learning phase. ; Returns:; 0 learning phase stopped or not active; -1 on error . Definition at line 9474 of file TTree.cxx. ◆ Streamer(). void TTree::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 9545 of file TTree.cxx. ◆ StreamerNVirtual(). void TTree::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 705 of file TTree.h. ◆ UnbinnedFit(). Int_t TTree::UnbinnedFit ; (; const char * ; funcname, . const char * ; varexp, . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Unbinned fit of one or more variable(s) from a tree. ; funcname is a TF1 function.; See alsoTTree::Draw for explanations of the other parameters.; Fit the variable varexp using the function funcname using the selection cuts given by selection.; The list of fit options is given in parameter o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:221805,learn,learning,221805,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['learn'],['learning']
Usability,"tric function ;  FirstContour.C Make a contour plot and get the first contour in a TPolyMarker ;  h1draw.C 1-D histogram drawing options ;  h2proj.C;  hbars.C Example of bar charts with 1-d histograms ;  histpalettecolor.C Palette coloring for histogram is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  hksimple.C Illustrates the advantages of a TH1K histogram ;  hlabels1.C 1-D histograms with alphanumeric labels ;  hlabels2.C 2-D histograms with alphanumeric labels ;  hstack.C Example of stacked histograms: class THStack ;  hsum.C Histograms filled and drawn in a loop ;  hsumTimer.C Demo of Timers ;  legendautoplaced.C The legend can be placed automatically in the current pad in an empty space found at painting time ;  logscales.C Draw parametric functions with log scales ;  multicolor.C Use a THStack to show a 2-D hist with cells with different colors ;  ratioplot1.C Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot1.py Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot2.C Example of a fit residual plot ;  ratioplot2.py Example of a fit residual plot ;  ratioplot3.C Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot3.py Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot4.C Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot4.py Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot5.C Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot5.py Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot6.C ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:125382,simpl,simple,125382,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['simpl'],['simple']
Usability,"tries, Long64_t firstentry=0);  Interface to the Principal Components Analysis class. ;  ; void Print (Option_t *option="""") const override;  Print a summary of the tree contents. ;  ; virtual void PrintCacheStats (Option_t *option="""") const;  Print statistics about the TreeCache for this tree. ;  ; virtual Long64_t Project (const char *hname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Make a projection of a tree using selections. ;  ; virtual TSQLResult * Query (const char *varexp="""", const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Loop over entries and return a TSQLResult object containing entries following selection. ;  ; virtual Long64_t ReadFile (const char *filename, const char *branchDescriptor="""", char delimiter=' ');  Create or simply read branches from filename. ;  ; virtual Long64_t ReadStream (std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ');  Create or simply read branches from an input stream. ;  ; void RecursiveRemove (TObject *obj) override;  Make sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree. ;  ; virtual void Refresh ();  Refresh contents of this tree and its branches from the current status on disk. ;  ; virtual void RegisterExternalFriend (TFriendElement *);  Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is because this chain is a friend of another TChain) ;  ; virtual void RemoveExternalFriend (TFriendElement *);  Removes external friend. ;  ; virtual bool SetAlias (const char *aliasName, const char *aliasFormula);  Set a tree variable alias. ;  ; virtual void SetAutoFlush (Long64_t autof=-30000000);  This function may be called at the start of a program to change the default value for fAutoFlush. ;  ; virtual void SetAutoSave (Long64_t autos=-300000000);  In case of a program crash, it",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:24246,simpl,simply,24246,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,3,['simpl'],['simply']
Usability,"tring histoName, double x, double y) {if (fMonitoring) fMonitoring->addPoint (histoName, x, y); } ///< for monitoring; 823 void plot (std::string histoName, std::string options, int pad, EColor color) { if (fMonitoring) fMonitoring->plot (histoName, options, pad, color); } ///< for monitoring; 824 void clear (std::string histoName) { if (fMonitoring) fMonitoring->clear (histoName); } ///< for monitoring; 825 bool exists (std::string histoName) { if (fMonitoring) return fMonitoring->exists (histoName); return false; } ///< for monitoring; 826 ; 827 size_t convergenceCount () const { return m_convergenceCount; } ///< returns the current convergence count; 828 size_t maxConvergenceCount () const { return m_maxConvergenceCount; } ///< returns the max convergence count so far; 829 size_t minError () const { return m_minError; } ///< returns the smallest error so far; 830 ; 831 public:; 832 Timer m_timer; ///< timer for monitoring; 833 double m_minProgress; ///< current limits for the progress bar; 834 double m_maxProgress; ///< current limits for the progress bar; 835 ; 836 ; 837 size_t m_convergenceSteps; ///< number of steps without improvement to consider the DNN to have converged; 838 size_t m_batchSize; ///< mini-batch size; 839 size_t m_testRepetitions;; 840 double m_factorWeightDecay;; 841 ; 842 size_t count_E;; 843 size_t count_dE;; 844 size_t count_mb_E;; 845 size_t count_mb_dE;; 846 ; 847 EnumRegularization m_regularization;; 848 ; 849 double m_dropRepetitions;; 850 std::vector<double> m_dropOut;; 851 ; 852 double fLearningRate;; 853 double fMomentum;; 854 int fRepetitions;; 855 MinimizerType fMinimizerType;; 856 ; 857 size_t m_convergenceCount;; 858 size_t m_maxConvergenceCount;; 859 double m_minError;; 860 ; 861 ; 862 protected:; 863 bool m_useMultithreading;; 864 ; 865 std::shared_ptr<Monitoring> fMonitoring;; 866 };; 867 ; 868 ; 869 ; 870 ; 871 ; 872 ; 873 ; 874 ; 875 ; 876 ; 877 ; 878 ; 879 ; 880 ; 881 ; 882 ; 883 ; 884 ; 885 ; 886 ; 887 ; 888 ; 889 ; 890 /",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:32065,progress bar,progress bar,32065,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['progress bar'],['progress bar']
Usability,"tring; 5 : invalid syntax; 6 : Too many operators; 7 : Too many parameters; 10 : z specified but not x and y; 11 : z and y specified but not x; 12 : y specified but not x; 13 : z and x specified but not y; 20 : non integer value for parameter number; 21 : atan2 requires two arguments; 22 : pow requires two arguments; 23 : degree of polynomial not specified; 24 : Degree of polynomial must be positive; 25 : Degree of polynomial must be less than 20; 26 : Unknown name; 27 : Too many constants in expression; 28 : strstr requires two arguments; 29 : interpreted or compiled function have to return a numerical type; 30 : Bad numerical expression; 31 : Part of the variable exist but some of it is not accessible or useable; 40 : '(' is expected; 41 : ')' is expected; 42 : '[' is expected; 43 : ']' is expected; . Special functions; By default, the formula is assigned fNumber=0. However, the following formula built with simple functions are assigned fNumber: ""gaus"" 100 (or gausn); ""xygaus"" 110; ""expo"" 200; ""polN"" 300+N; ""landau"" 400; ""xylandau"" 410; Note that expressions like gaus(0), expo(1) will force fNumber=0. Warning when deriving a class from TFormula; If you overload this member function, you also HAVE TO never call the constructor:; TFormula::TFormula(const char *name,const char *expression); namechar name[80]Definition TGX11.cxx:110; ROOT::v5::TFormula::TFormulaTFormula()Formula default constructor.Definition TFormula_v5.cxx:136; and write your own constructor; MyClass::MyClass(const char *name,const char *expression) : TFormula(); ROOT::v5::TFormulaThe FORMULA class (ROOT version 5)Definition TFormula.h:65; which has to call the TFormula default constructor and whose implementation should be similar to the implementation of the normal TFormula constructor; This is necessary because the normal TFormula constructor call indirectly the virtual member functions Analyze, DefaultString, DefaultValue and DefaultVariable. ; Definition at line 712 of file TFormula_v5.cxx. ◆ A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1v5_1_1TFormula.html:29359,simpl,simple,29359,doc/master/classROOT_1_1v5_1_1TFormula.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1v5_1_1TFormula.html,1,['simpl'],['simple']
Usability,"tringfValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TXMLParser. ←. TDOMParser. TSAXParser. Function documentation; TXMLParser(); Initializes parser variables. ~TXMLParser(); Cleanup. void SetValidate(Bool_t val = kTRUE); The parser will validate the xml file if val = true. void SetReplaceEntities(Bool_t val = kTRUE); The parser will replace/expand entities. void ReleaseUnderlying(); To release any existing document. void OnValidateError(const TString& message); This function is called when an error from the parser has occured.; Message is the parse error. void OnValidateWarning(const TString& message); This function is called when a warning from the parser has occured.; Message is the parse error. const char * GetParseCodeMessage(Int_t parseCode) const; Returns the parse code message. void InitializeContext(); Initialize parser parameters, such as, disactivate non-standards libxml1; features, on/off validation, clear error and warning messages. void StopParser(); Stops parsing. void SetParseCode(Int_t code); Set the parse code:; 0: Parse successful; -1: Attempt to parse a second file while a parse is in progress; -2: Parse context is not created; -3: An error occured while parsing file; -4: A fatal error occured while parsing file; -5: Document is not well-formed. void SetStopOnError(Bool_t stop = kTRUE); Set parser stops in case of error:; stop = true, stops on error; stop = false, continue parsing on error... TXMLParser(const TXMLParser& ). TXMLParser& operator=(const TXMLParser& ). Bool_t GetValidate() const; { return fValidate; }. Bool_t GetReplaceEntities() const; { return fReplaceEntities; }. Int_t ParseFile(const char* filename). Int_t ParseBuffer(const char* contents, Int_t len). Int_t GetParseCode() const; { return fParseCode; }. Bool_t GetStopOnError() const; { return fStopError; }. const char * GetValidateError() const; { return fVali",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXMLParser.html:11610,clear,clear,11610,root/html602/TXMLParser.html,https://root.cern,https://root.cern/root/html602/TXMLParser.html,4,['clear'],['clear']
Usability,"trix();; 2485 const Double_t *orot = other.GetRotationMatrix();; 2486 for (auto i = 0; i < 9; i++); 2487 if (TMath::Abs(rot[i] - orot[i]) > 1.E-10); 2488 return kFALSE;; 2489 const Double_t *scl = GetScale();; 2490 const Double_t *oscl = other.GetScale();; 2491 for (auto i = 0; i < 3; i++); 2492 if (TMath::Abs(scl[i] - oscl[i]) > 1.E-10); 2493 return kFALSE;; 2494 return kTRUE;; 2495}; 2496 ; 2497////////////////////////////////////////////////////////////////////////////////; 2498/// Fast copy method.; 2499 ; 2500void TGeoHMatrix::CopyFrom(const TGeoMatrix *other); 2501{; 2502 SetBit(kGeoTranslation, other->IsTranslation());; 2503 SetBit(kGeoRotation, other->IsRotation());; 2504 SetBit(kGeoReflection, other->IsReflection());; 2505 memcpy(fTranslation, other->GetTranslation(), kN3);; 2506 memcpy(fRotationMatrix, other->GetRotationMatrix(), kN9);; 2507}; 2508 ; 2509////////////////////////////////////////////////////////////////////////////////; 2510/// clear the data for this matrix; 2511 ; 2512void TGeoHMatrix::Clear(Option_t *); 2513{; 2514 SetBit(kGeoReflection, kFALSE);; 2515 if (IsIdentity()); 2516 return;; 2517 ResetBit(kGeoTranslation);; 2518 ResetBit(kGeoRotation);; 2519 ResetBit(kGeoScale);; 2520 memcpy(fTranslation, kNullVector, kN3);; 2521 memcpy(fRotationMatrix, kIdentityMatrix, kN9);; 2522 memcpy(fScale, kUnitScale, kN3);; 2523}; 2524 ; 2525////////////////////////////////////////////////////////////////////////////////; 2526/// Make a clone of this matrix.; 2527 ; 2528TGeoMatrix *TGeoHMatrix::MakeClone() const; 2529{; 2530 TGeoMatrix *matrix = new TGeoHMatrix(*this);; 2531 return matrix;; 2532}; 2533 ; 2534////////////////////////////////////////////////////////////////////////////////; 2535/// Perform a rotation about Z having the sine/cosine of the rotation angle.; 2536 ; 2537void TGeoHMatrix::FastRotZ(const Double_t *sincos); 2538{; 2539 fRotationMatrix[0] = sincos[1];; 2540 fRotationMatrix[1] = -sincos[0];; 2541 fRotationMatrix[3] = sincos[0];; 2542",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:86233,clear,clear,86233,doc/master/TGeoMatrix_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html,1,['clear'],['clear']
Usability,"trix, weights, false, includeRegularization);; 1343 }; 1344 // add Regularization term; 1345 Double_t regzTerm = (includeRegularization) ? deepNet.RegularizationTerm() : 0.0;; 1346 minValError /= (Double_t)(nValidationSamples / settings.batchSize);; 1347 minValError += regzTerm;; 1348 ; 1349 ; 1350 // create a pointer to base class VOptimizer; 1351 std::unique_ptr<DNN::VOptimizer<Architecture_t, Layer_t, DeepNet_t>> optimizer;; 1352 ; 1353 // initialize the base class pointer with the corresponding derived class object.; 1354 switch (O) {; 1355 ; 1356 case EOptimizer::kSGD:; 1357 optimizer = std::unique_ptr<DNN::TSGD<Architecture_t, Layer_t, DeepNet_t>>(; 1358 new DNN::TSGD<Architecture_t, Layer_t, DeepNet_t>(settings.learningRate, deepNet, settings.momentum));; 1359 break;; 1360 ; 1361 case EOptimizer::kAdam: {; 1362 optimizer = std::unique_ptr<DNN::TAdam<Architecture_t, Layer_t, DeepNet_t>>(; 1363 new DNN::TAdam<Architecture_t, Layer_t, DeepNet_t>(; 1364 deepNet, settings.learningRate, settings.optimizerParams[""ADAM_beta1""],; 1365 settings.optimizerParams[""ADAM_beta2""], settings.optimizerParams[""ADAM_eps""]));; 1366 break;; 1367 }; 1368 ; 1369 case EOptimizer::kAdagrad:; 1370 optimizer = std::unique_ptr<DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>>(; 1371 new DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1372 settings.optimizerParams[""ADAGRAD_eps""]));; 1373 break;; 1374 ; 1375 case EOptimizer::kRMSProp:; 1376 optimizer = std::unique_ptr<DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>>(; 1377 new DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate, settings.momentum,; 1378 settings.optimizerParams[""RMSPROP_rho""],; 1379 settings.optimizerParams[""RMSPROP_eps""]));; 1380 break;; 1381 ; 1382 case EOptimizer::kAdadelta:; 1383 optimizer = std::unique_ptr<DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>>(; 1384 new DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 138",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:54010,learn,learningRate,54010,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['learn'],['learningRate']
Usability,"trixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; const TMatrixDSym&covarianceMatrix() const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMultiVarGaussian.html:3357,clear,clearShapeDirty,3357,root/html534/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html534/RooMultiVarGaussian.html,6,['clear'],['clearShapeDirty']
Usability,"trix_t > > fPastSquaredWeightUpdates;  The accumulation of the square of the past weight updates associated with the deep net. ;  ; Scalar_t fRho;  The Rho constant used by the optimizer. ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor1;  working tensor used to keep a temporary copy of bias or bias gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkBiasTensor2;  working tensor used to keep a temporary copy of bias or bias gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkWeightTensor1;  working tensor used to keep a temporary copy of weights or weight gradients ;  ; std::vector< std::vector< Matrix_t > > fWorkWeightTensor2;  working tensor used to keep a temporary copy of weights or weight gradients ;  ;  Protected Attributes inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; DeepNet_t & fDeepNet;  The reference to the deep net. ;  ; size_t fGlobalStep;  The current global step count during training. ;  ; Scalar_t fLearningRate;  The learning rate used for training. ;  . #include <TMVA/DNN/Adadelta.h>. Inheritance diagram for TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Matrix_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >::Matrix_t = typename Architecture_t::Matrix_t. Definition at line 47 of file Adadelta.h. ◆ Scalar_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >::Scalar_t = typename Architecture_t::Scalar_t. Definition at line 48 of file Adadelta.h. Constructor & Destructor Documentation. ◆ TAdadelta(). template<typename Architecture_t , typename L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html:4473,learn,learning,4473,doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,1,['learn'],['learning']
Usability,"tructor; Should only be used by proof. RooProfileLL(const char* name, const char* title, RooAbsReal& nll, const RooArgSet& observables); Constructor of profile likelihood given input likelihood nll w.r.t; the given set of variables. The input log likelihood is minimized w.r.t; to all other variables of the likelihood at each evaluation and the; value of the global log likelihood minimum is always subtracted. RooProfileLL(const RooProfileLL& other, const char* name = 0); Copy constructor. ~RooProfileLL(); Destructor. const RooArgSet& bestFitParams() const. const RooArgSet& bestFitObs() const. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Optimized implementation of createProfile for profile likelihoods.; Return profile of original function in terms of stated parameters; of interest rather than profiling recursively. Double_t evaluate() const; Evaluate profile likelihood by minimizing likelihood w.r.t. all; parameters that are not considered observables of this profile; likelihood object. void validateAbsMin() const; Check that parameters and likelihood value for 'best fit' are still valid. If not,; because the best fit has never been calculated, or because constant parameters have; changed value or parameters have changed const/float status, the minimum is recalculated. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ). TObject* clone(const char* newname) const; { return new RooProfileLL(*this,newname); }. void setAlwaysStartFromMin(Bool_t flag); { _startFromMin = flag ; }. Bool_t alwaysStartFromMin() const; { return _startFromMin ; }. RooMinuit* minuit(); { return _minuit ; }. RooAbsReal& nll(); { return const_cast<RooAbsReal&>(_nll.arg()) ; }. void clearAbsMin(); { _absMinValid = kFALSE ; }. » Last changed: Wed Nov 17 19:12:29 2010 » Last generated: 2010-11-17 19:12; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProfileLL.html:35762,clear,clearAbsMin,35762,root/html528/RooProfileLL.html,https://root.cern,https://root.cern/root/html528/RooProfileLL.html,1,['clear'],['clearAbsMin']
Usability,"tructures. Building a complete geometry in this style is virtually possible but highly not recommended.; The Structure of Composite Shapes; A composite shape can always be looked as the result of a Boolean operation between only two shape components. All information identifying these two components as well as their positions with respect to the frame of the composite is represented by an object called Boolean node. A composite shape has a pointer to such a Boolean node. Since the shape components may also be composites, they will also contain binary Boolean nodes branching out other two shapes in the hierarchy. Any such branch ends-up when the final leaves are no longer composite shapes, but basic primitives. The figure shows the composite shapes structure. The composite shapes structure; Suppose that A, B, C and D represent basic shapes, we will illustrate how the internal representation of few combinations look like. We do this only for understanding how to create them in a proper way, since the user interface for this purpose is in fact very simple. We will ignore for the time being the positioning of components. The definition of a composite shape takes an expression where the identifiers are shape names. The expression is parsed and decomposed in 2 sub-expressions and the top-level Boolean operator. Union: A+B+C. Just to illustrate the Boolean expression parsing and the composite shape structure, let's take a simple example. We will describe the union of A, B and C. Both union operators are at the same level. Since:; A+B+C = (A+B)+C = A+(B+C); The first(+) is taken as separator, hence the expression split in: A and (B+C). A Boolean node of type **TGeoUnion**(""A"",""B+C"") is created. This tries to replace the 2 expressions by actual pointers to corresponding shapes. The first expression (A) contains no operators therefore is interpreted as representing a shape. The shape named ""A"" is searched into the list of shapes handled by the manager class and stored as the """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoCompositeShape.html:2379,simpl,simple,2379,doc/master/classTGeoCompositeShape.html,https://root.cern,https://root.cern/doc/master/classTGeoCompositeShape.html,1,['simpl'],['simple']
Usability,"try Shapes; TModuleDocInfo documentation for a group of classes; TMonitor Monitor activity on a set of TSocket objects; TMultiDimFit Multi dimensional fit class; TMultiGraph A collection of TGraph objects; TMultiLayerPerceptron a Neural Network; TMutex Mutex lock class; TMutexImp Mutex lock implementation ABC; TMySQLResult MySQL query result; TMySQLRow One row of MySQL query result; TMySQLServer Connection to MySQL server; TMySQLStatement SQL statement class for MySQL DB; TNamed The basis for a named object (name, title); TNetFile A ROOT file that reads/writes via a rootd server; TNetSystem Directory handler for NetSystem; TNeuron Neuron for MultiLayerPerceptrons; TNewChainDlg New chain dialog; TNewQueryDlg New query dialog; TNode Description of parameters to position a 3-D geometry object; TNodeDiv Description of parameters to divide a 3-D geometry object; TNonSplitBrowsable Helper object to browse unsplit objects; TNtuple A simple tree with branches of floats.; TNtupleD A simple tree with branches of floats.; TObjArray An array of objects; TObjArrayIter Object array iterator; TObjString Collectable string class; TObject Basic ROOT object; TObjectRefSpy Spy object reference for deletion; TObjectSet TDataSet wrapper for TObject class objects; TObjectSpy Spy object pointer for deletion; TObjectTable Table of active objects; TOracleResult Oracle query result; TOracleRow One row of Oracle query result; TOracleServer Connection to Oracle server; TOracleStatement SQL statement class for Oracle; TOrdCollection An ordered collection; TOrdCollectionIter Ordered collection iterator; TOutputListSelectorDataMap Converter from output list to TSelector data members; TPARA PARA shape; TPCON PCON shape; TPDF PDF driver; TPGON PGON shape; TPMERegexp Wrapper for Perl-like regular expression matching.; TPRegexp Perl Compatible Regular Expression Class; TPServerSocket Parallel server socket; TPSocket Parallel client socket; TPackageDescription Package description; TPacketizer Generate ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:109112,simpl,simple,109112,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,1,['simpl'],['simple']
Usability,"try Shapes; TModuleDocInfo documentation for a group of classes; TMonitor Monitor activity on a set of TSocket objects; TMultiDimFit Multi dimensional fit class; TMultiGraph A collection of TGraph objects; TMultiLayerPerceptron a Neural Network; TMutex Mutex lock class; TMutexImp Mutex lock implementation ABC; TMySQLResult MySQL query result; TMySQLRow One row of MySQL query result; TMySQLServer Connection to MySQL server; TMySQLStatement SQL statement class for MySQL DB; TNamed The basis for a named object (name, title); TNetFile A ROOT file that reads/writes via a rootd server; TNetSystem Directory handler for NetSystem; TNeuron Neuron for MultiLayerPerceptrons; TNewChainDlg New chain dialog; TNewQueryDlg New query dialog; TNode Description of parameters to position a 3-D geometry object; TNodeDiv Description of parameters to divide a 3-D geometry object; TNonSplitBrowsable Helper object to browse unsplit objects; TNtuple A simple tree with branches of floats.; TNtupleD A simple tree with branches of floats.; TObjArray An array of objects; TObjArrayIter Object array iterator; TObjString Collectable string class; TObject Basic ROOT object; TObjectRefSpy Spy object reference for deletion; TObjectSet TDataSet wrapper for TObject class objects; TObjectSpy Spy object pointer for deletion; TObjectTable Table of active objects; TOracleResult Oracle query result; TOracleRow One row of Oracle query result; TOracleServer Connection to Oracle server; TOracleStatement SQL statement class for Oracle; TOrdCollection An ordered collection; TOrdCollectionIter Ordered collection iterator; TPARA PARA shape; TPCON PCON shape; TPDF PDF driver; TPGON PGON shape; TPMERegexp Wrapper for Perl-like regular expression matching.; TPRegexp Perl Compatible Regular Expression Class; TPServerSocket Parallel server socket; TPSocket Parallel client socket; TPackageDescription Package description; TPacketizer Generate work packets for parallel processing; TPacketizerAdaptive Generate work packets f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:104198,simpl,simple,104198,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,2,['simpl'],['simple']
Usability,"try is a one line text input widget.Definition TGTextEntry.h:24; TGTextEntry::SetDefaultSizevirtual void SetDefaultSize(UInt_t w, UInt_t h)Set the default / minimal size of the widget.Definition TGTextEntry.cxx:384; TGTextEntry::Clearvoid Clear(Option_t *option="""") overrideClears up the text entry.Definition TGTextEntry.cxx:972; TGTextEntry::GetTextconst char * GetText() constDefinition TGTextEntry.h:119; TGTextEntry::SetCursorPositionvirtual void SetCursorPosition(Int_t pos)Set the cursor position to newPos.Definition TGTextEntry.cxx:718; TGTextEntry::AppendTextvirtual void AppendText(const char *text)Appends text to the end of text entry, clears the selection and moves the cursor to the end of the li...Definition TGTextEntry.cxx:1689; TGTextEntry::SetToolTipTextvirtual void SetToolTipText(const char *text, Long_t delayms=500)Set tool tip text associated with this text entry.Definition TGTextEntry.cxx:1647; TGTextEntry::SetTextvirtual void SetText(const char *text, Bool_t emit=kTRUE)Sets text entry to text, clears the selection and moves the cursor to the end of the line.Definition TGTextEntry.cxx:611; TGTextEntry::HandleButtonBool_t HandleButton(Event_t *event) overrideHandle mouse button event in text entry widget.Definition TGTextEntry.cxx:1342; TGToolBarA toolbar is a composite frame that contains TGPictureButtons.Definition TGToolBar.h:33; TGVSplitterDefinition TGSplitter.h:53; TGVSplitter::SetFramevoid SetFrame(TGFrame *frame, Bool_t left) overrideSet frame to be resized.Definition TGSplitter.cxx:143; TGVertical3DLineA vertical 3D line is a line that can be used to separate groups of widgets.Definition TG3DLine.h:33; TGVerticalFrameA composite frame that layout their children in vertical way.Definition TGFrame.h:374; TGWidget::Associatevirtual void Associate(const TGWindow *w)Definition TGWidget.h:72; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::SetTitlevoid SetTitle(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:130136,clear,clears,130136,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['clear'],['clears']
Usability,"try-lists should be set in the data set object using; TDSet::SetEntryList.; Returns -1 in case of error or number of selected events otherwise. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Int_t CreateSymLinks(TList* files, TList* wrks = 0); Create in each worker sandbox symlinks to the files in the list; Used to make the cache information available to workers. Int_t InitDataSetManager(); Initialize the dataset manager from directives or from defaults; Return 0 on success, -1 on failure. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove files from all file caches. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Copy the specified macro in the cache directory. The macro file is; uploaded if new or updated. If existing, the corresponding header; basename(macro).h or .hh, is also uploaded. For the other arguments; see TProof::Load().; Returns 0 in case of success and -1 in case of error. Int_t CopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0, TList* wrks = 0); Copy a macro, and its possible associated .h[h] file,; to the cache directory, from where the workers can get the file.; If headerRequired is 1, return -1 in case the header is not found.; If headerRequired is 0, try to copy header too.; If headerRequired is -1, don't look for header, only copy macro.; If the selector pionter is not 0, consider the macro to be a selector; and try to load the selector and set it to the pointer.; The mask 'opt' is an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:31376,Clear,ClearCache,31376,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,2,['Clear'],['ClearCache']
Usability,"ts are wrapped in smart pointers; we'll see why in a minute. Applying a filter; Let's say we want to cut over the value of branch ""MET"" and count how many events pass this cut. This is one way to do it: RDataFrame d(""myTree"", ""file.root"");; auto c = d.Filter(""MET > 4."").Count(); // computations booked, not run; std::cout << *c << std::endl; // computations run here, upon first access to the result; The filter string (which must contain a valid C++ expression) is applied to the specified columns for each event; the name and types of the columns are inferred automatically. The string expression is required to return a bool which signals whether the event passes the filter (true) or not (false).; You can think of your data as ""flowing"" through the chain of calls, being transformed, filtered and finally used to perform actions. Multiple Filter() calls can be chained one after another.; Using string filters is nice for simple things, but they are limited to specifying the equivalent of a single return statement or the body of a lambda, so it's cumbersome to use strings with more complex filters. They also add a small runtime overhead, as ROOT needs to just-in-time compile the string into C++ code. When more freedom is required or runtime performance is very important, a C++ callable can be specified instead (a lambda in the following snippet, but it can be any kind of function or even a functor class), together with a list of column names. This snippet is analogous to the one above: RDataFrame d(""myTree"", ""file.root"");; auto metCut = [](double x) { return x > 4.; }; // a C++11 lambda function checking ""x > 4""; auto c = d.Filter(metCut, {""MET""}).Count();; std::cout << *c << std::endl;; ROOT::RDF::RInterface< RDFDetail::RLoopManager >::CountRResultPtr< ULong64_t > Count()Return the number of entries processed (lazy action).Definition RInterface.hxx:1560; xDouble_t x[n]Definition legend1.C:17; An example of a more complex filter expressed as a string containing C++ code is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:18222,simpl,simple,18222,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['simpl'],['simple']
Usability,"ts are wrapped in smart pointers; we'll see why in a minute. Applying a filter; Let's say we want to cut over the value of branch ""MET"" and count how many events pass this cut. This is one way to do it: RDataFrame d(""myTree"", ""file.root"");; auto c = d.Filter(""MET > 4."").Count(); // computations booked, not run; std::cout << *c << std::endl; // computations run here, upon first access to the result; The filter string (which must contain a valid C++ expression) is applied to the specified columns for each event; the name and types of the columns are inferred automatically. The string expression is required to return a bool which signals whether the event passes the filter (true) or not (false).; You can think of your data as ""flowing"" through the chain of calls, being transformed, filtered and finally used to perform actions. Multiple Filter() calls can be chained one after another.; Using string filters is nice for simple things, but they are limited to specifying the equivalent of a single return statement or the body of a lambda, so it's cumbersome to use strings with more complex filters. They also add a small runtime overhead, as ROOT needs to just-in-time compile the string into C++ code. When more freedom is required or runtime performance is very important, a C++ callable can be specified instead (a lambda in the following snippet, but it can be any kind of function or even a functor class), together with a list of column names. This snippet is analogous to the one above: RDataFrame d(""myTree"", ""file.root"");; auto metCut = [](double x) { return x > 4.; }; // a C++11 lambda function checking ""x > 4""; auto c = d.Filter(metCut, {""MET""}).Count();; std::cout << *c << std::endl;; ROOT::RDF::RInterface< RDFDetail::RLoopManager >::CountRResultPtr< ULong64_t > Count()Return the number of entries processed (lazy action).Definition RInterface.hxx:1729; xDouble_t x[n]Definition legend1.C:17; An example of a more complex filter expressed as a string containing C++ code is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:18611,simpl,simple,18611,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['simpl'],['simple']
Usability,"ts as arguments.; Useful to use the string operator +; example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Draw expression varexp for specified entries.; Returns -1 in case of error or number of selected events in case of success. varexp is an expression of the general form; - ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; - ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1"" versus ""e2""; - ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3""; - ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" and ""e4"" mapped on the color number.; (to create histograms in the 2, 3, and 4 dimesional case, see section ""Saving; the result of Draw to an histogram""). Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim distribution of y versus sqrt(x); = px:py:pz:2.5*E produces a 3-d scatter-plot of px vs py ps pz; and the color number of each marker will be 2.5*E.; If the color number is negative it is set to 0.; If the color number is greater than the current number of colors; it is set to the highest color number.; The default number of colors is 50.; see TStyle::SetPalette for setting a new color palette. Note that the variables e1, e2 or e3 may contain a selection.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. The expressions can use all the operations and build-in functions; supported by TFormula (See TFormula::Analyze), including free; standing function taking numerical arguments (TMath::Bessel).; In addition, you can call member functions taking numerical; arguments. For example:; - ""TMath::BreitWigner(fPx,3,2)""; - ""event.GetHistogram().GetXaxis().GetXmax()""; Note: You can only pass expression th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:62755,simpl,simplest,62755,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,4,['simpl'],['simplest']
Usability,"ts painting operations. ; Definition at line 26 of file TPadPainter.h. Public Member Functions;  TPadPainter ();  Empty ctor. We need it only because of explicit copy ctor. ;  ; void ClearDrawable () override;  Clear the current gVirtualX window. ;  ; void CopyDrawable (Int_t device, Int_t px, Int_t py) override;  Copy a gVirtualX pixmap. ;  ; Int_t CreateDrawable (UInt_t w, UInt_t h) override;  Create a gVirtualX Pixmap. ;  ; void DestroyDrawable (Int_t device) override;  Close the current gVirtualX pixmap. ;  ; void DrawBox (Double_t x1, Double_t y1, Double_t x2, Double_t y2, EBoxMode mode) override;  Paint a simple box. ;  ; void DrawFillArea (Int_t n, const Double_t *x, const Double_t *y) override;  Paint filled area. ;  ; void DrawFillArea (Int_t n, const Float_t *x, const Float_t *y) override;  Paint filled area. ;  ; void DrawLine (Double_t x1, Double_t y1, Double_t x2, Double_t y2) override;  Paint a simple line. ;  ; void DrawLineNDC (Double_t u1, Double_t v1, Double_t u2, Double_t v2) override;  Paint a simple line in normalized coordinates. ;  ; void DrawPixels (const unsigned char *pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t enableAlphaBlending) override;  Noop, for non-gl pad TASImage calls gVirtualX->CopyArea. ;  ; void DrawPolyLine (Int_t n, const Double_t *x, const Double_t *y) override;  Paint Polyline. ;  ; void DrawPolyLine (Int_t n, const Float_t *x, const Float_t *y) override;  Paint polyline. ;  ; void DrawPolyLineNDC (Int_t n, const Double_t *u, const Double_t *v) override;  Paint polyline in normalized coordinates. ;  ; void DrawPolyMarker (Int_t n, const Double_t *x, const Double_t *y) override;  Paint polymarker. ;  ; void DrawPolyMarker (Int_t n, const Float_t *x, const Float_t *y) override;  Paint polymarker. ;  ; void DrawText (Double_t x, Double_t y, const char *text, ETextMode mode) override;  Paint text. ;  ; void DrawText (Double_t x, Double_t y, const wchar_t *text, ETextMode mode) override;  Special versio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPadPainter.html:1391,simpl,simple,1391,doc/master/classTPadPainter.html,https://root.cern,https://root.cern/doc/master/classTPadPainter.html,1,['simpl'],['simple']
Usability,"ts w.r.t. the weights of the layer.Definition GeneralLayer.h:74; TMVA::DNN::VGeneralLayer::fOutputTensor_t fOutputActivations of this layer.Definition GeneralLayer.h:77; TMVA::DNN::VGeneralLayer::GetWeightGradientsconst std::vector< Matrix_t > & GetWeightGradients() constDefinition GeneralLayer.h:184; TMVA::DNN::VGeneralLayer::SetDropoutProbabilityvirtual void SetDropoutProbability(Scalar_t)Set Dropout probability.Definition GeneralLayer.h:160; TMVA::DNN::VGeneralLayer::CopyParametersvoid CopyParameters(const VGeneralLayer< Arch > &layer)Copy all trainable weight and biases from another equivalent layer but with different architecture Th...Definition GeneralLayer.h:478; TMVA::DNN::VGeneralLayer::GetWeightsAtconst Matrix_t & GetWeightsAt(size_t i) constDefinition GeneralLayer.h:175; TMVA::DNN::VGeneralLayer::SetHeightvoid SetHeight(size_t height)Definition GeneralLayer.h:222; TMVA::DNN::VGeneralLayer::UpdateWeightGradientsvoid UpdateWeightGradients(const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate)Updates the weight gradients, given some other weight gradients and learning rate.Definition GeneralLayer.h:438; TMVA::DNN::VGeneralLayer::Initializevirtual void Initialize()Initialize the weights and biases according to the given initialization method.Definition GeneralLayer.h:395; TMVA::DNN::VGeneralLayer::GetBiasesAtMatrix_t & GetBiasesAt(size_t i)Definition GeneralLayer.h:182; TMVA::DNN::VGeneralLayer::SetInputHeightvoid SetInputHeight(size_t inputHeight)Definition GeneralLayer.h:219; TMVA::DNN::VGeneralLayer::fBiasGradientsstd::vector< Matrix_t > fBiasGradientsGradients w.r.t. the bias values of the layer.Definition GeneralLayer.h:75; TMVA::DNN::VGeneralLayer::SetDepthvoid SetDepth(size_t depth)Definition GeneralLayer.h:221; TMVA::DNN::VGeneralLayer::SetExtraLayerParametersvirtual void SetExtraLayerParameters(const std::vector< Matrix_t > &)Definition GeneralLayer.h:212; TMVA::DNN::VGeneralLayer::ReadWeightsFromXMLvirtual void ReadWeightsFromXM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GeneralLayer_8h_source.html:28191,learn,learningRate,28191,doc/master/GeneralLayer_8h_source.html,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html,2,['learn'],"['learning', 'learningRate']"
Usability,"ts* l, TGPopupMenu* before = 0); virtual voidAddPopup(const char* s, TGPopupMenu* menu, TGLayoutHints* l, TGPopupMenu* before = 0); virtual TGPopupMenu*AddPopup(const TString& s, Int_t padleft = 4, Int_t padright = 0, Int_t padtop = 0, Int_t padbottom = 0); virtual voidAddTitle(TGMenuTitle* title, TGLayoutHints* l, TGPopupMenu* before = 0); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal = 0, void* receive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGMenuBar.html:3512,Clear,Clear,3512,root/html532/TGMenuBar.html,https://root.cern,https://root.cern/root/html532/TGMenuBar.html,4,['Clear'],['Clear']
Usability,"ts, \(CL_{s}\) has no similar direct interpretation as for exclusion and can be larger than one. ; Definition at line 22 of file HypoTestResult.h. Public Member Functions;  HypoTestResult (const char *name, double nullp, double altp);  constructor from name, null and alternate p values ;  ;  HypoTestResult (const char *name=nullptr);  default constructor ;  ;  HypoTestResult (const HypoTestResult &other);  copy constructor ;  ;  ~HypoTestResult () override;  destructor ;  ; virtual double AlternatePValue () const;  Return p-value for alternate hypothesis. ;  ; virtual void Append (const HypoTestResult *other);  add values from another HypoTestResult ;  ; virtual double CLb () const;  Convert NullPValue into a ""confidence level"". ;  ; double CLbError () const;  The error on the ""confidence level"" of the null hypothesis. ;  ; TObject * Clone (const char *newname=nullptr) const override;  clone method, required since some data members cannot rely on the streamers to copy them ;  ; virtual double CLs () const;  \(CL_{s}\) is simply \(CL_{s+b}/CL_{b}\) (not a method, but a quantity) ;  ; double CLsError () const;  The error on the ratio \(CL_{s+b}/CL_{b}\). ;  ; virtual double CLsplusb () const;  Convert AlternatePValue into a ""confidence level"". ;  ; double CLsplusbError () const;  The error on the ""confidence level"" of the alternative hypothesis. ;  ; const RooArgList * GetAllTestStatisticsData (void) const;  ; RooDataSet * GetAltDetailedOutput (void) const;  ; SamplingDistribution * GetAltDistribution (void) const;  ; bool GetBackGroundIsAlt (void) const;  ; RooDataSet * GetFitInfo () const;  ; RooDataSet * GetNullDetailedOutput (void) const;  ; SamplingDistribution * GetNullDistribution (void) const;  ; bool GetPValueIsRightTail (void) const;  ; double GetTestStatisticData (void) const;  ; bool HasTestStatisticData (void) const;  ; TClass * IsA () const override;  ; virtual double NullPValue () const;  Return p-value for null hypothesis. ;  ; double NullPValueError (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HypoTestResult.html:2910,simpl,simply,2910,doc/master/classRooStats_1_1HypoTestResult.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HypoTestResult.html,1,['simpl'],['simply']
Usability,"ts. ROOT; » HIST; » HIST; » THnT<unsigned long>. class THnT<unsigned long>: public THn. Helper struct to hold one dimension's bin range for THnBinIter. Function Members (Methods); public:. virtual~THnT<unsigned long>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THnT_unsigned_long_.html:1024,Clear,Clear,1024,root/html602/THnT_unsigned_long_.html,https://root.cern,https://root.cern/root/html602/THnT_unsigned_long_.html,2,['Clear'],['Clear']
Usability,"ts.back();; 118 fChild = fStackChilds.back();; 119 ; 120 fStackParents.pop_back();; 121 fStackChilds.pop_back();; 122 ; 123 if (fParentId < 0) {; 124 fNodeId = 0;; 125 } else {; 126 fNodeId = fDesc.fDesc[fParentId].chlds[fChild];; 127 }; 128 return true;; 129 }; 130 ; 131 bool Next(); 132 {; 133 // does not have parents; 134 if ((fNodeId <= 0) || (fParentId < 0)) {; 135 Reset();; 136 return false;; 137 }; 138 ; 139 auto &prnt = fDesc.fDesc[fParentId];; 140 if (++fChild >= prnt.chlds.size()) {; 141 fNodeId = -1; // not valid node, only Leave can be called; 142 return false;; 143 }; 144 ; 145 fNodeId = prnt.chlds[fChild];; 146 return true;; 147 }; 148 ; 149 bool Reset(); 150 {; 151 fParentId = -1;; 152 fNodeId = -1;; 153 fChild = 0;; 154 fStackParents.clear();; 155 fStackChilds.clear();; 156 ; 157 return true;; 158 }; 159 ; 160 bool NextNode(); 161 {; 162 if (Enter()); 163 return true;; 164 ; 165 if (Next()); 166 return true;; 167 ; 168 while (Leave()) {; 169 if (Next()); 170 return true;; 171 }; 172 ; 173 return false;; 174 }; 175 ; 176 /** Navigate to specified path - path specified as string and should start with ""/"" */; 177 bool Navigate(const std::string &path); 178 {; 179 size_t pos = path.find('/');; 180 if (pos != 0); 181 return false;; 182 ; 183 Reset(); // set to the top of element; 184 ; 185 while (++pos < path.length()) {; 186 auto last = pos;; 187 ; 188 pos = path.find('/', last);; 189 ; 190 if (pos == std::string::npos); 191 pos = path.length();; 192 ; 193 std::string folder = path.substr(last, pos - last);; 194 ; 195 if (!Enter()); 196 return false;; 197 ; 198 bool find = false;; 199 ; 200 do {; 201 find = (folder.compare(GetName()) == 0);; 202 } while (!find && Next());; 203 ; 204 if (!find); 205 return false;; 206 }; 207 ; 208 return true;; 209 }; 210 ; 211 /** Navigate to specified path */; 212 bool Navigate(const std::vector<std::string> &path); 213 {; 214 Reset(); // set to the top of element; 215 ; 216 for (auto &folder : path) {; 217 ; 218 if (!E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:4079,clear,clear,4079,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"ts::NumEventsTestStat ; RooStats::NumberCountingPdfFactory A factory specific to common number counting problems.; RooStats::NumberCountingUtils ; RooStats::PdfProposal ; RooStats::PointSetInterval Concrete implementation of ConfInterval for simple 1-D intervals in the form [a,b]; RooStats::ProfileInspector Class containing the results of the IntervalCalculator; RooStats::ProfileLikelihoodCalculator A concrete implementation of CombinedCalculator that uses the ProfileLikelihood ratio.; RooStats::ProfileLikelihoodTestStat implements the profile likelihood ratio as a test statistic to be used with several tools; RooStats::ProofConfig Configuration options for proof.; RooStats::ProposalFunction Interface for the proposal function used with Markov Chain Monte Carlo; RooStats::ProposalHelper ; RooStats::RatioOfProfiledLikelihoodsTestStat ; RooStats::SPlot Class used for making sPlots; RooStats::SamplingDistPlot Class containing the results of the HybridCalculator; RooStats::SamplingDistribution Class containing the results of the HybridCalculator; RooStats::SamplingSummary A summary of acceptance regions for confidence belt; RooStats::SamplingSummaryLookup A simple class used by ConfidenceBelt; RooStats::SequentialProposal A concrete implementation of ProposalFunction, that uniformly samples the parameter space.; RooStats::SimpleInterval Concrete implementation of ConfInterval for simple 1-D intervals in the form [a,b]; RooStats::SimpleLikelihoodRatioTestStat ; RooStats::TestStatSampler Interface for tools setting limits (producing confidence intervals); RooStats::TestStatistic Interface for a TestStatistic; RooStats::ToyMCSampler A simple implementation of the TestStatSampler interface; RooStats::ToyMCSamplerOld A simple implementation of the TestStatSampler interface; RooStats::ToyMCStudy toy MC study for parallel processing; RooStats::UniformProposal A concrete implementation of ProposalFunction, that uniformly samples the parameter space.; RooStats::UpperLimitMCSModu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:47458,simpl,simple,47458,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,2,['simpl'],['simple']
Usability,"ts::NumberCountingPdfFactory A factory specific to common number counting problems.; RooStats::NumberCountingUtils ; RooStats::PdfProposal ; RooStats::PointSetInterval Concrete implementation of ConfInterval for simple 1-D intervals in the form [a,b]; RooStats::ProfileInspector Class containing the results of the IntervalCalculator; RooStats::ProfileLikelihoodCalculator A concrete implementation of CombinedCalculator that uses the ProfileLikelihood ratio.; RooStats::ProfileLikelihoodTestStat implements the profile likelihood ratio as a test statistic to be used with several tools; RooStats::ProofConfig Configuration options for proof.; RooStats::ProposalFunction Interface for the proposal function used with Markov Chain Monte Carlo; RooStats::ProposalHelper ; RooStats::RatioOfProfiledLikelihoodsTestStat implements the ratio of profiled likelihood as test statistic; RooStats::SPlot Class used for making sPlots; RooStats::SamplingDistPlot Class containing the results of the HybridCalculator; RooStats::SamplingDistribution Class containing the results of the HybridCalculator; RooStats::SamplingSummary A summary of acceptance regions for confidence belt; RooStats::SamplingSummaryLookup A simple class used by ConfidenceBelt; RooStats::SequentialProposal A concrete implementation of ProposalFunction, that uniformly samples the parameter space.; RooStats::SimpleInterval Concrete implementation of ConfInterval for simple 1-D intervals in the form [a,b]; RooStats::SimpleLikelihoodRatioTestStat ; RooStats::TestStatSampler Interface for tools setting limits (producing confidence intervals); RooStats::TestStatistic Interface for a TestStatistic; RooStats::ToyMCImportanceSampler An implementation of importance sampling; RooStats::ToyMCPayload ; RooStats::ToyMCSampler A simple implementation of the TestStatSampler interface; RooStats::ToyMCStudy toy MC study for parallel processing; RooStats::UniformProposal A concrete implementation of ProposalFunction, that uniformly samples the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:50070,simpl,simple,50070,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,6,['simpl'],['simple']
Usability,"ts; // Here n=4 - each polygon defines a rectangle - 4 sides.; buffer.fPols[ 0] = fColor ; buffer.fPols[ 1] = 4 ; buffer.fPols[ 2] = 0 ; // base; buffer.fPols[ 3] = 1 ; buffer.fPols[ 4] = 2 ; buffer.fPols[ 5] = 3 ;; ; buffer.fPols[ 6] = fColor ; buffer.fPols[ 7] = 3 ; buffer.fPols[ 8] = 0 ; // side 0; buffer.fPols[ 9] = 4 ; buffer.fPols[10] = 5 ;; buffer.fPols[11] = fColor ; buffer.fPols[12] = 3 ; buffer.fPols[13] = 1 ; // side 1; buffer.fPols[14] = 5 ; buffer.fPols[15] = 6 ;; buffer.fPols[16] = fColor ; buffer.fPols[17] = 3 ; buffer.fPols[18] = 2 ; // side 2; buffer.fPols[19] = 6 ; buffer.fPols[20] = 7 ;; buffer.fPols[21] = fColor ; buffer.fPols[22] = 3 ; buffer.fPols[23] = 3 ; // side 3; buffer.fPols[24] = 7 ; buffer.fPols[25] = 4 ;; ; buffer.SetSectionsValid(TBuffer3D::kRaw);; }; ; return buffer;; }; ; class MyGeom : public TObject, public TAtt3D; {; public:; MyGeom();; ~MyGeom() override;; ; void Draw(Option_t *option) override;; void Paint(Option_t *option) override;; ; private:; std::vector<Shape *> fShapes;; ; ClassDefOverride(MyGeom,0);; };; ; ClassImp(MyGeom);; ; MyGeom::MyGeom(); {; // Create our simple geometry - sphere, couple of boxes; // and a square base pyramid; Shape * aShape;; aShape = new Sphere(kYellow, 80.0, 60.0, 120.0, 10.0);; fShapes.push_back(aShape);; aShape = new Box(kRed, 0.0, 0.0, 0.0, 20.0, 20.0, 20.0);; fShapes.push_back(aShape);; aShape = new Box(kBlue, 50.0, 100.0, 200.0, 5.0, 10.0, 15.0);; fShapes.push_back(aShape);; aShape = new SBPyramid(kGreen, 20.0, 25.0, 45.0, 30.0, 30.0, 90.0);; fShapes.push_back(aShape);; }; ; MyGeom::~MyGeom(); {; // Clear out fShapes; }; ; void MyGeom::Draw(Option_t *option); {; TObject::Draw(option);; ; // Ask pad to create 3D viewer of type 'option'; gPad->GetViewer3D(option);; }; ; void MyGeom::Paint(Option_t * /*option*/); {; TVirtualViewer3D * viewer = gPad->GetViewer3D();; ; // If MyGeom derives from TAtt3D then pad will recognise; // that the object it is asking to paint is 3D, and open/close; // the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/viewer3DLocal_8C.html:13426,simpl,simple,13426,doc/master/viewer3DLocal_8C.html,https://root.cern,https://root.cern/doc/master/viewer3DLocal_8C.html,1,['simpl'],['simple']
Usability,"ts[fUniqueID] from the fPID object.; When the TRef is written, the process id number pidf of fPID is written in addition to the TObject part of the TRef (fBits,fUniqueID). When the TRef is read, its pointer fPID is set to the value stored in the TObjArray of TFile::fProcessIDs(fProcessIDs[pidf]).; When a referenced object is written, TObject::Streamer writes the pidf in addition to the standard fBits and fUniqueID. When TObject::Streamer reads a reference object, the pidf is read. At this point, the referenced object is entered into the table of objects of the TProcessID corresponding to pidf.; WARNING: If MyClass is the class of the referenced object, The TObject part of MyClass must be streamed. One should not call MyClass::Class()->IgnoreTObjectStreamer().; 11.4.4.1 TProccessID and TUUID; A TProcessID uniquely identifies a ROOT job. The TProcessID title consists of a TUUID object, which provides a globally unique identifier. The TUUID class implements the UUID (Universally Unique Identifier), also known as GUID (Globally Unique Identifier). A UUID is 128 bits long, and if generated according to this algorithm, is either guaranteed to be different from all other UUID generated until 3400 A.D. or extremely likely to be different.; The TROOT constructor automatically creates a TProcessID. When a TFile contains referenced objects, the TProcessID object is written to the file. If a file has been written in multiple sessions (same machine or not), a TProcessID is written for each session. The TProcessID objects are used by TRef to uniquely identify the referenced TObject.; When a referenced object is read from a file (its bit kIsReferenced is set), this object is entered into the objects table of the corresponding TProcessID. Each TFile has a list of TProcessIDs (see TFile::fProcessIDs) also accessible from TProcessID::fgPIDs (for all files). When this object is deleted, it is removed from the table via the cleanup mechanism invoked by the TObject destructor. Each TPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:483185,GUID,GUID,483185,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['GUID'],['GUID']
Usability,"ttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tfPhi1first phi limit; Float_tfPhi2second phi limit; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tTTUBE::fRminellipse semi-axis in X inside; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTUBS(); TUBS shape default constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape normal constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape ""simplified"" constructor. void MakeTableOfCoSin() const; Make table of sine and cosine. ~TTUBS(); TUBS shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a TUBE. Compute the closest distance of approach from point px,py to each; computed outline point of the TUBE. void SetPoints(Double_t* points) const; Create TUBS points. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3d. TTUBS(). Float_t GetPhi1() const; {return fPhi1;}. Float_t GetPhi2() const; {return fPhi2;}. » Author: Nenad Buncic 18/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT sup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTUBS.html:9588,simpl,simplified,9588,root/html534/TTUBS.html,https://root.cern,https://root.cern/root/html534/TTUBS.html,2,['simpl'],['simplified']
Usability,"ttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tfPhi1first phi limit; Float_tfPhi2second phi limit; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tTTUBE::fRminellipse semi-axis in X inside; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTUBS(); TUBS shape default constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape normal constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape ""simplified"" constructor. void MakeTableOfCoSin() const; Make table of sine and cosine. ~TTUBS(); TUBS shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a TUBE. Compute the closest distance of approach from point px,py to each; computed outline point of the TUBE. void SetPoints(Double_t* points) const; Create TUBS points. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3d. TTUBS(). Float_t GetPhi1() const; {return fPhi1;}. Float_t GetPhi2() const; {return fPhi2;}. » Author: Nenad Buncic 18/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id: TTUBS.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTUBS.html:9354,simpl,simplified,9354,root/html528/TTUBS.html,https://root.cern,https://root.cern/root/html528/TTUBS.html,1,['simpl'],['simplified']
Usability,"ttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tfPhi1first phi limit; Float_tfPhi2second phi limit; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tTTUBE::fRminellipse semi-axis in X inside; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTUBS(); TUBS shape default constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape normal constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape ""simplified"" constructor. void MakeTableOfCoSin() const; Make table of sine and cosine. ~TTUBS(); TUBS shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a TUBE. Compute the closest distance of approach from point px,py to each; computed outline point of the TUBE. void SetPoints(Double_t* points) const; Create TUBS points. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3d. TTUBS(). Float_t GetPhi1() const; {return fPhi1;}. Float_t GetPhi2() const; {return fPhi2;}. » Author: Nenad Buncic 18/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id: TTUBS.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTUBS.html:9423,simpl,simplified,9423,root/html530/TTUBS.html,https://root.cern,https://root.cern/root/html530/TTUBS.html,1,['simpl'],['simplified']
Usability,"ttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tfPhi1first phi limit; Float_tfPhi2second phi limit; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tTTUBE::fRminellipse semi-axis in X inside; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTUBS(); TUBS shape default constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape normal constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape ""simplified"" constructor. void MakeTableOfCoSin() const; Make table of sine and cosine. ~TTUBS(); TUBS shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a TUBE. Compute the closest distance of approach from point px,py to each; computed outline point of the TUBE. void SetPoints(Double_t* points) const; Create TUBS points. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3d. TTUBS(). Float_t GetPhi1() const; {return fPhi1;}. Float_t GetPhi2() const; {return fPhi2;}. » Author: Nenad Buncic 18/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id: TTUBS.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTUBS.html:9423,simpl,simplified,9423,root/html532/TTUBS.html,https://root.cern,https://root.cern/root/html532/TTUBS.html,2,['simpl'],['simplified']
Usability,"tte Line Color) and AMC (Palette Marker Color) ;  multipalette.C Draw color plots using different color palettes ;  seism.C Strip chart example ;  splines_test.C Examples of use of the spline classes ;  surfaces.C Draw 2-Dim functions ;  timeonaxis.C This macro illustrates the use of the time mode on the axis with different time intervals and time formats ;  timeonaxis2.C Define the time offset as 2003, January 1st ;  timeonaxis3.C This example compares what the system time function gmtime and localtime give with what gives TGaxis ;  waves.C Hint: Spherical waves ;  zdemo.C This macro is an example of graphs in log scales with annotations ;  zones.C Example of script showing how to divide a canvas into adjacent subpads + axis labels on the top and right side of the pads ;  ► gui;  buttonChangelabel.CThis macro gives an example for changing text button labels anytime the Start or Pause buttons are clicked ;  buttongroupState.CA simple example that shows the enabled and disabled state of a button group with radio and check buttons ;  buttonsLayout.CThis macro gives an example of different buttons' layout ;  buttonTest.CThis macro gives an example of how to set/change text button attributes ;  calendar.CThis macro gives an example of how to use html widget to display tabular data ;  CPUMeter.CSimple macro showing capabilities of the TGSpeedo widget ;  customContextMenu.CExample showing how to add a function to the class context menu ;  customTH1Fmenu.CExample showing how to customize a context menu for a class ;  drag_and_drop.CThis tutorial illustrates how to use drag and drop within ROOT ;  exec3.CExample of using signal/slot in TCanvas/TPad to get feedback about processed events ;  exec_macro.CThis utility macro executes the macro ""macro"" given as first argument and save a capture in a png file ;  games.CThis macro runs three ""games"" that each nicely illustrate the graphics capabilities of ROOT ;  gtreeTableTest.CThis TableTest class is a simple example of how to us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:118450,simpl,simple,118450,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['simpl'],['simple']
Usability,"tter action. ; By default, all functions with names like ""SetXXX"" or ""setXXX"" considered as setters. Another type of setters are Move, Resize operations; More complicated commands might want to override this function. ; Definition at line 440 of file TQCommand.cxx. ◆ IsUndoing(). Bool_t TQCommand::IsUndoing ; (; ); const. Undo action is in progress. ; Definition at line 808 of file TQCommand.cxx. ◆ ls(). void TQCommand::ls ; (; Option_t * ; option = """"); const. overridevirtual . ls this command and merged commands ; Reimplemented from TCollection.; Reimplemented in TQUndoManager.; Definition at line 848 of file TQCommand.cxx. ◆ Merge() [1/2]. Long64_t TQCommand::Merge ; (; TCollection * ; collection, . TFileMergeInfo * ;  . ). virtual . Merge a collection of TQCommand. ; Definition at line 337 of file TQCommand.cxx. ◆ Merge() [2/2]. void TQCommand::Merge ; (; TQCommand * ; c). virtual . Add command to the list of merged commands. ; This make it possible to group complex actions together so an end user can undo and redo them with one command. Execution of TQUndoManager::Undo(), TQUndoManager::Redo() methods only invokes the top level command as a whole.; Merge method is analogous to logical join operation.; Note: Merge method invokes redo action. ; Definition at line 329 of file TQCommand.cxx. ◆ operator=(). TQCommand & TQCommand::operator= ; (; const TQCommand & ; ). private . ◆ PrintCollectionHeader(). void TQCommand::PrintCollectionHeader ; (; Option_t * ; option); const. overrideprotectedvirtual . Print collection header. ; Reimplemented from TCollection.; Definition at line 864 of file TQCommand.cxx. ◆ Redo(). void TQCommand::Redo ; (; Option_t * ; option = """"). virtual . Execute command and then merge commands. ; Reimplemented in TQUndoManager.; Definition at line 588 of file TQCommand.cxx. ◆ SetArgs(). void TQCommand::SetArgs ; (; Int_t ; narg, .  ; ... . ). virtual . Set do/redo and undo parameters. ; The format is SetArgs(number_of_params, redo_params, undo_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:41706,undo,undo,41706,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"ttings, provided as a string in a key-value form. ;  ; void ReadWeightsFromStream (std::istream &);  ; virtual void ReadWeightsFromStream (std::istream &)=0;  Methods for writing and reading weights. ;  ; virtual void ReadWeightsFromStream (TFile &);  Methods for writing and reading weights. ;  ; void ReadWeightsFromXML (void *wghtnode);  ; void SetArchitectureString (TString architectureString);  ; void SetBatchDepth (size_t batchDepth);  ; void SetBatchHeight (size_t batchHeight);  ; void SetBatchSize (size_t batchSize);  ; void SetBatchWidth (size_t batchWidth);  ; void SetErrorStrategyString (TString errorStrategy);  ; void SetInputDepth (int inputDepth);  Setters. ;  ; void SetInputHeight (int inputHeight);  ; void SetInputShape (std::vector< size_t > inputShape);  ; void SetInputWidth (int inputWidth);  ; void SetLayoutString (TString layoutString);  ; void SetOutputFunction (DNN::EOutputFunction outputFunction);  ; void SetTrainingStrategyString (TString trainingStrategyString);  ; void SetWeightInitialization (DNN::EInitialization weightInitialization);  ; void SetWeightInitializationString (TString weightInitializationString);  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Train ();  Methods for training the deep learning network. ;  ;  Public Member Functions inherited from TMVA::MethodBase;  MethodBase (const TString &jobName, Types::EMVA methodType, const TString &methodTitle, DataSetInfo &dsi, const TString &theOption="""");  standard constructor ;  ;  MethodBase (Types::EMVA methodType, DataSetInfo &dsi, const TString &weightFile);  constructor used for Testing + Application of the MVA, only (no training), using given WeightFiles ;  ; virtual ~MethodBase ();  destructor ;  ; void AddOutput (Types::ETreeType type, Types::EAnalysisType analysisType);  ; TDirectory * BaseDir () const;  returns the ROOT directory where info/histograms etc of the corresponding MVA method instance are stored ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodDL.html:3689,learn,learning,3689,doc/master/classTMVA_1_1MethodDL.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodDL.html,1,['learn'],['learning']
Usability,"ttributes() const; const RooFormulaVar&RooResolutionModel::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:3435,clear,clearEvalError,3435,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,1,['clear'],['clearEvalError']
Usability,"tual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearAbsMin(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProfileLL.html:3691,clear,clearShapeDirty,3691,root/html526/RooProfileLL.html,https://root.cern,https://root.cern/root/html526/RooProfileLL.html,1,['clear'],['clearShapeDirty']
Usability,"tual function for retrieving title of the render-element. ;  ; virtual TString GetHighlightTooltip ();  ; virtual const TGPicture * GetListTreeCheckBoxIcon ();  Returns list-tree-item check-box picture appropriate for given rendering state. ;  ; virtual const TGPicture * GetListTreeIcon (Bool_t open=kFALSE);  Returns pointer to first listtreeicon. ;  ; virtual Color_t GetMainColor () const;  ; Color_t * GetMainColorPtr () const;  ; virtual Char_t GetMainTransparency () const;  ; TEveElement * GetMaster ();  Returns the master element - that is: ;  ; virtual Int_t GetNItems () const;  ; virtual TObject * GetObject (const TEveException &eh) const;  Get a TObject associated with this render-element. ;  ; Int_t GetParentIgnoreCnt () const;  Get number of parents that should be ignored in doing reference-counting. ;  ; virtual TObject * GetRenderObject (const TEveException &eh) const;  ; virtual Bool_t GetRnrAnything () const;  ; virtual Bool_t GetRnrChildren () const;  ; virtual Bool_t GetRnrSelf () const;  ; virtual Bool_t GetRnrState () const;  ; virtual UChar_t GetSelectedLevel () const;  Get selection level, needed for rendering selection and highlight feedback. ;  ; TRef & GetSource ();  ; TObject * GetSourceObject () const;  ; void * GetUserData () const;  ; TEveElement * GetVizModel () const;  ; const TString & GetVizTag () const;  ; Bool_t HasChild (TEveElement *el);  Check if element el is a child of this element. ;  ; Bool_t HasChildren () const;  ; virtual Bool_t HasMainColor () const;  ; virtual Bool_t HasMainTrans () const;  ; Bool_t HasParents () const;  ; virtual void HighlightElement (Bool_t state);  Set element's highlight state. Stamp appropriately. ;  ; void IncDenyDestroy ();  Increases the deny-destroy count of the element. ;  ; virtual void IncImpliedHighlighted ();  Increase element's implied-highlight count. Stamp appropriately. ;  ; virtual void IncImpliedSelected ();  Increase element's implied-selection count. Stamp appropriately. ;  ; void In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveSceneInfo.html:9309,feedback,feedback,9309,doc/master/classTEveSceneInfo.html,https://root.cern,https://root.cern/doc/master/classTEveSceneInfo.html,1,['feedback'],['feedback']
Usability,"tual function for retrieving title of the render-element. ;  ; virtual TString GetHighlightTooltip ();  ; virtual const TGPicture * GetListTreeCheckBoxIcon ();  Returns list-tree-item check-box picture appropriate for given rendering state. ;  ; virtual const TGPicture * GetListTreeIcon (Bool_t open=kFALSE);  Returns pointer to first listtreeicon. ;  ; virtual Color_t GetMainColor () const;  ; Color_t * GetMainColorPtr () const;  ; virtual Char_t GetMainTransparency () const;  ; TEveElement * GetMaster ();  Returns the master element - that is: ;  ; virtual Int_t GetNItems () const;  ; virtual TObject * GetObject (const TEveException &eh) const;  Get a TObject associated with this render-element. ;  ; Int_t GetParentIgnoreCnt () const;  Get number of parents that should be ignored in doing reference-counting. ;  ; virtual TObject * GetRenderObject (const TEveException &eh) const;  ; virtual Bool_t GetRnrAnything () const;  ; virtual Bool_t GetRnrChildren () const;  ; virtual Bool_t GetRnrSelf () const;  ; virtual Bool_t GetRnrState () const;  ; virtual UChar_t GetSelectedLevel () const;  Get selection level, needed for rendering selection and highlight feedback. ;  ; TRef & GetSource ();  ; TObject * GetSourceObject () const;  ; void * GetUserData () const;  ; TEveElement * GetVizModel () const;  ; const TString & GetVizTag () const;  ; virtual Bool_t HandleElementPaste (TEveElement *el);  React to element being pasted or dnd-ed. ;  ; Bool_t HasChild (TEveElement *el);  Check if element el is a child of this element. ;  ; Bool_t HasChildren () const;  ; virtual Bool_t HasMainColor () const;  ; virtual Bool_t HasMainTrans () const;  ; Bool_t HasParents () const;  ; virtual void HighlightElement (Bool_t state);  Set element's highlight state. Stamp appropriately. ;  ; void IncDenyDestroy ();  Increases the deny-destroy count of the element. ;  ; virtual void IncImpliedHighlighted ();  Increase element's implied-highlight count. Stamp appropriately. ;  ; virtual void I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCalo2D.html:14840,feedback,feedback,14840,doc/master/classTEveCalo2D.html,https://root.cern,https://root.cern/doc/master/classTEveCalo2D.html,9,['feedback'],['feedback']
Usability,"tual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); RooStats::TestStatisticRooStats::TestStatistic::TestStatistic(); RooStats::TestStatisticRooStats::TestStatistic::TestStatistic(const RooStats::TestStatistic&). Data Members; private:. RooArgSet*fAltParameters; RooAbsPdf*fAltPdf; RooArgSetfConditionalObs; RooArgSet*fDetailedOutput!; boolfDetailedOutputEnabled; boolfFirstEval; RooAbsReal*fNllAlt! transient copy of the alt NLL; RooAbsReal*fNllNull! transient copy of the null NLL; RooArgSet*fNullParameters; RooAbsPdf*fNullPdf; Bool_tfReuseNll; static Bool_tfgAlwaysReuseNll. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetAlwaysReuseNLL(Bool_t flag); { fgAlwaysReuseNll = flag ; }. Double_t Evaluate(RooAbsData& data, RooArgSet& nullPOI). SimpleLikelihoodRatioTestStat(). SimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf). SimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf, const RooArgSet& nullParameters, const RooArgSet& altParameters). virtual ~SimpleLikelihoodRatioTestStat(). void SetReuseNLL(Bool_t flag); { fReuseNll = flag ; }. void SetNullParameters(const RooArgSet& nullParameters). void SetAltParameters(const RooArgSet& altParameters). bool ParamsAreEqual(). void SetConditionalObservables(const RooArgSet& set); set the conditional observables which will be used when creating the NLL; so the pdf's will not be normalized on the conditional observables when computing the NLL. {fConditionalObs.removeAll(); fConditionalObs.add(set);}. void EnableDetailedOutput(bool e = true); { fDetailedOutputEnabled = e; fDetailedOutput = NULL; }. const RooArgSet* GetDetailedOutput(void); { return fDetailedOutput; }. const TString GetVarName() const. » Author: Kyle Cranmer and Sven Kreiss June 2010 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-30 14:37; This page has been automatically gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__SimpleLikelihoodRatioTestStat.html:2628,Simpl,SimpleLikelihoodRatioTestStat,2628,root/html602/RooStats__SimpleLikelihoodRatioTestStat.html,https://root.cern,https://root.cern/root/html602/RooStats__SimpleLikelihoodRatioTestStat.html,1,['Simpl'],['SimpleLikelihoodRatioTestStat']
Usability,"tual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); RooStats::TestStatisticRooStats::TestStatistic::TestStatistic(); RooStats::TestStatisticRooStats::TestStatistic::TestStatistic(const RooStats::TestStatistic&). Data Members; private:. RooArgSet*fAltParameters; RooAbsPdf*fAltPdf; RooArgSetfConditionalObs; RooArgSet*fDetailedOutput!; boolfDetailedOutputEnabled; boolfFirstEval; RooAbsReal*fNllAlt! transient copy of the alt NLL; RooAbsReal*fNllNull! transient copy of the null NLL; RooArgSet*fNullParameters; RooAbsPdf*fNullPdf; Bool_tfReuseNll; static Bool_tfgAlwaysReuseNll. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetAlwaysReuseNLL(Bool_t flag); { fgAlwaysReuseNll = flag ; }. Double_t Evaluate(RooAbsData& data, RooArgSet& nullPOI). SimpleLikelihoodRatioTestStat(). SimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf). SimpleLikelihoodRatioTestStat(RooAbsPdf& nullPdf, RooAbsPdf& altPdf, const RooArgSet& nullParameters, const RooArgSet& altParameters). virtual ~SimpleLikelihoodRatioTestStat(). void SetReuseNLL(Bool_t flag); { fReuseNll = flag ; }. void SetNullParameters(const RooArgSet& nullParameters). void SetAltParameters(const RooArgSet& altParameters). bool ParamsAreEqual(). void SetConditionalObservables(const RooArgSet& set); set the conditional observables which will be used when creating the NLL; so the pdf's will not be normalized on the conditional observables when computing the NLL. {fConditionalObs.removeAll(); fConditionalObs.add(set);}. void EnableDetailedOutput(bool e = true); { fDetailedOutputEnabled = e; fDetailedOutput = NULL; }. const RooArgSet* GetDetailedOutput(void); { return fDetailedOutput; }. const TString GetVarName() const. » Author: Kyle Cranmer and Sven Kreiss June 2010 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-09-08 17:42; This page has been automatically gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooStats__SimpleLikelihoodRatioTestStat.html:2628,Simpl,SimpleLikelihoodRatioTestStat,2628,root/html604/RooStats__SimpleLikelihoodRatioTestStat.html,https://root.cern,https://root.cern/root/html604/RooStats__SimpleLikelihoodRatioTestStat.html,1,['Simpl'],['SimpleLikelihoodRatioTestStat']
Usability,"tual voidTEveElement::AddStamp(UChar_t bits); virtual voidTEveElement::Annihilate(); virtual voidTEveElement::AnnihilateElements(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; voidCloseBins(); virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(); voidTEveElement::C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEvePointSetArray.html:2709,Clear,ClearStamps,2709,root/html532/TEvePointSetArray.html,https://root.cern,https://root.cern/root/html532/TEvePointSetArray.html,4,['Clear'],['ClearStamps']
Usability,"tual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); voidDrawNeedle(); voidDrawText(); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE); voidTranslate(Float_t val, Float_t angle, Int_t* x, Int_t* y). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditModeTGWindow::kEditDisableEvents; static TGWindow::EEditModeTGWindow::kEditDisableGrab; static TGWindow::EEditMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGSpeedo.html:15188,Clear,ClearFlags,15188,root/html602/TGSpeedo.html,https://root.cern,https://root.cern/root/html602/TGSpeedo.html,2,['Clear'],['ClearFlags']
Usability,"tual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidDrawBottomLeft(); virtual voidDrawBottomRight(); virtual voidDrawCenterX(); virtual voidDrawCenterY(); virtual voidDrawExpandX(); virtual voidDrawExpandY(); virtual voidDrawTopLeft(); virtual voidDrawTopRight(); virtual voidTGButton::EmitSignals(Bool_t wasUp); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGButton::SetToggleButton(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGuiBldHintsButton.html:15155,Clear,ClearFlags,15155,root/html602/TGuiBldHintsButton.html,https://root.cern,https://root.cern/root/html602/TGuiBldHintsButton.html,2,['Clear'],['ClearFlags']
Usability,"tualBranchBrowsable::RegisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator); voidTVirtualBranchBrowsable::SetType(TClass* type); voidTVirtualBranchBrowsable::SetTypeIsPointer(Bool_t set = kTRUE); static voidTVirtualBranchBrowsable::UnregisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TMethod*fMethodpointer to a method. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0); Constructor.; Links a TBranchElement to a TMethod, allowing the TBrowser to; browse simple methods. The c'tor sets the name for a method ""Class::Method(params) const""; to ""Method(params)"", title to TMethod::GetPrototype. void GetBrowsableMethodsForClass(TClass* cl, TList& list); Given a class, this methods fills list with TMethodBrowsables; for the class and its base classes, and returns the number of; added elements. If called from a TBranch::Browse overload, ""branch""; should be set to the calling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being brows",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMethodBrowsable.html:9015,simpl,simple,9015,root/html528/TMethodBrowsable.html,https://root.cern,https://root.cern/root/html528/TMethodBrowsable.html,6,['simpl'],['simple']
Usability,"tualCollectionProxy* Generate() const; Virtual copy constructor. TEmulatedCollectionProxy(const TEmulatedCollectionProxy& copy); Copy constructor. TEmulatedCollectionProxy(const char* cl_name, Bool_t silent); Initializing constructor. virtual ~TEmulatedCollectionProxy(); Standard destructor. void* New() const; Virtual constructor. { return new Cont_t; }. void* New(void* memory) const; Virtual in-place constructor. { return new(memory) Cont_t; }. void* NewArray(Int_t nElements) const; Virtual array constructor. { return new Cont_t[nElements]; }. void* NewArray(Int_t nElements, void* memory) const; Virtual in-place constructor. { return new(memory) Cont_t[nElements]; }. void Destructor(void* p, Bool_t dtorOnly = kFALSE) const; Virtual destructor. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; Virtual array destructor. UInt_t Sizeof() const; TVirtualCollectionProxy overload: Return the sizeof the collection object. { return sizeof(Cont_t); }. void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. void Resize(UInt_t n, Bool_t force_delete); Resize the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete); Block allocation of containees. void Commit(void* env); Block commit of containees. void ReadBuffer(TBuffer& buff, void* pObj); Read portion of the streamer. void ReadBuffer(TBuffer& buff, void* pObj, const TClass* onfile). void Streamer(TBuffer& refBuffer); Streamer for I/O handling. void Streamer(TBuffer& buff, void* pObj, int siz); Streamer I/O overload. Bool_t IsValid() const; Check validity of the proxy itself. » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-09-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEmulatedCollectionProxy.html:8808,Clear,Clear,8808,root/html534/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TEmulatedCollectionProxy.html,2,['Clear'],['Clear']
Usability,"tual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:48020,clear,clearing,48020,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['clear'],['clearing']
Usability,ture* TTreeViewer::fPicRefr. private . Pictures for Refresh buttons ///<ia. ; Definition at line 95 of file TTreeViewer.h. ◆ fPicStop. const TGPicture* TTreeViewer::fPicStop. private . Pictures for Stop buttons. ; Definition at line 94 of file TTreeViewer.h. ◆ fPicX. const TGPicture* TTreeViewer::fPicX. private . Pictures for X expressions. ; Definition at line 90 of file TTreeViewer.h. ◆ fPicY. const TGPicture* TTreeViewer::fPicY. private . Pictures for Y expressions. ; Definition at line 91 of file TTreeViewer.h. ◆ fPicZ. const TGPicture* TTreeViewer::fPicZ. private . Pictures for Z expressions. ; Definition at line 92 of file TTreeViewer.h. ◆ fProgressBar. TGHProgressBar* TTreeViewer::fProgressBar. private . Progress bar. ; Definition at line 152 of file TTreeViewer.h. ◆ fREFR. TGPictureButton* TTreeViewer::fREFR. private . REFRESH button ///<ia. ; Definition at line 160 of file TTreeViewer.h. ◆ fReset. TGTextButton* TTreeViewer::fReset. private . clear expression's entries ; Definition at line 168 of file TTreeViewer.h. ◆ fRunMenu. TGPopupMenu* TTreeViewer::fRunMenu. private . Definition at line 113 of file TTreeViewer.h. ◆ fScanMode. bool TTreeViewer::fScanMode. private . Flag activated when Scan Box is double-clicked. ; Definition at line 85 of file TTreeViewer.h. ◆ fSession. TTVSession* TTreeViewer::fSession. private . Current tree-viewer session. ; Definition at line 77 of file TTreeViewer.h. ◆ fSlider. TGDoubleVSlider* TTreeViewer::fSlider. private . Vertical slider to select processed tree entries;. ; Definition at line 143 of file TTreeViewer.h. ◆ fSourceFile. const char* TTreeViewer::fSourceFile. private . Name of the C++ source file - default treeviewer.C. ; Definition at line 79 of file TTreeViewer.h. ◆ fSPIDER. TGTextButton* TTreeViewer::fSPIDER. private . SPIDER button. ; Definition at line 158 of file TTreeViewer.h. ◆ fStatusBar. TGStatusBar* TTreeViewer::fStatusBar. private . Status bar. ; Definition at line 161 of file TTreeViewer.h. ◆ fSTOP. TGPic,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeViewer.html:64656,clear,clear,64656,doc/master/classTTreeViewer.html,https://root.cern,https://root.cern/doc/master/classTTreeViewer.html,1,['clear'],['clear']
Usability,"ture_t>; 388VGeneralLayer<Architecture_t>::~VGeneralLayer(); 389{; 390 // Nothing to do here.; 391}; 392 ; 393//_________________________________________________________________________________________________; 394template <typename Architecture_t>; 395auto VGeneralLayer<Architecture_t>::Initialize() -> void; 396{; 397 for (size_t i = 0; i < fWeights.size(); i++) {; 398 initialize<Architecture_t>(fWeights[i], this->GetInitialization());; 399 initialize<Architecture_t>(fWeightGradients[i], EInitialization::kZero);; 400 }; 401 ; 402 for (size_t i = 0; i < fBiases.size(); i++) {; 403 initialize<Architecture_t>(fBiases[i], EInitialization::kZero);; 404 initialize<Architecture_t>(fBiasGradients[i], EInitialization::kZero);; 405 }; 406}; 407 ; 408//_________________________________________________________________________________________________; 409template <typename Architecture_t>; 410auto VGeneralLayer<Architecture_t>::Update(const Scalar_t learningRate) -> void; 411{; 412 this->UpdateWeights(fWeightGradients, learningRate);; 413 this->UpdateBiases(fBiasGradients, learningRate);; 414}; 415 ; 416//_________________________________________________________________________________________________; 417template <typename Architecture_t>; 418auto VGeneralLayer<Architecture_t>::UpdateWeights(const std::vector<Matrix_t> &weightGradients,; 419 const Scalar_t learningRate) -> void; 420{; 421 for (size_t i = 0; i < fWeights.size(); i++) {; 422 Architecture_t::ScaleAdd(fWeights[i], weightGradients[i], -learningRate);; 423 }; 424}; 425 ; 426//_________________________________________________________________________________________________; 427template <typename Architecture_t>; 428auto VGeneralLayer<Architecture_t>::UpdateBiases(const std::vector<Matrix_t> &biasGradients,; 429 const Scalar_t learningRate) -> void; 430{; 431 for (size_t i = 0; i < fBiases.size(); i++) {; 432 Architecture_t::ScaleAdd(fBiases[i], biasGradients[i], -learningRate);; 433 }; 434}; 435 ; 436//_______________",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GeneralLayer_8h_source.html:18759,learn,learningRate,18759,doc/master/GeneralLayer_8h_source.html,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html,4,['learn'],['learningRate']
Usability,"turn false;; 3215}; 3216 ; 3217////////////////////////////////////////////////////////////////////////////////; 3218 ; 3219void ExtractHeadersForDecls(const RScanner::ClassColl_t &annotatedRcds,; 3220 const RScanner::TypedefColl_t tDefDecls,; 3221 const RScanner::FunctionColl_t funcDecls,; 3222 const RScanner::VariableColl_t varDecls,; 3223 const RScanner::EnumColl_t enumDecls,; 3224 HeadersDeclsMap_t &headersClassesMap,; 3225 HeadersDeclsMap_t &headersDeclsMap,; 3226 const cling::Interpreter &interp); 3227{; 3228 std::set<const clang::CXXRecordDecl *> visitedDecls;; 3229 std::unordered_set<std::string> buffer;; 3230 std::string autoParseKey;; 3231 ; 3232 // Add some manip of headers; 3233 for (auto & annotatedRcd : annotatedRcds) {; 3234 if (const clang::CXXRecordDecl *cxxRcd =; 3235 llvm::dyn_cast_or_null<clang::CXXRecordDecl>(annotatedRcd.GetRecordDecl())) {; 3236 autoParseKey = """";; 3237 visitedDecls.clear();; 3238 std::list<std::string> headers(RecordDecl2Headers(*cxxRcd, interp, visitedDecls));; 3239 // remove duplicates, also if not subsequent; 3240 buffer.clear();; 3241 headers.remove_if([&buffer](const std::string & s) {; 3242 return !buffer.insert(s).second;; 3243 });; 3244 GetMostExternalEnclosingClassName(*cxxRcd, autoParseKey, interp);; 3245 if (autoParseKey.empty()) autoParseKey = annotatedRcd.GetNormalizedName();; 3246 if (IsGoodForAutoParseMap(*cxxRcd)){; 3247 headersDeclsMap[autoParseKey] = headers;; 3248 headersDeclsMap[annotatedRcd.GetRequestedName()] = headers;; 3249 } else {; 3250 ROOT::TMetaUtils::Info(nullptr, ""Class %s is not included in the set of autoparse keys.\n"", autoParseKey.c_str());; 3251 }; 3252 ; 3253 // Propagate to the classes map only if this is not a template.; 3254 // The header is then used as autoload key and we want to avoid duplicates.; 3255 if (!llvm::isa<clang::ClassTemplateSpecializationDecl>(cxxRcd)){; 3256 headersClassesMap[autoParseKey] = headersDeclsMap[autoParseKey];; 3257 headersClassesMap[annotatedRcd.GetRequeste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:128543,clear,clear,128543,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['clear'],['clear']
Usability,"turn layerPatternData;; 1216}; 1217 ; 1218 ; 1219 ; 1220 template <typename LayerContainer>; 1221 void Net::forwardPattern (const LayerContainer& _layers,; 1222 std::vector<LayerData>& layerData) const; 1223 {; 1224 size_t idxLayer = 0, idxLayerEnd = _layers.size ();; 1225 for (; idxLayer < idxLayerEnd; ++idxLayer); 1226 {; 1227 LayerData& prevLayerData = layerData.at (idxLayer);; 1228 LayerData& currLayerData = layerData.at (idxLayer+1);; 1229 ; 1230 forward (prevLayerData, currLayerData);; 1231 ; 1232 applyFunctions (currLayerData.valuesBegin (), currLayerData.valuesEnd (), currLayerData.activationFunction ());; 1233 }; 1234 }; 1235 ; 1236 ; 1237 ; 1238 ; 1239 template <typename LayerContainer, typename LayerPatternContainer>; 1240 void Net::forwardBatch (const LayerContainer& _layers,; 1241 LayerPatternContainer& layerPatternData,; 1242 std::vector<double>& valuesMean,; 1243 std::vector<double>& valuesStdDev,; 1244 size_t trainFromLayer) const; 1245 {; 1246 valuesMean.clear ();; 1247 valuesStdDev.clear ();; 1248 ; 1249 // ---------------------------------- loop over layers and pattern -------------------------------------------------------; 1250 for (size_t idxLayer = 0, idxLayerEnd = layerPatternData.size (); idxLayer < idxLayerEnd-1; ++idxLayer); 1251 {; 1252 bool doTraining = idxLayer >= trainFromLayer;; 1253 ; 1254 // get layer-pattern data for this and the corresponding one from the next layer; 1255 std::vector<LayerData>& prevLayerPatternData = layerPatternData.at (idxLayer);; 1256 std::vector<LayerData>& currLayerPatternData = layerPatternData.at (idxLayer+1);; 1257 ; 1258 size_t numPattern = prevLayerPatternData.size ();; 1259 size_t numNodesLayer = _layers.at (idxLayer).numNodes ();; 1260 ; 1261 std::vector<MeanVariance> means (numNodesLayer);; 1262 // ---------------- loop over layerDatas of pattern compute forward ----------------------------; 1263 for (size_t idxPattern = 0; idxPattern < numPattern; ++idxPattern); 1264 {; 1265 const LayerData& prevLaye",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:40540,clear,clear,40540,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['clear'],['clear']
Usability,"turn nullptr;; 2301 }; 2302 // Change the volume for the new node; 2303 newnode->SetVolume(vol);; 2304 // Replace the matrix; 2305 if (newpos && !nodeorig->IsOffset()) {; 2306 TGeoNodeMatrix *nodemat = (TGeoNodeMatrix *)newnode;; 2307 nodemat->SetMatrix(newpos);; 2308 }; 2309 // Replace nodeorig with new one; 2310 fNodes->RemoveAt(ind);; 2311 fNodes->AddAt(newnode, ind);; 2312 if (fVoxels); 2313 fVoxels->SetNeedRebuild();; 2314 if (IsAssembly()); 2315 fShape->ComputeBBox();; 2316 return newnode;; 2317}; 2318 ; 2319////////////////////////////////////////////////////////////////////////////////; 2320/// Select this volume as matching an arbitrary criteria. The volume is added to; 2321/// a static list and the flag TGeoVolume::kVolumeSelected is set. All flags need; 2322/// to be reset at the end by calling the method with CLEAR=true. This will also clear; 2323/// the list.; 2324 ; 2325void TGeoVolume::SelectVolume(Bool_t clear); 2326{; 2327 static TObjArray array(256);; 2328 static Int_t len = 0;; 2329 Int_t i;; 2330 TObject *vol;; 2331 if (clear) {; 2332 for (i = 0; i < len; i++) {; 2333 vol = array.At(i);; 2334 vol->ResetBit(TGeoVolume::kVolumeSelected);; 2335 }; 2336 array.Clear();; 2337 len = 0;; 2338 return;; 2339 }; 2340 SetBit(TGeoVolume::kVolumeSelected);; 2341 array.AddAtAndExpand(this, len++);; 2342}; 2343 ; 2344////////////////////////////////////////////////////////////////////////////////; 2345/// set visibility of this volume; 2346 ; 2347void TGeoVolume::SetVisibility(Bool_t vis); 2348{; 2349 TGeoAtt::SetVisibility(vis);; 2350 if (fGeoManager->IsClosed()); 2351 SetVisTouched(kTRUE);; 2352 fGeoManager->SetVisOption(4);; 2353 TSeqCollection *brlist = gROOT->GetListOfBrowsers();; 2354 TIter next(brlist);; 2355 TBrowser *browser = nullptr;; 2356 while ((browser = (TBrowser *)next())) {; 2357 browser->CheckObjectItem(this, vis);; 2358 browser->Refresh();; 2359 }; 2360}; 2361 ; 2362///////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:86344,clear,clear,86344,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,2,['clear'],['clear']
Usability,"turn the Hue, Light, Saturation (HLS) definition of this RColor */; 163 bool GetHLS(float &hue, float &light, float &satur) const;; 164 ; 165 /** Set the Red Green and Blue (RGB) values from the Hue, Light, Saturation (HLS). */; 166 void SetHLS(float hue, float light, float satur);; 167 ; 168 std::string AsHex(bool with_alpha = false) const;; 169 std::string AsSVG() const;; 170 ; 171 void Clear(); 172 {; 173 fColor.clear();; 174 }; 175 ; 176 static const RColor &AutoColor();; 177 ; 178 R__DLLEXPORT static constexpr RGB_t kBlack{{0, 0, 0}};; 179 R__DLLEXPORT static constexpr RGB_t kGreen{{0, 0x80, 0}};; 180 R__DLLEXPORT static constexpr RGB_t kLime{{0, 0xFF, 0}};; 181 R__DLLEXPORT static constexpr RGB_t kAqua{{0, 0xFF, 0xFF}};; 182 R__DLLEXPORT static constexpr RGB_t kPurple{{0x80, 0, 0x80}};; 183 R__DLLEXPORT static constexpr RGB_t kGrey{{0x80, 0x80, 0x80}};; 184 R__DLLEXPORT static constexpr RGB_t kFuchsia{{0xFF, 0, 0xFF}};; 185 R__DLLEXPORT static constexpr RGB_t kNavy{{0, 0, 0x80}};; 186 R__DLLEXPORT static constexpr RGB_t kBlue{{0, 0, 0xff}};; 187 R__DLLEXPORT static constexpr RGB_t kTeal{{0, 0x80, 0x80}};; 188 R__DLLEXPORT static constexpr RGB_t kOlive{{0x80, 0x80, 0}};; 189 R__DLLEXPORT static constexpr RGB_t kSilver{{0xc0, 0xc0, 0xc0}};; 190 R__DLLEXPORT static constexpr RGB_t kMaroon{{0x80, 0, 0}};; 191 R__DLLEXPORT static constexpr RGB_t kRed{{0xff, 0, 0}};; 192 R__DLLEXPORT static constexpr RGB_t kYellow{{0xff, 0xff, 0}};; 193 R__DLLEXPORT static constexpr RGB_t kWhite{{0xff, 0xff, 0xff}};; 194 R__DLLEXPORT static constexpr float kTransparent{0.};; 195 R__DLLEXPORT static constexpr float kSemiTransparent{0.5};; 196 R__DLLEXPORT static constexpr float kOpaque{1.};; 197 ; 198 friend bool operator==(const RColor &lhs, const RColor &rhs); 199 {; 200 if (lhs.fColor == rhs.fColor) return true;; 201 ; 202 auto l = lhs.AsRGBA();; 203 auto r = rhs.AsRGBA();; 204 ; 205 return !l.empty() && (l == r);; 206 }; 207};; 208 ; 209} // namespace Experimental; 210} // namesp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RColor_8hxx_source.html:5223,clear,clear,5223,doc/master/RColor_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RColor_8hxx_source.html,1,['clear'],['clear']
Usability,"turn the list of header files to include to be able to compile this rule as a TObjArray of TObjString. ;  ; ReadFuncPtr_t GetReadFunctionPointer () const;  Get the pointer to the function to be run for the rule (if it is a read rule). ;  ; ReadRawFuncPtr_t GetReadRawFunctionPointer () const;  Get the pointer to the function to be run for the rule (if it is a raw read rule). ;  ; RuleType_t GetRuleType () const;  Return the type of the rule. ;  ; const TObjArray * GetSource () const;  Get the list of source members as a TObjArray of TNamed object, with the name being the member name and the title being its type. ;  ; const char * GetSourceClass () const;  Get the source class of this rule (i.e. the onfile class). ;  ; const TObjArray * GetTarget () const;  Get the target data members of this rule (i.e. the in memory data member). ;  ; const char * GetTargetClass () const;  Get the targte class of this rule (i.e. the in memory class). ;  ; const char * GetTargetString () const;  Get the target data members of this rule as a simple string (i.e. the in memory data member). ;  ; const char * GetVersion () const;  Get the version string. ;  ; Bool_t HasSource (const TString &source) const;  Return true if one of the rule's data member source is 'source'. ;  ; Bool_t HasTarget (const TString &target) const;  Return true if one of the rule's data member target is 'target'. ;  ; TClass * IsA () const override;  ; Bool_t IsAliasRule () const;  Return kTRUE if the rule is a strict renaming of one of the data member of the class. ;  ; Bool_t IsRenameRule () const;  Return kTRUE if the rule is a strict renaming of the class to a new name. ;  ; Bool_t IsValid () const;  Return kTRUE if this rule is valid. ;  ; void ls (Option_t *option="""") const override;  The ls function lists the contents of a class on stdout. ;  ; TSchemaRule & operator= (const TSchemaRule &rhs);  Copy operator. ;  ; Bool_t operator== (const TSchemaRule &rhs) const;  Return true if the rule have the same effect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html:3101,simpl,simple,3101,doc/v632/classROOT_1_1TSchemaRule.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html,2,['simpl'],['simple']
Usability,"turning an optional hint for initial sampling points when constructing a curve projected on observable obs. ; Parameters. [in]obsObservable to retrieve sampling hint for. ; [in]xloBeginning of range. ; [in]xhiEnd of range. . ReturnsThe caller owns the returned std::list. ; Reimplemented from RooAbsReal.; Definition at line 627 of file RooRealSumPdf.cxx. ◆ plotSamplingHint() [2/2]. std::list< double > * RooRealSumPdf::plotSamplingHint ; (; RooArgList const & ; funcList, . RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ). staticprivate . Definition at line 633 of file RooRealSumPdf.cxx. ◆ printMetaArgs() [1/2]. void RooRealSumPdf::printMetaArgs ; (; RooArgList const & ; funcList, . RooArgList const & ; coefList, . std::ostream & ; os . ). staticprivate . Definition at line 706 of file RooRealSumPdf.cxx. ◆ printMetaArgs() [2/2]. void RooRealSumPdf::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the product operator construction. ; Reimplemented from RooAbsArg.; Definition at line 700 of file RooRealSumPdf.cxx. ◆ selfNormalized(). bool RooRealSumPdf::selfNormalized ; (; ); const. inlineoverridevirtual . Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ; Always returns false, unless a PDF overrides this function. ; Reimplemented from RooAbsPdf.; Definition at line 53 of file RooRealSumPdf.h. ◆ setCacheAndTrackHints() [1/2]. void RooRealSumPdf::setCacheAndTrackHints ; (; RooArgList const & ; funcList, . RooArgSet & ; trackNodes . ). staticprivate . Definition at line 686 of file RooRealSumPdf.cxx. ◆ setCacheAndTrackHints() [2/2]. void RooRealSumPdf::setCacheAndTrackHints ; (; RooArgSet & ; trackNodes). overridevirtual . Label OK'ed components of a RooRealSumPdf with cache-and-track. ; Reimplemented from RooAbsArg.; Definition at line 680 of file RooRealSumPdf.cxx. ◆ setExtended(). void RooRealSumPd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealSumPdf.html:89113,intuit,intuitively,89113,doc/master/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/master/classRooRealSumPdf.html,1,['intuit'],['intuitively']
Usability,"turning an optional hint for initial sampling points when constructing a curve projected on observable obs. ; Parameters. [in]obsObservable to retrieve sampling hint for. ; [in]xloBeginning of range. ; [in]xhiEnd of range. . ReturnsThe caller owns the returned std::list. ; Reimplemented from RooAbsReal.; Definition at line 632 of file RooRealSumPdf.cxx. ◆ plotSamplingHint() [2/2]. std::list< double > * RooRealSumPdf::plotSamplingHint ; (; RooArgList const & ; funcList, . RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ). staticprivate . Definition at line 637 of file RooRealSumPdf.cxx. ◆ printMetaArgs() [1/2]. void RooRealSumPdf::printMetaArgs ; (; RooArgList const & ; funcList, . RooArgList const & ; coefList, . std::ostream & ; os . ). staticprivate . Definition at line 714 of file RooRealSumPdf.cxx. ◆ printMetaArgs() [2/2]. void RooRealSumPdf::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the product operator construction. ; Reimplemented from RooAbsArg.; Definition at line 708 of file RooRealSumPdf.cxx. ◆ selfNormalized(). bool RooRealSumPdf::selfNormalized ; (; ); const. inlineoverridevirtual . Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ; Always returns false, unless a PDF overrides this function. ; Reimplemented from RooAbsPdf.; Definition at line 53 of file RooRealSumPdf.h. ◆ setCacheAndTrackHints() [1/2]. void RooRealSumPdf::setCacheAndTrackHints ; (; RooArgList const & ; funcList, . RooArgSet & ; trackNodes . ). staticprivate . Definition at line 693 of file RooRealSumPdf.cxx. ◆ setCacheAndTrackHints() [2/2]. void RooRealSumPdf::setCacheAndTrackHints ; (; RooArgSet & ; trackNodes). overridevirtual . Label OK'ed components of a RooRealSumPdf with cache-and-track. ; Reimplemented from RooAbsArg.; Definition at line 687 of file RooRealSumPdf.cxx. ◆ setExtended(). void RooRealSumPd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumPdf.html:90234,intuit,intuitively,90234,doc/v632/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumPdf.html,1,['intuit'],['intuitively']
Usability,turns const iterator to the end of the gradients; 602 ; 603 iterator_type gradientsBegin () { assert (m_hasGradients); return m_itGradientBegin; } ///< returns iterator to the begin of the gradients; 604 const_iterator_type gradientsBegin () const { assert (m_hasGradients); return m_itGradientBegin; } ///< returns const iterator to the begin of the gradients; 605 const_iterator_type weightsBegin () const { assert (m_hasWeights); return m_itConstWeightBegin; } ///< returns const iterator to the begin of the weights for this layer; 606 ; 607 std::shared_ptr<std::function<double(double)>> activationFunction () const { return m_activationFunction; }; 608 std::shared_ptr<std::function<double(double)>> inverseActivationFunction () const { return m_inverseActivationFunction; }; 609 ; 610 /*! \brief set the drop-out info for this layer; 611 *; 612 */; 613 template <typename Iterator>; 614 void setDropOut (Iterator itDrop) { m_itDropOut = itDrop; m_hasDropOut = true; }; 615 ; 616 /*! \brief clear the drop-out-data for this layer; 617 *; 618 *; 619 */; 620 void clearDropOut () { m_hasDropOut = false; }; 621 ; 622 bool hasDropOut () const { return m_hasDropOut; } ///< has this layer drop-out turned on?; 623 const_dropout_iterator dropOut () const { assert (m_hasDropOut); return m_itDropOut; } ///< return the begin of the drop-out information; 624 ; 625 size_t size () const { return m_size; } ///< return the size of the layer; 626 ; 627 private:; 628 ; 629 /*! \brief compute the probabilities from the node values; 630 *; 631 *; 632 */; 633 container_type computeProbabilities () const;; 634 ; 635 private:; 636 ; 637 size_t m_size; ////< layer size; 638 ; 639 const_iterator_type m_itInputBegin; ///< iterator to the first of the nodes in the input node vector; 640 const_iterator_type m_itInputEnd; ///< iterator to the end of the nodes in the input node vector; 641 ; 642 std::vector<double> m_deltas; ///< stores the deltas for the DNN training; 643 std::vector<double> m_valueGradie,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:21134,clear,clear,21134,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['clear'],['clear']
Usability,"tus; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query information frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSessionQueryFrame.html:21474,progress bar,progress bar,21474,root/html534/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html534/TSessionQueryFrame.html,2,['progress bar'],['progress bar']
Usability,"tus; TGTextButton*fStop; TGTextBuffer*fTextQuery; TGLabel*fTimeLab; TGLabel*fTitleLab; TGraph*fTotSGraph; TGLabel*fTotal; TGTextButton*fUpdtSpeedo; static Bool_tfgKeepDefault; static Bool_tfgLogQueryDefault; static TStringfgTextQueryDefault; static TProofProgressDialog::EQueryStatuskAborted; static TProofProgressDialog::EQueryStatuskDone; static TProofProgressDialog::EQueryStatuskIncomplete; static TProofProgressDialog::EQueryStatuskRunning; static TProofProgressDialog::EQueryStatuskStopped. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries); Create PROOF processing progress dialog. void ToggleOdometerInfos(); Toggle information displayed in Analog Meter. void ToggleThreshold(). void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset dialog box preparing for new query. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. Float_t AdjustBytes(Float_t mbs, TString& sf); Transform MBs to GBs ot TBs and get the correct suffix. ~TProofProgressDialog(); Cleanup dialog. void CloseWindow(); Called when dialog is closed. void DisableAsyn(); Disable the asyn switch when an external request for going asynchronous is issued. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void DoClose(); Close dialog. void DoLog(); Ask proof session for logs. void DoKeep(Bool_t on); Handle keep toggle but",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofProgressDialog.html:3853,progress bar,progress bar,3853,root/html602/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html602/TProofProgressDialog.html,4,['progress bar'],['progress bar']
Usability,"two histograms with different scales ;  twoscales.C Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad ;  twoscales.py Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad ;  xyplot.C Example showing how to produce a plot with an orthogonal axis system centered at (0,0) ;  ► histfactory;  example.C;  example.py;  makeExample.C;  makeQuickModel.py;  ModifyInterpolation.C;  ► html;  MakeTutorials.C;  ► http;  custom.CThis program creates and fills one and two dimensional histogram Macro used to demonstrate usage of custom HTML page in custom.htm One can use plain JavaScript to assign different actions with HTML buttons ;  histfitserver.CThis program demonstrates simultaneous update of histogram and fitted function ;  httpaccess.CThis program demonstrates access control to the THttpServer with digest methods ;  httpcontrol.CThis program demonstrates simple application control via THttpServer Two histogram are filled within endless loop ;  httpserver.CThis program creates : ;  httptextlog.CThis macro demonstrates custom access and custom drawing for TMsgList class Main motivation for this example - demonstrate how traffic between server and client can be minimized and how one could build custom UI in the browser ;  httptextlog.js;  ws.C;  ► image;  galaxy_image.C Importing an image and manipulating it ;  hist2image.C Create an image from a 2-D histogram and manipulate it ;  hsumanim.C This script is a slightly modified version of hsum.C ;  image2hist.C Create a 2-D histogram from an image ;  img2pad.C Display image in canvas and pad ;  imgconv.C Open rose512.jpg and save it in the following formats: .png, .gif, .xpm and tiff ;  pad2png.C Create a canvas and save as png ;  rose_image.C Display image in a new canvas and pad ;  trans_graph.C Demonstrates how to access and manipulate ARGB pixel values of an image +.. ;  ► io;  copyFiles.C Example of script showing how to c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:126679,simpl,simple,126679,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['simpl'],['simple']
Usability,"two theorems:. A linear combination of sigmoids can approximate any continuous function.; Trained with output = 1 for the signal and 0 for the background, the approximated function of inputs X is the probability of signal, knowing X. Learning methods; The aim of all learning methods is to minimize the total error on a set of weighted examples. The error is defined as the sum in quadrature, divided by two, of the error on each individual output neuron. In all methods implemented, one needs to compute the first derivative of that error with respect to the weights. Exploiting the well-known properties of the derivative, especially the derivative of compound functions, one can write:. for a neuron: product of the local derivative with the weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative of the output neuron. This computation is called back-propagation of the errors. A loop over all examples is called an epoch. Six learning methods are implemented.; Stochastic minimization:; is the most trivial learning method. This is the Robbins-Monro stochastic approximation applied to multilayer perceptrons. The weights are updated after each example according to the formula: \(w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t)\); with; \(\Delta w_{ij}(t) = - \eta(d e_p / d w_{ij} + \delta) + \epsilon \Delta w_{ij}(t-1)\); The parameters for this method are Eta, EtaDecay, Delta and Epsilon.; Steepest descent with fixed step size (batch learning):; It is the same as the stochastic minimization, but the weights are updated after considering all the examples, with the total derivative dEdw. The parameters for this method are Eta, EtaDecay, Delta and Epsilon.; Steepest descent algorithm:; Weights are set to the minimum along the line defined by the gradient. The only parameter for this method is Tau. Lower tau = higher precision = slower search. A value Tau = 3 seems reasonable.; Conjugate gradients with the Polak-Ribiere updating for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:4254,learn,learning,4254,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['learn'],['learning']
Usability,"ty greater than or equal to newCap. void Clear(); Clear string without changing its capacity. void Clobber(Ssiz_t nc); Clear string and make sure it has a capacity of nc. void Clone(Ssiz_t nc); Make self a distinct copy with capacity of at least tot, where tot cannot; be smaller than the current length. Preserve previous contents. void FillBuffer(char*& buffer) const; Copy string into I/O buffer. void ReadBuffer(char*& buffer); Read string from I/O buffer. TString * ReadString(TBuffer& b, const TClass* clReq); Read TString object from buffer. Simplified version of; TBuffer::ReadObject (does not keep track of multiple; references to same string). We need to have it here; because TBuffer::ReadObject can only handle descendant; of TObject. Int_t Sizeof() const; Returns size string will occupy on I/O buffer. void Streamer(TBuffer& ); Stream a string object. void WriteString(TBuffer& b, const TString* a); Write TString object to buffer. Simplified version of; TBuffer::WriteObject (does not keep track of multiple; references to the same string). We need to have it here; because TBuffer::ReadObject can only handle descendant; of TObject. Ssiz_t GetInitialCapacity(). Ssiz_t GetResizeIncrement(). Ssiz_t GetMaxWaste(). Ssiz_t InitialCapacity(Ssiz_t ic = 15); Set default initial capacity for all TStrings. Default is 15. Ssiz_t ResizeIncrement(Ssiz_t ri = 16); Set default resize increment for all TStrings. Default is 16. Ssiz_t MaxWaste(Ssiz_t mw = 15); Set maximum space that may be wasted in a string before doing a resize.; Default is 15. TSubString operator()(Ssiz_t start, Ssiz_t len) const; Return sub-string of string starting at start with length len. TSubString SubString(const char* pat, Ssiz_t start = 0, TString::ECaseCompare cmp = kExact) const; Returns a substring matching ""pattern"", or the null substring; if there is no such match. It would be nice if this could be yet another; overloaded version of operator(), but this would result in a type; conversion ambiguity with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TString.html:14362,Simpl,Simplified,14362,root/html534/TString.html,https://root.cern,https://root.cern/root/html534/TString.html,3,['Simpl'],['Simplified']
Usability,"ty string is returned; 238 const char * Name() const;; 239 ; 240 /*; 241 set print level; 242 level = 0 quiet (no messages print); 243 = 1 print only the result; 244 = 3 max debug. Print result at each iteration; 245 */; 246 void SetPrintLevel(int level) { fPrintLevel = level; }; 247 ; 248 /// return the print level; 249 int PrintLevel() const { return fPrintLevel; }; 250 ; 251 ; 252 //-- static methods to set configurations; 253 ; 254 /// set tolerance (absolute and relative); 255 /// relative tolerance is only use to verify the convergence; 256 /// do it is a minor parameter; 257 static void SetDefaultTolerance(double abstol, double reltol = 0 );; 258 ; 259 /// set maximum number of iterations; 260 static void SetDefaultMaxIterations(int maxiter);; 261 ; 262 /// print iteration state; 263 void PrintState(std::ostream & os = std::cout);; 264 ; 265 ; 266 protected:; 267 ; 268 // return type given a name; 269 std::pair<bool,int> GetType(const char * name);; 270 // clear list of functions; 271 void ClearFunctions();; 272 ; 273 ; 274 private:; 275 ; 276 int fIter; // current number of iterations; 277 int fStatus; // current status; 278 int fPrintLevel; // print level; 279 ; 280 // int fMaxIter; // max number of iterations; 281 // double fAbsTolerance; // absolute tolerance; 282 // double fRelTolerance; // relative tolerance; 283 int fType; // type of algorithm; 284 bool fUseDerivAlgo; // algorithm using derivative; 285 ; 286 GSLMultiRootBaseSolver * fSolver;; 287 std::vector<ROOT::Math::IMultiGenFunction *> fFunctions; //! transient Vector of the functions; 288 ; 289 ; 290 };; 291 ; 292 // use typedef for most sensible name; 293 typedef GSLMultiRootFinder MultiRootFinder;; 294 ; 295} // namespace Math; 296} // namespace ROOT; 297 ; 298 ; 299#endif /* ROOT_Math_GSLMultiRootFinder */; IFunction.h; f#define f(i)Definition RSha256.hxx:104; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GSLMultiRootFinder_8h_source.html:10059,clear,clear,10059,doc/master/GSLMultiRootFinder_8h_source.html,https://root.cern,https://root.cern/doc/master/GSLMultiRootFinder_8h_source.html,1,['clear'],['clear']
Usability,"tyle settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TMVA::IFitterTarget;  IFitterTarget ();  constructor ;  ; virtual ~IFitterTarget ();  ; virtual void ProgressNotifier (TString, TString);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TMVA::ConvergenceTest;  ConvergenceTest ();  constructor ;  ;  ~ConvergenceTest ();  destructor ;  ; Float_t GetCurrentValue ();  ; Bool_t HasConverged (Bool_t withinConvergenceBand=kFALSE);  gives back true if the last ""steps"" steps have lead to an improvement of the ""fitness"" of the ""individuals"" of at least ""improvement"" ;  ; Float_t Progress ();  returns a float from 0 (just started) to 1 (finished) ;  ; void ResetConvergenceCounter ();  ; void SetConvergenceParameters (Int_t steps, Double_t improvement);  ; void SetCurrentValue (Float_t value);  ; Float_t SpeedControl (UInt_t ofSteps);  this function provides the ability to change the learning rate according to the success of the last generations. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TMVA::MethodANNBase; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TMVA::MethodBase; static TClass * Cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:25076,learn,learning,25076,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['learn'],['learning']
Usability,"type &key) constDefinition TClass.cxx:390; ROOT::TMapTypeToTClass::size_typeIdMap_t::size_type size_typeDefinition TClass.cxx:373; ROOT::TMapTypeToTClass::mapped_typeIdMap_t::mapped_type mapped_typeDefinition TClass.cxx:378; ROOT::TMapTypeToTClass::const_iteratorIdMap_t::const_iterator const_iteratorDefinition TClass.cxx:372; ROOT::TMapTypeToTClass::IdMap_tstd::map< std::string, TClass * > IdMap_tDefinition TClass.cxx:370; ROOT::TMapTypeToTClass::key_typeIdMap_t::key_type key_typeDefinition TClass.cxx:371; ROOT::TMapTypeToTClass::Removevoid Remove(const key_type &key)Definition TClass.cxx:398; ROOT::TMapTypeToTClass::Addvoid Add(const key_type &key, mapped_type &obj)Definition TClass.cxx:385; ROOT::TSchemaRuleDefinition TSchemaRule.h:20; ROOT::TSchemaRule::SetFromRuleBool_t SetFromRule(const char *rule)Set the content fot this object from the rule See TClass::AddRule for details on the syntax.Definition TSchemaRule.cxx:321; ROOT::TSchemaRule::GetTargetStringconst char * GetTargetString() constGet the target data members of this rule as a simple string (i.e. the in memory data member).Definition TSchemaRule.cxx:512; ROOT::TSchemaRule::GetVersionconst char * GetVersion() constGet the version string.Definition TSchemaRule.cxx:393; ROOT::TSchemaRule::GetTargetClassconst char * GetTargetClass() constGet the targte class of this rule (i.e. the in memory class).Definition TSchemaRule.cxx:484; TArray::Classstatic TClass * Class(); TAutoInspectorDefinition TClass.cxx:901; TAutoInspector::fBrowserTBrowser * fBrowserDefinition TClass.cxx:904; TAutoInspector::IsTreatingNonAccessibleTypesBool_t IsTreatingNonAccessibleTypes() overrideDefinition TClass.cxx:914; TAutoInspector::TAutoInspectorTAutoInspector(TBrowser *b)Definition TClass.cxx:906; TAutoInspector::~TAutoInspectorvirtual ~TAutoInspector()Definition TClass.cxx:911; TAutoInspector::fCountInt_t fCountDefinition TClass.cxx:903; TAutoInspector::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:302475,simpl,simple,302475,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['simpl'],['simple']
Usability,"type &key) constDefinition TClass.cxx:390; ROOT::TMapTypeToTClass::size_typeIdMap_t::size_type size_typeDefinition TClass.cxx:373; ROOT::TMapTypeToTClass::mapped_typeIdMap_t::mapped_type mapped_typeDefinition TClass.cxx:378; ROOT::TMapTypeToTClass::const_iteratorIdMap_t::const_iterator const_iteratorDefinition TClass.cxx:372; ROOT::TMapTypeToTClass::IdMap_tstd::map< std::string, TClass * > IdMap_tDefinition TClass.cxx:370; ROOT::TMapTypeToTClass::key_typeIdMap_t::key_type key_typeDefinition TClass.cxx:371; ROOT::TMapTypeToTClass::Removevoid Remove(const key_type &key)Definition TClass.cxx:398; ROOT::TMapTypeToTClass::Addvoid Add(const key_type &key, mapped_type &obj)Definition TClass.cxx:385; ROOT::TSchemaRuleDefinition TSchemaRule.h:20; ROOT::TSchemaRule::SetFromRuleBool_t SetFromRule(const char *rule)Set the content fot this object from the rule See TClass::AddRule for details on the syntax.Definition TSchemaRule.cxx:321; ROOT::TSchemaRule::GetTargetStringconst char * GetTargetString() constGet the target data members of this rule as a simple string (i.e. the in memory data member).Definition TSchemaRule.cxx:512; ROOT::TSchemaRule::GetVersionconst char * GetVersion() constGet the version string.Definition TSchemaRule.cxx:393; ROOT::TSchemaRule::GetTargetClassconst char * GetTargetClass() constGet the targte class of this rule (i.e. the in memory class).Definition TSchemaRule.cxx:484; TArray::Classstatic TClass * Class(); TAutoInspectorDefinition TClass.cxx:968; TAutoInspector::fBrowserTBrowser * fBrowserDefinition TClass.cxx:971; TAutoInspector::IsTreatingNonAccessibleTypesBool_t IsTreatingNonAccessibleTypes() overrideDefinition TClass.cxx:981; TAutoInspector::TAutoInspectorTAutoInspector(TBrowser *b)Definition TClass.cxx:973; TAutoInspector::~TAutoInspectorvirtual ~TAutoInspector()Definition TClass.cxx:978; TAutoInspector::fCountInt_t fCountDefinition TClass.cxx:970; TAutoInspector::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:305113,simpl,simple,305113,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['simpl'],['simple']
Usability,"type, . const RooArgSet * ; auxProto, . bool ; verbose . ); const. overridevirtual . Return specialized generator context for RooEffProds that implements generation in a more efficient way than can be done for generic correlated products. ; Reimplemented from RooAbsPdf.; Definition at line 66 of file RooEffProd.cxx. ◆ IsA(). TClass * RooEffProd::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 41 of file RooEffProd.h. ◆ Streamer(). void RooEffProd::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooEffProd::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 41 of file RooEffProd.h. ◆ translate(). void RooEffProd::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overrideprotectedvirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 75 of file RooEffProd.cxx. Member Data Documentation. ◆ _eff. RooRealProxy RooEffProd::_eff. protected . Efficiency function. ; Definition at line 39 of file RooEffProd.h. ◆ _pdf. RooRealProxy RooEffProd::_pdf. protected . Probability Density function. ; Definition at line 38 of file RooEffProd.h. Libraries for RooEffProd:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooEffProd.html:76514,simpl,simple,76514,doc/master/classRooEffProd.html,https://root.cern,https://root.cern/doc/master/classRooEffProd.html,1,['simpl'],['simple']
Usability,"t GetEta () const;  ; Double_t GetEtaDecay () const;  ; TMultiLayerPerceptron::ELearningMethod GetLearningMethod () const;  ; Int_t GetReset () const;  ; TString GetStructure () const;  ; Double_t GetTau () const;  ; TNeuron::ENeuronType GetType () const;  ; TClass * IsA () const override;  ; Bool_t LoadWeights (Option_t *filename="""");  Loads the weights from a text file conforming to the format defined by DumpWeights. ;  ; void Randomize () const;  Randomize the weights. ;  ; Double_t Result (Int_t event, Int_t index=0) const;  Computes the output for a given event. ;  ; void SetData (TTree *);  Set the data source. ;  ; void SetDelta (Double_t delta);  Sets Delta - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetEpsilon (Double_t eps);  Sets Epsilon - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetEta (Double_t eta);  Sets Eta - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetEtaDecay (Double_t ed);  Sets EtaDecay - Eta *= EtaDecay at each epoch (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetEventWeight (const char *);  Set the event weight. ;  ; void SetLearningMethod (TMultiLayerPerceptron::ELearningMethod method);  Sets the learning method. ;  ; void SetReset (Int_t reset);  Sets number of epochs between two resets of the search direction to the steepest descent. ;  ; void SetTau (Double_t tau);  Sets Tau - used in line search (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetTestDataSet (const char *test);  Sets the Test dataset. ;  ; void SetTestDataSet (TEventList *test);  Sets the Test dataset. ;  ; void SetTrainingDataSet (const char *train);  Sets the Training dataset. ;  ; void SetTrainingDa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:13420,learn,learning,13420,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,4,['learn'],['learning']
Usability,"u-scan is expected to work well with 1st or 2nd; derivative regularisation, because at some point the negative; correlations from migrations are approximately cancelled by the; positive correlations from the regularisation conditions. whichever algorithm is used, the output has to be checked:; (1) The L-curve should have approximate L-shape; and the final choice of tau should not be at the very edge of the; scanned region; (2) The scan result should have a well-defined minimum and the; final choice of tau should sit right in the minimum. Function Members (Methods); public:. virtual~TUnfoldDensity(); voidTObject::AbstractMethod(const char* method) const; voidTUnfoldSys::AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTUnfold::DoUnfold(Double_t tau); Double_tTUnfold::DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfoldDensity.html:5193,Clear,Clear,5193,root/html602/TUnfoldDensity.html,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html,2,['Clear'],['Clear']
Usability,"ual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition at line 2169 of file TTreeCache.cxx. ◆ StopLearningPhase(). void TTreeCache::StopLearningPhase ; (; ). virtual . This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ; It's useful when the user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2186 of file TTreeCache.cxx. ◆ Streamer(). void TTreeCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip. ◆ StreamerNVirtual(). void TTreeCache::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 175 of file TTreeCache.h. ◆ UpdateBranches(). void TTreeCache::UpdateBranches ; (; TTree * ; tree). virtual . Update pointer to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:50682,learn,learning,50682,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['learn'],['learning']
Usability,"ual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2160 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the functionality on/off. ; Definition at line 683 of file TTreeCache.cxx. ◆ StartLearningPhase(). void TTreeCache::StartLearningPhase ; (; ). The name should be enough to explain the method. ; The only additional comments is that the cache is cleaned before the new learning phase. ; Definition at line 2170 of file TTreeCache.cxx. ◆ StopLearningPhase(). void TTreeCache::StopLearningPhase ; (; ). virtual . This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ; It's useful when the user knows exactly what branches they are going to use. For the moment it's just a call to FillBuffer() since that method will create the buffer lists from the specified branches. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2187 of file TTreeCache.cxx. ◆ Streamer(). void TTreeCache::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip. ◆ StreamerNVirtual(). void TTreeCache::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 175 of file TTreeCache.h. ◆ UpdateBranches(). void TTreeCache::UpdateBranches ; (; TTree * ; tree). virtual . Update pointer to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:50752,learn,learning,50752,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['learn'],['learning']
Usability,"ual Int_tTGX11::AddPixmap(ULong_t pixid, UInt_t w, UInt_t h); virtual Int_tTGX11::AddWindow(ULong_t qwid, UInt_t w, UInt_t h); virtual Bool_tTGX11::AllocColor(Colormap_t cmap, ColorStruct_t& color); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGX11::Bell(Int_t percent); virtual voidTObject::Browse(TBrowser* b); virtual voidTGX11::ChangeActivePointerGrab(Window_t, UInt_t, Cursor_t); virtual voidTGX11::ChangeGC(GContext_t gc, GCValues_t* gval); virtual voidTGX11::ChangeProperties(Window_t id, Atom_t property, Atom_t type, Int_t format, UChar_t* data, Int_t len); virtual voidTGX11::ChangeProperty(Window_t id, Atom_t property, Atom_t type, UChar_t* data, Int_t len); virtual voidTGX11::ChangeWindowAttributes(Window_t id, SetWindowAttributes_t* attr); virtual Bool_tTGX11::CheckEvent(Window_t id, EGEventType type, Event_t& ev); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGX11::ClearArea(Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGX11::ClearWindow(); virtual voidTGX11::ClearWindow(Window_t id); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTGX11::CloseDisplay(); virtual voidTGX11::ClosePixmap(); virtual voidTGX11::CloseWindow(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGX11::ConvertPrimarySelection(Window_t id, Atom_t clipboard, Time_t when); virtual voidTGX11::ConvertSelection(Window_t, Atom_t&, Atom_t&, Atom_t&, Time_t&); virtual voidTNamed::Copy(TObject& named) const; virtual voidTGX11::CopyArea(Drawable_t src, Drawable_t dest, GContext_t gc, Int_t src_x, Int_t src_y, UInt_t width, UInt_t height, Int_t dest_x, Int_t dest_y); virtual voidTGX11::CopyGC(GContext_t org, GContext_t dest, Mask_t mask); virtual voidTGX11::CopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); virtual Pixmap_tTGX11::CreateBitmap(Drawable_t id, const char* bitmap, UInt_t width, UInt_t height); virtual Cursor_tTGX11::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGX11TTF.html:1793,Clear,ClearArea,1793,root/html532/TGX11TTF.html,https://root.cern,https://root.cern/root/html532/TGX11TTF.html,1,['Clear'],['ClearArea']
Usability,"ual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:3512,clear,clearShapeDirty,3512,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,1,['clear'],['clearShapeDirty']
Usability,"ual Long64_t GetReadEntry() constDefinition TTree.h:549; TTree::GetListOfBranchesvirtual TObjArray * GetListOfBranches()Definition TTree.h:528; TTree::fZipBytesLong64_t fZipBytesTotal number of bytes in all branches after compression.Definition TTree.h:87; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557; TTree::fTransientBufferTBuffer * fTransientBuffer! Pointer to the current transient buffer.Definition TTree.h:138; TTree::GetValvirtual Double_t * GetVal(Int_t i)Definition TTree.h:574; TTree::SetEntryListvirtual void SetEntryList(TEntryList *list, Option_t *opt="""")Set an EntryList.Definition TTree.cxx:9046; TTree::Notifybool Notify() overrideFunction called when loading a new class library.Definition TTree.cxx:7033; TTree::AddZipBytesvirtual void AddZipBytes(Int_t zip)Definition TTree.h:332; TTree::LoadTreevirtual Long64_t LoadTree(Long64_t entry)Set current entry.Definition TTree.cxx:6473; TTree::ReadFilevirtual Long64_t ReadFile(const char *filename, const char *branchDescriptor="""", char delimiter=' ')Create or simply read branches from filename.Definition TTree.cxx:7564; TTree::GetAliasvirtual const char * GetAlias(const char *aliasName) constReturns the expanded value of the alias. Search in the friends if any.Definition TTree.cxx:5226; TTree::SetIOFeaturesROOT::TIOFeatures SetIOFeatures(const ROOT::TIOFeatures &)Provide the end-user with the ability to enable/disable various experimental IO features for this TTr...Definition TTree.cxx:9130; TTree::CreateBasketvirtual TBasket * CreateBasket(TBranch *)Create a basket for this tree and given branch.Definition TTree.cxx:3731; TTree::fUserInfoTList * fUserInfopointer to a list of user objects associated to this TreeDefinition TTree.h:133; TTree::GetMinimumvirtual Double_t GetMinimum(const char *columname)Return minimum of column with name columname.Definition TTree.cxx:6275; TTree::RemoveFriendvirtual void RemoveFriend(TTree *)Remove a friend from the list of friends.Definition TTree.cxx:7977; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:76484,simpl,simply,76484,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['simpl'],['simply']
Usability,"ual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsAnaConvPdf.html:4238,clear,clearEvalError,4238,root/html602/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsAnaConvPdf.html,2,['clear'],['clearEvalError']
Usability,"ual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedPdf.html:3343,clear,clearEvalError,3343,root/html534/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html,12,['clear'],['clearEvalError']
Usability,"ual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsAnaConvPdf::coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDecay.html:2747,clear,clearEvalError,2747,root/html534/RooDecay.html,https://root.cern,https://root.cern/root/html534/RooDecay.html,6,['clear'],['clearEvalError']
Usability,"ual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBCPEffDecay.html:3049,clear,clearEvalError,3049,root/html534/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html534/RooBCPEffDecay.html,24,['clear'],['clearEvalError']
Usability,"ual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBDecay.html:2947,clear,clearEvalError,2947,root/html534/RooBDecay.html,https://root.cern,https://root.cern/root/html534/RooBDecay.html,6,['clear'],['clearEvalError']
Usability,"ual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooArgusBG.html:2771,clear,clearEvalError,2771,root/html534/RooArgusBG.html,https://root.cern,https://root.cern/root/html534/RooArgusBG.html,260,['clear'],['clearEvalError']
Usability,"ual voidResize(UInt_t n, Bool_t force_delete); virtual voidSetOnFileClass(TClass* cl); virtual voidSetValueClass(TClass* newcl); virtual UInt_tSize() const; virtual UInt_tSizeof() const; virtual voidStreamer(TBuffer& refBuffer); virtual voidStreamer(TBuffer& refBuffer, void* pObject, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize() const; virtual TGenCollectionProxy*InitializeEx(). private:. TGenCollectionProxy(). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGenCollectionProxy.html:3847,clear,clear,3847,root/html528/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html528/TGenCollectionProxy.html,2,['clear'],['clear']
Usability,"ual voidTEveElement::Annihilate(); virtual voidTEveElement::AnnihilateElements(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; virtual voidTEveCaloData::CellSelectionChanged(); virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren(); voidTEveElement::CSCApplyMainTransparencyToMatchingChildren(); voidTEveElement::CSCImplySelectAllChildren(); voidTEveElement::CSCTakeAnyParentAs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveCaloDataHist.html:2079,Clear,ClearStamps,2079,root/html532/TEveCaloDataHist.html,https://root.cern,https://root.cern/root/html532/TEveCaloDataHist.html,8,['Clear'],['ClearStamps']
Usability,"ual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBuild(TSessionViewer* gui); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TNewQueryDlg.html:1741,Clear,Clear,1741,root/html532/TNewQueryDlg.html,https://root.cern,https://root.cern/root/html532/TNewQueryDlg.html,4,['Clear'],['Clear']
Usability,"ual voidTList::AddLast(TObject* obj); virtual voidTList::AddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; virtual TObject*TList::Before(const TObject* obj) const; TIterTCollection::begin() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTCollection::Browse(TBrowser* b); virtual Bool_tCanCompress(TQCommand* c) const; virtual Bool_tCanMerge(TQCommand* c) const; virtual Bool_tCanRedo() const; virtual Bool_tCanUndo() const; Int_tTCollection::Capacity() const; virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidCompress(TQCommand* c); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual voidTQObject::Destroyed()SIGNAL ; Bool_tTQObject::Disconnect(const char* signal = 0, void* receiver = 0, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:4797,Clear,Clear,4797,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,2,['Clear'],['Clear']
Usability,"ual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCLsCleanupThreshold(Double_t th); virtual voidSetConfidenceLevel(Double_t cl); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetInterpolationOption(RooStats::HypoTestInverterResult::InterpolOption_t opt); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetTestSize(Double_t size); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const char* name = 0); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const RooStats::SimpleInterval&); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const RooStats::SimpleInterval& other, const char* name); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const char* name, const RooRealVar& var, Double_t lower, Double_t upper, Double_t cl); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Double_tUpperLimit(); Double_tUpperLimitEstimatedError(); voidUseCLs(bool on = true); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestInverterResult.html:7018,Simpl,SimpleInterval,7018,root/html534/RooStats__HypoTestInverterResult.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestInverterResult.html,1,['Simpl'],['SimpleInterval']
Usability,"ual voidToggled(Bool_t on)SIGNAL ; virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidEmitSignals(Bool_t wasUp); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidSetToggleButton(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGButton(const TGButton&); TGButton&operator=(const TGButton&). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGButton.html:17387,Clear,ClearFlags,17387,root/html532/TGButton.html,https://root.cern,https://root.cern/root/html532/TGButton.html,2,['Clear'],['ClearFlags']
Usability,"ual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:64077,clear,clearEvalErrorLog,64077,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"ual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::unique_ptr< RooPolyFunc > taylorExpand (const char *name, const char *title, RooAbsReal &func, const RooArgList &observables, int order=1, std::vector< double > const &observableValues={}, double eps1=1e-6, double eps2=1e-3);  Taylor expanding given function in terms of observables around observableValues. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPolyFunc.html:46229,clear,clearEvalErrorLog,46229,doc/master/classRooPolyFunc.html,https://root.cern,https://root.cern/doc/master/classRooPolyFunc.html,1,['clear'],['clearEvalErrorLog']
Usability,"ualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70; DrawLineOption_t Option_t TPoint TPoint const char DrawLineDefinition TGWin32VirtualXProxy.cxx:70; srcOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t srcDefinition TGWin32VirtualXProxy.cxx:164; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; TObject.h; TAttBBox2DAbstract base class for elements drawn in the editor.Definition TAttBBox2D.h:19; TAttLineLine Attributes class.Definition TAttLine.h:18; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::lsvoid ls(Option_t *option="""") const overrideList this line with its attributes.Definition TLine.cxx:380; TLine::SetY2virtual void SetY2(Double_t y2)Definition TLine.h:68; TLine::fY1Double_t fY1Y of 1st point.Definition TLine.h:26; TLine::fX1Double_t fX1X of 1st point.Definition TLine.h:25; TLine::SetX2virtual void SetX2(Double_t x2)Definition TLine.h:66; TLine::kLineNDC@ kLineNDCUse NDC coordinates.Definition TLine.h:33; TLine::kHorizontal@ kHorizontalLine is horizontal.Definition TLine.h:35; TLine::kVertical@ kVerticalLine is vertical.Definition TLine.h:34; TLine::IsVerticalBool_t IsVertical()Check whether this line is to be drawn vertically.Definition TLine.cxx:459; TLine::SetBBoxY1void SetBBoxY1(const Int_t y) overrideSet top of BoundingBox to a value (resize in y direction on top)Definition TLine.cxx:667; TLine::SetVerticalvoid SetVertical(Bool_t set=kTRUE)Force the line to be drawn vertically.Definition TLine.cxx:499; TL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLine_8h_source.html:4625,simpl,simple,4625,doc/master/TLine_8h_source.html,https://root.cern,https://root.cern/doc/master/TLine_8h_source.html,1,['simpl'],['simple']
Usability,"ual~TEveCompositeFrameInTab(); voidTObject::AbstractMethod(const char* method) const; virtual voidTEveCompositeFrame::AcquireEveWindow(TEveWindow* ew); voidTEveCompositeFrame::ActionPressed(); virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidDestroy(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* si",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveCompositeFrameInTab.html:1523,Clear,Clear,1523,root/html532/TEveCompositeFrameInTab.html,https://root.cern,https://root.cern/root/html532/TEveCompositeFrameInTab.html,4,['Clear'],['Clear']
Usability,"uble> parValues = fClingParameters;; 3720 auto paramMap = fParams;; 3721 fNpar = fParams.size();; 3722 ; 3723 fLazyInitialization = true; // when reading we initialize the formula later to avoid problem of recursive Jitting; 3724 ; 3725 if (!TestBit(TFormula::kLambda) ) {; 3726 ; 3727 // save dimension read from the file (stored for V >=12); 3728 // and we check after initializing if it is the same; 3729 int ndim = fNdim;; 3730 fNdim = 0;; 3731 ; 3732 //std::cout << ""Streamer::Reading preprocess the formula "" << fFormula << "" ndim = "" << fNdim << "" npar = "" << fNpar << std::endl;; 3733 // for ( auto &p : fParams); 3734 // std::cout << ""parameter "" << p.first << "" index "" << p.second << std::endl;; 3735 ; 3736 fClingParameters.clear(); // need to be reset before re-initializing it; 3737 ; 3738 FillDefaults();; 3739 ; 3740 ; 3741 PreProcessFormula(fFormula);; 3742 ; 3743 //std::cout << ""Streamer::after pre-process the formula "" << fFormula << "" ndim = "" << fNdim << "" npar = "" << fNpar << std::endl;; 3744 ; 3745 PrepareFormula(fFormula);; 3746 ; 3747 //std::cout << ""Streamer::after prepared "" << fClingInput << "" ndim = "" << fNdim << "" npar = "" << fNpar << std::endl;; 3748 ; 3749 ; 3750 // restore parameter values; 3751 if (fNpar != (int) parValues.size() ) {; 3752 Error(""Streamer"",""number of parameters computed (%d) is not same as the stored parameters (%d)"",fNpar,int(parValues.size()) );; 3753 Print(""v"");; 3754 }; 3755 if (v > 11 && fNdim != ndim) {; 3756 Error(""Streamer"",""number of dimension computed (%d) is not same as the stored value (%d)"",fNdim, ndim );; 3757 Print(""v"");; 3758 }; 3759 }; 3760 else {; 3761 // we also delay the initialization of lamda expressions; 3762 if (!fLazyInitialization) {; 3763 bool ret = InitLambdaExpression(fFormula);; 3764 if (ret) {; 3765 fClingInitialized = true;; 3766 }; 3767 }else {; 3768 fReadyToExecute = true;; 3769 }; 3770 }; 3771 assert(fNpar == (int) parValues.size() );; 3772 std::copy( parValues.begin(), parValues.end(), fClingP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:142012,clear,clear,142012,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['clear'],['clear']
Usability,"uble_t bestx, ystar, y1, y2, ystst, pb, wg;; 7444 Double_t absmin, rho, sig2, rho1, rho2;; 7445 Int_t npfn, i, j, k, jhold, ncycl, nparx;; 7446 Int_t nparp1, kg, jh, nf, jl, ns;; 7447 ; 7448 if (fNpar <= 0) return;; 7449 if (fAmin == fUndefi) mnamin();; 7450 fCfrom = ""SIMPLEX "";; 7451 fNfcnfr = fNfcn;; 7452 fCstatu = ""UNCHANGED "";; 7453 npfn = fNfcn;; 7454 nparp1 = fNpar + 1;; 7455 nparx = fNpar;; 7456 rho1 = alpha + 1;; 7457 rho2 = rho1 + alpha*gamma;; 7458 wg = 1 / Double_t(fNpar);; 7459 if (fISW[4] >= 0) {; 7460 Printf("" START SIMPLEX MINIMIZATION. CONVERGENCE WHEN EDM .LT. %g"",fEpsi);; 7461 }; 7462 for (i = 1; i <= fNpar; ++i) {; 7463 fDirin[i-1] = fWerr[i-1];; 7464 mndxdi(fX[i-1], i-1, dxdi);; 7465 if (dxdi != 0) fDirin[i-1] = fWerr[i-1] / dxdi;; 7466 dmin_ = fEpsma2*TMath::Abs(fX[i-1]);; 7467 if (fDirin[i-1] < dmin_) fDirin[i-1] = dmin_;; 7468 }; 7469// choose the initial simplex using single-parameter searches; 7470L1:; 7471 ynpp1 = fAmin;; 7472 jl = nparp1;; 7473 fSIMPy[nparp1-1] = fAmin;; 7474 absmin = fAmin;; 7475 for (i = 1; i <= fNpar; ++i) {; 7476 aming = fAmin;; 7477 fPbar[i-1] = fX[i-1];; 7478 bestx = fX[i-1];; 7479 kg = 0;; 7480 ns = 0;; 7481 nf = 0;; 7482L4:; 7483 fX[i-1] = bestx + fDirin[i-1];; 7484 mninex(fX);; 7485 Eval(nparx, fGin, f, fU, 4); ++fNfcn;; 7486 if (f <= aming) goto L6;; 7487// failure; 7488 if (kg == 1) goto L8;; 7489 kg = -1;; 7490 ++nf;; 7491 fDirin[i-1] *= -.4;; 7492 if (nf < 3) goto L4;; 7493 ns = 6;; 7494// success; 7495L6:; 7496 bestx = fX[i-1];; 7497 fDirin[i-1] *= 3;; 7498 aming = f;; 7499 fCstatu = ""PROGRESS "";; 7500 kg = 1;; 7501 ++ns;; 7502 if (ns < 6) goto L4;; 7503// local minimum found in ith direction; 7504L8:; 7505 fSIMPy[i-1] = aming;; 7506 if (aming < absmin) jl = i;; 7507 if (aming < absmin) absmin = aming;; 7508 fX[i-1] = bestx;; 7509 for (k = 1; k <= fNpar; ++k) { fP[k + i*fMaxpar - fMaxpar-1] = fX[k-1]; }; 7510 }; 7511 jh = nparp1;; 7512 fAmin = fSIMPy[jl-1];; 7513 mnrazz(ynpp1, fPbar, fSIMPy, jh, jl);; 7514 for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:239085,simpl,simplex,239085,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['simpl'],['simplex']
Usability,"uble_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TTree::Fillvirtual Int_t Fill()Fill all branches.Definition TTree.cxx:4603; TTree::BranchTBranch * Branch(const char *name, T *obj, Int_t bufsize=32000, Int_t splitlevel=99)Add a new branch, and infer the data type from the type of obj being passed.Definition TTree.h:353; It is not always possible to add branches to existing datasets stored in TFiles: for example, these files might not be writeable, just readable. In addition, modifying in place a TTree causes a new TTree instance to be written and the previous one to be deleted. For this reasons, ROOT offers the concept of friends for TTree and TChain: if is good practice to rely on friend trees rather than adding a branch manually. An Example. // A simple example with histograms and a tree; //; // This program creates :; // - a one dimensional histogram; // - a two dimensional histogram; // - a profile histogram; // - a tree; //; // These objects are filled with some random numbers and saved on a file.; ; #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h""; ; //__________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");; ; // Create some histograms and a profile histogram; TH1F hpx(""hpx"",""This is the px distribution"",100,-4,4);; TH2F hpxpy(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; TProfile hprof(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; ; // Define some simple structures; typedef struct {Float_t x,y,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:11549,simpl,simple,11549,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['simpl'],['simple']
Usability,"uble_t x, Double_t y, Double_t xcl1, Double_t ycl1, Double_t xcl2, Double_t ycl2); Compute the endpoint codes for TPad::Clip. Int_t ClipPolygon(Int_t n, Double_t* x, Double_t* y, Int_t nn, Double_t* xc, Double_t* yc, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); Clip polygon using the Sutherland-Hodgman algorithm. Input parameters:. n: Number of points in the polygon to be clipped; x[n], y[n] : Polygon do be clipped vertices; xclipl, yclipb, xclipr, yclipt : Clipping boundary. Output parameters:. nn: number of points in xc and yc; xc, yc: clipped polygon vertices. The Int_t returned by this function is; the number of points in the clipped polygon. These vectors must; be allocated by the calling function. A size of 2*n for each is; enough. Sutherland and Hodgman's polygon-clipping algorithm uses a divide-and-conquer; strategy: It solves a series of simple and identical problems that, when; combined, solve the overall problem. The simple problem is to clip a polygon; against a single infinite clip edge. Four clip edges, each defining one boundary; of the clip rectangle, successively clip a polygon against a clip rectangle. Steps of Sutherland-Hodgman's polygon-clipping algorithm:. * Polygons can be clipped against each edge of the window one at a time.; Windows/edge intersections, if any, are easy to find since the X or Y coordinates; are already known.; * Vertices which are kept after clipping against one window edge are saved for; clipping against the remaining edges.; * Note that the number of vertices usually changes and will often increases. The clip boundary determines a visible and invisible region. The edges from; vertex i to vertex i+1 can be one of four types:. * Case 1 : Wholly inside visible region - save endpoint; * Case 2 : Exit visible region - save the intersection; * Case 3 : Wholly outside visible region - save nothing; * Case 4 : Enter visible region - save intersection and endpoint. void Close(Option_t* option = """"); Delete a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPad.html:34286,simpl,simple,34286,root/html528/TPad.html,https://root.cern,https://root.cern/root/html528/TPad.html,10,['simpl'],['simple']
Usability,"uble_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y). void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. void DrawText(Double_t x, Double_t y, const wchar_t* text, TVirtualPadPainter::ETextMode mode); That's a special version working with wchar_t and required by TMathText (who uses utf-8(?)). void DrawTextNDC(Double_t u, Double_t v, const char* text, TVirtualPadPainter::ETextMode mode); Paint text in normalized coordinates. void SaveImage(TVirtualPad* pad, const char* fileName, Int_t type) const; Save the image displayed in the canvas pointed by ""pad"" into a; binary file.; assert(pad != 0 && ""SaveImage, parameter 'pad' is null"");; assert(fileName != 0 && ""SaveImage, parameter 'fileName' is null"");. void DrawTextNDC(Double_t u, Double_t v, const wchar_t* text, TVirtualPadPainter::ETextMode mode); Paint text in normalized coordinates. TPadPainter(); Final overriders for TVirtualPadPainter pure virtual functions.; 1. Part, which simply delegates to TVirtualX.; Line attributes. » Author: Olivier Couet, Timur Pocheptsov 06/05/2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/gpad:$Id$ » Last generated: 2015-03-14 16:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPadPainter.html:7443,simpl,simply,7443,root/html534/TPadPainter.html,https://root.cern,https://root.cern/root/html534/TPadPainter.html,2,['simpl'],['simply']
Usability,"uble_t& seed); Randomize matrix element values. void TMatrixTBase<Element> Streamer(TBuffer& ); Stream an object of class TMatrixTBase<Element>. Element & TMatrixTBase<Element> NaNValue(). template<class Element> Element TMatrixTBase<Element> SetTol(double tol). Element * GetElements(). Int_t GetRowLwb() const; { return fRowLwb; }. Int_t GetRowUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetColLwb() const; { return fColLwb; }. Int_t GetColUpb() const; { return fNcols+fColLwb-1; }. Int_t GetNcols() const; { return fNcols; }. Int_t GetNoElements() const; { return fNelems; }. Element GetTol() const; { return fTol; }. const Element * GetMatrixArray() const. Element * GetMatrixArray(). const Int_t * GetRowIndexArray() const. Int_t * GetRowIndexArray(). const Int_t * GetColIndexArray() const. Int_t * GetColIndexArray(). TMatrixTBase<Element> & SetRowIndexArray(Int_t* data). TMatrixTBase<Element> & SetColIndexArray(Int_t* data). void Clear(Option_t* option = """"). void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. TMatrixTBase<Element> & GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const. TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1). TMatrixTBase<Element> & ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1). Double_t Determinant() const; { AbstractMethod(""Determinant()""); return 0.; }. void Determinant(Double_t& d1, Double_t& d2) const; { AbstractMethod(""Determinant()""); d1 = 0.; d2 = 0.; }. Element NormInf() const; { return RowNorm(); }. Element Norm1() const; { return ColNorm(); }. Element operator()(Int_t rown, Int_t coln) const. Element & operator()(Int_t rown, Int_t coln). » Last changed: root/matrix:$Id$ » Last generated: 2015-06-02 16:20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMatrixTBase_double_.html:21982,Clear,Clear,21982,root/html604/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html604/TMatrixTBase_double_.html,1,['Clear'],['Clear']
Usability,"uble_t* data) const; static voidTUnfold::DeleteMatrix(TMatrixD** m); static voidTUnfold::DeleteMatrix(TMatrixDSparse** m); voidTUnfoldSys::DoBackgroundSubtraction(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tTUnfold::DoUnfold(); voidTUnfold::ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; const TMatrixDSparse*TUnfold::GetAx() const; Int_tTUnfold::GetBinFromRow(int ix) const; Double_tGetDensityFactor(TUnfoldDensity::EDensityMode densityMode, Int_t iBin) const; const TMatrixDSparse*TUnfold::GetDXDAM(int i) const; const TMatrixDSparse*TUnfold::GetDXDAZ(int i) const; const TMatrixDSparse*TUnfold::GetDXDtauSquared() const; const TMatrixDSparse*TUnfold::GetDXDY() const; const TMatrixDSparse*TUnfold::GetE() const; const TMatrixDSparse*TUnfold::GetEinv() const; voidTUnfoldSys::GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); Int_tTUnfold::GetNx() const; Int_tTUnfold::GetNy() const; virtual TStringGetOutputBinName(Int_t iBinX) const; Double_tTUnfold::GetRhoIFromMatrix(TH1* rhoi, const TMatrixDSparse* eOrig, const Int_t* binMap, TH2* invEmat) const; Int_tTUnfold::GetRowFromBin(int ix) const; TMatrixDSparse*TUnfoldSys::GetSummedErrorMatrixXX(); TMatrixDSparse*TUnfoldSys::GetSummedErrorMatrixYY(); const TMatrixDSparse*TUnfold::GetVxx() const; const TMatrixDSparse*TUnfold::GetVxxInv() const; const TMatrixDSparse*TUnfold::GetVyyInv() const; const TMatrixD*TUnfold::GetX() const; TMatrixDSparse*TUnfold::InvertMSparseSymmPos(const TMatrixDSparse* A, Int_t* rank) const; voidTObject::MakeZombie(); TMatrixDSparse*TUnfold::MultiplyMSparseM(const TMatrixDSparse* a, const TMatrixD* b) const; TMatrixDSparse*TUnfold::MultiplyMSparseMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const; TMatrixDSparse*TUnfold::MultiplyMSparseMSparseTranspVector(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldDensity.html:17571,clear,clearEmat,17571,root/html534/TUnfoldDensity.html,https://root.cern,https://root.cern/root/html534/TUnfoldDensity.html,6,['clear'],['clearEmat']
Usability,"uble_t* err = 0, Double_t* errUpper = 0); return boosted MVA response. Double_t GetBoostROCIntegral(Bool_t , TMVA::Types::ETreeType , Bool_t CalcOverlapIntergral = kFALSE); Calculate the ROC integral of a single classifier or even the; whole boosted classifier. The tree type (training or testing; sample) is specified by 'eTT'. If tree type kTraining is set, the original training sample is; used to compute the ROC integral (original weights). - singleMethod - if kTRUE, return ROC integral of single (last; trained) classifier; if kFALSE, return ROC; integral of full classifier. - eTT - tree type (Types::kTraining / Types::kTesting). - CalcOverlapIntergral - if kTRUE, the overlap integral of the; signal/background MVA distributions; is calculated and stored in; 'fOverlap_integral'. void CalcMVAValues(); Calculate MVA values of current method fMethods.back() on; training sample. void SetBoostedMethodName(TString methodName); { fBoostedMethodName = methodName; }. Int_t GetBoostNum(); { return fBoostNum; }. TH1* GetMonitoringHist(Int_t histInd); gives the monitoring historgram from the vector according to index of the; histrogram added in the MonitorBoost function. { return (*fMonitorHist)[fDefaultHistNum+histInd]; }. void AddMonitoringHist(TH1* hist); { return fMonitorHist->push_back(hist); }. Types::EBoostStage GetBoostStage(); { return fBoostStage; }. void ClearAll(); clean up. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; print fit results. MethodBoost* SetStage(TMVA::Types::EBoostStage stage); { fBoostStage = stage; return this; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen, Jan Therhaag, Eckhard von Toerne » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id: MethodBoost.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodBoost.html:22118,Clear,ClearAll,22118,root/html532/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodBoost.html,1,['Clear'],['ClearAll']
Usability,"uble_tTGeoTrapEditor::fThetaiInitial theta; Double_tTGeoTrapEditor::fTl1iInitial half length in x at low z and y high edge; Double_tfTwistiInitial twist angle; TGTextButton*TGeoTrapEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtraEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for gtra editor. ~TGeoGtraEditor(); Destructor. void SetModel(TObject* obj); Connect to a given twisted trapezoid. void DoApply(); Slot for applying current settings. void DoUndo(); Slot for undoing last operation. void DoTwist(); Change the twist angle. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrapEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoGtraEditor.html:22415,undo,undoing,22415,root/html528/TGeoGtraEditor.html,https://root.cern,https://root.cern/root/html528/TGeoGtraEditor.html,1,['undo'],['undoing']
Usability,"uble_tTGeoTrapEditor::fThetaiInitial theta; Double_tTGeoTrapEditor::fTl1iInitial half length in x at low z and y high edge; Double_tfTwistiInitial twist angle; TGTextButton*TGeoTrapEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtraEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for gtra editor. ~TGeoGtraEditor(); Destructor. void SetModel(TObject* obj); Connect to a given twisted trapezoid. void DoApply(); Slot for applying current settings. void DoUndo(); Slot for undoing last operation. void DoTwist(); Change the twist angle. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrapEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoGtraEditor.html:22515,undo,undoing,22515,root/html530/TGeoGtraEditor.html,https://root.cern,https://root.cern/root/html530/TGeoGtraEditor.html,1,['undo'],['undoing']
Usability,"uble_tTGeoTrapEditor::fThetaiInitial theta; Double_tTGeoTrapEditor::fTl1iInitial half length in x at low z and y high edge; Double_tfTwistiInitial twist angle; TGTextButton*TGeoTrapEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtraEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for gtra editor. ~TGeoGtraEditor(); Destructor. void SetModel(TObject* obj); Connect to a given twisted trapezoid. void DoApply(); Slot for applying current settings. void DoUndo(); Slot for undoing last operation. void DoTwist(); Change the twist angle. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoTrapEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoGtraEditor.html:22515,undo,undoing,22515,root/html532/TGeoGtraEditor.html,https://root.cern,https://root.cern/root/html532/TGeoGtraEditor.html,2,['undo'],['undoing']
Usability,"uble_tfYiInitial Y; Double_tfZiInitial Z; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParaEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoParaEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoX(); Slot for X. void DoY(); Slot for Y. void DoZ(); Slot for Z. void DoAlpha(); Slot for alpha. void DoTheta(); Slot for theta. void DoPhi(); Slot for phi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoParaEditor.html:21453,undo,undoing,21453,root/html534/TGeoParaEditor.html,https://root.cern,https://root.cern/root/html534/TGeoParaEditor.html,2,['undo'],['undoing']
Usability,"uble_t ; c1 = 1 . ). overridevirtual . Performs the operation: this = this*c1*f1. ; The function return kFALSE if the Multiply operation failed ; Reimplemented from TH1.; Definition at line 1202 of file TProfile.cxx. ◆ operator=(). TProfile & TProfile::operator= ; (; const TProfile & ; profile). Definition at line 249 of file TProfile.cxx. ◆ ProjectionX(). TH1D * TProfile::ProjectionX ; (; const char * ; name = ""_px"", . Option_t * ; option = ""e"" . ); const. Project this profile into a 1-D histogram along X. ; The projection is always of the type TH1D. if option ""E"" is specified the errors of the projected histogram are computed and set to be equal to the errors of the profile. Option ""E"" is defined as the default one in the header file.; if option """" is specified the histogram errors are simply the sqrt of its content; if option ""B"" is specified, the content of bin of the returned histogram will be equal to the GetBinEntries(bin) of the profile, otherwise (default) it will be equal to GetBinContent(bin); if option ""C=E"" the bin contents of the projection are set to the bin errors of the profile; if option ""W"" is specified the bin content of the projected histogram is set to the product of the bin content of the profile and the entries. With this option the returned histogram will be equivalent to the one obtained by filling directly a TH1D using the 2-nd value as a weight. This makes sense only for profile filled with weights =1. If not, the error of the projected histogram obtained with this option will not be correct. . Definition at line 1283 of file TProfile.cxx. ◆ PutStats(). void TProfile::PutStats ; (; Double_t * ; stats). overridevirtual . Replace current statistics with the values in array stats. ; Reimplemented from TH1.; Definition at line 1358 of file TProfile.cxx. ◆ Rebin(). TH1 * TProfile::Rebin ; (; Int_t ; ngroup = 2, . const char * ; newname = """", . const Double_t * ; xbins = nullptr . ). overridevirtual . Rebin this profile grouping ngroup bins toge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile.html:80228,simpl,simply,80228,doc/master/classTProfile.html,https://root.cern,https://root.cern/doc/master/classTProfile.html,1,['simpl'],['simply']
Usability,"ublic TColor. TColorGradient. TColorGradient extends basic TColor.; Actually, this is not a simple color, but linear gradient + shadow; for filled area. By inheriting from TColor, gradients can be placed; inside gROOT's list of colors and use it in all TAttXXX descendants; without modifying any existing code.; Shadow, of course, is not a property of any color, and gradient is; not, but this is the best way to add new attributes to filled area; without re-writing all the graphics code. Function Members (Methods); public:. TColorGradient(const TColorGradient&); ~TColorGradient(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); const char*TColor::AsHexString() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTColor::Copy(TObject& color) const; static voidTColor::CreateColorsCircle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorsGray(); static voidTColor::CreateColorsRectangle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorWheel(); static Int_tTColor::CreateGradientColorTable(UInt_t Number, Double_t* Stops, Double_t* Red, Double_t* Green, Double_t* Blue, UInt_t NColors, Float_t alpha = 1.); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TColorGradient.html:1155,Clear,Clear,1155,root/html534/TColorGradient.html,https://root.cern,https://root.cern/root/html534/TColorGradient.html,1,['Clear'],['Clear']
Usability,"ublic:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMapfDescriptionMapstores the key, value pairs of the JDL; TMapfMapstores the key, value pairs of the JDL. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGridJDL(); Cleanup. void Clear(const Option_t* = 0); Clears the JDL information. void SetValue(const char* key, const char* value); Sets a value. If the entry already exists the old one is replaced. const char * GetValue(const char* key); Returns the value corresponding to the provided key. Return 0 in case; key is not found. void SetDescription(const char* key, const char* description); Sets a value. If the entry already exists the old one is replaced. const char * GetDescription(const char* key); Returns the value corresponding to the provided key. Return 0 in case; key is not found. TString AddQuotes(const char* value); Adds quotes to the provided string.; E.g. Value --> ""Value"". void AddToSet(const char* key, const char* value); Adds a value to a key value which hosts a set of values.; E.g. InputSandbox: {""file1"",""file2""}. void AddToSetDescription(const char* key, const char* description); Adds a value to a key value which hosts a set of values.; E.g. InputSandbox: {""file1"",""file2""}. TString Generate(); Generates the JDL snippet. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGridJDL.html:8089,Clear,Clear,8089,root/html602/TGridJDL.html,https://root.cern,https://root.cern/root/html602/TGridJDL.html,4,['Clear'],"['Clear', 'Clears']"
Usability,"ubset that is currently available is:; 662- AsNumpy; 663- Count; 664- Define; 665- DefinePerSample; 666- Filter; 667- Graph; 668- Histo[1,2,3]D; 669- HistoND; 670- Max; 671- Mean; 672- Min; 673- Profile[1,2,3]D; 674- Redefine; 675- Snapshot; 676- Stats; 677- StdDev; 678- Sum; 679- Systematic variations: Vary and [VariationsFor](\ref ROOT::RDF::Experimental::VariationsFor).; 680- Parallel submission of distributed graphs: [RunGraphs](\ref ROOT::RDF::RunGraphs).; 681- Information about the dataframe: GetColumnNames.; 682 ; 683with support for more operations coming in the future. Data sources other than TTree and TChain (e.g. CSV, RNTuple) are; 684currently not supported.; 685 ; 686\note The distributed RDataFrame module requires at least Python version 3.8.; 687 ; 688### Connecting to a Spark cluster; 689 ; 690In order to distribute the RDataFrame workload, you can connect to a Spark cluster you have access to through the; 691official [Spark API](https://spark.apache.org/docs/latest/rdd-programming-guide.html#initializing-spark), then hook the; 692connection instance to the distributed `RDataFrame` object like so:; 693 ; 694~~~{.py}; 695import pyspark; 696import ROOT; 697 ; 698# Create a SparkContext object with the right configuration for your Spark cluster; 699conf = SparkConf().setAppName(appName).setMaster(master); 700sc = SparkContext(conf=conf); 701 ; 702# Point RDataFrame calls to the Spark specific RDataFrame; 703RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; 704 ; 705# The Spark RDataFrame constructor accepts an optional ""sparkcontext"" parameter; 706# and it will distribute the application to the connected cluster; 707df = RDataFrame(""mytree"", ""myfile.root"", sparkcontext = sc); 708~~~; 709 ; 710If an instance of [SparkContext](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.SparkContext.html); 711is not provided, the default behaviour is to create one in the background for you.; 712 ; 713### Connecting to a Dask cluste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:40422,guid,guide,40422,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['guid'],['guide']
Usability,"ubset that is currently available is:; 702- AsNumpy; 703- Count; 704- Define; 705- DefinePerSample; 706- Filter; 707- Graph; 708- Histo[1,2,3]D; 709- HistoND; 710- Max; 711- Mean; 712- Min; 713- Profile[1,2,3]D; 714- Redefine; 715- Snapshot; 716- Stats; 717- StdDev; 718- Sum; 719- Systematic variations: Vary and [VariationsFor](\ref ROOT::RDF::Experimental::VariationsFor).; 720- Parallel submission of distributed graphs: [RunGraphs](\ref ROOT::RDF::RunGraphs).; 721- Information about the dataframe: GetColumnNames.; 722 ; 723with support for more operations coming in the future. Data sources other than TTree and TChain (e.g. CSV, RNTuple) are; 724currently not supported.; 725 ; 726\note The distributed RDataFrame module requires at least Python version 3.8.; 727 ; 728### Connecting to a Spark cluster; 729 ; 730In order to distribute the RDataFrame workload, you can connect to a Spark cluster you have access to through the; 731official [Spark API](https://spark.apache.org/docs/latest/rdd-programming-guide.html#initializing-spark), then hook the; 732connection instance to the distributed `RDataFrame` object like so:; 733 ; 734~~~{.py}; 735import pyspark; 736import ROOT; 737 ; 738# Create a SparkContext object with the right configuration for your Spark cluster; 739conf = SparkConf().setAppName(appName).setMaster(master); 740sc = SparkContext(conf=conf); 741 ; 742# Point RDataFrame calls to the Spark specific RDataFrame; 743RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; 744 ; 745# The Spark RDataFrame constructor accepts an optional ""sparkcontext"" parameter; 746# and it will distribute the application to the connected cluster; 747df = RDataFrame(""mytree"", ""myfile.root"", sparkcontext = sc); 748~~~; 749 ; 750If an instance of [SparkContext](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.SparkContext.html); 751is not provided, the default behaviour is to create one in the background for you.; 752 ; 753### Connecting to a Dask cluste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:42062,guid,guide,42062,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['guid'],['guide']
Usability,"uctures and perform some checks. Note the messages posted after the statement is executed. We will describe the corresponding operations later.; root[] gGeoManager->CloseGeometry();; Now we are really done with geometry building stage, but we would like to see our simple world:; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; 18.1.2 Example 2: A Geometrical Hierarchy Look and Feel; Before going further, let us get a look and feel of interacting with the modeller. For this, we will use one of the examples illustrating the geometry package. To get an idea on the geometry structure created in this example, just look at the link: http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html. You will notice that this is a bit more complex that just creating the “world” since several other volumes are created and put together in a hierarchy. The purpose here is just to learn how to interact with a geometry that is already built, but just few hints on the building steps in this example might be useful. The geometry here represents the word ROOT that is replicated in some symmetric manner. You might for instance ask some questions after having a first look:; Q: “OK, I understand the first lines that load the libGeom library and create a geometry manager object. I also recognize from the previous example the following lines creating some materials and media, but what about the geometrical transformations below?”; A: As explained before, the model that we are trying to create is a hierarchy of volumes based on containment. This is accomplished by positioning some volumes inside others. Any volume is an un-positioned object in the sense that it defines only a local frame (matching the one of its shape). In order to fully define the mother-daughter relationship between two volumes one has to specify how the daughter will be positioned inside. This is accomplished by defining a local geometrical transformatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:879286,learn,learn,879286,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['learn'],['learn']
Usability,udaMatrixTCudaMatrix Class ;  CTDataLoaderTDataLoader ;  CTDeviceTDevice ;  CTGradientDescent;  CTLayerGeneric layer class ;  CTNetGeneric neural network class ;  CTReferenceThe reference architecture class ;  CTSharedLayerLayer class width shared weight and bias layers ;  ►NkNN;  CEvent;  CModulekNN;  CNode;  CAbsoluteDeviationLossFunctionAbsolute Deviation Loss Function ;  CAbsoluteDeviationLossFunctionBDTAbsolute Deviation BDT Loss Function ;  CAbsValue;  CBDTEventWrapper;  CBinarySearchTreeA simple Binary search tree including a volume search method ;  CBinarySearchTreeNodeNode for the BinarySearch or Decision Trees ;  CBinaryTreeBase class for BinarySearch and Decision Trees ;  CCCPrunerA helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) ;  ►CCCTreeWrapper;  CCCTreeNode;  CClassifierFactoryThis is the MVA factory ;  CClassInfoClass that contains all the information of a class ;  Ccompose_binary_t;  Ccompose_unary_t;  ►CConfigSingleton class for global configuration settings used by TMVA ;  CIONames;  CVariablePlotting;  CConfigurable;  CConvergenceTestCheck for convergence ;  CCostComplexityPruneToolA class to prune a decision tree using the Cost Complexity method ;  CCrossEntropyImplementation of the CrossEntropy as separation criterion ;  CCrossValidation;  CCrossValidationResult;  CDataInputHandlerClass that contains all the data information ;  CDataLoader;  CDataSetClass that contains all the data information ;  ►CDataSetFactoryClass that contains all the data information ;  CEventStats;  CDataSetInfoClass that contains all the data information ;  CDataSetManagerClass that contains all the data information ;  CDecisionTreeImplementation of a Decision Tree ;  CDecisionTreeNode;  CDeleteFunctor_t;  CDTNodeTrainingInfo;  CEnvelopeBase class for all machine learning algorithms ;  CEvent;  CExpectedErrorPruneToolA helper class to prune a decision tree using the expected error (C4.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:70681,learn,learning,70681,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['learn'],['learning']
Usability,"udes; Libraries. Function documentation; TMethodArg(MethodArgInfo_t* info = 0, TFunction* method = 0); Default TMethodArg ctor. TMethodArgs are constructed in TFunction; via a call to TCint::CreateListOfMethodArgs(). ~TMethodArg(); TMethodArg dtor deletes adopted CINT MethodArgInfo object. const char * GetDefault() const; Get default value of method argument. const char * GetTypeName() const; Get type of method argument, e.g.: ""class TDirectory*"" -> ""TDirectory""; Result needs to be used or copied immediately. const char * GetFullTypeName() const; Get full type description of method argument, e.g.: ""class TDirectory*"". Long_t Property() const; Get property description word. For meaning of bits see EProperty. TList * GetOptions() const; Returns list of possible options - according to pointed datamember.; If there is no datamember field assigned to this methodarg - returns 0. TDataMember * GetDataMember() const; Returns TDataMember pointed by this methodarg.; If you want to specify list of options or current value for your; MethodArg (i.e. it is used as initial values in argument-asking dialogs; popped up from context-meny),you can get this value from one of data; members of the class.; The only restriction is, that this DataMember object must have its; Getter/Setter methods set-up correctly - for details look at TDataMember.; To learn how to specify the data member to which the argument should; ""point"", look at TMethod. This is TMethod which sets up fDataMember,; so it could work correctly. TMethodArg(const TMethodArg& ). TMethodArg& operator=(const TMethodArg& ). TFunction * GetMethod() const; { return fMethod; }. » Author: Rene Brun 04/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TMethodArg.h 25986 2008-10-28 08:39:44Z brun $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMethodArg.html:7604,learn,learn,7604,root/html528/TMethodArg.html,https://root.cern,https://root.cern/root/html528/TMethodArg.html,1,['learn'],['learn']
Usability,"udes; Libraries. Function documentation; TMethodArg(MethodArgInfo_t* info = 0, TFunction* method = 0); Default TMethodArg ctor. TMethodArgs are constructed in TFunction; via a call to TCint::CreateListOfMethodArgs(). ~TMethodArg(); TMethodArg dtor deletes adopted CINT MethodArgInfo object. const char * GetDefault() const; Get default value of method argument. const char * GetTypeName() const; Get type of method argument, e.g.: ""class TDirectory*"" -> ""TDirectory""; Result needs to be used or copied immediately. const char * GetFullTypeName() const; Get full type description of method argument, e.g.: ""class TDirectory*"". Long_t Property() const; Get property description word. For meaning of bits see EProperty. TList * GetOptions() const; Returns list of possible options - according to pointed datamember.; If there is no datamember field assigned to this methodarg - returns 0. TDataMember * GetDataMember() const; Returns TDataMember pointed by this methodarg.; If you want to specify list of options or current value for your; MethodArg (i.e. it is used as initial values in argument-asking dialogs; popped up from context-meny),you can get this value from one of data; members of the class.; The only restriction is, that this DataMember object must have its; Getter/Setter methods set-up correctly - for details look at TDataMember.; To learn how to specify the data member to which the argument should; ""point"", look at TMethod. This is TMethod which sets up fDataMember,; so it could work correctly. TMethodArg(const TMethodArg& ). TMethodArg& operator=(const TMethodArg& ). TFunction * GetMethod() const; { return fMethod; }. » Author: Rene Brun 04/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TMethodArg.h 25986 2008-10-28 08:39:44Z brun $ » Last generated: 2011-07-04 15:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMethodArg.html:7673,learn,learn,7673,root/html530/TMethodArg.html,https://root.cern,https://root.cern/root/html530/TMethodArg.html,1,['learn'],['learn']
Usability,"udes; Libraries. Function documentation; TMethodArg(MethodArgInfo_t* info = 0, TFunction* method = 0); Default TMethodArg ctor. TMethodArgs are constructed in TFunction; via a call to TCint::CreateListOfMethodArgs(). ~TMethodArg(); TMethodArg dtor deletes adopted CINT MethodArgInfo object. const char * GetDefault() const; Get default value of method argument. const char * GetTypeName() const; Get type of method argument, e.g.: ""class TDirectory*"" -> ""TDirectory""; Result needs to be used or copied immediately. const char * GetFullTypeName() const; Get full type description of method argument, e.g.: ""class TDirectory*"". Long_t Property() const; Get property description word. For meaning of bits see EProperty. TList * GetOptions() const; Returns list of possible options - according to pointed datamember.; If there is no datamember field assigned to this methodarg - returns 0. TDataMember * GetDataMember() const; Returns TDataMember pointed by this methodarg.; If you want to specify list of options or current value for your; MethodArg (i.e. it is used as initial values in argument-asking dialogs; popped up from context-meny),you can get this value from one of data; members of the class.; The only restriction is, that this DataMember object must have its; Getter/Setter methods set-up correctly - for details look at TDataMember.; To learn how to specify the data member to which the argument should; ""point"", look at TMethod. This is TMethod which sets up fDataMember,; so it could work correctly. TMethodArg(const TMethodArg& ). TMethodArg& operator=(const TMethodArg& ). TFunction * GetMethod() const; { return fMethod; }. » Author: Rene Brun 04/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TMethodArg.h 25986 2008-10-28 08:39:44Z brun $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMethodArg.html:7812,learn,learn,7812,root/html532/TMethodArg.html,https://root.cern,https://root.cern/root/html532/TMethodArg.html,2,['learn'],['learn']
Usability,"ue, but can be specified as from \(\mbox{low}\) to \(\mbox{high}\). After each scan, if a new minimum is found, the best parameter values are retained as start values for future scans or minimizations. The curve resulting from each scan can be plotted on the output terminal using MnPlot [api:plot] in order to show the approximate behaviour of the function.; 5.10.2 ScanMinimizer; Although the \(\mbox{SCAN}\) method is not intended for minimization it can be used as a minimizer in its most primitive form.; 5.11 MnSimplex and SimplexMinimizer; [api:simplex]; \(\mbox{SIMPLEX}\) is a function minimization method using the simplex method of Nelder and Mead. MnSimplex provides minimization of the function by the method of \(\mbox{SIMPLEX}\) and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the SimplexMinimizer. Minimization of the function can be done by directly using the SimplexMinimizer if no parameters interaction is required. As \(\mbox{SIMPLEX}\) is a stepping method it does not produce a covariance matrix.; 5.11.1 MnSimplex(const FCNBase&, const std::vector\(<\)double\(>\)&,. const std::vector\(<\)double\(>\)&, unsigned int) ###; Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.11.2 MnSimplex(const FCNBase&, const MnUserParameters&,. unsigned int) ###; Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.11.3 MnSimplex(const FCNBase&, const MnUserParameterState&,. const MnStrategy&) ###; Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.11.4 operator(); MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:50013,Simpl,SimplexMinimizer,50013,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['Simpl'],['SimplexMinimizer']
Usability,"ue, but can be specified as from \(\mbox{low}\) to \(\mbox{high}\). After each scan, if a new minimum is found, the best parameter values are retained as start values for future scans or minimizations. The curve resulting from each scan can be plotted on the output terminal using MnPlot [api:plot] in order to show the approximate behaviour of the function.; 5.10.2 ScanMinimizer; Although the \(\mbox{SCAN}\) method is not intended for minimization it can be used as a minimizer in its most primitive form.; 5.11 MnSimplex and SimplexMinimizer; [api:simplex]; \(\mbox{SIMPLEX}\) is a function minimization method using the simplex method of Nelder and Mead. MnSimplex provides minimization of the function by the method of \(\mbox{SIMPLEX}\) and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the SimplexMinimizer. Minimization of the function can be done by directly using the SimplexMinimizer if no parameters interaction is required. As \(\mbox{SIMPLEX}\) is a stepping method it does not produce a covariance matrix.; 5.11.1 MnSimplex(const FCNBase&, const std::vector\(<\)double\(>\)&,; const std::vector\(<\)double\(>\)&, unsigned int); Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.11.2 MnSimplex(const FCNBase&, const MnUserParameters&,; unsigned int); Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.11.3 MnSimplex(const FCNBase&, const MnUserParameterState&,; const MnStrategy&); Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.11.4 operator(); MnSimplex::operator()(unsigned int maxfcn, double tolerance) causes minimization",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:54018,Simpl,SimplexMinimizer,54018,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['Simpl'],['SimplexMinimizer']
Usability,"ue;; 934 }; 935 ; 936 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 937 TDataType *type = (TDataType *)typeTable->THashTable::FindObject( inner );; 938 if (type) {; 939 // This is a raw type and an already loaded typedef.; 940 const char *newname = type->GetFullTypeName();; 941 if (type->GetType() == kLong64_t) {; 942 newname = ""Long64_t"";; 943 } else if (type->GetType() == kULong64_t) {; 944 newname = ""ULong64_t"";; 945 }; 946 if (strcmp(inner,newname) == 0) {; 947 return true;; 948 }; 949 if (offset) result = ""const "";; 950 result += newname;; 951 if ( end != tname.length() ) {; 952 result += tname.substr(end,tname.length()-end);; 953 }; 954 if (result == tname) result.clear();; 955 return true;; 956 }; 957 ; 958 // Check if the name is an enumerator; 959 const auto lastPos = TClassEdit::GetUnqualifiedName(inner);; 960 if (lastPos != inner) // Main switch: case 1 - scoped enum, case 2 global enum; 961 {; 962 // We have a scope; 963 const auto enName = lastPos;; 964 const auto scopeNameSize = (lastPos - inner) / sizeof(decltype(*lastPos)) - 2;; 965 std::string scopeName{inner, scopeNameSize};; 966 // Check if the scope is in the list of classes; 967 if (auto scope = static_cast<TClass *>(gROOT->GetListOfClasses()->FindObject(scopeName.c_str()))) {; 968 auto enumTable = dynamic_cast<const THashList *>(scope->GetListOfEnums(false));; 969 if (enumTable && enumTable->THashList::FindObject(enName)); 970 return true;; 971 }; 972 // It may still be in one of the loaded protoclasses; 973 else if (auto scope = static_cast<TProtoClass *>(gClassTable->GetProtoNorm(scopeName.c_str()))) {; 974 auto listOfEnums = scope->GetListOfEnums();; 975 if (listOfEnums) { // it could be null: no enumerators in the protoclass; 976 auto enumTable = dynamic_cast<const THashList *>(listOfEnums);; 977 if (enumTable && enumTable->THashList::FindObject(enName)); 978 return true;; 979 }; 980 }; 981 } else; 982 {; 983 // We don't have any scope: this could only be a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:33670,clear,clear,33670,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['clear'],['clear']
Usability,"uery; 1 save results after each packet (to reduce the; loss in case of crash). Setting 'ds' automatically sets 'mvf=1'; it is still possible to set 'mvf=11'; to save results after each packet. The separator from the next option is either a ' ' or a ';'. All recognized settings are removed from the input string opt.; If action == 0, set up the output file accordingly, if action == 1 clean related; output file settings.; If the final target file is local then 'target' is set to the final local path; when action == 0 and used to retrieve the file with TFile::Cp when action == 1. Output file settings are in the form. <previous_option>of=name <next_option>; <previous_option>outfile=name,...;<next_option>. The separator from the next option is either a ' ' or a ';'; Called interanally by TProof::Process. Returns 0 on success, -1 on error. void SetFeedback(TString& opt, TString& optfb, Int_t action); Extract from opt in optfb information about wanted feedback settings.; Feedback are removed from the input string opt.; If action == 0, set up feedback accordingly, if action == 1 clean related; feedback settings (using info in optfb, if available, or reparsing opt). Feedback requirements are in the form. <previous_option>fb=name1,name2,name3,... <next_option>; <previous_option>feedback=name1,name2,name3,...;<next_option>. The special name 'stats' triggers feedback about events and packets.; The separator from the next option is either a ' ' or a ';'.; Called interanally by TProof::Process. Long64_t Process(TDSet* dset, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process a data set (TDSet) using the specified selector (.C) file or; Tselector object; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Long64_t Process(TFileCollection* fc, const char* selector, Option_t* option = """", Long64_t nentries = -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:50991,Feedback,Feedback,50991,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,3,['Feedback'],['Feedback']
Usability,"ueryFrame::EQueryStatuskStopped. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TSessionQueryFrame. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query information frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }. TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h). TCanvas * GetStatsCanvas() const; { return fStatsCanvas; }. TEditQueryFrame * GetQueryEditFrame() const; { return fFD; }. void Progress(Long64_t total, Long64_t processed). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyrig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSessionQueryFrame.html:22959,progress bar,progress bar,22959,root/html602/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html602/TSessionQueryFrame.html,4,['progress bar'],['progress bar']
Usability,"ues at the knots.; a[200][4] two dimensional array whose columns are; the computed spline coefficients; diff[3] maximum values of differences of values and; derivatives to right and left of knots.; com[3] maximum values of coefficients. test of TSpline3 with nonequidistant knots and; equidistant knots follows. Int_t FindX(Double_t x) const; Find X. Double_t Eval(Double_t x) const; Eval this spline at x. Double_t Derivative(Double_t x) const; Derivative. void SaveAs(const char* filename, Option_t* option = """") const; write this spline as a C++ function that can be executed without ROOT; the name of the function is the name of the file up to the ""."" if any. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetPoint(Int_t i, Double_t x, Double_t y); set point number i. void SetPointCoeff(Int_t i, Double_t b, Double_t c, Double_t d); set point coefficient number i. void BuildCoeff(); subroutine cubspl ( tau, c, n, ibcbeg, ibcend ); from * a practical guide to splines * by c. de boor; ************************ input ***************************; n = number of data points. assumed to be .ge. 2.; (tau(i), c(1,i), i=1,...,n) = abscissae and ordinates of the; data points. tau is assumed to be strictly increasing.; ibcbeg, ibcend = boundary condition indicators, and; c(2,1), c(2,n) = boundary condition information. specifically,; ibcbeg = 0 means no boundary condition at tau(1) is given.; in this case, the not-a-knot condition is used, i.e. the; jump in the third derivative across tau(2) is forced to; zero, thus the first and the second cubic polynomial pieces; are made to coincide.); ibcbeg = 1 means that the slope at tau(1) is made to equal; c(2,1), supplied by input.; ibcbeg = 2 means that the second derivative at tau(1) is; made to equal c(2,1), supplied by input.; ibcend = 0, 1, or 2 has analogous meaning concerning the; boundary condition at tau(n), with the additional infor-; mation taken from c(2,n).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpline3.html:12586,guid,guide,12586,root/html528/TSpline3.html,https://root.cern,https://root.cern/root/html528/TSpline3.html,10,['guid'],['guide']
Usability,"uffer &ClassDef_StreamerNVirtual_b);  ; void wireCache () override;  ;  Public Member Functions inherited from RooAbsCache;  RooAbsCache (const RooAbsCache &, RooAbsArg *owner=nullptr);  Copy constructor. Takes owner as argument and registers cache with owne. ;  ;  RooAbsCache (RooAbsArg *owner=nullptr);  Constructor. Takes owner as argument and register cache with owner. ;  ; virtual ~RooAbsCache ();  Destructor. Unregisters cache with owner. ;  ; void setOwner (RooAbsArg *owner);  Reset the owner, triggering the owner to register this cache in its list of caches. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static bool clearObsList ();  ; static const char * DeclFileName ();  ; static void doClearObsList (bool flag);  ;  Static Public Member Functions inherited from RooCacheManager< RooAbsCacheElement >; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsCache; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Attributes; bool _allowOptimize;  ; bool _clearOnRedirect;  ; bool _optCacheModeSeen;  ! ;  ; RooArgSet * _optCacheObservables = nullptr;  ! current optCacheObservables ;  ;  Protected Attributes inherited from RooCacheManager< RooAbsCacheElement >; Int_t _lastIndex;  ! Last slot accessed ;  ; Int_t _maxSize;  ! Maximum size ;  ; std::vector< RooNormSetCache > _nsetCache;  ! Normalization/Integration set manager ;  ; std::vector< RooAbsCacheElement * > _object;  ! Payload ;  ; Int_t _size;  ! Actual use ;  ; bool _wired;  ! In wired mode, there is a single payload which is returned always ;  ;  Protected Attributes inherit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:5285,clear,clearObsList,5285,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['clear'],['clearObsList']
Usability,"uffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafF(); Default constructor for LeafF*-*-*-*-*-*-*-*-; *-* ============================. TLeafF(TBranch* parent, const char* name, const char* type); Create a LeafF*-*-; *-* ==============; -. ~TLeafF(); Default destructor for a LeafF*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* ==========================================. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a float from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Double_t GetValue(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { return fValue[i]; }. TLeafF(). const char * GetTypeName() const; {return ""Float_t"";}. void * GetValuePointer() const; {return fValue;}. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TLeafF.html:9233,simpl,simple,9233,root/html534/TLeafF.html,https://root.cern,https://root.cern/root/html534/TLeafF.html,2,['simpl'],['simple']
Usability,"uffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::WriteClassBuffervirtual Int_t WriteClassBuffer(const TClass *cl, void *pointer)=0; TCollection::Printvoid Print(Option_t *option="""") const overrideDefault print for collections, calls Print(option, 1).Definition TCollection.cxx:476; TCollection::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an collection using the Streamer facility.Definition TCollection.cxx:263; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::GetXsizeDouble_t GetXsize()Return size of the formula along X in pad coordinates when the text precision is smaller than 3.Definition TLatex.cxx:2569; TLatex::Classstatic TClass * Class(); TLatex::PaintLatexvirtual void PaintLatex(Double_t x, Double_t y, Double_t angle, Double_t size, const char *text)Main drawing function.Definition TLatex.cxx:2114; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::Classstatic TClass * Class(); TLine::PaintLinevirtual void PaintLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:399; TLine::GetY1Double_t GetY1() constDefinition TLine.h:52; TLine::GetX2Double_t GetX2() constDefinition TLine.h:51; TLine::IsATClass * IsA() const overrideDefinition TLine.h:79; TLine::GetX1Double_t GetX1() constDefinition TLine.h:50; TLine::GetY2Double_t GetY2() constDefinition TLine.h:53; TListA doubly linked list.Definition TList.h:38; TList::AddAftervoid AddAfter(const TObject *after, TObject *obj) overrideInsert object after object after in the list.Definition TList.cxx:248; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::LastTObject * Last() const overrideReturn the last object in the list. Returns 0 when list is em",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPaveText_8cxx_source.html:35795,simpl,simple,35795,doc/master/TPaveText_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPaveText_8cxx_source.html,1,['simpl'],['simple']
Usability,"ufferSizeInt_t SetBufferSize(Long64_t buffersize) overrideChange the underlying buffer size of the cache.Definition TTreeCache.cxx:2073; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2145; TTreeCache::GetTreeTTree * GetTree() constDefinition TTreeCache.h:149; TTreeCache::SetEntryRangevirtual void SetEntryRange(Long64_t emin, Long64_t emax)Set the minimum and maximum entry number to be processed this information helps to optimize the numbe...Definition TTreeCache.cxx:2106; TTreeCache::DropBranchvirtual Int_t DropBranch(TBranch *b, bool subbranches=false)Remove a branch to the list of branches to be stored in the cache this function is called by TBranch:...Definition TTreeCache.cxx:541; TTreeCache::SetAutoCreatedvoid SetAutoCreated(bool val)Definition TTreeCache.h:164; TTreeCache::StopLearningPhasevirtual void StopLearningPhase()This is the counterpart of StartLearningPhase() and can be used to stop the learning phase.Definition TTreeCache.cxx:2187; TTreeCache::Printvoid Print(Option_t *option="""") const overridePrint cache statistics.Definition TTreeCache.cxx:1899; TTreeCache::AddBranchInt_t AddBranch(TBranch *b, bool subgbranches=false) overrideAdd a branch to the list of branches to be stored in the cache this function is called by the user vi...Definition TTreeCache.cxx:376; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeCloner::kNoWarnings@ kNoWarningsDefinition TTreeCloner.h:100; TTreeCloner::GetWarningconst char * GetWarning() constDefinition TTreeCloner.h:117; TTreeCloner::Execbool Exec()Execute the cloning.Definition TTreeCloner.cxx:222; TTreeCloner::NeedConversionbool NeedConversion()Definition TTreeCloner.h:121; TTreeCloner::IsValidbool IsValid()Definition TTreeCloner.h:120; TTreeCloner::SetCacheSizevoid SetCacheSize(Long64_t size)Set the cache size us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:430357,learn,learning,430357,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['learn'],['learning']
Usability,"ug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Support RootTalk Digest. This mailing list is used to keep you up to date about important ROOT events (new releases, urgent bug fixes, etc.). This list is also used to discuss anything concerning ROOT with your fellow ROOT users and with the developers.; Currently available digests:; All articles of 2012 on the new e-groups mailing list; All articles of 2012; All articles of 2011; All articles of 2010; All articles of 2009; All articles of 2008; All articles of 2007; All articles of 2006; All articles of 2005; All articles of 2004; All articles of 2003; All articles of 2002; All articles of 2001; All articles of 2000; All articles of 1999; All articles of 1998; All articles of 1997. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/roottalk-digest.html:2780,guid,guidelines,2780,d/roottalk-digest.html,https://root.cern,https://root.cern/d/roottalk-digest.html,1,['guid'],['guidelines']
Usability,"uick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » BINDINGS; » PYROOT; » TPyMultiGenFunction. class TPyMultiGenFunction: public ROOT::Math::IBaseFunctionMultiDim. Python wrapper for Fit functions. Function Members (Methods); public:. TPyMultiGenFunction(PyObject* self = 0); virtual~TPyMultiGenFunction(); static TClass*Class(); virtual ROOT::Math::IBaseFunctionMultiDim*Clone() const; virtual doubleDoEval(const double* x) const; virtual TClass*IsA() const; virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TPyMultiGenFunction(const TPyMultiGenFunction& src); TPyMultiGenFunction&operator=(const TPyMultiGenFunction&). Data Members; private:. PyObject*fPySelf! actual python object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPyMultiGenFunction(PyObject* self = 0); Construct a TPyMultiGenFunction derived with <self> as the underlying. ~TPyMultiGenFunction(); Destructor. Only deref if still holding on to Py_None (circular otherwise). unsigned int NDim() const; Simply forward the call to python self. double DoEval(const double* x) const; Simply forward the call to python self. TPyMultiGenFunction(PyObject* self = 0); ctor/dtor, and assignment. ROOT::Math::IBaseFunctionMultiDim* Clone() const; Math::IMultiGenFunction implementation. { return new TPyMultiGenFunction( fPySelf ); }. TPyMultiGenFunction& operator=(const TPyMultiGenFunction& ); { return *this; }. » Last changed: Thu Nov 3 20:22:00 2011 » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPyMultiGenFunction.html:1389,Simpl,Simply,1389,root/html532/TPyMultiGenFunction.html,https://root.cern,https://root.cern/root/html532/TPyMultiGenFunction.html,2,['Simpl'],['Simply']
Usability,"uit::mnimprvirtual void mnimpr()Attempts to improve on a good local minimum.Definition TMinuit.cxx:4295; TMinuit::fPstarDouble_t * fPstarDefinition TMinuit.h:92; TMinuit::fObjectFitTObject * fObjectFitDefinition TMinuit.h:175; TMinuit::BuildArraysvirtual void BuildArrays(Int_t maxpar=15)Create internal Minuit arrays for the maxpar parameters.Definition TMinuit.cxx:512; TMinuit::mnwerrvirtual void mnwerr()Calculates the WERR, external parameter errors.Definition TMinuit.cxx:7861; TMinuit::fNfcnfrInt_t fNfcnfrDefinition TMinuit.h:148; TMinuit::mnrsetvirtual void mnrset(Int_t iopt)Resets function value and errors to UNDEFINED.Definition TMinuit.cxx:6661; TMinuit::fIMPRyDouble_t * fIMPRyDefinition TMinuit.h:106; TMinuit::fVlimhiDouble_t fVlimhiDefinition TMinuit.h:59; TMinuit::mneigvirtual void mneig(Double_t *a, Int_t ndima, Int_t n, Int_t mits, Double_t *work, Double_t precis, Int_t &ifault)Compute matrix eigen values.Definition TMinuit.cxx:2305; TMinuit::mnsimpvirtual void mnsimp()Minimization using the simplex method of Nelder and Mead.Definition TMinuit.cxx:7431; TMinuit::fLwarnBool_t fLwarnDefinition TMinuit.h:157; TMinuit::fXptDouble_t * fXptDefinition TMinuit.h:97; TMinuit::fGinDouble_t * fGinDefinition TMinuit.h:84; TMinuit::GetMethodCallTMethodCall * GetMethodCall() constDefinition TMinuit.h:193; TMinuit::fNfcnmxInt_t fNfcnmxDefinition TMinuit.h:146; TMinuit::fItaurInt_t fItaurDefinition TMinuit.h:149; TMinuit::TMinuitTMinuit()Minuit normal constructor.Definition TMinuit.cxx:347; TMinuit::fUndefiDouble_t fUndefiDefinition TMinuit.h:60; TMinuit::fKe2crInt_t fKe2crDefinition TMinuit.h:156; TMinuit::mnaminvirtual void mnamin()Initialize AMIN.Definition TMinuit.cxx:972; TMinuit::SetErrorDefvirtual Int_t SetErrorDef(Double_t up)To get the n-sigma contour the error def parameter ""up"" has to set to n^2.Definition TMinuit.cxx:908; TMinuit::fNuInt_t fNuDefinition TMinuit.h:130; TMinuit::fPDouble_t * fPDefinition TMinuit.h:91; TMinuit::fNblockInt_t fNblockDefinition TMin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:259761,simpl,simplex,259761,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['simpl'],['simplex']
Usability,"uited setter method. ~TMultiLayerPerceptron(); Destructor. void SetData(TTree* ); Set the data source. void SetEventWeight(const char* ); Set the event weight. void SetTrainingDataSet(TEventList* train); Sets the Training dataset.; Those events will be used for the minimization. void SetTestDataSet(TEventList* test); Sets the Test dataset.; Those events will not be used for the minimization but for control. void SetTrainingDataSet(const char* train); Sets the Training dataset.; Those events will be used for the minimization.; Note that the tree must be already defined. void SetTestDataSet(const char* test); Sets the Test dataset.; Those events will not be used for the minimization but for control.; Note that the tree must be already defined. void SetLearningMethod(TMultiLayerPerceptron::ELearningMethod method); Sets the learning method.; Available methods are: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS.; (look at the constructor for the complete description; of learning methods and parameters). void SetEta(Double_t eta); Sets Eta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEpsilon(Double_t eps); Sets Epsilon - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetDelta(Double_t delta); Sets Delta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEtaDecay(Double_t ed); Sets EtaDecay - Eta *= EtaDecay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:23609,learn,learning,23609,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,10,['learn'],['learning']
Usability,"ult pavetext AttText.; A title can be added later to this pavetext via TPaveText::SetLabel. IMPORTANT NOTE:; Because TPave objects (and objects deriving from TPave) have their; master coordinate system in NDC, one cannot use the TBox functions; SetX1,SetY1,SetX2,SetY2 to change the corner coordinates. One should use; instead SetX1NDC, SetY1NDC, SetX2NDC, SetY2NDC. ~TPaveText(); pavetext default destructor. TPaveText(const TPaveText& pavetext); pavetext copy constructor. TPaveText& operator=(const TPaveText& ); assignment operator. TBox * AddBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Add a new graphics box to this pavetext. TLine * AddLine(Double_t x1 = 0, Double_t y1 = 0, Double_t x2 = 0, Double_t y2 = 0); Add a new graphics line to this pavetext. TText * AddText(Double_t x1, Double_t y1, const char* label); Add a new Text line to this pavetext at given coordinates. TText * AddText(const char* label); Add a new Text line to this pavetext. void Clear(Option_t* option = """"); Clear all lines in this pavetext. void DeleteText(); Delete text at the mouse position. void Draw(Option_t* option = """"); Draw this pavetext with its current attributes. void DrawFile(const char* filename, Option_t* option = """"); Draw lines in filename in this pavetext. void EditText(); Edit text at the mouse position. TText * GetLine(Int_t number) const; Get Pointer to line number in this pavetext. TText * GetLineWith(const char* text) const; Get Pointer to first containing string text in this pavetext. TObject * GetObject(Double_t& ymouse, Double_t& yobj) const; Get object pointed by the mouse in this pavetext. Int_t GetSize() const; return number of text lines (ignoring Tlines, etc). void InsertLine(); Add a new lineine at the mouse position. void InsertText(const char* label); Add a new Text line at the mouse position. void Paint(Option_t* option = """"); Paint this pavetext with its current attributes. void PaintPrimitives(Int_t mode); Paint list of primitives in this pavetext. voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPaveText.html:13653,Clear,Clear,13653,root/html532/TPaveText.html,https://root.cern,https://root.cern/root/html532/TPaveText.html,2,['Clear'],['Clear']
Usability,"ult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*createChi2(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:3352,clear,clearShapeDirty,3352,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,1,['clear'],['clearShapeDirty']
Usability,"ultB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr=0); Elementary constructors. void AMultB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr=0). void AMultB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr=0). void APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr=0). TMatrixTBase<Element> & SetRowIndexArray(Int_t* data); { memmove(fRowIndex,data,(this->fNrows+1)*sizeof(Int_t)); return *this; }. TMatrixTBase<Element> & SetColIndexArray(Int_t* data); { memmove(fColIndex,data,this->fNelems*sizeof(Int_t)); return *this; }. TMatrixTSparse<Element> & SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b). TMatrixTBase<Element> & SetMatrixArray(const double* data, Option_t* = """"); { memcpy(fElements,data,this->fNelems*sizeof(Element)); return *this; }. TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1). void Clear(Option_t* = """"). TMatrixTSparse<Element> & Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, Int_t* pRowIndex, Int_t* pColIndex, double* pData). Bool_t IsSymmetric() const; { return (*this == TMatrixTSparse<Element>(kTransposed,*this)); }. void Mult(const TMatrixTSparse<double>& a, const TMatrixTSparse<double>& b); { AMultB(a,b,0); }. Int_t NonZeros() const; { return this->fNelems; }. TMatrixTBase<Element> & NormByDiag(const TVectorT<double>& , Option_t* ); { MayNotUse(""NormByDiag""); return *this; }. const TMatrixTSparseRow_const<Element> operator[](Int_t rown) const; or as a[i][j]. { return TMatrixTSparseRow_const<Element>(*this,rown); }. TMatrixTSparseRow <Element> operator[](Int_t rown); { return TMatrixTSparseRow <Element>(*this,rown); }. TMatrixTSparse<Element> & operator-=(Element val). TMatrixTSparse<Element> & operator+=(Element val). TMatrixTSparse<Element> & operator*=(Element val). TMatrixTSparse<Element> & operator+=(const TMatrixTSparse<Eleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMatrixTSparse_double_.html:26955,Clear,Clear,26955,root/html532/TMatrixTSparse_double_.html,https://root.cern,https://root.cern/root/html532/TMatrixTSparse_double_.html,4,['Clear'],['Clear']
Usability,"ultiRootFinder.h:233; ROOT::Math::GSLMultiRootFinder::fIterint fIterDefinition GSLMultiRootFinder.h:276; ROOT::Math::GSLMultiRootFinder::EDerivTypeEDerivTypeenumeration specifying the types of GSL multi root finders requiring the derivativesDefinition GSLMultiRootFinder.h:104; ROOT::Math::GSLMultiRootFinder::kGNewton@ kGNewtonDefinition GSLMultiRootFinder.h:108; ROOT::Math::GSLMultiRootFinder::kHybridSJ@ kHybridSJDefinition GSLMultiRootFinder.h:105; ROOT::Math::GSLMultiRootFinder::kNewton@ kNewtonDefinition GSLMultiRootFinder.h:107; ROOT::Math::GSLMultiRootFinder::kHybridJ@ kHybridJDefinition GSLMultiRootFinder.h:106; ROOT::Math::GSLMultiRootFinder::GSLMultiRootFinderGSLMultiRootFinder(const GSLMultiRootFinder &)=delete; ROOT::Math::GSLMultiRootFinder::AddFunctionint AddFunction(Function &f, int ndim)same method as before but using any function implementing the operator(), so can be wrapped in a IMul...Definition GSLMultiRootFinder.h:193; ROOT::Math::GSLMultiRootFinder::Clearvoid Clear()clear list of functionsDefinition GSLMultiRootFinder.cxx:127; ROOT::Math::GSLMultiRootFinder::operator=GSLMultiRootFinder & operator=(const GSLMultiRootFinder &)=delete; ROOT::Math::GSLMultiRootFinder::SetDefaultTolerancestatic void SetDefaultTolerance(double abstol, double reltol=0)set tolerance (absolute and relative) relative tolerance is only use to verify the convergence do it ...Definition GSLMultiRootFinder.cxx:57; ROOT::Math::GSLMultiRootFinder::AddFunctionint AddFunction(const ROOT::Math::IMultiGenFunction &func)Definition GSLMultiRootFinder.cxx:110; ROOT::Math::GSLMultiRootFinder::fUseDerivAlgobool fUseDerivAlgoDefinition GSLMultiRootFinder.h:284; ROOT::Math::GSLMultiRootFinder::Xconst double * X() constreturn the root X values solving the systemDefinition GSLMultiRootFinder.cxx:135; ROOT::Math::GSLMultiRootFinder::SetDefaultMaxIterationsstatic void SetDefaultMaxIterations(int maxiter)set maximum number of iterationsDefinition GSLMultiRootFinder.cxx:62; ROOT::Math::GSLMultiR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GSLMultiRootFinder_8h_source.html:16508,clear,clear,16508,doc/master/GSLMultiRootFinder_8h_source.html,https://root.cern,https://root.cern/doc/master/GSLMultiRootFinder_8h_source.html,1,['clear'],['clear']
Usability,"um of daughter's capacities. void CheckGeometry(Int_t nrays = 1, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0) const; Shoot nrays with random directions from starting point (startx, starty, startz); in the reference frame of this volume. Track each ray until exiting geometry, then; shoot backwards from exiting point and compare boundary crossing points. void CheckOverlaps(Double_t ovlp = 0.1, Option_t* option = """") const; Overlap checking tool. Check for illegal overlaps within a limit OVLP.; Use option=""s[number]"" to force overlap checking by sampling volume with; [number] points.; Ex: myVol->CheckOverlaps(0.01, ""s10000000""); // shoot 10000000 points; myVol->CheckOverlaps(0.01, ""s""); // shoot the default value of 1e6 points. void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); Tests for checking the shape navigation algorithms. See TGeoShape::CheckShape(). void CleanAll(); Clean data of the volume. void ClearShape(); Clear the shape of this volume from the list held by the current manager. void CheckShapes(); check for negative parameters in shapes.; THIS METHOD LEAVES SOME GARBAGE NODES -> memory leak, to be fixed; printf(""---Checking daughters of volume %s\n"", GetName());. Int_t CountNodes(Int_t nlevels = 1000, Int_t option = 0); Count total number of subnodes starting from this volume, nlevels down; option = 0 (default) - count only once per volume; option = 1 - count every time; option = 2 - count volumes on visible branches; option = 3 - return maximum level counted already with option = 0. Bool_t IsAllInvisible() const; Return TRUE if volume and all daughters are invisible. void InvisibleAll(Bool_t flag = kTRUE); Make volume and each of it daughters (in)visible. Bool_t IsFolder() const; Return TRUE if volume contains nodes; return (GetNdaughters()?kTRUE:kFALSE);. Bool_t IsStyleDefault() const; check if the visibility and attributes are the default ones. Bool_t IsTopVolume() const; True if this is the top volume of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoVolume.html:23077,Clear,ClearShape,23077,root/html532/TGeoVolume.html,https://root.cern,https://root.cern/root/html532/TGeoVolume.html,4,['Clear'],"['Clear', 'ClearShape']"
Usability,"umVect->clear();; 911 ; 912 //---------------------------------------------------------------------------; 913 // Check the validity of each list element; 914 /////////////////////////////////////////////////////////////////////////////; 915 ; 916 for( const auto& checksumStr : checksums ) {; 917 auto chksum = ParseChecksum( checksumStr.c_str() );; 918 if (chksum == 0u) {; 919 delete fChecksumVect;; 920 fChecksumVect = nullptr;; 921 return kFALSE;; 922 }; 923 ; 924 fChecksumVect->push_back( chksum );; 925 }; 926 return kTRUE;; 927}; 928 ; 929////////////////////////////////////////////////////////////////////////////////; 930/// Parse the checksum in the given string. Returns either the checksum or zero; 931/// if the string is not a hex or decimal number.; 932 ; 933UInt_t TSchemaRule::ParseChecksum(const char* checksum) const {; 934 std::istringstream converter(checksum);; 935 UInt_t chksum;; 936 converter >> std::hex >> chksum;; 937 if (converter.fail()) {; 938 converter.clear();; 939 converter.seekg(0);; 940 converter >> std::dec >> chksum;; 941 }; 942 ; 943 if( converter.fail() ) {; 944 return 0u;; 945 }; 946 ; 947 return chksum;; 948}; 949 ; 950////////////////////////////////////////////////////////////////////////////////; 951/// Split the list as a comma separated list into a TObjArray of TObjString.; 952 ; 953void TSchemaRule::ProcessList( TObjArray* array, const TString& list ); 954{; 955 std::list<std::string> elems;; 956 std::list<std::string>::iterator it;; 957 Internal::TSchemaRuleProcessor::SplitList( (const char*)list, elems );; 958 ; 959 array->Clear();; 960 ; 961 if( elems.empty() ); 962 return;; 963 ; 964 for( it = elems.begin(); it != elems.end(); ++it ) {; 965 TObjString *str = new TObjString;; 966 *str = it->c_str();; 967 array->Add( str );; 968 }; 969}; 970 ; 971////////////////////////////////////////////////////////////////////////////////; 972/// Split the list as a declaration into as a TObjArray of TNamed(name,type).; 973 ; 974void TSchem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRule_8cxx_source.html:30633,clear,clear,30633,doc/master/TSchemaRule_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRule_8cxx_source.html,1,['clear'],['clear']
Usability,"umber (1->5) of; branches, since all their baskets will be clustered together; instead of being spread across the file. However it might; decrease the performance when reading more branches (or the full; entry). When using SortBasketsByEntry the baskets with the lowest; starting entry are written first. (i.e. the baskets are; sorted on the index/number of the first entry they contain).; This means that on the file the baskets will be in the order; in which they will be needed when reading the whole tree; sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in $ROOTSYS/test/Event; with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in $ROOTSYS/test/Event; with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree from its original. Long64_t CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); Copy nentries from given tree to this tree.; This routines assumes that the branches that intended to be copied are; already connected. The typical case is that this tree was created using; tree->CloneTree(0). By default copy all entries. Returns number of bytes copied to this tree. If 'option' contains the word 'fast' and nentries is -1, the cloning will be; done without unzipping or unstreaming the baskets (i.e., a direct copy of the; raw bytes on disk). When 'fast' is specified, 'option' can also contains a sorting order for the; baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. See TTree::CloneTree for a detailed explanat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:58154,undo,undo,58154,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,4,['undo'],['undo']
Usability,umber counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspector;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset ;  CProofConfigHolds configuration options for proof and proof-lite ;  CProposalFunctionProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ;  CSamplingDistPlotThis class provides simple and straightforward utilities to plot SamplingDistribution objects ;  CSamplingDistributionThis class simply holds a sampling distribution of some test statistic ;  CSamplingSummary;  CSamplingSummaryLookup;  CSequentialProposalClass implementing a proposal function that samples the parameter space by moving only in one coordinate (choosen randomly) at each step ;  CSimpleInterval;  CSimpleLikelihoodRatioTestStatTestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood ;  CSPlotThis class calculates sWeights used to create an sPlot ;  CTestStatisticTestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class ;  CTestStatSamplerTestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions ;  CToyMCImportanceSamplerToyMCImportanceSampler is an extension of the ToyMCSampler for Importance Sampling ;  CToyMCPayload;  CToyMCSamplerToyMCSampler is an impleme,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:8648,simpl,simple,8648,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,3,['simpl'],['simple']
Usability,"umber of events requested; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t MakeSelector(const char* selfile); Create the selector object and save the relevant files and binary information; in the cache so that the worker can pick it up.; Returns 0 and fill fSelector in case of success. Returns -1 and sets; fSelector to 0 in case of failure. Long64_t Process(TDSet* set, TSelector* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF.; This method is called on client and on the PROOF master.; The return value is -1 in case of an error and TSelector::GetStatus() in; in case of success. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF.; This method is called on client and on the PROOF master.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); Finalize a query.; Returns -1 in case error, 0 otherwise. Bool_t HandleTimer(TTimer* timer); Send feedback objects to client. void SetupFeedback(); Setup reporting of feedback objects. void StoreFeedback(TObject* slave, TList* out); Store feedback results from the specified slave. TProofPlayerLite(TProof* proof = 0); { }. virtual ~TProofPlayerLite(); { }. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). » Author: G. Ganis Mar 2008 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-30 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerLite.html:19776,feedback,feedback,19776,root/html602/TProofPlayerLite.html,https://root.cern,https://root.cern/root/html602/TProofPlayerLite.html,6,['feedback'],['feedback']
Usability,"umber of events requested; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t MakeSelector(const char* selfile); Create the selector object and save the relevant files and binary information; in the cache so that the worker can pick it up.; Returns 0 and fill fSelector in case of success. Returns -1 and sets; fSelector to 0 in case of failure. Long64_t Process(TDSet* set, TSelector* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF.; This method is called on client and on the PROOF master.; The return value is -1 in case of an error and TSelector::GetStatus() in; in case of success. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF.; This method is called on client and on the PROOF master.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); Finalize a query.; Returns -1 in case error, 0 otherwise. Bool_t HandleTimer(TTimer* timer); Send feedback objects to client. void SetupFeedback(); Setup reporting of feedback objects. void StoreFeedback(TObject* slave, TList* out); Store feedback results from the specified slave. TProofPlayerLite(TProof* proof = 0); { }. virtual ~TProofPlayerLite(); { }. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). » Author: G. Ganis Mar 2008 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-09-08 17:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerLite.html:19986,feedback,feedback,19986,root/html604/TProofPlayerLite.html,https://root.cern,https://root.cern/root/html604/TProofPlayerLite.html,6,['feedback'],['feedback']
Usability,"umbers distributed according to a function defined by the user ;  TestBinomial.C Perform a fit to a set of data with binomial errors like those derived from the division of two histograms ;  TwoHistoFit2D.C Example to fit two histograms at the same time ;  ► fitsio;  FITS_tutorial1.COpen a FITS file and retrieve the first plane of the image array as a TImage object ;  FITS_tutorial2.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial3.COpen a FITS file and retrieve the first plane of the image array as a TImage object ;  FITS_tutorial4.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial5.COpen a FITS file whose primary array represents a spectrum (flux vs wavelength) ;  FITS_tutorial6.COpen a FITS file whose primary array represents a spectrum table (flux vs wavelength) and dump its columns ;  ► foam;  foam_demo.C Demonstrate the TFoam class ;  foam_demopers.C This simple macro demonstrates persistency of FOAM object ;  foam_kanwa.C This program can be execute from the command line as folows: ;  ► geom;  assembly.CGeometry detector assembly example ;  building.CDrawing a building where Dept ;  cheongwadae.CDrawing the Cheongwadae building which is the Presidential Residence of the Republic of Korea, using ROOT geometry class ;  csgdemo.CCombinatorial Solid Geometry example ;  geodemo.CGUI to draw the geometry shapes ;  geomAlice.CScript drawing a detector geometry (here ALICE) ;  geomAlice_itsv.CScript drawing a detector geometry (here ITSV from Alice) ;  geomAtlas.CScript drawing a detector geometry (here ATLAS) ;  geomBrahms.CScript drawing a detector geometry (here BRAHMS) ;  geomD0.CScript drawing a detector geometry (here D0) ;  geometry.CExample of the old geometry package (now obsolete) ;  iterplugin.cxx;  lego.CDrawing a figure, made of lego block, using ROOT geometry class ;  mp3player.CDrawing a mp3 type music player, using ROOT geometry class ;  na49.CThis file has",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:108315,simpl,simple,108315,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,2,['simpl'],['simple']
Usability,"ume is a small world by itself - what we need to do is to take it out and to ignore all the rest since it is a self-contained object. In fact, the modeller can act like this, considering a given volume as temporary MARS, but we will describe this feature later on. Let us focus on the biggest pack - it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:; 18.1.1 Example 1: Creating the World; We first need to load the geometry library. This is not needed if one does make map in root folder.; root[] gSystem->Load(""libGeom"");; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; We can finally make our volume having a box shape. Note that the world volume does not need to be a box - it can be any other shape. Generally, boxes and tubes are the most recommendable shapes for this purpose due to their fast navigation algorithms.; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; The default units are in centimeters. Now we want to make this volume our world. We have to do this operation before closing the geometry.; root[] gGeoManager->SetTopVolume(top);; This should be enough, but it is not since always after defining some geometry hierarchy, TGeo needs to bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:877300,simpl,simplest,877300,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simplest']
Usability,"umed for all frames put into the editor. This implies:. do not share the layout-hints among GUI components;; do not delete child widgets in the destructor as this is done automatically. 25.9.2.2 Using Several Tabs; Sometimes you might need to use several tabs to organize properly your class-editor. Each editor tab is a resource shared among all the class-editors. Tabs must be created from the constructor of your editor-class by using the method:; TGVerticalFrame* TGedFrame::CreateEditorTabSubFrame(const Text_t *name),; It returns a pointer to a new tab container frame ready for use in your class. If you need to hide/show this frame depending on the object’s status, you should store it in a data member. See for examples: TH1Editor, TH2Editor.; 25.9.2.3 Base-Class Editors Control; Full control over base-class editors can be achieved by re-implementing virtual method void TGedFrame::ActivateBaseClassEditors(TClass *cl). It is called during each compound editor rebuild and the default implementation simply offers all base-classes to the publishing mechanism.; To prevent inclusion of a base-class into the compound editor, call:; void TGedEditor::ExcludeClassEditor(TClass* class, Bool_t recurse); Pointer to the compound GED-editor is available in TGedFrame‘s data-member:; TGedEditor *fGedEditor; Ordering of base-class editor frames follows the order of the classes in the class hierarchy. This order can be changed by modifying the value of TGedFrame’s data member Int_t fPriority. The default value is 50; smaller values move the frame towards to the top. This priority should be set in the editor constructor.; 25.10 Drag and Drop; Drag and Drop support is introduced for Linux (via Xdnd - the drag and drop protocol for X window system) and for Windows (via Clipboard). Users can selects something in ROOT with a mouse press, drags it (moves the mouse while keeping the mouse button pressed) and releases the mouse button someplace else. When the button is released the selected da",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1225973,simpl,simply,1225973,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simply']
Usability,"ummy, std::string histoName, int bins=0, double min=0, double max=0);  ; TH2F * getHistogram (const TH2F *dummy, std::string histoName, int bins=0, double min=0, double max=0, int bins2=0, double min2=0, double max2=0);  . Private Attributes; TCanvas * fCanvas;  ; std::map< std::string, TH1F * > m_histos1D;  ; std::map< std::string, TH2F * > m_histos2D;  . #include <TMVA/Monitoring.h>; Constructor & Destructor Documentation. ◆ Monitoring(). TMVA::Monitoring::Monitoring ; (; ). inline . Definition at line 26 of file Monitoring.h. ◆ ~Monitoring(). TMVA::Monitoring::~Monitoring ; (; ). inline . Definition at line 31 of file Monitoring.h. Member Function Documentation. ◆ addPoint() [1/2]. void TMVA::Monitoring::addPoint ; (; std::string ; histoName, . double ; x . ). inline . Definition at line 169 of file Monitoring.h. ◆ addPoint() [2/2]. void TMVA::Monitoring::addPoint ; (; std::string ; histoName, . double ; x, . double ; y . ). inline . Definition at line 176 of file Monitoring.h. ◆ clear(). void TMVA::Monitoring::clear ; (; std::string ; histoName). inline . Definition at line 183 of file Monitoring.h. ◆ create() [1/2]. void TMVA::Monitoring::create ; (; std::string ; histoName, . int ; bins, . double ; min, . double ; max . ). inline . Definition at line 132 of file Monitoring.h. ◆ create() [2/2]. void TMVA::Monitoring::create ; (; std::string ; histoName, . int ; bins, . double ; min, . double ; max, . int ; bins2, . double ; min2, . double ; max2 . ). inline . Definition at line 138 of file Monitoring.h. ◆ exists() [1/3]. bool TMVA::Monitoring::exists ; (; std::string ; histoName). inline . Definition at line 116 of file Monitoring.h. ◆ exists() [2/3]. bool TMVA::Monitoring::exists ; (; TH1F * ; dummy, . std::string ; histoName . ). inline . Definition at line 99 of file Monitoring.h. ◆ exists() [3/3]. bool TMVA::Monitoring::exists ; (; TH2F * ; dummy, . std::string ; histoName . ). inline . Definition at line 107 of file Monitoring.h. ◆ GetCanvas(). TCanvas * TM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Monitoring.html:2128,clear,clear,2128,doc/master/classTMVA_1_1Monitoring.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Monitoring.html,1,['clear'],['clear']
Usability,"umns of a Haar -matrix of order order are indeed orthogonal:; const TMatrixD haar = THaarMatrixD(order);; TVectorD colj(1<<order);; TVectorD coll(1<<order);; for (Int_t j = haar.GetColLwb(); j <= haar.GetColUpb(); j++) {; colj = TMatrixDColumn_const(haar,j);; Assert(TMath::Abs(colj*colj-1.0) <= 1.0e-15);. for (Int_t l = j+1; l <= haar.GetColUpb(); l++) {; coll = TMatrixDColumn_const(haar,l);; Assert(TMath::Abs(colj*coll) <= 1.0e-15);; }; }; Multiplying part of a matrix with another part of that matrix (they can overlap); TMatrixDSub(m,1,3,1,3) *= m.GetSub(5,7,5,7);; 14.6 Matrix Decompositions; The linear algebra package offers several classes to assist in matrix decompositions. Each of the decomposition methods performs a set of matrix transformations to facilitate solving a system of linear equations, the formation of inverses as well as the estimation of determinants and condition numbers. More specifically the classes TDecompLU, TDecompBK, TDecompChol, TDecompQRH and TDecompSVD give a simple and consistent interface to the LU, Bunch-Kaufman, Cholesky, QR and SVD decompositions. All of these classes are derived from the base class TDecompBase of which the important methods are listed in next table:. Method; Action. Bool_t Decompose(); perform the matrix decomposition. Double_t Condition(); calculate ||A||1 ||A-1||1, see “Condition number”. void Det(Double_t &d1,Double_t &d2); the determinant is d1 \(2^{d_{2}}\). Expressing the determinant this way makes under/over-flow very unlikely. Bool_t Solve(TVectorD &b); solve Ax=b; vectorb is supplied through the argument and replaced with solution x. TVectorD Solve(const TVectorD &b,Bool_t &ok); solve Ax=b; x is returned. Bool_t Solve(TMatrixDColumn &b); solve Ax=column(B,j);column(B,j) is supplied through the argument and replaced with solution x. Bool_t TransSolve(TVectorD &b); solve \(A^Tx=b;\) vector b is supplied through the argument and replaced with solution x. TVectorD TransSolve(const TVectorD b, Bool_t &ok); solve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:788826,simpl,simple,788826,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"unction / constant. Needs to be overridden by all derived classes. ;  ; double expectedEvents (const RooArgSet *nset) const override;  Return the number of expected events over the full range of all variables. ;  ; ExtendMode extendMode () const override;  Returns ability of PDF to provide extended likelihood terms. ;  ; bool forceAnalyticalInt (const RooAbsArg &) const override;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Forward determination of analytical integration capabilities to input p.d.f. ;  ; TClass * IsA () const override;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;  ; virtual RooAbsGenContext * binnedGenContext (const RooArgSet &vars, bool verbose=false) const;  Return a binned generator context. ;  ; bool canBeExtended () const;  If true, PDF can provide extended likelihood term. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExtendPdf.html:3227,simpl,simple,3227,doc/master/classRooExtendPdf.html,https://root.cern,https://root.cern/doc/master/classRooExtendPdf.html,1,['simpl'],['simple']
Usability,"unction class and of the member function are required only; if running in CINT and they are not need in compiled C++ mode.; See also the tutorial math/exampleFunctor.C for a running example.; . Function Members (Methods); public:. virtual~TF1(); voidTObject::AbstractMethod(const char* method) const; static voidAbsValue(Bool_t reject = kTRUE); virtual voidAddParameter(const TString& name, Double_t value); virtual Bool_tAddToGlobalList(Bool_t on = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static voidCalcGaussLegendreSamplingPoints(Int_t num, Double_t* x, Double_t* w, Double_t eps = 3.0E-11); virtual Double_tCentralMoment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 9.9999999999999995E-7); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& f1) const; virtual TH1*CreateHistogram(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDerivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tDerivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tDerivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; static Double_tDerivativeError(); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TF1*DrawCopy(Option_t* option = """") const; virtual TObject*DrawDerivative(Option_t* option = ""al"")MENU ; virtual voidDrawF1(Double_t xmin, Double_t xmax, Option_t* option = """"); virtual TObject*DrawIntegra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF1.html:5962,Clear,Clear,5962,root/html604/TF1.html,https://root.cern,https://root.cern/root/html604/TF1.html,1,['Clear'],['Clear']
Usability,"unction is virtual, we append ""virtual"" before the return type.; 796 returnType.Prepend(""virtual "");; 797 }; 798 returnType.ReplaceAll("" *"", ""*"");; 799 } else {; 800 // If the function is not inline we only change the spacing in ""returnType""; 801 returnType.ReplaceAll(""*"", "" *"");; 802 }; 803 // In any case (with no respect to virtual/inline check) we need to change; 804 // the return type as following.; 805 // TODO: prepend ""std::"" to all stdlib classes!; 806 returnType.ReplaceAll(""istream"", ""std::istream"");; 807 returnType.ReplaceAll(""ostream"", ""std::ostream"");; 808 returnType.ReplaceAll(""map"", ""std::map"");; 809 returnType.ReplaceAll(""vector"", ""std::vector"");; 810 returnType.ReplaceAll(""&"", "" &"");; 811 return returnType;; 812}; 813} // namespace; 814 ; 815namespace {; 816////////////////////////////////////////////////////////////////////////////////; 817/// The function generates a URL for ""dataMemberName"" defined in ""scopeName"".; 818/// It returns a TString with the URL used in the online reference guide,; 819/// generated with Doxygen. For data members the URL consist of 2 parts -; 820/// URL for ""scopeName"" and a part for ""dataMemberName"".; 821/// For enumerator, the URL could be separated into 3 parts - URL for; 822/// ""scopeName"", part for the enumeration and a part for the enumerator.; 823///; 824/// \param[in] scopeName the name of the class/namespace/struct; 825/// \param[in] dataMemberName the name of the data member/enumerator; 826/// \param[in] dataMember pointer to the data member/enumerator; 827/// \param[in] scopeType enumerator to the scope type; 828 ; 829static TString; 830GetUrlForDataMember(const TString &scopeName, const TString &dataMemberName, TDataMember *dataMember, EUrl scopeType); 831{; 832 // We first check if the data member is not enumerator.; 833 if (!dataMember->IsEnum()) {; 834 // If we work with data members, we have to append a hashed with MD5 text, consisting of:; 835 // ""Type ClassName::DataMemberNameDataMemberName(arguments)"".; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:29868,guid,guide,29868,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['guid'],['guide']
Usability,"unction, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:77357,clear,clearEvalError,77357,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,12,"['Clear', 'clear']","['Clear', 'clearEvalError']"
Usability,"unctions |; Variables ; ROOT::Fit Namespace ReferenceMath » MathCore » Fitting and Parameter Estimation. Namespace for the fitting classes. ; More... Namespaces; namespace  FitUtil;  namespace defining utility free functions using in Fit for evaluating the various fit method functions (chi2, likelihood, etc..) given the data and the model function ;  ; namespace  HFitInterface;  . Classes; class  AreaComparer;  ; class  BasicFCN;  BasicFCN class: base class for the objective functions used in the fits It has a reference to the data and the model function used in the fit. More...;  ; class  BinData;  Class describing the binned data sets : vectors of x coordinates, y values and optionally error on y values and error on coordinates The dimension of the coordinate is free There are 4 different options: More...;  ; class  Box;  ; class  BoxContainer;  ; class  Chi2FCN;  Chi2FCN class for binned fits using the least square methods. More...;  ; struct  DataOptions;  DataOptions : simple structure holding the options on how the data are filled. More...;  ; class  DataRange;  class describing the range in the coordinates it supports multiple range in a coordinate. More...;  ; class  FcnAdapter;  ; class  FitConfig;  Class describing the configuration of the fit, options and parameter settings using the ROOT::Fit::ParameterSettings class. More...;  ; class  FitData;  Base class for all the fit data types: Stores the coordinates and the DataOptions. More...;  ; class  FitResult;  class containing the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values. More...;  ; class  Fitter;  Fitter class, entry point for performing all type of fits. More...;  ; class  LogLikelihoodFCN;  LogLikelihoodFCN class for likelihood fits. More...;  ; struct  ObjFuncTrait;  ; struct  ObjFuncTrait< ROOT::Math::FitMethodFunct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Fit.html:1163,simpl,simple,1163,doc/master/namespaceROOT_1_1Fit.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Fit.html,2,['simpl'],['simple']
Usability,"und()); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidCreateDisabledPicture(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; TStringGetTypeString() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGSlider&operator=(const TGSlider&); TGSlider(const TGSlider&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditModeTGWindow::kEditDisableEvents; static TGWindow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGSlider.html:15131,Clear,ClearFlags,15131,root/html602/TGSlider.html,https://root.cern,https://root.cern/root/html602/TGSlider.html,2,['Clear'],['ClearFlags']
Usability,"undaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooResolutionModel.html:4480,clear,clearShapeDirty,4480,root/html532/RooResolutionModel.html,https://root.cern,https://root.cern/root/html532/RooResolutionModel.html,2,['clear'],['clearShapeDirty']
Usability,"unexpectedly. The objects which can be used to minimize are:; 6.1.1 \(\mbox{MIGRAD}\); This is the best minimizer for nearly all functions. It is a variable-metric method with inexact line search, a stable metric updating scheme, and checks for positive-definiteness. It will run faster if you instantiate it with a low–level MnStrategy and will be more reliable if you instantiate it with a high–level MnStrategy (although the latter option may not help much). Its main weakness is that it depends heavily on knowledge of the first derivatives, and fails miserably if they are very inaccurate. If first derivatives are a problem, they can be calculated analytically inside \(\mbox{FCN}\) (see [howto:fcn]) or if this is not feasible, the user can try to improve the accuracy of M ’s numerical approximation by adjusting values of MnMachinePrecision and/or MnStrategy (see [api:epsmac] and [api:strategy]).; 6.1.2 \(\mbox{MINIMIZE}\); This is equivalent to \(\mbox{MIGRAD}\), except that if \(\mbox{MIGRAD}\) fails, it reverts to \(\mbox{SIMPLEX}\) and then calls \(\mbox{MIGRAD}\) again.; 6.1.3 \(\mbox{SCAN}\); This is not intended to minimize, and just scans the function, one parameter at a time. It does however retain the best value after each scan, so it does some sort of highly primitive minimization.; 6.1.4 \(\mbox{SIMPLEX}\); This genuine multidimensional minimization routine is usually much slower than \(\mbox{MIGRAD}\), but it does not use first derivatives, so it should not be so sensitive to the precision of the \(\mbox{FCN}\) calculations, and is even rather robust with respect to gross fluctuations in the function value. However, it gives no reliable information about parameter errors, no information whatsoever about parameter correlations, and worst of all cannot be expected to converge accurately to the minimum in a finite time. Its estimate of the expected distance to the minimum \(\mbox{EDM}\) is largely fantasy, so it would not even know if it did converge.; 6.2 Fl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:67011,SIMPL,SIMPLEX,67011,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['SIMPL'],['SIMPLEX']
Usability,"unfold distributions from detector to truth level. ; TUnfold is used to decompose a measurement y into several sources x, given the measurement uncertainties and a matrix of migrations A. The method can be applied to a large number of problems, where the measured distribution y is a linear superposition of several Monte Carlo shapes. Beyond such a simple template fit, TUnfold has an adjustable regularisation term and also supports an optional constraint on the total number of events.; For most applications, it is better to use the derived class TUnfoldDensity instead of TUnfold. TUnfoldDensity adds various features to TUnfold, such as: background subtraction, propagation of systematic uncertainties, complex multidimensional arrangements of the bins. For innocent users, the most notable improvement of TUnfoldDensity over TUnfold are the getter functions. For TUnfold, histograms have to be booked by the user and the getter functions fill the histogram bins. TUnfoldDensity simply returns a new, already filled histogram.; If you use this software, please consider the following citation ; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201] ; Detailed documentation and updates are available on http://www.desy.de/~sschmitt; Brief recipy to use TUnfold: . a matrix (truth,reconstructed) is given as a two-dimensional histogram as argument to the constructor of TUnfold . a vector of measurements is given as one-dimensional histogram using the SetInput() method . The unfolding is performed . either once with a fixed parameter tau, method DoUnfold(tau) . or multiple times in a scan to determine the best chouce of tau, method ScanLCurve() . Unfolding results are retrieved using various GetXXX() methods . Basic formulae:; χ2A=(Ax-y)TVyy-1(Ax-y); χ2L=(x-f*x0)TLTL(x-f*x0); χ2unf=χ2A+τ2χ2L+λΣi(Ax-y)i; x:result, A:probabilities, y:data, Vyy:data covariance, f:bias scale, x0:bias, L:regularisation conditions, τ:regularisation strength, λ:Lagrangian multiplier; Without area constraint, λ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:1405,simpl,simply,1405,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,1,['simpl'],['simply']
Usability,"unk. The core library (libCore.so) contains the essentials; it is a part of all ROOT applications. In the Figure 1-2 you see that libCore.so is made up of base classes, container classes, meta information classes, operating system specific classes, and the ZIP algorithm used for compression of the ROOT files.; The Cling library (libCling.so) is also needed in all ROOT applications, and even by libCore. A program referencing only TObject only needs libCore; libCling will be opened automatically. To add the ability to read and write ROOT objects one also has to load libRIO. As one would expect, none of that depends on graphics or the GUI.; Library dependencies have different consequences; depending on whether you try to build a binary, or you just try to access a class that is defined in a library.; 1.6.2.2 Linktime Library Dependencies; When building your own executable you will have to link against the libraries that contain the classes you use. The ROOT reference guide states the library a class is reference guide defined in. Almost all relevant classes can be found in libraries returned by root-config -glibs; the graphics libraries are retuned by root-config --libs. These commands are commonly used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly link",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:21655,guid,guide,21655,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,['guid'],['guide']
Usability,"unts, const char* prefix = """", Bool_t colourfulOutput = kTRUE); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMVA::MsgLogger&Log() const; TStringSecToText(Double_t, Bool_t) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Bool_tfColourfulOutputflag for use of colors; TMVA::MsgLogger*fLoggerthe output logger; Int_tfNcountsreference number of ""counts"" ; TStringfPrefixprefix for outputs; static const TStringfgClassNameused for output; static const Int_tfgNbinsnumber of bins in progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE); constructor. Timer(Int_t ncounts, const char* prefix = """", Bool_t colourfulOutput = kTRUE); standard constructor: ncounts gives the total number of counts that; the loop will iterate through. At each call of the timer, the current; number of counts is provided by the user, so that the timer can obtain; the due time from linearly interpolating the spent time. ~Timer( void ); destructor. void Init(Int_t ncounts); timer initialisation. void Reset( void ); resets timer. Double_t ElapsedSeconds( void ); computes elapsed tim in seconds. TString GetElapsedTime(Bool_t Scientific = kTRUE); returns pretty string with elaplsed time. TString GetLeftTime(Int_t icounts); returns pretty string with time left. void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__Timer.html:6564,progress bar,progress bar,6564,root/html528/TMVA__Timer.html,https://root.cern,https://root.cern/root/html528/TMVA__Timer.html,6,['progress bar'],['progress bar']
Usability,"up . Definition at line 7150 of file TSpectrum2Painter.cxx. ◆ SetColorIncrements(). void TSpectrum2Painter::SetColorIncrements ; (; Double_t ; r, . Double_t ; g, . Double_t ; b . ). Sets color increments between two color levels for r, g, b components: . r, g, b - color increments between two color levels . Definition at line 7162 of file TSpectrum2Painter.cxx. ◆ SetContourWidth(). void TSpectrum2Painter::SetContourWidth ; (; Int_t ; width). Sets width between horizontal slices: . width - width between contours, applies only for contours display mode . Definition at line 7218 of file TSpectrum2Painter.cxx. ◆ SetDisplayMode(). void TSpectrum2Painter::SetDisplayMode ; (; Int_t ; modeGroup, . Int_t ; displayMode . ). Sets display group mode and display mode: . modeGroup - the following group modes can be set: simple modes-kPicture2ModeGroupSimple, modes with shading according to light-kPicture2ModeGroupLight, modes with shading according to channels counts-kPicture2ModeGroupHeight, modes of combination of shading according to light and to channels counts-kPicture2ModeGroupLightHeight; displayMode - posible display modes are: points, grid, contours, bars, x_lines, y_lines, bars_x, bars_y, needles, surface, triangles . Definition at line 7071 of file TSpectrum2Painter.cxx. ◆ SetLightHeightWeight(). void TSpectrum2Painter::SetLightHeightWeight ; (; Double_t ; weight). Sets weight between shading according to fictive light source and according to channels counts: . weight - weight between shading according to fictive light source and according to channels counts, applies only for kPicture2ModeGroupLightHeight modes group . Definition at line 7228 of file TSpectrum2Painter.cxx. ◆ SetLightPosition(). void TSpectrum2Painter::SetLightPosition ; (; Int_t ; x, . Int_t ; y, . Int_t ; z . ). Sets position of fictive light source in 3D space: . x, y, z . Definition at line 7176 of file TSpectrum2Painter.cxx. ◆ SetNodes(). void TSpectrum2Painter::SetNodes ; (; Int_t ; nodesx, . Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Painter.html:54037,simpl,simple,54037,doc/master/classTSpectrum2Painter.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Painter.html,1,['simpl'],['simple']
Usability,"up Combobox popup window; TGCommandPlugin Command (I/O redirection) plugin for the new ROOT Browser; TGCompositeFrame Base class for composite widgets (menubars, etc.); TGContainer Canvas container; TGDMLParse imports GDML using DOM and binds it to ROOT; TGDMLRefl helper class used for the storage of reflected solids; TGDNDManager The main Drag and Drop Manager; TGDimension Dimension object (width, height); TGDockButton Dock button; TGDockHideButton Hide dock button; TGDockableFrame Dockable widget; TGDoubleHSlider Horizontal double slider widget; TGDoubleSlider Double slider widget abstract base class; TGDoubleVSlider Vertical double slider widget; TGDragWindow Window used for dragging; TGEventHandler Abstract event handler; TGFSComboBox Combo box widget for file system path; TGFileBrowser File browser.; TGFileContainer Container containing file system objects; TGFileDialog File selection dialog; TGFileInfo ; TGFileItem Class representing file system object; TGFont GUI font description; TGFontDialog Font selection dialog; TGFontDialog::FontProp_t ; TGFontPool Font pool; TGFontTypeComboBox Font type combobox widget; TGFrame Base class for simple widgets (button, etc.); TGFrameElement Base class used in GUI containers; TGFrameElementPack Class used in TGPack.; TGGC Graphics context; TGGCPool Graphics context pool; TGGotoDialog Goto line dialog used by TGTextEdit widget; TGGroupFrame A composite frame with border and title; TGHButtonGroup A button group with one horizontal row; TGHProgressBar Horizontal progress bar widget; TGHScrollBar Horizontal scrollbar widget; TGHSlider Horizontal slider widget; TGHSplitter A horizontal frame splitter; TGHeaderFrame Header frame with buttons and splitters; TGHorizontal3DLine A horizontal 3D separator line; TGHorizontalFrame Composite frame with horizontal child layout; TGHorizontalLayout Horizontal layout manager; TGHotString Graphics string with hot character; TGHtml HTML widget; TGHtmlBrowser very simple html browser; TGIcon Ic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:69347,simpl,simple,69347,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,4,['simpl'],['simple']
Usability,"up, display mode = surface, 64 x 64 channels. Light modes group, display mode = triangles, 64 x 64 channels. Height modes group, display mode = points, 256 x 256 channels. Height modes group, display mode = grid, 256 x 256 channels. Height modes group, display mode = contours, 64 x 64 channels. Height modes group, display mode = bars, 64 x 64 channels. Height modes group, display mode = surface, 64 x 64 channels. Height modes group, display mode = triangles, 64 x 64 channels. Light - height modes group, display mode = surface, 64 x 64 channels. The weight; between both shading algorithms is set to 0.5. One can observe the influence of; both shadings.; Function:; TSpectrum2Painter::SetPenAttr(Int_t color,Int_t style,Int_t width). Using this function one can change pen color, pen style and pen width.; Possible pen styles are:. kPenStyleSolid,; kPenStyleDash,; kPenStyleDot,; kPenStyleDashDot. Default values:. color = kBlack; style = kPenStyleSolid; width = 1. Simple modes group, display mode = linesX, 64 x 64 channels. Pen width = 3.; Function:; TSpectrum2Painter::SetNodes(Int_t nodesx,Int_t nodesy); Sometimes the displayed region is rather large. When displaying all channels; pictures become very dense and complicated. It is very difficult to understand; overall shape of the data. Therefore in the package we have implemented the; possibility to change the density of displayed channels. Only channels; coinciding with given nodes are displayed. In the next figure we introduce the; example of the above presented spectrum with number of nodes set to 64x64.; Default values:. nodesx = Xmax-Xmin+1; nodesy = Ymax-Ymin+1. Simple modes group, display mode = grid, 256 x 256 channels.; Number of nodes is 64x64.; Function:; void TSpectrum2Painter::SetAngles (Int_t alpha,Int_t beta, Int_t view); One can change the angles of the position of 3-d space and to rotate the; space. Alpha parameter defines the angle between bottom horizontal screen line; and the displayed space on the right",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSpectrum2Painter.html:19549,Simpl,Simple,19549,root/html532/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html532/TSpectrum2Painter.html,4,['Simpl'],['Simple']
Usability,"uple.Draw(""x"",cut1+cut2+cut3);. Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Draw expression varexp for specified entries.; Returns -1 in case of error or number of selected events in case of success. varexp is an expression of the general form; - ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; - ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1""; on the y-axis versus ""e2"" on the x-axis; - ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" on the x-, y-, z-axis, respectively.; - ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" and ""e4"" mapped on the color number.; (to create histograms in the 2, 3, and 4 dimensional case, see section ""Saving; the result of Draw to an histogram""). Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim distribution of y versus sqrt(x); = px:py:pz:2.5*E produces a 3-d scatter-plot of px vs py ps pz; and the color number of each marker will be 2.5*E.; If the color number is negative it is set to 0.; If the color number is greater than the current number of colors; it is set to the highest color number.; The default number of colors is 50.; see TStyle::SetPalette for setting a new color palette. Note that the variables e1, e2 or e3 may contain a selection.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. The expressions can use all the operations and build-in functions; supported by TFormula (See TFormula::Analyze), including free; standing function taking numerical arguments (TMath::Bessel).; In addition, you can call member functions taking numerical; arguments. For example:; - ""TMath::BreitWigner(fPx,3,2)""; - ""event.GetHistogram().GetXaxis().GetXmax()""; Note: You can only pass expression th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:67774,simpl,simplest,67774,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,6,['simpl'],['simplest']
Usability,"ural networks ;  CMethodBaseVirtual base Class for all MVA method ;  CMethodBayesClassifierDescription of bayesian classifiers ;  CMethodBDTAnalysis of Boosted Decision Trees ;  CMethodBoostClass for boosting a TMVA method ;  CMethodC50;  CMethodCategoryClass for categorizing the phase space ;  CMethodCFMlpANNInterface to Clermond-Ferrand artificial neural network ;  ►CMethodCFMlpANN_UtilsImplementation of Clermond-Ferrand artificial neural network ;  CVARn2;  CMethodCompositeBaseVirtual base class for combining several TMVA method ;  CMethodCutsMultivariate optimisation of signal efficiency for given background efficiency, applying rectangular minimum and maximum requirements ;  ►CMethodDNNDeep Neural Network Implementation ;  CTTrainingSettings;  CMethodDTAnalysis of Boosted Decision Trees ;  CMethodFDAFunction discriminant analysis (FDA) ;  CMethodFisherFisher and Mahalanobis Discriminants (Linear Discriminant Analysis) ;  CMethodHMatrixH-Matrix method, which is implemented as a simple comparison of chi-squared estimators for signal and background, taking into account the linear correlations between the input variables ;  CMethodInfo;  CMethodKNNAnalysis of k-nearest neighbor ;  CMethodLDLinear Discriminant ;  CMethodLikelihoodLikelihood analysis (""non-parametric approach"") ;  CMethodMLPMultilayer Perceptron class built off of MethodANNBase ;  CMethodPDEFoamThe PDEFoam method is an extension of the PDERS method, which divides the multi-dimensional phase space in a finite number of hyper-rectangles (cells) of constant event density ;  CMethodPDERSThis is a generalization of the above Likelihood methods to \( N_{var} \) dimensions, where \( N_{var} \) is the number of input variables used in the MVA ;  CMethodPyAdaBoost;  CMethodPyGTB;  CMethodPyKeras;  CMethodPyRandomForest;  CMethodRSNNS;  CMethodRSVM;  CMethodRuleFitJ Friedman's RuleFit method ;  CMethodRXGB;  CMethodSVMSMO Platt's SVM classifier with Keerthi & Shavade improvements ;  CMethodTMlpANNThis is the TM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:73418,simpl,simple,73418,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,2,['simpl'],['simple']
Usability,"uralNet.h:855; TMVA::DNN::Settings::addPointvoid addPoint(std::string histoName, double x, double y)for monitoringDefinition NeuralNet.h:822; TMVA::DNN::Settings::setMonitoringvoid setMonitoring(std::shared_ptr< Monitoring > ptrMonitoring)prepared for monitoringDefinition NeuralNet.h:764; TMVA::DNN::Settings::testIterationvirtual void testIteration()callback for monitoring and logggingDefinition NeuralNet.h:806; TMVA::DNN::Settings::m_convergenceStepssize_t m_convergenceStepsnumber of steps without improvement to consider the DNN to have convergedDefinition NeuralNet.h:837; TMVA::DNN::Settings::hasConvergedvirtual bool hasConverged(double testError)has this training converged already?Definition NeuralNet.cxx:485; TMVA::DNN::Settings::minimizerTypeMinimizerType minimizerType() constwhich minimizer shall be used (e.g. SGD)Definition NeuralNet.h:774; TMVA::DNN::Settings::m_dropOutstd::vector< double > m_dropOutDefinition NeuralNet.h:850; TMVA::DNN::Settings::m_minProgressdouble m_minProgresscurrent limits for the progress barDefinition NeuralNet.h:833; TMVA::DNN::Settings::cyclevirtual void cycle(double progress, TString text)Definition NeuralNet.h:799; TMVA::DNN::Settings::setProgressLimitsvirtual void setProgressLimits(double minProgress=0, double maxProgress=100)Definition NeuralNet.h:790; TMVA::DNN::Settings::m_maxProgressdouble m_maxProgresscurrent limits for the progress barDefinition NeuralNet.h:834; TMVA::DNN::Settings::endTrainCyclevirtual void endTrainCycle(double)callback for monitoring and loggingDefinition NeuralNet.h:788; TMVA::DNN::Settings::count_dEsize_t count_dEDefinition NeuralNet.h:843; TMVA::DNN::Settings::drawSamplevirtual void drawSample(const std::vector< double > &, const std::vector< double > &, const std::vector< double > &, double)callback for monitoring and loggingDefinition NeuralNet.h:807; TMVA::DNN::Settings::learningRatedouble learningRate() constget the learning rateDefinition NeuralNet.h:771; TMVA::DNN::Settings::m_dropRepetitionsdoubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:73749,progress bar,progress barDefinition,73749,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['progress bar'],['progress barDefinition']
Usability,"urce file and save it where you can find it: EventDataSelector.C (or wget http://root-mirror.github.io/training/intro/EventDataSelector.C).; This selector contains all the necessary steps to read the data from the tree branches, like the number of particles, the X position of each particle PosX[nparticles], and the absolute momentum of each particle Momentum[nparticles].; Now quit and restart ROOT (to make sure everybody starts from the same point). Then open the file again:; root[0] TFile::Open(""http://root.cern/files/introtutorials/eventdata.root"");. Adding a Data Member; Just like for the sum of event sizes, you need to add a data member to the class. As in Histogramming, we want to histogram the particles' fPosX; the type of the data member should thus be TH1F*. Don't forget to initialize the histogram pointer to 0 in the constructor, again just like for the event size sum.; Creating the Histogram; You then create the object with new TH1F(""hPosX"", ""Position in X"", 20, -5, 5);; check the documentation of TSelector to learn in which of your selector's functions to create the histogram object.; Associate error bars with this histogram (see TH1F::Sumw2()); Filling the Histogram; Like in the Histogramming chapter, fill the histogram with the value of fPosX from the tree for all particles with a momentum > 40.; Just like before, the per-event analysis happens in Process(). Here again, you need to get the tree entry before you can access the corresponding data members of your selector.; Fitting and Drawing the Histogram; Here again, once the histogram is filled, fit it with a pol2 using TH1::Fit(""pol2"").; See the documentation of TSelector on where to do the fitting, i.e. which function of your selector gets called after the whole tree has been processed. You should first fit and then draw, to see the fit together with the histogram.; At the end, you should get the same result than the figure 6 in Histogramming; If, for any reason, you don't manage to get it working, yo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/histogramming-selector.html:3119,learn,learn,3119,d/histogramming-selector.html,https://root.cern,https://root.cern/d/histogramming-selector.html,1,['learn'],['learn']
Usability,"urceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidSetVertical(Bool_t x = kTRUE); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector& insp); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveWindowPack.html:17218,Undo,UndockWindow,17218,root/html532/TEveWindowPack.html,https://root.cern,https://root.cern/root/html532/TEveWindowPack.html,2,['Undo'],"['UndockWindow', 'UndockWindowDestroySlot']"
Usability,"ure) ; Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 1339 of file TVirtualX.cxx. ◆ ChangeProperties(). void TVirtualX::ChangeProperties ; (; Window_t ; id, . Atom_t ; property, . Atom_t ; type, . Int_t ; format, . UChar_t * ; data, . Int_t ; len . ). virtual . Alters the property for the specified window and causes the X server to generate a PropertyNotify event on that window. ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 2448 of file TVirtualX.cxx. ◆ ChangeProperty(). void TVirtualX::ChangeProperty ; (; Window_t ; id, . Atom_t ; property, . Atom_t ; type, . UChar_t * ; data, . Int_t ; len . ). virtual . Alters the property for the specified window and causes the X server to generate a PropertyNotify event on that window. ; Parameters. [in]idthe window whose property you want to change ; [in]propertyspecifies the property name ; [in]typethe type of the property; the X server does not interpret the type but simply passes it back to an application that might ask about the window properties ; [in]datathe property data ; [in]lenthe length of the specified data format . Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1572 of file TVirtualX.cxx. ◆ ChangeWindowAttributes(). void TVirtualX::ChangeWindowAttributes ; (; Window_t ; id, . SetWindowAttributes_t * ; attr . ). virtual . Changes the attributes of the specified window ""id"" according the values provided in ""attr"". ; The mask data member of ""attr"" specifies which window attributes are defined in the attributes argument. This mask is the bitwise inclusive OR of the valid attribute mask bits; if it is zero, the attributes are ignored. ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1554 of file TVirtualX.cxx. ◆ CheckEvent(). Bool_t TVirtualX::CheckEvent ; (; Window_t ; id, . EGEventType ; type, . Event_t & ; ev . ). virtual . Check if there is for window",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:53045,simpl,simply,53045,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['simpl'],['simply']
Usability,"urns kTRUE you can make repeated calls to AddObject(), with TBuffer3D containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers to the properties of logical object, with the fLocalMaster transform and the fColor and fTransparency attributes, which can be varied for each physical object.; As a minimum requirement all clients must be capable of filling the raw tessellation of the object buffer, in the master reference frame. Conversely viewers must always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; it may for various reasons decide to ignore it:; It already has the object internally cached .; The object falls outside some 'interest' limits of the viewer camera.; The object is too small to be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition, simply indicating it does not require you to provide further information about this object. You should not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially millions of objects, and only accept those that are of interest at a certain time, caching the relatively small number of CPU/memory costly logical shapes, and retaining/discarding the physical placements as required. The viewer may decide to force the client to rebuild (republish) the scene (via a TPad repaint at present), and thus collect these objects if the internal viewer state changes. It does this presently by forcing a repaint on the attached TPad object - hence the reason for putting all publishing to the viewer in the attached pad objects Paint() method. We will likely remove this requirement in the future, indicating the rebuild request via a normal ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for tw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer3D.html:7120,simpl,simply,7120,doc/master/classTBuffer3D.html,https://root.cern,https://root.cern/doc/master/classTBuffer3D.html,2,['simpl'],['simply']
Usability,"uron, separated by comas. Hidden layers are just described; by the number of neurons. The layers are separated by colons.; In addition, input/output layer formulas can be preceded by '@' (e.g ""@out""); if one wants to also normalize the data from the TTree.; Input and outputs are taken from the TTree given as second argument.; Expressions are evaluated as for TTree::Draw(), arrays are expended in; distinct neurons, one for each index.; This can only be done for fixed-size arrays.; If the formula ends with ""!"", softmax functions are used for the output layer.; One defines the training and test datasets by TEventLists. Example:; TMultiLayerPerceptron(""x,y:10:5:f"",inputTree);; Both the TTree and the TEventLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitely, or via; a string containing the formula to be used to define them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :; TMultiLayerPerceptron::kStochastic, ; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS; A weight can be assigned to events, either in the constructor, either; with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; are available. . Example:; net.Train(100,""text, graph, update=10"").; When the neural net is trained, it can be used; directly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:7359,learn,learning,7359,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,4,['learn'],['learning']
Usability,"ursiveFraction.h. ◆ evaluate(). double RooRecursiveFraction::evaluate ; (; ); const. overrideprotectedvirtual . Calculate and return value of \( a_n * \prod_{i=0}^{n-1} (1 - a_i) \). ; Implements RooAbsReal.; Definition at line 77 of file RooRecursiveFraction.cxx. ◆ IsA(). TClass * RooRecursiveFraction::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsReal.; Definition at line 42 of file RooRecursiveFraction.h. ◆ Streamer(). void RooRecursiveFraction::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooRecursiveFraction::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 42 of file RooRecursiveFraction.h. ◆ translate(). void RooRecursiveFraction::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 91 of file RooRecursiveFraction.cxx. Member Data Documentation. ◆ _list. RooListProxy RooRecursiveFraction::_list. protected . Definition at line 38 of file RooRecursiveFraction.h. Libraries for RooRecursiveFraction:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooRecursiveFraction.h; roofit/roofitcore/src/RooRecursiveFraction.cxx. RooRecursiveFraction. ROOT master ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRecursiveFraction.html:62578,simpl,simple,62578,doc/master/classRooRecursiveFraction.html,https://root.cern,https://root.cern/doc/master/classRooRecursiveFraction.html,1,['simpl'],['simple']
Usability,"us& st); TProofProgressStatus&operator=(const TProofProgressStatus&); TProofProgressStatus&operator=(TProofProgressStatus&&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBytesRead(Long64_t bytesRead); voidSetCPUTime(Double_t procTime); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEntries(Long64_t entries); voidSetLastEntries(Long64_t entries); voidSetLastProcTime(Double_t procTime); voidSetLastUpdate(Double_t updtTime = 0); voidSetLearnTime(Double_t learnTime); static voidTObject::SetObjectStat(Bool_t stat); voidSetProcTime(Double_t procTime); voidSetReadCalls(Long64_t readCalls); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TProofProgressStatus(TProofProgressStatus&&); TProofProgressStatus(const TProofProgressStatus&); TProofProgressStatus(Long64_t fEntries = 0, Long64_t fBytesRead = 0, Long64_t fReadCalls = 0, Double_t fProcTime = 0, Double_t fCPUTime = 0); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofProgressStatus.html:4978,learn,learnTime,4978,root/html602/TProofProgressStatus.html,https://root.cern,https://root.cern/root/html602/TProofProgressStatus.html,4,['learn'],['learnTime']
Usability,"us(); in case of success. Bool_t JoinProcess(TList* workers); Not implemented: meaningful only in the remote player. Returns kFALSE. Bool_t CheckMemUsage(Long64_t& mfreq, Bool_t& w80r, Bool_t& w80v, TString& wmsg); Check the memory usage, if requested.; Return kTRUE if OK, kFALSE if above 95% of at least one between virtual or; resident limits are depassed. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); Finalize query (may not be used in this class). Long64_t Finalize(TQueryResult* qr); Finalize query (may not be used in this class). void MergeOutput(); Merge output (may not be used in this class). void MapOutputListToDataMembers() const. void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); Update automatic binning parameters for given object ""name"". TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet (may not be used in this class). void SetupFeedback(); Set up feedback (may not be used in this class). void StopFeedback(); Stop feedback (may not be used in this class). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (may not be used in this class). void HandleGetTreeHeader(TMessage* mess); Handle tree header request. void HandleRecvHisto(TMessage* mess); Receive histo from slave. Int_t DrawCanvas(TObject* obj); Draw the object if it is a canvas.; Return 0 in case of success, 1 if it is not a canvas or libProofDraw; is not available. Int_t GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); Parse the arguments from var, sel and opt and fill the selector and; object name accordingly.; Return 0 in case of success, 1 if libProofDraw is not available. void FeedBackCanvas(const char* name, Bool_t create); Create/destroy a named canvas for feedback. Long64_t GetCacheSize(); Return the size in bytes of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayer.html:21583,feedback,feedback,21583,root/html602/TProofPlayer.html,https://root.cern,https://root.cern/root/html602/TProofPlayer.html,2,['feedback'],['feedback']
Usability,"us)TObject::kSingleKey; static TCondor::EStatekSuspended; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char* pool = """"); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char* cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char* vmname, const char* cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetState(TCondor::EState state); Set the state of workers. Bool_t Suspend(); Suspend worker. Bool_t Resume(); Resume worker. Bool_t Release(); Release worker. Bool_t GetVmInfo(const char* vm, TString& image, Int_t& perfidx) const; Get info about worker status. TString GetImage(const char* host) const; Get image of the worker. TCondor(const char* pool = """"). Bool_t IsValid() const; { return fValid; }. EState GetState() const; {return fState;}. » Author: Maarten Ballintijn 06/12/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-02 15:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TCondor.html:7424,Resume,Resume,7424,root/html604/TCondor.html,https://root.cern,https://root.cern/root/html604/TCondor.html,2,['Resume'],['Resume']
Usability,"us)TObject::kSingleKey; static TCondor::EStatekSuspended; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char* pool = """"); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char* cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char* vmname, const char* cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetState(TCondor::EState state); Set the state of workers. Bool_t Suspend(); Suspend worker. Bool_t Resume(); Resume worker. Bool_t Release(); Release worker. Bool_t GetVmInfo(const char* vm, TString& image, Int_t& perfidx) const; Get info about worker status. TString GetImage(const char* host) const; Get image of the worker. TCondor(const char* pool = """"). Bool_t IsValid() const; { return fValid; }. EState GetState() const; {return fState;}. » Author: Maarten Ballintijn 06/12/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCondor.html:7424,Resume,Resume,7424,root/html602/TCondor.html,https://root.cern,https://root.cern/root/html602/TCondor.html,2,['Resume'],['Resume']
Usability,"us; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TGTab * GetTab() const; { return fTab; }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSessionQueryFrame.html:21181,progress bar,progress bar,21181,root/html528/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html,2,['progress bar'],['progress bar']
Usability,"us; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update query information (header) text view. TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSessionQueryFrame.html:21456,progress bar,progress bar,21456,root/html532/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html532/TSessionQueryFrame.html,2,['progress bar'],['progress bar']
Usability,"use the function range when creating the fit data (default is false); 52 bool fErrors1; ///< use all errors equal to 1, i.e. fit without errors (default is false); 53 bool fExpErrors; ///< use expected errors from the function and not from the data; 54 bool fCoordErrors; ///< use errors on the x coordinates when available (default is true); 55 bool fAsymErrors; ///< use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); 56 ; 57 ; 58};; 59 ; 60 } // end namespace Fit; 61 ; 62} // end namespace ROOT; 63 ; 64 ; 65#endif /* ROOT_Fit_DataOptions */; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::Fit::DataOptionsDataOptions : simple structure holding the options on how the data are filled.Definition DataOptions.h:28; ROOT::Fit::DataOptions::fErrors1bool fErrors1use all errors equal to 1, i.e. fit without errors (default is false)Definition DataOptions.h:52; ROOT::Fit::DataOptions::fAsymErrorsbool fAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residua...Definition DataOptions.h:55; ROOT::Fit::DataOptions::fNormBinVolumebool fNormBinVolumenormalize data by a normalized the bin volume (bin volume divided by a reference value)Definition DataOptions.h:49; ROOT::Fit::DataOptions::fUseRangebool fUseRangeuse the function range when creating the fit data (default is false)Definition DataOptions.h:51; ROOT::Fit::DataOptions::fUseEmptybool fUseEmptyuse empty bins (default is false) with a fixed error of 1Definition DataOptions.h:50; ROOT::Fit::DataOptions::fIntegralbool fIntegraluse integral of bin content instead of bin center (default is false)Definition DataOptions.h:4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataOptions_8h_source.html:2642,simpl,simple,2642,doc/master/DataOptions_8h_source.html,https://root.cern,https://root.cern/doc/master/DataOptions_8h_source.html,1,['simpl'],['simple']
Usability,"ush origin vX-YY-ZZ. Tag ROOTTEST repository. Artifacts. Produce binary tarfiles. start the procedure root-release-6.20 (or whichever branch) in Jenkins; tarfiles and other artifacts are copied to final destination. Install binaries to CVMFS. Install release binaries to CVMFS with the Jenkins procedure root-release-CVMFS. Documentation. Update the release pages. Generate the release notes with the Jenkins procedure called root-releasenotes; Update the releases xml with the Jenkins procedure called root-release-makeReleasesXml; Once authenticated, import the releases xml in the site clicking import here (Be reminded: this works for authenticated users only!).; Eventually edit the 'highlights' section, which is currently commented, in the generated release page.; If this applies, mark the release as Pro or Old and remove the attribute to the one previously holding it. There are radio buttons exposed by Drupal when editing a release's page.; If not a patch release edit reference-guide page to add the new reference guide for the release. Announcements. send mail to the following mailing lists: root-planning@cern.ch, root-dev@cern.ch, roottalk@cern.ch, root-godparents@cern.ch, root-ambassadors@cern.ch; write announcement in RootTalk forum news. Quick Links; Jenkins Service; Jenkins How To; CDash; Coverity; Github; GitWeb; LXR; Jira; Conventions Violations; ROOT Logos; Upgrade of ROOTbinder. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxyge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/release-checklist.html:4303,guid,guide,4303,d/release-checklist.html,https://root.cern,https://root.cern/d/release-checklist.html,2,['guid'],['guide']
Usability,"ush_back(region);; 5522 }; 5523 ; 5524 } else {; 5525 ; 5526 // loop over pixels; 5527 ; 5528 Double_t beta = (TMath::Log10(xMax) - TMath::Log10(xMin))/(nPixels-1.0);; 5529 ; 5530 for (Int_t pixelIndex=0; pixelIndex<(nPixels-1); pixelIndex++) {; 5531 // linear plot; 5532 Int_t binLow = pAxis->FindBin(xMin*TMath::Power(10.0, beta*pixelIndex));; 5533 Int_t binHigh = pAxis->FindBin(xMin*TMath::Power(10.0, beta*(pixelIndex+1)));; 5534 THistRenderingRegion region = { std::make_pair(pixelIndex, pixelIndex+1),; 5535 std::make_pair(binLow, binHigh)};; 5536 regions.push_back(region);; 5537 }; 5538 }; 5539 } else {; 5540 // standard linear plot; 5541 ; 5542 if (strategy == Bins) {; 5543 // loop over bins; 5544 for (Int_t bin=pAxis->GetFirst(); bin<=pAxis->GetLast(); bin++) {; 5545 ; 5546 // linear plot. we simply need to find the appropriate bin; 5547 // for the; 5548 Int_t xPx0 = ((bin - pAxis->GetFirst()) * nPixels)/nBins;; 5549 Int_t xPx1 = xPx0 + nPixels/nBins;; 5550 ; 5551 // make sure we don't compute beyond our bounds; 5552 if (xPx1>= nPixels) xPx1 = nPixels-1;; 5553 ; 5554 THistRenderingRegion region = {std::make_pair(xPx0, xPx1),; 5555 std::make_pair(bin, bin+1)};; 5556 regions.push_back(region);; 5557 }; 5558 } else {; 5559 // loop over pixels; 5560 for (Int_t pixelIndex=0; pixelIndex<nPixels-1; pixelIndex++) {; 5561 // linear plot; 5562 Int_t binLow = (nBins*pixelIndex)/nPixels + pAxis->GetFirst();; 5563 Int_t binHigh = binLow + nBins/nPixels;; 5564 THistRenderingRegion region = { std::make_pair(pixelIndex, pixelIndex+1),; 5565 std::make_pair(binLow, binHigh)};; 5566 regions.push_back(region);; 5567 }; 5568 }; 5569 }; 5570 ; 5571 return regions;; 5572}; 5573 ; 5574////////////////////////////////////////////////////////////////////////////////; 5575/// [Rendering scheme for the COL2 and COLZ2 options] (\ref HP14); 5576 ; 5577void THistPainter::PaintColorLevelsFast(Option_t*); 5578{; 5579 ; 5580 if (Hoption.System != kCARTESIAN) {; 5581 Error(""THistPainter::PaintCol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:207387,simpl,simply,207387,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['simpl'],['simply']
Usability,"using PyROOT.; Previously, when showing the different ways an RDataFrame can be created, we showed a constructor that takes a number of entries as a parameter. In the following example we show how to combine such an ""empty"" RDataFrame with Define() transformations to create a dataset on the fly. We then save the generated data on disk using the Snapshot() action. RDataFrame d(100); // an RDF that will generate 100 entries (currently empty); int x = -1;; auto d_with_columns = d.Define(""x"", [&x] { return ++x; }); .Define(""xx"", [&x] { return x*x; });; d_with_columns.Snapshot(""myNewTree"", ""newfile.root"");; ROOT::RDF::RInterface< RDFDetail::RLoopManager >::DefineRInterface< RDFDetail::RLoopManager, DS_t > Define(std::string_view name, F expression, const ColumnNames_t &columns={})Define a new column.Definition RInterface.hxx:338; This example is slightly more advanced than what we have seen so far. First, it makes use of lambda captures (a simple way to make external variables available inside the body of C++ lambdas) to act on the same variable x from both Define() transformations. Second, we have stored the transformed dataframe in a variable. This is always possible, since at each point of the transformation chain users can store the status of the dataframe for further use (more on this below).; You can read more about defining new columns here. A graph composed of two branches, one starting with a filter and one with a define. The end point of a branch is always an action. Running on a range of entries; It is sometimes necessary to limit the processing of the dataset to a range of entries. For this reason, the RDataFrame offers the concept of ranges as a node of the RDataFrame chain of transformations; this means that filters, columns and actions can be concatenated to and intermixed with Range()s. If a range is specified after a filter, the range will act exclusively on the entries passing the filter – it will not even count the other entries! The same goes for a Ra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:22888,simpl,simple,22888,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['simpl'],['simple']
Usability,"using PyROOT.; Previously, when showing the different ways an RDataFrame can be created, we showed a constructor that takes a number of entries as a parameter. In the following example we show how to combine such an ""empty"" RDataFrame with Define() transformations to create a dataset on the fly. We then save the generated data on disk using the Snapshot() action. RDataFrame d(100); // an RDF that will generate 100 entries (currently empty); int x = -1;; auto d_with_columns = d.Define(""x"", [&x] { return ++x; }); .Define(""xx"", [&x] { return x*x; });; d_with_columns.Snapshot(""myNewTree"", ""newfile.root"");; ROOT::RDF::RInterface< RDFDetail::RLoopManager >::DefineRInterface< RDFDetail::RLoopManager, DS_t > Define(std::string_view name, F expression, const ColumnNames_t &columns={})Define a new column.Definition RInterface.hxx:441; This example is slightly more advanced than what we have seen so far. First, it makes use of lambda captures (a simple way to make external variables available inside the body of C++ lambdas) to act on the same variable x from both Define() transformations. Second, we have stored the transformed dataframe in a variable. This is always possible, since at each point of the transformation chain users can store the status of the dataframe for further use (more on this below).; You can read more about defining new columns here. A graph composed of two branches, one starting with a filter and one with a define. The end point of a branch is always an action. Running on a range of entries; It is sometimes necessary to limit the processing of the dataset to a range of entries. For this reason, the RDataFrame offers the concept of ranges as a node of the RDataFrame chain of transformations; this means that filters, columns and actions can be concatenated to and intermixed with Range()s. If a range is specified after a filter, the range will act exclusively on the entries passing the filter – it will not even count the other entries! The same goes for a Ra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:23277,simpl,simple,23277,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['simpl'],['simple']
Usability,"using ROOT::Experimental::RFieldBase::RSchemaIterator = RSchemaIteratorTemplate<false>. Definition at line 443 of file RFieldBase.hxx. Member Enumeration Documentation. ◆ EState. enum class ROOT::Experimental::RFieldBase::EState. strong . During its lifetime, a field undergoes the following possible state transitions: ; [*] --> Unconnected --> ConnectedToSink -— | | | | --> ConnectedToSource —> [*] . | |. EnumeratorkUnconnected ; kConnectedToSink ; kConnectedToSource . Definition at line 134 of file RFieldBase.hxx. Constructor & Destructor Documentation. ◆ RFieldBase() [1/3]. ROOT::Experimental::RFieldBase::RFieldBase ; (; std::string_view ; name, . std::string_view ; type, . ENTupleStructure ; structure, . bool ; isSimple, . std::size_t ; nRepetitions = 0 . ). The constructor creates the underlying column objects and connects them to either a sink or a source. ; If isSimple is true, the trait kTraitMappable is automatically set on construction. However, the field might be demoted to non-simple if a post-read callback is set. ; Definition at line 557 of file RField.cxx. ◆ RFieldBase() [2/3]. ROOT::Experimental::RFieldBase::RFieldBase ; (; const RFieldBase & ; ). delete . ◆ RFieldBase() [3/3]. ROOT::Experimental::RFieldBase::RFieldBase ; (; RFieldBase && ; ). default . ◆ ~RFieldBase(). virtual ROOT::Experimental::RFieldBase::~RFieldBase ; (; ). virtualdefault . Member Function Documentation. ◆ AcceptVisitor(). void ROOT::Experimental::RFieldBase::AcceptVisitor ; (; Detail::RFieldVisitor & ; visitor); const. virtual . Reimplemented in ROOT::Experimental::RFieldZero, ROOT::Experimental::RClassField, ROOT::Experimental::RStreamerField, ROOT::Experimental::REnumField, ROOT::Experimental::RCardinalityField, ROOT::Experimental::RField< TObject >, ROOT::Experimental::RField< bool >, ROOT::Experimental::RField< char >, ROOT::Experimental::RField< float >, ROOT::Experimental::RField< double >, ROOT::Experimental::RProxiedCollectionField, ROOT::Experimental::RRecordField, ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html:17606,simpl,simple,17606,doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,1,['simpl'],['simple']
Usability,"usted MC template (Aji) for template (parm). ; Note that the (Aji) times fractions only sum to the total prediction of the fit if all weights are 1. Note also that the histogram is managed by the TFractionFitter class, so the returned pointer will be invalid if the class is deleted ; Definition at line 961 of file TFractionFitter.cxx. ◆ GetNDF(). Int_t TFractionFitter::GetNDF ; (; ); const. return the number of degrees of freedom in the fit the fNDF parameter has been previously computed during a fit. ; The number of degrees of freedom corresponds to the number of points used in the fit minus the number of templates. ; Definition at line 894 of file TFractionFitter.cxx. ◆ GetPlot(). TH1 * TFractionFitter::GetPlot ; (; ). Return the ""template prediction"" corresponding to the fit result (this is not the same as the weighted sum of template distributions, as template statistical uncertainties are taken into account). ; Note that the name of this histogram will simply be the same as that of the ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". Note also that the histogram is managed by the TFractionFitter class, so the returned pointer will be invalid if the class is deleted ; Definition at line 621 of file TFractionFitter.cxx. ◆ GetProb(). Double_t TFractionFitter::GetProb ; (; ); const. return the fit probability ; Definition at line 903 of file TFractionFitter.cxx. ◆ GetRanges(). void TFractionFitter::GetRanges ; (; Int_t & ; minX, . Int_t & ; maxX, . Int_t & ; minY, . Int_t & ; maxY, . Int_t & ; minZ, . Int_t & ; maxZ . ); const. private . Used internally to obtain the bin ranges according to the dimensionality of the histogram and the limits set by hand. ; Definition at line 639 of file TFractionFitter.cxx. ◆ GetResult(). void TFractionFitter::GetResult ; (; Int_t ; parm, . Double_t & ; value, . Double_t & ; error . ); const. Obtain the fit result for parameter <parm> (the parameter numbering follows that of the input template vector). ; Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFractionFitter.html:28105,simpl,simply,28105,doc/master/classTFractionFitter.html,https://root.cern,https://root.cern/doc/master/classTFractionFitter.html,1,['simpl'],['simply']
Usability,"ustomizing HTML; THtml allows a vast amount of customizations, from a custom style to custom links, to customized java scripts. By default, the style sheet is taken from $ROOTSYS/etc/html/ROOT.css when the documentation is generated. The path for ROOT.css can be changed by calling THtml::SetEtcDir(); it should contain the same CSS classes and entity IDs as the original ROOT.css. This style sheet is an easy means of customizing the layout and appearance of the documentation pages. Many of THtml setting can be customized by calls to THtml member functions or by settings in .rootrc, as documented in the THtml class reference page http://root.cern.ch/root/html/THtml. The following will enumerate some of the highlights.; 27.4.1 Referencing Documentation for other Libraries; When THtml generates documentation for classes it recognizes all class names known to ROOT. If THtml does not have sources for a class it determines the class’s library name. This has to be set by means of rootmap files, see Library AutoLoading of this User’s Guide. Given the library name, THtml searches for an entry in its map of libraries to documentation URLs. If it finds it, it will create a link to the documentation at that URL for all occurrences of a given class name. One can set the URL ../mylib/ for a library name MyLib by setting Root.Html.MyLib: ../mylib/ or by calling THtml::SetLibURL(""MyLib"", ""../mylib/""). Occurrences of class MyClass of MyLib will now be referenced as ../mylib/MyClass.html.; 27.4.2 Search Engine; THtml can invoke external search engines. The ROOT reference guide sets Root.Html.Search to http://www.google.com/search?q=%s+site%3A%u. Calling THtml::SetSearchStemURL() will set the same. If this URL stem is set, THtml will create search fields in the index pages. It will send the words entered in these search fields as %s in the URL; %u will be replaced by the current document’s path, allowing a site- and directory-specific search.; 27.4.3 ViewCVS; Most code is managed in a v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1249268,Guid,Guide,1249268,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Guid'],['Guide']
Usability,"ut & ; selection, . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). overridevirtual . Draw expression varexp for selected entries. ; Returns -1 in case of error or number of selected events in case of success.; This function accepts TCut objects as arguments. Useful to use the string operator +, example: ntuple.Draw(""x"",cut1+cut2+cut3);. Reimplemented from TTree.; Reimplemented in TProofChain.; Definition at line 793 of file TChain.cxx. ◆ Draw() [3/3]. void TChain::Draw ; (; Option_t * ; option). inlineoverridevirtual . Default Draw method for all objects. ; Reimplemented from TObject.; Reimplemented in TProofChain.; Definition at line 90 of file TChain.h. ◆ Fill(). Int_t TChain::Fill ; (; ). inlineoverridevirtual . Fill all branches. ; This function loops on all the branches of this tree. For each branch, it copies to the branch buffer (basket) the current values of the leaves data types. If a leaf is a simple data type, a simple conversion to a machine independent format has to be done.; This machine independent version of the data is copied into a basket (each branch has its own basket). When a basket is full (32k worth of data by default), it is then optionally compressed and written to disk (this operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function returns the number of bytes committed to the individual branches.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.; The baskets are flushed and the Tree header saved at regular intervals; At regular intervals, when the amount of data written so far is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk. This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region. When the first call to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:69598,simpl,simple,69598,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,2,['simpl'],['simple']
Usability,"ut & ; selection, . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). overridevirtual . Draw expression varexp for selected entries. ; Returns -1 in case of error or number of selected events in case of success.; This function accepts TCut objects as arguments. Useful to use the string operator +, example: ntuple.Draw(""x"",cut1+cut2+cut3);. Reimplemented from TTree.; Reimplemented in TProofChain.; Definition at line 819 of file TChain.cxx. ◆ Draw() [3/3]. void TChain::Draw ; (; Option_t * ; option). inlineoverridevirtual . Default Draw method for all objects. ; Reimplemented from TObject.; Reimplemented in TProofChain.; Definition at line 90 of file TChain.h. ◆ Fill(). Int_t TChain::Fill ; (; ). inlineoverridevirtual . Fill all branches. ; This function loops on all the branches of this tree. For each branch, it copies to the branch buffer (basket) the current values of the leaves data types. If a leaf is a simple data type, a simple conversion to a machine independent format has to be done.; This machine independent version of the data is copied into a basket (each branch has its own basket). When a basket is full (32k worth of data by default), it is then optionally compressed and written to disk (this operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function returns the number of bytes committed to the individual branches.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.; The baskets are flushed and the Tree header saved at regular intervals; At regular intervals, when the amount of data written so far is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk. This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region. When the first call to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:70007,simpl,simple,70007,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,2,['simpl'],['simple']
Usability,"ut 'physics' pdf resmodel : input 'resolution' pdf; output is pdf(x) (X) resmodel(x) = Int [ pdf(x') resmodel (x-x') ] dx' ; Definition at line 106 of file RooNumConvolution.cxx. ◆ RooNumConvolution() [3/3]. RooNumConvolution::RooNumConvolution ; (; const RooNumConvolution & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 143 of file RooNumConvolution.cxx. ◆ ~RooNumConvolution(). RooNumConvolution::~RooNumConvolution ; (; ). override . Destructor. ; Definition at line 214 of file RooNumConvolution.cxx. Member Function Documentation. ◆ Class(). static TClass * RooNumConvolution::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooNumConvolution::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooNumConvolution::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 97 of file RooNumConvolution.h. ◆ clearConvolutionWindow(). void RooNumConvolution::clearConvolutionWindow ; (; ). Removes previously defined convolution window, reverting to convolution from -inf to +inf. ; Definition at line 274 of file RooNumConvolution.cxx. ◆ clone(). TObject * RooNumConvolution::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 39 of file RooNumConvolution.h. ◆ cloneModel(). RooAbsReal & RooNumConvolution::cloneModel ; (; ); const. inlineprotected . Definition at line 87 of file RooNumConvolution.h. ◆ clonePdf(). RooAbsReal & RooNumConvolution::clonePdf ; (; ); const. inlineprotected . Definition at line 86 of file RooNumConvolution.h. ◆ cloneVar(). RooRealVar & RooNumConvolution::cloneVar ; (; ); const. inlineprotected . Definition at line 85 of file RooNumConvolution.h. ◆ convIntConfig() [1/2]. RooNumIntConfig & RooNumConvolution::convIntConfig ; (; ). inline . Definition at line 44 of file RooNumConvolution.h. ◆ convIntConfig() [2/2]. const RooNum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvolution.html:66039,clear,clearConvolutionWindow,66039,doc/master/classRooNumConvolution.html,https://root.cern,https://root.cern/doc/master/classRooNumConvolution.html,1,['clear'],['clearConvolutionWindow']
Usability,"ut global) minimization by monte carlo search. ; Each time a new minimum is found, the search area is shifted to be centered at the best value. Random points are chosen uniformly over a hypercube determined by current step sizes. The Metropolis algorithm accepts a worse point with probability exp(-d/UP), where d is the degradation. Improved points are of course always accepted. Actual steps are random multiples of the nominal steps (DIRIN). ; Definition at line 6818 of file TMinuit.cxx. ◆ mnset(). void TMinuit::mnset ; (; ). virtual . Interprets the commands that start with SET and SHOW. ; Called from MNEXCM file characteristics for SET INPUT 'SET ' or 'SHOW', 'ON ' or 'OFF', 'SUPPRESSED' or 'REPORTED ' explanation of print level numbers -1:3 and strategies 0:2 identification of debug options things that can be set or shown options not intended for normal users ; Definition at line 6913 of file TMinuit.cxx. ◆ mnsimp(). void TMinuit::mnsimp ; (; ). virtual . Minimization using the simplex method of Nelder and Mead. ; Performs a minimization using the simplex method of Nelder and Mead (ref. – Comp. J. 7,308 (1965)). ; Definition at line 7431 of file TMinuit.cxx. ◆ mnstat(). void TMinuit::mnstat ; (; Double_t & ; fmin, . Double_t & ; fedm, . Double_t & ; errdef, . Int_t & ; npari, . Int_t & ; nparx, . Int_t & ; istat . ). virtual . Returns concerning the current status of the minimization. ; User-called Namely, it returns:; FMIN: the best function value found so far; FEDM: the estimated vertical distance remaining to minimum; ERRDEF: the value of UP defining parameter uncertainties; NPARI: the number of currently variable parameters; NPARX: the highest (external) parameter number defined by user; ISTAT: a status integer indicating how good is the covariance matrix:; 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix . Definition at line 7638 of file TMinuit.cxx. ◆ mntiny(). voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:64413,simpl,simplex,64413,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['simpl'],['simplex']
Usability,"ut specification option; vector<TNeuron*>fOutputNeuronscache this for fast access; static const Bool_tfgDEBUGdebug flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeclareOptions(); define the options (their key words) that can be set in the option string; here the options valid for ALL MVA methods are declared.; know options: NCycles=xx :the number of training cycles; Normalize=kTRUE,kFALSe :if normalised in put variables should be used; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers; NeuronType=sigmoid,tanh,radial,linar : the type of activation function; used at the neuronn. void ProcessOptions(); do nothing specific at this moment. std::vector<Int_t>* ParseLayoutString(TString layerSpec); parse layout specification string and return a vector, each entry; containing the number of neurons to go in each successive layer. void InitANNBase(); initialize ANNBase object. ~MethodANNBase(); destructor. void DeleteNetwork(); delete/clear network. void DeleteNetworkLayer(TObjArray*& layer); delete a network layer. void BuildNetwork(vector<Int_t>* layout, vector<Double_t>* weights = NULL, Bool_t fromFile = kFALSE); build network given a layout (number of neurons in each layer); and optional weights array. void BuildLayers(vector<Int_t>* layout, Bool_t from_file = false); build the network layers. void BuildLayer(Int_t numNeurons, TObjArray* curLayer, TObjArray* prevLayer, Int_t layerIndex, Int_t numLayers, Bool_t from_file = false); build a single layer with neurons and synapses connecting this; layer to the previous layer. void AddPreLinks(TMVA::TNeuron* neuron, TObjArray* prevLayer); add synapses connecting a neuron to its preceding layer. void InitWeights(); initialize the synapse weights randomly. void ForceWeights(vector<Double_t>* weights); force the synapse weights. void ForceNetworkInputs(const TMVA::Event* ev, Int_t ignoreIndex = -1); force the input values of the input neurons; force the value for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodANNBase.html:19450,clear,clear,19450,root/html534/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodANNBase.html,2,['clear'],['clear']
Usability,"ut, UInt_t option); Check for the 'ls.txt' for 'group' and 'user' and fill the path for the; ls file in 'out'.; If 'dsname' is defined, open the file and extract the relevant line.; Return 0 on success, -1 on failure. TFileCollection * GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0). Returns the dataset <dsName> of user <user> in group <group> .; If checksum is non-zero, it will contain the pointer to a TMD5 sum object; with the checksum of the file, has to be deleted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not; contain the list of files. This is much faster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is checked against it,; if it does not match the file is not written (the function returns 2 in this; case, if the file has disappeared it is also not written (i.e. checksum; implies the bit kFileMustExist set in option).; Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum); Calculate the checksum of the indicated dataset at 'path' and save it to the; appropriate file 'md5path'. The MD5 string is returned in 'md5sum'.; Return 0 on success, -1 on error. Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDataSetManagerFile.html:16494,Clear,ClearCache,16494,root/html532/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html532/TDataSetManagerFile.html,8,['Clear'],"['Clear', 'ClearCache']"
Usability,"utes |; Private Member Functions |; Private Attributes |; List of all members ; TH1Editor Class ReferenceGUI » ROOT Graphics Editor. ; Editor for changing TH1 histogram attributes, rebinning & fitting. ; For all possible draw options (there are a few which are not implementable in graphical user interface) see THistPainter::Paint; These changes can be made via the TH1Editor: Style Tab: 'Line' : change Line attributes (color, thickness) see TAttLineEditor 'Fill' : change Fill attributes (color, pattern) see TAttFillEditor 'Title' : TextEntry: set the title of the histogram 'Histogram': change the draw options of the histogram 'Plot' : Radiobutton: draw a 2D or 3D plot of the histogram according to the Plot dimension there will be different drawing possibilities (ComboBoxes/ CheckBoxes) 2d Plot: 'Error' : ComboBox: add different error bars to the histogram (no errors, simple, ..., see THistPainter::Paint 'Add' : ComboBox: further things which can be added to the histogram (None, simple/smooth line, fill area 'Simple Drawing': CheckBox: draw a simple histogram without errors (= ""HIST"" drawoption). In combination with some other draw options an outer line is drawn on top of the histogram 'Show markers': CheckBox: draw a marker on to of each bin (=""P"" drawoption) 'Draw bar chart': CheckBox: draw a bar chart (=""B"" drawoption) change the Fill Color with Fill in the Style Tab => will show Bar menue in the Style Tab 'Bar option': CheckBox: draw a bar chart (=""BAR"" drawoption) => will show Bar menue in the Style Tab 3d Plot: 'Type' : ComboBox: set histogram type Lego-Plot or Surface draw(Lego, Lego1.2, Surf, Surf1..5) see THistPainter::Paint 'Coords' : ComboBox: set the coordinate system (Cartesian, .. Spheric) see THistPainter::Paint 'Error' : see 2D plot 'Bar' : change the bar attributes 'W' : change Bar Width 'O' : change Bar Offset 'Percentage': specifies the percentage of the bar which is drawn brighter and darker (10% == BAR1 drawoption) 'Horizontal Bar': draw a horizont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1Editor.html:1241,simpl,simple,1241,doc/master/classTH1Editor.html,https://root.cern,https://root.cern/doc/master/classTH1Editor.html,2,['simpl'],['simple']
Usability,"utines like drawing, size of string on screen depen...Definition TGString.h:20; TGString::GetStringconst char * GetString() constDefinition TGString.h:30; TGTextBufferA text buffer is used in several widgets, like TGTextEntry, TGFileDialog, etc.Definition TGTextBuffer.h:17; TGTextButtonYield an action as soon as it is clicked.Definition TGButton.h:142; TGTextEntryA TGTextEntry is a one line text input widget.Definition TGTextEntry.h:24; TGTextEntry::SetDefaultSizevirtual void SetDefaultSize(UInt_t w, UInt_t h)Set the default / minimal size of the widget.Definition TGTextEntry.cxx:384; TGTextEntry::Clearvoid Clear(Option_t *option="""") overrideClears up the text entry.Definition TGTextEntry.cxx:972; TGTextEntry::GetTextconst char * GetText() constDefinition TGTextEntry.h:119; TGTextEntry::SetCursorPositionvirtual void SetCursorPosition(Int_t pos)Set the cursor position to newPos.Definition TGTextEntry.cxx:718; TGTextEntry::AppendTextvirtual void AppendText(const char *text)Appends text to the end of text entry, clears the selection and moves the cursor to the end of the li...Definition TGTextEntry.cxx:1689; TGTextEntry::SetToolTipTextvirtual void SetToolTipText(const char *text, Long_t delayms=500)Set tool tip text associated with this text entry.Definition TGTextEntry.cxx:1647; TGTextEntry::SetTextvirtual void SetText(const char *text, Bool_t emit=kTRUE)Sets text entry to text, clears the selection and moves the cursor to the end of the line.Definition TGTextEntry.cxx:611; TGTextEntry::HandleButtonBool_t HandleButton(Event_t *event) overrideHandle mouse button event in text entry widget.Definition TGTextEntry.cxx:1342; TGToolBarA toolbar is a composite frame that contains TGPictureButtons.Definition TGToolBar.h:33; TGVSplitterDefinition TGSplitter.h:53; TGVSplitter::SetFramevoid SetFrame(TGFrame *frame, Bool_t left) overrideSet frame to be resized.Definition TGSplitter.cxx:143; TGVertical3DLineA vertical 3D line is a line that can be used to separate groups of widgets",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:129761,clear,clears,129761,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['clear'],['clears']
Usability,"ution . Definition at line 1250 of file TUnfoldSys.cxx. ◆ GetEmatrixInput(). void TUnfoldSys::GetEmatrixInput ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance matrix contribution from input measurement uncertainties ; Parameters. [in,out]ematrixoutput histogram ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result from the uncertainties or covariance of the input data. In many cases, these are the ""statistical uncertainties"". ; The array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1207 of file TUnfoldSys.cxx. ◆ GetEmatrixSysBackgroundScale(). void TUnfoldSys::GetEmatrixSysBackgroundScale ; (; TH2 * ; ematrix, . const char * ; name, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background normalisation uncertainty ; Parameters. [in,out]ematrixoutput histogram ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram prior to adding the covariance matrix contribution. this method returns the uncertainties on the unfolding result arising from the background source source and its normalisation uncertainty. See method SubtractBackground() how to set the normalisation uncertainty ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1144 of file TUnfoldSys.cxx. ◆ GetEmatrixSysBackgroundUncorr(). void TUnfoldSys::GetEmatrixSysBackgroundUncorr ; (; TH2 * ; ematrix, . const char * ; source, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:38447,clear,clearEmat,38447,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearEmat']
Usability,"utomatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:1389,learn,learning,1389,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,2,['learn'],['learning']
Usability,"utomatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  ; file  na49geomfile.C;  Before executing this macro, the file makegeometry.C must have been executed. ;  ; file  na49view.C;  This macro generates with 2 views of the NA49 detector using the old obsolete geometry package. ;  ; file  parallel_world.C;  Misaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and are correlated. ;  ; file  RadioNuclides.C;  Macro that demonstrates usage of radioactive elements/materials/mixtures with TGeo package. ;  ; file  robot.C;  Drawing a famous Korean robot, TaekwonV, using ROOT geometry class. ;  ; file  rootgeom.C;  Definition of a simple geometry (the 4 ROOT characters) ;  ; file  runplugin.C;  Creates and runs a simple iterator plugin connected to TGeoPainter iterator. ;  ; file  shapes.C;  The old geometry shapes (see script geodemo.C) ;  ; file  shapesAnim.C;  Macro illustrating how to animate a geometry picture using a Timer. ;  ; file  south_gate.C;  Drawing a famous Korean gate, the South gate, called Namdeamoon in Korean, using ROOT geometry class. ;  ; file  station1.C;  Drawing a space station, using ROOT geometry class. ;  ; file  station2.C;  Drawing a space station (version 2), using ROOT geometry class. ;  ; file  tank.C;  Drawing a fine tank, using ROOT geometry class. ;  ; file  tessellatedNav.C;  Macro allowing to vizualize tessellations from Wavefront's .obj format. ;  ; file  testoptical.C;  Tests importing/exporting optical surfaces from GDML. ;  ; file  visualizeWavefrontObj.C;  Macro allowing to vizualize tessellations from Wavefront's .obj format. ;  ; file  xtruDraw.C;  Draw a ""representative"" TXTRU shape. ;  ; file  xtruSamples.C;  Draw a sample of TXTRU shapes some convex, concave (and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__geom.html:2232,simpl,simple,2232,doc/master/group__tutorial__geom.html,https://root.cern,https://root.cern/doc/master/group__tutorial__geom.html,1,['simpl'],['simple']
Usability,uttons ; Definition at line 97 of file TGDockableFrame.h. ◆ fContainer. TGCompositeFrame* TGDockableFrame::fContainer. protected . container containing dockable frame ; Definition at line 96 of file TGDockableFrame.h. ◆ fDeleted. Bool_t TGDockableFrame::fDeleted. protected . kTRUE if it is being deleted ; Definition at line 93 of file TGDockableFrame.h. ◆ fDockButton. TGDockButton* TGDockableFrame::fDockButton. protected . dock button ; Definition at line 98 of file TGDockableFrame.h. ◆ fDockName. TString TGDockableFrame::fDockName. protected . name of frame ; Definition at line 95 of file TGDockableFrame.h. ◆ fEnableHide. Bool_t TGDockableFrame::fEnableHide. protected . if frame can be hidden ; Definition at line 91 of file TGDockableFrame.h. ◆ fEnableUndock. Bool_t TGDockableFrame::fEnableUndock. protected . if frame can be undocked ; Definition at line 92 of file TGDockableFrame.h. ◆ fFixedSize. Bool_t TGDockableFrame::fFixedSize. protected . kTRUE if fixed size when undocked ; Definition at line 94 of file TGDockableFrame.h. ◆ fFrame. TGUndockedFrame* TGDockableFrame::fFrame. protected . undocked frame ; Definition at line 100 of file TGDockableFrame.h. ◆ fHidden. Bool_t TGDockableFrame::fHidden. protected . if frame is hidden ; Definition at line 90 of file TGDockableFrame.h. ◆ fHideButton. TGDockHideButton* TGDockableFrame::fHideButton. protected . hide button ; Definition at line 99 of file TGDockableFrame.h. ◆ fHints. TGLayoutHints* TGDockableFrame::fHints. protected . layout hints ; Definition at line 101 of file TGDockableFrame.h. ◆ fLb. TGLayoutHints* TGDockableFrame::fLb. protected . Definition at line 102 of file TGDockableFrame.h. ◆ fLc. TGLayoutHints * TGDockableFrame::fLc. protected . layout hints ; Definition at line 102 of file TGDockableFrame.h. Libraries for TGDockableFrame:. [legend]; The documentation for this class was generated from the following files:; gui/gui/inc/TGDockableFrame.h; gui/gui/src/TGDockableFrame.cxx. TGDockableFrame. ROOT mast,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDockableFrame.html:40271,undo,undocked,40271,doc/master/classTGDockableFrame.html,https://root.cern,https://root.cern/doc/master/classTGDockableFrame.html,1,['undo'],['undocked']
Usability,"v = new TF1Convolution(function1, function2, xmin, xmax);; 558 ; 559 // (note: currently ignoring `useFFT` option); 560 fNpar = conv->GetNpar();; 561 fNdim = 1; // (note: may want to extend this in the future?); 562 ; 563 fType = EFType::kCompositionFcn;; 564 fComposition = std::unique_ptr<TF1AbsComposition>(conv);; 565 ; 566 fParams = std::make_unique<TF1Parameters>(fNpar); // default to zeros (TF1Convolution has no GetParameters()); 567 // set parameter names; 568 for (int i = 0; i < fNpar; i++); 569 this->SetParName(i, conv->GetParName(i));; 570 // set parameters to default values; 571 int f1Npar = function1->GetNpar();; 572 int f2Npar = function2->GetNpar();; 573 // first, copy parameters from function1; 574 for (int i = 0; i < f1Npar; i++); 575 this->SetParameter(i, function1->GetParameter(i));; 576 // then, check if the ""Constant"" parameters were combined; 577 // (this code assumes function2 has at most one parameter named ""Constant""); 578 if (conv->GetNpar() == f1Npar + f2Npar - 1) {; 579 int cst1 = function1->GetParNumber(""Constant"");; 580 int cst2 = function2->GetParNumber(""Constant"");; 581 this->SetParameter(cst1, function1->GetParameter(cst1) * function2->GetParameter(cst2));; 582 // and copy parameters from function2; 583 for (int i = 0; i < f2Npar; i++); 584 if (i < cst2); 585 this->SetParameter(f1Npar + i, function2->GetParameter(i));; 586 else if (i > cst2); 587 this->SetParameter(f1Npar + i - 1, function2->GetParameter(i));; 588 } else {; 589 // or if no constant, simply copy parameters from function2; 590 for (int i = 0; i < f2Npar; i++); 591 this->SetParameter(i + f1Npar, function2->GetParameter(i));; 592 }; 593 ; 594 // Then check if we need NSUM syntax:; 595 } else if (formulaLength > 5 && strncmp(formula, ""NSUM("", 5) == 0 && formula[formulaLength - 1] == ')') {; 596 // using comma as delimiter; 597 char delimiter = ',';; 598 // first, remove ""NSUM("" and "")"" and spaces; 599 TString formDense = TString(formula)(5,formulaLength-5-1);; 600 formDense.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:19029,simpl,simply,19029,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['simpl'],['simply']
Usability,"vEmat = 0) const; get global correlation coefficients with arbitrary min map; rhoi: global correlation histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. return value: maximum global correlation. Double_t GetRhoIFromMatrix(TH1* rhoi, const TMatrixDSparse* eOrig, const Int_t* binMap, TH2* invEmat) const; get global correlation coefficients with arbitrary min map; rhoi: global correlation histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. return value: maximum global correlation. void ClearHistogram(TH1* h, Double_t x = 0.) const; clear histogram contents and error. void SetEpsMatrix(Double_t eps); set accuracy for matrix inversion. TUnfold(const TUnfold& ); Int_t IsNotSymmetric(TMatrixDSparse const &m) const;. TMatrixDSparse * MultiplyMSparseTranspMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const. TMatrixDSparse * InvertMSparseSymmPos(const TMatrixDSparse* A, Int_t* rank) const. TMatrixDSparse * CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const. Int_t GetNx(void). Int_t GetNy(void). const TMatrixDSparse * GetDXDY(void); { return fDXDY; }. const TMatrixDSparse * GetDXDAM(int i) const; { return fDXDAM[i]; }. const TMatrixDSparse * GetDXDAZ(int i) const; { return fDXDAZ[i]; }. const TMatrixDSparse * GetDXDtauSquared(void); { return fDXDtauSquared; }. const TMatrixDSparse * GetAx(void); { return fAx; }. const TMatrixDSparse * GetEinv(void); { return fEinv; }. const TMatrixDSparse * GetE(void); { return fE; }. const TMatrixDSparse * GetVxx(void); { return fVxx; }. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfold.html:32052,clear,clear,32052,root/html534/TUnfold.html,https://root.cern,https://root.cern/root/html534/TUnfold.html,6,['clear'],['clear']
Usability,"vaSigMVA distrituion for signal events, used for spline fit; TH1D*fMvaSigFineBinMVA distrituion for signal events; TStringfOptimizationFitTypewhich type of optimisation procedure to be used ; map<TString,TMVA::Interval>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__OptimizeConfigParameters.html:3152,simpl,simple,3152,root/html530/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html530/TMVA__OptimizeConfigParameters.html,3,['simpl'],['simple']
Usability,"val(3); (Double_t)4.70400026866224020e-02; root[] f1.Derivative(3); (Double_t)(-3.45675056671992330e-01); root[] f1.Integral(0,3); (Double_t)1.84865252799946810e+00; root[] f1.Draw(); By default the method TF1::Paint(), that draws the function, computes 100 equidistant points to draw it. The number of points can be set to a higher value with:; root[] f1.SetNpx(2000);; Note that while the ROOT framework is an object-oriented framework, this does not prevent the user from calling plain functions.; 2.3.4 User Interaction; Now we will look at some interactive capabilities. Try to draw the function sin(x)/x again. Every object in a window (which is called a canvas) is, in fact, a graphical object in the sense that you can grab it, resize it, and change its characteristics with a mouse click. For example, bring the cursor over the x-axis. The cursor changes to a hand with a pointing finger when it is over the axis. Now, left click and drag the mouse along the axis to the right. You have a very simple zoom.; When you move the mouse over any object, you can get access to selected methods by pressing the right mouse button and obtaining a context menu. If you try this on the function TF1, you will get a menu showing available methods. The other objects on this canvas are the title, a TPaveText object; the x and y-axis, TAxis objects, the frame, a TFrame object, and the canvas a TCanvas object. Try clicking on these and observe the context menu with their methods. A context menu. For example try selecting the SetRange() method and putting -10, 10 in the dialog box fields. This is equivalent to executing f1.SetRange(-10,10) from the command line, followed by f1.Draw(). Here are some other options you can try.; Once the picture suits your wishes, you may want to see the code you should put in a script to obtain the same result. To do that, choose Save / canvas.C entry of the File menu. This will generate a script showing the options set in the current canvas. Notice that you can",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:49246,simpl,simple,49246,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"valid = kFALSE) const; virtual RooAbsGenContext*RooAbsPdf::binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction1PdfBinding_double_double_.html:3286,clear,clearShapeDirty,3286,root/html534/RooCFunction1PdfBinding_double_double_.html,https://root.cern,https://root.cern/root/html534/RooCFunction1PdfBinding_double_double_.html,64,['clear'],['clearShapeDirty']
Usability,"valid = kFALSE) const; virtual RooAbsGenContext*binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:6940,clear,clearValueAndShapeDirty,6940,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,4,['clear'],['clearValueAndShapeDirty']
Usability,"value press the left mouse button near to the left/right (top/bottom) edges of the slider. To change both values simultaneously press the mouse button near to the slider center. To change pointer value press the mouse on the pointer and drag it to the desired position.; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; 25.8.10 Progress Bars; A progress bar is a widget that shows that an operation is in progress and how much time is left. It is a long rectangular bar, initially empty, that fills with a color as a process is being performed. The filled-in area indicates the percentage of the process that has been completed. You should use this widget for waits exceeding one minute. For a very time consuming operation it is better to break the operation into subtasks and provide a progress bar for each of them. A progress bar may be oriented horizontally or vertically. The horizontally oriented progress bar fills with a color from left to right; the vertically oriented - from bottom to top. A percent complete message provides an indication of the completed part of the process. It is a good practice to include some descriptive text of the process to keep users informed and entertained while they are waiting for process completion.; The picture below shows the progress bars you can create using the classes TGProgressBar, TGHProgressBar, and TGHProgressBar.; // vertical frame with three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; fHProg2->SetBarColor(""lightblue"");; fHProg2->ShowPosition(kTRUE,kF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1208132,progress bar,progress bar,1208132,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['progress bar'],['progress bar']
Usability,"values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset); Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset); Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedPdf.html:41764,clear,clearCacheObject,41764,root/html526/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedPdf.html,1,['clear'],['clearCacheObject']
Usability,"variables. We assign px and py a Gaussian with mean = 0 and sigma = 1 by calling gRandom->Rannor(px,py), and calculatepz. Then we call the TTree::Fill() method. The call t1.Fill() fills all branches in the tree because we have already organized the tree into branches and told each branch where to get the value from. After this script is executed we have a ROOT file called tree1.root with a tree called t1. There is a possibility to fill branches one by one using the method TBranch::Fill(). In this case you do not need to call TTree::Fill() method. The entries can be set by TTree::SetEntries(Double_t n). Calling this method makes sense only if the number of existing entries is null.; 12.14.2 Viewing the Tree. The tree1.root file and its tree in the browser and a leaf histogram. In the right panel of the ROOT object browse are the branches: ev, px, py, pz, and random. Note that these are shown as leaves because they are “end” branches with only one leaf. To histogram a leaf, we can simply double click on it in the browser. This is how the tree t1 looks in the Tree Viewer. Here we can add a cut and add other operations for histogramming the leaves. See “The Tree Viewer”. For example, we can plot a two dimensional histogram. The tree viewer. 12.14.3 Reading the Tree; The tree1r function shows how to read the tree and access each entry and each leaf. We first define the variables to hold the read values.; Float_t px, py, pz;; Then we tell the tree to populate these variables when reading an entry. We do this with the method TTree::SetBranchAddress. The first parameter is the branch name, and the second is the address of the variable where the branch data is to be placed. In this example, the branch name is px. This name was given when the tree was written (see tree1w). The second parameter is the address of the variable px.; t1->SetBranchAddress(""px"",&px);; 12.14.3.1 GetEntry; Once the branches have been given the address, a specific entry can be read into the variables w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:555071,simpl,simply,555071,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simply']
Usability,"vas() [1/2]. ROOT::Experimental::RCanvas::RCanvas ; (; const RCanvas & ; ). privatedelete . Disable copy construction for now. . ◆ RCanvas() [2/2]. ROOT::Experimental::RCanvas::RCanvas ; (; ). inline . Create a temporary RCanvas; for long-lived ones please use Create(). ; Definition at line 88 of file RCanvas.hxx. ◆ ~RCanvas(). ROOT::Experimental::RCanvas::~RCanvas ; (; ). overridedefault . Member Function Documentation. ◆ AddPanel(). template<class PANEL > . bool ROOT::Experimental::RCanvas::AddPanel ; (; std::shared_ptr< PANEL > & ; panel). inline . Insert panel into the canvas, canvas should be shown at this moment. ; Definition at line 139 of file RCanvas.hxx. ◆ ClearOnClose(). void ROOT::Experimental::RCanvas::ClearOnClose ; (; const std::shared_ptr< void > & ; handle). Set handle which will be cleared when connection is closed. ; Definition at line 239 of file RCanvas.cxx. ◆ ClearShown(). void ROOT::Experimental::RCanvas::ClearShown ; (; ). inline . clear IsShown() flag ; Definition at line 123 of file RCanvas.hxx. ◆ ClearUpdated(). void ROOT::Experimental::RCanvas::ClearUpdated ; (; ). inline . clear IsUpdated() flag ; Definition at line 169 of file RCanvas.hxx. ◆ Create(). std::shared_ptr< ROOT::Experimental::RCanvas > ROOT::Experimental::RCanvas::Create ; (; const std::string & ; title). static . Create new canvas instance. ; Definition at line 89 of file RCanvas.cxx. ◆ CreateJSON(). std::string ROOT::Experimental::RCanvas::CreateJSON ; (; ). Provide JSON which can be used for offline display. ; Create JSON data for the canvas Can be used of offline display with JSROOT. ; Definition at line 211 of file RCanvas.cxx. ◆ GetCanvas() [1/2]. const RCanvas * ROOT::Experimental::RCanvas::GetCanvas ; (; ); const. inlineoverridevirtual . Access to the top-most canvas, if any (const version). ; Implements ROOT::Experimental::RPadBase.; Definition at line 92 of file RCanvas.hxx. ◆ GetCanvas() [2/2]. RCanvas * ROOT::Experimental::RCanvas::GetCanvas ; (; ). inlineoverride",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvas.html:10507,clear,clear,10507,doc/master/classROOT_1_1Experimental_1_1RCanvas.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvas.html,1,['clear'],['clear']
Usability,"vas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar; static TSessionQueryFrame::EQueryStatuskAborted; static TSessionQueryFrame::EQueryStatuskDone; static TSessionQueryFrame::EQueryStatuskRunning; static TSessionQueryFrame::EQueryStatuskStopped. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TSessionQueryFrame. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query information frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSessionQueryFrame.html:22530,feedback,feedback,22530,root/html602/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html602/TSessionQueryFrame.html,4,['feedback'],['feedback']
Usability,"vas.cxx:199; ROOT::Experimental::RCanvas::CreateJSONstd::string CreateJSON()Provide JSON which can be used for offline display.Definition RCanvas.cxx:211; ROOT::Experimental::RCanvas::SetHeightvoid SetHeight(int height)Set canvas height.Definition RCanvas.hxx:108; ROOT::Experimental::RCanvas::IsShownbool IsShown() constreturns true if Show() method was calledDefinition RCanvas.hxx:120; ROOT::Experimental::RCanvas::fPainterstd::unique_ptr< Internal::RVirtualCanvasPainter > fPainterThe painter of this canvas, bootstrapping the graphics connection.Definition RCanvas.hxx:67; ROOT::Experimental::RCanvas::fWidthint fWidthWidth of the canvas in pixels.Definition RCanvas.hxx:56; ROOT::Experimental::RCanvas::fUpdatedbool fUpdatedindicate if Update() method was called beforeDefinition RCanvas.hxx:73; ROOT::Experimental::RCanvas::Createstatic std::shared_ptr< RCanvas > Create(const std::string &title)Create new canvas instance.Definition RCanvas.cxx:89; ROOT::Experimental::RCanvas::ClearShownvoid ClearShown()clear IsShown() flagDefinition RCanvas.hxx:123; ROOT::Experimental::RCanvas::ClearOnClosevoid ClearOnClose(const std::shared_ptr< void > &handle)Set handle which will be cleared when connection is closed.Definition RCanvas.cxx:239; ROOT::Experimental::RCanvas::SetWidthvoid SetWidth(int width)Set canvas width.Definition RCanvas.hxx:105; ROOT::Experimental::RCanvas::GetCanvasconst RCanvas * GetCanvas() const overrideAccess to the top-most canvas, if any (const version).Definition RCanvas.hxx:92; ROOT::Experimental::RCanvas::RCanvasRCanvas()Create a temporary RCanvas; for long-lived ones please use Create().Definition RCanvas.hxx:88; ROOT::Experimental::RCanvas::Modifiedvoid Modified(std::shared_ptr< RDrawable > drawable)Set newest version to specified drawable.Definition RCanvas.hxx:152; ROOT::Experimental::RCanvas::Modifiedvoid Modified()Definition RCanvas.hxx:149; ROOT::Experimental::RCanvas::GetWidthint GetWidth() constGet canvas width.Definition RCanvas.hxx:111; ROOT::Exp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RCanvas_8hxx_source.html:12304,clear,clear,12304,doc/master/RCanvas_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RCanvas_8hxx_source.html,1,['clear'],['clear']
Usability,"ve a linear system using its Cholesky decomposition (N=4) ;  C_solver< F, 5, V >Struct to solve a linear system using its Cholesky decomposition (N=5) ;  C_solver< F, 6, V >Struct to solve a linear system using its Cholesky decomposition (N=6) ;  C_solverGenDimStruct to solve a linear system using its Cholesky decomposition (generalised dimensionality) ;  CPackedArrayAdapterAdapter for packed arrays (to SMatrix indexing conventions) ;  ►Ndetail;  Cmanipulator;  NGenAlgoOptUtil;  NGenVector;  ►NGenVector_detail;  ►CBitReproducible;  CDB8;  CBitReproducibleException;  NGSLRootHelperHelper functions to test convergence of Root-Finding algorithms ;  NGSLSimAn;  ►Ngv_detail;  CERROR_This_Rotation_Conversion_is_NOT_Supported;  ►NImpl;  CPlane3DClass describing a geometrical plane in 3 dimensions ;  CTransform3DBasic 3D Transformation class describing a rotation and then a translation The internal data are a 3D rotation data (represented as a 3x3 matrix) and a 3D vector data ;  CTranslation3DClass describing a 3 dimensional translation ;  NIntegMultiDim;  NIntegOneDim;  NIntegOptionsUtil;  NIntegration;  NIntegrationMultiDim;  NIntegrationOneDim;  NInternal;  NInterpolation;  NMCIntegration;  NMinim;  NMinim1D;  ►NRootsRoot-Finding Algorithms ;  CBisectionRoots::Bisection Bisection algorithm, simplest algorithm for bracketing the roots of a function, but slowest one ;  CBrentBrent-Dekker algorithm which combines an interpolation strategy with the bisection algorithm See the GSL manual for more information ;  CFalsePosFalse Position algorithm based on linear interpolation ;  CNewtonNewton algorithm, which computes the derivative at each iteration See the GSL manual for more information ;  CSecantSecant algorithm, simplified version of Newton method, which does not require the derivative at every step ;  CSteffensonSteffenson method, providing the fastes convergence ;  ►NrowOffsetsUtils;  Cindices;  Cmake_indices;  Cmake_indices_impl;  Cmake_indices_impl< I, indices< Indices.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/namespaces.html:38075,simpl,simplest,38075,doc/v616/namespaces.html,https://root.cern,https://root.cern/doc/v616/namespaces.html,2,['simpl'],"['simplest', 'simplified']"
Usability,"ve and node info need to be provided ;  ; std::string fSelectedVolume;  ! name of selected volume ;  ; bool fShowColumns {true};  ! show columns in hierarchy ;  ; bool fShowHierarchy {true};  ! if hierarchy visible by default ;  ; std::string fTitle;  ! title of geometry viewer ;  ; std::shared_ptr< RGeomHierarchy > fWebHierarchy;  ! web handle for hierarchy part ;  ; std::shared_ptr< RWebWindow > fWebWindow;  ! web window to show geometry ;  . #include <ROOT/RGeomViewer.hxx>; Constructor & Destructor Documentation. ◆ RGeomViewer(). RGeomViewer::RGeomViewer ; (; TGeoManager * ; mgr = nullptr, . const std::string & ; volname = """" . ). constructor ; Definition at line 35 of file RGeomViewer.cxx. ◆ ~RGeomViewer(). RGeomViewer::~RGeomViewer ; (; ). virtual . destructor ; Definition at line 63 of file RGeomViewer.cxx. Member Function Documentation. ◆ ClearOnClose(). void RGeomViewer::ClearOnClose ; (; const std::shared_ptr< void > & ; handle). Set handle which will be cleared when connection is closed Must be called after window is shown. ; Definition at line 444 of file RGeomViewer.cxx. ◆ Description(). RGeomDescription & ROOT::RGeomViewer::Description ; (; ). inline . Definition at line 107 of file RGeomViewer.hxx. ◆ GetShowColumns(). bool ROOT::RGeomViewer::GetShowColumns ; (; ); const. inline . Definition at line 97 of file RGeomViewer.hxx. ◆ GetShowHierarchy(). bool ROOT::RGeomViewer::GetShowHierarchy ; (; ); const. inline . Returns default hierarchy browser visibility. ; Definition at line 93 of file RGeomViewer.hxx. ◆ GetStackFromJson(). std::vector< int > RGeomViewer::GetStackFromJson ; (; const std::string & ; json, . bool ; node_ids = false . ). protected . convert JSON into stack array ; Definition at line 164 of file RGeomViewer.cxx. ◆ GetTitle(). const std::string & ROOT::RGeomViewer::GetTitle ; (; ); const. inline . Definition at line 59 of file RGeomViewer.hxx. ◆ GetWindowAddr(). std::string RGeomViewer::GetWindowAddr ; (; ); const. Return web window addres",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RGeomViewer.html:4580,clear,cleared,4580,doc/v632/classROOT_1_1RGeomViewer.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RGeomViewer.html,1,['clear'],['cleared']
Usability,"ve and node info need to be provided ;  ; std::string fSelectedVolume;  ! name of selected volume ;  ; bool fShowColumns {true};  ! show columns in hierarchy ;  ; bool fShowHierarchy {true};  ! if hierarchy visible by default ;  ; std::string fTitle;  ! title of geometry viewer ;  ; std::shared_ptr< RGeomHierarchy > fWebHierarchy;  ! web handle for hierarchy part ;  ; std::shared_ptr< RWebWindow > fWebWindow;  ! web window to show geometry ;  . #include <ROOT/RGeomViewer.hxx>; Constructor & Destructor Documentation. ◆ RGeomViewer(). RGeomViewer::RGeomViewer ; (; TGeoManager * ; mgr = nullptr, . const std::string & ; volname = """" . ). constructor ; Definition at line 43 of file RGeomViewer.cxx. ◆ ~RGeomViewer(). RGeomViewer::~RGeomViewer ; (; ). virtual . destructor ; Definition at line 71 of file RGeomViewer.cxx. Member Function Documentation. ◆ ClearOnClose(). void RGeomViewer::ClearOnClose ; (; const std::shared_ptr< void > & ; handle). Set handle which will be cleared when connection is closed Must be called after window is shown. ; Definition at line 452 of file RGeomViewer.cxx. ◆ Description(). RGeomDescription & ROOT::RGeomViewer::Description ; (; ). inline . Definition at line 107 of file RGeomViewer.hxx. ◆ GetShowColumns(). bool ROOT::RGeomViewer::GetShowColumns ; (; ); const. inline . Definition at line 97 of file RGeomViewer.hxx. ◆ GetShowHierarchy(). bool ROOT::RGeomViewer::GetShowHierarchy ; (; ); const. inline . Returns default hierarchy browser visibility. ; Definition at line 93 of file RGeomViewer.hxx. ◆ GetStackFromJson(). std::vector< int > RGeomViewer::GetStackFromJson ; (; const std::string & ; json, . bool ; node_ids = false . ). protected . convert JSON into stack array ; Definition at line 172 of file RGeomViewer.cxx. ◆ GetTitle(). const std::string & ROOT::RGeomViewer::GetTitle ; (; ); const. inline . Definition at line 59 of file RGeomViewer.hxx. ◆ GetWindowAddr(). std::string RGeomViewer::GetWindowAddr ; (; ); const. Return web window addres",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RGeomViewer.html:4626,clear,cleared,4626,doc/master/classROOT_1_1RGeomViewer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RGeomViewer.html,1,['clear'],['cleared']
Usability,"ve been making some commits to your local repository on the master branch, and you realize (perhaps because your project is turning out to be a bit more involved than you thought, or because a slew of changes have just appeared upstream) that you might have been better using NoSY. It's actually quite easy to swap to using NoSY without any disruption to your already-committed changes. Starting from your current position on the master branch:; Stash your current changes if appropriate:git stash; Create (but do not switch to) a branch which will contain all your local commits up to this point:git branch <local-branch>; Download the latest metadata from the remote:git fetch origin; Now, reset your local master branch directly to the current state of origin/master:git reset --hard origin/master; Note that you have not lost your local commits: they are on your local branch already.; Switch to your local branch:git checkout <local-branch>; Do an initial sync between your local branch and the remote, resolving conflicts if necessary:git rebase origin/master; Apply your stash, again, resolving conflicts if necessary:git stash pop; Pick up at step 2 of the NoSY workflow above.; Reproduced with permission from the following page: https://cdcvs.fnal.gov/redmine/projects/cet-is-public/wiki/GitTipsAndTricks. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/suggested-work-flow-distributed-projects-nosy.html:5168,guid,guidelines,5168,d/suggested-work-flow-distributed-projects-nosy.html,https://root.cern,https://root.cern/d/suggested-work-flow-distributed-projects-nosy.html,1,['guid'],['guidelines']
Usability,"ve;; 4525 Hparam = hparsave;; 4526 }; 4527 gCurrentHist = oldhist;; 4528 fXbuf.clear();; 4529 fYbuf.clear();; 4530 return;; 4531 }; 4532 TView *view = gPad->GetView();; 4533 if (view) {; 4534 if (!Hoption.Lego && !Hoption.Surf && !Hoption.Tri) {; 4535 delete view;; 4536 gPad->SetView(nullptr);; 4537 }; 4538 }; 4539 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) {; 4540 // In case of 1D histogram, Z axis becomes Y axis.; 4541 Int_t logysav=0, logzsav=0;; 4542 if (fH->GetDimension() == 1) {; 4543 logysav = Hoption.Logy;; 4544 logzsav = Hoption.Logz;; 4545 Hoption.Logz = 0;; 4546 if (Hoption.Logy) {; 4547 Hoption.Logz = 1;; 4548 Hoption.Logy = 0;; 4549 }; 4550 }; 4551 PaintTable(option);; 4552 if (Hoption.Func) {; 4553 Hoption_t hoptsave = Hoption;; 4554 Hparam_t hparsave = Hparam;; 4555 PaintFunction(option);; 4556 SetHistogram(hsave);; 4557 Hoption = hoptsave;; 4558 Hparam = hparsave;; 4559 }; 4560 fH->SetMinimum(minsav);; 4561 gCurrentHist = oldhist;; 4562 fXbuf.clear();; 4563 fYbuf.clear();; 4564 if (fH->GetDimension() == 1) {; 4565 Hoption.Logy = logysav;; 4566 Hoption.Logz = logzsav;; 4567 }; 4568 return;; 4569 }; 4570 ; 4571 if (Hoption.Bar >= 20) {; 4572 PaintBarH(option);; 4573 fXbuf.clear();; 4574 fYbuf.clear();; 4575 return;; 4576 }; 4577 ; 4578 gPad->RangeAxisChanged(); //emit RangeAxisChanged() signal to sync axes; 4579 // fill Hparam structure with histo parameters; 4580 if (!PaintInit()) {; 4581 fXbuf.clear();; 4582 fYbuf.clear();; 4583 return;; 4584 }; 4585 ; 4586 // Picture surround (if new page) and page number (if requested).; 4587 // Histogram surround (if not option ""Same"").; 4588 PaintFrame();; 4589 ; 4590 // Paint histogram axis only; 4591 Bool_t gridx = gPad->GetGridx();; 4592 Bool_t gridy = gPad->GetGridy();; 4593 if (Hoption.Axis > 0) {; 4594 if (Hoption.Axis > 1) PaintAxis(kTRUE); //axis with grid; 4595 else {; 4596 if (gridx) gPad->SetGridx(0);; 4597 if (gridy) gPad->SetGridy(0);; 4598 PaintAxis(kFALSE);; 4599 if (gridx) gPad->Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:173159,clear,clear,173159,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['clear'],['clear']
Usability,"veCompositeFrameInMainFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTEveCompositeFrame::AcquireEveWindow(TEveWindow* ew); voidTEveCompositeFrame::ActionPressed(); virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidDestroy(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* si",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveCompositeFrameInMainFrame.html:1553,Clear,Clear,1553,root/html532/TEveCompositeFrameInMainFrame.html,https://root.cern,https://root.cern/root/html532/TEveCompositeFrameInMainFrame.html,4,['Clear'],['Clear']
Usability,"veElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); Float_t*TAttBBox::AssertBBox(); Bool_tAssertCellIdCache() const; TEveRGBAPalette*AssertPalette(); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_tTEveElement::CanEditMainTrans() const; virtual Bool_tTEveElement::CanEditMainTransparency() const; Bool_tCellInEtaPhiRng(TEveCaloData::CellData_t&) const; virtual voidCellSelectionChanged(); virtual voidTEveElement::CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTEveProjectable::ClearProjectedList(); virtual voidTEveElement::ClearStamps(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level = 0) const; virtual TEveElement*TEveElement::CloneElement() const; virtual TEveElement*TEveElement::CloneElementRecurse(Int_t level = 0) const; virtual voidTEveElement::CollectSceneParents(TEveElement::List_t& scenes); virtual voidTEveElement::CollectSceneParentsFromChildren(TEveElement::List_t& scenes, TEveElement* parent); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTAttBBox::ComputeBBox(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTEveElement::CopyVizParams(const TEveElement* el); virtual voidTEveElement::CopyVizParamsFromDB(); voidTEveElement::CSCApplyMainColorToAllChildren(); voidTEveElement::CSCApplyMainColorToMatchingChildren(); voidTEveElement::CSCApplyMainTransparencyToAllChildren()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveCaloViz.html:2540,Clear,Clear,2540,root/html532/TEveCaloViz.html,https://root.cern,https://root.cern/root/html532/TEveCaloViz.html,4,['Clear'],['Clear']
Usability,"veElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveWindowFrame.html:17173,Undo,UndockWindow,17173,root/html534/TEveWindowFrame.html,https://root.cern,https://root.cern/root/html534/TEveWindowFrame.html,4,['Undo'],"['UndockWindow', 'UndockWindowDestroySlot']"
Usability,"veElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; static Pixel_tTEveWindow::fgCurrentBackgroundColor; static Bool_tfgInitInternal; static UInt_tTEveWindow::fgMainFrameDefHeight; static UInt_tTEveWindow::fgMainFrameDefWidth; static Pixel_tTEveWindow::fgMiniBarBackgroundColor; static Bool_tfgRecreateGlOnDockOps. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveViewer(const char* n = ""TEveViewer"", const char* t = """"); Constructor.; The base-class TEveWindowFrame is constructed without a frame so; a default composite-frame is instantiated and stored in fGUIFrame.; Cleanup is set to no-cleanup as viewers need to be zapped with some; more care. ~TEveViewer(); Destructor. void InitInternal(); Initialize static data-members according to running conditions. void PreUndock(); Virtual function called before a window is undocked.; On mac we have to force recreation of gl-context. void PostDock(); Virtual function called after a window is docked.; On mac we have to force recreation of gl-context. const TGPicture* GetListTreeIcon(Bool_t open = kFALSE); Return TEveViewer icon. void SetGLViewer(TGLViewer* viewer, TGFrame* frame); Set TGLViewer that is represented by this object.; The old gl-viewer is deleted. TGLSAViewer* SpawnGLViewer(TGedEditor* ged = 0, Bool_t stereo = kFALSE); Spawn new GLViewer and adopt it. TGLEmbeddedViewer* SpawnGLEmbeddedViewer(TGedEditor* ged = 0, Int_t border = 0); Spawn new GLViewer and adopt it. void Redraw(Bool_t resetCameras = kFALSE); Redraw viewer immediately. void SwitchStereo(); Switch stereo mode.; This only works TGLSAViewers and, of course, with stereo support; provided by the OpenGL driver. void AddScene(TEveScene* scene); Add 'scene' to the list of scenes. void RemoveElementLocal(TEveElement* el); Remove element 'el' from the list of child",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveViewer.html:22748,undo,undocked,22748,root/html528/TEveViewer.html,https://root.cern,https://root.cern/root/html528/TEveViewer.html,6,['undo'],['undocked']
Usability,"veRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCLsCleanupThreshold(Double_t th); virtual voidSetConfidenceLevel(Double_t cl); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetInterpolationOption(RooStats::HypoTestInverterResult::InterpolOption_t opt); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetTestSize(Double_t size); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const char* name = 0); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const RooStats::SimpleInterval&); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const RooStats::SimpleInterval& other, const char* name); RooStats::SimpleIntervalRooStats::SimpleInterval::SimpleInterval(const char* name, const RooRealVar& var, Double_t lower, Double_t upper, Double_t cl); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Double_tUpperLimit(); Double_tUpperLimitEstimatedError(); voidUseCLs(bool on = true); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HypoTestInverterResult.html:7199,Simpl,SimpleInterval,7199,root/html602/RooStats__HypoTestInverterResult.html,https://root.cern,https://root.cern/root/html602/RooStats__HypoTestInverterResult.html,2,['Simpl'],['SimpleInterval']
Usability,"veWindow () override;  Destructor. ;  ; void ClearEveFrame ();  Clears eve-frame associated with this window. ;  ; virtual void DestroyWindow ();  Destroy eve-window - replace it with an empty frame-slot. ;  ; virtual void DestroyWindowAndSlot ();  Destroy eve-window and its frame-slot. ;  ; void FlipShowTitleBar ();  ; TEveCompositeFrame * GetEveFrame ();  ; Bool_t GetShowTitleBar () const;  ; Bool_t IsAncestorOf (TEveWindow *win);  Returns true if this is an ancestor of win. ;  ; Bool_t IsCurrent () const;  Returns true if this window is the current one. ;  ; void MakeCurrent ();  Make this window current. ;  ; void NameTitleChanged () override;  Name or title of the window changed - propagate to frames. ;  ; void PopulateEmptyFrame (TEveCompositeFrame *ef);  Populate given frame-slot - intended for initial population of a new slot or low-level window-swapping. ;  ; virtual void PostDock ();  Virtual function called after a window is docked. ;  ; virtual void PreUndock ();  Virtual function called before a window is undocked. ;  ; void ReplaceWindow (TEveWindow *w);  Replace this window with the passed one. ;  ; void SetShowTitleBar (Bool_t x);  Set display state of the title-bar. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void SwapWindow (TEveWindow *w);  Swap frames with the given window. ;  ; void SwapWindowWithCurrent ();  Swap frames with the current window. ;  ; void TitleBarClicked ();  Slot for clicking on the title-bar. ;  ; void UndockWindow ();  Undock the window - put it into a dedicated main-frame. ;  ; void UndockWindowDestroySlot ();  Undock the window - put it into a dedicated main-frame. ;  ;  Public Member Functions inherited from TEveElementList;  TEveElementList (const char *n=""TEveElementList"", const char *t="""", Bool_t doColor=kFALSE, Bool_t doTransparency=kFALSE);  Constructor. ;  ;  TEveElementList (const TEveElementList &e);  Copy constructor. ;  ;  ~TEveElementList () override;  ; Bool_t AcceptElement (TEveElemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveWindowPack.html:2625,undo,undocked,2625,doc/master/classTEveWindowPack.html,https://root.cern,https://root.cern/doc/master/classTEveWindowPack.html,2,['undo'],['undocked']
Usability,"vector< RooNormSetCache > _nsetCache;  ! Normalization/Integration set manager ;  ; std::vector< RooAbsCacheElement * > _object;  ! Payload ;  ; Int_t _size;  ! Actual use ;  ; bool _wired;  ! In wired mode, there is a single payload which is returned always ;  ;  Protected Attributes inherited from RooAbsCache; RooAbsArg * _owner;  Pointer to owning RooAbsArg. ;  . Static Protected Attributes; static bool _clearObsList;  Clear obslist on sterilize? ;  . #include <RooObjCacheManager.h>. Inheritance diagram for RooObjCacheManager:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooObjCacheManager() [1/2]. RooObjCacheManager::RooObjCacheManager ; (; RooAbsArg * ; owner = nullptr, . Int_t ; maxSize = 2, . bool ; clearCacheOnServerRedirect = true, . bool ; allowOptimize = false . ). Constructor of object cache manager for given owner. ; If clearCacheOnServerRedirect is true all cache elements will be cleared when a server redirect is intercepted by the cache manager. This is the default strategy and should only be overridden when you really understand what you're doing as properly implementing server redirect in cache elements can get very complicated, especially if there are (cyclical) reference back to the owning object ; Definition at line 47 of file RooObjCacheManager.cxx. ◆ RooObjCacheManager() [2/2]. RooObjCacheManager::RooObjCacheManager ; (; const RooObjCacheManager & ; other, . RooAbsArg * ; owner = nullptr . ). Copy constructor. ; Definition at line 59 of file RooObjCacheManager.cxx. ◆ ~RooObjCacheManager(). RooObjCacheManager::~RooObjCacheManager ; (; ). override . Destructor. ; Definition at line 71 of file RooObjCacheManager.cxx. Member Function Documentation. ◆ Class(). static TClass * RooObjCacheManager::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooObjCacheManager::Class_Name ; (; ). static . ReturnsName of this ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:7130,clear,clearCacheOnServerRedirect,7130,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,2,['clear'],"['clearCacheOnServerRedirect', 'cleared']"
Usability,"vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(); LM: WARNING: Coverity detects here a false USE_AFTER_FREE for fY and fVyy; the objects are deleted but then re-created immediatly afterwards in; TUnfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: scale factor applied to the background; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); get output error contribution from statistical fluctuations in A; ematrix: output error matrix histogram; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors; data members modified:; fVYAx, fESparse, fEAtV, fErrorAStat. TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2); propagate uncorrelated systematic errors to a covariance matrix; m0,m1 : coefficients (matrices) for propagating the errors. the error matrix is calculated by standard error propagation, where the; derivative of the result vector X wrt the matrix A is given by. dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. where:; the matrices M0 and M1 are arguments to this f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfoldSys.html:20726,clear,clear,20726,root/html528/TUnfoldSys.html,https://root.cern,https://root.cern/root/html528/TUnfoldSys.html,5,"['Clear', 'clear']","['ClearResults', 'clear']"
Usability,"ved class with the appropriated type; of the parameters. void BuildSorter(TString& colName, Int_t firstRow, Int_t numberRows). BuildSorter backs TTableSorter ctor. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression inside of [], only a single integer number allowed !; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the sie of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. void SetSimpleArray(Int_t arraySize, Int_t firstRow, Int_t numberRows); Set some common parameteres for the ""simple"" arrays. ~TTableSorter(); to be documented. Int_t BSearch(valuetype value). Int_t SelectSearch(valuetype value). Int_t BSearch(const void* value) const; to be ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTableSorter.html:16680,simpl,simpleArray,16680,root/html528/TTableSorter.html,https://root.cern,https://root.cern/root/html528/TTableSorter.html,10,['simpl'],['simpleArray']
Usability,"vel"" will be ignored.; calling the function with a negative argument (e.g., ""NoMsg( -1 )"") resets gErrorIgnoreLevel to its previous value. ; Definition at line 1108 of file TTabCom.cxx. ◆ operator=(). TTabCom & TTabCom::operator= ; (; const TTabCom & ; ). privatedelete . ◆ ParseReverse(). int TTabCom::ParseReverse ; (; const char * ; var_str, . int ; start . ). private . Returns the place in the string where to put the \0, starting the search from ""start"". ; Definition at line 2565 of file TTabCom.cxx. ◆ PathIsSpecifiedInFileName(). Bool_t TTabCom::PathIsSpecifiedInFileName ; (; const TString & ; fileName). static . [static utility function]///////////////////////////// ; true if ""fileName""; is an absolute path (""/tmp/a""); is a relative path (""../whatever"", ""./test""); starts with user name (""~/mail""); starts with an environment variable (""$ROOTSYS/bin"") . Definition at line 1088 of file TTabCom.cxx. ◆ RehashAll(). void TTabCom::RehashAll ; (; ). clears and then rebuilds all lists except for user names and system include files. ; Definition at line 415 of file TTabCom.cxx. ◆ RehashClasses(). void TTabCom::RehashClasses ; (; ). Do the class rehash. ; Definition at line 335 of file TTabCom.cxx. ◆ RehashCppDirectives(). void TTabCom::RehashCppDirectives ; (; ). Cpp rehashing. ; Definition at line 344 of file TTabCom.cxx. ◆ RehashEnvVars(). void TTabCom::RehashEnvVars ; (; ). Environemnt variables rehashing. ; Definition at line 353 of file TTabCom.cxx. ◆ RehashFiles(). void TTabCom::RehashFiles ; (; ). Close files. ; Definition at line 362 of file TTabCom.cxx. ◆ RehashGlobalFunctions(). void TTabCom::RehashGlobalFunctions ; (; ). Reload global functions. ; Definition at line 370 of file TTabCom.cxx. ◆ RehashGlobals(). void TTabCom::RehashGlobals ; (; ). Reload globals. ; Definition at line 378 of file TTabCom.cxx. ◆ RehashPragmas(). void TTabCom::RehashPragmas ; (; ). Reload pragmas. ; Definition at line 387 of file TTabCom.cxx. ◆ RehashSysIncFiles(). void TTabCom::Rehas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTabCom.html:17663,clear,clears,17663,doc/master/classTTabCom.html,https://root.cern,https://root.cern/doc/master/classTTabCom.html,1,['clear'],['clears']
Usability,"ven initialization method. ;  ; bool IsTraining () const;  ; void ReadMatrixXML (void *node, const char *name, Matrix_t &matrix);  ; virtual void ResetTraining ();  Reset some training flags after a loop on all batches Some layer (e.g. ;  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetDepth (size_t depth);  ; virtual void SetExtraLayerParameters (const std::vector< Matrix_t > &);  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t &matrix);  ; void WriteTensorToXML (void *node, const char *name, const std::vector< Matrix_t > &tensor);  helper functions for XML ;  . Private Attributes; Architecture_t::ActivationDescriptor_t fActivationDesc;  ; Tensor_t fDerivatives;  activation function gradient ;  ; Scalar_t fDropoutProbability;  Probability that an input is active. ;  ; EActivationFunction fF;  Activation function of the layer. ;  ; Tensor_t fInputActivation;  output of GEMM and input to a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDenseLayer.html:6900,learn,learningRate,6900,doc/master/classTMVA_1_1DNN_1_1TDenseLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDenseLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"ven stable for problems involving for instance 500 variables, 100 inequality conditions and 50 equality conditions .; Enough said about quadratic programming, let's return to our example . Suppose, after a long day of doing physics, you have a look at your investments and realize that an early retirement is not possible, given the returns of your stocks . So what now ? ROOT to the rescue ...; In 1990 Harry Markowitz was awarded the Nobel prize for economics: "" his work provided new tools; for weighing the risks and rewards of different investments and for valuing corporate stocks and bonds"" . In plain English, he developed the tools to balance greed and fear, we want the maximum return with the minimum amount of risk. Our stock portfolio should be at the ""Efficient Frontier"". To quantify better the risk we are willing to take, we define a utility function \( U(x) \). It describes as a function of our total assets \( x \), our ""satisfaction"" . A common choice is \( 1-exp(-k*x) \) (the reason for the exponent will be clear later) . The parameter \( k \) is the risk-aversion factor . For small values of \( k \) the satisfaction is small for small values of \( x \); by increasing \( x \) the satisfaction can still be increased significantly . For large values of \( k \), \( U(x) \) increases rapidly to 1, there is no increase in satisfaction for additional dollars earned .; In summary :; small \( k \) ==> risk-loving investor; large \( k \) ==> risk-averse investor. Suppose we have for nrStocks the historical daily returns \( r = closing_price(n) - closing_price(n-1) \). Define a vector \( x \) of length of \( nrStocks \), which contains the fraction of our money invested in each stock . We can calculate the average daily return \( z \) of our portfolio and its variance using the portfolio covariance Covar :; \( z = r^T x \) and \( var = x^T Covar x \); Assuming that the daily returns have a Normal distribution, \( N(x) \), so will \( z \) with mean \( r^T x \) and varia",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/portfolio_8C.html:2590,clear,clear,2590,doc/master/portfolio_8C.html,https://root.cern,https://root.cern/doc/master/portfolio_8C.html,1,['clear'],['clear']
Usability,"ventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation » Courses » Introductory Tutorials Compiling Your Code (also known as ACLiC). You can run your code as compiled code instead of interpreted. This makes it possible to debug your code, and might give slightly faster code.; Wherever you would specify MyCode.C you can simply specify MyCode.C+ (note the trailing ""+"") and ROOT will start your compiler and load your code as dynamic library. Give it a try with "".x AnalyzeTree.C+"". If you see ""command not found"", ROOT cannot find the compiler in your $PATH / %PATH%.; . ‹ Fit Panel; up; Accessing a TTree With a TSelector ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/compiling-your-code-also-known-aclic.html:3040,guid,guidelines,3040,d/compiling-your-code-also-known-aclic.html,https://root.cern,https://root.cern/d/compiling-your-code-also-known-aclic.html,1,['guid'],['guidelines']
Usability,"ventions; Class definition conventions. Inline; Declaration Order. Avoid raw C types; Exception handling; Namespaces; Using comments to document the code; Source file layout. Header file layout; Implementation file layout. Preferred Coding Style. Indentation; Placing Braces and Spaces. ClangFormat; Astyle; Where to go from here. Naming conventions; For naming conventions we follow the Taligent rules. They have written a very large body of C++ and their rules seem well thought out. No need to invent something new. The only addition/change we made is to append an _t to typedefs and simple structs, e.g.:; typedef int Int_t ; struct Simple_t { ..... } ; ; Addherence to the rules is mandatory. After a while one really gets used to the fact that all class fields start with an f followed by a capitalized word, fEnergy, or that TStreamerInfo is a class. If the convention is sporadically violated debugging becomes a nightmare. The usage of a standard begin letter or token for the different types also makes it easy to parse and search the code using simple tools.; Class definition conventions; Also here the Taligent guide is quite reasonable. Of course, no class data member should ever be public. Make the data fields always private. Or protected, if you want to grant an inherited class direct access.; Inline; Add trivial get or setters directly in the class definition. This improves reading time since one does not have to look for it somewhere else. Add more complex inlines (longer than one line) at the bottom of the .h file. Creating separate .icc files increases the build time, the complexity of the build system and, more importantly, increases the number of files one possibly has to scan to find a piece of code.; Declaration Order; In the class definition we first declare all private data members, followed by the private static members, the private methods and the private static methods. Then the protected members and methods and finally the public methods (no public data ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/coding-conventions.html:2953,simpl,simple,2953,d/coding-conventions.html,https://root.cern,https://root.cern/d/coding-conventions.html,1,['simpl'],['simple']
Usability,"vents from CMS OpenData containing muon candidates part of 2012 dataset (DOI: 10.7483/OPENDATA.CMS.YLIC.86ZZ and DOI: 10.7483/OPENDATA.CMS.M5AD.Y3V3). The macro matches muon pairs and produces an histogram of the dimuon mass spectrum showing resonances up to the Z mass. Note that the bump at 30 GeV is not a resonance but a trigger effect.; More details about the dataset can be found on the CERN Open Data portal. ; #include ""ROOT/RDataFrame.hxx""; #include ""ROOT/RDFHelpers.hxx""; #include ""ROOT/RVec.hxx""; #include ""TCanvas.h""; #include ""TH1D.h""; #include ""TLatex.h""; #include ""TStyle.h""; ; using namespace ROOT::VecOps;; ; void df102_NanoAODDimuonAnalysis(); {; // Enable multi-threading; ROOT::EnableImplicitMT();; ; // Create dataframe from NanoAOD files; ROOT::RDataFrame df(""Events"", ""root://eospublic.cern.ch//eos/opendata/cms/derived-data/AOD2NanoAODOutreachTool/""; ""Run2012BC_DoubleMuParked_Muons.root"");; ; // Add ProgressBar; ROOT::RDF::Experimental::AddProgressBar(df);; ; // For simplicity, select only events with exactly two muons and require opposite charge; auto df_2mu = df.Filter(""nMuon == 2"", ""Events with exactly two muons"");; auto df_os = df_2mu.Filter(""Muon_charge[0] != Muon_charge[1]"", ""Muons with opposite charge"");; ; // Compute invariant mass of the dimuon system; auto df_mass = df_os.Define(""Dimuon_mass"", InvariantMass<float>, {""Muon_pt"", ""Muon_eta"", ""Muon_phi"", ""Muon_mass""});; ; // Make histogram of dimuon mass spectrum. Note how we can set title and axis labels in one go; auto h = df_mass.Histo1D({""Dimuon_mass"", ""Dimuon mass;m_{#mu#mu} (GeV);N_{Events}"", 30000, 0.25, 300}, ""Dimuon_mass"");; ; // Request cut-flow report; auto report = df.Report();; ; // Produce plot; gStyle->SetOptStat(0); gStyle->SetTextFont(42);; auto c = new TCanvas(""c"", """", 800, 700);; c->SetLogx(); c->SetLogy();; ; h->GetXaxis()->SetTitleSize(0.04);; h->GetYaxis()->SetTitleSize(0.04);; h->DrawClone();; ; TLatex label; label.SetNDC(true);; label.DrawLatex(0.175, 0.740, ""#eta"");; label.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html:1443,simpl,simplicity,1443,doc/master/df102__NanoAODDimuonAnalysis_8C.html,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html,1,['simpl'],['simplicity']
Usability,"vents, . std::function< void(unsigned int, T &)> ; callback . ). inline . Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result. ; Parameters. [in]everyNEventsFrequency at which the callback will be called by each thread, as a number of events processed ; [in]callbackA callable with signature void(unsigned int, Value_t&) where Value_t is the type of the value contained in this RResultPtr . Returnsthis RResultPtr, to allow chaining of OnPartialResultSlot with other calls; See OnPartialResult for a generic explanation of the callback mechanism. Compared to OnPartialResult, this method has two major differences:; all worker threads invoke the callback once every specified number of events. The event count is per-thread, and callback invocation might happen concurrently (i.e. the callback must be thread-safe); the callable must take an extra unsigned int parameter corresponding to a multi-thread ""processing slot"": this is a ""helper value"" to simplify writing thread-safe callbacks: different worker threads might invoke the callback concurrently but always with different slot numbers.; a value of 0 for everyNEvents indicates the callback must be executed once per slot. For example, the following snippet prints out a thread-safe progress bar of the events processed by RDataFrame auto c = tdf.Count(); // any action would do, but `Count` is the most lightweight; std::string progress;; std::mutex bar_mutex;; c.OnPartialResultSlot(nEvents / 100, [&progress, &bar_mutex](unsigned int, ULong64_t &) {; std::lock_guard<std::mutex> lg(bar_mutex);; progress.push_back('#');; std::cout << ""\r["" << std::left << std::setw(100) << progress << ']' << std::flush;; });; std::cout << ""Analysis running..."" << std::endl;; *c; // trigger the event loop by accessing an action's result; std::cout << ""\nDone!"" << std::endl;; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70. Definition at line 364 of file RResultPtr.hxx. ◆ o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html:12883,simpl,simplify,12883,doc/master/classROOT_1_1RDF_1_1RResultPtr.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html,1,['simpl'],['simplify']
Usability,"ver a faster but more; difficult to maintain code. Nevertheless, the time penalty does not; exceed a factor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being; linear for output neurons or a sigmoid for hidden layers. This is; useful because of two theorems:. A linear combination of sigmoids can approximate any; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, devided by two, of the error on each individual output; neuron.; In all methods implemented, one needs to compute; the first derivative of that error with respect to the weights.; Exploiting the well-known properties of the derivative, especialy the; derivative of compound functions, one can write:. for a neuton: product of the local derivative with the; weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented.; Stochastic minimization: This; is the most trivial learning method. This is the Robbins-Monro; stochastic approximation applied to multilayer perceptrons. The; weights are updated after each example according to the formula:; $w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:3546,learn,learning,3546,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,10,['learn'],['learning']
Usability,"ver, const char *slot);  Create connection between sender and receiver. ;  . Protected Attributes; TGCompositeFrame * f10;  Contains the Bar Option Title. ;  ; TGCompositeFrame * f11;  Contains the Bar Width/Offset NumberEntries. ;  ; TGCompositeFrame * f12;  Contains fPercentCombo, fMakeHBar. ;  ; TGCompositeFrame * f15;  Contains outer line CheckBox. ;  ; TGCompositeFrame * f3;  Contains Histogram Type. ;  ; TGCompositeFrame * f6;  Contains the Add-ComboBox (Style) ;  ; TGCompositeFrame * f7;  Contains the Marker OnOff CheckBox. ;  ; TGCompositeFrame * f8;  Contains the Bar Chart CheckBox. ;  ; TGCompositeFrame * f9;  Contains the Bar Option CheckBox. ;  ; TGCheckButton * fAdd;  Activate more Options. ;  ; TGCheckButton * fAddB;  Draw a Bar Chart. ;  ; TGCheckButton * fAddBar;  Bar Option. ;  ; TGComboBox * fAddCombo;  Add Lines, Bars, Fill. ;  ; TGCheckButton * fAddMarker;  Draw a Marker on top of each bin. ;  ; TGCheckButton * fAddSimple;  Draw a simple histogram (==HIST draw option) ;  ; TGTextButton * fApply;  Apply-Button to accept the rebinned histogram. ;  ; TGNumberEntry * fBarOffset;  Change the Bar Offset. ;  ; TGNumberEntry * fBarWidth;  Change the Bar Width. ;  ; TGCompositeFrame * fBin;  Contains the Binning Widgets. ;  ; TGCompositeFrame * fBinCont;  Contains the Rebin Widgets for case 1. ;  ; TGCompositeFrame * fBinCont1;  Contains the Rebin Widgets for case 2. ;  ; TGNumberEntryField * fBinNumberEntry;  Label which shows the rebinned bin number. ;  ; TGNumberEntryField * fBinNumberEntry1;  Label which shows the rebinned bin number for ntuple histogram. ;  ; TGHSlider * fBinOffsetSld;  Add an offset to the origin of the histogram. ;  ; TGHSlider * fBinSlider;  Slider to set rebinning integer value. ;  ; TGHSlider * fBinSlider1;  Slider to set rebinning integer value for ntuple histogram. ;  ; TGTextButton * fCancel;  Cancel-Button to reprobate the rebinned histogram. ;  ; TGComboBox * fCoordsCombo;  Coordinate System combo box. ;  ; TGCheckButton * f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1Editor.html:33201,simpl,simple,33201,doc/master/classTH1Editor.html,https://root.cern,https://root.cern/doc/master/classTH1Editor.html,1,['simpl'],['simple']
Usability,"verFromNaNStrength ; (; double ; strength). Try to recover from invalid function values. ; When invalid function values are encountered, a penalty term is returned to the minimiser to make it back off. This sets the strength of this penalty. NoteA strength of zero is equivalent to a constant penalty (= the gradient vanishes, ROOT < 6.24). Positive values lead to a gradient pointing away from the undefined regions. Use ~10 to force the minimiser away from invalid function values. ; Definition at line 802 of file RooMinimizer.cxx. ◆ setStrategy(). void RooMinimizer::setStrategy ; (; int ; istrat). Change MINUIT strategy to istrat. ; Accepted codes are 0,1,2 and represent MINUIT strategies for dealing most efficiently with fast FCNs (0), expensive FCNs (2) and 'intermediate' FCNs (1) ; Definition at line 189 of file RooMinimizer.cxx. ◆ setVerbose(). void RooMinimizer::setVerbose ; (; bool ; flag = true). inline . Definition at line 153 of file RooMinimizer.h. ◆ simplex(). int RooMinimizer::simplex ; (; ). Execute SIMPLEX. ; Changes in parameter values and calculated errors are automatically propagated back the RooRealVars representing the floating parameters in the MINUIT operation. ; Definition at line 453 of file RooMinimizer.cxx. ◆ Streamer(). void RooMinimizer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void RooMinimizer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 247 of file RooMinimizer.h. ◆ update(). bool RooMinimizer::update ; (; bool ; isValid). private . Definition at line 1100 of file RooMinimizer.cxx. ◆ updateErrors(). void RooMinimizer::updateErrors ; (; ). private . Definition at line 1129 of file RooMinimizer.cxx. ◆ updateFitConfig(). void RooMinimizer::updateFitConfig ; (; ). private . Definition at line 1013 of file RooMinimizer.cxx. ◆ updateMinimizerOptions(). bool RooMinimizer::updateMinimizerOptions ; (; boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMinimizer.html:29581,simpl,simplex,29581,doc/master/classRooMinimizer.html,https://root.cern,https://root.cern/doc/master/classRooMinimizer.html,1,['simpl'],['simplex']
Usability,"verride;  ; Int_t SavePartialResults (Bool_t queryend=kFALSE, Bool_t force=kFALSE) override;  Save the partial results of this query to a dedicated file under the user data directory. ;  ; void SetCurrentQuery (TQueryResult *q) override;  Set current query and save previous value. ;  ; void SetDispatchTimer (Bool_t on=kTRUE) override;  Enable/disable the timer to dispatch pening events while processing. ;  ; void SetDrawFeedbackOption (TDrawFeedback *f, Option_t *opt) override;  Set draw feedback option. ;  ; void SetExitStatus (EExitStatus st) override;  ; void SetInitTime () override;  ; void SetMaxDrawQueries (Int_t max) override;  ; void SetMerging (Bool_t=kTRUE) override;  ; void SetOutputFilePath (const char *fp) override;  ; void SetProcessing (Bool_t on=kTRUE);  Set processing bit according to 'on'. ;  ; void SetStopTimer (Bool_t on=kTRUE, Bool_t abort=kFALSE, Int_t timeout=0) override;  Enable/disable the timer to stop/abort processing. ;  ; virtual void StopFeedback ();  Stop feedback (may not be used in this class). ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1) override;  Stop the process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback list (may not be used in this class). ;  ; void StoreOutput (TList *out) override;  Store output list (may not be used in this class). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UpdateAutoBin (const char *name, Double_t &xmin, Double_t &xmax, Double_t &ymin, Double_t &ymax, Double_t &zmin, Double_t &zmax) override;  Update automatic binning parameters for given object ""name"". ;  ; void UpdateProgressInfo () override;  Update fProgressStatus. ;  ;  Public Member Functions inherited from TVirtualProofPlayer;  TVirtualProofPlayer ();  ;  ~TVirtualProofPlayer () override;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:7508,feedback,feedback,7508,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['feedback'],['feedback']
Usability,"verridevirtual . Paint a simple box. ; Implements TVirtualPadPainter.; Definition at line 390 of file TPadPainter.cxx. ◆ DrawFillArea() [1/2]. void TPadPainter::DrawFillArea ; (; Int_t ; n, . const Double_t * ; x, . const Double_t * ; y . ). overridevirtual . Paint filled area. ; Implements TVirtualPadPainter.; Definition at line 411 of file TPadPainter.cxx. ◆ DrawFillArea() [2/2]. void TPadPainter::DrawFillArea ; (; Int_t ; n, . const Float_t * ; x, . const Float_t * ; y . ). overridevirtual . Paint filled area. ; Implements TVirtualPadPainter.; Definition at line 425 of file TPadPainter.cxx. ◆ DrawLine(). void TPadPainter::DrawLine ; (; Double_t ; x1, . Double_t ; y1, . Double_t ; x2, . Double_t ; y2 . ). overridevirtual . Paint a simple line. ; Implements TVirtualPadPainter.; Definition at line 360 of file TPadPainter.cxx. ◆ DrawLineNDC(). void TPadPainter::DrawLineNDC ; (; Double_t ; u1, . Double_t ; v1, . Double_t ; u2, . Double_t ; v2 . ). overridevirtual . Paint a simple line in normalized coordinates. ; Implements TVirtualPadPainter.; Definition at line 375 of file TPadPainter.cxx. ◆ DrawPixels(). void TPadPainter::DrawPixels ; (; const unsigned char * ; pixelData, . UInt_t ; width, . UInt_t ; height, . Int_t ; dstX, . Int_t ; dstY, . Bool_t ; enableAlphaBlending . ). overridevirtual . Noop, for non-gl pad TASImage calls gVirtualX->CopyArea. ; Implements TVirtualPadPainter.; Definition at line 351 of file TPadPainter.cxx. ◆ DrawPolyLine() [1/2]. void TPadPainter::DrawPolyLine ; (; Int_t ; n, . const Double_t * ; x, . const Double_t * ; y . ). overridevirtual . Paint Polyline. ; Implements TVirtualPadPainter.; Definition at line 438 of file TPadPainter.cxx. ◆ DrawPolyLine() [2/2]. void TPadPainter::DrawPolyLine ; (; Int_t ; n, . const Float_t * ; x, . const Float_t * ; y . ). overridevirtual . Paint polyline. ; Implements TVirtualPadPainter.; Definition at line 454 of file TPadPainter.cxx. ◆ DrawPolyLineNDC(). void TPadPainter::DrawPolyLineNDC ; (; Int_t ; n, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPadPainter.html:9165,simpl,simple,9165,doc/master/classTPadPainter.html,https://root.cern,https://root.cern/doc/master/classTPadPainter.html,1,['simpl'],['simple']
Usability,"verridevirtual . Return the sizeof the collection object. ; Implements TVirtualCollectionProxy.; Definition at line 1014 of file TGenCollectionProxy.cxx. ◆ Streamer() [1/2]. void TGenCollectionProxy::Streamer ; (; TBuffer & ; refBuffer). virtual . Streamer Function. ; Reimplemented in TEmulatedCollectionProxy, TEmulatedMapProxy, and TGenCollectionStreamer.; Definition at line 1427 of file TGenCollectionProxy.cxx. ◆ Streamer() [2/2]. void TGenCollectionProxy::Streamer ; (; TBuffer & ; refBuffer, . void * ; pObject, . int ; siz . ). virtual . Streamer I/O overload. ; Reimplemented in TEmulatedCollectionProxy, TEmulatedMapProxy, and TGenCollectionStreamer.; Definition at line 1439 of file TGenCollectionProxy.cxx. Friends And Related Symbol Documentation. ◆ TCollectionProxyFactory. friend class TCollectionProxyFactory. friend . Definition at line 34 of file TGenCollectionProxy.h. Member Data Documentation. ◆ fClear. Method TGenCollectionProxy::fClear. protected . Method cache for container accessors: clear container. ; Definition at line 301 of file TGenCollectionProxy.h. ◆ fCollect. Collectfunc_t TGenCollectionProxy::fCollect. protected . Method to collect objects from container. ; Definition at line 309 of file TGenCollectionProxy.h. ◆ fConstruct. ArrIterfunc_t TGenCollectionProxy::fConstruct. protected . Container accessors: block construct. ; Definition at line 306 of file TGenCollectionProxy.h. ◆ fConversionReadMemberWise. std::map<std::string, TObjArray*>* TGenCollectionProxy::fConversionReadMemberWise. mutableprotected . Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ; Definition at line 292 of file TGenCollectionProxy.h. ◆ fCreateEnv. Method0 TGenCollectionProxy::fCreateEnv. protected . Method to allocate an Environment holder. ; Definition at line 310 of file TGenCollectionProxy.h. ◆ fDestruct. Sizing_t TGenCollectionProxy::fDestruct. protected . Container accessors: block destruct. ; Definition at line 307 of file TGenC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:27160,clear,clear,27160,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['clear'],['clear']
Usability,"versity of Bonn in Germany. He worked in ATLAS to improve the sensitivity in the search for Higgs --> bb decays. His main focus was on analysis frameworks, machine learning, systematic uncertainties and statistical models.; He joined the ROOT team in 2018 to support and improve RooFit. He further looks into math and statistics, as well as into questions regarding performance and programming model.; ; . Vassil Vassilev ; ; Vassil graduated from the University of Plovdiv ""Paisii Hilendarski"", Bulgaria. He received a MSc in Software Technologies and a PhD in Computer Science with specialization in programming languages and visual programming. He joined the ROOT team in 2010, authoring Cling - the interactive, LLVM-based C++ interpreter. He was one of the core engineers involved in ROOT6.; Vassil is responsible for the implementation and adoption of clang's C++ modules (PCMs) in ROOT. He also helps with interpreter and reflection related activities in the ROOT project. He works on the CMS interests in the ROOT collaboration including development, trouble shooting, and any other activities as may be required.   ; From January, 2017, Vassil is employed by Princeton University and part of the Princeton Intel Parallel Computing Center (IPCC) project, which focuses on code modernization in ROOT.;  ; ; . Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/team.html:11523,guid,guidelines,11523,d/team.html,https://root.cern,https://root.cern/d/team.html,1,['guid'],['guidelines']
Usability,"very specification document. Short overview:. If the BEARER_TOKEN environment variable is set, then the value is taken to be the token contents.; If the BEARER_TOKEN_FILE environment variable is set, then its value is interpreted as a filename. The contents of the specified file are taken to be the token contents.; If the XDG_RUNTIME_DIR environment variable is set, then take the token from the contents of $XDG_RUNTIME_DIR/bt_u$ID(this additional location is intended to provide improved security for shared login environments as $XDG_RUNTIME_DIR is defined to be user-specific as opposed to a system-wide directory.).; Otherwise, take the token from /tmp/bt_u$ID. Xrootd client support; ROOT can now be built with Xrootd 5 client libraries.; GUI Libraries; RBrowser improvements. central factory methods to handle browsing, editing and drawing of different classes; simple possibility to extend RBrowser on user-defined classes; support of web-based geometry viewer; better support of TTree drawing; server-side handling of code editor and image viewer widgets; rbrowser content is fully recovered when web-browser is reloaded; load of widgets code only when really required (shorter startup time for RBrowser). JavaScript ROOT; Major JSROOT update to version 6. update all used libraries d3.js, three.js, MathJax.js, openui5; change to Promise based interface for all async methods, remove call-back arguments; change scripts names, core scripts name now JSRoot.core.js; unify function/methods naming conventions, many changes in method names; provide central code loader via JSROOT.require, supporting 4 different loading engines; many nice features and many bug fixes; see JSROOT v6 release notes. Class Reference Guide; One can now select a class’s documentation for a specific version. If a class does not exist in a given version, that version is grayed out, see for instance the documentation for ROOT::Experimental::RNTupleReader.; Build, Configuration and Testing Infrastructure. a new ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:28226,simpl,simple,28226,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['simpl'],['simple']
Usability,"ves implementation class using GSL ;  CGSLRootFinderBase class for GSL Root-Finding algorithms for one dimensional functions which do not use function derivatives ;  CGSLRootFinderDerivBase class for GSL Root-Finding algorithms for one dimensional functions which use function derivatives ;  CGSLRootFSolverRoot-Finder implementation class using GSL ;  CGSLSimAnFuncGSLSimAnFunc class description ;  CGSLSimAnMinimizerGSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL ;  CGSLSimAnnealingGSLSimAnnealing class for performing a simulated annealing search of a multidimensional function ;  CGSLSimAnParamsStructure holding the simulated annealing parameters ;  CGSLVegasIntegrationWorkspaceWorkspace for VEGAS ;  CIBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim ;  CIBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evaluate the function given a value (simple double) by implementing operator() (const double ) ;  CIBaseParamDocumentation for the abstract class IBaseParam ;  CIGradientFunctionMultiDimInterface (abstract class) for multi-dimensional functions providing a gradient calculation ;  CIGradientFunctionOneDimInterface (abstract class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxiliary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integratio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:38037,simpl,simple,38037,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['simpl'],['simple']
Usability,"ves implementation class using GSL ;  CGSLRootFinderBase class for GSL Root-Finding algorithms for one dimensional functions which do not use function derivatives ;  CGSLRootFinderDerivBase class for GSL Root-Finding algorithms for one dimensional functions which use function derivatives ;  CGSLRootFSolverRoot-Finder implementation class using GSL ;  CGSLSimAnFuncGSLSimAnFunc class description ;  CGSLSimAnMinimizerGSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL ;  CGSLSimAnnealingGSLSimAnnealing class for performing a simulated annealing search of a multidimensional function ;  CGSLSimAnParamsStructure holding the simulated annealing parameters ;  CGSLVegasIntegrationWorkspaceWorkspace for VEGAS ;  CIBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim ;  CIBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evaluate the function given a value (simple double) by implementing operator() (const double ) ;  CIBaseParamDocumentation for the abstract class IBaseParam ;  CIGradientFunctionMultiDimTemplInterface (abstract class) for multi-dimensional functions providing a gradient calculation ;  CIGradientFunctionOneDimInterface (abstract class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimTemplGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxiliary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:43667,simpl,simple,43667,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,4,['simpl'],['simple']
Usability,"ves; TSeqCollection*fpEnvVars; TSeqCollection*fpFiles; TSeqCollection*fpGlobalFuncs; TSeqCollection*fpGlobals; int*fpLocinitialized by Hook(); TSeqCollection*fpNamespacesContains the names of namespaces registered in CINT.; TSeqCollection*fpPragmas; TSeqCollection*fpSysIncFiles; TSeqCollection*fpUsers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTabCom(); Default constructor. ~TTabCom(); Destructor. void ClearClasses(); Clear classes and namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far. void ClearGlobals(); Forget all global variables seen so far. void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. const TSeqCollection * GetListOfCppDirectives(); Return the list of CPP directives. const TSeqCollection * GetListOfFilesInPath(const char* path); ""path"" should be initialized with a colon separated list of; system directories. const TSeqCollection * GetListOfEnvVars(); Uses ""env"" (Unix) or ""set"" (Windows) to get list of environment variables. const TSeqCollection * GetListOfGlobals(); Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTabCom.html:7453,clear,clears,7453,root/html528/TTabCom.html,https://root.cern,https://root.cern/root/html528/TTabCom.html,8,"['Clear', 'clear']","['ClearAll', 'clears']"
Usability,"vevoid SetIpythonInteractive(IPythonInteractive *fI, bool *fE, UInt_t *M, UInt_t *C)Definition NeuralNet.h:1283; TMVA::DNN::Net::computestd::vector< double > compute(const std::vector< double > &input, const Weights &weights) constcompute the net with the given input and the given weightsDefinition NeuralNet.icc:1037; TMVA::DNN::Net::container_typestd::vector< double > container_typeDefinition NeuralNet.h:1065; TMVA::DNN::Net::iterator_typecontainer_type::iterator iterator_typeDefinition NeuralNet.h:1066; TMVA::DNN::Net::preTrainvoid preTrain(std::vector< double > &weights, std::vector< Pattern > &trainPattern, const std::vector< Pattern > &testPattern, Minimizer &minimizer, Settings &settings)pre-training for future use; TMVA::DNN::Net::fetchOutputvoid fetchOutput(const LayerData &lastLayerData, OutputContainer &outputContainer) constDefinition NeuralNet.icc:1291; TMVA::DNN::Net::inputSizesize_t inputSize() constinput size of the DNNDefinition NeuralNet.h:1098; TMVA::DNN::Net::clearvoid clear()Definition NeuralNet.h:1251; TMVA::DNN::Net::begin_end_typestd::pair< iterator_type, iterator_type > begin_end_typeDefinition NeuralNet.h:1067; TMVA::DNN::Net::m_eErrorFunctionModeErrorFunction m_eErrorFunctiondenotes the error functionDefinition NeuralNet.h:1269; TMVA::DNN::Net::dEvoid dE(); TMVA::DNN::Net::addLayervoid addLayer(Layer &&layer)Definition NeuralNet.h:1095; TMVA::DNN::Net::numNodessize_t numNodes(size_t trainingStartLayer=0) constreturns the number of nodes in this netDefinition NeuralNet.cxx:556; TMVA::DNN::Net::traindouble train(std::vector< double > &weights, std::vector< Pattern > &trainPattern, const std::vector< Pattern > &testPattern, Minimizer &minimizer, Settings &settings)start the trainingDefinition NeuralNet.icc:712; TMVA::DNN::Net::layersconst std::vector< Layer > & layers() constreturns the layers (structure)Definition NeuralNet.h:1245; TMVA::DNN::Net::prepareLayerDatastd::vector< std::vector< LayerData > > prepareLayerData(LayerContainer &layers,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:66410,clear,clearvoid,66410,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,2,['clear'],"['clear', 'clearvoid']"
Usability,"vex polygon.; Both the X3D and OpenGL renderers expect polygons to be convex.; The OpenGL spec specifies that points defining a polygon using the; GL_POLYGON primitive may be rendered as the convex hull of that set. Solid rendering under X3D can also give unexpected artifacts if; the combination of x-y-z offsets and scales for the segments are; chosen in such a manner that they represent a concave shape when; sliced along a plane parallel to the z axis. Choosing sets of point that represent a malformed polygon is; not supported, but testing for such a condition is not implemented; and thus it is left to the user to avoid this mistake. . Function Members (Methods); public:. TXTRU(); TXTRU(const TXTRU& xtru); TXTRU(const char* name, const char* title, const char* material, Int_t nyx, Int_t nz); virtual~TXTRU(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& xtru) const; virtual voidDefineSection(Int_t secNum, Float_t z, Float_t scale = 1., Float_t x0 = 0., Float_t y0 = 0.); virtual voidDefineVertex(Int_t pointNum, Float_t x, Float_t y); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXTRU.html:2482,Clear,Clear,2482,root/html532/TXTRU.html,https://root.cern,https://root.cern/root/html532/TXTRU.html,2,['Clear'],['Clear']
Usability,"ve” objects, which mean they are reordered to be on top of the others. To interactively make an object “active”, you can use the middle mouse button. In case of canvases or pads, the border becomes highlighted when it is active.; 9.2.2.2 With C++ Statements (Programmatically); Frequently we want to draw in different canvases or pads. By default, the objects are drawn in the active canvas. To activate a canvas you can use the TPad::cd() method.; root[] c1->cd(); 9.2.3 Context Menus: the Right Mouse Button; The context menus are a way to interactively call certain methods of an object. When designing a class, the programmer can add methods to the context menu of the object by making minor changes to the header file.; 9.2.3.1 Using Context Menus; On a ROOT canvas, you can right-click on any object and see the context menu for it. The script hsimple.C draws a histogram. The image below shows the context menus for some of the objects on the canvas. Next picture shows that drawing a simple histogram involves as many as seven objects. When selecting a method from the context menu and that method has options, the user will be asked for numerical values or strings to fill in the option. For example, TAxis::SetTitle will prompt you for a string to use for the axis title. Context menus of different objects in a canvas. 9.2.3.2 Structure of the Context Menus; The curious reader will have noticed that each entry in the context menu corresponds to a method of the class. Look for example to the menu named TAxis::xaxis. xaxis is the name of the object and TAxis the name of its class. If we look at the list of TAxis methods, for example in https://root.cern/doc/master/classTAxis.html, we see the methods SetTimeDisplay() andUnZoom(), which appear also in the context menu.; There are several divisions in the context menu, separated by lines. The top division is a list of the class methods; the second division is a list of the parent class methods. The subsequent divisions are the meth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:294268,simpl,simple,294268,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"via a message. ;  ; virtual Int_t Echo (const TObject *obj);  Sends an object to master and workers and expect them to send back a message with the output of its TObject::Print(). ;  ; Int_t EnablePackage (const char *package, Bool_t notOnClient=kFALSE, TList *workers=0);  Enable specified package. ;  ; Int_t EnablePackage (const char *package, const char *loadopts, Bool_t notOnClient=kFALSE, TList *workers=0);  Enable specified package. ;  ; Int_t EnablePackage (const char *package, TList *loadopts, Bool_t notOnClient=kFALSE, TList *workers=0);  Enable specified package. ;  ; Int_t Exec (const char *cmd, Bool_t plusMaster=kFALSE);  Send command to be executed on the PROOF master and/or slaves. ;  ; Int_t Exec (const char *cmd, const char *ord, Bool_t logtomacro=kFALSE);  Send command to be executed on node of ordinal 'ord' (use ""0"" for master). ;  ; virtual Bool_t ExistsDataSet (const char *dataset);  Returns kTRUE if 'dataset' exists, kFALSE otherwise. ;  ; void Feedback (TList *objs);  Get list of feedback objects. ;  ; Long64_t Finalize (const char *queryref, Bool_t force=kFALSE);  Finalize query with reference ref. ;  ; Long64_t Finalize (Int_t query=-1, Bool_t force=kFALSE);  Finalize the qry-th query in fQueries. ;  ; TList * FindDataSets (const char *searchString, const char *optStr="""");  Find datasets, returns in a TList all found datasets. ;  ; Long64_t GetBytesRead () const;  ; Int_t GetClientProtocol () const;  ; const char * GetConfDir () const;  ; const char * GetConfFile () const;  ; Float_t GetCpuTime () const;  ; const char * GetDataPoolUrl () const;  ; virtual TFileCollection * GetDataSet (const char *dataset, const char *optStr="""");  Get a list of TFileInfo objects describing the files of the specified dataset. ;  ; TMap * GetDataSetQuota (const char *optStr="""");  returns a map of the quotas of all groups ;  ; virtual TMap * GetDataSets (const char *uri="""", const char *optStr="""");  Lists all datasets that match given uri. ;  ; TString Getenv (const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:7592,feedback,feedback,7592,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,3,['feedback'],['feedback']
Usability,"vide, which will return an asymmetric and non-zero lower; error for the case b1=b2. void Draw(Option_t* option = """"); -*-*-*-*-*-*-*-*-*Draw this histogram with options*-*-*-*-*-*-*-*-*-*-*-*. Histograms are drawn via the THistPainter class. Each histogram has; a pointer to its own painter (to be usable in a multithreaded program).; The same histogram can be drawn with different options in different pads.; When an histogram drawn in a pad is deleted, the histogram is; automatically removed from the pad or pads where it was drawn.; If an histogram is drawn in a pad, then filled again, the new status; of the histogram will be automatically shown in the pad next time; the pad is updated. One does not need to redraw the histogram.; To draw the current version of an histogram in a pad, one can use; h->DrawCopy();; This makes a clone of the histogram. Once the clone is drawn, the original; histogram may be modified or deleted without affecting the aspect of the; clone.; By default, TH1::Draw clears the current pad. One can use TH1::SetMaximum and TH1::SetMinimum to force a particular; value for the maximum or the minimum scale on the plot. TH1::UseCurrentStyle can be used to change all histogram graphics; attributes to correspond to the current selected style.; This function must be called for each histogram.; In case one reads and draws many histograms from a file, one can force; the histograms to inherit automatically the current graphics style; by calling before gROOT->ForceStyle();. See THistPainter::Paint for a description of all the drawing options. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1 * DrawCopy(Option_t* option = """") const; -*-*-*-*-*Copy this histogram and Draw in the current pad*-*-*-*-*-*-*-*. Once the histogram is drawn into the pad, any further modification; using graphics input will be made on the copy of the histogram,; and not to the original object. See Draw for the list of options. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:60390,clear,clears,60390,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,4,['clear'],['clears']
Usability,"view are present and send signal ""Modified"" to pad. void Paint(Option_t* option = """"); Paint current geometry according to option. void PaintOverlap(void* ovlp, Option_t* option = """"); Paint an overlap. void PaintNode(TGeoNode* node, Option_t* option = """", TGeoMatrix* global = 0); Paint recursively a node and its content accordind to visualization options. void PaintVolume(TGeoVolume* vol, Option_t* option = """", TGeoMatrix* global = 0); Paint recursively a node and its content accordind to visualization options. Bool_t PaintShape(const TGeoShape& shape, Option_t* option) const; Paint the supplied shape into the current 3D viewer. void PaintShape(TGeoShape* shape, Option_t* option = """"); Paint an overlap. void PaintPhysicalNode(TGeoPhysicalNode* node, Option_t* option = """"); Paints a physical node associated with a path. void PrintOverlaps() const; Print overlaps (see TGeoChecker::PrintOverlaps()). void OpProgress(const char* opname, Long64_t current, Long64_t size, TStopwatch* watch = 0, Bool_t last = kFALSE, Bool_t refresh = kFALSE, const char* msg = """"); Text progress bar. void RandomPoints(const TGeoVolume* vol, Int_t npoints, Option_t* option = """"); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char* target_vol = 0, Bool_t check_norm = kFALSE); Shoot nrays in the current drawn geometry. void Raytrace(Option_t* option = """"); Raytrace current drawn geometry. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside. void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); --- Set cartesian and radial bomb factors for translations. void SetExplodedView(Int_t iopt = 0); set type of exploding view. void SetNsegments(Int_t nseg = 20); Set number of segments to approximate circles. void SetN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPainter.html:19032,progress bar,progress bar,19032,root/html534/TGeoPainter.html,https://root.cern,https://root.cern/root/html534/TGeoPainter.html,6,['progress bar'],['progress bar']
Usability,"viour; in split or non-split mode. classname does not have to derive from TObject.; The function is based on the new TStreamerInfo. Build a TBranchElement for an object of class classname. addr is the address of a pointer to an object of class classname.; The class dictionary must be available (ClassDef in class header). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addr parameter. This option requires access to the library where the corresponding class; is defined. Accessing one single data member in the object implies; reading the full object. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:53322,simpl,simply,53322,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,2,['simpl'],['simply']
Usability,"viour; in split or non-split mode. classname does not have to derive from TObject.; The function is based on the new TStreamerInfo. Build a TBranchElement for an object of class classname. addr is the address of a pointer to an object of class classname.; The class dictionary must be available (ClassDef in class header). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addr parameter. This option requires access to the library where the corresponding class; is defined. Accessing one single data member in the object implies; reading the full object. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (eg 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:50983,simpl,simply,50983,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['simpl'],['simply']
Usability,"vironment. ;  ; void InitMembers ();  Default initializations. ;  ; virtual Int_t PollForNewWorkers ();  Asks the PROOF Serv for new workers in Dynamic Startup mode and activates them. ;  ; void PrepareInputDataFile (TString &dataFile);  Prepare the file with the input data objects to be sent the master; the objects are taken from the dedicated list and / or the specified file. ;  ; Int_t RemoveWorkers (TList *wrks);  Used for shuting down the workres after a query is finished. ;  ; virtual void SaveWorkerInfo ();  Save information about the worker set in the file .workers in the working dir. ;  ; Int_t SendFile (const char *file, Int_t opt=(kBinary|kForward|kCp|kCpBin), const char *rfile=0, TSlave *sl=0);  Send a file to master or slave servers. ;  ; virtual void SendInputDataFile ();  Send the input data objects to the master; the objects are taken from the dedicated list and / or the specified file. ;  ; void SetDSet (TDSet *dset);  ; void SetFeedback (TString &opt, TString &optfb, Int_t action);  Extract from opt in optfb information about wanted feedback settings. ;  ; void SetPlayer (TVirtualProofPlayer *player);  Set a new PROOF player. ;  ; void SetupWorkersEnv (TList *wrks, Bool_t increasingpool=kFALSE);  Set up packages, loaded macros, include and lib paths ... ;  ; void UpdateDialog ();  Final update of the progress dialog. ;  ; Int_t VerifyDataSetParallel (const char *uri, const char *optStr);  Internal function for parallel dataset verification used TProof::VerifyDataSet and TProofLite::VerifyDataSet. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Friends; class TProofPlayerSuperMaster;  . Additional Inherited Members;  Public Types inherited from TPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofSuperMaster.html:37820,feedback,feedback,37820,doc/master/classTProofSuperMaster.html,https://root.cern,https://root.cern/doc/master/classTProofSuperMaster.html,1,['feedback'],['feedback']
Usability,"virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooStats::SimpleInterval::IsInInterval(const RooArgSet&) const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual Double_tLowerLimit(); Double_tLowerLimitEstimatedError(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::SimpleInterval&RooStats::SimpleInterval::operator=(const RooStats::SimpleInterval&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetConfidenceLevel(Double_t cl); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetInterpolationOption(RooStats::HypoTestInverterResult::InterpolOption_t opt); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HypoTestInverterResult.html:5482,Simpl,SimpleInterval,5482,root/html532/RooStats__HypoTestInverterResult.html,https://root.cern,https://root.cern/root/html532/RooStats__HypoTestInverterResult.html,1,['Simpl'],['SimpleInterval']
Usability,"virtual Int_tTGX11::AddWindow(ULong_t qwid, UInt_t w, UInt_t h); virtual Bool_tTGX11::AllocColor(Colormap_t cmap, ColorStruct_t& color); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualX::BeginModalSessionFor(Window_t window); virtual voidTGX11::Bell(Int_t percent); virtual voidTObject::Browse(TBrowser* b); virtual voidTGX11::ChangeActivePointerGrab(Window_t, UInt_t, Cursor_t); virtual voidTGX11::ChangeGC(GContext_t gc, GCValues_t* gval); virtual voidTGX11::ChangeProperties(Window_t id, Atom_t property, Atom_t type, Int_t format, UChar_t* data, Int_t len); virtual voidTGX11::ChangeProperty(Window_t id, Atom_t property, Atom_t type, UChar_t* data, Int_t len); virtual voidTGX11::ChangeWindowAttributes(Window_t id, SetWindowAttributes_t* attr); virtual Bool_tTGX11::CheckEvent(Window_t id, EGEventType type, Event_t& ev); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGX11::ClearArea(Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGX11::ClearWindow(); virtual voidTGX11::ClearWindow(Window_t id); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTGX11::CloseDisplay(); virtual voidTGX11::ClosePixmap(); virtual voidTGX11::CloseWindow(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGX11::ConvertPrimarySelection(Window_t id, Atom_t clipboard, Time_t when); virtual voidTGX11::ConvertSelection(Window_t, Atom_t&, Atom_t&, Atom_t&, Time_t&); virtual voidTNamed::Copy(TObject& named) const; virtual voidTGX11::CopyArea(Drawable_t src, Drawable_t dest, GContext_t gc, Int_t src_x, Int_t src_y, UInt_t width, UInt_t height, Int_t dest_x, Int_t dest_y); virtual voidTGX11::CopyGC(GContext_t org, GContext_t dest, Mask_t mask); virtual voidTGX11::CopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); virtual Pixmap_tTGX11::CreateBitmap(Drawable_t id, const char* bitmap, UInt_t width, UInt_t height); virtual Cursor_tTGX11::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGX11TTF.html:1855,Clear,ClearArea,1855,root/html534/TGX11TTF.html,https://root.cern,https://root.cern/root/html534/TGX11TTF.html,3,['Clear'],['ClearArea']
Usability,"virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGTable::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGTable::Expand(UInt_t nrows, UInt_t ncolumns); virtual voidTGTable::ExpandColumns(UInt_t ncolumns); virtual voidTGTable::ExpandRows(UInt_t nrows); virtual UInt_tTGTable::GetCHdrWidth() const; static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual UInt_tTGTable::GetRHdrHeight() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTGTable::Init(); voidTObject::MakeZombie(); TGWindow&TGWindow::operator=(const TGWindow& tgw); virtual voidTGTable::ResizeTable(UInt_t nrows, UInt_t ncolumns); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGTable::SetInterface(TVirtualTableInterface* interface, UInt_t nrows = 50, UInt_t ncolumns = 20); virtual voidTGTable::Shrink(UInt_t nrows, UInt_t ncolumns); virtual voidTGTable::ShrinkColumns(UInt_t ncolumns); virtual voidTGTable::ShrinkRows(UInt_t nrows); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE); virtual voidTGTable::UpdateHeaders(EHeaderType type); virtual voidTGTable::UpdateRangeFrame(). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGSimpleTable.html:17452,Clear,ClearFlags,17452,root/html532/TGSimpleTable.html,https://root.cern,https://root.cern/root/html532/TGSimpleTable.html,4,['Clear'],['ClearFlags']
Usability,"virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this infor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:14609,learn,learning,14609,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['learn'],['learning']
Usability,"virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; TClass * IsA () const override;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Long64_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:14610,learn,learning,14610,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['learn'],['learning']
Usability,"virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGetBackground(TH1* bgr, const char* bgrSource = 0, const Int_t* binMap = 0, Int_t includeError = 3, Bool_t clearHist = kTRUE) const; voidTUnfold::GetBias(TH1* bias, const Int_t* binMap = 0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); Bool_tGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); Double_tTUnfold::GetEpsMatrix() const; voidTUnfold::GetFoldedOutput(TH1* folded, const Int_t* binMap = 0) const; virtual const char*TObject::GetIconName() const; voidTUnfold::GetInput(TH1* inputData, const Int_t* binMap = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); voidTUnfold::GetL(TH2* l) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() const; voidTUnfold::GetLsquared(TH2* lsquared) const; virtual const char*TObject::GetName() const; Int_tTUnfold::GetNdf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldSys.html:6047,clear,clearEmat,6047,root/html534/TUnfoldSys.html,https://root.cern,https://root.cern/root/html534/TUnfoldSys.html,6,['clear'],['clearEmat']
Usability,"virtual void computeResult(const Net &, std::vector< double > &)callback for monitoring and loggingDefinition NeuralNet.h:809; TMVA::DNN::Settings::dropRepetitionssize_t dropRepetitions() constDefinition NeuralNet.h:761; TMVA::DNN::Settings::createvoid create(std::string histoName, int bins, double min, double max)for monitoringDefinition NeuralNet.h:819; TMVA::DNN::Settings::startTestCyclevirtual void startTestCycle()callback for monitoring and logggingDefinition NeuralNet.h:804; TMVA::DNN::Steepest::m_repetitionssize_t m_repetitionsDefinition NeuralNet.h:337; TMVA::DNN::Steepest::m_betadouble m_betainternal parameter (momentum)Definition NeuralNet.h:372; TMVA::DNN::Steepest::m_localGradientsstd::vector< double > m_localGradientslocal gradients for reuse in thread.Definition NeuralNet.h:376; TMVA::DNN::Steepest::m_prevGradientsstd::vector< double > m_prevGradientsvector remembers the gradients of the previous stepDefinition NeuralNet.h:373; TMVA::DNN::Steepest::m_alphadouble m_alphainternal parameter (learningRate)Definition NeuralNet.h:371; TMVA::DNN::Steepest::m_localWeightsstd::vector< double > m_localWeightslocal weights for reuse in thread.Definition NeuralNet.h:375; TMVA::DNN::Steepest::operator()double operator()(Function &fitnessFunction, Weights &weights, PassThrough &passThrough)operator to call the steepest gradient descent algorithmDefinition NeuralNet.icc:271; TMVA::IPythonInteractive::AddPointvoid AddPoint(Double_t x, Double_t y1, Double_t y2)This function is used only in 2 TGraph case, and it will add new data points to graphs.Definition MethodBase.cxx:207; TStringBasic string class.Definition TString.h:139; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; double; nconst Int_t nDefinition legend1.C:16; TMVA::DNN::InvGaussstd::shared_ptr< std::function< double(double)> > InvGaussDefinition NeuralNet.cxx:14; TMVA::DNN::su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:70304,learn,learningRate,70304,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['learn'],['learningRate']
Usability,"virtual voidSetValueClass(TClass* newcl); virtual UInt_tSize() const; virtual UInt_tSizeof() const; virtual voidStreamer(TBuffer& refBuffer); virtual voidStreamer(TBuffer& refBuffer, void* pObject, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent). private:. TGenCollectionProxy(); TGenCollectionProxy&operator=(const TGenCollectionProxy&). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; void*fCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCopyIterator; void*fFunctionCreateIterators; void*fFunctionDeleteIterator; void*fFunctionDeleteTwoIterators; void*fFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGenCollectionProxy.html:3995,clear,clear,3995,root/html534/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html,2,['clear'],['clear']
Usability,"virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector& insp) const; virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; TEveWindowFrame(TGFrame* frame, const char* n = ""TEveWindowFrame"", const char* t = """"); voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveWindowFrame.html:17156,Undo,UndockWindow,17156,root/html602/TEveWindowFrame.html,https://root.cern,https://root.cern/root/html602/TEveWindowFrame.html,4,['Undo'],"['UndockWindow', 'UndockWindowDestroySlot']"
Usability,"virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidEmitSignals(Bool_t wasUp = kTRUE); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidInit(); voidTObject::MakeZombie(); voidPSetState(EButtonState state, Bool_t emit); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGButton::SetToggleButton(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGCheckButton(const TGCheckButton&); TGCheckButton&operator=(const TGCheckButton&). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGCheckButton.html:19446,Clear,ClearFlags,19446,root/html532/TGCheckButton.html,https://root.cern,https://root.cern/root/html532/TGCheckButton.html,2,['Clear'],['ClearFlags']
Usability,"virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidEmitSignals(Bool_t wasUp = kTRUE); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidInit(); voidTObject::MakeZombie(); voidPSetState(EButtonState state, Bool_t emit); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGButton::SetToggleButton(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGRadioButton(const TGRadioButton&); TGRadioButton&operator=(const TGRadioButton&). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGRadioButton.html:19436,Clear,ClearFlags,19436,root/html532/TGRadioButton.html,https://root.cern,https://root.cern/root/html532/TGRadioButton.html,2,['Clear'],['ClearFlags']
Usability,"virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TUnfoldSys(const TUnfoldSys&); TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTUnfold::AddMSparse(TMatrixDSparse* dest, Double_t f, const TMatrixDSparse* src) const; Bool_tTUnfold::AddRegularisationCondition(Int_t nEle, const Int_t* indices, const Double_t* rowData); Bool_tTUnfold::AddRegularisationCondition(Int_t i0, Double_t f0, Int_t i1 = -1, Double_t f1 = 0., Int_t i2 = -1, Double_t f2 = 0.); voidTUnfold::ClearHistogram(TH1* h, Double_t x = 0.) const; virtual voidClearResults(); TMatrixDSparse*TUnfold::CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const; static voidTUnfold::DeleteMatrix(TMatrixD** m); static voidTUnfold::DeleteMatrix(TMatrixDSparse** m); voidDoBackgroundSubtraction(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tTUnfold::DoUnfold(); voidTUnfold::ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; const TMatrixDSparse*TUnfold::GetAx() const; Int_tTUnfold::GetBinFromRow(int ix) const; const TMatrixDSparse*TUnfold::GetDXDAM(int i) const; const TMatrixDSparse*TUnfold::GetDXDAZ(int i) const; const TMatrixDSparse*TUnfold::GetDXDtauSquared() const; const TMatrixDSparse*TUnfold::GetDXDY() const; const TMatrixDSparse*TUnfold::GetE() const; const TMatrixDSparse*TUnfold::GetEinv() const; voidGetEmatrixFromVyy(const TMatrixDS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfoldSys.html:11958,Clear,ClearHistogram,11958,root/html602/TUnfoldSys.html,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html,2,['Clear'],['ClearHistogram']
Usability,"void * ; object, . const char * ; redo, . const char * ; undo . ). protectedvirtual . Common protected method used in several constructors. ; Definition at line 120 of file TQCommand.cxx. ◆ IsA(). TClass * TQCommand::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TList.; Reimplemented in TQUndoManager.; Definition at line 98 of file TQCommand.h. ◆ IsEqual(). Bool_t TQCommand::IsEqual ; (; const TObject * ; obj); const. overridevirtual . Equal comparison. ; The commands are equal if they are applied to the same object and have the same Redo/Undo actions; More complicated commands might want to override this function. ; Reimplemented from TObject.; Definition at line 418 of file TQCommand.cxx. ◆ IsExecuting(). Bool_t TQCommand::IsExecuting ; (; ); const. Returns kTRUE if command execution is in progress. ; Definition at line 824 of file TQCommand.cxx. ◆ IsMacro(). Bool_t TQCommand::IsMacro ; (; ); const. Returns kTRUE if neither redo nor undo action specified. ; Definition at line 800 of file TQCommand.cxx. ◆ IsRedoing(). Bool_t TQCommand::IsRedoing ; (; ); const. Redo action is in progress. ; Definition at line 816 of file TQCommand.cxx. ◆ IsSetter(). Bool_t TQCommand::IsSetter ; (; ); const. virtual . Returns kTRUE is command if Redo is the same as Undo function and is the setter action. ; By default, all functions with names like ""SetXXX"" or ""setXXX"" considered as setters. Another type of setters are Move, Resize operations; More complicated commands might want to override this function. ; Definition at line 440 of file TQCommand.cxx. ◆ IsUndoing(). Bool_t TQCommand::IsUndoing ; (; ); const. Undo action is in progress. ; Definition at line 808 of file TQCommand.cxx. ◆ ls(). void TQCommand::ls ; (; Option_t * ; option = """"); const. overridevirtual . ls this command and merged commands ; Reimplemented from TCollection.; Reimplemented in TQUndoManager.; Definition at line 848 of file TQCommand.cxx. ◆ Merge() [1/2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:40339,undo,undo,40339,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"void StopProcess(Bool_t abort, Int_t timeout = -1). void AddInput(TObject* inp). void ClearInput(). TObject * GetOutput(const char* name) const. TList * GetOutputList() const. TList * GetInputList() const. TList * GetListOfResults() const. void AddQueryResult(TQueryResult* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedback * CreateDrawFeedback(TProof* p). void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt). void DeleteDrawFeedback(TDrawFeedback* f). TDSetElement * GetNextPacket(TSlave* slave, TMessage* r). Int_t ReinitSelector(TQueryResult* qr). void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax). Bool_t IsClient() const. EExitStatus GetExitStatus() const. Long64_t GetEventsProcessed() const. void AddEventsProcessed(Long64_t ev). TProofProgressStatus* GetProgressStatus() const. void SetDispatchTimer(Bool_t on = kTRUE). void SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0). Long64_t GetCacheSize(). Int_t GetLearnEntries(). TVirtualPacketizer * GetPacketizer() const; { return 0; }. TVirtualProofPlayer * Create(const char* player, TProof* p, TSocket* s = 0). » Author: Fons Rademakers 15/03/07 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualProofPlayer.html:13471,Feedback,Feedback,13471,root/html532/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html,1,['Feedback'],['Feedback']
Usability,"void StopProcess(Bool_t abort, Int_t timeout = -1). void AddInput(TObject* inp). void ClearInput(). TObject * GetOutput(const char* name) const. TList * GetOutputList() const. TList * GetInputList() const. TList * GetListOfResults() const. void AddQueryResult(TQueryResult* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedback * CreateDrawFeedback(TProof* p). void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt). void DeleteDrawFeedback(TDrawFeedback* f). TDSetElement * GetNextPacket(TSlave* slave, TMessage* r). Int_t ReinitSelector(TQueryResult* qr). void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax). Bool_t IsClient() const. EExitStatus GetExitStatus() const. void SetExitStatus(TVirtualProofPlayer::EExitStatus ). Long64_t GetEventsProcessed() const. void AddEventsProcessed(Long64_t ev). TProofProgressStatus* GetProgressStatus() const. void SetDispatchTimer(Bool_t on = kTRUE). void SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0). Long64_t GetCacheSize(). Int_t GetLearnEntries(). void UpdateProgressInfo(). TVirtualPacketizer * GetPacketizer() const; { return 0; }. void SetOutputFilePath(const char* fp). Int_t SavePartialResults(Bool_t queryend = kFALSE, Bool_t force =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualProofPlayer.html:15022,Feedback,Feedback,15022,root/html602/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html602/TVirtualProofPlayer.html,1,['Feedback'],['Feedback']
Usability,"void StopProcess(Bool_t abort, Int_t timeout = -1). void AddInput(TObject* inp). void ClearInput(). TObject * GetOutput(const char* name) const. TList * GetOutputList() const. TList * GetInputList() const. TList * GetListOfResults() const. void AddQueryResult(TQueryResult* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedback * CreateDrawFeedback(TProof* p). void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt). void DeleteDrawFeedback(TDrawFeedback* f). TDSetElement * GetNextPacket(TSlave* slave, TMessage* r). Int_t ReinitSelector(TQueryResult* qr). void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax). Bool_t IsClient() const. EExitStatus GetExitStatus() const. void SetExitStatus(TVirtualProofPlayer::EExitStatus ). Long64_t GetEventsProcessed() const. void AddEventsProcessed(Long64_t ev). TProofProgressStatus* GetProgressStatus() const. void SetDispatchTimer(Bool_t on = kTRUE). void SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0). void SetMerging(Bool_t on = kTRUE). Long64_t GetCacheSize(). Int_t GetLearnEntries(). void UpdateProgressInfo(). TVirtualPacketizer * GetPacketizer() const; { return 0; }. void SetOutputFilePath(const char* fp). Int_t SavePartialResults(Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualProofPlayer.html:14045,Feedback,Feedback,14045,root/html534/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html534/TVirtualProofPlayer.html,2,['Feedback'],['Feedback']
Usability,"void TFormula::Copy(TObject &obj) const; 685{; 686 TNamed::Copy(obj);; 687 // need to copy also cling parameters; 688 TFormula & fnew = dynamic_cast<TFormula&>(obj);; 689 ; 690 fnew.fClingParameters = fClingParameters;; 691 fnew.fClingVariables = fClingVariables;; 692 ; 693 fnew.fFuncs = fFuncs;; 694 fnew.fVars = fVars;; 695 fnew.fParams = fParams;; 696 fnew.fConsts = fConsts;; 697 fnew.fFunctionsShortcuts = fFunctionsShortcuts;; 698 fnew.fFormula = fFormula;; 699 fnew.fNdim = fNdim;; 700 fnew.fNpar = fNpar;; 701 fnew.fNumber = fNumber;; 702 fnew.fVectorized = fVectorized;; 703 fnew.SetParameters(GetParameters());; 704 // copy Linear parts (it is a vector of TFormula pointers) needs to be copied one by one; 705 // looping at all the elements; 706 // delete first previous elements; 707 int nLinParts = fnew.fLinearParts.size();; 708 if (nLinParts > 0) {; 709 for (int i = 0; i < nLinParts; ++i) delete fnew.fLinearParts[i];; 710 fnew.fLinearParts.clear();; 711 }; 712 // old size that needs to be copied; 713 nLinParts = fLinearParts.size();; 714 if (nLinParts > 0) {; 715 fnew.fLinearParts.reserve(nLinParts);; 716 for (int i = 0; i < nLinParts; ++i) {; 717 TFormula * linearNew = new TFormula();; 718 TFormula * linearOld = (TFormula*) fLinearParts[i];; 719 if (linearOld) {; 720 linearOld->Copy(*linearNew);; 721 fnew.fLinearParts.push_back(linearNew);; 722 }; 723 else; 724 Warning(""Copy"",""Function %s - expr %s has a dummy linear part %d"",GetName(),GetExpFormula().Data(),i);; 725 }; 726 }; 727 ; 728 fnew.fClingInput = fClingInput;; 729 fnew.fReadyToExecute = fReadyToExecute;; 730 fnew.fClingInitialized = fClingInitialized.load();; 731 fnew.fAllParametersSetted = fAllParametersSetted;; 732 fnew.fClingName = fClingName;; 733 fnew.fSavedInputFormula = fSavedInputFormula;; 734 fnew.fLazyInitialization = fLazyInitialization;; 735 ; 736 // case of function based on a C++ expression (lambda's) which is ready to be compiled; 737 if (fLambdaPtr && TestBit(TFormula::kLambda)) {; 738 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:26186,clear,clear,26186,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['clear'],['clear']
Usability,"voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcanBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = RooCmdArg::non",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:6315,clear,clearShapeDirty,6315,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['clear'],['clearShapeDirty']
Usability,"voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra(). » Author: L. Moneta Fri Aug 15 2008 » Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IntegratorOptions.h 36806 2010-11-20 11:09:14Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:2541,Clear,ClearExtra,2541,root/html532/ROOT__Math__BaseIntegratorOptions.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html,1,['Clear'],['ClearExtra']
Usability,"voidTArrayD::Adopt(Int_t n, Double_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); static voidApproximate(Bool_t approx = kTRUE); Double_tTArrayD::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tBufferEmpty(Int_t action = 0); voidBuildOptions(Double_t tmin, Double_t tmax, Option_t* option); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tDivide(const TH1* h1); virtual Bool_tDivide(TF1* h1, Double_t c1 = 1); virtual Bool_tDivide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; virtual TH1*TH1::DrawNormalized(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProfile3D.html:3579,Clear,ClearUnderflowAndOverflow,3579,root/html602/TProfile3D.html,https://root.cern,https://root.cern/root/html602/TProfile3D.html,2,['Clear'],['ClearUnderflowAndOverflow']
Usability,"voidTArrayD::Adopt(Int_t n, Double_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); static voidApproximate(Bool_t approx = kTRUE); Double_tTArrayD::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tBufferEmpty(Int_t action = 0); voidBuildOptions(Double_t ymin, Double_t ymax, Option_t* option); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tDivide(const TH1* h1); virtual Bool_tDivide(TF1* h1, Double_t c1 = 1); virtual Bool_tDivide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; virtual TH1*TH1::DrawNormalized(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProfile.html:3964,Clear,ClearUnderflowAndOverflow,3964,root/html602/TProfile.html,https://root.cern,https://root.cern/root/html602/TProfile.html,2,['Clear'],['ClearUnderflowAndOverflow']
Usability,"voidTArrayD::Adopt(Int_t n, Double_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); static voidApproximate(Bool_t approx = kTRUE); Double_tTArrayD::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tBufferEmpty(Int_t action = 0); voidBuildOptions(Double_t zmin, Double_t zmax, Option_t* option); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tDivide(const TH1* h1); virtual Bool_tDivide(TF1* h1, Double_t c1 = 1); virtual Bool_tDivide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; virtual TH1*TH1::DrawNormalized(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProfile2D.html:3509,Clear,ClearUnderflowAndOverflow,3509,root/html602/TProfile2D.html,https://root.cern,https://root.cern/root/html602/TProfile2D.html,2,['Clear'],['ClearUnderflowAndOverflow']
Usability,"voidTArrayI::AddAt(Int_t c, Int_t i); virtual voidAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayI::Adopt(Int_t n, Int_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTArrayI::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH1::BufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1I.html:1979,Clear,Clear,1979,root/html534/TH1I.html,https://root.cern,https://root.cern/root/html534/TH1I.html,1,['Clear'],['Clear']
Usability,"voidTArrayI::AddAt(Int_t c, Int_t i); virtual voidAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayI::Adopt(Int_t n, Int_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTArrayI::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH2::BufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH2I.html:2328,Clear,Clear,2328,root/html534/TH2I.html,https://root.cern,https://root.cern/root/html534/TH2I.html,1,['Clear'],['Clear']
Usability,"voidTArrayI::AddAt(Int_t c, Int_t i); virtual voidAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayI::Adopt(Int_t n, Int_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTArrayI::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH3::BufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH3I.html:2198,Clear,Clear,2198,root/html534/TH3I.html,https://root.cern,https://root.cern/root/html534/TH3I.html,1,['Clear'],['Clear']
Usability,"voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGButton::EmitSignals(Bool_t wasUp); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidInit(); voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGButton::SetToggleButton(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGTextButton&operator=(const TGTextButton&); TGTextButton(const TGTextButton&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditModeTGWindow::kEd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTextButton.html:19084,Clear,ClearFlags,19084,root/html602/TGTextButton.html,https://root.cern,https://root.cern/root/html602/TGTextButton.html,2,['Clear'],['ClearFlags']
Usability,"voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddPixmap(ULong_t pixid, UInt_t w, UInt_t h); virtual Int_tAddWindow(ULong_t qwid, UInt_t w, UInt_t h); virtual Bool_tAllocColor(Colormap_t cmap, ColorStruct_t& color); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualX::BeginModalSessionFor(Window_t window); virtual voidBell(Int_t percent); virtual voidTObject::Browse(TBrowser* b); virtual voidChangeActivePointerGrab(Window_t, UInt_t, Cursor_t); virtual voidChangeGC(GContext_t gc, GCValues_t* gval); virtual voidChangeProperties(Window_t id, Atom_t property, Atom_t type, Int_t format, UChar_t* data, Int_t len); virtual voidChangeProperty(Window_t id, Atom_t property, Atom_t type, UChar_t* data, Int_t len); virtual voidChangeWindowAttributes(Window_t id, SetWindowAttributes_t* attr); virtual Bool_tCheckEvent(Window_t id, EGEventType type, Event_t& ev); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearArea(Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidClearWindow(); virtual voidClearWindow(Window_t id); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidCloseDisplay(); virtual voidClosePixmap(); virtual voidCloseWindow(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConvertPrimarySelection(Window_t id, Atom_t clipboard, Time_t when); virtual voidConvertSelection(Window_t, Atom_t&, Atom_t&, Atom_t&, Time_t&); virtual voidTNamed::Copy(TObject& named) const; virtual voidCopyArea(Drawable_t src, Drawable_t dest, GContext_t gc, Int_t src_x, Int_t src_y, UInt_t width, UInt_t height, Int_t dest_x, Int_t dest_y); virtual voidCopyGC(GContext_t org, GContext_t dest, Mask_t mask); virtual voidCopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); virtual Pixmap_tCreateBitmap(Drawable_t id, const char* bitmap, UInt_t width, UInt_t height); virtual Cursor_tCreateCursor(ECursor cursor); virtual GC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGX11.html:1679,Clear,Clear,1679,root/html534/TGX11.html,https://root.cern,https://root.cern/root/html534/TGX11.html,3,['Clear'],['Clear']
Usability,"voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsInInterval(const RooArgSet&) const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual Double_tLowerLimit(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::SimpleInterval&operator=(const RooStats::SimpleInterval& other); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetConfidenceLevel(Double_t); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__SimpleInterval.html:3819,Simpl,SimpleInterval,3819,root/html534/RooStats__SimpleInterval.html,https://root.cern,https://root.cern/root/html534/RooStats__SimpleInterval.html,1,['Simpl'],['SimpleInterval']
Usability,"voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsInInterval(const RooArgSet&) const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual Double_tLowerLimit(); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::SimpleInterval&operator=(const RooStats::SimpleInterval&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetConfidenceLevel(Double_t); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMemb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__SimpleInterval.html:3819,Simpl,SimpleInterval,3819,root/html532/RooStats__SimpleInterval.html,https://root.cern,https://root.cern/root/html532/RooStats__SimpleInterval.html,1,['Simpl'],['SimpleInterval']
Usability,"voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); virtual Bool_tCancelStagingDataSet(const char* dataset); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearCache(const char* file = 0); voidTProof::ClearData(UInt_t what = kUnregistered, const char* dsname = 0); virtual voidClearDataSetCache(const char* dataset = 0); voidTProof::ClearFeedback(); voidTProof::ClearInput(); voidTProof::ClearInputData(TObject* obj = 0); voidTProof::ClearInputData(const char* name); Int_tTProof::ClearPackage(const char* package); Int_tTProof::ClearPackages(); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTProof::Close(Option_t* option = """"); voidTProof::CloseProgressDialog()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTNamed::Copy(TObject& named) const; TDrawFeedback*TProof::CreateDrawFeedback(); voidTProof::DataSetStatus(const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:2323,Clear,ClearInput,2323,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,3,['Clear'],['ClearInput']
Usability,"voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUdpService(int port, int backlog); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTSystem::CloseConnection(int sock, Bool_t force = kFALSE); virtual voidTSystem::Closelog(); virtual intTSystem::ClosePipe(FILE* pipe); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual intTSystem::CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); virtual char*TSystem::ConcatFileName(const char* dir, const char* name); virtual Bool_tConsistentWith(const char* path, void* dirptr); virtual voidTNamed::Copy(TObject& named) const; virtual intTSystem::CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidTSystem::DispatchOneEvent(Bool_t pendingOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TNetSystem.html:3891,Clear,Clear,3891,root/html532/TNetSystem.html,https://root.cern,https://root.cern/root/html532/TNetSystem.html,11,['Clear'],['Clear']
Usability,"voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidTSystem::AddTimer(TTimer* t); virtual intTSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intTSystem::AnnounceUdpService(int port, int backlog); virtual intTSystem::AnnounceUnixService(int port, int backlog); virtual intTSystem::AnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tTSystem::ChangeDirectory(const char* path); virtual intTSystem::Chmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTSystem::CloseConnection(int sock, Bool_t force = kFALSE); virtual voidTSystem::Closelog(); virtual intTSystem::ClosePipe(FILE* pipe); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual intTSystem::CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); virtual char*TSystem::ConcatFileName(const char* dir, const char* name); virtual voidTNamed::Copy(TObject& named) const; virtual intTSystem::CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidTSystem::DispatchOneEvent(Bool_t pendingOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDCacheSystem.html:1919,Clear,Clear,1919,root/html532/TDCacheSystem.html,https://root.cern,https://root.cern/root/html532/TDCacheSystem.html,6,['Clear'],['Clear']
Usability,"void AddBuffer (const char *buffer);  Add text to the window. ;  ; void BuildLogList (Bool_t create=kFALSE);  Build the list of workers. ;  ; void Clear (Option_t *=nullptr) override;  Clear log window. ;  ; void CloseWindow () override;  Handle close button or when closed via window manager action. ;  ; void DoLog (Bool_t grep=kFALSE);  Display logs. ;  ; TClass * IsA () const override;  ; void LoadBuffer (const char *buffer);  Load a text buffer in the window. ;  ; void LoadFile (const char *file);  Load a file in the window. ;  ; void LogMessage (const char *msg, Bool_t all);  Load/append a log msg in the log frame, if open. ;  ; void NoLineEntry ();  Enable/disable the line number entry. ;  ; void Popup ();  Show log window. ;  ; void Rebuild ();  Rebuild the log info for a new entered session. ;  ; void SaveToFile ();  Save the logs to a file Only the name of the file is taken, no expansion. ;  ; void Select (Int_t id, Bool_t all=kTRUE);  actions of select all/clear all button ;  ; void SetGrepView ();  Sets the view of grep filters according to the value of checkboxes. ;  ; void SetUrl (const char *url);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGTransientFrame;  TGTransientFrame (const TGWindow *p=nullptr, const TGWindow *main=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=kVerticalFrame);  Create a transient window. ;  ; virtual void CenterOnParent (Bool_t croot=kTRUE, EPlacement pos=kCenter);  Position transient frame centered relative to the parent frame. ;  ; const TGWindow * GetMain () const;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a transient frame widget as a C++ statement(s) on output stream out. ;  ; void SaveSource (const char *filename=""Rootdlog.C"", Option_t *option="""") override;  Save the GUI transient frame widget in a C++ macro file. ;  ; void StreamerNVirtual (TBu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofProgressLog.html:1852,clear,clear,1852,doc/master/classTProofProgressLog.html,https://root.cern,https://root.cern/doc/master/classTProofProgressLog.html,1,['clear'],['clear']
Usability,"void AddInputData (TObject *obj, Bool_t push=kFALSE);  Add data objects that might be needed during the processing of the selector (see Process()). ;  ; Int_t Archive (const char *queryref, const char *url=0);  Send archive request for the query specified by ref. ;  ; Int_t Archive (Int_t query, const char *url);  Send archive request for the qry-th query in fQueries. ;  ; void Browse (TBrowser *b) override;  Build the PROOF's structure in the browser. ;  ; void cd (Int_t id=-1);  Set session with 'id' the default one. ;  ; Int_t CleanupSession (const char *sessiontag);  Send cleanup request for the session specified by tag. ;  ; void ClearData (UInt_t what=kUnregistered, const char *dsname=0);  Remove files for the data directory. ;  ; void ClearFeedback ();  Clear feedback list. ;  ; void ClearInput ();  Clear input object list. ;  ; void ClearInputData (const char *name);  Remove obj 'name' form the input data list;. ;  ; void ClearInputData (TObject *obj=0);  Remove obj form the input data list; if obj is null (default), clear the input data info. ;  ; Int_t ClearPackage (const char *package);  Remove a specific package. ;  ; Int_t ClearPackages ();  Remove all packages. ;  ; void Close (Option_t *option="""");  Close all open slave servers. ;  ; void CloseProgressDialog ();  Close progress dialog. ;  ; TDrawFeedback * CreateDrawFeedback ();  Draw feedback creation proxy. ;  ; void DataSetStatus (const char *msg, Bool_t status, Int_t done, Int_t total);  Send dataset preparation status. ;  ; Int_t DeactivateWorker (const char *ord, Bool_t save=kTRUE);  Remove the worker identified by the ordinal number 'ord' from the the active list. ;  ; void DeleteDrawFeedback (TDrawFeedback *f);  Delete draw feedback object. ;  ; void DeleteParameters (const char *wildcard);  Delete the input list parameters specified by a wildcard (e.g. ;  ; void Detach (Option_t *opt="""");  Detach this instance to its proofserv. ;  ; void DisableGoAsyn ();  Signal to disable related switches. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:7649,clear,clear,7649,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['clear'],['clear']
Usability,"void ClearEveFrame ();  Clears eve-frame associated with this window. ;  ; virtual void DestroyWindow ();  Destroy eve-window - replace it with an empty frame-slot. ;  ; virtual void DestroyWindowAndSlot ();  Destroy eve-window and its frame-slot. ;  ; void FlipShowTitleBar ();  ; TEveCompositeFrame * GetEveFrame ();  ; Bool_t GetShowTitleBar () const;  ; Bool_t IsAncestorOf (TEveWindow *win);  Returns true if this is an ancestor of win. ;  ; Bool_t IsCurrent () const;  Returns true if this window is the current one. ;  ; void MakeCurrent ();  Make this window current. ;  ; void NameTitleChanged () override;  Name or title of the window changed - propagate to frames. ;  ; virtual TEveWindowSlot * NewSlot ();  ; void PopulateEmptyFrame (TEveCompositeFrame *ef);  Populate given frame-slot - intended for initial population of a new slot or low-level window-swapping. ;  ; virtual void PostDock ();  Virtual function called after a window is docked. ;  ; virtual void PreUndock ();  Virtual function called before a window is undocked. ;  ; void ReplaceWindow (TEveWindow *w);  Replace this window with the passed one. ;  ; void SetShowTitleBar (Bool_t x);  Set display state of the title-bar. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void SwapWindow (TEveWindow *w);  Swap frames with the given window. ;  ; void SwapWindowWithCurrent ();  Swap frames with the current window. ;  ; void TitleBarClicked ();  Slot for clicking on the title-bar. ;  ; void UndockWindow ();  Undock the window - put it into a dedicated main-frame. ;  ; void UndockWindowDestroySlot ();  Undock the window - put it into a dedicated main-frame. ;  ;  Public Member Functions inherited from TEveElementList;  TEveElementList (const char *n=""TEveElementList"", const char *t="""", Bool_t doColor=kFALSE, Bool_t doTransparency=kFALSE);  Constructor. ;  ;  TEveElementList (const TEveElementList &e);  Copy constructor. ;  ;  ~TEveElementList () override;  ; Bool_t AcceptElement (TEveElemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveWindowFrame.html:2211,undo,undocked,2211,doc/master/classTEveWindowFrame.html,https://root.cern,https://root.cern/doc/master/classTEveWindowFrame.html,2,['undo'],['undocked']
Usability,"void Compress (TQCommand *c);  Compress command. ;  ; void Delete (Option_t *option="""") override;  If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ;  ; const char * GetName () const override;  Returns the command name. ;  ; Int_t GetNRargs () const;  Returns a number of redo arguments. ;  ; Int_t GetNUargs () const;  Returns a number of undo arguments. ;  ; void * GetObject () const;  Returns an object for which undo redo actions are applied. ;  ; TQConnection * GetRedo () const;  ; Long_t * GetRedoArgs () const;  Returns a pointer to array of redo arguments. ;  ; const char * GetRedoName () const;  Returns the name of redo command. ;  ; Int_t GetStatus () const;  Returns a number of sequential undo or redo operations. ;  ; const char * GetTitle () const override;  Returns command description. ;  ; TQConnection * GetUndo () const;  ; Long_t * GetUndoArgs () const;  Returns a pointer to array of undo arguments. ;  ; const char * GetUndoName () const;  Returns the name of undo command. ;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison. ;  ; Bool_t IsExecuting () const;  Returns kTRUE if command execution is in progress. ;  ; Bool_t IsMacro () const;  Returns kTRUE if neither redo nor undo action specified. ;  ; Bool_t IsRedoing () const;  Redo action is in progress. ;  ; virtual Bool_t IsSetter () const;  Returns kTRUE is command if Redo is the same as Undo function and is the setter action. ;  ; Bool_t IsUndoing () const;  Undo action is in progress. ;  ; virtual Long64_t Merge (TCollection *, TFileMergeInfo *);  Merge a collection of TQCommand. ;  ; virtual void Merge (TQCommand *c);  Add command to the list of merged commands. ;  ; virtual void SetArgs (Int_t nargs,...);  Set do/redo and undo parameters. ;  ; virtual void SetName (const char *name);  Sets name of the command. ;  ; virtual void SetRedoArgs (Int_t nargs,...);  Set redo parameters. ;  ; virtual void SetTitle (const char *title);  Sets des",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:3572,undo,undo,3572,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['undo'],['undo']
Usability,"void Compress (TQCommand *c);  Compress command. ;  ; void Delete (Option_t *option="""") override;  If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ;  ; const char * GetName () const override;  Returns the command name. ;  ; Int_t GetNRargs () const;  Returns a number of redo arguments. ;  ; Int_t GetNUargs () const;  Returns a number of undo arguments. ;  ; void * GetObject () const;  Returns an object for which undo redo actions are applied. ;  ; TQConnection * GetRedo () const;  ; Long_t * GetRedoArgs () const;  Returns a pointer to array of redo arguments. ;  ; const char * GetRedoName () const;  Returns the name of redo command. ;  ; Int_t GetStatus () const;  Returns a number of sequential undo or redo operations. ;  ; const char * GetTitle () const override;  Returns command description. ;  ; TQConnection * GetUndo () const;  ; Long_t * GetUndoArgs () const;  Returns a pointer to array of undo arguments. ;  ; const char * GetUndoName () const;  Returns the name of undo command. ;  ; TClass * IsA () const override;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison. ;  ; Bool_t IsExecuting () const;  Returns kTRUE if command execution is in progress. ;  ; Bool_t IsMacro () const;  Returns kTRUE if neither redo nor undo action specified. ;  ; Bool_t IsRedoing () const;  Redo action is in progress. ;  ; virtual Bool_t IsSetter () const;  Returns kTRUE is command if Redo is the same as Undo function and is the setter action. ;  ; Bool_t IsUndoing () const;  Undo action is in progress. ;  ; void ls (Option_t *option="""") const override;  ls this command and merged commands ;  ; virtual Long64_t Merge (TCollection *, TFileMergeInfo *);  Merge a collection of TQCommand. ;  ; virtual void Merge (TQCommand *c);  Add command to the list of merged commands. ;  ; virtual void Redo (Option_t *option="""");  Execute command and then merge commands. ;  ; virtual void SetArgs (Int_t nargs,...);  Set do/redo and undo pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:6648,undo,undo,6648,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,volution in high resolution peak searching function (class TSpectrum) ;  Smoothing.C Example to illustrate smoothing using Markov algorithm (class TSpectrum) ;  spectrumpainter.C Examples showing how to use TSpectrum2Painter (the SPEC option) ;  ► splot;  TestSPlot.CThis tutorial illustrates the use of class TSPlot and of the sPlots method ;  ► sql;  sqlcanvas.CThis is slight modification of ntuple1.C example ;  sqlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlcreatedb.py Create a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlfilldb.py Fill run catalog with nfiles entries ;  sqlselect.CQuery example to MySQL test database ;  sqlselect.py Query example to MySQL test database ;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► envelope;  classification.C;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVACrossValida,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:158000,simpl,simple,158000,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['simpl'],['simple']
Usability,"vt);  train network over a single event this uses the new event model ;  ; void TrainOneEventFast (Int_t ievt, Float_t *&branchVar, Int_t &type);  fast per-event training ;  ; void UpdateNetwork (const std::vector< Float_t > &desired, Double_t eventWeight=1.0);  update the network based on how closely the output matched the desired output ;  ; void UpdateNetwork (Double_t desired, Double_t eventWeight=1.0);  update the network based on how closely the output matched the desired output ;  ; void UpdatePriors ();  zjh ;  ; void UpdateRegulators ();  zjh ;  ; void UpdateSynapses ();  update synapse error fields and adjust the weights (if in sequential mode) ;  . Private Attributes; Int_t fBatchSize;  batch size, only matters if in batch learning mode ;  ; EBPTrainingMode fBPMode;  backprop learning mode (sequential or batch) ;  ; TString fBpModeS;  backprop learning mode option string (sequential or batch) ;  ; bool fCalculateErrors;  compute inverse hessian matrix at the end of the training ;  ; Double_t fDecayRate;  decay rate for above learning rate ;  ; std::vector< std::pair< Float_t, Float_t > > * fDeviationsFromTargets;  deviation from the targets, event weight ;  ; Bool_t fEpochMon;  create and fill epoch-wise monitoring histograms (makes outputfile big!) ;  ; Int_t fGA_nsteps;  GA settings: number of steps. ;  ; Int_t fGA_preCalc;  GA settings: number of pre-calc steps. ;  ; Double_t fGA_SC_factor;  GA settings: SC_factor. ;  ; Int_t fGA_SC_rate;  GA settings: SC_rate. ;  ; Int_t fGA_SC_steps;  GA settings: SC_steps. ;  ; Double_t fLastAlpha;  line search variable ;  ; Double_t fLearnRate;  learning rate for synapse weight adjustments ;  ; Double_t fPrior;  zjh ;  ; std::vector< Double_t > fPriorDev;  zjh ;  ; Int_t fResetStep;  reset time (how often we clear hessian matrix) ;  ; Float_t fSamplingEpoch;  fraction of epochs where sampling is used ;  ; Float_t fSamplingFraction;  fraction of events which is sampled for training ;  ; Bool_t fSamplingTesting;  The ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:33879,learn,learning,33879,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,4,['learn'],['learning']
Usability,"w all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t Buil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProof.html:61260,Clear,ClearPackage,61260,root/html532/TProof.html,https://root.cern,https://root.cern/root/html532/TProof.html,1,['Clear'],['ClearPackage']
Usability,"w all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = 2, TList* workers = 0); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:70512,Clear,ClearPackage,70512,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['Clear'],['ClearPackage']
Usability,"w all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = kCheckROOT); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of success and -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:72670,Clear,ClearPackage,72670,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,1,['Clear'],['ClearPackage']
Usability,"w all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = kCheckROOT, TList* workers = 0); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProof.html:73343,Clear,ClearPackage,73343,root/html604/TProof.html,https://root.cern,https://root.cern/root/html604/TProof.html,1,['Clear'],['ClearPackage']
Usability,"w classes are added to the existing directory.; Existing classes with the same name are replaced by the; new definition. If the directory dirname doest not exist,; same effect as ""new"".; If option = ""genreflex"", then use genreflex rather than rootcint to generate; the dictionary.; If, in addition to one of the 3 above options, the option ""+"" is specified,; the function will generate:; - a script called MAKEP to build the shared lib; - a dirnameLinkDef.h file; - rootcint will be run to generate a dirnameProjectDict.cxx file; - dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; - a shared lib dirname.so will be created.; If the option ""++"" is specified, the generated shared lib is dynamically; linked with the current executable module.; If the option ""+"" and ""nocompile"" are specified, the utility files are generated; as in the option ""+"" but they are not executed.; Example:; file.MakeProject(""demo"",""*"",""recreate++"");; - creates a new directory demo unless it already exist; - clear the previous directory content; - generate the xxx.h files for all classes xxx found in this file; and not yet known to the CINT dictionary.; - creates the build script MAKEP; - creates a LinkDef.h file; - runs rootcint generating demoProjectDict.cxx; - compiles demoProjectDict.cxx into demoProjectDict.o; - generates a shared lib demo.so; - dynamically links the shared lib demo.so to the executable; If only the option ""+"" had been specified, one can still link the; shared lib to the current executable module with:; gSystem->load(""demo/demo.so"");. The following feature is not yet enabled:; One can restrict the list of classes to be generated by using expressions like:; classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only. void ReadStreamerInfo(); Read the list of StreamerInfo from this file.; The key with name holding the list of TStreamerInfo objects is read.; The corresponding TClass objec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:41825,clear,clear,41825,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,2,['clear'],['clear']
Usability,"w functionality).; What M does not:. histogramming; data handling; graphics. M is kept as a low-level package with optimal performance.; The main usages of M are. from a user’s program (such as int main()…); from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. its numerical accuracy (equivalent to its Fortran version); its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a two-way strategy was imposed:. a minimal required interface with minimum interaction with M objects and with appropriate usage of the standard library (STL): the user’s implementation of the FCNBase class, initial parameter values and uncertainties are provided by the to M user via std::vectors.; a rich interface which provides the user with more functionality such as interaction with parameters. The core of the minimization functionality and related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal and external parameters; Each of the parameters to the \(\mbox{FCN}\) is defined by the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified by the user.; Variable with single sided limits: allowed to vary only between one upper or one lower limit specified by the user and unlimited to the other side.; Fixed: originally defined as variable, but now taking on only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, in his \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and he therefore has access to what we call the extern",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:10401,clear,clearly,10401,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['clear'],['clearly']
Usability,"w functionality).; What M does not:. histogramming; data handling; graphics. M is kept as a low-level package with optimal performance.; The main usages of M are. from a user’s program (such as int main()…); from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. its numerical accuracy (equivalent to its Fortran version); its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a two-way strategy was imposed:. a minimal required interface with minimum interaction with M objects and with appropriate usage of the standard library (STL): the user’s implementation of the FCNBase class, initial parameter values and uncertainties are provided by the to M user via std::vectors.; a rich interface which provides the user with more functionality such as interaction with parameters. The core of the minimization functionality and related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal and external parameters; Each of the parameters to the \(\mbox{FCN}\) is defined by the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified by the user.; Variable with single sided limits: allowed to vary only between one upper or one lower limit specified by the user and unlimited to the other side.; Fixed: originally defined as variable, but now taking on only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, in their \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and they therefore have access to what we call the e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:6365,clear,clearly,6365,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,2,['clear'],['clearly']
Usability,"w the object communication mechanism can be used for handling the TCanvas’s mouse/key events in an interpreted class. With this demo you can fill histograms by hand:. Click the left button or move mouse with button pressed to fill histograms.; Use the right button of the mouse to reset the histograms. 26.6.4 Complex GUI Using Signals and Slots (guitest.C); Based on $ROOTSYS/test/guitest.cxx this example demonstrates:. All features of the original compiled guitest.cxx program.; Sophisticated use of signals and slots to build a complete user interface that can be executed either in the interpreter or as a compiled program. 27 Automatic HTML Documentation. THtml is ROOT’s documentation engine. It can be used to document your classes in a reference guide, and to convert your text or source files to HTML.; 27.1 Reference Guide; The Reference Guide for the ROOT classes at http://root.cern.ch/root/html/ has been generated by ROOT’s THtml class. Just as for ROOT’s classes, it can generate (and update) a reference guide for your classes, too. You document your classes using source code comments. All comments will be automatically put into a <pre></pre> environment to keep the indentation and line length. You can write “raw” HTML by enclosing comments in the keywords Begin_Html and End_Html.; To generate documentation for the class TObject you could run the following commands:; root[] THtml h; root[] h.SetInputDir(""$(ROOTSYS)"");; root[] h.MakeClass(""TObject"");; root[] h.CreateJavascript();; root[] h.CreateStylesheet();; The comments following the first comment of the form //____________________, before any method, is assumed to be the class description. As with any other documentation part, it has to be a continuous block of comments.; Any documented class will have an class index entry in the ClassIndex.html, showing their name with a link to their documentation page and a miniature description. This description for e.g. the class MyClass has to be given in MyClass's header ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1240236,guid,guide,1240236,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['guid'],['guide']
Usability,"w(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidEmitSignals(Bool_t wasUp = kTRUE); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidInit(); voidTObject::MakeZombie(); voidPSetState(EButtonState state, Bool_t emit); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGButton::SetToggleButton(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGCheckButton&operator=(const TGCheckButton&); TGCheckButton(const TGCheckButton&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGCheckButton.html:19411,Clear,ClearFlags,19411,root/html602/TGCheckButton.html,https://root.cern,https://root.cern/root/html602/TGCheckButton.html,2,['Clear'],['ClearFlags']
Usability,"w(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidEmitSignals(Bool_t wasUp = kTRUE); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidInit(); voidTObject::MakeZombie(); voidPSetState(EButtonState state, Bool_t emit); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGButton::SetToggleButton(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGRadioButton&operator=(const TGRadioButton&); TGRadioButton(const TGRadioButton&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGRadioButton.html:19401,Clear,ClearFlags,19401,root/html602/TGRadioButton.html,https://root.cern,https://root.cern/root/html602/TGRadioButton.html,2,['Clear'],['ClearFlags']
Usability,"w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidAddTH3(const TH3* hist, TGLTH3Composition::ETH3BinShape shape = kBox); voidTArrayC::Adopt(Int_t n, Char_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Char_tTArrayC::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH3::BufferEmpty(Int_t action = 0); virtual Bool_tTH1::CanExtendAllAxes() const; virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTH1::ClearUnderflowAndOverflow(); virtual TObject*TH1::Clone(const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidTH3C::Copy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """", const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLTH3Composition.html:1783,Clear,Clear,1783,root/html602/TGLTH3Composition.html,https://root.cern,https://root.cern/root/html602/TGLTH3Composition.html,2,['Clear'],['Clear']
Usability,"w* p, TGTable* table = 0, UInt_t w = 1, UInt_t h = 1, EHeaderType type = kColumnHeader, UInt_t option = 0); virtual~TGTableHeaderFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal = 0, void* receive",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTableHeaderFrame.html:1662,Clear,Clear,1662,root/html532/TGTableHeaderFrame.html,https://root.cern,https://root.cern/root/html532/TGTableHeaderFrame.html,2,['Clear'],['Clear']
Usability,"w::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoCombiTransEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for combi matrix editor. ~TGeoCombiTransEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected combi matrix. void DoName(); Slot for name. void DoRotPhi(); Slot for phi (Euler X convention). void DoRotTheta(); Slot for theta (Euler X convention). void DoRotPsi(); Slot for psi (Euler X convention). void DoRotAngle(); Slot for additional rotation about one axis. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying modifications. void DoCancel(); Slot for cancelling last un-applied operations. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last changes. void DoDx(); Slot for X. void DoDy(); Slot for Y. void DoDz(); Slot for Z. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMatrixEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCombiTransEditor.html:22179,undo,undoing,22179,root/html528/TGeoCombiTransEditor.html,https://root.cern,https://root.cern/root/html528/TGeoCombiTransEditor.html,1,['undo'],['undoing']
Usability,"w::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoCombiTransEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for combi matrix editor. ~TGeoCombiTransEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected combi matrix. void DoName(); Slot for name. void DoRotPhi(); Slot for phi (Euler X convention). void DoRotTheta(); Slot for theta (Euler X convention). void DoRotPsi(); Slot for psi (Euler X convention). void DoRotAngle(); Slot for additional rotation about one axis. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying modifications. void DoCancel(); Slot for cancelling last un-applied operations. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last changes. void DoDx(); Slot for X. void DoDy(); Slot for Y. void DoDz(); Slot for Z. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMatrixEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoCombiTransEditor.html:22279,undo,undoing,22279,root/html530/TGeoCombiTransEditor.html,https://root.cern,https://root.cern/root/html530/TGeoCombiTransEditor.html,1,['undo'],['undoing']
Usability,"w::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoCombiTransEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for combi matrix editor. ~TGeoCombiTransEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected combi matrix. void DoName(); Slot for name. void DoRotPhi(); Slot for phi (Euler X convention). void DoRotTheta(); Slot for theta (Euler X convention). void DoRotPsi(); Slot for psi (Euler X convention). void DoRotAngle(); Slot for additional rotation about one axis. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying modifications. void DoCancel(); Slot for cancelling last un-applied operations. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last changes. void DoDx(); Slot for X. void DoDy(); Slot for Y. void DoDz(); Slot for Z. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMatrixEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoCombiTransEditor.html:22279,undo,undoing,22279,root/html532/TGeoCombiTransEditor.html,https://root.cern,https://root.cern/root/html532/TGeoCombiTransEditor.html,2,['undo'],['undoing']
Usability,"w::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPconEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPconEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a given pcon. void CreateSections(Int_t inew); Change dynamically the number of sections. Bool_t CheckSections(Bool_t change = kFALSE); Check validity of sections. void UpdateSections(); Update sections according fShape. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoSectionChange(Int_t i); Change parameters of section isect;. void DoNz(); Change number of sections. void DoPhi(); Change phi range. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); {;}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoPconEditor.h 21425 2007-12-17 15:59:27Z brun $ » Last generated: 2010-11-08 19:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPconEditor.html:21973,undo,undoing,21973,root/html528/TGeoPconEditor.html,https://root.cern,https://root.cern/root/html528/TGeoPconEditor.html,1,['undo'],['undoing']
Usability,"w::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPconEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPconEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a given pcon. void CreateSections(Int_t inew); Change dynamically the number of sections. Bool_t CheckSections(Bool_t change = kFALSE); Check validity of sections. void UpdateSections(); Update sections according fShape. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoSectionChange(Int_t i); Change parameters of section isect;. void DoNz(); Change number of sections. void DoPhi(); Change phi range. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); {;}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoPconEditor.h 21425 2007-12-17 15:59:27Z brun $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoPconEditor.html:22073,undo,undoing,22073,root/html530/TGeoPconEditor.html,https://root.cern,https://root.cern/root/html530/TGeoPconEditor.html,1,['undo'],['undoing']
Usability,"w::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPconEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPconEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a given pcon. void CreateSections(Int_t inew); Change dynamically the number of sections. Bool_t CheckSections(Bool_t change = kFALSE); Check validity of sections. void UpdateSections(); Update sections according fShape. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoSectionChange(Int_t i); Change parameters of section isect;. void DoNz(); Change number of sections. void DoPhi(); Change phi range. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); {;}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoPconEditor.h 21425 2007-12-17 15:59:27Z brun $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPconEditor.html:22073,undo,undoing,22073,root/html532/TGeoPconEditor.html,https://root.cern,https://root.cern/root/html532/TGeoPconEditor.html,2,['undo'],['undoing']
Usability,"w;  TGWindow (const TGWindow &tgw);  ;  TGWindow (Window_t id);  ; TGWindow & operator= (const TGWindow &tgw);  ;  Protected Member Functions inherited from TGObject; TGObject & operator= (const TGObject &tgo);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual const char * GetSenderClassName () const;  . Protected Attributes; TGCheckButton * fAutoUpdate;  ; TGComboBox * fComboBox;  ; TRootEmbeddedCanvas * fHistCanvas;  canvas to draw the histogram ;  ; TH1D * fHisto;  histogram of image pixels ;  ; TVirtualPad * fImagePad;  ; LimitLine * fLimitLine [2];  ; Double_t fMaxValue;  max value of image ;  ; Double_t fMinValue;  min value of image ;  ; PaintPalette * fPaintPalette;  ; TImagePalette * fPalette;  current palette ;  ; TRootEmbeddedCanvas * fPaletteCanvas;  canvas to draw the current palette ;  ; TList * fPaletteList;  list of palettes for undo and redo ;  ; Int_t fRampFactor;  ; TGRadioButton * fRamps [3];  ; TGTextButton * fReDoButton;  ; TGCheckButton * fStepButton;  ; TGTextButton * fUnDoButton;  ;  Protected Attributes inherited from TPaletteEditor; TAttImage * fAttImage {nullptr};  ;  Protected Attributes inherited from TGMainFrame; TList * fBindList;  list with key bindings ;  ; TString fClassName;  WM class name. ;  ; Atom_t * fDNDTypeList;  handles DND types ;  ; TString fIconName;  icon name ;  ; TString fIconPixmap;  icon pixmap name ;  ; UInt_t fMWMFuncs;  MWM functions. ;  ; UInt_t fMWMInput;  MWM input modes. ;  ; UInt_t fMWMValue;  MWM decoration hints. ;  ; TString fResourceName;  WM resource name. ;  ; TString fWindowName;  window name ;  ; UInt_t fWMHeight;  WM height. ;  ; UInt_t fWMHeightInc;  WM height increments. ;  ; EInitialState fWMInitState;  WM initial state. ;  ; UInt_t fWMMaxHeight;  WM max height. ;  ; UInt_t f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASPaletteEditor.html:31274,undo,undo,31274,doc/master/classTASPaletteEditor.html,https://root.cern,https://root.cern/doc/master/classTASPaletteEditor.html,1,['undo'],['undo']
Usability,"wGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-04-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGDockableFrame.html:21709,Undo,Undocked,21709,root/html534/TGDockableFrame.html,https://root.cern,https://root.cern/root/html534/TGDockableFrame.html,2,['Undo'],['Undocked']
Usability,"wRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw lines in exposed region. Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Bool_t HandleTimer(TTimer* t); Handle scroll timer. Bool_t HandleButton(Event_t* event); Handle mouse button event in text editor. Bool_t HandleDoubleClick(Event_t* event); handle double click. Bool_t HandleMotion(Event_t* event); Handle mouse motion event in the text editor widget. Bool_t HandleSelectionClear(Event_t* event); Handle selection clear event. Bool_t HandleSelectionRequest(Event_t* event); Handle request to send current clipboard contents to requestor window. Bool_t HandleDNDDrop(TDNDData* data); Handle Drop event. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle Drag position event. Atom_t HandleDNDEnter(Atom_t* typelist); Handle Drag Enter event. Bool_t HandleDNDLeave(); Handle Drag Leave event. void Mark(Long_t xPos, Long_t yPos); Mark a text region from xPos to yPos. void UnMark(); Clear marked region. void AdjustWidth(); Adjust widget width to longest line. void Layout(); Layout the components of view. void HLayout(); Horizontal layout of widgets (canvas, scrollbar). void VLayout(); Vertical layout of widgets (canvas, scrollbar). void SetSBRange(Int_t direction); Set the range for the kVertical or kHorizontal scrollbar. void SetHsbPosition(Long_t newPos); Set position of horizontal scrollbar. void SetVsbPosition(Long_t newPos); Set position of vertical scrollbar. FontStruct_t GetDefaultFontStruct(); Return default font structure in use. void ShowBottom(); Show bottom of the page. void ShowTop(); Show top of the page. void SetForegroundColor(Pixel_t ); Set text color. const TGGC & GetDefaultGC(); Return default graphics context in use. const TGGC & GetDefaultSelectedGC(); Return selection graphics context in use. const TGGC & GetDefaultSelectedBackgroundGC(); Return graphics context for highlighted frame background. void SavePrimitive(ostream& out, Option_t* = """");",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTextView.html:27381,Clear,Clear,27381,root/html532/TGTextView.html,https://root.cern,https://root.cern/root/html532/TGTextView.html,4,['Clear'],['Clear']
Usability,"want for the progress bar, but we need to; // take care that two threads will not print to terminal at the same time: we need a std::mutex for synchronization.; std::string progressBar;; std::mutex barMutex; // Only one thread at a time can lock a mutex. Let's use this to avoid concurrent printing.; // Magic numbers that yield good progress bars for nSlots = 1,2,4,8; const auto everyN = nSlots == 8 ? 1000 : 100ull * nSlots;; const auto barWidth = nEvents / everyN;; h.OnPartialResultSlot(everyN, [&barWidth, &progressBar, &barMutex](unsigned int /*slot*/, TH1D & /*partialHist*/) {; std::lock_guard<std::mutex> l(barMutex); // lock_guard locks the mutex at construction, releases it at destruction; progressBar.push_back('#');; // re-print the line with the progress bar; std::cout << ""\r["" << std::left << std::setw(barWidth) << progressBar << ']' << std::flush;; });; ; // ## Running the analysis; // So far we told RDataFrame what we want to happen during the event-loop, but we have not actually run any of those; // actions: the TBrowser is still empty, the progress bar has not been printed even once, and we haven't produced; // a single data-point!; // As usual with RDataFrame, the event-loop is triggered by accessing the contents of a TResultProxy for the first; // time. Let's run!; std::cout << ""Analysis running..."" << std::endl;; h->Draw(); // the final, complete result will be drawn after the event-loop has completed.; std::cout << ""\nDone!"" << std::endl;; ; // Finally, some book-keeping: in the TMemFile that we are using as TBrowser directory, we substitute the partial; // result with a clone of the final result (the ""original"" final result will be deleted at the end of the macro).; dfDirectory->Clear();; auto clone = static_cast<TH1D *>(h->Clone());; clone->SetDirectory(nullptr);; dfDirectory->Add(clone);; if (!browserPad); return; // in case root -b was invoked; browserPad->cd();; clone->Draw();; browserPad->Update();; }; d#define d(i)Definition RSha256.hxx:102; h#d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df013__InspectAnalysis_8C.html:5604,progress bar,progress bar,5604,doc/master/df013__InspectAnalysis_8C.html,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html,2,['progress bar'],['progress bar']
Usability,"ways considered to be dirty. void setACleanADirty(Bool_t flag); This global switch changes the cache mode of all objects marked as 'always clean'; to 'always dirty'. For internal use in RooRealIntegral. void verboseDirty(Bool_t flag); Activate verbose messaging related to dirty flag propagation. Bool_t isCloneOf(const RooAbsArg& other) const; Check if this object was created as a clone of 'other'. void setAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes are unset. void setStringAttribute(const Text_t* key, const Text_t* value); Associate string 'value' to this object under key 'key'. const Text_t* getStringAttribute(const Text_t* key) const; Get string attribute mapped under key 'key'. Returns null pointer; if no attribute exists under that key. void setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getTransientAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes; are unset. void addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Register another RooAbsArg as a server to us, ie, declare that; we depend on it. In addition to the basic client-server relationship,; we can declare dependence on the server's value and/or shape. void addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Register a list of RooAbsArg as servers to us by calls; addServer() for each arg in the list. void removeServer(RooAbsArg& server, Bool_t force = kFALSE); Unregister another RooAbsArg as a server to us, ie, declare that; we no longer depend on its value and shape. void replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); Replace 'oldServer' with 'newServer'. void change",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:18633,clear,clear,18633,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,3,['clear'],['clear']
Usability,"ween two points; TMVA::Interval Interval definition, continous and discrete; TMVA::KDEKernel Kernel density estimator for PDF smoothing; TMVA::MCFitter Fitter using Monte Carlo sampling of parameters ; TMVA::MethodANNBase Base class for TMVA ANNs; TMVA::MethodBDT Analysis of Boosted Decision Trees; TMVA::MethodBase Virtual base class for all TMVA method; TMVA::MethodBayesClassifier Friedman's BayesClassifier method ; TMVA::MethodBoost ; TMVA::MethodCFMlpANN Interface for Clermond-Ferrand artificial neural network; TMVA::MethodCFMlpANN_Utils Implementation of Clermond-Ferrand artificial neural network; TMVA::MethodCategory ; TMVA::MethodCommittee Analysis of Boosted MVA methods; TMVA::MethodCompositeBase ; TMVA::MethodCuts Multivariate optimisation of signal efficiency; TMVA::MethodDT Analysis of Decision Trees ; TMVA::MethodFDA Function Discriminant Analysis; TMVA::MethodFisher Analysis of Fisher discriminant (Fisher or Mahalanobis approach) ; TMVA::MethodHMatrix H-Matrix method, a simple comparison of chi-squared estimators for signal and background; TMVA::MethodKNN k Nearest Neighbour classifier; TMVA::MethodLD Linear discriminant analysis; TMVA::MethodLikelihood Likelihood analysis (""non-parametric approach"") ; TMVA::MethodMLP Multi-layer perceptron implemented specifically for TMVA; TMVA::MethodPDEFoam Analysis of PDEFoam discriminant (PDEFoam or Mahalanobis approach) ; TMVA::MethodPDERS Multi-dimensional probability density estimator range search (PDERS) method; TMVA::MethodRuleFit Friedman's RuleFit method; TMVA::MethodSVM Support Vector Machine; TMVA::MethodSeedDistance Function Discriminant Analysis; TMVA::MethodTMlpANN Implementation of interface for TMultiLayerPerceptron; TMVA::MetricEuler calculates the ""distance"" between two points; TMVA::MetricManhattan calculates the ""distance"" between two points; TMVA::MinuitFitter Fitter using a Genetic Algorithm; TMVA::MinuitWrapper Wrapper around TMinuit; TMVA::MisClassificationError Implementation of the MisClassif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:97461,simpl,simple,97461,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,2,['simpl'],['simple']
Usability,"ween; buttons and drawnbuttons (let's say icons) and assign to them their; own actions (let's say ROOT or C++ commands). The macro belows shows an example of controlbar.; To execute an item, click with the left mouse button.; To see the HELP of a button, click on the right mouse button. You have access to the last clicked button via the method; GetClicked(). For example, bar->GetClicked()->GetName(); will return the name of the last clicked button. {; gROOT.Reset(""a"");; TControlBar bar(""vertical"");; bar.AddButton(""Help to run demos"","".x demoshelp.C"",; ""Explains how to run the demos"");; bar.AddButton(""framework"", "".x framework.C"",; ""An Example of Object Oriented User Interface"");; bar.AddButton(""hsimple"", "".x hsimple.C"",; ""An Example Creating Histograms/Ntuples on File"");; bar.AddButton(""hsum"", "".x hsum.C"",; ""Filling histograms and some graphics options"");; bar.AddButton(""canvas"", "".x canvas.C"",; ""Canvas and Pad Management"");; bar.AddButton(""formula1"", "".x formula1.C"",; ""Simple Formula and Functions"");; bar.AddButton(""fillrandom"", "".x fillrandom.C"",; ""Histograms with Random Numbers from a Function"");; bar.AddButton(""fit1"", "".x fit1.C"",; ""A Simple Fitting Example"");; bar.AddButton(""h1draw"", "".x h1draw.C"",; ""Drawing Options for 1D Histograms"");; bar.AddButton(""graph"", "".x graph.C"",; ""Examples of a simple graph"");; bar.AddButton(""tornado"", "".x tornado.C"",; ""Examples of 3-D PolyMarkers"");; bar.AddButton(""shapes"", "".x shapes.C"",; ""The Geometry Shapes"");; bar.AddButton(""atlasna49"", "".x atlasna49.C"",; ""Creating and Viewing Geometries"");; bar.AddButton(""file_layout"", "".x file.C"",; ""The ROOT file format"");; bar.AddButton(""tree_layout"", "".x tree.C"",; ""The Tree Data Structure"");; bar.AddButton(""ntuple1"", "".x ntuple1.C"",; ""Ntuples and Selections"");; bar.AddButton(""run benchmarks"", "".x benchmarks.C"",; ""Runs all the ROOT benchmarks"");; bar.AddButton(""rootmarks"", "".x rootmarks.C"",; ""Prints an estimated ROOTMARKS for your machine"");; bar.AddButton(""edit_hsimple"", "".!ved hsimple.C &"",",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TControlBar.html:1418,Simpl,Simple,1418,root/html602/TControlBar.html,https://root.cern,https://root.cern/root/html602/TControlBar.html,2,['Simpl'],['Simple']
Usability,"weights go to nan and lead to an ABORT. MethodANNBase(TMVA::Types::EMVA methodType, TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir); construct the Method from the weight file. void DeclareOptions(); define the options (their key words) that can be set in the option string; here the options valid for ALL MVA methods are declared.; know options: NCycles=xx :the number of training cycles; Normalize=kTRUE,kFALSe :if normalised in put variables should be used; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers; NeuronType=sigmoid,tanh,radial,linar : the type of activation function; used at the neuronn. void ProcessOptions(); do nothing specific at this moment. std::vector<Int_t>* ParseLayoutString(TString layerSpec); parse layout specification string and return a vector, each entry; containing the number of neurons to go in each successive layer. void InitANNBase(); initialize ANNBase object. ~MethodANNBase(); destructor. void DeleteNetwork(); delete/clear network. void DeleteNetworkLayer(TObjArray*& layer); delete a network layer. void BuildNetwork(vector<Int_t>* layout, vector<Double_t>* weights = __null, Bool_t fromFile = kFALSE); build network given a layout (number of neurons in each layer); and optional weights array. void BuildLayers(vector<Int_t>* layout, Bool_t from_file = false); build the network layers. void BuildLayer(Int_t numNeurons, TObjArray* curLayer, TObjArray* prevLayer, Int_t layerIndex, Int_t numLayers, Bool_t from_file = false); build a single layer with neurons and synapses connecting this; layer to the previous layer. void AddPreLinks(TMVA::TNeuron* neuron, TObjArray* prevLayer); add synapses connecting a neuron to its preceding layer. void InitWeights(); initialize the synapse weights randomly. void ForceWeights(vector<Double_t>* weights); force the synapse weights. void ForceNetworkInputs(const TMVA::Event* ev, Int_t ignoreIndex = -1); force the input values of the input neurons; force the value f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodANNBase.html:21601,clear,clear,21601,root/html602/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodANNBase.html,4,['clear'],['clear']
Usability,"wer before rendering a scene if some; moderately significant part of render-context has changed. Here we update the basic state (clear last-LOD, mark the time,; set global <-> scene transforamtion matrices) and potentially; study and refine the clipping planes based on scene bounding box. void LodifySceneInfo(TGLRnrCtx& ctx); Setup LOD-dependant values in scene-info. Nothing to be done here but to store the last LOD. void PreDraw(TGLRnrCtx& rnrCtx); Perform basic pre-render initialization:; - calculate LOD, Style, Clipping,; - build draw lists. This is called in the beginning of the GL-viewer draw cycle. void PreRender(TGLRnrCtx& rnrCtx); Perform pre-render initialization - fill rnrCtx with; values stored during PreDraw(). This is called each time before RenderXyzz(). void Render(TGLRnrCtx& rnrCtx); This function does rendering of all stages, the shapes are; rendered in the following order: opaque, transparent,; selected-opaque, selected-transparent. GL-depth buffer is cleared after transparent shapes have been; rendered. This is never called from ROOT GL directly. Use it if you know; you are rendering a single scene. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque elements. void RenderTransp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements for highlight. void RenderSelOpaqueForHighlight(TGLRnrCtx& rnrCtx); Render selected opaque elements for highlight. void RenderSelTranspForHighlight(TGLRnrCtx& rnrCtx); Render selected transparent elements. void PostRender(TGLRnrCtx& rnrCtx); Perform post-render clean-up. void PostDraw(TGLRnrCtx& rnrCtx); Finalize drawing. This is called at the end of the GL-viewer draw cycle. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLSceneBase.html:6370,clear,cleared,6370,root/html534/TGLSceneBase.html,https://root.cern,https://root.cern/root/html534/TGLSceneBase.html,6,['clear'],['cleared']
Usability,"wer before rendering a scene if some; moderately significant part of render-context has changed. Here we update the basic state (clear last-LOD, mark the time,; set global <-> scene transforamtion matrices) and potentially; study and refine the clipping planes based on scene bounding box. void LodifySceneInfo(TGLRnrCtx& ctx); Setup LOD-dependant values in scene-info. Nothing to be done here but to store the last LOD. void PreDraw(TGLRnrCtx& rnrCtx); Perform basic pre-render initialization:; - calculate LOD, Style, Clipping,; - build draw lists. This is called in the beginning of the GL-viewer draw cycle. void PreRender(TGLRnrCtx& rnrCtx); Perform pre-render initialization - fill rnrCtx with; values stored during PreDraw(). This is called each time before RenderXyzz(). void Render(TGLRnrCtx& rnrCtx); This function does rendering of all stages, the shapes are; rendered in the following order: opaque, transparent,; selected-opaque, selected-transparent. GL-depth buffer is cleared after transparent shapes have been; rendered. This is never called from ROOT GL directly. Use it if you know; you are rendering a single scene. void RenderOpaque(TGLRnrCtx& rnrCtx); Render opaque elements. void RenderTransp(TGLRnrCtx& rnrCtx); Render transparent elements. void RenderSelOpaque(TGLRnrCtx& rnrCtx); Render selected opaque elements. void RenderSelTransp(TGLRnrCtx& rnrCtx); Render selected transparent elements. void PostRender(TGLRnrCtx& rnrCtx); Perform post-render clean-up. void PostDraw(TGLRnrCtx& rnrCtx); Finalize drawing. This is called at the end of the GL-viewer draw cycle. Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx); Process selection record rec.; 'curIdx' is the item position where the scene should start; its processing.; Return TRUE if an object has been identified or FALSE otherwise.; The scene-info member of the record is already set by the caller. See implementation in sub-class TGLScene, here we just return FALSE. TGLSceneBase& operator=(const TGLScen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLSceneBase.html:6231,clear,cleared,6231,root/html528/TGLSceneBase.html,https://root.cern,https://root.cern/root/html528/TGLSceneBase.html,4,['clear'],['cleared']
Usability,"when reconnecting ; Definition at line 10583 of file TProof.cxx. ◆ SetDataPoolUrl(). void TProof::SetDataPoolUrl ; (; const char * ; url). inline . Definition at line 1044 of file TProof.h. ◆ SetDataSetTreeName(). Int_t TProof::SetDataSetTreeName ; (; const char * ; dataset, . const char * ; treename . ). virtual . Set/Change the name of the default tree. ; The tree name may contain subdir specification in the form ""subdir/name"". Returns 0 on success, -1 otherwise. ; Reimplemented in TProofLite.; Definition at line 10766 of file TProof.cxx. ◆ SetDrawFeedbackOption(). void TProof::SetDrawFeedbackOption ; (; TDrawFeedback * ; f, . Option_t * ; opt . ). Set draw feedback option. ; Definition at line 10102 of file TProof.cxx. ◆ SetDSet(). void TProof::SetDSet ; (; TDSet * ; dset). inlineprotected . Definition at line 737 of file TProof.h. ◆ SetFeedback(). void TProof::SetFeedback ; (; TString & ; opt, . TString & ; optfb, . Int_t ; action . ). protected . Extract from opt in optfb information about wanted feedback settings. ; Feedback are removed from the input string opt. If action == 0, set up feedback accordingly, if action == 1 clean related feedback settings (using info in optfb, if available, or reparsing opt).; Feedback requirements are in the form <previous_option>fb=name1,name2,name3,... <next_option>; <previous_option>feedback=name1,name2,name3,...;<next_option>; The special name 'stats' triggers feedback about events and packets. The separator from the next option is either a ' ' or a ';'. Called interanally by TProof::Process. ; Definition at line 5232 of file TProof.cxx. ◆ SetInputDataFile(). void TProof::SetInputDataFile ; (; const char * ; datafile). Set the file to be used to optimally distribute the input data objects. ; If the file exists the object in the file are added to those in the fInputData list. If the file path is null, a default file will be created at the moment of sending the processing request with the content of the fInputData list. See a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:142720,feedback,feedback,142720,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['feedback'],['feedback']
Usability,"which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLearnPrefill() const; {return fPrefillType;}. TTree * GetTree() const; {return fTree;}. Bool_t IsAutoCreated() const; {return fAutoCreated;}. Bool_t IsEnabled() const; {return fEnabled;}. Bool_t IsLearning() const; {return fIsLearning;}. void SetAutoCreated(Bool_t val); {fAutoCreated = val;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:26458,learn,learning,26458,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,3,"['Learn', 'learn']","['LearnPrefill', 'learning']"
Usability,"with an object of the same name already existing in; the list, or just added.; The boolean merged is set to kFALSE when the object is just added to 'outlist';; this happens if the Merge() method does not exist or if a object named as 'obj'; is not already in the list. If the obj is not 'merged' than it should not be; deleted, unless outlist is not owner of its objects.; Return 0 on success, -1 on error. TObject * HandleHistogram(TObject* obj, Bool_t& merged); Low statistic histograms need a special treatment when using autobin. Bool_t HistoSameAxis(TH1* h0, TH1* h1); Return kTRUE is the histograms 'h0' and 'h1' have the same binning and ranges; on the axis (i.e. if they can be just Add-ed for merging). void StoreOutput(TList* out); Store received output list. TList * MergeFeedback(); Merge feedback lists. void StoreFeedback(TObject* slave, TList* out); Store feedback results from the specified slave. void SetupFeedback(); Setup reporting of feedback objects. void StopFeedback(); Stop reporting of feedback objects. Bool_t HandleTimer(TTimer* timer); Send feedback objects to client. TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet for specified slave. Bool_t IsClient() const; Is the player running on the client?. Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (support for TChain::Draw()).; Returns -1 in case of error or number of selected events in case of success. void SetInitTime(); Set init time. TVirtualPacketizer * GetPacketizer() const; { return 0; }. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). TProof * GetProof() const; { return fProof; }. TProofPlayerRemote(TProof* proof = 0); { fProgressStatus = n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofPlayerRemote.html:19421,feedback,feedback,19421,root/html532/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html532/TProofPlayerRemote.html,8,['feedback'],['feedback']
Usability,"with the worker. If needed, this master will move the worker from the active to the inactive list and rebuild the list of unique workers. Use ord = ""*"" to deactivate all active workers. The string 'ord' can also be a comma-separated list of ordinal numbers the status of which will be modified at once. Return <0 if something went wrong (-2 if at least one worker was not found) or the number of workers with status change (on master; 0 on client). ; Definition at line 11370 of file TProof.cxx. ◆ DeclFileName(). static const char * TProof::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 1073 of file TProof.h. ◆ DelEnvVar(). void TProof::DelEnvVar ; (; const char * ; name). static . Remove an variable from the list of environment variables passed to proofserv on the master and slaves. ; Definition at line 11782 of file TProof.cxx. ◆ DeleteDrawFeedback(). void TProof::DeleteDrawFeedback ; (; TDrawFeedback * ; f). Delete draw feedback object. ; Definition at line 10110 of file TProof.cxx. ◆ DeleteParameters(). void TProof::DeleteParameters ; (; const char * ; wildcard). Delete the input list parameters specified by a wildcard (e.g. ; PROOF_*) or exact name (e.g. PROOF_MaxSlavesPerNode). ; Definition at line 9933 of file TProof.cxx. ◆ Detach(). void TProof::Detach ; (; Option_t * ; opt = """"). Detach this instance to its proofserv. ; If opt is 'S' or 's' the remote server is shutdown ; Definition at line 10518 of file TProof.cxx. ◆ DisableGoAsyn(). void TProof::DisableGoAsyn ; (; ). Signal to disable related switches. ; Definition at line 6259 of file TProof.cxx. ◆ DisablePackage(). Int_t TProof::DisablePackage ; (; const char * ; pack). private . Remove a specific package. ; Returns 0 in case of success and -1 in case of error. ; Definition at line 7885 of file TProof.cxx. ◆ DisablePackages(). Int_t TProof::DisablePackages ; (; ). private . Remove all packages. ; Returns 0 in case of success and -1 in case of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:81981,feedback,feedback,81981,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['feedback'],['feedback']
Usability,"wn; unless the option 0 is set. The following example illustrates the option 0 combined with the option; COL. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,600);; c1->Divide(1,2);; TH2F *hcol21 = new TH2F(""hcol21"",""Option COLZ"",40,-4,4,40,-20,20);; TH2F *hcol22 = new TH2F(""hcol22"",""Option COLZ0"",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol21->Fill(px,5*py);; hcol22->Fill(px,5*py);; }; hcol21->SetBit(TH1::kNoStats);; hcol22->SetBit(TH1::kNoStats);; gStyle->SetPalette(57);; c1->cd(1); hcol21->Draw(""COLZ"");; c1->cd(2); hcol22->Draw(""COLZ0"");; hcol22->SetMaximum(100);; hcol22->SetMinimum(40);; return c1;; }. The option COL can be combined with the option POL:. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol1->Fill(px,py);; }; gStyle->SetPalette(57);; hcol1->Draw(""COLZPOL"");; return c1;; }; The CANDLE option; A Candle plot (also known as; a ""box-and whisker plot"" or simply ""box plot"") is a convenient way to describe; graphically a data distribution (D) with only five numbers. It was invented; in 1977 by John Tukey. With the option CANDLEX five numbers are:. The minimum value of the distribution D (bottom dashed line).; The lower quartile (Q1): 25% of the data points in D are less than; Q1 (bottom of the box).; The median (M): 50% of the data points in D are less than M; (thick line segment inside the box).; The upper quartile (Q3): 75% of the data points in D are less; than Q3 (top of the box).; The maximum value of the distribution D (top dashed line). The mean value of the distribution D is also represented as a circle. In this implementation a TH2 is considered as a collection of TH1 along; X (option CANDLE or CANDLEX) or Y (option CANDLEY).; Each TH1 is represented as a candle plot. Picture; Source. {; TCanvas *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THistPainter.html:33340,simpl,simply,33340,root/html604/THistPainter.html,https://root.cern,https://root.cern/root/html604/THistPainter.html,2,['simpl'],['simply']
Usability,"wo discriminating variables collectively denoted  which are chosen within three possible variables denoted , and .; The variable which is not incorporated in  is used as the control variable . The six distributions of the three variables are assumed to be the ones depicted in Fig. 1. Figure 1:; Distributions of the three discriminating variables available to perform the Likelihood fit:; , , .; Among the three variables, two are used to perform the fit while one is; kept out of the fit to serve the purpose of a control variable. The; three distributions on the top (resp. bottom) of the figure correspond; to the signal (resp. background). The unit of the vertical axis is; chosen such that it indicates the number of entries per bin, if one; slices the histograms in 25 bins. A data sample being built through a Monte Carlo simulation based on the distributions shown in Fig. 1, one obtains the three distributions of Fig. 2. Whereas the distribution of  clearly indicates the presence of the signal, the distribution of and are less obviously populated by signal. Figure 2:; Distributions of the three discriminating variables for signal plus; background. The three distributions are the ones obtained from a data; sample obtained through a Monte Carlo simulation based on the; distributions shown in Fig. 1. The data sample consists of 500 signal events and 5000 background events. Chosing and as discriminating variables to determine and through a maximum Likelihood fit, one builds, for the control variable which is unknown to the fit, the two ; for signal and background shown in Fig. 3. One observes that the . for signal reproduces correctly the PDF even where the latter vanishes,; although the error bars remain sizeable. This results from the almost; complete cancellation between positive and negative weights: the sum of; weights is close to zero while the sum of weights squared is not. The; occurence of negative weights occurs through the appearance of the; covariance matrix, an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSPlot.html:6246,clear,clearly,6246,root/html602/TSPlot.html,https://root.cern,https://root.cern/root/html602/TSPlot.html,4,['clear'],['clearly']
Usability,"works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:22767,learn,learning,22767,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,4,['learn'],['learning']
Usability,"write; kWriteDelete; };. private:. Int_tfCountnumber of updates contributing to error field; Double_tfDEDwsum of deltas; Double_tfDeltalocal error field; Double_tfLearnRatelearning rate parameter; TMVA::TNeuron*fPostNeuronpointer to post-neuron; TMVA::TNeuron*fPreNeuronpointer to pre-neuron; Double_tfWeightweight of the synapse; static TMVA::MsgLogger*fgLogger! message logger, static to save resources. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSynapse(); constructor. ~TSynapse(); destructor. void SetWeight(Double_t weight); set synapse weight. Double_t GetWeightedValue(); get output of pre-neuron weighted by synapse weight. Double_t GetWeightedDelta(); get error field of post-neuron weighted by synapse weight. void AdjustWeight(); adjust the weight based on the error field all ready calculated by CalculateDelta. void CalculateDelta(); calculate/adjust the error field for this synapse. TSynapse(). Double_t GetWeight(); get the weight of the synapse. { return fWeight; }. void SetLearningRate(Double_t rate); set the learning rate. { fLearnRate = rate; }. Double_t GetLearningRate(); get the learning rate. { return fLearnRate; }. void DecayLearningRate(Double_t rate); decay the learning rate. { fLearnRate *= (1-rate); }. void SetPreNeuron(TMVA::TNeuron* pre); set the pre-neuron. { fPreNeuron = pre; }. void SetPostNeuron(TMVA::TNeuron* post); set hte post-neuron. { fPostNeuron = post; }. void InitDelta(); initialize the error field of the synpase to 0. { fDelta = 0.0; fCount = 0; }. void SetDEDw(Double_t DEDw); { fDEDw = DEDw; }. Double_t GetDEDw(); { return fDEDw; }. Double_t GetDelta(); { return fDelta; }. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TSynapse.h 33928 2010-06-15 16:19:31Z stelzer $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__TSynapse.html:6591,learn,learning,6591,root/html528/TMVA__TSynapse.html,https://root.cern,https://root.cern/root/html528/TMVA__TSynapse.html,3,['learn'],['learning']
Usability,"write; kWriteDelete; };. private:. Int_tfCountnumber of updates contributing to error field; Double_tfDEDwsum of deltas; Double_tfDeltalocal error field; Double_tfLearnRatelearning rate parameter; TMVA::TNeuron*fPostNeuronpointer to post-neuron; TMVA::TNeuron*fPreNeuronpointer to pre-neuron; Double_tfWeightweight of the synapse; static TMVA::MsgLogger*fgLogger! message logger, static to save resources. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSynapse(); constructor. ~TSynapse(); destructor. void SetWeight(Double_t weight); set synapse weight. Double_t GetWeightedValue(); get output of pre-neuron weighted by synapse weight. Double_t GetWeightedDelta(); get error field of post-neuron weighted by synapse weight. void AdjustWeight(); adjust the weight based on the error field all ready calculated by CalculateDelta. void CalculateDelta(); calculate/adjust the error field for this synapse. TSynapse(). Double_t GetWeight(); get the weight of the synapse. { return fWeight; }. void SetLearningRate(Double_t rate); set the learning rate. { fLearnRate = rate; }. Double_t GetLearningRate(); get the learning rate. { return fLearnRate; }. void DecayLearningRate(Double_t rate); decay the learning rate. { fLearnRate *= (1-rate); }. void SetPreNeuron(TMVA::TNeuron* pre); set the pre-neuron. { fPreNeuron = pre; }. void SetPostNeuron(TMVA::TNeuron* post); set hte post-neuron. { fPostNeuron = post; }. void InitDelta(); initialize the error field of the synpase to 0. { fDelta = 0.0; fCount = 0; }. void SetDEDw(Double_t DEDw); { fDEDw = DEDw; }. Double_t GetDEDw(); { return fDEDw; }. Double_t GetDelta(); { return fDelta; }. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TSynapse.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__TSynapse.html:6660,learn,learning,6660,root/html532/TMVA__TSynapse.html,https://root.cern,https://root.cern/root/html532/TMVA__TSynapse.html,6,['learn'],['learning']
Usability,"ws - the total number of rows to be inserted; = 1 ""by default; return:; The number of the rows has been shifted to accomodate; the new rows. void * ReAllocate(); Reallocate this table leaving only (used rows)+1 allocated; GetTableSize() = GetNRows() + 1; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void * ReAllocate(Int_t newsize); Reallocate this table leaving only <newsize> allocated; GetTableSize() = newsize;; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void ReAlloc(Int_t newsize); The table is reallocated if it is an owner of the internal array. Char_t * Create(); Allocate a space for the new table, if any; Sleep for a while if space is not available and try again. void Browse(TBrowser* b); Wrap each table coulumn with TColumnView object to browse. void Clear(Option_t* opt = """"); Deletes the internal array of this class; if this object does own its internal table. void Delete(Option_t* opt = """"). Delete the internal array and free the memory it occupied; if this object did own this array. Then perform TDataSet::Delete(opt). TClass * GetRowClass() const; to be documented. Long_t GetNRows() const; Returns the number of the used rows for the wrapped table. Long_t GetRowSize() const; Returns the size (in bytes) of one table row. Long_t GetTableSize() const; Returns the number of the allocated rows. void Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); Fit a projected item(s) from a TTable*-; *-* =======================================. formula is a TF1 expression. See TTable::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTable.html:27367,Clear,Clear,27367,root/html532/TTable.html,https://root.cern,https://root.cern/root/html532/TTable.html,4,['Clear'],['Clear']
Usability,"wvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCollection::IsEmptyvirtual Bool_t IsEmpty() constDefinition TCollection.h:188; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMethodCall::Executevoid Execute(const char *, const char *, int *=nullptr) overrideExecute method on this object with the given parameter string, e.g.Definition TMethodCall.h:64; TMethodCall::IsValidBool_t IsValid() constReturn true if the method call has been properly initialized and is usable.Definition TMethodCall.cxx:376; TMethodCall::InitWithPrototypevoid InitWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)Initialize the method invocation environment.Definition TMethodCall.cxx:342; TMethodCall::SetParamvoid SetParam(Long_t l)Add a long method parameter.Definition TMethodCall.cxx:606; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::IsEqualvirtual Bool_t IsEqual(const TObject *obj) constDefault equal comparison (objects are equal if they have the same address in memory).Definition TObject.cxx:570; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::InheritsFromvirtual Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSeqCollection_8cxx_source.html:11586,usab,usable,11586,doc/master/TSeqCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSeqCollection_8cxx_source.html,1,['usab'],['usable']
Usability,"x, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidChangeTab(Int_t tabIndex, Bool_t emit = kTRUE); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TGTab&operator=(const TGTab&); TGTab(const TGTab&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TGWindow::EEditModeTGWindow::kEditDisable; static TGWindow::EEditModeTGWindow::kEditDisableBtnEnable; static TGWindow::EEditModeTGWindow::kEditDisableEvents; static TGWindow::EEditModeTGWindow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTab.html:16733,Clear,ClearFlags,16733,root/html602/TGTab.html,https://root.cern,https://root.cern/root/html602/TGTab.html,2,['Clear'],['ClearFlags']
Usability,"x. ◆ IsImplicitMTEnabledImpl(). static Bool_t & ROOT::Internal::IsImplicitMTEnabledImpl ; (; ). static . Keeps track of the status of ImplicitMT w/o resorting to the load of libImt. ; Definition at line 463 of file TROOT.cxx. ◆ IsParBranchProcessingEnabled(). Bool_t ROOT::Internal::IsParBranchProcessingEnabled ; (; ). Returns true if parallel branch processing is enabled. ; Definition at line 447 of file TROOT.cxx. ◆ LogicalCPUBandwidthControl(). int ROOT::Internal::LogicalCPUBandwidthControl ; (; ). Returns the available number of logical cores. . Checks if there is CFS bandwidth control in place (linux, via cgroups, assuming standard paths); Otherwise, returns the number of logical cores provided by std::thread::hardware_concurrency() . Definition at line 50 of file RTaskArena.cxx. ◆ MinimalErrorHandler(). void ROOT::Internal::MinimalErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const char * ; location, . const char * ; msg . ). A very simple error handler that is usually replaced by the TROOT default error handler. ; The minimal error handler is not serialized across threads, so that output of multi-threaded programs can get scrambled Noteabort() is only called if abort_bool is true and level >= gErrorIgnoreLevel ; Definition at line 67 of file TError.cxx. ◆ NotifyDirected(). void ROOT::Internal::NotifyDirected ; (; Detail::TBranchProxy * ; x). Definition at line 36 of file TBranchProxyDirector.cxx. ◆ operator<<(). std::ostream & ROOT::Internal::operator<< ; (; std::ostream & ; os, . const RConcurrentHashColl::HashValue & ; h . ). Definition at line 24 of file RConcurrentHashColl.cxx. ◆ operator==(). bool ROOT::Internal::operator== ; (; const RConcurrentHashColl::HashValue & ; lhs, . const RConcurrentHashColl::HashValue & ; rhs . ). inline . Definition at line 69 of file RConcurrentHashColl.hxx. ◆ ParallelReduceHelper(). template<typename T > . static T ROOT::Internal::ParallelReduceHelper ; (; const std::vector< T > & ; objs, . const std::function< T(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:38215,simpl,simple,38215,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,2,['simpl'],['simple']
Usability,"x1: outside radius at -DZ in z; rmin2: inside radius at +DZ in z; rmax2: outside radius at +DZ in z . Definition at line 28 of file TCONE.h. Public Member Functions;  TCONE ();  CONE shape default constructor. ;  ;  TCONE (const char *name, const char *title, const char *material, Float_t dz, Float_t rmax1, Float_t rmax2=0);  CONE shape ""simplified"" constructor. ;  ;  TCONE (const char *name, const char *title, const char *material, Float_t dz, Float_t rmin1, Float_t rmax1, Float_t rmin2, Float_t rmax2);  CONE shape normal constructor. ;  ;  ~TCONE () override;  CONE shape default destructor. ;  ; Float_t GetRmax2 () const;  ; Float_t GetRmin2 () const;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TTUBE;  TTUBE ();  TUBE shape default constructor. ;  ;  TTUBE (const char *name, const char *title, const char *material, Float_t rmax, Float_t dz);  TUBE shape ""simplified"" constructor. ;  ;  TTUBE (const char *name, const char *title, const char *material, Float_t rmin, Float_t rmax, Float_t dz, Float_t aspect=1);  TUBE shape normal constructor. ;  ;  ~TTUBE () override;  TUBE shape default destructor. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a TUBE. ;  ; virtual Float_t GetAspectRatio () const;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections) const override;  Get buffer 3d. ;  ; virtual Float_t GetDz () const;  ; virtual Int_t GetNdiv () const;  ; virtual Int_t GetNumberOfDivisions () const;  ; virtual Float_t GetRmax () const;  ; virtual Float_t GetRmin () const;  ; TClass * IsA () const override;  ; virtual void SetAspectRatio (Float_t factor=1);  ; virtual void SetNumberOfDivisions (Int_t ndiv);  Set number of divisions used to draw this tube. ;  ; void Sizeof3D () const override;  Return total X3D needed by TNode::ls (when called wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCONE.html:1557,simpl,simplified,1557,doc/master/classTCONE.html,https://root.cern,https://root.cern/doc/master/classTCONE.html,1,['simpl'],['simplified']
Usability,"x:381; TRandom::Binomialvirtual Int_t Binomial(Int_t ntot, Double_t prob)Generates a random integer N according to the binomial law.Definition TRandom.cxx:212; Note that the time to generate a number from an arbitrary TF1 function using TF1::GetRandom or using TUnuran is independent of the complexity of the function.; TH1::FillRandom(TH1 *) or TH1::FillRandom(const char *tf1name) can be used to fill an histogram (1-d, 2-d, 3-d from an existing histogram or from an existing function.; Note this interesting feature when working with objects. You can use several TRandom objects, each with their ""independent"" random sequence. For example, one can imagine TRandom *eventGenerator = new TRandom();; TRandom *tracking = new TRandom();; eventGenerator can be used to generate the event kinematics. tracking can be used to track the generated particles with random numbers independent from eventGenerator. This very interesting feature gives the possibility to work with simple and very fast random number generators without worrying about random number periodicity as it was the case with Fortran. One can use TRandom::SetSeed to modify the seed of one generator.; A TRandom object may be written to a Root file. as part of another object; or with its own key (example: gRandom->Write(""Random"") ) ; . Definition at line 27 of file TRandom.h. Public Member Functions;  TRandom (UInt_t seed=65539);  Default constructor. For seed see SetSeed(). ;  ;  ~TRandom () override;  Default destructor. ;  ; virtual Int_t Binomial (Int_t ntot, Double_t prob);  Generates a random integer N according to the binomial law. ;  ; virtual Double_t BreitWigner (Double_t mean=0, Double_t gamma=1);  Return a number distributed following a BreitWigner function with mean and gamma. ;  ; virtual void Circle (Double_t &x, Double_t &y, Double_t r);  Generates random vectors, uniformly distributed over a circle of given radius. ;  ; virtual Double_t Exp (Double_t tau);  Returns an exponential deviate. ;  ; virtual Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRandom.html:10630,simpl,simple,10630,doc/master/classTRandom.html,https://root.cern,https://root.cern/doc/master/classTRandom.html,1,['simpl'],['simple']
Usability,"x;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  line.cxxThis ROOT 7 example demonstrates how to create a ROOT 7 canvas (RCanvas) and draw ROOT 7 lines in it (RLine) ;  lineStyle.cxx;  lineWidth.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  vo004_SortAndSelect.C In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo004_SortAndSelect.py In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo005_Combinations.C In this tutorial we learn how combinations of RVecs can be build ;  vo005_Combinations.py In this tutorial we learn how combinations of RVecs can be build ;  vo006_IndexManipulation.C In this tutorial we demonstrate RVec helpers for index manipulation ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlmodifyfile.C Example to read, modify and store xml file, using TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro ru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:172721,learn,learn,172721,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['learn'],['learn']
Usability,"x;; 1584 fSelectedY = py;; 1585 }; 1586 }; 1587 return pad;; 1588}; 1589 ; 1590////////////////////////////////////////////////////////////////////////////////; 1591/// Emit Picked() signal.; 1592 ; 1593void TCanvas::Picked(TPad *pad, TObject *obj, Int_t event); 1594{; 1595 Longptr_t args[3];; 1596 ; 1597 args[0] = (Longptr_t) pad;; 1598 args[1] = (Longptr_t) obj;; 1599 args[2] = event;; 1600 ; 1601 Emit(""Picked(TPad*,TObject*,Int_t)"", args);; 1602}; 1603 ; 1604////////////////////////////////////////////////////////////////////////////////; 1605/// Emit Highlighted() signal.; 1606///; 1607/// - pad is pointer to pad with highlighted histogram or graph; 1608/// - obj is pointer to highlighted histogram or graph; 1609/// - x is highlighted x bin for 1D histogram or highlighted x-th point for graph; 1610/// - y is highlighted y bin for 2D histogram (for 1D histogram or graph not in use); 1611 ; 1612void TCanvas::Highlighted(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y); 1613{; 1614 Longptr_t args[4];; 1615 ; 1616 args[0] = (Longptr_t) pad;; 1617 args[1] = (Longptr_t) obj;; 1618 args[2] = x;; 1619 args[3] = y;; 1620 ; 1621 Emit(""Highlighted(TVirtualPad*,TObject*,Int_t,Int_t)"", args);; 1622}; 1623 ; 1624////////////////////////////////////////////////////////////////////////////////; 1625/// This is ""simplification"" for function TCanvas::Connect with Highlighted; 1626/// signal for specific slot.; 1627///; 1628/// Slot has to be defined ""UserFunction(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y)""; 1629/// all parameters of UserFunction are taken from TCanvas::Highlighted; 1630 ; 1631void TCanvas::HighlightConnect(const char *slot); 1632{; 1633 Connect(""Highlighted(TVirtualPad*,TObject*,Int_t,Int_t)"", nullptr, nullptr, slot);; 1634}; 1635 ; 1636////////////////////////////////////////////////////////////////////////////////; 1637/// Emit Selected() signal.; 1638 ; 1639void TCanvas::Selected(TVirtualPad *pad, TObject *obj, Int_t event); 1640{; 1641 Longptr_t args[3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:50816,simpl,simplification,50816,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['simpl'],['simplification']
Usability,"x;i++){; �����; for(j=0;j<nbinsy;j++){�� ��������������� ; �������� fwrite(source[i][j],; sizeof(source[0][0][0]),nbinsz,out);; ����� }; �� }�� ; �� fclose(out);����� ; �� ; ��; back->Draw("""");� ; };  ;  . const char* SmoothMarkov(float*** source, Int_t ssizex, Int_t ssizey, Int_t ssizez, Int_t averWindow). THREE-DIMENSIONAL MARKOV SPECTRUM SMOOTHING FUNCTION. This function calculates smoothed spectrum from source spectrum; based on Markov chain method.; The result is placed in the array pointed by spectrum pointer. Function parameters:; source-pointer to the array of source spectrum; working_space-pointer to the working array; ssizex-x length of spectrum and working space arrays; ssizey-y length of spectrum and working space arrays; ssizey-z length of spectrum and working space arrays; averWindow-width of averaging smoothing window. . Smoothing;  ; Goal: Suppression of statistical fluctuations; �        ; the algorithm is based on discrete Markov chain, which has very simple; invariant distribution;  ; ����������� �����; �������; ��being defined from the normalization; condition ; �������� n is the length of the smoothed spectrum and .  ;  ;  . is the; probability of the change of the peak position from channel i to the channel; i+1.� is; the normalization constant so that �and m is a width of smoothing window.; We have extended this algorithm to three dimensions. ;  ; Function:; const char*; TSpectrum3::SmoothMarkov(float; ***fSpectrum, int fSizex, int; fSizey, int fSizey, �int; fAverWindow)� ;  ; This function calculates smoothed; spectrum from the source spectrum based on Markov chain method. The result is; placed in the field pointed by source pointer. On successful completion it; returns 0. On error it returns pointer to the string describing error.;  ; Parameters:; ������� fSpectrum-pointer to the matrix of source; spectrum����������������� ; ������� fSizex, fSizey, fSizez -lengths of the; spectrum matrix��������������� �����������������; ������� fAverWindow-w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum3.html:18606,simpl,simple,18606,root/html528/TSpectrum3.html,https://root.cern,https://root.cern/root/html528/TSpectrum3.html,6,['simpl'],['simple']
Usability,"xD& S12, TMatrixD& S21, TMatrixDSym& S22); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; const TMatrixDSym&covarianceMatrix() const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMultiVarGaussian.html:3445,clear,clearValueDirty,3445,root/html534/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html534/RooMultiVarGaussian.html,6,['clear'],['clearValueDirty']
Usability,"xDBase::kAtA,m);; const TMatrixDSymEigen eigen(mtm);; const TVectorD eigenVal = eigen.GetEigenValues();; const Bool_t ok = VerifyVectorIdentity(sig,eigenVal,1,1.-e-14);; 14.8 Speed Comparisons; Speed of four matrix operations have been compared between four matrix libraries, GSL CLHEP, ROOT v3.10 and ROOT v4.0. Next figure shows the CPU time for these four operations as a function of the matrix size:. A*B The execution time is measured for the sum of A * Bsym, Bsym* A and A * B. Notice the matrix_size3 dependence of execution time. CLHEP results are hampered by a poor implementation of symmetric matrix multiplications. For instance, for general matrices of size 100x100, the time is 0.015 sec. while A * Bsym takes 0.028 sec and Bsym* A takes 0.059 sec. Both GSL and ROOT v4.0 can be setup to use the hardware-optimized multiplication routines of the BLAS libraries. It was tested on a G4 PowerPC. The improvement becomes clearly visible around sizes of (50x50) were the execution speed improvement of the Altivec processor becomes more significant than the overhead of filling its pipe. \(A^{-1}\) Here, the time is measured for an in-place matrix inversion. Except for ROOT v3.10, the algorithms are all based on an LUfactorization followed by forward/back-substitution. ROOT v3.10 is using the slower Gaussian elimination method. The numerical accuracy of the CLHEP routine is poor:. up to 6x6 the numerical imprecise Cramer multiplication is hard-coded. For instance, calculating U=H*H-1, where H is a (5x5) Hilbert matrix, results in off-diagonal elements of \(10^{-7}\) instead of the \(10^{-13}\) using an LUaccording to Crout.; scaling protection is non-existent and limits are hard-coded, as a consequence inversion of a Hilbert matrix for sizes>(12x12) fails. In order to gain speed the CLHEP algorithm stores its permutation info of the pivots points in a static array, making multi-threading not possible. GSL uses LU decomposition without the implicit scaling of Crout. Therefore",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:802290,clear,clearly,802290,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['clear'],['clearly']
Usability,"x_t & GetWeightsAt (size_t i);  ; const Matrix_t & GetWeightsAt (size_t i) const;  ; size_t GetWidth () const;  ; virtual void Initialize ();  Initialize the weights and biases according to the given initialization method. ;  ; bool IsTraining () const;  ; virtual void Print () const =0;  Prints the info about the layer. ;  ; void ReadMatrixXML (void *node, const char *name, Matrix_t &matrix);  ; virtual void ReadWeightsFromXML (void *parent)=0;  Read the information and the weights about the layer from XML node. ;  ; virtual void ResetTraining ();  Reset some training flags after a loop on all batches Some layer (e.g. ;  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetDepth (size_t depth);  ; virtual void SetDropoutProbability (Scalar_t);  Set Dropout probability. ;  ; virtual void SetExtraLayerParameters (const std::vector< Matrix_t > &);  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:5145,learn,learningRate,5145,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"xclusiongraph2.C;   Draw several graphs with an exclusion zones. ;  ;  gerrors.C;   Draw a graph with error bars ;  ;  gerrors2.C;   Draw two graphs with error bars ;  ;  gmultierrors.C;   Draw a graph with multiple y errors ;  ;  graph.C;   Draw a simple graph. ;  ;  graph2derrorsfit.C;   Draw and fit a TGraph2DErrors ;  ;  graphApply.C;   A macro to demonstrate the functionality of TGraph::Apply() method. ;  ;  graphpalettecolor.C;   Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ;  ;  graphpolar.C;   Create and draw a polar graph. ;  ;  graphpolar2.C;   Create and draw a polar graph with PI axis ;  ;  graphpolar3.C;   Create and draw a polar graph with PI axis using a TF1. ;  ;  graphreverse.C;   This example test all the various case of reverse graphs combined with logarithmic scale. ;  ;  graphShade.C;   Show how to shade an area between two graphs ;  ;  graphstruct.C;   Draw a simple graph structure. ;  ;  graphtext.C;   Draw a graph with text attached to each point. ;  ;  gtime.C;   Example of TGraphTime. ;  ;  gtime2.C;   Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program. ;  ;  hlGraph1.C;  This tutorial demonstrates how to use the highlight mode on graph. ;  ;  hlGraph2.C;  This tutorial demonstrates how to use the highlight mode on graph. ;  ;  labels1.C;   Setting alphanumeric labels in a 1-d histogram. ;  ;  labels2.C;   Setting alphanumeric labels. ;  ;  motorcycle.C;   Macro to test scatterplot smoothers: ksmooth, lowess, supsmu as described in: ;  ;  multigraph.C;   Create and Draw a TMultiGraph. ;  ;  multigraphpalettecolor.C;   Palette coloring for multi-graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ;  ;  multipalette.C;   Draw color plots using different color palettes. ;  ;  scatter.C;   D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html:1582,simpl,simple,1582,doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html,https://root.cern,https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html,1,['simpl'],['simple']
Usability,"xel coordinates. If (px,py) is the cursor position, px=0 and py=0 corresponds to the top-left corner of the pad, which is the standard convention in windowing systems.; 9.3.2.4 Using NDC for a particular Object; Most of the time, you will be using the user coordinate system. But sometimes, you will want to use NDC. For example, if you want to draw text always at the same place over a histogram, no matter what the histogram coordinates are. There are two ways to do this. You can set the NDC for one object or may convert NDC to user coordinates. Most graphical objects offer an option to be drawn in NDC. For instance, a line (TLine) may be drawn in NDC by using DrawLineNDC(). A latex formula or a text may use TText::SetNDC() to be drawn in NDC coordinates.; 9.3.3 Converting between Coordinate Systems; There are a few utility functions in TPad to convert from one system of coordinates to another. In the following table, a point is defined by (px,py) in pixel coordinates, (ux,uy) in user coordinates, (ndcx,ndcy) in normalized coordinates, (apx, apy) are in absolute pixel coordinates. Conversion; TPad’s Methods; Returns. NDC to Pixel; UtoPixel(ndcx); VtoPixel(ndcy); Int_t; Int_t. Pixel to User; PixeltoX(px); PixeltoY(py); PixeltoXY(px,py,&ux,&uy); Double_t; Double_t; Double_t ux,uy. User to Pixel; XtoPixel(ux); YtoPixel(uy); XYtoPixel(ux,uy,&px,&py); Int_t; Int_t; Int_t px,py. User to absolute pixel; XtoAbsPixel(ux); YtoAbsPixel(uy); XYtoAbsPixel(ux,uy,&apx,&apy); Int_t; Int_t; Int_t apx,apy. Absolute pixel to user; AbsPixeltoX(apx); AbsPixeltoY(apy); AbsPixeltoXY(apx,apy,&ux,&uy); Double_t; Double_t; Double_t ux,uy. Note: all the pixel conversion functions along the Y axis consider that py=0 is at the top of the pad except PixeltoY() which assume that the position py=0 is at the bottom of the pad. To make PixeltoY() converting the same way as the other conversion functions, it should be used the following way (p is a pointer to a TPad):; p->PixeltoY(py - p->GetWh());; 9.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:310549,ux,ux,310549,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['ux'],['ux']
Usability,"xel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; TGButtonGroup*fgrGroup the Radiobuttons:. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPieEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of graph editor. ~TPieEditor(); Destructor of pie editor. void ConnectSignals2Slots(); Connect signals to slots. void ActivateBaseClassEditors(TClass* ); Exclude TAttTextEditor from this interface. void SetModel(TObject* ); Pick up the used values of graph attributes. void DoTitle(const char* text); Slot for setting the graph title. void DoShape(); Slot connected to the draw options. void DoMarkerOnOff(Bool_t on); Slot for setting markers as visible/invisible. void DoChange3DAngle(); Slot for setting the 3D angle. void DoGraphLineWidth(); Slot connected to the graph line width. void DoTextChange(); Change text. TGComboBox* BuildFontSizeComboBox(TGFrame* , Int_t ); Create text size combo box. » Author: Guido Volpi 04/10/2007 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id: TPieEditor.h 31945 2009-12-21 19:03:21Z rdm $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPieEditor.html:21659,Guid,Guido,21659,root/html532/TPieEditor.html,https://root.cern,https://root.cern/root/html532/TPieEditor.html,1,['Guid'],['Guido']
Usability,"xel_t back = GetDefaultFrameBackground()); virtual~TGContainer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidAdjustPosition(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidAssociate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual voidClearViewPort(); virtual voidClicked(TGFrame* f, Int_t btn)SIGNAL ; virtual voidClicked(TGFrame* f, Int_t btn, Int_t x, Int_t y)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCurrentChanged(TGFrame* f)SIGNAL ; virtual voidCurrentChanged(Int_t x, Int_t y)SIGNAL ; virtual voidTGFrame::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGContainer.html:2756,Clear,Clear,2756,root/html532/TGContainer.html,https://root.cern,https://root.cern/root/html532/TGContainer.html,2,['Clear'],['Clear']
Usability,"xel_tTGFrame::fgDefaultFrameBackground; static const TGGC*fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*fgDefaultSelectedBackgroundGC; static const TGGC*fgDefaultSelectedGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGTextEntry(const TGWindow* p, TGTextBuffer* text, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t option = kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); Create a text entry widget. It will adopt the TGTextBuffer object; (i.e. the text buffer will be deleted by the text entry widget). TGTextEntry(const TGWindow* parent = 0, const char* text = 0, Int_t id = -1); Simple text entry constructor. TGTextEntry(const TString& contents, const TGWindow* parent, Int_t id = -1); Simple test entry constructor. Notice TString argument comes before the; parent argument (to make this ctor different from the first one taking a; const char*). ~TGTextEntry(); Delete a text entry widget. void Init(); Do default initialization. TGDimension GetDefaultSize() const; Return the default / minimal size of the widget. void SetDefaultSize(UInt_t w, UInt_t h); Set the default / minimal size of the widget. void ReturnPressed(); This signal is emitted when the return or enter key is pressed. void ShiftTabPressed(); This signal is emitted when <SHIFT> and <TAB> keys are pressed. void TabPressed(); This signal is emitted when the <TAB> key is pressed. void TextChanged(const char* text = 0); This signal is emitted every time the text has changed. void CursorOutLeft(); This signal is emitted when cursor is going out of left side. void CursorOutRight(); T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTextEntry.html:26594,Simpl,Simple,26594,root/html532/TGTextEntry.html,https://root.cern,https://root.cern/root/html532/TGTextEntry.html,2,['Simpl'],['Simple']
Usability,"xis * GetYaxis()Definition TH1.h:325; TH1::GetNdivisionsvirtual Int_t GetNdivisions(Option_t *axis=""X"") constReturn the number of divisions for ""axis"".Definition Haxis.cxx:27; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::GetMaximumStoredvirtual Double_t GetMaximumStored() constDefinition TH1.h:289; TH1::GetMinimumvirtual Double_t GetMinimum(Double_t minval=-FLT_MAX) constReturn minimum value larger than minval of bins in the range, unless the value has been overridden by...Definition TH1.cxx:8635; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TIterDefinition TCollection.h:235; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::PaintLinevirtual void PaintLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:399; TListIterIterator of linked list.Definition TList.h:193; TListIter::NextTObject * Next() overrideReturn next object in the list. Returns 0 when no more objects in list.Definition TList.cxx:1109; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::FirstTObject * First() const overrideReturn the first object in the list. Returns 0 when list is empty.Definition TList.cxx:657; TList::FirstLinkvirtual TObjLink * FirstLink() constDefinition TList.h:104; TList::AddFirstvoid AddFirst(T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:208845,simpl,simple,208845,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['simpl'],['simple']
Usability,"xis; TAxisfCartesianYAxis; TAxisfCartesianZAxis; Int_tfColorScheme; TGLParametricEquation*fEquation; TGL2DArray<TGLParametricPlot::Vertex_t>fMesh; Int_tfMeshSize; Bool_tfShowMesh; static TGLParametricPlot::EMeshSizekHigh; static TGLParametricPlot::EMeshSizekLow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLParametricPlot(TGLParametricEquation* equation, TGLPlotCamera* camera); Constructor. Bool_t InitGeometry(); Build mesh. The surface is 'immutable':; the only reason to rebuild it - the change in size or; if one of equations contain reference to TF2 function, whose; parameters were changed. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. char * GetPlotInfo(Int_t px, Int_t py); No object info yet. void AddOption(const TString& option); No additional options for parametric surfaces. void ProcessEvent(Int_t event, Int_t px, Int_t py); Change color/mesh size or switch on/off mesh/box cut.; Left double click - remove box cut. void InitGL() const; Initialize gl state. void DeInitGL() const; Initialize gl state. void DrawPlot() const; Draw parametric surface. void InitColors(); Calculate colors for vertices,; using one of 20 color themes.; -1 simple 'metal' surface. void DrawSectionXOZ() const; No such sections. void DrawSectionYOZ() const; No such sections. void DrawSectionXOY() const; No such sections. void SetSurfaceColor() const; Set material properties. TGLParametricPlot(TGLParametricEquation* equation, TGLPlotCamera* camera). » Author: Timur Pocheptsov 26/01/2007 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-02 15:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLParametricPlot.html:5823,simpl,simple,5823,root/html604/TGLParametricPlot.html,https://root.cern,https://root.cern/root/html604/TGLParametricPlot.html,2,['simpl'],['simple']
Usability,"xis; TAxisfCartesianYAxis; TAxisfCartesianZAxis; Int_tfColorScheme; TGLParametricEquation*fEquation; TGL2DArray<TGLParametricPlot::Vertex_t>fMesh; Int_tfMeshSize; Bool_tfShowMesh; static TGLParametricPlot::EMeshSizekHigh; static TGLParametricPlot::EMeshSizekLow. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLParametricPlot(TGLParametricEquation* equation, TGLPlotCamera* camera); Constructor. Bool_t InitGeometry(); Build mesh. The surface is 'immutable':; the only reason to rebuild it - the change in size or; if one of equations contain reference to TF2 function, whose; parameters were changed. void StartPan(Int_t px, Int_t py); User clicks right mouse button (in a pad). void Pan(Int_t px, Int_t py); User's moving mouse cursor, with middle mouse button pressed (for pad).; Calculate 3d shift related to 2d mouse movement. char * GetPlotInfo(Int_t px, Int_t py); No object info yet. void AddOption(const TString& option); No additional options for parametric surfaces. void ProcessEvent(Int_t event, Int_t px, Int_t py); Change color/mesh size or switch on/off mesh/box cut.; Left double click - remove box cut. void InitGL() const; Initialize gl state. void DeInitGL() const; Initialize gl state. void DrawPlot() const; Draw parametric surface. void InitColors(); Calculate colors for vertices,; using one of 20 color themes.; -1 simple 'metal' surface. void DrawSectionXOZ() const; No such sections. void DrawSectionYOZ() const; No such sections. void DrawSectionXOY() const; No such sections. void SetSurfaceColor() const; Set material properties. TGLParametricPlot(TGLParametricEquation* equation, TGLPlotCamera* camera). » Author: Timur Pocheptsov 26/01/2007 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLParametricPlot.html:5823,simpl,simple,5823,root/html602/TGLParametricPlot.html,https://root.cern,https://root.cern/root/html602/TGLParametricPlot.html,2,['simpl'],['simple']
Usability,"xlo, . double ; xhi . ); const. overridevirtual . Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ; Reimplemented from RooAbsReal.; Definition at line 130 of file RooParamHistFunc.cxx. ◆ setActual(). void RooParamHistFunc::setActual ; (; Int_t ; ibin, . double ; newVal . ). Definition at line 104 of file RooParamHistFunc.cxx. ◆ Streamer(). void RooParamHistFunc::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooParamHistFunc::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 63 of file RooParamHistFunc.h. ◆ translate(). void RooParamHistFunc::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 80 of file RooParamHistFunc.cxx. Friends And Related Symbol Documentation. ◆ RooHistConstraint. friend class RooHistConstraint. friend . Definition at line 52 of file RooParamHistFunc.h. Member Data Documentation. ◆ _dh. RooDataHist RooParamHistFunc::_dh. protected . Definition at line 56 of file RooParamHistFunc.h. ◆ _p. RooListProxy RooParamHistFunc::_p. protected . Definition at line 55 of file RooParamHistFunc.h. ◆ _relPar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooParamHistFunc.html:66133,simpl,simple,66133,doc/master/classRooParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooParamHistFunc.html,1,['simpl'],['simple']
Usability,"xpensiveObjectCache Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; List of all members ; RooExpensiveObjectCache Class ReferenceRooFit » RooFit Core. ; Singleton class that serves as repository for objects that are expensive to calculate. ; Owners of such objects can registers these here with associated parameter values for which the object is valid, so that other instances can, at a later moment retrieve these precalculated objects. ; Definition at line 24 of file RooExpensiveObjectCache.h. Classes; class  ExpensiveObject;  . Public Member Functions;  RooExpensiveObjectCache ();  ;  RooExpensiveObjectCache (const RooExpensiveObjectCache &other);  ;  ~RooExpensiveObjectCache () override;  Destructor. ;  ; void clearAll ();  Clear all cache elements. ;  ; bool clearObj (Int_t uniqueID);  Clear cache element with given unique ID Retrieve payload object of cache element with given unique ID. ;  ; bool empty () const;  ; const TObject * getObj (Int_t uniqueID);  Retrieve payload object of cache element with given unique ID. ;  ; void importCacheObjects (RooExpensiveObjectCache &other, const char *ownerName, bool verbose=false);  ; TClass * IsA () const override;  ; void print () const;  ; bool registerObject (const char *ownerName, const char *objectName, TObject &cacheObject, const RooArgSet &params);  Register object associated with given name and given associated parameters with given values in cache. ;  ; const TObject * retrieveObject (const char *name, TClass *tclass, const RooArgSet &params);  Retrieve object from cache that was registered under given name with given parameters, if current parameter values match those that were stored in the registry for this object. ;  ; bool setObj (Int_t uniqueID, TObject *obj);  Place new payload object in cache element with given unique ID. ;  ; Int_t size (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExpensiveObjectCache.html:952,clear,clearObj,952,doc/master/classRooExpensiveObjectCache.html,https://root.cern,https://root.cern/doc/master/classRooExpensiveObjectCache.html,1,['clear'],['clearObj']
Usability,"xplained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1176 of file TUnfoldSys.cxx. ◆ GetEmatrixSysUncorr(). void TUnfoldSys::GetEmatrixSysUncorr ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). Covariance contribution from uncorrelated uncertainties of the response matrix. ; Parameters. [in,out]ematrixcovariance matrix histogram ; [in]binMapmapping of histogram bins ; [in]clearEmatif true, ematrix is cleared prior to adding this covariance matrix contribution. This method propagates the uncertainties of the response matrix histogram, specified with the constructor, to the unfolding result. It is assumed that the entries of that histogram are bin-to-bin uncorrelated. In many cases this corresponds to the ""Monte Carlo statistical uncertainties"". ; The array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 760 of file TUnfoldSys.cxx. ◆ GetEmatrixTotal(). void TUnfoldSys::GetEmatrixTotal ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr . ). Get total error matrix, summing up all contributions. ; Parameters. [out]ematrixhistogram which will be filled ; [in]binMap(default=nullptr) remapping of histogram bins. the array binMap is explained with the method GetOutput(). ; Definition at line 1276 of file TUnfoldSys.cxx. ◆ GetRhoItotal(). void TUnfoldSys::GetRhoItotal ; (; TH1 * ; rhoi, . const Int_t * ; binMap = nullptr, . TH2 * ; invEmat = nullptr . ). Get global correlatiocn coefficients, summing up all contributions. ; Parameters. [out]rhoihistogram which will be filled ; [in]binMap(default=nullptr) remapping of histogram bins ; [out]invEmat(default=nullptr) inverse of error matrix. return the global correlation coefficients, including all error sources. If invEmat is nonzero, the inverse of the error matrix is retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:42453,clear,clearEmat,42453,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearEmat']
Usability,xt {-1}. protected . ! next entry number where cache must be filled ; Definition at line 41 of file TTreeCache.h. ◆ fFillTimes. Int_t TTreeCache::fFillTimes {0}. protected . ! how many times we can fill the current buffer ; Definition at line 59 of file TTreeCache.h. ◆ fFirstBuffer. bool TTreeCache::fFirstBuffer {true}. protected . ! true if first buffer is used for prefetching ; Definition at line 56 of file TTreeCache.h. ◆ fFirstEntry. Long64_t TTreeCache::fFirstEntry {-1}. protected . ! save the value of the first entry ; Definition at line 61 of file TTreeCache.h. ◆ fFirstMiss. Long64_t TTreeCache::fFirstMiss {-1}. protected . ! set to the event # of the first miss. ; Definition at line 73 of file TTreeCache.h. ◆ fFirstTime. bool TTreeCache::fFirstTime {true}. protected . ! save the fact that we processes the first entry ; Definition at line 60 of file TTreeCache.h. ◆ fgLearnEntries. Int_t TTreeCache::fgLearnEntries = 100. staticprotected . number of entries used for learning mode ; Definition at line 65 of file TTreeCache.h. ◆ fIsLearning. bool TTreeCache::fIsLearning {true}. protected . ! true if cache is in learning mode ; Definition at line 54 of file TTreeCache.h. ◆ fIsManual. bool TTreeCache::fIsManual {false}. protected . ! true if cache is StopLearningPhase was used ; Definition at line 55 of file TTreeCache.h. ◆ fLastMiss. Long64_t TTreeCache::fLastMiss {-1}. protected . ! set to the event # of the last miss. ; Definition at line 74 of file TTreeCache.h. ◆ fLearnPrefilling. bool TTreeCache::fLearnPrefilling {false}. protected . ! true if we are in the process of executing LearnPrefill ; Definition at line 68 of file TTreeCache.h. ◆ fMissCache. std::unique_ptr<MissCache> TTreeCache::fMissCache. protected . ! Cache contents for misses ; Definition at line 105 of file TTreeCache.h. ◆ fNbranches. Int_t TTreeCache::fNbranches {0}. protected . ! Number of branches in the cache ; Definition at line 44 of file TTreeCache.h. ◆ fNextClusterStart. Long64_t TTreeCac,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:54081,learn,learning,54081,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['learn'],['learning']
Usability,"xtEvent. Reads both from CmdTree and GuiTree and chooses that event that becomes; earlier; - fCmdTreeCounter determines actual position in fCmdTree; - fGuiTreeCounter determines actual position in fCmdTree. If GUI event should be replayed, we must first make sure that there is; appropriate mapping for this event. RETURN VALUE:; kFALSE = there is no event to be replayed; kTRUE = there is still at least one event to be replayed. Cases:; - fNextEvent = 0 => We are waiting for the appropriate; window to be registered; - fNextEvent != 0 => fNextEvent can be replayed (windows are; ready). Bool_t CanOverlap(); ButtonPress and ButtonRelease must be sometimes replayed more times; Example: pressing of a button opens small window and user chooses; something from that window (color); Window must be opened while user is choosing. void ReplayRealtime(); Replays the next event. It is called when fTimer times out.; Every time fTimer is set again to time equal to time difference between; current two events being replayed. It can happen that execution of an event lasts different time during the; recording and during the replaying.; If fTimer times out too early and the previous event has not been yet; replayed, it is usually postponed in order; to keep events execution in the right order.; The excpetions are determined by TRecorderReplaying::CanOverlap(). void Pause(TRecorder* r); Pauses replaying. void ReplayStop(TRecorder* r); Cancels replaying. void Continue(); Continues previously paused replaying. TRecorder::ERecorderState GetState() const; Gets current state of recorder. TRecorderReplaying(const char* filename). » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRecorderReplaying.html:6103,pause,paused,6103,root/html528/TRecorderReplaying.html,https://root.cern,https://root.cern/root/html528/TRecorderReplaying.html,1,['pause'],['paused']
Usability,"xtEvent. Reads both from CmdTree and GuiTree and chooses that event that becomes; earlier; - fCmdTreeCounter determines actual position in fCmdTree; - fGuiTreeCounter determines actual position in fCmdTree. If GUI event should be replayed, we must first make sure that there is; appropriate mapping for this event. RETURN VALUE:; kFALSE = there is no event to be replayed; kTRUE = there is still at least one event to be replayed. Cases:; - fNextEvent = 0 => We are waiting for the appropriate; window to be registered; - fNextEvent != 0 => fNextEvent can be replayed (windows are; ready). Bool_t CanOverlap(); ButtonPress and ButtonRelease must be sometimes replayed more times; Example: pressing of a button opens small window and user chooses; something from that window (color); Window must be opened while user is choosing. void ReplayRealtime(); Replays the next event. It is called when fTimer times out.; Every time fTimer is set again to time equal to time difference between; current two events being replayed. It can happen that execution of an event lasts different time during the; recording and during the replaying.; If fTimer times out too early and the previous event has not been yet; replayed, it is usually postponed in order; to keep events execution in the right order.; The excpetions are determined by TRecorderReplaying::CanOverlap(). void Pause(TRecorder* r); Pauses replaying. void ReplayStop(TRecorder* r); Cancels replaying. void Continue(); Continues previously paused replaying. TRecorder::ERecorderState GetState() const; Gets current state of recorder. TRecorderReplaying(const char* filename). » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2011-07-04 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TRecorderReplaying.html:6103,pause,paused,6103,root/html530/TRecorderReplaying.html,https://root.cern,https://root.cern/root/html530/TRecorderReplaying.html,1,['pause'],['paused']
Usability,"xtEvent. Reads both from CmdTree and GuiTree and chooses that event that becomes; earlier; - fCmdTreeCounter determines actual position in fCmdTree; - fGuiTreeCounter determines actual position in fCmdTree. If GUI event should be replayed, we must first make sure that there is; appropriate mapping for this event. RETURN VALUE:; kFALSE = there is no event to be replayed; kTRUE = there is still at least one event to be replayed. Cases:; - fNextEvent = 0 => We are waiting for the appropriate; window to be registered; - fNextEvent != 0 => fNextEvent can be replayed (windows are; ready). Bool_t CanOverlap(); ButtonPress and ButtonRelease must be sometimes replayed more times; Example: pressing of a button opens small window and user chooses; something from that window (color); Window must be opened while user is choosing. void ReplayRealtime(); Replays the next event. It is called when fTimer times out.; Every time fTimer is set again to time equal to time difference between; current two events being replayed. It can happen that execution of an event lasts different time during the; recording and during the replaying.; If fTimer times out too early and the previous event has not been yet; replayed, it is usually postponed in order; to keep events execution in the right order.; The excpetions are determined by TRecorderReplaying::CanOverlap(). void Pause(TRecorder* r); Pauses replaying. void ReplayStop(TRecorder* r); Cancels replaying. void Continue(); Continues previously paused replaying. TRecorder::ERecorderState GetState() const; Gets current state of recorder. TRecorderReplaying(const char* filename). » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRecorderReplaying.html:6103,pause,paused,6103,root/html532/TRecorderReplaying.html,https://root.cern,https://root.cern/root/html532/TRecorderReplaying.html,4,"['Pause', 'pause']","['Pause', 'Pauses', 'paused']"
Usability,"xt_t GetNormGC () const;  ; Float_t GetPosition () const;  ; Bool_t GetShowPos () const;  ; const char * GetValueFormat () const;  ; void Increment (Float_t inc);  Increment progress position. ;  ; TClass * IsA () const override;  ; virtual void Percent (Bool_t on);  ; virtual void Reset ();  Reset progress bar (i.e. set pos to 0). ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save progress bar parameters as a C++ statement(s) on output stream out. ;  ; void SetBarColor (const char *color=""blue"");  Set progress bar color. ;  ; virtual void SetBarColor (Pixel_t color);  Set progress bar color. ;  ; void SetBarType (EBarType type);  Set bar type. ;  ; void SetFillType (EFillType type);  Set fill type. ;  ; void SetForegroundColor (Pixel_t pixel) override;  Change text color drawing. ;  ; void SetMax (Float_t max);  ; void SetMin (Float_t min);  ; void SetPosition (Float_t pos);  Set progress position between [min,max]. ;  ; void SetRange (Float_t min, Float_t max);  Set min and max of progress bar. ;  ; virtual void ShowPos (Bool_t on);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Bool_t UsePercent () const;  ;  Public Member Functions inherited from TGFrame;  TGFrame (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=0, Pixel_t back=GetDefaultFrameBackground());  Create a TGFrame object. Options is an OR of the EFrameTypes. ;  ;  TGFrame (TGClient *c, Window_t id, const TGWindow *parent=nullptr);  Create a frame using an externally created window. ;  ;  ~TGFrame () override;  Destructor. ;  ; virtual void Activate (Bool_t);  ; void AddInput (UInt_t emask);  Add events specified in the emask to the events the frame should handle. ;  ; virtual void ChangeBackground (Pixel_t back);  Change frame background color. ;  ; virtual void ChangeOptions (UInt_t options);  Change frame options. Options is an OR of the EFrameTypes. ;  ; B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHProgressBar.html:3319,progress bar,progress bar,3319,doc/master/classTGHProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGHProgressBar.html,2,['progress bar'],['progress bar']
Usability,"xtra day is added to February to make the year; 366 days long. If the year is the last year of a century, eg. 1700, 1800,; 1900, 2000, then it is only a leap year if it is exactly divisible by; 400. Therefore, 1900 wasn't a leap year but 2000 was. The reason for; these rules is to bring the average length of the calendar year into; line with the length of the Earth's orbit around the Sun, so that the; seasons always occur during the same months each year. Int_t GetZoneOffset(); Static method returning local (current) time zone offset from UTC.; This is the value in seconds one must add to the local time to arrive at; Coordinated Universal Time, so it is negative east of the Prime Meridian. void Add(const TTimeStamp& offset); Add ""offset"" as a delta time. void Print(const Option_t* option = """") const; Print date and time. void Set(); Set Date/Time to current time as reported by the system.; No accounting for nanoseconds with std ANSI functions,; ns part faked so that subsequent calls simply add 1 to it; this ensures that calls within the same second come back; distinct (and sortable). Time is since Jan 1, 1970. void Set(Int_t year, Int_t month, Int_t day, Int_t hour, Int_t min, Int_t sec, Int_t nsec, Bool_t isUTC, Int_t secOffset); Set Date/Time from components. Month & day both use normal 1..12 and 1..31 counting,; hours, min, sec run from 0 to 23, 59, 59 respectively,; secOffset provides method for adjusting for alternative timezones. ""year"" | 0 1 ... 37 | 38...69 | 70 .. 100 101 .. 137; true | 2000 2001 2037 | undefined | 1970 2000 2001 .. 2037. ""year"" | 138...1969 | 1970 .. 2037 | ...; true | undefined | 1970 .. 2037 | undefined. void Set(Int_t date, Int_t time, Int_t nsec, Bool_t isUTC, Int_t secOffset); Set date/time from integers of the form [yy]YYMMDD and HHMMSS,; assume UTC (UTC) components:. MM: 01=January .. 12=December; DD: 01 .. 31. HH: 00=midnight .. 23; MM: 00 .. 59; SS: 00 .. 69. Date must be in format 980418 or 19980418; 1001127 or 20001127 (i.e. year",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTimeStamp.html:8525,simpl,simply,8525,root/html602/TTimeStamp.html,https://root.cern,https://root.cern/root/html602/TTimeStamp.html,4,['simpl'],['simply']
Usability,"xtract the correlation matrix and the; global correlation coefficients from the MINUIT memory buffer and; fill the internal arrays. Bool_t isIdentical(const RooFitResult& other, Double_t tol = 5e-5, Double_t tolCorr = 1e-4, Bool_t verbose = kTRUE) const; Return true if this fit result is identical to other within tolerance 'tol' on fitted values; and tolerance 'tolCor' on correlation coefficients. RooFitResult* lastMinuitFit(const RooArgList& varList = RooArgList()); Import the results of the last fit performed by gMinuit, interpreting; the fit parameters as the given varList of parameters. void setCovarianceMatrix(TMatrixDSym& V); Store externally provided correlation matrix in his RooFitResult ;. TH2* correlationHist(const char* name = ""correlation_matrix"") const; Return TH2D of correlation matrix. const TMatrixDSym& covarianceMatrix() const; Return covariance matrix. TMatrixDSym reducedCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix (Note that Vred _is_ a simple sub-matrix of V,; row/columns are ordered to matched the convention given in input argument 'params'. TMatrixDSym conditionalCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix, which is calculated as; ___ -1; Vred = V22 = V11 - V12 * V22 * V21. Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; is the Shur complement of V22, calculated as shown above. (Note that Vred is _not_ a simple sub-matrix of V). const TMatrixDSym& correlationMatrix() const; Return correlation matrix ;. RooAbsPdf* createHessePdf(const RooArgSet& params) const; Return a p.d.f that represents the fit result as a multi-variate probability densisty; function on the floating fit parameters, including correlations. void SetName(const char* name); Change name of RooFitResult object. void SetNameTitle(const char* name, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFitResult.html:14901,simpl,simple,14901,root/html532/RooFitResult.html,https://root.cern,https://root.cern/root/html532/RooFitResult.html,4,['simpl'],['simple']
Usability,"xx:142. Clock Sequence; The clock sequence value must be changed whenever:; The UUID generator detects that the local value of UTC has gone backward; this may be due to re-syncing of the system clock.; While a node is operational, the UUID service always saves the last UTC used to create a UUID. Each time a new UUID is created, the current UTC is compared to the saved value and if either the current value is less or the saved value was lost, then the clock sequence is incremented modulo 16,384, thus avoiding production of duplicated UUIDs.; The clock sequence must be initialized to a random number to minimize the correlation across system. This provides maximum protection against node identifiers that may move or switch from system to system rapidly. Clock Adjustment; UUIDs may be created at a rate greater than the system clock resolution. Therefore, the system must also maintain an adjustment value to be added to the lower-order bits of the time. Logically, each time the system clock ticks, the adjustment value is cleared. Every time a UUID is generated, the current adjustment value is read and incremented, and then added to the UTC time field of the UUID. Clock Overrun; The 100-nanosecond granularity of time should prove sufficient even for bursts of UUID production in the next generation of high-performance multiprocessors. If a system overruns the clock adjustment by requesting too many UUIDs within a single system clock tick, the UUID generator will stall until the system clock catches up. ; Definition at line 42 of file TUUID.h. Classes; struct  uuid_time_t;  . Public Member Functions;  TUUID ();  Create a UUID. ;  ;  TUUID (const char *uuid_str);  Initialize a TUUID with uuid (which must be in TUUID::AsString() format). ;  ; virtual ~TUUID ();  delete this TUUID ;  ; const char * AsString () const;  Return UUID as string. Copy string immediately since it will be reused. ;  ; Int_t Compare (const TUUID &u) const;  Compare two UUIDs ""lexically"" and return. ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUUID.html:4018,clear,cleared,4018,doc/master/classTUUID.html,https://root.cern,https://root.cern/doc/master/classTUUID.html,1,['clear'],['cleared']
Usability,"y (mode) only the ; applicable states are built (A,C for pdfA, B,D for pdfB); ; Advanced options; Partial splits. You can request to limit the list of states of each splitCat that; will be considered in the build. This limitation is requested in the ; each build as follows:; . splitCats = tagCat(Lep,Kao) RunBlock(Run1); . In this example the splitting of tagCat is limited to states Lep,Kao; and the splitting of runBlock is limited to Run1. The splits apply; globally to each build, i.e. every parameter split requested in this; build will be limited according to these specifications. ; ; ; NB: Partial builds have no pdf associated with the unbuilt states of the ; limited splits. Running such a pdf on a dataset that contains data with ; unbuilt states will result in this data being ignored completely.; ; Non-trivial splits. It is possible to make non-trivial parameter splits with RooSimPdfBuilder.; Trivial splits are considered simple splits in one (fundamental) category; in the dataset or a split in a RooSuperCategory 'product' of multiple; fundamental categories in the dataset. Non-trivial splits can be performed; using an intermediate 'category function' (RooMappedCategory,; RooGenericCategory,RooThresholdCategory etc), i.e. any RooAbsCategory; derived objects that calculates its output as function of one or more; input RooRealVars and/or RooCategories.; . Such 'function categories' objects must be constructed by the user prior; to building the PDF. In the RooSimPdfBuilder::buildPdf() function these; objects can be passed in an optional RooArgSet called 'auxiliary categories':; . const RooSimultaneous* buildPdf(const RooArgSet& buildConfig, const RooAbsData* dataSet, ; const RooArgSet& auxSplitCats, Bool_t verbose=kFALSE) {; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; . Objects passed in this argset can subsequently be used in the build configuration, e.g.; . RooMappedCategory tagMap(""tagMap"",""Mapped tagging category"",tagCat,""CutBased"") ;; tagMap.map(""Lep"",""CutBased"") ;; tagMap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimPdfBuilder.html:10537,simpl,simple,10537,root/html526/RooSimPdfBuilder.html,https://root.cern,https://root.cern/root/html526/RooSimPdfBuilder.html,11,['simpl'],['simple']
Usability,"y constructor. TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); Initializing constructor. TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl). virtual ~TGenCollectionProxy(); Standard destructor. TClass * GetCollectionClass() const; Return a pointer to the TClass representing the container. Int_t GetCollectionType() const; Return the type of collection see TClassEdit::ESTLType. ULong_t GetIncrement() const; Return the offset between two consecutive value_types (memory layout). UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objstart); Push new proxy environment. void PopProxy(); Pop old proxy environment. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass() const; Return a pointer to the TClass representing the content. void SetValueClass(TClass* newcl); Set pointer to the TClass representing the content. EDataType GetType() const; If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete); Block allocation of containees. void Commit(void* env); Block commit of containees. void operator()(TBuffer& refBuffer, void* pObject); TClassStreamer I/O overload. void ReadBuffer(TBuffer& b, void* obj); Routine to read the content of the buffer into 'obj'. void ReadBuffer(TBuffer& b, void* obj, const TClass* onfileClass). void SetOnFileClass(TClass* cl); { fOnFileClass = cl; }. TClass* GetOnFileClass() const; { return fOnFileClass; }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGenCollectionProxy.html:7866,simpl,simple,7866,root/html534/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html,2,['simpl'],['simple']
Usability,"y explored with SWAN.; . 06-07-2016 ; CERN Summer Students' Course ; The CERN Summer Student program is in full swing and ROOT is part of it.; . 05-01-2016 ; Wanted: A tool to 'warn' user of inefficient (for I/O) construct in data model ; A tool to 'warn' user of inefficient (for I/O) construct in data model; . 16-12-2015 ; Try the new ROOTbooks on Binder (beta) ; Try the new ROOTbooks on Binder (Beta)! Use ROOT interactively in notebooks and explore to the examples.; . 05-12-2015 ; ROOT has its Jupyter Kernel! ; ROOT has its Jupyter kernel! More information here.; . 15-09-2015 ; ROOT Users' Workshop 2015 ; The next ROOT Users' Workshop will celebrate ROOT's 20th anniversary. It will take place on 15-18 Sept 2015 in Saas-Fee, Switzerland . 03-09-2015 ; The New ROOT Website is Online! ; The new ROOT website is online!; . 02-09-2015 ; Wanted: Storage of HEP data via key/value storage solutions ; Interface the ROOT I/O to key/value stores.; . 16-08-2015 ; ROOT Tutorial for Summer Students ; Four instances of the summer student tutorial took place this year: more than 140 people attended.; . 28-03-2015 ; Commandline tools for ROOT files inspection, modification and automated plotting ; Create a unix-like set of Python command line tools to explore, modify and display the content of ROOT files.; . . Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/news.html:6095,guid,guidelines,6095,d/news.html,https://root.cern,https://root.cern/d/news.html,1,['guid'],['guidelines']
Usability,"y for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int zlight; // z position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int shadow; // determines whether shadow will be drawn (no shadow, shadow),; // for rainbowed display modes with shading according to light; int shading; // determines whether the picture will shaded, smoothed (no shading,; // shading), for rainbowed display modes only; int bezier; // determines Bezier interpolation (applies only for simple display; // modes group for grid, x_lines, y",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:74001,simpl,simple,74001,root/htmldoc/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html,2,['simpl'],['simple']
Usability,"y implement (see later). User convenient typedefs are also provided. They derive from the common generic interface multi-dimensional for function evaluation, ROOT::Math::IBaseFunctionMultiDim. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, ROOT::Math::IParametricFunctionMultiDim to define the fit model function and use the ROOT::Math::Minimizer interface to perform the minimization of the objective function. More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter.; Here we present a detailed description of the ROOT::Fit classes and how to use them. Using these classes instead of the interface provided directly in the ROOT data objects, like TH1::Fit allow are more fine control to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed.; To understand how these class work, let’s go through a simple example, such as fitting an histogram.; When fitting an histogram, instead of using TH1::Fit we will show in the following hot wo use the ROOT::Fit classes. We will show how to perform the following different type of fits with the histogram data: * a least square fit using the observed errors (Neyman chi-squared); * a least square fit using the expected errors from the function (Pearson chi-squared); * a binned likelihood fit; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it.; Let’s go through all the steps required for performing these fits using the ROOT::Fit::Fitter class. These steps are: 1. Create the input fit data object. 2. Create the input model function. 3. Configure the fit. 4. Perform the data fitting. 5. Examine the result.; 5.7.1 Creating the input fit data; We have two types of input data, binned data (class ROOT::Fit::BinData) used for least square (chi-square) fits of histograms ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:190575,simpl,simple,190575,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"y integrating over the observables in nset. ; If nset is 0, the unnormalized value is returned. All elements of nset must be lvalues.; Unnormalized values are not cached. Doing so would be complicated as _norm->getVal() could spoil the cache and interfere with returning the cached return value. Since unnormalized calls are typically done in integration calls, there is no performance hit. ; Reimplemented from RooAbsPdf.; Definition at line 79 of file RooNormalizedPdf.h. ◆ selfNormalized(). bool RooNormalizedPdf::selfNormalized ; (; ); const. inlineoverridevirtual . Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ; Always returns false, unless a PDF overrides this function. ; Reimplemented from RooAbsPdf.; Definition at line 44 of file RooNormalizedPdf.h. ◆ translate(). void RooNormalizedPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 51 of file RooNormalizedPdf.cxx. Member Data Documentation. ◆ _normIntegral. RooRealProxy RooNormalizedPdf::_normIntegral. private . Definition at line 86 of file RooNormalizedPdf.h. ◆ _normSet. RooArgSet RooNormalizedPdf::_normSet. private . Definition at line 87 of file RooNormalizedPdf.h. ◆ _pdf. RooTemplateProxy<RooAbsPdf> RooNormalizedPdf::_pdf. private . Definition at line 85 of file RooNormalizedPdf.h. roofit/roofitcore",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNormalizedPdf.html:77922,simpl,simple,77922,doc/master/classRooNormalizedPdf.html,https://root.cern,https://root.cern/doc/master/classRooNormalizedPdf.html,1,['simpl'],['simple']
Usability,y standard PDF previewer tools showed very thin white lines between the bins as well as in the color palette. This made very ugly the final output. This problem is due to bad implementation of anti-aliasing in these previewers. A way to bypass this issue was to turn off the anti-aliasing in the previewer but then the rest of the document does not look nice. This problem is now bypassed with a fix in both PDF and PostScript output.; Offer 0 as line width option. Useful to make a line invisible. TSVG. Use float numbers instead of integer to describe graphics paths to avoid rounding problems.; Implement missing math symbols.; Offer 0 as line width option. Useful to make a line invisible. TASImage. In the animated gif it is now possible to specify the delay between the last image and the fist image in case of infinite loop. (Fernando Hueso González f.gonzalez at hzdr dot de). TPadPainter. Offer 0 as line width option. Useful to make a line invisible. TPad. In TPad::ShowGuidelines the number of guide lines is limited to 15. Above that they become useless.; Print a warning if one of the pad limit is a NaN.; Fix https://sft.its.cern.ch/jira/browse/ROOT-6703. TCanvas. Make sure that “/” and “.” are not part of the method name when a canvas is saved as a .C file. TLatex. With the Cocoa backend the PDF and PS output produced miss-aligned exponents because the GetTextExtend method behaved differently in batch mode and “screen” mode. This is now fixed. See http://root.cern.ch/phpBB3/viewtopic.php?f=3&t=18883; Improve the square-root drawing in case it is small.; Better adjustment of the tilde accent position in case of Cocoa backend. TMathText. \mu is now working for Postscript output.; \splitline is now implemented. Cocoa backend. Line width and line style were not applied on boxes. 3D Graphics Libraries; GL Viewer. New option “Rotate scene” in the “Extras” tab of the GL Viewer. It allows to do a real rotation instead of a wobbling when the “Auto Rotator” is launched.; New met,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:23593,guid,guide,23593,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['guid'],['guide']
Usability,"y this profile2D by h1*-; *-* =============================. this = this*h1. void Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this profile2D by multiplication of h1 by h2; *-* ================================================================. this = (c1*h1)*(c2*h2). TH2D * ProjectionXY(const char* name = ""_pxy"", Option_t* option = ""e"") const; Project this profile2D into a 2-D histogram along X,Y*-*-; *-* =====================================================. The projection is always of the type TH2D. if option ""E"" is specified the errors of the projected histogram are computed and set; to be equal to the errors of the profile.; Option ""E"" is defined as the default one in the header file.; if option """" is specified the histogram errors are simply the sqrt of its content; if option ""B"" is specified, the content of bin of the returned histogram; will be equal to the GetBinEntries(bin) of the profile,; if option ""C=E"" the bin contents of the projection are set to the; bin errors of the profile; if option ""W"" is specified the bin content of the projected histogram is set to the; product of the bin content of the profile and the entries.; With this option the returned histogram will be equivalent to the one obtained by; filling directly a TH2D using the 3-rd value as a weight.; This option makes sense only for profile filled with all weights =1.; When the profile is weighted (filled with weights different than 1) the; bin error of the projected histogram (obtained using this option ""W"") cannot be; correctly computed from the information stored in the profile. void PutStats(Double_t* stats); Replace current statistics with the values in array stats. void Reset(Option_t* option = """"); -*-*Reset contents of a Profile2D histogram; *-* =======================================. void RebinAxis(Double_t x, TAxis* axis); Profile histogram is resized along axis such that x is in the axis range.; The new axi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile2D.html:40127,simpl,simply,40127,root/html528/TProfile2D.html,https://root.cern,https://root.cern/root/html528/TProfile2D.html,4,['simpl'],['simply']
Usability,"y useful because of two theorems:; 1- A linear combination of sigmoids can approximate any continuous function.; 2- Trained with output=1 for the signal and 0 for the background, the approximated function of inputs X is the probability of signal, knowing X.; 5.12.3 Learning Methods; The aim of all learning methods is to minimize the total error on a set of weighted examples. The error is defined as the sum in quadrate, divided by two, of the error on each individual output neuron. In all methods implemented in this library, one needs to compute the first derivative of that error with respect to the weights. Exploiting the well-known properties of the derivative, one can express this derivative as the product of the local partial derivative by the weighted sum of the outputs derivatives (for a neuron) or as the product of the input value with the local partial derivative of the output neuron (for a synapse). This computation is called “back-propagation of the errors”. Six learning methods are implemented.; 5.12.3.1 Stochastic Minimization; This is the most trivial learning method. The Robbins-Monro stochastic approximation is applied to multilayer perceptrons. The weights are updated after each example according to the formula:; \[; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); \]; with:; \[; \Delta w_{ij}(t) = - \eta \left(; \frac{\partial e_p}{\partial w_{ij}} + \delta \right) +; \epsilon \Delta w_{ij}(t-1); \]; The parameters for this method are Eta, EtaDecay, Delta and Epsilon.; 5.12.3.2 Steepest Descent With Fixed Step Size (Batch Learning); It is the same as the stochastic minimization, but the weights are updated after considering all the examples, with the total derivative dEdw. The parameters for this method are Eta, EtaDecay, Delta and Epsilon.; 5.12.3.3 Steepest Descent Algorithm; Weights are set to the minimum along the line defined by the gradient. The only parameter for this method is Tau. Lower Tau = higher precision = slower search. A value Tau=3 seems ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:232557,learn,learning,232557,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['learn'],['learning']
Usability,"y widget. ;  ; Bool_t HandleKey (Event_t *event) override;  The key press event handler converts a key press to some line editor action. ;  ; Bool_t HandleMotion (Event_t *event) override;  Handle mouse motion event in the text entry widget. ;  ; Bool_t HandleSelection (Event_t *event) override;  Handle text selection event. ;  ; Bool_t HandleSelectionClear (Event_t *event) override;  Handle selection clear event. ;  ; Bool_t HandleSelectionRequest (Event_t *event) override;  Handle request to send current clipboard contents to requestor window. ;  ; Bool_t HandleTimer (TTimer *t) override;  Handle cursor blink timer. ;  ; Bool_t HasMarkedText () const;  ; Bool_t HasOwnFont () const;  ; void Home (Bool_t mark=kFALSE);  Moves the text cursor to the left end of the line. ;  ; virtual void Insert (const char *);  Removes any currently selected text, inserts newText, sets it as the new contents of the text entry. ;  ; virtual void InsertText (const char *text, Int_t pos);  Inserts text at position pos, clears the selection and moves the cursor to the end of the line. ;  ; TClass * IsA () const override;  ; Bool_t IsEdited () const;  ; Bool_t IsFrameDrawn () const;  ; void Layout () override;  ; void MarkWord (Int_t pos);  Marks the word nearest to cursor position. ;  ; Int_t MaxMark () const;  ; Int_t MinMark () const;  ; void NewMark (Int_t pos);  New character mark at position pos. ;  ; void Remove ();  Deletes all characters on the right side of the cursor. ;  ; virtual void RemoveText (Int_t start, Int_t end);  Removes text at the range, clears the selection and moves the cursor to the end of the line. ;  ; virtual void ReturnPressed ();  This signal is emitted when the return or enter key is pressed. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a text entry widget as a C++ statement(s) on output stream out. ;  ; virtual void SelectAll ();  Selects all text (i.e. ;  ; virtual void SetAlignment (ETextJustification mode=kTextLeft);  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEntry.html:10062,clear,clears,10062,doc/master/classTGTextEntry.html,https://root.cern,https://root.cern/doc/master/classTGTextEntry.html,1,['clear'],['clears']
Usability,"y widget. ;  ; Bool_t HandleKey (Event_t *event) override;  The key press event handler converts a key press to some line editor action. ;  ; Bool_t HandleMotion (Event_t *event) override;  Handle mouse motion event in the text entry widget. ;  ; Bool_t HandleSelection (Event_t *event) override;  Handle text selection event. ;  ; Bool_t HandleSelectionClear (Event_t *event) override;  Handle selection clear event. ;  ; Bool_t HandleSelectionRequest (Event_t *event) override;  Handle request to send current clipboard contents to requestor window. ;  ; Bool_t HandleTimer (TTimer *t) override;  Handle cursor blink timer. ;  ; Bool_t HasMarkedText () const;  ; Bool_t HasOwnFont () const;  ; void Home (Bool_t mark=kFALSE);  Moves the text cursor to the left end of the line. ;  ; virtual void Insert (const char *);  Removes any currently selected text, inserts newText, sets it as the new contents of the text entry. ;  ; virtual void InsertText (const char *text, Int_t pos);  Inserts text at position pos, clears the selection and moves the cursor to the end of the line. ;  ; TClass * IsA () const override;  ; Bool_t IsEdited () const;  ; Bool_t IsFrameDrawn () const;  ; void Layout () override;  ; void MarkWord (Int_t pos);  Marks the word nearest to cursor position. ;  ; Int_t MaxMark () const;  ; Int_t MinMark () const;  ; void NewMark (Int_t pos);  New character mark at position pos. ;  ; void Remove ();  Deletes all characters on the right side of the cursor. ;  ; virtual void RemoveText (Int_t start, Int_t end);  Removes text at the range, clears the selection and moves the cursor to the end of the line. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a text entry widget as a C++ statement(s) on output stream out. ;  ; virtual void SelectAll ();  Selects all text (i.e. ;  ; virtual void SetAlignment (ETextJustification mode=kTextLeft);  Sets the alignment of the text entry. ;  ; virtual void SetCursorPosition (Int_t pos);  Set the curso",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGNumberEntryField.html:8259,clear,clears,8259,doc/master/classTGNumberEntryField.html,https://root.cern,https://root.cern/doc/master/classTGNumberEntryField.html,1,['clear'],['clears']
Usability,"y(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. TFitResultPtr Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "".; Note also that the histogram is managed by the TFractionFitter class, so the returned pointer will be invalid if; the class is deleted. void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Double_t& f, const Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double& t_i, int& k_0, double& A_ki) const; Function used internally to obtain the template prediction in the individual bins; 'bin' <=> 'i' (paper); 'par' <=> 'j' (paper). Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFractionFitter.html:18162,simpl,simply,18162,root/html602/TFractionFitter.html,https://root.cern,https://root.cern/root/html602/TFractionFitter.html,4,['simpl'],['simply']
Usability,"y). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree mechanism. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass *cl, Int_t s); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. NB: This function should not be called in the TClonesArray is already; initialized with a class. void SetClass(const char *classname, Int_t s); see TClonesArray::SetClass(const TClass*). void SetOwner(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClonesArray.html:15955,simpl,simplified,15955,root/html526/TClonesArray.html,https://root.cern,https://root.cern/root/html526/TClonesArray.html,1,['simpl'],['simplified']
Usability,"y). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree mechanism. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass* cl, Int_t size = 1000); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the array. If more than s objects are entered,; the array will be automatically expanded. NB: This function should not be called in the TClonesArray is already; initialized with a class. void SetClass(const char* classname, Int_t size = 1000); see TClonesArray::SetClass(const TCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:18723,simpl,simplified,18723,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,2,['simpl'],['simplified']
Usability,"y); Int_t; Int_t; Int_t px,py. User to absolute pixel; XtoAbsPixel(ux); YtoAbsPixel(uy); XYtoAbsPixel(ux,uy,&apx,&apy); Int_t; Int_t; Int_t apx,apy. Absolute pixel to user; AbsPixeltoX(apx); AbsPixeltoY(apy); AbsPixeltoXY(apx,apy,&ux,&uy); Double_t; Double_t; Double_t ux,uy. Note: all the pixel conversion functions along the Y axis consider that py=0 is at the top of the pad except PixeltoY() which assume that the position py=0 is at the bottom of the pad. To make PixeltoY() converting the same way as the other conversion functions, it should be used the following way (p is a pointer to a TPad):; p->PixeltoY(py - p->GetWh());; 9.3.4 Dividing a Pad into Sub-pads; Dividing a pad into sub pads in order for instance to draw a few histograms, may be done in two ways. The first is to build pad objects and to draw them into a parent pad, which may be a canvas. The second is to automatically divide a pad into horizontal and vertical sub pads.; 9.3.4.1 Creating a Single Sub-pad; The simplest way to divide a pad is to build sub-pads in it. However, this forces the user to explicitly indicate the size and position of those sub-pads. Suppose we want to build a sub-pad in the active pad (pointed by gPad). First, we build it, using a TPad constructor:; root[] spad1 = new TPad(""spad1"",""The first subpad"",.1,.1,.5,.5); One gives the coordinates of the lower left point (0.1, 0.1) and of the upper right one (0.5, 0.5). These coordinates are in NDC. This means that they are independent of the user coordinates system, in particular if you have already drawn for example a histogram in the mother pad. The only thing left is to draw the pad:; root[] spad1->Draw(); If you want more sub-pads, you have to repeat this procedure as many times as necessary.; 9.3.4.2 Dividing a Canvas into Sub-Pads; The manual way of dividing a pad into sub-pads is sometimes very tedious. There is a way to automatically generate horizontal and vertical sub-pads inside a given pad.; root[] pad1->Divide(3,2). Dividi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:311918,simpl,simplest,311918,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simplest']
Usability,"y); virtual Bool_tTGLPlotPainter::PlotSelected(Int_t px, Int_t py); virtual voidProcessEvent(Int_t event, Int_t px, Int_t py); const TGLPlotBox&TGLPlotPainter::RefBackBox() const; voidTGLPlotPainter::SetDrawAxes(Bool_t s); voidTGLPlotPainter::SetDrawBackBox(Bool_t b); voidTGLPlotPainter::SetDrawFrontBox(Bool_t b); virtual voidTGLPlotPainter::SetFrameColor(const TColor* frameColor); voidTGLPlotPainter::SetPadColor(const TColor* color); voidTGLPlotPainter::SetPhysicalShapeColor(const Float_t* rgba); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStartPan(Int_t px, Int_t py); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TGLVoxelPainter(TH1* hist, TGLPlotCamera* camera, TGLPlotCoordinates* coord). protected:. virtual voidTGLPlotPainter::ClearBuffers() const; voidTGLPlotPainter::DrawSections() const; const TColor*TGLPlotPainter::GetPadColor() const; voidTGLPlotPainter::MoveSection(Int_t px, Int_t py); voidTGLPlotPainter::PrintPlot() const; voidTGLPlotPainter::RestoreModelviewMatrix() const; voidTGLPlotPainter::RestoreProjectionMatrix() const; voidTGLPlotPainter::SaveModelviewMatrix() const; voidTGLPlotPainter::SaveProjectionMatrix() const. private:. virtual voidDeInitGL() const; voidDrawPalette() const; virtual voidDrawPaletteAxis() const; virtual voidDrawPlot() const; virtual voidDrawSectionXOY() const; virtual voidDrawSectionXOZ() const; virtual voidDrawSectionYOZ() const; voidFindVoxelColor(Double_t binContent, Float_t* rgba) const; Bool_tHasSections() const; virtual voidInitGL() const; TGLVoxelPainter&operator=(const TGLVoxelPainter&); voidPreparePalette() const; voidSetVoxelColor(const Float_t* rgba) const; TGLVoxelPainter(const TGLVoxelPainter&). Data Members; public:. static TGLPlotPainter::ECutAxisIDTGLPlotPainter::kXAxis; static TGLPlotPainter::ECutAxisIDTGLPlotPainter::kYAxis; static TGLPlotPainter::ECutAxisIDTGLPlotPainter::kZAxis. protected:. TGLPlotBoxTGLPlotPainter::fBackBox; TGLBoxCutTGLPlo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLVoxelPainter.html:1661,Clear,ClearBuffers,1661,root/html602/TGLVoxelPainter.html,https://root.cern,https://root.cern/root/html602/TGLVoxelPainter.html,2,['Clear'],['ClearBuffers']
Usability,"y* Generate() const; Virtual copy constructor. TGenCollectionProxy * Initialize(Bool_t silent) const; Proxy initializer. void CheckFunctions() const; Check existence of function pointers. TGenCollectionProxy * InitializeEx(Bool_t silent); Proxy initializer. TClass * GetCollectionClass() const; Return a pointer to the TClass representing the container. Int_t GetCollectionType() const; Return the type of collection see TClassEdit::ESTLType. ULong_t GetIncrement() const; Return the offset between two consecutive value_types (memory layout). UInt_t Sizeof() const; Return the sizeof the collection object. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass() const; Return a pointer to the TClass representing the content. void UpdateValueClass(const TClass* oldcl, TClass* newcl); Update the internal ValueClass when a TClass constructor need to; replace an emulated TClass by the real TClass. EDataType GetType() const; If the content is a simple numerical value, return its type (see TDataType). void* At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the emulated collection. UInt_t Size() const; Return the current size of the container. void Resize(UInt_t n, Bool_t force_delete); Resize the container. void* Allocate(UInt_t n, Bool_t forceDelete); Allocate the needed space.; For associative collection, this returns a TStaging object that; need to be deleted manually __or__ returned by calling Commit(TStaging*). void Insert(const void* data, void* container, size_t size); Insert data into the container where data is a C-style array of the actual type contained in the collection; of the given size. For associative container (map, etc.), the data type is the pair<key,value>. void Commit(void* env); Commit the change. void PushProxy(void* objstart); Add an object. void PopProxy(); Remove the last object. void DeleteItem(Bool_t force, void* ptr) const; Call to delete/destruct i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGenCollectionProxy.html:8146,simpl,simple,8146,root/html602/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TGenCollectionProxy.html,4,['simpl'],['simple']
Usability,"y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); voidValueSet(Double_t)SIGNAL ; Bool_tTGWidget::WantFocus() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; Int_tTGWidget::WidgetId() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Int_tCalcSliderPos(Float_t v); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTGWidget::ClearFlags(Int_t flags); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); static Time_tTGFrame::GetLastClick(); TStringTGFrame::GetOptionString() const; const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(); Int_tTGWidget::SetFlags(Int_t flags); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TEveGValuator(const TEveGValuator&); TEveGValuator&operator=(const TEveGValuator&). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReference",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveGValuator.html:16074,Clear,ClearFlags,16074,root/html532/TEveGValuator.html,https://root.cern,https://root.cern/root/html532/TEveGValuator.html,2,['Clear'],['ClearFlags']
Usability,"y, if action == 1 clean related; output file settings.; If the final target file is local then 'target' is set to the final local path; when action == 0 and used to retrieve the file with TFile::Cp when action == 1. Output file settings are in the form. <previous_option>of=name <next_option>; <previous_option>outfile=name,...;<next_option>. The separator from the next option is either a ' ' or a ';'; Called interanally by TProof::Process. Returns 0 on success, -1 on error. void SetFeedback(TString& opt, TString& optfb, Int_t action); Extract from opt in optfb information about wanted feedback settings.; Feedback are removed from the input string opt.; If action == 0, set up feedback accordingly, if action == 1 clean related; feedback settings (using info in optfb, if available, or reparsing opt). Feedback requirements are in the form. <previous_option>fb=name1,name2,name3,... <next_option>; <previous_option>feedback=name1,name2,name3,...;<next_option>. The special name 'stats' triggers feedback about events and packets.; The separator from the next option is either a ' ' or a ';'.; Called interanally by TProof::Process. Long64_t Process(TDSet* dset, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process a data set (TDSet) using the specified selector (.C) file or; Tselector object; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Long64_t Process(TFileCollection* fc, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process a data set (TFileCollection) using the specified selector (.C) file; or TSelector object.; The default tree is analyzed (i.e. the first one found). To specify another; tree, the default tree can be changed using TFileCollection::SetDefaultMetaData .; The return value is -1 in case of error and TSelector::GetStatus() in; in case ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:51381,feedback,feedback,51381,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,6,['feedback'],['feedback']
Usability,"y,z;} POINT;; typedef struct {; Int_t ntrack,nseg,nvertex;; UInt_t flag;; Float_t temperature;; } EVENTN;; POINT point;; EVENTN eventn;; ; // Create a ROOT Tree; TTree tree(""T"",""An example of ROOT tree with a few branches"");; tree.Branch(""point"",&point,""x:y:z"");; tree.Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree.Branch(""hpx"",""TH1F"",&hpx,128000,0);; ; Float_t px,py,pz;; ; // Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; const auto random = gRandom->::Rndm(1);; ; // Fill histograms; hpx.Fill(px);; hpxpy.Fill(px,py,1);; hprof.Fill(px,pz,1);; ; // Fill structures; point.x = 10*(random-1);; point.y = 5*random;; point.z = 20*random;; eventn.ntrack = Int_t(100*random);; eventn.nseg = Int_t(2*eventn.ntrack);; eventn.nvertex = 1;; eventn.flag = Int_t(random+0.5);; eventn.temperature = 20+random;; ; // Fill the tree. For each event, save the 2 structures and 3 objects; // In this simple example, the objects hpx, hprof and hpxpy are slightly; // different from event to event. We expect a big compression factor!; tree->Fill();; }; // End of the loop; ; tree.Print();; ; // Save all objects in this file; hfile.Write();; ; // Close the file. Note that this is automatically done when you leave; // the application upon file destruction.; hfile.Close();; ; return 0;; }; mainint main()Definition Prototype.cxx:12; Int_tint Int_tDefinition RtypesCore.h:45; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; TFile.h; TH1.h; TH2.h; TProfile.h; TRandom.h; TTree.h; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:621; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TProfileProfile Histogram.Definition TProfile.h:32; TRandom::Rannorvirtual void Rannor(Float_t &a, Float_t &b)Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.Definition TRandom.cxx:507; yDouble_t y[n]Definition legend1.C:17; xDoubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:13658,simpl,simple,13658,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['simpl'],['simple']
Usability,"y,z;} POINT;; typedef struct {; Int_t ntrack,nseg,nvertex;; UInt_t flag;; Float_t temperature;; } EVENTN;; POINT point;; EVENTN eventn;; ; // Create a ROOT Tree; TTree tree(""T"",""An example of ROOT tree with a few branches"");; tree.Branch(""point"",&point,""x:y:z"");; tree.Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree.Branch(""hpx"",""TH1F"",&hpx,128000,0);; ; Float_t px,py,pz;; ; // Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; const auto random = gRandom->::Rndm(1);; ; // Fill histograms; hpx.Fill(px);; hpxpy.Fill(px,py,1);; hprof.Fill(px,pz,1);; ; // Fill structures; point.x = 10*(random-1);; point.y = 5*random;; point.z = 20*random;; eventn.ntrack = Int_t(100*random);; eventn.nseg = Int_t(2*eventn.ntrack);; eventn.nvertex = 1;; eventn.flag = Int_t(random+0.5);; eventn.temperature = 20+random;; ; // Fill the tree. For each event, save the 2 structures and 3 objects; // In this simple example, the objects hpx, hprof and hpxpy are slightly; // different from event to event. We expect a big compression factor!; tree->Fill();; }; // End of the loop; ; tree.Print();; ; // Save all objects in this file; hfile.Write();; ; // Close the file. Note that this is automatically done when you leave; // the application upon file destruction.; hfile.Close();; ; return 0;; }; mainint main()Definition Prototype.cxx:12; Int_tint Int_tDefinition RtypesCore.h:45; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; TFile.h; TH1.h; TH2.h; TProfile.h; TRandom.h; TTree.h; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TProfileProfile Histogram.Definition TProfile.h:32; TRandom::Rannorvirtual void Rannor(Float_t &a, Float_t &b)Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.Definition TRandom.cxx:507; yDouble_t y[n]Definition legend1.C:17; xDoubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:13659,simpl,simple,13659,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['simpl'],['simple']
Usability,"y. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorderRecording. class TRecorderRecording: public TRecorderState. Represents state of TRecorder when recording events. Function Members (Methods); public:. static TClass*Class(); voidFilterEventPave(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidTRecorderState::ListCmd(const char*); virtual voidTRecorderState::ListGui(const char*); TRecorderRecording&operator=(const TRecorderRecording&); virtual voidTRecorderState::Pause(TRecorder*); virtual voidTRecorderState::PrevCanvases(const char*, Option_t*); voidRecordCmdEvent(const char* line); voidRecordExtraEvent(TString line, TTime extTime); voidRecordGuiBldEvent(Event_t* e); voidRecordGuiCNEvent(Event_t* e); voidRecordGuiEvent(Event_t* e, Window_t wid); voidRecordMousePosition(); voidRecordPave(const TObject* obj); voidRecordText(const TObject* obj); voidRegisterWindow(Window_t w); virtual Bool_tTRecorderState::Replay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidTRecorderState::ReplayStop(TRecorder*); virtual voidTRecorderState::Resume(TRecorder*); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTRecorderState::Start(TRecorder*, const char*, Option_t*, Window_t*, Int_t); voidStartEditing(); virtual voidStop(TRecorder* r, Bool_t guiCommand); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TRecorderRecording(const TRecorderRecording&). protected:. voidTRecorderState::ChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState); Bool_tStartRecording(); TRecorderRecording(TRecorder* r, const char* filename, Option_t* option, Window_t* w, Int_t winCount). private:. virtual~TRecorderRecording(); voidCopyEvent(Event_t* e, Window_t wid); Bool_tIsFiltered(Window_t id); voidSetTypeOfC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecorderRecording.html:749,Pause,Pause,749,root/html602/TRecorderRecording.html,https://root.cern,https://root.cern/root/html602/TRecorderRecording.html,4,"['Pause', 'Resume']","['Pause', 'Resume']"
Usability,"y; TGLVContainer*fLVContainerand its container; TGListView*fListViewdataset files list view; TGTextEntry*fLocationURLlocation URL text entry; TGCheckButton*fOverwriteDSetoverwrite DataSet; TGCheckButton*fOverwriteFilesoverwrite All Files; TGTextButton*fRemoveButtonRemove button; TList*fSkippedFilesList of skipped files; TGTextButton*fUploadButtonUpload button; Bool_tfUploading; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h); Create a Upload DataSet dialog box. Used to create and upload a dataset. ~TUploadDataSetDlg(); Delete chain dialog. void CloseWindow(); Close upload dataset dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for upload dataset dialog. void AddFiles(const char* fileName); Add File name(s) from the file location URL to the list view. void AddFiles(TList* fileList); Add File name(s) from the file location URL to the list view. void BrowseFiles(); Opens the TGFileDialog to allow user to select local file(s) to be added; in the list view of dataset files. void ClearFiles(); Clear content of the list view. void OnOverwriteDataset(Bool_t on); Notification of Overwrite Dataset check button. void OnOverwriteFiles(Bool_t on); Notification of Overwrite Files check button. void OnAppendFiles(Bool_t on); Notification of Append Files check button. void RemoveFile(); Remove the selected entry from the list view. void UploadDataSet(); Upload the dataset to the server. TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TUploadDataSetDlg.html:24856,Clear,ClearFiles,24856,root/html604/TUploadDataSetDlg.html,https://root.cern,https://root.cern/root/html604/TUploadDataSetDlg.html,2,['Clear'],"['Clear', 'ClearFiles']"
Usability,"y;   Plot a PDF in disjunct ranges, and get normalisation right. ;  ; file  rf301_composition.C;   Multidimensional models: multi-dimensional pdfs through composition e.g. ;  ; file  rf301_composition.py;   Multidimensional models: multi-dimensional pdfs through composition, e.g. ;  ; file  rf302_utilfuncs.C;   Multidimensional models: utility functions classes available for use in tailoring of composite (multidimensional) pdfs ;  ; file  rf302_utilfuncs.py;   Multidimensional models: utility functions classes available for use in tailoring of composite (multidimensional) pdfs ;  ; file  rf303_conditional.C;   Multidimensional models: use of tailored pdf as conditional pdfs.s ;  ; file  rf303_conditional.py;   'MULTIDIMENSIONAL MODELS' RooFit tutorial macro #303 Use of tailored p.d.f as conditional p.d.fs.s ;  ; file  rf304_uncorrprod.C;   Multidimensional models: simple uncorrelated multi-dimensional pdfs ;  ; file  rf304_uncorrprod.py;   Multidimensional models: simple uncorrelated multi-dimensional pdfs ;  ; file  rf305_condcorrprod.C;   Multidimensional models: multi-dimensional pdfs with conditional pdfs in product ;  ; file  rf305_condcorrprod.py;   Multidimensional models: multi-dimensional pdfs with conditional pdfs in product ;  ; file  rf306_condpereventerrors.C;   Multidimensional models: conditional pdf with per-event errors ;  ; file  rf306_condpereventerrors.py;   Multidimensional models: complete example with use of conditional pdf with per-event errors ;  ; file  rf307_fullpereventerrors.C;   Multidimensional models: full pdf with per-event errors ;  ; file  rf307_fullpereventerrors.py;   Multidimensional models: usage of full pdf with per-event errors ;  ; file  rf308_normintegration2d.C;   Multidimensional models: normalization and integration of pdfs, construction of cumulative distribution functions from pdfs in two dimensions ;  ; file  rf308_normintegration2d.py;   Multidimensional models: normalization and integration of pdfs, construction of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__roofit.html:7071,simpl,simple,7071,doc/master/group__tutorial__roofit.html,https://root.cern,https://root.cern/doc/master/group__tutorial__roofit.html,1,['simpl'],['simple']
Usability,"yCovarianceMatrix(). void RooMinimizer::applyCovarianceMatrix ; (; TMatrixDSym const & ; V). Apply results of given external covariance matrix. ; i.e. propagate its errors to all RRV parameter representations and give this matrix instead of the HESSE matrix at the next save() call ; Definition at line 732 of file RooMinimizer.cxx. ◆ calculateHessErrors(). bool RooMinimizer::calculateHessErrors ; (; ). private . Definition at line 880 of file RooMinimizer.cxx. ◆ calculateMinosErrors(). bool RooMinimizer::calculateMinosErrors ; (; ). private . Definition at line 911 of file RooMinimizer.cxx. ◆ Class(). static TClass * RooMinimizer::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooMinimizer::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooMinimizer::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 247 of file RooMinimizer.h. ◆ clearStatusHistory(). void RooMinimizer::clearStatusHistory ; (; ). inline . Clears the Minuit status history. ; Definition at line 182 of file RooMinimizer.h. ◆ contour(). RooPlot * RooMinimizer::contour ; (; RooRealVar & ; var1, . RooRealVar & ; var2, . double ; n1 = 1.0, . double ; n2 = 2.0, . double ; n3 = 0.0, . double ; n4 = 0.0, . double ; n5 = 0.0, . double ; n6 = 0.0, . unsigned int ; npoints = 50 . ). Create and draw a TH2 with the error contours in the parameters var1 and var2. ; Parameters. [in]var1The first parameter (x axis). ; [in]var2The second parameter (y axis). ; [in]n1First contour. ; [in]n2Optional contour. 0 means don't draw. ; [in]n3Optional contour. 0 means don't draw. ; [in]n4Optional contour. 0 means don't draw. ; [in]n5Optional contour. 0 means don't draw. ; [in]n6Optional contour. 0 means don't draw. ; [in]npointsNumber of points for evaluating the contour. Up to six contours can be drawn using the arguments n1 to n6 to request the desired coverage in units of \( \si",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMinimizer.html:18562,clear,clearStatusHistory,18562,doc/master/classRooMinimizer.html,https://root.cern,https://root.cern/doc/master/classRooMinimizer.html,1,['clear'],['clearStatusHistory']
Usability,"yD::AddAt(Double_t c, Int_t i); virtual voidAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayD::Adopt(Int_t n, Double_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tTArrayD::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH1::BufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1D.html:2011,Clear,Clear,2011,root/html534/TH1D.html,https://root.cern,https://root.cern/root/html534/TH1D.html,1,['Clear'],['Clear']
Usability,"yD::AddAt(Double_t c, Int_t i); virtual voidAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayD::Adopt(Int_t n, Double_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tTArrayD::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH2::BufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH2D.html:2358,Clear,Clear,2358,root/html534/TH2D.html,https://root.cern,https://root.cern/root/html534/TH2D.html,1,['Clear'],['Clear']
Usability,"yD::AddAt(Double_t c, Int_t i); virtual voidAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidTH1::AddDirectory(Bool_t add = kTRUE); static Bool_tTH1::AddDirectoryStatus(); voidTArrayD::Adopt(Int_t n, Double_t* array); virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Option_t* option = """") const; virtual Double_tTH1::AndersonDarlingTest(const TH1* h2, Double_t& advalue) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tTArrayD::At(Int_t i) const; virtual voidTH1::Browse(TBrowser* b); virtual Int_tTH3::BufferEmpty(Int_t action = 0); virtual Double_tTH1::Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tTH1::Chisquare(TF1* f1, Option_t* option = """") const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(Bool_t onlyPositive = false); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH3D.html:2199,Clear,Clear,2199,root/html534/TH3D.html,https://root.cern,https://root.cern/root/html534/TH3D.html,1,['Clear'],['Clear']
Usability,yInstance(); Bool_tDrawProgressBar() const; TMVA::Config::IONames&GetIONames(); TMVA::Config::VariablePlotting&GetVariablePlotting(); static TMVA::Config&Instance(); virtual TClass*IsA() const; Bool_tIsSilent() const; TMVA::Config&operator=(const TMVA::Config&); voidSetDrawProgressBar(Bool_t d); voidSetSilent(Bool_t s); voidSetUseColor(Bool_t uc); voidSetWriteOptionsReference(Bool_t w); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Bool_tUseColor() const; Bool_tWriteOptionsReference() const. private:. (unknown)(); TMVA::ConfigConfig(); TMVA::MsgLogger&Log() const. Data Members; public:. TMVA::Config::IONamesfIONamesCustomisable weight file properties; TMVA::Config::VariablePlottingfVariablePlottingCustomisable plotting properties. private:. Bool_tfDrawProgressBardraw progress bar to indicate training evolution; TMVA::MsgLogger*fLoggermessage logger; Bool_tfSilentno output at all; Bool_tfUseColoredConsolecoloured standard output; Bool_tfWriteOptionsReferenceif set true: Configurable objects write file with option reference; static TMVA::Config*fgConfigPtr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Config(); constructor - set defaults. void DestroyInstance(); static function: destroy TMVA instance. TMVA::Config& Instance(); static function: returns TMVA instance. Bool_t UseColor() const; { return fUseColoredConsole; }. void SetUseColor(Bool_t uc); { fUseColoredConsole = uc; }. Bool_t IsSilent() const; { return fSilent; }. void SetSilent(Bool_t s); { fSilent = s; }. Bool_t WriteOptionsReference() const; { return fWriteOptionsReference; }. void SetWriteOptionsReference(Bool_t w); { fWriteOptionsReference = w; }. Bool_t DrawProgressBar() const; { return fDrawProgressBar; }. void SetDrawProgressBar(Bool_t d); { fDrawProgressBar = d; }. VariablePlotting& GetVariablePlotting(); { return fVariablePlotting; }. IONames& GetIONames(); { retur,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__Config.html:1259,progress bar,progress bar,1259,root/html534/TMVA__Config.html,https://root.cern,https://root.cern/root/html534/TMVA__Config.html,2,['progress bar'],['progress bar']
Usability,"yROOT.so needs to be loaded first with gSystem->Load() before use. Refer back to the other example of the use of TPython that was given in “Access to Python from ROOT”.; To show in detail how Python access can be used, an example Python module is needed, as follows:; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; This module can now be loaded into a Cling session, the class used to instantiate objects, and their member functions called for showing how different types can cross:; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; Note that the LoadMacro() call makes the class automatically available, such that it can be used directly. Otherwise, a gROOT->GetClass() call is required first.; 19.1.5.5 Callbacks; The simplest way of setting a callback to Python from Cling, e.g. for a button, is by providing the execution string. See for example tutorials/pyroot/demo.py that comes with the ROOT installation:; # [..]; bar = ROOT.TControlBar('vertical','Demos'); bar.AddButton('Help on Demos',r'TPython::Exec(""execfile('demoshelp.py')"");','Click Here For Help on Running the Demos'); bar.AddButton('browser',r'TPython::Exec(""b = Tbrowser()"");','Start the ROOT browser'); # [..]; Here, the callback is a string that will be interpreted by Cling to call TPython::Exec(), which will, in turn, interpret and execute the string given to it. Note the use of raw strings (the ‘r’ in front of the second argument string), in order to remove the need of escaping the backslashes.; 19.1.5.6 Cling Commands; In interactive mode, the Python exception hook is used to mimic some of the Cling commands available. These are: .q, .!, .x, .L, .cd, .ls, .pwd, .? and .help. Note that .x translates to Python ‘execfile()’ and thus accepts only Python files",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1058989,simpl,simplest,1058989,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simplest']
Usability,"ySelect (Int_t x, Int_t y);  Secondary selection. ;  ; Bool_t DoSelect (Int_t x, Int_t y);  Perform GL selection, picking objects overlapping WINDOW area described by 'rect'. ;  ; virtual void DoubleClicked ();  ; void DrawDebugInfo ();  If in debug mode draw camera aids and overall bounding box. ;  ; void DrawGuides ();  Draw reference marker and coordinate axes. ;  ; void EndScene () override;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Process event of type 'event' - one of EEventType types, occurring at window location px, py This is provided for use when embedding GL viewer into pad. ;  ; TGLAutoRotator * GetAutoRotator ();  Get the auto-rotator for this viewer. ;  ; TGLCameraOverlay * GetCameraOverlay () const;  ; Bool_t GetClipAutoUpdate () const;  ; TGLClipSet * GetClipSet () const;  ; TGLOverlayElement * GetCurrentOvlElm () const;  ; Int_t GetDev () const;  ; EDragAction GetDragAction () const;  ; Bool_t GetDrawCameraCenter ();  ; TGEventHandler * GetEventHandler () const;  ; Float_t GetFader () const;  ; TGedEditor * GetGedEditor () const;  ; TGLWidget * GetGLWidget ();  ; void GetGuideState (Int_t &axesType, Bool_t &axesDepthTest, Bool_t &referenceOn, Double_t *referencePos) const;  Fetch the state of guides (axes & reference markers) into arguments. ;  ; Bool_t GetIgnoreSizesOnUpdate () const;  ; TGLLightSet * GetLightSet () const;  ; Float_t GetLineScale () const;  ; Float_t GetMaxSceneDrawTimeHQ () const;  ; Float_t GetMaxSceneDrawTimeLQ () const;  ; TGLOvlSelectRecord & GetOvlSelRec ();  ; const char * GetPictureFileName () const;  ; TImage * GetPictureUsingBB ();  Returns current image. ;  ; TImage * GetPictureUsingFBO (Int_t w, Int_t h, Float_t pixel_object_scale=0);  Returns current image. ;  ; Float_t GetPointScale () const;  ; EPushAction GetPushAction () const;  ; Bool_t GetResetCamerasOnUpdate () const;  ; const TGLPhysicalShape * GetSelected () const;  Return selected physical shape. ;  ; TGLSelectRecord & GetSelRec ();  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLEmbeddedViewer.html:4559,guid,guides,4559,doc/master/classTGLEmbeddedViewer.html,https://root.cern,https://root.cern/doc/master/classTGLEmbeddedViewer.html,3,['guid'],['guides']
Usability,"ybridCalculator: public RooStats::HypoTestCalculator, public TNamed. HybridCalculator class: this class is a fresh rewrite in RooStats of; 	RooStatsCms/LimitCalculator developped by D. Piparo and G. Schott; Authors: D. Piparo, G. Schott - Universitaet Karlsruhe. The class is born from the need to have an implementation of the CLs; method that could take advantage from the RooFit Package.; The basic idea is the following:; - Instantiate an object specifying a signal+background model, a background model and a dataset.; - Perform toy MC experiments to know the distributions of -2lnQ; - Calculate the CLsb and CLs values as ""integrals"" of these distributions. The class allows the user to input models as RooAbsPdf ( TH1 object could be used; by using the RooHistPdf class); The pdfs must be ""extended"": for more information please refer to; http://roofit.sourceforge.net). The dataset can be entered as a; RooAbsData objects. Unlike the TLimit Class a complete MC generation is performed at each step; and not a simple Poisson fluctuation of the contents of the bins.; Another innovation is the treatment of the nuisance parameters. The user; can input in the constructor nuisance parameters.; To include the information that we have about the nuisance parameters a prior; PDF (RooAbsPdf) should be specified. Different test statistic can be used (likelihood ratio, number of events or; profile likelihood ratio. The default is the likelihood ratio.; See the method SetTestStatistic. The number of toys to be generated is controlled by SetNumberOfToys(n). The result of the calculations is returned as a HybridResult object pointer. see also the following interesting references:; - Alex Read, ""Presentation of search results: the CLs technique"",; Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; see http://www.iop.org/EJ/abstract/0954-3899/28/10/313/. - Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)"" CERN 2000-005 (30 May 2000). - V. Bartsch, G.Quas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__HybridCalculator.html:1328,simpl,simple,1328,root/html526/RooStats__HybridCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__HybridCalculator.html,1,['simpl'],['simple']
Usability,"ycle one and add it to the prefetchBlocks list. ; Definition at line 214 of file TFilePrefetch.cxx. ◆ ReadBuffer(). Bool_t TFilePrefetch::ReadBuffer ; (; char * ; buf, . Long64_t ; offset, . Int_t ; len . ). Return a prefetched element. ; Definition at line 178 of file TFilePrefetch.cxx. ◆ ReadListOfBlocks(). void TFilePrefetch::ReadListOfBlocks ; (; ). Get blocks specified in prefetchBlocks. ; Definition at line 128 of file TFilePrefetch.cxx. ◆ SaveBlockInCache(). void TFilePrefetch::SaveBlockInCache ; (; TFPBlock * ; block). Save the block content in cache. ; Definition at line 474 of file TFilePrefetch.cxx. ◆ SetCache(). Bool_t TFilePrefetch::SetCache ; (; const char * ; path). Set the path of the cache directory. ; Definition at line 526 of file TFilePrefetch.cxx. ◆ SetFile(). void TFilePrefetch::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). Change the file. ; When prefetching is enabled we also need to:; make sure the async thread is not doing any work; clear all blocks from prefetching and read list; reset the file pointer . Definition at line 317 of file TFilePrefetch.cxx. ◆ Streamer(). void TFilePrefetch::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TFilePrefetch::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 84 of file TFilePrefetch.h. ◆ SumHex(). Int_t TFilePrefetch::SumHex ; (; const char * ; hex). Sum up individual hex values to obtain a decimal value. ; Definition at line 381 of file TFilePrefetch.cxx. ◆ ThreadProc(). TThread::VoidRtnFunc_t TFilePrefetch::ThreadProc ; (; void * ; arg). staticprivate . Execution loop of the consumer thread. ; Definition at line 365 of file TFilePrefetch.cxx. ◆ ThreadStart(). Int_t TFilePrefetch::ThreadStart ; (; ). Used to start the consumer thread. ; Definition at line 349 of file TFilePrefetch.cxx. ◆ WaitFinishPrefetch(). void TFilePrefet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFilePrefetch.html:17898,clear,clear,17898,doc/master/classTFilePrefetch.html,https://root.cern,https://root.cern/doc/master/classTFilePrefetch.html,1,['clear'],['clear']
Usability,"yer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. Bool_tfReturnFeedback; TArrayIfSlaveActW; TArrayL64fSlaveBytesRead; TArrayFfSlaveEffS; TArrayFfSlaveEvtRti; TArrayFfSlaveInitTime; TArrayFfSlaveMBRti; TArrayFfSlaveProcTime; TArrayL64fSlaveProgress; TArrayIfSlaveTotS; TArrayL64fSlaveTotals; TListfSlaves. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF. Runs on super master.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void Progress(TSlave* sl, Long64_t total, Long64_t processed); Report progress. void Progress(TSlave* sl, Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress. void Progress(TSlave* sl, TProofProgressInfo* pi); Progress signal. Bool_t HandleTimer(TTimer* timer); Send progress and feedback to client. void SetupFeedback(); Setup reporting of feedback objects and progress messages. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* sl, Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). TProofPlayerSuperMaster(TProof* proof = 0); { }. virtual ~TProofPlayerSuperMaster(); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-03 17:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPlayerSuperMaster.html:20248,feedback,feedback,20248,root/html604/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html604/TProofPlayerSuperMaster.html,4,['feedback'],['feedback']
Usability,"yer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. Bool_tfReturnFeedback; TArrayIfSlaveActW; TArrayL64fSlaveBytesRead; TArrayFfSlaveEffS; TArrayFfSlaveEvtRti; TArrayFfSlaveInitTime; TArrayFfSlaveMBRti; TArrayFfSlaveProcTime; TArrayL64fSlaveProgress; TArrayIfSlaveTotS; TArrayL64fSlaveTotals; TListfSlaves. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF. Runs on super master.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void Progress(TSlave* sl, Long64_t total, Long64_t processed); Report progress. void Progress(TSlave* sl, Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress. void Progress(TSlave* sl, TProofProgressInfo* pi); Progress signal. Bool_t HandleTimer(TTimer* timer); Send progress and feedback to client. void SetupFeedback(); Setup reporting of feedback objects and progress messages. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* sl, Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). TProofPlayerSuperMaster(TProof* proof = 0); { }. virtual ~TProofPlayerSuperMaster(); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-04 16:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayerSuperMaster.html:19373,feedback,feedback,19373,root/html534/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html534/TProofPlayerSuperMaster.html,4,['feedback'],['feedback']
Usability,"yer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. Bool_tfReturnFeedback; TArrayIfSlaveActW; TArrayL64fSlaveBytesRead; TArrayFfSlaveEffS; TArrayFfSlaveEvtRti; TArrayFfSlaveInitTime; TArrayFfSlaveMBRti; TArrayFfSlaveProcTime; TArrayL64fSlaveProgress; TArrayIfSlaveTotS; TArrayL64fSlaveTotals; TListfSlaves. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF. Runs on super master.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void Progress(TSlave* sl, Long64_t total, Long64_t processed); Report progress. void Progress(TSlave* sl, Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress. void Progress(TSlave* sl, TProofProgressInfo* pi); Progress signal. Bool_t HandleTimer(TTimer* timer); Send progress and feedback to client. void SetupFeedback(); Setup reporting of feedback objects and progress messages. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* sl, Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). TProofPlayerSuperMaster(TProof* proof = 0); { }. virtual ~TProofPlayerSuperMaster(); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-30 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayerSuperMaster.html:20038,feedback,feedback,20038,root/html602/TProofPlayerSuperMaster.html,https://root.cern,https://root.cern/root/html602/TProofPlayerSuperMaster.html,4,['feedback'],['feedback']
Usability,"yerData ;  ;  LayerData (const_iterator_type itInputBegin, const_iterator_type itInputEnd, ModeOutputValues eModeOutput=ModeOutputValues::DIRECT);  c'tor of LayerData ;  ;  LayerData (LayerData &&other);  move c'tor of LayerData ;  ;  LayerData (size_t inputSize);  c'tor of LayerData ;  ;  LayerData (size_t size, const_iterator_type itWeightBegin, iterator_type itGradientBegin, std::shared_ptr< std::function< double(double)> > activationFunction, std::shared_ptr< std::function< double(double)> > inverseActivationFunction, ModeOutputValues eModeOutput=ModeOutputValues::DIRECT);  c'tor of LayerData ;  ;  LayerData (size_t size, const_iterator_type itWeightBegin, std::shared_ptr< std::function< double(double)> > activationFunction, ModeOutputValues eModeOutput=ModeOutputValues::DIRECT);  c'tor of LayerData ;  ;  ~LayerData ();  ; std::shared_ptr< std::function< double(double)> > activationFunction () const;  ; void clear ();  clear the values and the deltas ;  ; void clearDropOut ();  clear the drop-out-data for this layer ;  ; iterator_type deltasBegin ();  returns iterator to the begin of the deltas (back-propagation) ;  ; const_iterator_type deltasBegin () const;  returns const iterator to the begin of the deltas (back-propagation) ;  ; iterator_type deltasEnd ();  returns iterator to the end of the deltas (back-propagation) ;  ; const_iterator_type deltasEnd () const;  returns const iterator to the end of the deltas (back-propagation) ;  ; const_dropout_iterator dropOut () const;  return the begin of the drop-out information ;  ; iterator_type gradientsBegin ();  returns iterator to the begin of the gradients ;  ; const_iterator_type gradientsBegin () const;  returns const iterator to the begin of the gradients ;  ; bool hasDropOut () const;  has this layer drop-out turned on? ;  ; std::shared_ptr< std::function< double(double)> > inverseActivationFunction () const;  ; ModeOutputValues outputMode () const;  returns the output mode ;  ; container_type probabilities ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1LayerData.html:2000,clear,clear,2000,doc/master/classTMVA_1_1DNN_1_1LayerData.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1LayerData.html,1,['clear'],['clear']
Usability,"yle.Definition TAttFill.h:39; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TBenchmark::Startvirtual void Start(const char *name)Starts Benchmark with the specified name.Definition TBenchmark.cxx:172; TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TCanvasThe Canvas class.Definition TCanvas.h:23; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPaveLabelA Pave (see TPave) with a text centered in the Pave.Definition TPaveLabel.h:20; TPaveLabel::Drawvoid Draw(Option_t *option="""") overrideDraw this pavelabel with its current attributes.Definition TPaveLabel.cxx:88; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::AddLinevirtual TLine * AddLine(Double_t x1=0, Double_t y1=0, Double_t x2=0, Double_t y2=0)Add a new graphics line to this pavetext.Definition TPaveText.cxx:177; TPaveText::Drawvoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree_8C.html:11593,simpl,simple,11593,doc/master/tree_8C.html,https://root.cern,https://root.cern/doc/master/tree_8C.html,1,['simpl'],['simple']
Usability,"yle_tTAttFill::fFillStylefill area style; TGeoPatternFinder*fFinderfinder object for divisions; UInt_tTGeoAtt::fGeoAttoption flags; TGeoManager*fGeoManager! pointer to TGeoManager owning this volume; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TGeoMedium*fMediumtracking medium; TStringTNamed::fNameobject identifier; TObjArray*fNodesarray of nodes inside this volume; Int_tfNtotaltotal number of physical nodes; Int_tfNumbervolume serial number in the list of volumes; TStringfOption! option - if any; Int_tfRefCountreference counter; TGeoShape*fShapeshape; TStringTNamed::fTitleobject title; TGeoExtension*fUserExtension! Transient user-defined extension to volumes; TGeoVoxelFinder*fVoxelsfinder object for bounding boxes; static TGeoMedium*fgDummyMedium! dummy medium. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void CreateDummyMedium(); Create a dummy medium. void ClearThreadData() const. void CreateThreadData(Int_t nthreads). TGeoMedium * DummyMedium(). TGeoVolume(); dummy constructor. TGeoVolume(const char* name, const TGeoShape* shape, const TGeoMedium* med = 0); default constructor. TGeoVolume(const TGeoVolume& ); copy constructor. TGeoVolume& operator=(const TGeoVolume& ); assignment operator. ~TGeoVolume(); Destructor. void Browse(TBrowser* b); How to browse a volume. Double_t Capacity() const; Computes the capacity of this [cm^3] as the capacity of its shape.; In case of assemblies, the capacity is computed as the sum of daughter's capacities. void CheckGeometry(Int_t nrays = 1, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0) const; Shoot nrays with random directions from starting point (startx, starty, startz); in the reference frame of this volume. Track each ray until exiting geometry, then; shoot backwards from exiting point and compare boundary crossing points. void CheckOverlaps(Double_t ovlp = 0.1, Option_t* option = """") cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:31780,Clear,ClearThreadData,31780,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,1,['Clear'],['ClearThreadData']
Usability,"yle_tTAttFill::fFillStylefill area style; TGeoPatternFinder*fFinderfinder object for divisions; UInt_tTGeoAtt::fGeoAttoption flags; TGeoManager*fGeoManager! pointer to TGeoManager owning this volume; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TGeoMedium*fMediumtracking medium; TStringTNamed::fNameobject identifier; TObjArray*fNodesarray of nodes inside this volume; Int_tfNtotaltotal number of physical nodes; Int_tfNumbervolume serial number in the list of volumes; TStringfOption! option - if any; Int_tfRefCountreference counter; TGeoShape*fShapeshape; TStringTNamed::fTitleobject title; TGeoExtension*fUserExtension! Transient user-defined extension to volumes; TGeoVoxelFinder*fVoxelsfinder object for bounding boxes; static TGeoMedium*fgDummyMedium! dummy medium. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void CreateDummyMedium(); Create a dummy medium. void ClearThreadData() const. void CreateThreadData(Int_t nthreads). TGeoMedium * DummyMedium(). TGeoVolume(); dummy constructor. TGeoVolume(const char* name, const TGeoShape* shape, const TGeoMedium* med = 0); default constructor. TGeoVolume(const TGeoVolume& ); copy constructor. TGeoVolume& operator=(const TGeoVolume& ); assignment operator. ~TGeoVolume(); Destructor. void Browse(TBrowser* b); How to browse a volume. Double_t Capacity() const; Computes the capacity of this [cm^3] as the capacity of its shape.; In case of assemblies, the capacity is computed as the sum of daughter's capacities. void CheckGeometry(Int_t nrays = 1, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0) const; Shoot nrays with random directions from starting point (startx, starty, startz); in the reference frame of this volume. Track each ray until exiting geometry, then; shoot backwards from exiting point and compare boundary crossing points. void CheckOverlaps(Double_t ovlp = 0.10000000000000001, Option_t* o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolume.html:33341,Clear,ClearThreadData,33341,root/html602/TGeoVolume.html,https://root.cern,https://root.cern/root/html602/TGeoVolume.html,2,['Clear'],['ClearThreadData']
Usability,"ym<Element> Use(Int_t nrows, const float* data) const; { return Use(0,nrows-1,data); }. template <class Element> inline TMatrixTSym<Element> &TMatrixTSym<Element> Use(TMatrixTSym<float>& a); { return Use(a.GetRowLwb(),a.GetRowUpb(),a.GetMatrixArray()); }. template <class Element> inline const TMatrixTSym<Element> &TMatrixTSym<Element> Use(const TMatrixTSym<float>& a) const; { return Use(a.GetRowLwb(),a.GetRowUpb(),a.GetMatrixArray()); }. template <class Element> inline TMatrixTSym<Element> TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t* option = ""S"") const. template <class Element> inline Element TMatrixTSym<Element> operator()(Int_t rown, Int_t coln) const. template <class Element> inline Element &TMatrixTSym<Element> operator()(Int_t rown, Int_t coln). void Mult(const TMatrixTSym<float>& a); { TMult(a); }. const Int_t * GetRowIndexArray() const; { return 0; }. Int_t * GetRowIndexArray(); { return 0; }. const Int_t * GetColIndexArray() const; { return 0; }. Int_t * GetColIndexArray(); { return 0; }. TMatrixTBase<Element> & SetRowIndexArray(Int_t* ); { MayNotUse(""SetRowIndexArray(Int_t *)""); return *this; }. TMatrixTBase<Element> & SetColIndexArray(Int_t* ); { MayNotUse(""SetColIndexArray(Int_t *)""); return *this; }. void Clear(Option_t* = """"). Bool_t IsSymmetric() const; { return kTRUE; }. TMatrixTSym <Element> & Use(Int_t row_lwb, Int_t row_upb, float* data). TMatrixTBase<Element> & ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1). const TMatrixTRow_const<Element> operator[](Int_t rown) const; or as a[i][j]. { return TMatrixTRow_const<Element>(*this,rown); }. TMatrixTRow <Element> operator[](Int_t rown); { return TMatrixTRow <Element>(*this,rown); }. » Last changed: root/matrix:$Id: TMatrixTSym.h 34744 2010-08-07 06:16:36Z brun $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMatrixTSym_float_.html:22347,Clear,Clear,22347,root/html532/TMatrixTSym_float_.html,https://root.cern,https://root.cern/root/html532/TMatrixTSym_float_.html,1,['Clear'],['Clear']
Usability,"you can make repeated calls to AddObject(), with TBuffer3D; containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers; to the properties of logical object, with the fLocalMaster transform and the; fColor and fTransparency attributes, which can be varied for each physical; object.; As a minimum requirement all clients must be capable of filling the raw tessellation; of the object buffer, in the master reference frame. Conversely viewers must; always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; - it may for various reasons decide to ignore it:. It already has the object internally cached .; The object falls outside; some 'interest' limits of the viewer camera.; The object is too small to; be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition,; simply indicating it does not require you to provide further information about; this object. You should; not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially; millions of objects, and only accept those that are of interest at a certain; time, caching the relatively small number of CPU/memory costly logical shapes,; and retaining/discarding the physical placements as required. The viewer may; decide to force the client to rebuild (republish) the scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualVie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBuffer3D.html:6755,simpl,simply,6755,root/html526/TBuffer3D.html,https://root.cern,https://root.cern/root/html526/TBuffer3D.html,21,['simpl'],['simply']
Usability,"you can use TTree::MakeClass. It creates a class that loops over the trees entries one by one. You can then expand it to do the logic of your analysis.; The TTree::MakeSelector is the recommended method for ROOT data analysis. It is especially important for large data set in a parallel processing configuration where the analysis is distributed over several processors and you can specify which entries to send to each processor. With MakeClass the user has control over the event loop, with MakeSelectorthe tree is in control of the event loop.; 12.20 Simple Analysis Using TTree::Draw; We will use the tree in cernstaff.root that was made by the macro in $ROOTSYS/tutorials/tree/staff.C.; First, open the file and lists its contents.; root[] TFile f (""cernstaff.root""); root[] f.ls(); TFile** cernstaff.root; TFile* cernstaff.root; KEY: TTree T;1 staff data from ascii file; We can see the TTree“T” in the file. We will use it to experiment with the TTree::Draw method, so let’s create a pointer to it:; root[] TTree *MyTree = T; Cling allows us to get simply the object by using it. Here we define a pointer to a TTree object and assign it the value of “T”, the TTree in the file. Cling looks for an object named “T” in the current ROOT file and returns it (this assumes that “T” has not previously been used to declare a variable or function).; In contrast, in compiled code, you can use:; TTree *MyTree;f.GetObject(""T"",MyTree);; To show the different Draw options, we create a canvas with four sub-pads. We will use one sub-pad for each Draw command.; root[] TCanvas *myCanvas = new TCanvas(); root[] myCanvas->Divide(2,2); We activate the first pad with the TCanvas::cd statement:; root[] myCanvas->cd(1); We then draw the variable Cost:; root[] MyTree->Draw(""C; As you can see, the last call TTree::Draw has only one parameter. It is a string containing the leaf name. A histogram is automatically created as a result of a TTree::Draw. The style of the histogram is inherited from the TTree a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:585374,simpl,simply,585374,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simply']
Usability,"ype STL container; TStreamerSTLstring Streamer element of type C++ string; TStreamerString Streamer element of type TString; TString Basic string class; TStringLong Long string class (more than 255 chars); TStringRef ; TStringToken String tokenizer using PCRE for finding next tokens.; TStructNode Node with information about class; TStructNodeEditor GUI fo editing TStructNode; TStructNodeProperty Class with nodes color property; TStructViewer A 3D struct viewer; TStructViewerGUI A GUI fo 3D struct viewer ; TStyle A collection of all graphics attributes; TStyleDialog Dialog box used by the TStyleManager class; TStyleManager Graphical User Interface for managing styles; TStylePreview Preview window used by the TStyleManager class; TSubString ; TSynapse simple weighted bidirectionnal connection between 2 neurons; TSysEvtHandler ABC for handling system events; TSystem ABC defining a generic interface to the OS; TSystemDirectory A system directory; TSystemFile A system file; TTF Interface to TTF font handling; TTRAP TRAP shape; TTRD1 TRD1 shape; TTRD2 TRD2 shape; TTUBE TUBE shape; TTUBS TUBS shape; TTVLVContainer A dragging-capable LVContainer; TTVLVEntry Item that goes into the tree list view widget; TTVRecord A draw record for TTreeViewer; TTVSession A tree viewer session; TTabCom Perform comand line completion when hitting <TAB>; TTable vector of the C structures; TTable3Points A 3-D Points; TTable::iterator ; TTableDescriptor descrpitor defining the internal layout of TTable objects; TTableIter Iterator over ""sorted"" TTable objects; TTableMap ""Map"" array for TTable object; TTablePadView3D ; TTablePoints Defines the TTable as an element of ""event"" geometry; TTableRange Range used in TGTable.; TTableSorter Is an ""observer"" class to sort the TTable objects; TTask Base class for tasks; TText Text; TThread Thread class; TThreadFactory Thread factory ABC; TThreadImp ThreadImp class; TTime Basic time type with milli second precision; TTimeStamp Encapsulates seconds and ns sin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:121839,simpl,simple,121839,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['simpl'],['simple']
Usability,"ypes |; Public Member Functions |; Static Public Member Functions |; Private Attributes |; List of all members ; TStyle Class ReferenceCore ROOT classes » Base ROOT classes | Graphics » Graphics attributes. ; TStyle objects may be created to define special styles. ; By default ROOT creates a default style that can be accessed via the gStyle pointer.; This class includes functions to set some of the following object attributes.; Canvas; Pad; Histogram axis; Lines; Fill areas; Text; Markers; Functions; Histogram Statistics and Titles. All objects that can be drawn in a pad inherit from one or more attribute classes like TAttLine, TAttFill, TAttText, TAttMarker. When the objects are created, their default attributes are taken from the current style. The current style is an object of the classTStyle and can be referenced via the global variable gStyle (in TStyle.h).; ROOT provides two styles called ""Default"" and ""Plain"". The ""Default"" style is created simply by:; auto default = new TStyle(""Default"",""Default Style"");; TStyle::TStyleTStyle()Default constructor.Definition TStyle.cxx:145; The Plain style can be used if you are working on a monochrome display or if you want to get a ""conventional"" Postscript output. These are the instructions in the ROOT constructor to create the Plain style.; auto plain = new TStyle(""Plain"",""Plain Style (no colors/fill areas)"");; ; plain->SetCanvasBorderMode(0);; plain->SetPadBorderMode(0);; plain->SetPadColor(0);; plain->SetCanvasColor(0);; plain->SetTitleColor(0);; plain->SetStatColor(0);; You can set the current style with:; gROOT->SetStyle(style_name);; gROOT#define gROOTDefinition TROOT.h:406; You can get a pointer to an existing style with:; auto style = gROOT->GetStyle(style_name);; styleOption_t Option_t styleDefinition TGWin32VirtualXProxy.cxx:46; You can create additional styles with:; TStyle *st1 = new TStyle(""st1"",""my style"");; st1->Set....; st1->cd(); this becomes now the current style gStyle; gStyleR__EXTERN TStyle * gStyleDefi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStyle.html:1106,simpl,simply,1106,doc/master/classTStyle.html,https://root.cern,https://root.cern/doc/master/classTStyle.html,1,['simpl'],['simply']
Usability,"ypically here the branch addresses and branch; pointers of the tree will be set.; It is normaly not necessary to make changes to the generated; code, but the routine can be extended by the user if needed.; Init() will be called many times when running on PROOF; (once per file to be processed). Bool_t Notify(); This function is called at the first entry of a new tree in a chain. Bool_t Process(Long64_t entry); The Process() function is called for each entry in the tree (or possibly; keyed object in the case of PROOF) to be processed. The entry argument; specifies which entry in the currently loaded tree is to be processed.; It can be passed to either TSelectorEntries::GetEntry() or TBranch::GetEntry(); to read either all or the required parts of the data. When processing; keyed objects with PROOF, the object is already loaded and is available; via the fObject pointer. This function should contain the ""body"" of the analysis. It can contain; simple or elaborate selection criteria, run algorithms on the data; of the event and typically fill histograms. The processing can be stopped by calling Abort(). Use fStatus to set the return value of TTree::Process(). The return value is currently not used. void SetSelection(const char* selection); set the selection expression. void SlaveTerminate(); The SlaveTerminate() function is called after all entries or objects; have been processed. When running with PROOF SlaveTerminate() is called; on each slave server. void Terminate(); The Terminate() function is the last function to be called during; a query. It always runs on the client, it can be used to present; the results graphically or save the results to file. TSelectorEntries(TTree* tree = 0, const char* selection = 0). Int_t Version() const; { return 2; }. Long64_t GetSelectedRows() const; { return fSelectedRows; }. void SetOption(const char* option); { fOption = option; }. void SetObject(TObject* obj); { fObject = obj; }. TList * GetOutputList() const; { return fOutput; }. » ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSelectorEntries.html:9356,simpl,simple,9356,root/html602/TSelectorEntries.html,https://root.cern,https://root.cern/root/html602/TSelectorEntries.html,4,['simpl'],['simple']
Usability,"ysics with mixing and/or CP violation ;  ; file  rf709_BarlowBeeston.C;   Implementing the Barlow-Beeston method for taking into account the statistical uncertainty of a Monte-Carlo fit template. ;  ; file  rf709_BarlowBeeston.py;   Implementing the Barlow-Beeston method for taking into account the statistical uncertainty of a Monte-Carlo fit template. ;  ; file  rf710_roopoly.C;   Taylor expansion of RooFit functions using the taylorExpand function with RooPolyFunc ;  ; file  rf710_roopoly.py;   Taylor expansion of RooFit functions using the taylorExpand function ;  ; file  rf711_lagrangianmorph.C;   Morphing effective field theory distributions with RooLagrangianMorphFunc A morphing function as a function of one coefficient is setup and can be used to obtain the distribution for any value of the coefficient. ;  ; file  rf711_lagrangianmorph.py;   Morphing effective field theory distributions with RooLagrangianMorphFunc. ;  ; file  rf712_lagrangianmorphfit.C;   Performing a simple fit with RooLagrangianMorphFunc. ;  ; file  rf712_lagrangianmorphfit.py;   Performing a simple fit with RooLagrangianMorphFunc ;  ; file  rf801_mcstudy.C;   Validation and MC studies: toy Monte Carlo study that perform cycles of event generation and fitting ;  ; file  rf801_mcstudy.py;   Validation and MC studies: toy Monte Carlo study that perform cycles of event generation and fitting ;  ; file  rf802_mcstudy_addons.C;   Validation and MC studies: RooMCStudy - using separate fit and generator models, using the chi^2 calculator model Running a biased fit model against an optimal fit. ;  ; file  rf803_mcstudy_addons2.C;   Validation and MC studies: RooMCStudy - Using the randomizer and profile likelihood add-on models ;  ; file  rf804_mcstudy_constr.C;   Validation and MC studies: using RooMCStudy on models with constrains ;  ; file  rf901_numintconfig.C;   Numeric algorithm tuning: configuration and customization of how numeric (partial) integrals are executed ;  ; file  rf901_numintconfi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__roofit.html:22673,simpl,simple,22673,doc/master/group__tutorial__roofit.html,https://root.cern,https://root.cern/doc/master/group__tutorial__roofit.html,1,['simpl'],['simple']
Usability,"ystem_clock> tstart, tend;; 1400 tstart = std::chrono::system_clock::now();; 1401 ; 1402 // function building string with optimizer parameters values for logging; 1403 auto optimParametersString = [&]() {; 1404 TString optimParameters;; 1405 for ( auto & element : settings.optimizerParams) {; 1406 TString key = element.first;; 1407 key.ReplaceAll(settings.optimizerName + ""_"", """"); // strip optimizerName_; 1408 double value = element.second;; 1409 if (!optimParameters.IsNull()); 1410 optimParameters += "","";; 1411 else; 1412 optimParameters += "" ("";; 1413 optimParameters += TString::Format(""%s=%g"", key.Data(), value);; 1414 }; 1415 if (!optimParameters.IsNull()); 1416 optimParameters += "")"";; 1417 return optimParameters;; 1418 };; 1419 ; 1420 Log() << ""Training phase "" << trainingPhase << "" of "" << this->GetTrainingSettings().size() << "": ""; 1421 << "" Optimizer "" << settings.optimizerName; 1422 << optimParametersString(); 1423 << "" Learning rate = "" << settings.learningRate << "" regularization "" << (char)settings.regularization; 1424 << "" minimum error = "" << minValError << Endl;; 1425 if (!fInteractive) {; 1426 std::string separator(62, '-');; 1427 Log() << separator << Endl;; 1428 Log() << std::setw(10) << ""Epoch""; 1429 << "" | "" << std::setw(12) << ""Train Err."" << std::setw(12) << ""Val. Err."" << std::setw(12); 1430 << ""t(s)/epoch"" << std::setw(12) << ""t(s)/Loss"" << std::setw(12) << ""nEvents/s"" << std::setw(12); 1431 << ""Conv. Steps"" << Endl;; 1432 Log() << separator << Endl;; 1433 }; 1434 ; 1435 // set up generator for shuffling the batches; 1436 // if seed is zero we have always a different order in the batches; 1437 size_t shuffleSeed = 0;; 1438 if (fRandomSeed != 0) shuffleSeed = fRandomSeed + trainingPhase;; 1439 RandomGenerator<TRandom3> rng(shuffleSeed);; 1440 ; 1441 // print weights before; 1442 if (fBuildNet && debug) {; 1443 Log() << ""Initial Deep Net Weights "" << Endl;; 1444 auto & weights_tensor = deepNet.GetLayerAt(0)->GetWeights();; 1445 for (size_t l = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:56480,learn,learningRate,56480,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['learn'],['learningRate']
Usability,"ytest2.C This macro is testing the ""compacting"" algorithm in TPadPainter ;  pstable.C Display all possible types of ROOT/Postscript characters ;  psview.C An example how to display PS, EPS, PDF files in canvas ;  quarks.C Example illustrating divided pads and Latex ;  tmathtext.CThis macro draws various formula in a canvas ;  tmathtext2.C This macro draw all possible symbols provided by TMathtext ;  tornado.C Show 3-d polymarker ;  transparency.C This macro demonstrates the use of color transparency ;  triangles.C Generate small triangles randomly in the canvas ;  ► graphs;  annotation3d.C This example show how to put some annotation on a 3D plot using 3D polylines ;  approx.C Macro to test interpolation function Approx ;  bent.C Bent error bars ;  exclusiongraph.C Draw three graphs with an exclusion zone ;  exclusiongraph2.C Draw several graphs with an exclusion zones ;  gerrors.C Draw a graph with error bars ;  gerrors2.C Draw two graphs with error bars ;  graph.C Draw a simple graph ;  graph2derrorsfit.C Draw and fit a TGraph2DErrors ;  graphApply.C A macro to demonstrate the functionality of TGraph::Apply() method ;  graphpalettecolor.C Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  graphpolar.C Create and draw a polar graph ;  graphpolar2.C Create and draw a polar graph with PI axis ;  graphpolar3.C Create and draw a polar graph with PI axis using a TF1 ;  graphShade.C Show how to shade an area between two graphs ;  graphstruct.C Draw a simple graph structure ;  graphtext.C Draw a graph with text attached to each point ;  gtime.C Example of TGraphTime ;  gtime2.C Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program ;  labels1.C Setting alphanumeric labels in a 1-d histogram ;  labels2.C Setting alphanumeric labels ;  motorcycle.C Macro to test scatterplot smoothers: ksmooth, lowes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:116292,simpl,simple,116292,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['simpl'],['simple']
Usability,"ywork[0] = ylow;; 1637 gxwork[1] = xhigh;; 1638 gywork[1] = yhigh;; 1639 ComputeLogs(2, optionZ);; 1640 if (gyworkl[0] < gPad->GetUymin()) gyworkl[0] = gPad->GetUymin();; 1641 if (gyworkl[1] < gPad->GetUymin()) continue;; 1642 if (gyworkl[1] > gPad->GetUymax()) gyworkl[1] = gPad->GetUymax();; 1643 if (gyworkl[0] > gPad->GetUymax()) continue;; 1644 ; 1645 gPad->PaintBox(gxworkl[0],gyworkl[0],gxworkl[1],gyworkl[1]);; 1646 }; 1647 } else {; 1648 for (i=1;i<=npoints;i++) {; 1649 xhigh = x[i-1];; 1650 ylow = y[i-1] - dbar;; 1651 yhigh = y[i-1] + dbar;; 1652 xlow = TMath::Max((Double_t)0, gPad->GetUxmin());; 1653 gxwork[0] = xlow;; 1654 gywork[0] = ylow;; 1655 gxwork[1] = xhigh;; 1656 gywork[1] = yhigh;; 1657 ComputeLogs(2, optionZ);; 1658 gPad->PaintBox(gxworkl[0],gyworkl[0],gxworkl[1],gyworkl[1]);; 1659 }; 1660 }; 1661 theGraph->SetFillColor(FillSave);; 1662 theGraph->TAttFill::Modify();; 1663 }; 1664 gPad->ResetBit(TGraph::kClipFrame);; 1665 ; 1666 gxwork.clear();; 1667 gywork.clear();; 1668 gxworkl.clear();; 1669 gyworkl.clear();; 1670}; 1671 ; 1672 ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// This is a service method used by `THistPainter`; 1675/// to paint 1D histograms. It is not used to paint TGraph.; 1676///; 1677/// Input parameters:; 1678///; 1679/// - npoints : Number of points in X or in Y.; 1680/// - x[npoints] or x[0] : x coordinates or (xmin,xmax).; 1681/// - y[npoints] or y[0] : y coordinates or (ymin,ymax).; 1682/// - chopt : Option.; 1683///; 1684/// The aspect of the histogram is done according to the value of the chopt.; 1685///; 1686/// | Option | Description |; 1687/// |--------|-----------------------------------------------------------------|; 1688/// |""R"" | Graph is drawn horizontally, parallel to X axis. (default is vertically, parallel to Y axis).If option R is selected the user must give 2 values for Y (y[0]=YMIN and y[1]=YMAX) or N values for X, one for each channel. Otherwise the user must gi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:60401,clear,clear,60401,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['clear'],['clear']
Usability,"z);; // or:; gGeoManager->SetCurrentPoint(Double_t *point[3]);; 18.5.3 Initializing the Direction; In order to move inside geometry starting with the current point, the modeller needs to know the current direction (nx,ny,nz). This direction is stored as Double_t fCurrentDirection[3] by the navigator and it represents a direction in the global frame. It can be retrieved with:; Const Double_t *cdir = gGeoManager->GetCurrentDirection();; The direction can be initialized in a similar manner as the current point:; gGeoManager->SetCurrentDirection(nx,ny,nz);; // or:; gGeoManager->SetCurrentDirection(Double_t *dir);; 18.5.4 Initializing the State; Setting the initial point and direction is not enough for initializing tracking. The modeller needs to find out where the initial point is located in the geometrical hierarchy. Due to the containment based architecture of the model, this is the deepest positioned object containing the point. For illustrating this, imagine that we have a simple structure with a top volume A and another one Bpositioned inside. Since Ais a top volume, its associated node A_1 will define MARS and our simple hierarchy of nodes (positioned volumes) will be: /A_1/B_1. Suppose now that the initial point is contained by B_1. This implies by default that the point is also contained by A_1, since B_1 have to be fully contained by this. After searching the point location, the modeller will consider that the point is located inside B_1, which will be considered as the representative object (node) for the current state. This is stored as: TGeoNode *TGeoManager::fCurrentNodeand can be asked from the manager class only after the 'Where am I?' was completed:; TGeoNode *current = gGeoManager->GetCurrentNode();; In order to find the location of the current point inside the hierarchy of nodes, after setting this point it is mandatory to call the ‘Where am I?' method:; gGeoManager->FindNode();; In order to have more flexibility, there are in fact several alternative w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:974788,simpl,simple,974788,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['simpl'],['simple']
Usability,"ze fSelector using the selector files in the query result.; Needed when Finalize is called after a Process execution for the same; selector name. Int_t AddOutputObject(TObject* obj); Incorporate output object (may not be used in this class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Int_t SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); Save the partial results of this query to a dedicated file under the user; data directory. The file name has the form; <session_tag>.q<query_seq_num>.root; The file pat and the file are created if not existing already.; Only objects in the outputlist not being TProofOutputFile are saved.; The packets list 'packets' is saved if given.; Trees not attached to any file are attached to the open file.; If 'queryend' is kTRUE evrything is written out (TTrees included).; The actual saving action is controlled by 'force' and by fSavePartialResults; fSaveResultsPerPacket:. fSavePartialResults = kFALSE/kTRUE no-saving/saving; fSaveResultsPerPacket = kFALSE/kTRUE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:17606,feedback,feedback,17606,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,6,['feedback'],['feedback']
Usability,"ze fSelector using the selector files in the query result.; Needed when Finalize is called after a Process execution for the same; selector name. Int_t AddOutputObject(TObject* obj); Incorporate output object (may not be used in this class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF worker.; The return value is -1 in case of error and TSelector::GetStatus(); in case of success. Bool_t CheckMemUsage(Long64_t& mfreq, Bool_t& w80r, Bool_t& w80v, TString& wmsg); Check the memory usage, if requested.; Return kTRUE if OK, kFALSE if above 95% of at least one between virtual or; resident limits are depassed. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); Finalize query (may not be used in this class). Long64_t Finalize(TQueryResult* qr); Finalize query (may not be used in this class). void MergeOutput(); Merge output (may not be used in thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayer.html:16247,feedback,feedback,16247,root/html528/TProofPlayer.html,https://root.cern,https://root.cern/root/html528/TProofPlayer.html,4,['feedback'],['feedback']
Usability,"ze void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; THashList.h; TInterpreter.h; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; TMethod.h; TPRegexp.h; TQClass.h; TQConnection.h; gTQSendervoid * gTQSenderDefinition TQObject.cxx:74; ConnectCINTBool_t ConnectCINT(TQObject *sender, const char *signal, const char *slot)Global function which simplifies making connection in interpreted ROOT session.Definition TQObject.cxx:1069; TQObject.h; ClassImpQ#define ClassImpQ(name)Definition TQObject.h:283; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TVirtualMutex.h; R__LOCKGUARD2#define R__LOCKGUARD2(mutex)Definition TVirtualMutex.h:96; protoconst char * protoDefinition civetweb.c:17535; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; TBaseClass::GetClassPointerTClass * GetClassPointer(Bool_t load=kTRUE)Get pointer to the base class TClass.Definition TBaseClass.cxx:63; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8cxx_source.html:37230,simpl,simplifies,37230,doc/master/TQObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html,1,['simpl'],['simplifies']
Usability,"ze(UInt_t w=0, UInt_t h=0) overrideResize the frame.Definition TGFrame.cxx:605; TGFrame::MapWindowvoid MapWindow() overridemap windowDefinition TGFrame.h:204; TGLayoutHintsThis class describes layout hints used by the layout classes.Definition TGLayout.h:50; TGMainFrameDefines top level windows that interact with the system Window Manager.Definition TGFrame.h:397; TGMainFrame::SetWindowNamevoid SetWindowName(const char *name=nullptr) overrideSet window name. This is typically done via the window manager.Definition TGFrame.cxx:1788; TGSimpleTableInterfaceTGSimpleTableInterface is a very simple implementation of a TVirtualTableInterface.Definition TGSimpleTableInterface.h:18; TGTableCreate an array to hold a bunch of numbers.Definition TGTable.h:34; TGTable::Updatevirtual void Update()Update the range of the available data and refresh the current view.Definition TGTable.cxx:1529; double; int; unsigned int; It is also possible to visualise data from a tree. A simple macro showing the use of a TTreeTableInterface follows.; {; // Open a root file.; TFile *file = new TFile(""$ROOTSYS/tutorials/hsimple.root"");; // Load a tree from the file; TNtuple *ntuple = (TNtuple *)file->Get(""ntuple"");; ; // Create an interface; TTreeTableInterface *iface = new TTreeTableInterface(ntuple);; ; // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;; ; // Create the table; TGTable *table = new TGTable(mainframe, 999, iface, 10, 6);; ; // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));; ; // Set a selection; iface->SetSelection(""px > 0."");; // Add a column; iface->AddColumn(""(px+py)/(px-py)"", 0);; //update the table view; table->Update();; ; // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;; ; return mainframe;; }; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTable.html:4515,simpl,simple,4515,doc/master/classTGTable.html,https://root.cern,https://root.cern/doc/master/classTGTable.html,1,['simpl'],['simple']
Usability,"zeCurrentCamera(const TGLVector3& hAxis, const TGLVector3& vAxis, Bool_t redraw = kTRUE); Change base-vectors defining the camera-base transformation of current; camera. hAxis and vAxis are the default directions for forward; (inverted) and upwards. TGLAutoRotator* GetAutoRotator(); Get the auto-rotator for this viewer. void SetAutoRotator(TGLAutoRotator* ar); Set the auto-rotator for this viewer. The old rotator is deleted. void SetStereo(Bool_t stereo, Bool_t quad_buf = kTRUE); Enable stereo rendering.; If quad_buf is true rendering is done into separate left and right GL; buffers. This requires hardware support. Otherwise left and right images; get rendered into left and right half of the window.; Note that mouse highlighting and selection will not work exactly right; as image for each eye gets slightly shifted and there are two different; directions through the mouse pointer, one for each eye. void GetGuideState(Int_t& axesType, Bool_t& axesDepthTest, Bool_t& referenceOn, Double_t* referencePos) const; Fetch the state of guides (axes & reference markers) into arguments. void SetGuideState(Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t* referencePos); Set the state of guides (axes & reference markers) from arguments. void SetDrawCameraCenter(Bool_t x); Draw camera look at and rotation point. const TGLPhysicalShape * GetSelected() const; Return selected physical shape. void MouseOver(TGLPhysicalShape* ); Emit MouseOver signal. void MouseOver(TGLPhysicalShape* , UInt_t state); Emit MouseOver signal. void MouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void ReMouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void UnMouseOver(TObject* obj, UInt_t state); Emit UnMouseOver signal. void Clicked(TObject* obj); Emit Clicked signal. void Clicked(TObject* obj, UInt_t button, UInt_t state); Emit Clicked signal with button id and modifier state. void ReClicked(TObject* obj, UInt_t button, UInt_t state); Emit ReClicked signal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLViewer.html:35621,guid,guides,35621,root/html604/TGLViewer.html,https://root.cern,https://root.cern/root/html604/TGLViewer.html,2,['guid'],['guides']
Usability,"zeWeights(WeightInitializationStrategy::XAVIERUNIFORM,; 826 std::back_inserter(weights));; 827 break;; 828 default:; 829 net.initializeWeights(WeightInitializationStrategy::XAVIER,; 830 std::back_inserter(weights));; 831 break;; 832 }; 833 ; 834 int idxSetting = 0;; 835 for (auto s : fTrainingSettings) {; 836 ; 837 EnumRegularization r = EnumRegularization::NONE;; 838 switch(s.regularization) {; 839 case ERegularization::kNone: r = EnumRegularization::NONE; break;; 840 case ERegularization::kL1: r = EnumRegularization::L1; break;; 841 case ERegularization::kL2: r = EnumRegularization::L2; break;; 842 }; 843 ; 844 Settings * settings = new Settings(TString(), s.convergenceSteps, s.batchSize,; 845 s.testInterval, s.weightDecay, r,; 846 MinimizerType::fSteepest, s.learningRate,; 847 s.momentum, 1, s.multithreading);; 848 std::shared_ptr<Settings> ptrSettings(settings);; 849 ptrSettings->setMonitoring (0);; 850 Log() << kINFO; 851 << ""Training with learning rate = "" << ptrSettings->learningRate (); 852 << "", momentum = "" << ptrSettings->momentum (); 853 << "", repetitions = "" << ptrSettings->repetitions (); 854 << Endl;; 855 ; 856 ptrSettings->setProgressLimits ((idxSetting)*100.0/(fSettings.size ()),; 857 (idxSetting+1)*100.0/(fSettings.size ()));; 858 ; 859 const std::vector<double>& dropConfig = ptrSettings->dropFractions ();; 860 if (!dropConfig.empty ()) {; 861 Log () << kINFO << ""Drop configuration"" << Endl; 862 << "" drop repetitions = "" << ptrSettings->dropRepetitions(); 863 << Endl;; 864 }; 865 ; 866 int idx = 0;; 867 for (auto f : dropConfig) {; 868 Log () << kINFO << "" Layer "" << idx << "" = "" << f << Endl;; 869 ++idx;; 870 }; 871 Log () << kINFO << Endl;; 872 ; 873 DNN::Steepest minimizer(ptrSettings->learningRate(),; 874 ptrSettings->momentum(),; 875 ptrSettings->repetitions());; 876 net.train(weights, trainPattern, testPattern, minimizer, *ptrSettings.get());; 877 ptrSettings.reset();; 878 Log () << kINFO << Endl;; 879 idxSetting++;; 880 }; 881 size_t weightIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:30476,learn,learning,30476,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,2,['learn'],"['learning', 'learningRate']"
Usability,"ze_t minError() constreturns the smallest error so farDefinition NeuralNet.h:829; TMVA::DNN::Settings::startTrainingvirtual void startTraining()Definition NeuralNet.h:795; TMVA::DNN::Settings::m_maxConvergenceCountsize_t m_maxConvergenceCountDefinition NeuralNet.h:858; TMVA::DNN::Settings::startTestCyclevirtual void startTestCycle()callback for monitoring and logggingDefinition NeuralNet.h:804; TMVA::DNN::SteepestSteepest Gradient Descent algorithm (SGD)Definition NeuralNet.h:334; TMVA::DNN::Steepest::m_repetitionssize_t m_repetitionsDefinition NeuralNet.h:337; TMVA::DNN::Steepest::m_betadouble m_betainternal parameter (momentum)Definition NeuralNet.h:372; TMVA::DNN::Steepest::m_localGradientsstd::vector< double > m_localGradientslocal gradients for reuse in thread.Definition NeuralNet.h:376; TMVA::DNN::Steepest::m_prevGradientsstd::vector< double > m_prevGradientsvector remembers the gradients of the previous stepDefinition NeuralNet.h:373; TMVA::DNN::Steepest::m_alphadouble m_alphainternal parameter (learningRate)Definition NeuralNet.h:371; TMVA::DNN::Steepest::m_localWeightsstd::vector< double > m_localWeightslocal weights for reuse in thread.Definition NeuralNet.h:375; TMVA::DNN::Steepest::operator()double operator()(Function &fitnessFunction, Weights &weights, PassThrough &passThrough)operator to call the steepest gradient descent algorithmDefinition NeuralNet.icc:271; TMVA::DNN::Steepest::SteepestSteepest(double learningRate=1e-4, double momentum=0.5, size_t repetitions=10)c'torDefinition NeuralNet.h:348; TMVA::IPythonInteractiveThis class is needed by JsMVA, and it's a helper class for tracking errors during the training in Jup...Definition MethodBase.h:94; TMVA::TimerTiming information for training and evaluation of MVA methods.Definition Timer.h:58; TMVA::Timer::DrawProgressBarvoid DrawProgressBar(Int_t, const TString &comment="""")draws progress bar in color or B&W caution:Definition Timer.cxx:202; TStringBasic string class.Definition TString.h:139; double; u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:78823,learn,learningRate,78823,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['learn'],['learningRate']
Usability,"zer::applyCovarianceMatrix ; (; TMatrixDSym const & ; V). Apply results of given external covariance matrix. ; i.e. propagate its errors to all RRV parameter representations and give this matrix instead of the HESSE matrix at the next save() call ; Definition at line 732 of file RooMinimizer.cxx. ◆ calculateHessErrors(). bool RooMinimizer::calculateHessErrors ; (; ). private . Definition at line 880 of file RooMinimizer.cxx. ◆ calculateMinosErrors(). bool RooMinimizer::calculateMinosErrors ; (; ). private . Definition at line 911 of file RooMinimizer.cxx. ◆ Class(). static TClass * RooMinimizer::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooMinimizer::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooMinimizer::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 247 of file RooMinimizer.h. ◆ clearStatusHistory(). void RooMinimizer::clearStatusHistory ; (; ). inline . Clears the Minuit status history. ; Definition at line 182 of file RooMinimizer.h. ◆ contour(). RooPlot * RooMinimizer::contour ; (; RooRealVar & ; var1, . RooRealVar & ; var2, . double ; n1 = 1.0, . double ; n2 = 2.0, . double ; n3 = 0.0, . double ; n4 = 0.0, . double ; n5 = 0.0, . double ; n6 = 0.0, . unsigned int ; npoints = 50 . ). Create and draw a TH2 with the error contours in the parameters var1 and var2. ; Parameters. [in]var1The first parameter (x axis). ; [in]var2The second parameter (y axis). ; [in]n1First contour. ; [in]n2Optional contour. 0 means don't draw. ; [in]n3Optional contour. 0 means don't draw. ; [in]n4Optional contour. 0 means don't draw. ; [in]n5Optional contour. 0 means don't draw. ; [in]n6Optional contour. 0 means don't draw. ; [in]npointsNumber of points for evaluating the contour. Up to six contours can be drawn using the arguments n1 to n6 to request the desired coverage in units of \( \sigma = n^2 \cdot \mathrm{ErrorDef} \",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMinimizer.html:18603,clear,clearStatusHistory,18603,doc/master/classRooMinimizer.html,https://root.cern,https://root.cern/doc/master/classRooMinimizer.html,1,['clear'],['clearStatusHistory']
Usability,"zmax . ). inline . add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and [zmin,zmax] for the third coordinate ; Definition at line 173 of file DataRange.h. ◆ AddRange() [4/4]. void ROOT::Fit::DataRange::AddRange ; (; unsigned int ; icoord, . double ; xmin, . double ; xmax . ). add a range [xmin,xmax] for the new coordinate icoord Adding a range does not delete existing one, but takes the OR with existing ranges. ; if want to replace range use method SetRange, which replace range with existing one ; Definition at line 94 of file DataRange.cxx. ◆ CleanRangeSet(). void ROOT::Fit::DataRange::CleanRangeSet ; (; unsigned int ; icoord, . double ; xmin, . double ; xmax . ). protected . internal function to remove all the existing ranges between xmin and xmax called when a new range is inserted ; Definition at line 165 of file DataRange.cxx. ◆ Clear(). void ROOT::Fit::DataRange::Clear ; (; unsigned int ; icoord = 0). clear all ranges in one coordinate (is now -inf, +inf) ; Definition at line 158 of file DataRange.cxx. ◆ GetInfRange(). void ROOT::Fit::DataRange::GetInfRange ; (; double & ; x1, . double & ; x2 . ). staticprotected . Definition at line 182 of file DataRange.cxx. ◆ GetRange() [1/6]. void ROOT::Fit::DataRange::GetRange ; (; double & ; xmin, . double & ; xmax, . double & ; ymin, . double & ; ymax, . double & ; zmin, . double & ; zmax, . unsigned int ; irange = 0 . ); const. inline . get range for the x and y and z coordinates ; Definition at line 135 of file DataRange.h. ◆ GetRange() [2/6]. void ROOT::Fit::DataRange::GetRange ; (; double & ; xmin, . double & ; xmax, . double & ; ymin, . double & ; ymax, . unsigned int ; irange = 0 . ); const. inline . get range for the x and y coordinates ; Definition at line 129 of file DataRange.h. ◆ GetRange() [3/6]. void ROOT::Fit::DataRange::GetRange ; (; double & ; xmin, . double & ; xmax, . unsigned int ; irange = 0 . ); const. inline . get first range for the x - coordinate ; Definition at line",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1DataRange.html:7876,clear,clear,7876,doc/master/classROOT_1_1Fit_1_1DataRange.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1DataRange.html,1,['clear'],['clear']
Usability,"{ kUseBoundingBox; kUseVoxels; kUseGsord; };; enum TGeoAtt::EGeoSavePrimitiveAtt { kSavePrimitiveAtt; kSaveNodesAtt; };. protected:. TObject*fField! just a hook for now; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TGeoPatternFinder*fFinderfinder object for divisions; UInt_tTGeoAtt::fGeoAttoption flags; TGeoManager*fGeoManager! pointer to TGeoManager owning this volume; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TGeoMedium*fMediumtracking medium; TStringTNamed::fNameobject identifier; TObjArray*fNodesarray of nodes inside this volume; Int_tfNtotaltotal number of physical nodes; Int_tfNumbervolume serial number in the list of volumes; TStringfOption! option - if any; TGeoShape*fShapeshape; TStringTNamed::fTitleobject title; TGeoVoxelFinder*fVoxelsfinder object for bounding boxes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const. TGeoVolume(); dummy constructor. TGeoVolume(const char* name, const TGeoShape* shape, const TGeoMedium* med = 0); default constructor. TGeoVolume(const TGeoVolume& ); copy constructor. TGeoVolume& operator=(const TGeoVolume& ); assignment operator. ~TGeoVolume(); Destructor. void Browse(TBrowser* b); How to browse a volume. Double_t Capacity() const; Computes the capacity of this [cm^3] as the capacity of its shape.; In case of assemblies, the capacity is computed as the sum of daughter's capacities. void CheckGeometry(Int_t nrays = 1, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0) const; Shoot nrays with random directions from starting point (startx, starty, startz); in the reference frame of this volume. Track each ray until exiting geometry, then; shoot backwards from exiting point and compare boundary crossing points. void CheckOverlaps(Double_t ovlp = 0.1, Option_t* option = """") const; Overlap checking tool. Check for illegal overlaps wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoVolume.html:21615,Clear,ClearThreadData,21615,root/html532/TGeoVolume.html,https://root.cern,https://root.cern/root/html532/TGeoVolume.html,1,['Clear'],['ClearThreadData']
Usability,"{; 28 ; 29/// Helper types to present an offset column as array of collection sizes.; 30/// See RField<RNTupleCardinality<SizeT>> for details.; 31template <typename SizeT>; 32struct RNTupleCardinality {; 33 static_assert(std::is_same_v<SizeT, std::uint32_t> || std::is_same_v<SizeT, std::uint64_t>,; 34 ""RNTupleCardinality is only supported with std::uint32_t or std::uint64_t template parameters"");; 35 ; 36 using ValueType = SizeT;; 37 ; 38 RNTupleCardinality() : fValue(0) {}; 39 explicit constexpr RNTupleCardinality(ValueType value) : fValue(value) {}; 40 RNTupleCardinality &operator=(const ValueType value); 41 {; 42 fValue = value;; 43 return *this;; 44 }; 45 operator ValueType() const { return fValue; }; 46 ; 47 ValueType fValue;; 48};; 49 ; 50namespace Experimental {; 51 ; 52class RLogChannel;; 53/// Log channel for RNTuple diagnostics.; 54RLogChannel &NTupleLog();; 55 ; 56// clang-format off; 57/**; 58\class ROOT::Experimental::EColumnType; 59\ingroup NTuple; 60\brief The available trivial, native content types of a column; 61 ; 62More complex types, such as classes, get translated into columns of such simple types by the RField.; 63When changed, remember to update; 64 - RColumnElement::Generate(); 65 - RColumnElement::GetTypeName(); 66 - RColumnElement::GetValidBitRange(); 67 - RColumnElement template specializations / packing & unpacking; 68 - If necessary, endianess handling for the packing + unit test in ntuple_endian; 69 - RNTupleSerializer::[Des|S]erializeColumnType; 70*/; 71// clang-format on; 72enum class EColumnType {; 73 kUnknown = 0,; 74 // type for root columns of (nested) collections; offsets are relative to the current cluster; 75 kIndex64,; 76 kIndex32,; 77 // 96 bit column that is a pair of a kIndex64 and a 32bit dispatch tag to a column ID;; 78 // used to serialize std::variant.; 79 kSwitch,; 80 kByte,; 81 kChar,; 82 kBit,; 83 kReal64,; 84 kReal32,; 85 kReal16,; 86 kInt64,; 87 kUInt64,; 88 kInt32,; 89 kUInt32,; 90 kInt16,; 91 kUInt16,; 92 kInt8,;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleUtil_8hxx_source.html:2208,simpl,simple,2208,doc/master/RNTupleUtil_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleUtil_8hxx_source.html,1,['simpl'],['simple']
Usability,"{; 928 case 0: //No pointer && No array; 929 dictStream << "" "" << stlType.c_str() << "" &R__stl = "" << stlName.c_str() << "";"" << std::endl;; 930 break;; 931 case 1: //No pointer && array; 932 dictStream << "" "" << stlType.c_str() << "" &R__stl = "" << stlName.c_str() << ""[R__l];"" << std::endl;; 933 break;; 934 case 2: //pointer && No array; 935 dictStream << "" delete *"" << stlName.c_str() << "";"" << std::endl; 936 << "" *"" << stlName.c_str() << "" = new "" << stlType.c_str() << "";"" << std::endl; 937 << "" "" << stlType.c_str() << "" &R__stl = **"" << stlName.c_str() << "";"" << std::endl;; 938 break;; 939 case 3: //pointer && array; 940 dictStream << "" delete "" << stlName.c_str() << ""[R__l];"" << std::endl; 941 << "" "" << stlName.c_str() << ""[R__l] = new "" << stlType.c_str() << "";"" << std::endl; 942 << "" "" << stlType.c_str() << "" &R__stl = *"" << stlName.c_str() << ""[R__l];"" << std::endl;; 943 break;; 944 }; 945 ; 946 dictStream << "" R__stl.clear();"" << std::endl;; 947 ; 948 if (tcl1) {; 949 dictStream << "" TClass *R__tcl1 = TBuffer::GetClass(typeid("" << fulName1.c_str() << ""));"" << std::endl; 950 << "" if (R__tcl1==0) {"" << std::endl; 951 << "" Error(\"""" << stlName.c_str() << "" streamer\"",\""Missing the TClass object for ""; 952 << fulName1.c_str() << ""!\"");"" << std::endl; 953 << "" return;"" << std::endl; 954 << "" }"" << std::endl;; 955 }; 956 if (tcl2) {; 957 dictStream << "" TClass *R__tcl2 = TBuffer::GetClass(typeid("" << fulName2.c_str() << ""));"" << std::endl; 958 << "" if (R__tcl2==0) {"" << std::endl; 959 << "" Error(\"""" << stlName.c_str() << "" streamer\"",\""Missing the TClass object for ""; 960 << fulName2.c_str() << ""!\"");"" << std::endl; 961 << "" return;"" << std::endl; 962 << "" }"" << std::endl;; 963 }; 964 ; 965 dictStream << "" int R__i, R__n;"" << std::endl; 966 << "" R__b >> R__n;"" << std::endl;; 967 ; 968 if (stltype == kSTLvector) {; 969 dictStream << "" R__stl.reserve(R__n);"" << std::endl;; 970 }; 971 dictStream << "" for (R__i = 0; R__i < R__n; R__i++) {"" << std::endl;; 972 ; 973 ROOT:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:33516,clear,clear,33516,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['clear'],['clear']
Usability,"| ""SCAT"" | Draw a scatter plot (legacy draw option).|; 2339| ""COL"" | Draw a color plot. All the bins are painted even the empty bins (default).|; 2340| ""COLZ"" | Same as ""COL"". In addition the color palette is also drawn.|; 2341| ""0"" | When used with any COL options, the empty bins are not drawn.|; 2342| ""TEXT"" | Draw bin contents as text (format set via `gStyle->SetPaintTextFormat`).|; 2343| ""TEXTN"" | Draw bin names as text.|; 2344| ""TEXTnn"" | Draw bin contents as text at angle nn (0 < nn <= 90).|; 2345| ""L"" | Draw the bins boundaries as lines. The lines attributes are the TGraphs ones.|; 2346| ""P"" | Draw the bins boundaries as markers. The markers attributes are the TGraphs ones.|; 2347| ""F"" | Draw the bins boundaries as filled polygons. The filled polygons attributes are the TGraphs ones.|; 2348 ; 2349 ; 2350 ; 2351`TH2Poly` can be drawn as a color plot (option COL). `TH2Poly` bins can have any; 2352shapes. The bins are defined as graphs. The following macro is a very simple; 2353example showing how to book a TH2Poly and draw it.; 2354 ; 2355Begin_Macro(source); 2356{; 2357 auto ch2p1 = new TCanvas(""ch2p1"",""ch2p1"",600,400);; 2358 auto h2p = new TH2Poly();; 2359 h2p->SetName(""h2poly_name"");; 2360 h2p->SetTitle(""h2poly_title"");; 2361 double px1[] = {0, 5, 6};; 2362 double py1[] = {0, 0, 5};; 2363 double px2[] = {0, -1, -1, 0};; 2364 double py2[] = {0, 0, -1, 3};; 2365 double px3[] = {4, 3, 0, 1, 2.4};; 2366 double py3[] = {4, 3.7, 1, 3.7, 2.5};; 2367 h2p->AddBin(3, px1, py1);; 2368 h2p->AddBin(4, px2, py2);; 2369 h2p->AddBin(5, px3, py3);; 2370 h2p->Fill(0.1, 0.01, 3);; 2371 h2p->Fill(-0.5, -0.5, 7);; 2372 h2p->Fill(-0.7, -0.5, 1);; 2373 h2p->Fill(1, 3, 1.5);; 2374 double fx[] = {0.1, -0.5, -0.7, 1};; 2375 double fy[] = {0.01, -0.5, -0.5, 3};; 2376 double fw[] = {3, 1, 1, 1.5};; 2377 h2p->FillN(4, fx, fy, fw);; 2378 h2p->Draw(""col"");; 2379}; 2380End_Macro; 2381 ; 2382Rectangular bins are a frequent case. The special version of; 2383the `AddBin` method allows to defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:96231,simpl,simple,96231,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['simpl'],['simple']
Usability,"|; List of all members ; ROOT::TExecutorCRTP< SubC > Class Template Reference. ; template<class SubC>; class ROOT::TExecutorCRTP< SubC >This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. . ROOT::TExecutorCRTP<SubC>::Map; The two possible usages of the Map method are:. Map(F func, unsigned nTimes): func is executed nTimes with no arguments; Map(F func, T& args): func is executed on each element of the collection of arguments args. The Map function forwards the call to MapImpl, to be implemented by the child classes.; For either signature, func is executed as many times as needed by a pool of n workers, where n typically defaults to the number of available cores.; A collection containing the result of each execution is returned.; Note: the user is responsible for the deletion of any object that might be created upon execution of func, returned objects included. ROOT::TExecutorCRTP derived classes never delete what they return, they simply forget it.; Parameters. funca callable object, such as a lambda expression, an std::function, a functor object or a function that takes zero arguments (for the first signature) or one (for the second signature). ; argsa standard vector, a ROOT::TSeq of integer type or an initializer list for the second signature. An integer only for the first. Note: in cases where the function to be executed takes more than zero/one argument but all are fixed except zero/one, the function can be wrapped in a lambda or via std::bind to give it the right signature.; Return value:; An std::vector. The elements in the container will be the objects returned by func. The ordering of the elements corresponds to the ordering of the arguments. ROOT::TExecutorCRTP<SubC>::Reduce; These set of methods combine all elements from a std::vector into a single value. Parameters. redfunca callable object, such as a lambda expression, an std::function, a functor object or a function that",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TExecutorCRTP.html:1264,simpl,simply,1264,doc/v632/classROOT_1_1TExecutorCRTP.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TExecutorCRTP.html,2,['simpl'],['simply']
Usability,"} EVENTN;; static POINT point;; static EVENTN eventn;. // Create a ROOT Tree; TTree *tree = new TTree(""T"",""An example of ROOT tree with a few branches"");; tree->Branch(""point"",&point,""x:y:z"");; tree->Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree->Branch(""hpx"",""TH1F"",&hpx,128000,0);. Float_t px,py,pz;; static Float_t p[3];. //--------------------Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->::Rndm(1);. // Fill histograms; hpx->Fill(px);; hpxpy->Fill(px,py,1);; hprof->Fill(px,pz,1);. // Fill structures; p[0] = px;; p[1] = py;; p[2] = pz;; point.x = 10*(random-1);;; point.y = 5*random;; point.z = 20*random;; eventn.ntrack = Int_t(100*random);; eventn.nseg = Int_t(2*eventn.ntrack);; eventn.nvertex = 1;; eventn.flag = Int_t(random+0.5);; eventn.temperature = 20+random;. // Fill the tree. For each event, save the 2 structures and 3 objects; // In this simple example, the objects hpx, hprof and hpxpy are slightly; // different from event to event. We expect a big compression factor!; tree->Fill();; }; //--------------End of the loop. tree->Print();. // Save all objects in this file; hfile.Write();. // Close the file. Note that this is automatically done when you leave; // the application.; hfile.Close();. return 0;; }. Function Members (Methods); public:. TTree(); TTree(const char* name, const char* title, Int_t splitlevel = 99); virtual~TTree(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidAddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*AddFriend(const char* treename, TFile* file); virtual TFriendElement*AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidAddTotBytes(Int_t tot); virtual voidAddZipByte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:10804,simpl,simple,10804,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,6,['simpl'],['simple']
Usability,"} EVENTN;; static POINT point;; static EVENTN eventn;. // Create a ROOT Tree; TTree *tree = new TTree(""T"",""An example of ROOT tree with a few branches"");; tree->Branch(""point"",&point,""x:y:z"");; tree->Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree->Branch(""hpx"",""TH1F"",&hpx,128000,0);. Float_t px,py,pz;; static Float_t p[3];. //--------------------Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->::Rndm(1);. // Fill histograms; hpx->Fill(px);; hpxpy->Fill(px,py,1);; hprof->Fill(px,pz,1);. // Fill structures; p[0] = px;; p[1] = py;; p[2] = pz;; point.x = 10*(random-1);;; point.y = 5*random;; point.z = 20*random;; eventn.ntrack = Int_t(100*random);; eventn.nseg = Int_t(2*eventn.ntrack);; eventn.nvertex = 1;; eventn.flag = Int_t(random+0.5);; eventn.temperature = 20+random;. // Fill the tree. For each event, save the 2 structures and 3 objects; // In this simple example, the objects hpx, hprof and hpxpy are slightly; // different from event to event. We expect a big compression factor!; tree->Fill();; }; //--------------End of the loop. tree->Print();. // Save all objects in this file; hfile.Write();. // Close the file. Note that this is automatically done when you leave; // the application.; hfile.Close();. return 0;; }. Function Members (Methods); public:. TTreePlayer(); virtual~TTreePlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual TVirtualIndex*BuildIndex(const TTree* T, const char* majorname, const char* minorname); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:6736,simpl,simple,6736,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,1,['simpl'],['simple']
Usability,"} EVENTN;; static POINT point;; static EVENTN eventn;. // Create a ROOT Tree; TTree *tree = new TTree(""T"",""An example of ROOT tree with a few branches"");; tree->Branch(""point"",&point,""x:y:z"");; tree->Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree->Branch(""hpx"",""TH1F"",&hpx,128000,0);. Float_t px,py,pz;; static Float_t p[3];. //--------------------Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->::Rndm(1);. // Fill histograms; hpx->Fill(px);; hpxpy->Fill(px,py,1);; hprof->Fill(px,pz,1);. // Fill structures; p[0] = px;; p[1] = py;; p[2] = pz;; point.x = 10*(random-1);;; point.y = 5*random;; point.z = 20*random;; eventn.ntrack = Int_t(100*random);; eventn.nseg = Int_t(2*eventn.ntrack);; eventn.nvertex = 1;; eventn.flag = Int_t(random+0.5);; eventn.temperature = 20+random;. // Fill the tree. For each event, save the 2 structures and 3 objects; // In this simple example, the objects hpx, hprof and hpxpy are slightly; // different from event to event. We expect a big compression factor!; tree->Fill();; }; //--------------End of the loop. tree->Print();. // Save all objects in this file; hfile.Write();. // Close the file. Note that this is automatically done when you leave; // the application.; hfile.Close();. return 0;; }. Function Members (Methods); public:. virtual~TTree(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tAddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*AddFriend(const char* treename, TFile* file); virtual TFriendElement*AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidAddTotBytes(Int_t tot); virtual voidAddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:11523,simpl,simple,11523,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,2,['simpl'],['simple']
Usability,"} EVENTN;; static POINT point;; static EVENTN eventn;. // Create a ROOT Tree; TTree *tree = new TTree(""T"",""An example of ROOT tree with a few branches"");; tree->Branch(""point"",&point,""x:y:z"");; tree->Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree->Branch(""hpx"",""TH1F"",&hpx,128000,0);. Float_t px,py,pz;; static Float_t p[3];. //--------------------Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->::Rndm(1);. // Fill histograms; hpx->Fill(px);; hpxpy->Fill(px,py,1);; hprof->Fill(px,pz,1);. // Fill structures; p[0] = px;; p[1] = py;; p[2] = pz;; point.x = 10*(random-1);;; point.y = 5*random;; point.z = 20*random;; eventn.ntrack = Int_t(100*random);; eventn.nseg = Int_t(2*eventn.ntrack);; eventn.nvertex = 1;; eventn.flag = Int_t(random+0.5);; eventn.temperature = 20+random;. // Fill the tree. For each event, save the 2 structures and 3 objects; // In this simple example, the objects hpx, hprof and hpxpy are slightly; // different from event to event. We expect a big compression factor!; tree->Fill();; }; //--------------End of the loop. tree->Print();. // Save all objects in this file; hfile.Write();. // Close the file. Note that this is automatically done when you leave; // the application.; hfile.Close();. return 0;; }. Function Members (Methods); public:. virtual~TTree(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidAddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*AddFriend(const char* treename, TFile* file); virtual TFriendElement*AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidAddTotBytes(Int_t tot); virtual voidAddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTree.html:11547,simpl,simple,11547,root/html602/TTree.html,https://root.cern,https://root.cern/root/html602/TTree.html,2,['simpl'],['simple']
Usability,"}; 415 ; 416//_________________________________________________________________________________________________; 417template <typename Architecture_t>; 418auto VGeneralLayer<Architecture_t>::UpdateWeights(const std::vector<Matrix_t> &weightGradients,; 419 const Scalar_t learningRate) -> void; 420{; 421 for (size_t i = 0; i < fWeights.size(); i++) {; 422 Architecture_t::ScaleAdd(fWeights[i], weightGradients[i], -learningRate);; 423 }; 424}; 425 ; 426//_________________________________________________________________________________________________; 427template <typename Architecture_t>; 428auto VGeneralLayer<Architecture_t>::UpdateBiases(const std::vector<Matrix_t> &biasGradients,; 429 const Scalar_t learningRate) -> void; 430{; 431 for (size_t i = 0; i < fBiases.size(); i++) {; 432 Architecture_t::ScaleAdd(fBiases[i], biasGradients[i], -learningRate);; 433 }; 434}; 435 ; 436//_________________________________________________________________________________________________; 437template <typename Architecture_t>; 438auto VGeneralLayer<Architecture_t>::UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients,; 439 const Scalar_t learningRate) -> void; 440{; 441 for (size_t i = 0; i < fWeightGradients.size(); i++) {; 442 Architecture_t::ScaleAdd(fWeightGradients[i], weightGradients[i], -learningRate);; 443 }; 444}; 445 ; 446//_________________________________________________________________________________________________; 447template <typename Architecture_t>; 448auto VGeneralLayer<Architecture_t>::UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients,; 449 const Scalar_t learningRate) -> void; 450{; 451 for (size_t i = 0; i < fBiasGradients.size(); i++) {; 452 Architecture_t::ScaleAdd(fBiasGradients[i], biasGradients[i], -learningRate);; 453 }; 454}; 455 ; 456//_________________________________________________________________________________________________; 457template <typename Architecture_t>; 458auto VGeneralLayer<Architecture_t>::CopyWeights(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GeneralLayer_8h_source.html:19753,learn,learningRate,19753,doc/master/GeneralLayer_8h_source.html,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html,2,['learn'],['learningRate']
Usability,"}; 748 }; 749 ; 750 // use copy-constructor of TMethodCall; 751 // if c++-14 could use std::make_unique; 752 TMethodCall *m = (fMethod) ? new TMethodCall(*fMethod) : nullptr;; 753 fnew.fMethod.reset(m);; 754 ; 755 fnew.fFuncPtr = fFuncPtr;; 756 fnew.fGradGenerationInput = fGradGenerationInput;; 757 fnew.fHessGenerationInput = fHessGenerationInput;; 758 fnew.fGradFuncPtr = fGradFuncPtr;; 759 fnew.fHessFuncPtr = fHessFuncPtr;; 760 ; 761}; 762 ; 763////////////////////////////////////////////////////////////////////////////////; 764/// Clear the formula setting expression to empty and reset the variables and; 765/// parameters containers.; 766 ; 767void TFormula::Clear(Option_t * ); 768{; 769 fNdim = 0;; 770 fNpar = 0;; 771 fNumber = 0;; 772 fFormula = """";; 773 fClingName = """";; 774 ; 775 fMethod.reset();; 776 ; 777 fClingVariables.clear();; 778 fClingParameters.clear();; 779 fReadyToExecute = false;; 780 fClingInitialized = false;; 781 fAllParametersSetted = false;; 782 fFuncs.clear();; 783 fVars.clear();; 784 fParams.clear();; 785 fConsts.clear();; 786 fFunctionsShortcuts.clear();; 787 ; 788 // delete linear parts; 789 int nLinParts = fLinearParts.size();; 790 if (nLinParts > 0) {; 791 for (int i = 0; i < nLinParts; ++i) delete fLinearParts[i];; 792 }; 793 fLinearParts.clear();; 794 ; 795}; 796 ; 797// Returns nullptr on failure.; 798static std::unique_ptr<TMethodCall>; 799prepareMethod(bool HasParameters, bool HasVariables, const char* FuncName,; 800 bool IsVectorized, bool AddCladArrayRef = false) {; 801 std::unique_ptr<TMethodCall>; 802 Method = std::make_unique<TMethodCall>();; 803 ; 804 TString prototypeArguments = """";; 805 if (HasVariables || HasParameters) {; 806 if (IsVectorized); 807 prototypeArguments.Append(""ROOT::Double_v*"");; 808 else; 809 prototypeArguments.Append(""Double_t*"");; 810 }; 811 auto AddDoublePtrParam = [&prototypeArguments]() {; 812 prototypeArguments.Append("","");; 813 prototypeArguments.Append(""Double_t*"");; 814 };; 815 if (HasParameters); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:28517,clear,clear,28517,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['clear'],['clear']
Usability,"~RooAbsArg(); Destructor. void setDirtyInhibit(Bool_t flag); Control global dirty inhibit mode. When set to true no value or shape dirty; flags are propagated and cache is always considered to be dirty. void verboseDirty(Bool_t flag); Activate verbose messaging related to dirty flag propagation. Bool_t isCloneOf(const RooAbsArg& other) const; Check if this object was created as a clone of 'other'. void setAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes are unset. void setStringAttribute(const Text_t* key, const Text_t* value); Associate string 'value' to this object under key 'key'. const Text_t* getStringAttribute(const Text_t* key) const; Get string attribute mapped under key 'key'. Returns null pointer; if no attribute exists under that key. void setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getTransientAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes; are unset. void addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Register another RooAbsArg as a server to us, ie, declare that; we depend on it. In addition to the basic client-server relationship,; we can declare dependence on the server's value and/or shape. void addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Register a list of RooAbsArg as servers to us by calls; addServer() for each arg in the list. void removeServer(RooAbsArg& server, Bool_t force = kFALSE); Unregister another RooAbsArg as a server to us, ie, declare that; we no longer depend on its value and shape. void replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); Replace 'oldServer' with 'newServer'. void change",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsArg.html:19076,clear,clear,19076,root/html532/RooAbsArg.html,https://root.cern,https://root.cern/root/html532/RooAbsArg.html,7,['clear'],['clear']
Usability,"~TGWidget(); virtual voidAssociate(const TGWindow* w); static TClass*Class(); const char*GetCommand() const; Bool_tHasFocus() const; virtual TClass*IsA() const; Bool_tIsEnabled() const; virtual voidSetCommand(const char* command); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Bool_tWantFocus() const; Int_tWidgetId() const. protected:. TGWidget(const TGWidget& tgw); Int_tClearFlags(Int_t flags); TGWidget&operator=(const TGWidget& tgw); Int_tSetFlags(Int_t flags). Data Members; protected:. TStringfCommandcommand to be executed; const TGWindow*fMsgWindowwindow which handles widget events; Int_tfWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tfWidgetIdthe widget id (used for event processing). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGWidget(const TGWidget& tgw); { }. TGWidget& operator=(const TGWidget& tgw). Int_t SetFlags(Int_t flags); { return fWidgetFlags |= flags; }. Int_t ClearFlags(Int_t flags); { return fWidgetFlags &= ~flags; }. TGWidget(); { }. TGWidget(Int_t id); { }. virtual ~TGWidget(); { }. Int_t WidgetId() const; { return fWidgetId; }. Bool_t IsEnabled() const; { return (Bool_t)((fWidgetFlags & kWidgetIsEnabled) != 0); }. Bool_t HasFocus() const; { return (Bool_t)((fWidgetFlags & kWidgetHasFocus) != 0); }. Bool_t WantFocus() const; { return (Bool_t)((fWidgetFlags & kWidgetWantFocus) != 0); }. void Associate(const TGWindow* w); { fMsgWindow = w; }. void SetCommand(const char* command); { fCommand = command; }. const char * GetCommand() const; { return fCommand.Data(); }. » Author: Fons Rademakers 05/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGWidget.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGWidget.html:1537,Clear,ClearFlags,1537,root/html532/TGWidget.html,https://root.cern,https://root.cern/root/html532/TGWidget.html,1,['Clear'],['ClearFlags']
Usability,  TMVA Classification Example Using a Convolutional Neural Network ;  ;  TMVA_CNN_Classification.py;   TMVA Classification Example Using a Convolutional Neural Network ;  ;  TMVA_Higgs_Classification.C;   Classification example of TMVA based on public Higgs UCI dataset ;  ;  TMVA_Higgs_Classification.py;   Classification example of TMVA based on public Higgs UCI dataset ;  ;  TMVA_RNN_Classification.C;   TMVA Classification Example Using a Recurrent Neural Network ;  ;  TMVA_RNN_Classification.py;   TMVA Classification Example Using a Recurrent Neural Network ;  ;  TMVA_SOFIE_GNN.py;  ;  TMVA_SOFIE_GNN_Application.C;  ;  TMVA_SOFIE_GNN_Parser.py;  ;  TMVA_SOFIE_Inference.py;   This macro provides an example of using a trained model with Keras and make inference using SOFIE directly from Numpy This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ;  ;  TMVA_SOFIE_Keras.C;   This macro provides a simple example for the parsing of Keras .h5 file into RModel object and further generating the .hxx header files for inference. ;  ;  TMVA_SOFIE_Keras_HiggsModel.C;   This macro run the SOFIE parser on the Keras model obtaining running TMVA_Higgs_Classification.C You need to run that macro before this one ;  ;  TMVA_SOFIE_Models.py;   Example of inference with SOFIE using a set of models trained with Keras. ;  ;  TMVA_SOFIE_ONNX.C;   This macro provides a simple example for the parsing of ONNX files into RModel object and further generating the .hxx header files for inference. ;  ;  TMVA_SOFIE_PyTorch.C;   This macro provides a simple example for the parsing of PyTorch .pt file into RModel object and further generating the .hxx header files for inference. ;  ;  TMVA_SOFIE_RDataFrame.C;   This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:3035,simpl,simple,3035,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,1,['simpl'],['simple']
Usability," . Protected Types; typedef void *(* ArrIterfunc_t) (void *from, size_t size);  ; typedef void *(* Collectfunc_t) (void *from, void *to);  ; typedef ROOT::Detail::TCollectionProxyInfo::Environ< char[64]> Env_t;  ; typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  . Protected Member Functions; void CheckFunctions () const;  Check existence of function pointers. ;  ; virtual void DeleteItem (Bool_t force, void *ptr) const;  Call to delete/destruct individual item. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  . Protected Attributes; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:9978,clear,clear,9978,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['clear'],['clear']
Usability," ; Bool_t HandleTimer (TTimer *t) override;  Handle cursor blink timer. ;  ; Bool_t HasMarkedText () const;  ; Bool_t HasOwnFont () const;  ; void Home (Bool_t mark=kFALSE);  Moves the text cursor to the left end of the line. ;  ; virtual void Insert (const char *);  Removes any currently selected text, inserts newText, sets it as the new contents of the text entry. ;  ; virtual void InsertText (const char *text, Int_t pos);  Inserts text at position pos, clears the selection and moves the cursor to the end of the line. ;  ; TClass * IsA () const override;  ; Bool_t IsEdited () const;  ; Bool_t IsFrameDrawn () const;  ; void Layout () override;  ; void MarkWord (Int_t pos);  Marks the word nearest to cursor position. ;  ; Int_t MaxMark () const;  ; Int_t MinMark () const;  ; void NewMark (Int_t pos);  New character mark at position pos. ;  ; void Remove ();  Deletes all characters on the right side of the cursor. ;  ; virtual void RemoveText (Int_t start, Int_t end);  Removes text at the range, clears the selection and moves the cursor to the end of the line. ;  ; virtual void ReturnPressed ();  This signal is emitted when the return or enter key is pressed. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a text entry widget as a C++ statement(s) on output stream out. ;  ; virtual void SelectAll ();  Selects all text (i.e. ;  ; virtual void SetAlignment (ETextJustification mode=kTextLeft);  Sets the alignment of the text entry. ;  ; virtual void SetCursorPosition (Int_t pos);  Set the cursor position to newPos. ;  ; virtual void SetDefaultSize (UInt_t w, UInt_t h);  Set the default / minimal size of the widget. ;  ; virtual void SetEchoMode (EEchoMode mode=kNormal);  The echo modes available are: ;  ; void SetEdited (Bool_t flag=kTRUE);  ; void SetEnabled (Bool_t flag=kTRUE);  ; virtual void SetFocus ();  Set focus to this text entry. ;  ; virtual void SetFont (const char *fontName, Bool_t local=kTRUE);  Changes text font specified by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEntry.html:10612,clear,clears,10612,doc/master/classTGTextEntry.html,https://root.cern,https://root.cern/doc/master/classTGTextEntry.html,1,['clear'],['clears']
Usability," ; Bool_t HandleTimer (TTimer *t) override;  Handle cursor blink timer. ;  ; Bool_t HasMarkedText () const;  ; Bool_t HasOwnFont () const;  ; void Home (Bool_t mark=kFALSE);  Moves the text cursor to the left end of the line. ;  ; virtual void Insert (const char *);  Removes any currently selected text, inserts newText, sets it as the new contents of the text entry. ;  ; virtual void InsertText (const char *text, Int_t pos);  Inserts text at position pos, clears the selection and moves the cursor to the end of the line. ;  ; TClass * IsA () const override;  ; Bool_t IsEdited () const;  ; Bool_t IsFrameDrawn () const;  ; void Layout () override;  ; void MarkWord (Int_t pos);  Marks the word nearest to cursor position. ;  ; Int_t MaxMark () const;  ; Int_t MinMark () const;  ; void NewMark (Int_t pos);  New character mark at position pos. ;  ; void Remove ();  Deletes all characters on the right side of the cursor. ;  ; virtual void RemoveText (Int_t start, Int_t end);  Removes text at the range, clears the selection and moves the cursor to the end of the line. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a text entry widget as a C++ statement(s) on output stream out. ;  ; virtual void SelectAll ();  Selects all text (i.e. ;  ; virtual void SetAlignment (ETextJustification mode=kTextLeft);  Sets the alignment of the text entry. ;  ; virtual void SetCursorPosition (Int_t pos);  Set the cursor position to newPos. ;  ; virtual void SetDefaultSize (UInt_t w, UInt_t h);  Set the default / minimal size of the widget. ;  ; virtual void SetEchoMode (EEchoMode mode=kNormal);  The echo modes available are: ;  ; void SetEdited (Bool_t flag=kTRUE);  ; void SetEnabled (Bool_t flag=kTRUE);  ; virtual void SetFocus ();  Set focus to this text entry. ;  ; virtual void SetFont (const char *fontName, Bool_t local=kTRUE);  Changes text font specified by name. ;  ; virtual void SetFont (FontStruct_t font, Bool_t local=kTRUE);  Changes text font. ;  ; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGNumberEntryField.html:8809,clear,clears,8809,doc/master/classTGNumberEntryField.html,https://root.cern,https://root.cern/doc/master/classTGNumberEntryField.html,1,['clear'],['clears']
Usability," ; TObjArray * InputFiles () const;  ; TClass * IsA () const override;  ; virtual Bool_t IsCmdThread ();  ; Bool_t IsRunning () const;  ; virtual void KeyPressed (Int_t key);  Emit signal when console keyboard key was pressed. ;  ; virtual void LineProcessed (const char *line);  Emit signal when a line has been processed. ;  ; virtual void Lower ();  ; void ls (Option_t *option="""") const override;  Show available sessions. ;  ; Bool_t NoLogoOpt () const;  ; Bool_t NoLogOpt () const;  ; virtual void Open ();  ; void OpenForumTopic (const TString &type);  It opens a Forum topic in a web browser with prefilled ROOT version. ;  ; void OpenGitHubIssue (const TString &type);  It opens a GitHub issue in a web browser with prefilled ROOT version. ;  ; void OpenInBrowser (const TString &url);  The function generates and executes a command that loads the Doxygen URL in a browser. ;  ; void OpenReferenceGuideFor (const TString &strippedClass);  It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator. ;  ; virtual Longptr_t ProcessFile (const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE);  Process a file containing a C++ macro. ;  ; virtual Longptr_t ProcessLine (const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr);  Process a single command line, either a C++ statement or an interpreter command starting with a ""."". ;  ; Bool_t QuitOpt () const;  ; virtual void Raise ();  ; virtual void RemoveIdleTimer ();  Remove idle timer. Normally called via TROOT::Idle(0). ;  ; Bool_t ReturnFromRun () const;  ; virtual void ReturnPressed (char *text);  Emit signal when return key was pressed. ;  ; virtual void Run (Bool_t retrn=kFALSE);  Main application eventloop. Calls system dependent eventloop via gSystem. ;  ; virtual void SetEchoMode (Bool_t mode);  Set console echo mode: ;  ; virtual void SetIdleTimer (UInt_t idleTimeInSec, const char *command);  Set the c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplication.html:4065,guid,guide,4065,doc/master/classTApplication.html,https://root.cern,https://root.cern/doc/master/classTApplication.html,1,['guid'],['guide']
Usability," ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Static Public Member Functions inherited from RooProjectedPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classxRooProjectedPdf.html:66863,clear,clearEvalErrorLog,66863,doc/master/classxRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classxRooProjectedPdf.html,1,['clear'],['clearEvalErrorLog']
Usability," ; frame, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ); const. virtual . See alsoRooPlot* plotOn(RooPlot* frame, const RooLinkedList& cmdList) const. PyROOT; The RooAbsData::plotOn() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Reimplemented from RooAbsData.; Definition at line 169 of file RooAbsData.cxx. ◆ plotOn() [2/4]. RooPlot * RooAbsData::plotOn ; (; RooPlot * ; frame, . const RooLinkedList & ; argList . ); const. virtual . Plot dataset on specified frame. ; By default:; An unbinned dataset will use the default binning of the target frame.; A binned dataset will retain its intrinsic binning. The following optional named arguments can be used to modify the behaviour: NotePlease follow the function links in the left column to learn about PyROOT specifics for a given option. Data representation options . RooFit::Asymmetry(const RooCategory& c) Show the asymmetry of the data in given two-state category [F(+)-F(-)] / [F(+)+F(-)]. Category must have two states with indices -1 and +1 or three states with indices -1,0 and +1. . RooFit::Efficiency(const RooCategory& c) Show the efficiency F(acc)/[F(acc)+F(rej)]. Category must have two states with indices 0 and 1 . RooFit::DataError(Int_t) Select the type of error drawn:; Auto(default) results in Poisson for unweighted data and SumW2 for weighted data; Poisson draws asymmetric Poisson confidence intervals.; SumW2 draws symmetric sum-of-weights error ( \( \left( \sum w \right)^2 / \sum\left(w^2\right) \) ); None draws no error bars . RooFit::Binning(int nbins, double xlo, double xhi) Use specified binning to draw dataset . RooFit::Binning(const RooAbsBinning&) Use specified binning to draw dataset . RooFit::Binning(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:67669,learn,learn,67669,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['learn'],['learn']
Usability," ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; Int_t AssertSelector (const char *selector_file);  Make sure that a valid selector object Return -1 in case of problems, 0 otherwise. ;  ; Bool_t CheckMemUsage (Long64_t &mfreq, Bool_t &w80r, Bool_t &w80v, TString &wmsg);  Check the memory usage, if requested. ;  ; virtual Int_t DrawCanvas (TObject *obj);  Draw the object if it is a canvas. ;  ; void * GetSender () override;  ; void MapOutputListToDataMembers () const;  ; void MergeOutput (Bool_t savememvalues=kFALSE) override;  Merge output (may not be used in this class). ;  ; virtual void SetupFeedback ();  Set up feedback (may not be used in this class). ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual const char * GetSenderClassName () const;  . Protected Attributes; Bool_t fCreateSelObj;  the latest selector ;  ; TTimer * fDispatchTimer;  ; Int_t fDrawQueries;  ; TEventIter * fEvIter;  period (ms) for sending intermediate results ;  ; EExitStatus fExitStatus;  status of query in progress ;  ; Long_t fFeedbackPeriod;  timer for sending intermediate results ;  ; TTimer * fFeedbackTimer;  class of the latest selector ;  ; TList * fInput;  ; Int_t fMaxDrawQueries;  ; THashList * fOutput;  ; TFile * fOutputFile;  ; TString fOutputFilePath;  ; TQueryResult * fPreviousQuery;  ; Long64_t fProcessedRun;  Read calls in this run. ;  ; TStopwatch * fProcTime;  ; TTimer * fProcTi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:20931,feedback,feedback,20931,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['feedback'],['feedback']
Usability," ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  ;  Static Public Member Functions inherited from RooAbsLValue; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void syncCache (const RooArgSet *set=nullptr) override;  Force the internal value cache to be up to date. ;  ;  Protected Member Functions inherited from RooAbsRealLValue; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy cache of another RooAbsArg to our cache. ;  ; bool fitRangeOKForPlotting () const;  Check if fit range is usable as plot range, i.e. ;  ; virtual void setValFast (double value);  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooErrorVar.html:57723,usab,usable,57723,doc/master/classRooErrorVar.html,https://root.cern,https://root.cern/doc/master/classRooErrorVar.html,1,['usab'],['usable']
Usability," ; void SetMerging (Bool_t on=kTRUE) override;  Switch on/off merge timer. ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1) override;  Stop process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback results from the specified slave. ;  ; void StoreOutput (TList *out) override;  Store received output list. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayer;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:5340,feedback,feedback,5340,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,2,['feedback'],['feedback']
Usability," ; void setAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setDataToken (std::size_t index);  Sets the token for retrieving results in the BatchMode. For internal use only. ;  ; void setLocalNoDirtyInhibit (bool flag) const;  ; void SetName (const char *name) override;  Set the name of the TNamed. ;  ; void SetNameTitle (const char *name, const char *title) override;  Set all the TNamed parameters (name and title). ;  ; void setProhibitServerRedirect (bool flag);  ; void setStringAttribute (const Text_t *key, const Text_t *value);  Associate string 'value' to this object under key 'key'. ;  ; void setTransientAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setWorkspace (RooWorkspace &ws);  ; const std::map< std::string, std::string > & stringAttributes () const;  ; const std::set< std::string > & transientAttributes () const;  ; virtual void translate (RooFit::Detail::CodeSquashContext &ctx) const;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ; RooWorkspace * workspace () const;  ; TIterator * clientIterator () const R__DEPRECATED(6;  Retrieve a client iterator. ;  ; TIterator Use clients () and begin();  ; TIterator Use end () or range-based loops."") ;  ; TIterator * valueClientIterator () const R__DEPRECATED(6;  ; TIterator Use valueClients () and begin();  ; TIterator Use end () or range-based loops."") ;  ; TIterator * shapeClientIterator () const R__DEPRECATED(6;  ; TIterator Use shapeClients () and begin();  ; TIterator Use end () or range-based loops."") ;  ; TIterator * serverIterator () const R__DEPRECATED(6;  ; TIterator Use servers () and begin();  ; TIterator Use end () or range-based loops."") ;  ; RooFIter valueClientMIterator () const R__DEPRECATED(6;  ; RooFIter Use valueClients () and begin();  ; RooFIter Use end () o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:31415,simpl,simple,31415,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['simpl'],['simple']
Usability," ; void setAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setDataToken (std::size_t index);  Sets the token for retrieving results in the BatchMode. For internal use only. ;  ; void setLocalNoDirtyInhibit (bool flag) const;  ; void SetName (const char *name) override;  Set the name of the TNamed. ;  ; void SetNameTitle (const char *name, const char *title) override;  Set all the TNamed parameters (name and title). ;  ; void setProhibitServerRedirect (bool flag);  ; void setStringAttribute (const Text_t *key, const Text_t *value);  Associate string 'value' to this object under key 'key'. ;  ; void setTransientAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setWorkspace (RooWorkspace &ws);  ; const std::map< std::string, std::string > & stringAttributes () const;  ; const std::set< std::string > & transientAttributes () const;  ; virtual void translate (RooFit::Detail::CodeSquashContext &ctx) const;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ; RooWorkspace * workspace () const;  ; const RefCountList_t & clients () const;  List of all clients of this object. ;  ; const RefCountList_t & valueClients () const;  List of all value clients of this object. Value clients receive value updates. ;  ; const RefCountList_t & shapeClients () const;  List of all shape clients of this object. ;  ; const RefCountList_t & servers () const;  List of all servers of this object. ;  ; RooAbsArg * findServer (const char *name) const;  Return server of this with name name. Returns nullptr if not found. ;  ; RooAbsArg * findServer (const RooAbsArg &arg) const;  Return server of this that has the same name as arg. Returns nullptr if not found. ;  ; RooAbsArg * findServer (Int_t index) const;  Return i-th server from server list. ;  ; bool isValueServer (c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinWidthFunction.html:29105,simpl,simple,29105,doc/master/classRooBinWidthFunction.html,https://root.cern,https://root.cern/doc/master/classRooBinWidthFunction.html,112,['simpl'],['simple']
Usability," ; void setAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setDataToken (std::size_t index);  Sets the token for retrieving results in the BatchMode. For internal use only. ;  ; void setLocalNoDirtyInhibit (bool flag) const;  ; void SetName (const char *name) override;  Set the name of the TNamed. ;  ; void SetNameTitle (const char *name, const char *title) override;  Set all the TNamed parameters (name and title). ;  ; void setProhibitServerRedirect (bool flag);  ; void setStringAttribute (const Text_t *key, const Text_t *value);  Associate string 'value' to this object under key 'key'. ;  ; void setTransientAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setWorkspace (RooWorkspace &ws);  ; const std::map< std::string, std::string > & stringAttributes () const;  ; const std::set< std::string > & transientAttributes () const;  ; virtual void translate (RooFit::Detail::CodeSquashContext &ctx) const;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ; RooWorkspace * workspace () const;  ; virtual void writeToStream (std::ostream &os, bool compact) const =0;  ; Client-Server Interface; These functions allow RooFit to figure out who is serving values to whom. . const RefCountList_t & clients () const;  List of all clients of this object. ;  ; const RefCountList_t & valueClients () const;  List of all value clients of this object. Value clients receive value updates. ;  ; const RefCountList_t & shapeClients () const;  List of all shape clients of this object. ;  ; const RefCountList_t & servers () const;  List of all servers of this object. ;  ; RooAbsArg * findServer (const char *name) const;  Return server of this with name name. Returns nullptr if not found. ;  ; RooAbsArg * findServer (const RooAbsArg &arg) const;  Return server of this ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:16198,simpl,simple,16198,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['simpl'],['simple']
Usability," ; y1, . Int_t ; x2, . Int_t ; y2 . ). protected . Ensures hidden surface removal. ; Definition at line 799 of file TSpectrum2Painter.cxx. ◆ EnvelopeBars(). void TSpectrum2Painter::EnvelopeBars ; (; Int_t ; x1, . Int_t ; y1, . Int_t ; x2, . Int_t ; y2 . ). protected . Ensures hidden surface removal for Bars, BarsX and BarsY display modes. ; Definition at line 912 of file TSpectrum2Painter.cxx. ◆ GetAngles(). void TSpectrum2Painter::GetAngles ; (; Int_t & ; alpha, . Int_t & ; beta, . Int_t & ; view . ). Gets angles of the view: . alpha - angle between base line of Canvas and right lower edge of picture base plane; beta - angle between base line of Canvas and left lower edge of picture base plane; view - rotation angle of the view, it can be 0, 90, 180, 270 degrees . Definition at line 7325 of file TSpectrum2Painter.cxx. ◆ GetBezier(). void TSpectrum2Painter::GetBezier ; (; Int_t & ; bezier). Gets Bezier smoothing switch: . bezier - determines Bezier interpolation (applies only for simple display modes group for grid, x_lines, y_lines display modes) . Definition at line 7393 of file TSpectrum2Painter.cxx. ◆ GetChanGrid(). void TSpectrum2Painter::GetChanGrid ; (; Int_t & ; enable, . Int_t & ; color . ). This function gets attributes for drawing channel: . enable - decides whether the channel grid is shown or not; color - color of channel grid . Definition at line 7439 of file TSpectrum2Painter.cxx. ◆ GetChanMarks(). void TSpectrum2Painter::GetChanMarks ; (; Int_t & ; enable, . Int_t & ; color, . Int_t & ; width, . Int_t & ; height, . Int_t & ; style . ). Gets drawing attributes for channel marks: . enable - decides whether the channel marks are shown or not; color - color of channel marks; width - width of channel marks in pixels; height - height of channel marks in pixels; style - style of channel marks (dot, cross, star, rectangle, X, diamond, triangle) . Definition at line 7427 of file TSpectrum2Painter.cxx. ◆ GetColorAlgorithm(). void TSpectrum2Painter::GetColorAlg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Painter.html:26361,simpl,simple,26361,doc/master/classTSpectrum2Painter.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Painter.html,1,['simpl'],['simple']
Usability," ;  TMVAClassificationApplication.C;   This macro provides a simple example on how to use the trained classifiers within an analysis module ;  ;  TMVAClassificationCategory.C;   This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode. ;  ;  TMVAClassificationCategoryApplication.C;   This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  ;  TMVACrossValidation.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation. ;  ;  TMVACrossValidationApplication.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation in application. ;  ;  TMVACrossValidationRegression.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation. ;  ;  TMVAGAexample.C;   This executable gives an example of a very simple use of the genetic algorithm of TMVA ;  ;  TMVAGAexample2.C;   This executable gives an example of a very simple use of the genetic algorithm of TMVA. ;  ;  TMVAMinimalClassification.C;   Minimal self-contained example for setting up TMVA with binary classification. ;  ;  TMVAMulticlass.C;   This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  ;  TMVAMulticlassApplication.C;   This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  ;  TMVAMultipleBackgroundExample.C;   This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algorithm. ;  ;  TMVARegression.C;   This macro provides examples for the training and testing of the TMVA classifiers. ;  ;  TMVARegressionApplication.C;   This macro provides a simple example on",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:6073,simpl,simple,6073,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,1,['simpl'],['simple']
Usability," CAlgebraicProdType< sym, gen >;  CAlgebraicProdType< sym, sym >;  CAlgebraicProdType< sym, vec >;  CAlgebraicProdType< T, T >;  CAlgebraicProdType< vec, gen >;  CAlgebraicProdType< vec, sym >;  CAlgebraicSumType;  CAlgebraicSumType< gen, vec >;  CAlgebraicSumType< sym, vec >;  CAlgebraicSumType< T, T >;  CAlgebraicSumType< vec, gen >;  CAlgebraicSumType< vec, sym >;  CAnalyticalGradientCalculator;  CBasicFunctionGradient;  ►CBasicFunctionMinimumResult of the minimization; both internal and external (MnUserParameterState) representation available For the parameters at the Minimum ;  CMnAboveMaxEdm;  CMnReachedCallLimit;  ►CBasicMinimumErrorInternal Class containing the error information on the estimated minimum : Error matrix + dcovar + additional flags for quality and validity checks ;  CMnHesseFailed;  CMnInvertFailed;  CMnMadePosDef;  CMnNotPosDef;  CBasicMinimumParameters;  CBasicMinimumSeed;  CBasicMinimumState;  CCombinedMinimizerCombined minimizer: combination of Migrad and Simplex ;  CCombinedMinimumBuilder;  CContoursError;  CDavidonErrorUpdatorUpdate of the covariance matrix for the Variable Metric minimizer (MIGRAD) ;  CFCNAdapterTemplate wrapped class for adapting to FCNBase signature ;  CFCNBaseInterface (abstract class) defining the function to be minimized, which has to be implemented by the user ;  CFCNGradAdapterTemplate wrapped class for adapting to FCNBase signature a IGradFunction ;  CFCNGradientBaseExtension of the FCNBase for providing the analytical Gradient of the function ;  CFlatRandomGen;  CFumiliBuilderBuilds the FunctionMinimum using the Fumili method ;  CFumiliChi2FCNExtension of the FCNBase for the Fumili method ;  CFumiliErrorUpdatorIn the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives ;  CFumiliFCNAdapterTemplate wrapped class for adapting to FumiliFCNBase signature ;  CFumiliFC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:50428,Simpl,Simplex,50428,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['Simpl'],['Simplex']
Usability," CTMPClientBase class for multiprocess applications' clients ;  CTMPWorkerThis class works in conjuction with TMPClient, reacting to messages received from it as specified by the Notify and HandleInput methods ;  CTMrbSubevent_Caen;  CTMultiDimFitMultidimensional Fits in ROOT ;  CTMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects ;  CTMultiLayerPerceptron;  CTMutex;  CTMutexImp;  CTMySQLResult;  CTMySQLRow;  CTMySQLServer;  ►CTMySQLStatement;  CTParamData;  CTNamedBase class for all named ROOT classes ;  CTNDArray;  CTNDArrayRef;  CTNDArrayT;  CTNetFile;  CTNetFileStager;  CTNetSystem;  CTNetXNGFile;  CTNetXNGFileStager;  CTNetXNGSystem;  CTNeuron;  CTNewChainDlg;  CTNewQueryDlg;  CTNodeTNode description ;  CTNodeDivDescription of parameters to divide a 3-D geometry object ;  CTNonCopyable;  CTNonSplitBrowsableAllows a TBrowser to browse non-split branches as if they were split ;  CTNtupleA simple TTree restricted to a list of float variables only ;  CTNtupleDA simple TTree restricted to a list of double variables only ;  CTObjArrayAn array of TObjects ;  CTObjArrayIterIterator of object array ;  CTObjectMother of all ROOT objects ;  CTObjectRefSpy;  CTObjectSet;  CTObjectSpyMonitors objects for deletion and reflects the deletion by reverting the internal pointer to zero ;  CTObjectTableThis class registers all instances of TObject and its derived classes in a hash table ;  CTObjLinkWrapper around a TObject so it can be stored in a TList ;  CTObjOptLink;  CTObjStringCollectable string class ;  CTOCCToStep;  CTODBCResult;  CTODBCRow;  CTODBCServer;  ►CTODBCStatement;  CODBCBufferRec_t;  CToolBarData_t;  CTOptionListItem;  CTOracleResult;  CTOracleRow;  CTOracleServer;  ►CTOracleStatement;  CTBufferRec;  CTOrdCollectionOrdered collection ;  CTOrdCollectionIterIterator of ordered collection ;  CTOutputListSelectorDataMapSet the selector's data members to the corresponding elements of the output list ;  CTPackageDescription;  CTPacketizerThis class g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:171932,simpl,simple,171932,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['simpl'],['simple']
Usability," CTPointsArray3D;  CTPointSet3DTPolyMarker3D using TPointSet3DGL for direct OpenGL rendering ;  CTPointSet3DGLDirect OpenGL renderer for TPointSet3D ;  CTPolyLineDefined by an array on N points in a 2-D space ;  CTPolyLine3DA 3-dimensional polyline ;  CTPolyLineShape;  CTPolyMarkerA PolyMarker is defined by an array on N points in a 2-D space ;  CTPolyMarker3DA 3D polymarker ;  CTPoolProcessor;  CTPoolWorkerThis class works together with TProcPool to allow the execution of functions in server processes ;  CTPoolWorker< F, T, void >;  CTPoolWorker< F, void, R >;  CTPosixCondition;  CTPosixMutex;  CTPosixThread;  CTPosixThreadCleanUp;  CTPosixThreadFactory;  CTPostScriptInterface to PostScript ;  CTPRegexp;  CTPrimary;  CTPrincipalPrincipal Components Analysis (PCA) ;  CTProcessEventTimer;  CTProcessIDA TProcessID identifies a ROOT job in a unique way in time and space ;  CTProcessUUIDThis class is a specialized TProcessID managing the list of UUIDs ;  CTProcPoolThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTProfileProfile Historam ;  CTProfile2DProfile2D histograms are used to display the mean value of Z and its RMS for each cell in X,Y ;  CTProfile3DProfile3D histograms are used to display the mean value of T and its RMS for each cell in X,Y,Z ;  CTProfileHelper;  ►CTProof;  CMD5Mod_t;  CTProofBench;  CTProofBenchDataSet;  CTProofBenchRun;  CTProofBenchRunCPU;  CTProofBenchRunDataRead;  CTProofChain;  CTProofCondor;  CTProofDebug;  CTProofDesc;  CTProofDraw;  CTProofDrawEntryList;  CTProofDrawEventList;  CTProofDrawGraph;  CTProofDrawHist;  ►CTProofDrawListOfGraphs;  CPoint3D_t;  ►CTProofDrawListOfPolyMarkers3D;  CPoint4D_t;  CTProofDrawPolyMarker3D;  CTProofDrawProfile;  CTProofDrawProfile2D;  CTProofInputHandler;  CTProofInterruptHandler;  CTProofLimitsFinder;  CTProofLite;  CTProofLockPath;  CTProofLockPathGuard;  CTProofLog;  CTProofLogElem;  CTProofMergePrg;  CTProofMg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:148283,simpl,simple,148283,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,2,['simpl'],['simple']
Usability," Default rotation constructor with Euler angles. ;  ;  TGeoRotation (const char *name, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3);  Rotation constructor a la GEANT3. ;  ;  TGeoRotation (const TGeoMatrix &other);  Copy ctor. ;  ;  TGeoRotation (const TGeoRotation &other);  Copy ctor. ;  ;  ~TGeoRotation () override;  ; void Clear (Option_t *option="""") override;  reset data members ;  ; Double_t Determinant () const;  computes determinant of the rotation matrix ;  ; void FastRotZ (const Double_t *sincos);  Perform a rotation about Z having the sine/cosine of the rotation angle. ;  ; void GetAngles (Double_t &phi, Double_t &theta, Double_t &psi) const;  Retrieve Euler angles. ;  ; void GetAngles (Double_t &theta1, Double_t &phi1, Double_t &theta2, Double_t &phi2, Double_t &theta3, Double_t &phi3) const;  Retrieve rotation angles. ;  ; void GetInverse (Double_t *invmat) const;  Get the inverse rotation matrix (which is simply the transpose) ;  ; Double_t GetPhiRotation (Bool_t fixX=kFALSE) const;  Returns rotation angle about Z axis in degrees. ;  ; const Double_t * GetRotationMatrix () const override;  ; const Double_t * GetScale () const override;  ; const Double_t * GetTranslation () const override;  ; TGeoHMatrix Inverse () const override;  Return a temporary inverse of this. ;  ; TClass * IsA () const override;  ; Bool_t IsValid () const;  Perform orthogonality test for rotation. ;  ; void LocalToMaster (const Double_t *local, Double_t *master) const override;  convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse ;  ; void LocalToMasterBomb (const Double_t *local, Double_t *master) const override;  convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse ;  ; void LocalToMasterVect (const Double_t *local, Double_t *master) const override;  convert a vector by multiplying its column vector (x, y, z, 1) to matrix inverse ;  ; TGeoMatrix * MakeClone () const override",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoRotation.html:1701,simpl,simply,1701,doc/master/classTGeoRotation.html,https://root.cern,https://root.cern/doc/master/classTGeoRotation.html,1,['simpl'],['simply']
Usability," GetMinimum(). Int_t TLeafG::GetMinimum ; (; ); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 45 of file TLeafG.h. ◆ GetTypeName(). const char * TLeafG::GetTypeName ; (; ); const. overridevirtual . Returns name of leaf type. ; Reimplemented from TLeaf.; Definition at line 96 of file TLeafG.cxx. ◆ GetValue(). Double_t TLeafG::GetValue ; (; Int_t ; i = 0); const. overridevirtual . Returns current value of leaf. . if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned . Reimplemented from TLeaf.; Definition at line 107 of file TLeafG.cxx. ◆ GetValueLong64(). Long64_t TLeafG::GetValueLong64 ; (; Int_t ; i = 0); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 66 of file TLeafG.h. ◆ GetValueLongDouble(). LongDouble_t TLeafG::GetValueLongDouble ; (; Int_t ; i = 0); const. overridevirtual . Returns current value of leaf. . if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned . Reimplemented from TLeaf.; Definition at line 118 of file TLeafG.cxx. ◆ GetValuePointer(). void * TLeafG::GetValuePointer ; (; ); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 49 of file TLeafG.h. ◆ Import(). void TLeafG::Import ; (; TClonesArray * ; list, . Int_t ; n . ). overridevirtual . Import element from ClonesArray into local leaf buffer. ; Reimplemented from TLeaf.; Definition at line 143 of file TLeafG.cxx. ◆ IncludeRange(). bool TLeafG::IncludeRange ; (; TLeaf * ; input). overridevirtual . Copy/set fMinimum and fMaximum to include/be wide than those of the parameter. ; Reimplemented from TLeaf.; Definition at line 127 of file TLeafG.cxx. ◆ IsA(). TClass * TLeafG::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TLeaf.; Definition at line 61 of file TLeafG.h. ◆ PrintValue(). void TLeafG::PrintValue ; (; Int_t ; i = 0); const. overridev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafG.html:19741,simpl,simple,19741,doc/master/classTLeafG.html,https://root.cern,https://root.cern/doc/master/classTLeafG.html,1,['simpl'],['simple']
Usability," GetMinimum(). Int_t TLeafL::GetMinimum ; (; ); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 45 of file TLeafL.h. ◆ GetTypeName(). const char * TLeafL::GetTypeName ; (; ); const. overridevirtual . Returns name of leaf type. ; Reimplemented from TLeaf.; Definition at line 96 of file TLeafL.cxx. ◆ GetValue(). Double_t TLeafL::GetValue ; (; Int_t ; i = 0); const. overridevirtual . Returns current value of leaf. . if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned . Reimplemented from TLeaf.; Definition at line 107 of file TLeafL.cxx. ◆ GetValueLong64(). Long64_t TLeafL::GetValueLong64 ; (; Int_t ; i = 0); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 66 of file TLeafL.h. ◆ GetValueLongDouble(). LongDouble_t TLeafL::GetValueLongDouble ; (; Int_t ; i = 0); const. overridevirtual . Returns current value of leaf. . if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned . Reimplemented from TLeaf.; Definition at line 118 of file TLeafL.cxx. ◆ GetValuePointer(). void * TLeafL::GetValuePointer ; (; ); const. inlineoverridevirtual . Reimplemented from TLeaf.; Definition at line 49 of file TLeafL.h. ◆ Import(). void TLeafL::Import ; (; TClonesArray * ; list, . Int_t ; n . ). overridevirtual . Import element from ClonesArray into local leaf buffer. ; Reimplemented from TLeaf.; Definition at line 143 of file TLeafL.cxx. ◆ IncludeRange(). bool TLeafL::IncludeRange ; (; TLeaf * ; input). overridevirtual . Copy/set fMinimum and fMaximum to include/be wide than those of the parameter. ; Reimplemented from TLeaf.; Definition at line 127 of file TLeafL.cxx. ◆ IsA(). TClass * TLeafL::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TLeaf.; Definition at line 61 of file TLeafL.h. ◆ PrintValue(). void TLeafL::PrintValue ; (; Int_t ; i = 0); const. overridev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafL.html:19753,simpl,simple,19753,doc/master/classTLeafL.html,https://root.cern,https://root.cern/doc/master/classTLeafL.html,1,['simpl'],['simple']
Usability," Histograms tutorialsExamples showing the ""histograms' classes"" usage. ;  HTTP tutorialsExamples showing the HTTP interface ;  Image tutorialsExamples showing the TImage class usage ;  IO tutorialsThese tutorials illustrate some of the capabilities of the ROOT IO subsystem ;  ►Math tutorialsExamples showing the Math classes ;  ►TUnfold tutorialsTest programs for the classes TUnfold and related ;  TUnfoldDensity and TUnfoldBinning test suiteThis is an example of unfolding a two-dimensional distribution ;  Matrix tutorialsExamples showing how to use TMatrix ;  Monte Carlo tutorialsMonte Carlo examples ;  TMemStat tutorialsExamples showing the TMemStat class ;  Multi Layer Perceptron tutorialsExamples showing the Multi Layer Perceptron classes ;  Multicore tutorialsThese examples aim to illustrate the multicore features of ROOT, such as thread awareness and safety, multithreading and multiprocessing ;  Net tutorialsExamples showing the net classes ;  Physics tutorialsPhysics examples ;  ►Proof tutorialsThese examples aim to illustrate the usage of PROOF ;  ProcFileElementsClass to hold information about the processed elements of a file ;  ProofAuxSelector used for auxiliary actions in the PROOF tutorials ;  ProofEventSelector for generic processing with Event ;  ProofEventProcSelector to process trees containing Event structures ;  ProofFriendsSelector to process tree friends ;  ProofNtupleSelector to fill a simple ntuple ;  ProofPythiaSelector to generate Monte Carlo events with Pythia8 ;  ProofSimpleSelector to fill a set of histograms ;  ProofSimpleFileSelector to fill a set of histograms and merging via file ;  ProofStdVecSelector for generic processing with stdlib collections ;  ProofTestsAuxilliary selector used to test PROOF functionality ;  PyRoot tutorialsExamples showing how to write python script for Root ;  Pythia tutorialsExamples showing the pythia usage ;  Quadratic programming package.Example showing the use of the quadratic programming package quadp ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/modules.html:11074,simpl,simple,11074,doc/v608/modules.html,https://root.cern,https://root.cern/doc/v608/modules.html,1,['simpl'],['simple']
Usability, MinimumParameters.h;  MinimumSeed.h;  MinimumSeedGenerator.h;  MinimumState.h;  MinosError.h;  Minuit2Minimizer.h;  MinuitParameter.h;  MnApplication.h;  MnConfig.h;  MnContours.h;  MnCovarianceSqueeze.h;  MnCross.h;  MnEigen.h;  MnFcn.h;  MnFumiliMinimize.h;  MnFunctionCross.h;  MnGlobalCorrelationCoeff.h;  MnHesse.h;  MnLineSearch.h;  MnMachinePrecision.h;  MnMatrix.h;  MnMigrad.h;  MnMinimize.h;  MnMinos.h;  MnParabola.h;  MnParabolaFactory.h;  MnParabolaPoint.h;  MnParameterScan.h;  MnPlot.h;  MnPosDef.h;  MnPrint.h;  MnRefCountedPointer.h;  MnReferenceCounter.h;  MnScan.h;  MnSeedGenerator.h;  MnSimplex.h;  MnStrategy.h;  MnTiny.h;  MnTraceObject.h;  MnUserCovariance.h;  MnUserFcn.h;  MnUserParameters.h;  MnUserParameterState.h;  MnUserTransformation.h;  MnVectorTransform.h;  ModularFunctionMinimizer.h;  MPIProcess.h;  NegativeG2LineSearch.h;  Numerical2PGradientCalculator.h;  ParametricFunction.h;  ScanBuilder.h;  ScanMinimizer.h;  SimplexBuilder.h;  SimplexMinimizer.h;  SimplexParameters.h;  SimplexSeedGenerator.h;  SinParameterTransformation.h;  SqrtLowParameterTransformation.h;  SqrtUpParameterTransformation.h;  StackAllocator.h;  VariableMetricBuilder.h;  VariableMetricEDMEstimator.h;  VariableMetricMinimizer.h;  VectorOuterProduct.h;  LinkDef.h;  TMinuit2TraceObject.h;  ► src;  AnalyticalGradientCalculator.cxx;  BasicMinimumError.cxx;  CombinedMinimumBuilder.cxx;  DavidonErrorUpdator.cxx;  FitterUtil.h;  FumiliBuilder.cxx;  FumiliErrorUpdator.cxx;  FumiliGradientCalculator.cxx;  FumiliMinimizer.cxx;  FumiliStandardChi2FCN.cxx;  FumiliStandardMaximumLikelihoodFCN.cxx;  HessianGradientCalculator.cxx;  InitialGradientCalculator.cxx;  LaEigenValues.cxx;  LaInnerProduct.cxx;  LaInverse.cxx;  LaOuterProduct.cxx;  LaSumOfElements.cxx;  LaVtMVSimilarity.cxx;  MinimumBuilder.cxx;  Minuit2Minimizer.cxx;  MnApplication.cxx;  mnbins.cxx;  MnContours.cxx;  MnCovarianceSqueeze.cxx;  mndasum.cxx;  mndaxpy.cxx;  mnddot.cxx;  mndscal.cxx;  mndspmv.cxx;  mndspr.cxx;  MnEi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:52539,Simpl,SimplexParameters,52539,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['Simpl'],['SimplexParameters']
Usability," ReadMap (int nElements, TBuffer &b, const TClass *onfileClass);  ; void ReadMapHelper (StreamHelper *i, Value *v, Bool_t vsn3, TBuffer &b);  ; void ReadObjects (int nElements, TBuffer &b, const TClass *onfileClass);  ; void ReadPairFromMap (int nElements, TBuffer &b);  ; void ReadPrimitives (int nElements, TBuffer &b, const TClass *onfileClass);  ; void WriteMap (int nElements, TBuffer &b);  ; void WriteObjects (int nElements, TBuffer &b);  ; void WritePrimitives (int nElements, TBuffer &b);  ;  Protected Member Functions inherited from TGenCollectionProxy; void CheckFunctions () const;  Check existence of function pointers. ;  ; virtual void DeleteItem (Bool_t force, void *ptr) const;  Call to delete/destruct individual item. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  . Protected Attributes; ReadBuffer_t fReadBufferFunc;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionStreamer.html:9916,clear,clear,9916,doc/master/classTGenCollectionStreamer.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionStreamer.html,1,['clear'],['clear']
Usability," SetFocus ();  Set focus to this text entry. ;  ; virtual void SetFont (const char *fontName, Bool_t local=kTRUE);  Changes text font specified by name. ;  ; virtual void SetFont (FontStruct_t font, Bool_t local=kTRUE);  Changes text font. ;  ; virtual void SetFont (TGFont *font, Bool_t local=kTRUE);  Changes text font specified by pointer to TGFont object. ;  ; void SetForegroundColor (Pixel_t fore) override;  ; virtual void SetFrameDrawn (Bool_t flag=kTRUE);  Sets the text entry to draw itself inside a two-pixel frame if enable is kTRUE, and to draw itself without any frame if enable is kFALSE. ;  ; virtual void SetInsertMode (EInsertMode mode=kInsert);  Sets the mode how characters are entered to the text entry. ;  ; virtual void SetMaxLength (Int_t maxlen);  Set the maximum length of the text in the editor. ;  ; virtual void SetState (Bool_t state);  Set state of widget. If kTRUE=enabled, kFALSE=disabled. ;  ; virtual void SetText (const char *text, Bool_t emit=kTRUE);  Sets text entry to text, clears the selection and moves the cursor to the end of the line. ;  ; virtual void SetTextColor (Pixel_t color, Bool_t local=kTRUE);  Changes text color. ;  ; virtual void SetTextColor (TColor *color, Bool_t local=kTRUE);  Changes text color. ;  ; virtual void SetTitle (const char *label);  ; virtual void SetToolTipText (const char *text, Long_t delayms=500);  Set tool tip text associated with this text entry. ;  ; virtual void ShiftTabPressed ();  This signal is emitted when SHIFT and TAB keys are pressed. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void TabPressed ();  This signal is emitted when the <TAB> key is pressed. ;  ; virtual void TextChanged (const char *text=nullptr);  This signal is emitted every time the text has changed. ;  ;  Public Member Functions inherited from TGFrame;  TGFrame (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, UInt_t option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEntry.html:12471,clear,clears,12471,doc/master/classTGTextEntry.html,https://root.cern,https://root.cern/doc/master/classTGTextEntry.html,1,['clear'],['clears']
Usability," TDrawFeedback(). TDrawFeedback::TDrawFeedback ; (; TProof * ; proof = 0, . TSeqCollection * ; names = 0 . ). Constructor. ; Definition at line 41 of file TDrawFeedback.cxx. ◆ ~TDrawFeedback(). TDrawFeedback::~TDrawFeedback ; (; ). override . Destructor. ; Definition at line 80 of file TDrawFeedback.cxx. Member Function Documentation. ◆ Class(). static TClass * TDrawFeedback::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDrawFeedback::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDrawFeedback::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 54 of file TDrawFeedback.h. ◆ DeclFileName(). static const char * TDrawFeedback::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 54 of file TDrawFeedback.h. ◆ Feedback(). void TDrawFeedback::Feedback ; (; TList * ; objs). Display feedback. ; Definition at line 93 of file TDrawFeedback.cxx. ◆ GetName(). const char * TDrawFeedback::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 50 of file TDrawFeedback.h. ◆ Hash(). ULong_t TDrawFeedback::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDrawFeedback.html:16129,feedback,feedback,16129,doc/master/classTDrawFeedback.html,https://root.cern,https://root.cern/doc/master/classTDrawFeedback.html,1,['feedback'],['feedback']
Usability," The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this function to declare a function obsolete. ;  ; ErrorHandlerFunc_t SetErrorHandler (ErrorHandlerFunc_t newhandler);  Set an errorhandler function. Returns the old handler. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::SetErrorSystemMsgHandler (ErrorSystemMsgHandlerFunc_t h);  Returns the previous system error message handler. ;  ; void SysError (const char *location, const char *msgfmt,...);  Use this function in case a system (OS or GUI) related error occurred. ;  ; void Warning (const char *location, const char *msgfmt,...);  Use this function in warning situations. ;  . Variables; Int_t gErrorAbortLevel;  ; Int_t gErrorIgnoreLevel;  Error handling routines. ;  ; Bool_t gPrintViaErrorHandler;  ; const char * kAssertMsg;  ; constexpr Int_t kBreak = 4000;  ; const char * kCheckMs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8h.html:2553,simpl,simple,2553,doc/master/TError_8h.html,https://root.cern,https://root.cern/doc/master/TError_8h.html,1,['simpl'],['simple']
Usability," createProjection (const RooArgSet &iset) override;  Special version of RooAbsReal::createProjection that deals with projections of projections. ;  ; double expectedEvents (const RooArgSet *nset) const override;  Return expected number of events to be used in calculation of extended likelihood. ;  ; ExtendMode extendMode () const override;  Returns ability of PDF to provide extended likelihood terms. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force RooRealIntegral to relegate integration of all observables to internal logic. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Mark all requested variables as internally integrated. ;  ; void initGenerator (Int_t) override;  Interface for one-time initialization to setup the generator for the specified code. ;  ; TClass * IsA () const override;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the integration operation. ;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;  ; virtual Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProjectedPdf.html:2951,intuit,intuitively,2951,doc/master/classRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classRooProjectedPdf.html,1,['intuit'],['intuitively']
Usability," exec_macro.CThis utility macro executes the macro ""macro"" given as first argument and save a capture in a png file ;  games.CThis macro runs three ""games"" that each nicely illustrate the graphics capabilities of ROOT ;  gtreeTableTest.CThis TableTest class is a simple example of how to use a TGTreeTable ;  guilabels.CThis macro gives an example of how to create different kind of labels and the possibility to enable/disable them ;  guitest.CTest program for ROOT native GUI classes Exactly like $ROOTSYS/test/guitest.cxx but using the new signal and slots communication mechanism ;  guitest_playback.CThis macro plays a recorded ROOT session showing how to perform various interactive GUI operations with the guitest.C macro While replaying the session, several temporary macros (guitest0xx.C) macros will be saved ;  guiWithCINT.CA simple example of entering CINT commands and having the CINT output in a ROOT GUI application window ;  iconAsXPMData.CA simple example of creating icon image from XPM data, included into the code ;  listBox.CThis macro gives an example of how to create a list box and how to set and use its multiple selection feature ;  mditest.CGUI MDI features ;  ntupleTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  numberEntry.CThis macro gives an example of how to create a number entry and how to update a label according to the changed value of this number entry ;  QtFileDialog.CThis is a small ROOT macro to use Qt 3.3 class: QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileName ;  QtMultiFileDialog.CThis is a small ROOT macro to use Qt 3.3 class :QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileNames ;  QtPrintDialog.CThis is a small ROOT macro to use Qt 3.3 class: QPrinter to setup the printer via Qt ""setup printer dialog"" See: Printer setup dialog box and print out the ROOT TCanvas object either via the ""can"" pointer provided or the current one ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:119410,simpl,simple,119410,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['simpl'],['simple']
Usability," fIntHandler;  ; TString fLogFilePath;  ; TMonitor * fMonitor;  ; TString fName;  ; Int_t fProtocol;  ; TObject * fReceivedObject;  ; TSeqCollection * fRootFiles;  ; TSocket * fSocket;  ; TUrl fUrl;  ; TRemoteObject * fWorkingDir;  . Static Private Attributes; static Int_t fgPortAttempts = 100;  ; static Int_t fgPortLower = 49152;  ; static Int_t fgPortUpper = 65535;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TApplication;  TApplication ();  Default ctor. Can be used by classes deriving from TApplication. ;  ; virtual void Forum (const char *line);  The function ("".forum <type>"") submits a new post on the ROOT forum via web browser. ;  ; virtual void GitHub (const char *line);  The function ("".gh <type>"") submits a new issue on GitHub via web browser. ;  ; virtual void Help (const char *line);  The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxygen ("".help scope"" or "".help scope::member""). ;  ; virtual void LoadGraphicsLibs ();  Load shared libs necessary for graphics. ;  ; virtual void MakeBatch ();  Switch to batch mode. ;  ; virtual Longptr_t ProcessRemote (const char *line, Int_t *error=nullptr);  Process the content of a line starting with "".R"" (already stripped-off) The format is. ;  ; void SetSignalHandler (TSignalHandler *sh);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  ;  Static Protected Member Functions inherited from TApplication; static void Close (TApplication *app);  Static function used to close a remote application. ;  ; static TApplication * Open (const char *url, Int_t debug, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationRemote.html:20309,guid,guide,20309,doc/master/classTApplicationRemote.html,https://root.cern,https://root.cern/doc/master/classTApplicationRemote.html,1,['guid'],['guide']
Usability," fgShadowGC = nullptr;  ; static UInt_t fgUserColor = 0;  ; static const TGGC * fgWhiteGC = nullptr;  ; static Pixel_t fgWhitePixel = 0;  ;  Static Protected Attributes inherited from TGWindow; static Int_t fgCounter = 0;  counter of created windows in SavePrimitive ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TGInputDialog.h>. Inheritance diagram for TGInputDialog:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGInputDialog() [1/2]. TGInputDialog::TGInputDialog ; (; const TGInputDialog & ; ). privatedelete . ◆ TGInputDialog() [2/2]. TGInputDialog::TGInputDialog ; (; const TGWindow * ; p = nullptr, . const TGWindow * ; main = nullptr, . const char * ; prompt = nullptr, . const char * ; defval = nullptr, . char * ; retstr = nullptr, . UInt_t ; options = kVerticalFrame . ). Create simple input dialog. ; It is important to know that the case where the constructor in which all the variables are initialized to their default values is only used for the TBrowser to inspect on the classes. For normal use the only variable that should be free is options.; Variables prompt, defval are the content of the input dialog while retstr has to be initialized to a char[256]. In case these are not initialized, they will show default values while retstr will be automatically allocated by the dialog. However this will make impossible to retrieve the value entered by the dialog.; To see TGInputDialog in use see: $ROOTSYS/tutorials/testInputDialog.cxx ; Definition at line 48 of file TGInputDialog.cxx. ◆ ~TGInputDialog(). TGInputDialog::~TGInputDialog ; (; ). override . Cleanup dialog. ; Definition at line 134 of file TGInputDialog.cxx. Member Function Documentation. ◆ Class(). static TClass * TGInputDialog::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGInputDialog.html:37216,simpl,simple,37216,doc/master/classTGInputDialog.html,https://root.cern,https://root.cern/doc/master/classTGInputDialog.html,1,['simpl'],['simple']
Usability, sqlcanvas.CThis is slight modification of ntuple1.C example ;  sqlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlselect.C;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example explains how to use the cross-validation feature of TMVA ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:153090,simpl,simple,153090,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,2,['simpl'],['simple']
Usability," stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example explains how to use the cross-validation feature of TMVA ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algrorithm ;  TMVA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:153371,simpl,simple,153371,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,2,['simpl'],['simple']
Usability," this is a stack variable. The value of the pointer is set equal to; new Quad(1.,2.,-3.);; new, despite its looks, is an operator and creates an object or variable of the type that comes next, Quad in this case, on the heap. Just as with stack objects it has to be initialized by calling its constructor. The syntax requires that the argument list follows the type. This one statement has brought two items into existence, one on the heap and one on the stack. The heap object will live until the delete operator is applied to it.; There is no FORTRAN parallel to a heap object; variables either come or go as control passes in and out of a function or subroutine, or, like a COMMON block variables, live for the lifetime of the program. However, most people in HEP who use FORTRAN will have experience of a memory manager and the act of creating a bank is a good equivalent of a heap object. For those who know systems like ZEBRA, it will come as a relief to learn that objects do not move, C++ does not garbage collect, so there is never a danger that a pointer to an object becomes invalid for that reason. However, having created an object, it is the user’s responsibility to ensure that it is deleted when no longer needed, or to pass that responsibility onto to some other object. Failing to do that will result in a memory leak, one of the most common and most hard-to-find C++ bugs.; To send a message to an object via a pointer to it, you need to use the “->” operator e.g.:; root[] my_objptr->Solve();; Although we chose to call our pointer my_objptr, to emphasize that it is a pointer, heap objects are so common in an object-oriented program that pointer names rarely reflect the fact - you have to be careful that you know if you are dealing with an object or its pointer! Fortunately, the compiler won’t tolerate an attempt to do something like:; root[] my_objptr.Solve();; As we have seen, heap objects have to be accessed via pointers, whereas stack objects can be accessed directly. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:251469,learn,learn,251469,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['learn'],['learn']
Usability,"» TFitterFumili. class TFitterFumili: public TFitterMinuit. Function Members (Methods); public:. TFitterFumili(); TFitterFumili(Int_t maxpar); TFitterFumili(const TFitterFumili&); virtual~TFitterFumili(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTFitterMinuit::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tTFitterMinuit::ExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidTFitterMinuit::FixParameter(Int_t ipar); virtual voidTVirtualFitter::GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); virtual voidTVirtualFitter::GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFitterFumili.html:742,Clear,Clear,742,root/html532/TFitterFumili.html,https://root.cern,https://root.cern/root/html532/TFitterFumili.html,2,['Clear'],['Clear']
Usability,←. RooDataProjBinding. RooRealAnalytic. RooRealIntegral. RooRealMPFE. RooRealProxy. RooRealSumPdf. RooRealVar. RooRealVarSharedProperties. RooRecursiveFraction. RooRefArray. RooRefCountList. RooResolutionModel←. RooAddModel. RooGExpModel. RooGaussModel. RooTruthModel. RooScaledFunc. RooSecondMoment. RooSegmentedIntegrator1D←. RooSegmentedIntegrator2D. RooSegmentedIntegrator2D. RooSetPair. RooSetProxy. RooSharedProperties←. RooCategorySharedProperties. RooRealVarSharedProperties. RooSharedPropertiesList. RooSimGenContext. RooSimPdfBuilder. RooSimSplitGenContext. RooSimWSTool. RooSimWSTool::MultiBuildConfig. RooSimWSTool::SplitRule. RooSimultaneous←. RooStats::HistFactory::HistFactorySimultaneous. RooSpHarmonic. RooStats::AcceptanceRegion. RooStats::AsymptoticCalculator. RooStats::BayesianCalculator. RooStats::CombinedCalculator←. RooStats::ProfileLikelihoodCalculator. RooStats::ConfInterval←. RooStats::LikelihoodInterval. RooStats::MCMCInterval. RooStats::PointSetInterval. RooStats::SimpleInterval; ←. RooStats::HypoTestInverterResult. RooStats::ConfidenceBelt. RooStats::DebuggingSampler. RooStats::DebuggingTestStat. RooStats::FeldmanCousins. RooStats::FrequentistCalculator. RooStats::HLFactory. RooStats::Heaviside. RooStats::HistFactory::EstimateSummary. RooStats::HistFactory::FlexibleInterpVar. RooStats::HistFactory::HistFactorySimultaneous. RooStats::HistFactory::HistoToWorkspaceFactory. RooStats::HistFactory::HistoToWorkspaceFactoryFast. RooStats::HistFactory::LinInterpVar. RooStats::HistFactory::Measurement. RooStats::HistFactory::RooBarlowBeestonLL. RooStats::HybridCalculator. RooStats::HybridCalculatorOriginal. RooStats::HybridPlot. RooStats::HybridResult. RooStats::HypoTestCalculatorGeneric←. RooStats::AsymptoticCalculator. RooStats::FrequentistCalculator. RooStats::HybridCalculator. RooStats::HypoTestInverter. RooStats::HypoTestInverterOriginal. RooStats::HypoTestInverterPlot. RooStats::HypoTestInverterResult. RooStats::HypoTestPlot. RooStats::HypoTestResult←.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassHierarchy.html:25176,Simpl,SimpleInterval,25176,root/html534/ClassHierarchy.html,https://root.cern,https://root.cern/root/html534/ClassHierarchy.html,3,['Simpl'],['SimpleInterval']
Usability,◆ DeclFileName(). static const char * TGDockableFrame::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 139 of file TGDockableFrame.h. ◆ DockContainer(). void TGDockableFrame::DockContainer ; (; Int_t ; del = kTRUE). Dock container back to TGDockableFrame. ; Definition at line 325 of file TGDockableFrame.cxx. ◆ Docked(). virtual void TGDockableFrame::Docked ; (; ). inlinevirtual . Definition at line 112 of file TGDockableFrame.h. ◆ EnableHide() [1/2]. Bool_t TGDockableFrame::EnableHide ; (; ); const. inline . Definition at line 124 of file TGDockableFrame.h. ◆ EnableHide() [2/2]. void TGDockableFrame::EnableHide ; (; Bool_t ; onoff). Enable hiding. ; Definition at line 432 of file TGDockableFrame.cxx. ◆ EnableUndock() [1/2]. Bool_t TGDockableFrame::EnableUndock ; (; ); const. inline . Definition at line 122 of file TGDockableFrame.h. ◆ EnableUndock() [2/2]. void TGDockableFrame::EnableUndock ; (; Bool_t ; onoff). Enable undocking. ; Definition at line 419 of file TGDockableFrame.cxx. ◆ GetContainer(). TGCompositeFrame * TGDockableFrame::GetContainer ; (; ); const. inline . Definition at line 134 of file TGDockableFrame.h. ◆ GetUndocked(). TGUndockedFrame * TGDockableFrame::GetUndocked ; (; ); const. inline . Definition at line 135 of file TGDockableFrame.h. ◆ HideContainer(). void TGDockableFrame::HideContainer ; (; ). Hide dock container. ; Definition at line 374 of file TGDockableFrame.cxx. ◆ IsA(). TClass * TGDockableFrame::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGCompositeFrame.; Definition at line 139 of file TGDockableFrame.h. ◆ IsFixedSize(). Bool_t TGDockableFrame::IsFixedSize ; (; ); const. inline . Definition at line 131 of file TGDockableFrame.h. ◆ IsHidden(). Bool_t TGDockableFrame::IsHidden ; (; ); const. inline . Definition at line 129 of file TGDockableFrame.h. ◆ IsUndocked(). Bool_t TGDockableFrame::IsUndocked ; (; ); cons,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDockableFrame.html:36160,undo,undocking,36160,doc/master/classTGDockableFrame.html,https://root.cern,https://root.cern/doc/master/classTGDockableFrame.html,1,['undo'],['undocking']
Usability,"◆ HasFitFunction(). TF1 * TFitEditor::HasFitFunction ; (; ). protected . Look in the list of function for TF1. ; If a TF1 is found in the list of functions, it will be returned ; Definition at line 3281 of file TFitEditor.cxx. ◆ Hide(). void TFitEditor::Hide ; (; ). virtual . Hide the fit panel and set it to non-active state. ; Definition at line 1207 of file TFitEditor.cxx. ◆ MakeTitle(). void TFitEditor::MakeTitle ; (; TGCompositeFrame * ; parent, . const char * ; title . ). protected . Create section title in the GUI. ; Definition at line 3266 of file TFitEditor.cxx. ◆ operator=(). TFitEditor & TFitEditor::operator= ; (; const TFitEditor & ; ). private . ◆ ProcessTreeInput(). void TFitEditor::ProcessTreeInput ; (; TObject * ; objSelected, . Int_t ; selected, . TString ; variables, . TString ; cuts . ). protected . Definition at line 2401 of file TFitEditor.cxx. ◆ RecursiveRemove(). void TFitEditor::RecursiveRemove ; (; TObject * ; obj). overridevirtual . When obj is deleted, clear fFitObject if fFitObject = obj. ; Reimplemented from TObject.; Definition at line 1571 of file TFitEditor.cxx. ◆ RetrieveOptions(). void TFitEditor::RetrieveOptions ; (; Foption_t & ; fitOpts, . TString & ; drawOpts, . ROOT::Math::MinimizerOptions & ; minOpts, . Int_t ;  . ). private . Retrieve the fitting options from all the widgets. ; Definition at line 3344 of file TFitEditor.cxx. ◆ SetCanvas(). void TFitEditor::SetCanvas ; (; TCanvas * ; c). protectedvirtual . Connect to another canvas. ; Definition at line 1185 of file TFitEditor.cxx. ◆ SetEditable(). void TFitEditor::SetEditable ; (; Bool_t ; state). overrideprotectedvirtual . Reimplemented from TGWindow.; Definition at line 3445 of file TFitEditor.cxx. ◆ SetFitObject(). void TFitEditor::SetFitObject ; (; TVirtualPad * ; pad, . TObject * ; obj, . Int_t ; event . ). virtual . Slot called when the user clicks on an object inside a canvas. ; Updates pointers to the parent pad and the selected object for fitting (if suitable). ; Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFitEditor.html:59522,clear,clear,59522,doc/master/classTFitEditor.html,https://root.cern,https://root.cern/doc/master/classTFitEditor.html,1,['clear'],['clear']
Usability,"◆ ReadSpecialObject(). TObject * TSQLFile::ReadSpecialObject ; (; Long64_t ; keyid, . TObject * ; obj = nullptr . ). protected . Read data of special kind of objects. ; Definition at line 851 of file TSQLFile.cxx. ◆ ReadSQLClassInfos(). void TSQLFile::ReadSQLClassInfos ; (; ). protected . Read all class infos from IdsTable. ; Definition at line 1911 of file TSQLFile.cxx. ◆ Recover(). Int_t TSQLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:85000,usab,usable,85000,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['usab'],['usable']
Usability,"◆ TQCommand() [1/3]. TQCommand::TQCommand ; (; const char * ; clname = nullptr, . void * ; obj = nullptr, . const char * ; redo = nullptr, . const char * ; undo = nullptr . ). Constructor. ; Input parameters:; clname - class name.; obj - an object; redo - method or function to do/redo operation; undo - method or function to undo operation. Comments:; if either clname or obj is NULL that means that redo/undo is function; to specify default arguments for redo/undo method/function '=' must precede to argument value. Example: TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");; undo method can be same as redo one. In that case undo parameter can be omitted.; Example: TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. Definition at line 168 of file TQCommand.cxx. ◆ TQCommand() [2/3]. TQCommand::TQCommand ; (; TObject * ; obj, . const char * ; redo = nullptr, . const char * ; undo = nullptr . ). Constructor. ; Input parameters:; obj - an object; redo - method or function to do/redo operation; undo - method or function to undo operation. Comments: to specify default arguments for redo/undo method/function '=' must precede to argument value.; Example: TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");; undo method can be same as redo one. In that case ""undo"" can parameter be omitted.; Example: TQCommand(gPad, ""SetFillStyle(Style_t)"");. Definition at line 199 of file TQCommand.cxx. ◆ TQCommand() [3/3]. TQCommand::TQCommand ; (; const TQCommand & ; com). Copy constructor. ; Definition at line 209 of file TQCommand.cxx. ◆ ~TQCommand(). TQCommand::~TQCommand ; (; ). virtual . dtor. ; Definition at line 249 of file TQCommand.cxx. Member Function Documentation. ◆ Add() [1/2]. void TQCommand::Add ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TList.; Reimplemented in TQUndoManager.; Definition at line 91 of file TQCommand.h. ◆ Add() [2/2]. void TQCommand::Add ; (; TObject * ; obj, . Option_t * ; opt . ). overridevirtual . Add comm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:32826,undo,undo,32826,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,2,['undo'],['undo']
Usability,"◆ begin(). const_iterator RooAbsCollection::begin ; (; ); const. inline . Definition at line 253 of file RooAbsCollection.h. ◆ canBeAdded(). virtual bool RooAbsCollection::canBeAdded ; (; const RooAbsArg & ; arg, . bool ; silent . ); const. protectedpure virtual . Determine whether it's possible to add a given RooAbsArg to the collection or not. ; Implemented in RooArgSet, and RooArgList. ◆ Class(). static TClass * RooAbsCollection::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCollection::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCollection::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 432 of file RooAbsCollection.h. ◆ clear(). void RooAbsCollection::clear ; (; ). inline . Clear contents. If the collection is owning, it will also delete the contents. ; Definition at line 282 of file RooAbsCollection.h. ◆ clearStructureTags(). void RooAbsCollection::clearStructureTags ; (; ). inlineprotected . Definition at line 392 of file RooAbsCollection.h. ◆ clone(). virtual TObject * RooAbsCollection::clone ; (; const char * ; newname); const. pure virtual . Implemented in RooArgList, and RooArgSet. ◆ Clone(). TObject * RooAbsCollection::Clone ; (; const char * ; newname = nullptr); const. inlineoverridevirtual . Make a clone of an object using the Streamer facility. ; If the object derives from TNamed, this function is called by TNamed::Clone. TNamed::Clone uses the optional argument to set a new name to the newly created object.; If the object class has a DirectoryAutoAdd function, it will be called at the end of the function with the parameter gDirectory. This usually means that the object will be appended to the current ROOT directory. ; Reimplemented from TObject.; Definition at line 76 of file RooAbsCollection.h. ◆ contains(). bool RooAbsCollection::contains ; (; const RooAbsArg & ; var); const. inlin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCollection.html:36131,clear,clearStructureTags,36131,doc/master/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/master/classRooAbsCollection.html,1,['clear'],['clearStructureTags']
